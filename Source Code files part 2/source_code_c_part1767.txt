   {
        memset(&lf,0,sizeof(lf));
        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
        lf.lfPitchAndFamily = DEFAULT_PITCH|FF_SWISS;
        LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_FULL], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );

        // Set charset
        if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo, TCI_SRCCODEPAGE) == 0)
        {
            csInfo.ciCharset = 0;
        }
        lf.lfCharSet = (BYTE)csInfo.ciCharset;

        // TODO:  If user has accesibility large fonts turned on then scale the font sizes.

        LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_FULL], szFontSize, ARRAYSIZE(szFontSize) );
        *(rgpcyFont[i]) = MulDiv((_ttoi(szFontSize)), GetDeviceCaps(hdc, LOGPIXELSY), 72);
        lf.lfHeight = -(*(rgpcyFont[i]));

        BOOL fFound = FALSE;
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FoundFont, (LPARAM)&fFound, 0);
        if (!fFound)
        {
            LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_BACKUP], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );
            LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_BACKUP], szFontSize, ARRAYSIZE(szFontSize) );
            *(rgpcyFont[i]) = MulDiv((_ttoi(szFontSize)), GetDeviceCaps(hdc, LOGPIXELSY), 72);
            lf.lfHeight = -(*(rgpcyFont[i]));
        }
        *(rgpFont[i]) = CreateFontIndirect(&lf);
    }

    return TRUE;
}

#define BITMAPTYPE_NORMAL           0x0
#define BITMAPTYPE_LOWCOLOR         0x1

BOOL CDlgApp::_CreateBitmaps()
{
    const int rgiBitmapID[2][2] = {{IDB_FLAG, IDB_FLAG_256}, {IDB_FLAG_RTL, IDB_FLAG_RTL_256}}; // [in]
    HDC* rgphdc[2] = {&m_hdcFlag, &m_hdcFlagRTL}; // [out]
    
    int iBitmapType = (m_fLowColor) ? BITMAPTYPE_LOWCOLOR : BITMAPTYPE_NORMAL;
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;

        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][iBitmapType]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
        GetObject(hbm,sizeof(bm),&bm);
        
        SelectObject( *(rgphdc[i]), hbm );
    }

    return TRUE;
}

BOOL CDlgApp::_CreateArrowBitmaps()
{
    const int rgiBitmapID[2][6][2] = 
    {{{IDB_BACK, IDB_BACK_HOVER},    
    {IDB_NEXT, IDB_NEXT_HOVER},
    {IDB_CLOSE, IDB_CLOSE_HOVER},
    {IDB_CANCEL, IDB_CANCEL_HOVER},
    {IDB_RADIO_ON, IDB_RADIO_ON_HOVER},
    {IDB_RADIO_OFF, IDB_RADIO_OFF_HOVER}},
    {{IDB_BACK_256, IDB_BACK_HOVER_256},    
    {IDB_NEXT_256, IDB_NEXT_HOVER_256},
    {IDB_CLOSE_256, IDB_CLOSE_HOVER_256},
    {IDB_CANCEL_256, IDB_CANCEL_HOVER_256},
    {IDB_RADIO_ON_256, IDB_RADIO_ON_HOVER_256},
    {IDB_RADIO_OFF_256, IDB_RADIO_OFF_HOVER_256}}}; // [in]
    
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {    
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {    
                HBITMAP hbm;
                BITMAP bm;
                m_rghdcArrows[i][j][k] = CreateCompatibleDC(NULL);

                hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][j][k]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
                GetObject(hbm,sizeof(bm),&bm);
        
                SelectObject( m_rghdcArrows[i][j][k], hbm );
            }
        }
    }
    return TRUE;
}

BOOL CDlgApp::_CreateGradientBitmaps()
{
    const int rgiBitmapID[4] = {IDB_GRADIENT_TOP, IDB_GRADIENT_TOP_256, IDB_GRADIENT_BOTTOM, IDB_GRADIENT_BOTTOM_256}; // [in]
    HDC* rgphdc[4] = {&m_hdcGradientTop, &m_hdcGradientTop256, &m_hdcGradientBottom, &m_hdcGradientBottom256}; // [out]    
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;
        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);

        GetObject(hbm,sizeof(bm),&bm);
    
        SelectObject( *(rgphdc[i]), hbm );
    }
    return TRUE;
}

UINT CDlgApp::_StringWidth(HDC hdc, UINT idString, INT iLogPixelSx)
{
    TCHAR szBuffer[256];
    SIZE size;
    LoadString(m_hInstance, idString, szBuffer, ARRAYSIZE(szBuffer));            
    GetTextExtentPoint32(hdc, szBuffer, lstrlen(szBuffer), &size);
    return (size.cx * iLogPixelSx) / 80;
}

UINT CDlgApp::_StringHeight(HDC hdc, UINT idString, INT iLogPixelSy)
{
    TCHAR szBuffer[256];
    SIZE size;
    LoadString(m_hInstance, idString, szBuffer, ARRAYSIZE(szBuffer));            
    GetTextExtentPoint32(hdc, szBuffer, lstrlen(szBuffer), &size);
    return (size.cy * iLogPixelSy) / 80;
}

BOOL CDlgApp::_AdjustIconPlacement()
{
    HDC hdc = GetDC(m_hwnd);
    UINT cx;
    if (hdc)
    {    
        UINT i;
        INT iLogPixelSx = GetDeviceCaps(hdc, LOGPIXELSX);

        cWidthIconText[0] = m_f8by6 ? 250 : 200;
        cWidthIconText[1] = m_f8by6 ? 250 : 200;

        cWidthIconText[2] = _StringWidth(hdc, IDS_MENULABEL1, iLogPixelSx); // BACK
        cWidthIconText[3] = _StringWidth(hdc, IDS_MENULABEL2, iLogPixelSx); // NEXT

        // iterate over CANCEL, FINISH
        cWidthIconText[4] = 0;
        for (i = IDS_MENULABEL0; i <= IDS_MENULABEL3; i += 3)
        {
            cx = _StringWidth(hdc, i, iLogPixelSx);
            if (cx > cWidthIconText[4])
            {
                cWidthIconText[4] = cx;
            }
        }         

        ReleaseDC(m_hwnd, hdc);
    
        cx = cWidthIconText[4];

        rgPtIconText[4].x = rgPtIcons[4].x -  cx - BUTTONTEXTGAP;       // cancel/finish text
        rgPtIconText640[4].x = rgPtIcons640[4].x - cx - BUTTONTEXTGAP; // cancel/finish text
        
        rgPtIcons[3].x = rgPtIconText[4].x - MENUICON_WIDTH - TRANSBUTTONGAP;       // next button
        rgPtIcons640[3].x = rgPtIconText640[4].x - MENUICON_WIDTH - TRANSBUTTONGAP; // next button

        cx = _StringWidth(hdc, IDS_MENULABEL2, iLogPixelSx);

        rgPtIconText[3].x = rgPtIcons[3].x - cx - BUTTONTEXTGAP;       // next text
        rgPtIconText640[3].x = rgPtIcons640[3].x - cx - BUTTONTEXTGAP; // next text

        rgPtIcons[2].x = rgPtIconText[3].x - MENUICON_WIDTH - TRANSBUTTONGAP;       // back button
        rgPtIcons640[2].x = rgPtIconText640[3].x - MENUICON_WIDTH - TRANSBUTTONGAP; // back button

        cx = _StringWidth(hdc, IDS_MENULABEL1, iLogPixelSx);

        rgPtIconText[2].x = rgPtIcons[2].x - cx - BUTTONTEXTGAP;       // back text
        rgPtIconText640[2].x = rgPtIcons640[2].x - cx - BUTTONTEXTGAP; // back text

    }
    return TRUE;
}

BOOL CDlgApp::_AdjustToFitFonts()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {    
        SetMapMode(hdc,MM_TEXT);
        INT iLogPixelSy = GetDeviceCaps(hdc, LOGPIXELSY);
        
        for (UINT i = 0; i < ARRAYSIZE(rgPtIcons); i++ )
        {
            UINT dex = rgdwMenuByPos[m_dwScreen][i];
            if (EMPTY != dex)
            {
                POINT pt = *((m_f8by6) ? &rgPtIconText[i] : &rgPtIconText640[i]);
                HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
                SetWindowPos(hwnd, NULL, pt.x, pt.y, cWidthIconText[i], (3 * _StringHeight(hdc, rgdwLabel[dex], iLogPixelSy)) / 2, SWP_NOZORDER );
            }
        }
        ReleaseDC(m_hwnd, hdc);
    }

    return TRUE;
}

#define BITMAPSTUFF(rgarrows) {phdcBitmap = (m_iSelectedItem == rgdwMenuByPos[m_dwScreen][i]) ? &(rgarrows[1]) : &(rgarrows[0]); }

BOOL CDlgApp::_DrawMenuIcons(BOOL fEraseBackground)
{
    RECT rect;
    UINT i;
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        HPALETTE hpalOld = NULL;

        if ( m_hpal )
        {
            hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            RealizePalette(hdc);
        }

        HDC* phdcBitmap;
        for (i=0; i < ARRAYSIZE(rgPtIcons); i++ )
        {
            switch (rgdwMenuByPos[m_dwScreen][i])
            {
            case EMPTY:
                continue;
            case BACK_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][0]);
                break;
            case NEXT_DEX:
            case LINK_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][1]);
                break;
            case FINISH_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][2]);
                break;
            case EXIT_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][3]);
                break;
            case RADIO_1_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][m_fDynamicUpdate ? 4 : 5]);
                break;
            case RADIO_0_DEX:
                BITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][m_fDynamicUpdate ? 5 : 4]);
                break;
            }
            rect.left = m_f8by6 ? rgPtIcons[i].x : rgPtIcons640[i].x;
            rect.top =  m_f8by6 ? rgPtIcons[i].y : rgPtIcons640[i].y;
            rect.right = rect.left + MENUICON_WIDTH; // arrow width
            rect.bottom = rect.top + MENUICON_HEIGHT; // arrow height as well
            BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, *phdcBitmap, 0,0, SRCCOPY );
        }

        if(hpalOld)
            SelectPalette(hdc, hpalOld, FALSE);

        ReleaseDC(m_hwnd, hdc);
    }

    return TRUE;
}

void CDlgApp::_InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear)
{
    RECT* pRectToUse = pRect; // default to normal case (don't flip)
    RECT rectRTL;
    if (pRect)
    {
        OSVERSIONINFO osvi;
        if (GetVersionEx(&osvi) && 
            (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            Mirror_IsWindowMirroredRTL(hwnd)) // right to left on Win9X
        {
            rectRTL.top = pRect->top; 
            rectRTL.bottom = pRect->bottom;
            rectRTL.right = m_cxClient - pRect->left;
            rectRTL.left = m_cxClient - pRect->right;
            pRectToUse = &rectRTL;
        }
    }
    InvalidateRect(hwnd, pRectToUse, fBackgroundClear);
}

/**
*  This method will create the application window.
*
*  @return         No return value.
*/
void CDlgApp::Create(int nCmdShow)
{
    //
    //  load the window title from the resource.
    //
    TCHAR szTitle[MAX_PATH];
    LoadStringAuto(m_hInstance, IDS_TITLEBAR, szTitle, MAX_PATH);

    
    DWORD dwStyle = WS_OVERLAPPED | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    if (m_f8by6)
    {
        m_cxClient = 800;
        m_cyClient = 600;
    }
    else
    {
        m_cxClient = 640;
        m_cyClient = 460;
    }

    m_hwnd = CreateWindowEx(
            WS_EX_CONTROLPARENT,
            WINDOW_CLASS,
            szTitle,
            dwStyle,
            0,
            0,
            m_cxClient,
            m_cyClient,
            NULL,
            NULL,
            m_hInstance,
            this);


    //  set the client area to a fixed size and center the window on screen
    RECT rect = {0};

    rect.left = (m_cDesktopWidth - m_cxClient) / 2;
    rect.top = (m_cDesktopHeight - m_cyClient) / 2;

    rect.right = m_cDesktopWidth - rect.left;
    rect.bottom = m_cDesktopHeight - rect.top;

    AdjustWindowRect( &rect, dwStyle, FALSE );
    
    SetWindowPos(m_hwnd, NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
    ShowWindow(m_hwnd, SW_SHOW);

    m_cxTopPanel = m_f8by6 ? 80 : 84;
    m_cyBottomPanel = m_f8by6 ? 501 : 391;

    _InvalidateRectIntl(m_hwnd, NULL, TRUE);
}

/**
*  This method is our application message loop.
*
*  @return         No return value.
*/
void CDlgApp::MessageLoop()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // IsDialogMessage cannot understand the concept of ownerdraw default pushbuttons.  It treats
        // these attributes as mutually exclusive.  As a result, we handle this ourselves.  We want
        // whatever control has focus to act as the default pushbutton.
        if ( (WM_KEYDOWN == msg.message) && (VK_RETURN == msg.wParam) )
        {
            HWND hwndFocus = GetFocus();
            if ( hwndFocus )
            {
                SendMessage(m_hwnd, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndFocus), BN_CLICKED), (LPARAM)hwndFocus);
            }
            continue;
        }

        if ( IsDialogMessage(m_hwnd, &msg) )
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

/**
*  This is the window procedure for the container application. It is used
*  to deal with all messages to our window.
*
*  @param      hwnd        Window handle.
*  @param      msg         The window message.
*  @param      wParam      Window Parameter.
*  @param      lParam      Window Parameter.
*
*  @return     LRESULT
*/
LRESULT CALLBACK CDlgApp::s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch(msg)
    {
    case WM_NCCREATE:
        {
            CDlgApp* pThisCreate = (CDlgApp *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LRESULT)pThisCreate);
        }
        break;

    case WM_CREATE:
        return pThis->OnCreate(hwnd);

    case WM_DESTROY:
        return pThis->OnDestroy();

    case WM_ACTIVATE:
        return pThis->OnActivate(wParam);

    case WM_PAINT:
        return pThis->OnPaint((HDC)wParam);

    case WM_ERASEBKGND:
        return pThis->OnEraseBkgnd((HDC)wParam);

    case WM_LBUTTONUP:
        return pThis->OnLButtonUp(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_MOUSEMOVE:
        return pThis->OnMouseMove(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_SETCURSOR:
        return pThis->OnSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_SETFOCUS:
        SetFocus(GetDlgItem(hwnd, IDM_MENUITEM0 + rgdwPosition[pThis->m_iSelectedItem]));
        return TRUE;

    case WM_TIMER:
        if (LAUNCHTIMER == wParam)
        {
            KillTimer(hwnd, LAUNCHTIMER);
            pThis->OnLaunchApp();
            return TRUE;
        }
        break;
    case WM_COMMAND:
    case WM_SYSCOMMAND:
        if ( pThis->OnCommand(LOWORD(wParam)) )
            return 0;
        break;

    case WM_DRAWITEM:
        return pThis->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);

    case WM_QUERYNEWPALETTE:
        return pThis->OnQueryNewPalette();

    case WM_PALETTECHANGED:
        return pThis->OnPaletteChanged((HWND)wParam);

    case ARM_CHANGESCREEN:
        return pThis->OnChangeScreen((DWORD)wParam);
    
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/**
*  This method is called on WM_CREATE.
*
*  @param  hwnd    Window handle for the application.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    _CreateMenu();
    _RedrawMenu();
    SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + rgdwPosition[m_iSelectedItem]));

    return 0;
}

void CDlgApp::_CreateMenu()
{
    // Create one window for each button.  These windows will get resized and moved
    // after we call AdjustToFitFonts.
    
    for (UINT i = 0; i < ARRAYSIZE(rgPtIcons); i++)
    {
        HWND hwnd = CreateWindowEx(
                0,
                TEXT("BUTTON"),
                TEXT(""),
                WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN|WS_VISIBLE|WS_TABSTOP|BS_PUSHBUTTON|BS_MULTILINE|BS_OWNERDRAW,
                0,0,0,0,
                m_hwnd,
                NULL,
                m_hInstance,                            
                NULL );
        
        SetWindowLongPtr(hwnd, GWLP_ID, IDM_MENUITEM0 + i);
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfontMenu, 0);
        g_fnBtnProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)s_ButtonWndProc);        
    }

    // We created the windows with zero size, now we adjust that size to take into
    // account for the selected font size, etc.
    _AdjustIconPlacement();
    _AdjustToFitFonts();
    
}

void CDlgApp::_RedrawMenu()
{
    for (UINT i = 0; i < ARRAYSIZE(rgPtIcons); i++)
    {
        if (EMPTY != rgdwMenuByPos[m_dwScreen][i])
        {
            TCHAR szBuffer[100];
            LoadString(m_hInstance, rgdwLabel[rgdwMenuByPos[m_dwScreen][i]], szBuffer, ARRAYSIZE(szBuffer));
            SetWindowText(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), szBuffer);
            EnableWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), TRUE);
            ShowWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), TRUE);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), FALSE);
            ShowWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), FALSE);
        }
        // setting window text only actually sets the accelerator, real drawing of text is in OnDrawItem
    }
    _AdjustToFitFonts();
}

/**
*  This method handles the WM_DESTROY message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnDestroy()
{
    // ensure this is the last message we care about
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CDlgApp::OnActivate(WPARAM wParam)
{
    return 0;
}

/**
*  This method handles the WM_PAINT message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnPaint(HDC hdc)
{
    PAINTSTRUCT ps;
    BeginPaint(m_hwnd,&ps);
    RECT rect;
    
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
    }

    SetMapMode(hdc, MM_TEXT);

    _PaintFlagBitmap();
    _DrawMenuIcons(FALSE);

    // restore the DC to its original value
    
    if(hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);

    EndPaint(m_hwnd,&ps);    
    return 0;
}

/**
*  This method handles the WM_ERASEBKGND message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnEraseBkgnd(HDC hdc)
{
    RECT rect;

    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
    }

    SetMapMode(hdc, MM_TEXT);
    SetBkMode(hdc, TRANSPARENT);

    // Draw the top pane:
    rect.left = 0;
    rect.top = 0;
    rect.right = m_cxClient;
    rect.bottom = m_cxTopPanel;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrPanel);
    }

    // Draw center pane
    rect.left = 0;
    rect.top = m_cxTopPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyBottomPanel;
    FillRect(hdc, &rect, m_hbrCenter);



    // Draw the bottom pane:
    rect.left = 0;
    rect.top = m_cyBottomPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyClient;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrPanel);
    }

    // Draw the text
    _DrawText(hdc);

    if(hpalOld)
    {
        SelectPalette(hdc, hpalOld, FALSE);
    }

    return TRUE;
}

void CDlgApp::_DrawText(HDC hdc)
{
    HFONT* rgFontText[4] = {&m_hfontTitle, &m_hfontHeader, &m_hfontText, &m_hfontText};
    BOOL rgfShadowText[4] = {FALSE, TRUE, FALSE, FALSE};

    SetTextColor(hdc,m_crNormalText);

    HFONT hfontOld = (HFONT)SelectObject(hdc,m_hfontHeader); // first draw uses hfontHeader
    
    for (int i = TEXT_TITLE; i <= TEXT_SUB; i++)
    {
        TCHAR szBuffer[2048];
        SelectObject(hdc, *rgFontText[i]);
        LoadString(m_hInstance, rgdwText[m_dwScreen][i], szBuffer, ARRAYSIZE(szBuffer));
        if (rgfShadowText[i] && !m_fHighContrast)
        {
            SetTextColor(hdc,m_crShadow);
            RECT rectShadow;
            memcpy(&rectShadow, (m_f8by6) ? &(rgrectText[i]) : &(rgrectText640[i]), sizeof(rectShadow));
            rectShadow.left += 2; rectShadow.right += 2; rectShadow.top += 2; rectShadow.bottom += 2;
            DrawText(hdc,szBuffer,-1, &rectShadow, DT_NOCLIP|DT_WORDBREAK);
            SetTextColor(hdc,m_crTitleText);
        }

        DrawText(hdc,szBuffer,-1, (m_f8by6) ? &(rgrectText[i]) : &(rgrectText640[i]), DT_NOCLIP|DT_WORDBREAK);
    }

    // restore the DC to its original value
    SelectObject(hdc,hfontOld);
}

void CDlgApp::_PaintFlagBitmap()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        RECT rect;
        if (m_f8by6)
        {
            rect.left = 20;
            rect.top = 10;
        }
        else
        {
            rect.left = 20;
            rect.top = 20;
        }
        rect.right = rect.left + FLAG_WIDTH;
        rect.bottom = rect.top + FLAG_HEIGHT;
        BitBlt( hdc, rect.left, rect.top, FLAG_WIDTH, FLAG_HEIGHT, 
                Mirror_IsWindowMirroredRTL(m_hwnd) ? m_hdcFlagRTL : m_hdcFlag, 
                0,0, SRCCOPY); // don't mirror flag on RTL systems for trademark reasons

        ReleaseDC(m_hwnd, hdc);        
    }
}

BOOL CDlgApp::_GetButtonIntersect(int x, int y, UINT* pidMenuItem)
{
    POINT pt;
    pt.x = x;
    pt.y = y;

    for (UINT i = 0; i < rgcMenu[m_dwScreen]; i++)
    {
        UINT iPos = rgdwPosition[rgdwMenu[m_dwScreen][i]];
        RECT rect;
        rect.left = m_f8by6 ? rgPtIcons[iPos].x : rgPtIcons640[iPos].x;
        rect.top =  m_f8by6 ? rgPtIcons[iPos].y : rgPtIcons640[iPos].y;
        rect.right = rect.left + MENUICON_WIDTH;
        rect.bottom = rect.top + MENUICON_HEIGHT;

        // extend the "hot zone" of the button to the right of the button by this amount to close the gap
        // between the button and the menu item
        switch (rgdwMenu[m_dwScreen][i])
        {
        case EXIT_DEX:
        case BACK_DEX:
        case NEXT_DEX:
        case FINISH_DEX:
            rect.left -= 6; // for items with text to the left of the button, we extend to the left
            break;
        case LINK_DEX:
        case RADIO_1_DEX:
        case RADIO_0_DEX:
            rect.right += 6; // for items with text to the right of the button, we extend to the right
        }

        if (PtInRect(&rect, pt))
        {                
            *pidMenuItem = IDM_MENUITEM0 + iPos;
            return TRUE;
        }
    }

    return FALSE;
}

LRESULT CDlgApp::OnMouseMove(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        UINT idMenuItem;
        if (_GetButtonIntersect(x, y, &idMenuItem))
        {
            SetFocus(GetDlgItem(m_hwnd, idMenuItem));
            SetCursor(m_hcurHand);
        }
        else
        {
            SetCursor(LoadCursor(NULL,IDC_ARROW));
        }
    }
    return 0;
}

LRESULT CDlgApp::OnLButtonUp(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        UINT idMenuItem;
        if (_GetButtonIntersect(x, y, &idMenuItem))
        {
            OnCommand(idMenuItem);
        }
    }
    return 0;
}

LRESULT CDlgApp::OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg)
{
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        if ( hwnd != m_hwnd )
        {
            SetCursor(m_hcurHand);
            return TRUE;
        }

        SetCursor(LoadCursor(NULL,IDC_ARROW));
    }
    return TRUE;
}

LRESULT CDlgApp::OnChangeScreen(DWORD dwScreen)
{
    static DWORD dwSelectedOld; // we store the last position on the main screen

    m_dwScreen += dwScreen;
    _RedrawMenu();
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        _DrawText(hdc);
        ReleaseDC(m_hwnd, hdc);
    }

    // invalidate the text
    _InvalidateRectIntl(m_hwnd, NULL, TRUE);
    
    m_iSelectedItem = rgdwMenuByPos[m_dwScreen][rgdwPosition[m_iSelectedItem]];
    if (EMPTY == m_iSelectedItem)
    {
        m_iSelectedItem = rgdwMenu[m_dwScreen][rgcMenu[m_dwScreen] - 1];
        SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + rgdwPosition[m_iSelectedItem]));
    }    
    return TRUE;
}

LRESULT CDlgApp::OnLaunchApp()
{
    BOOL fResult = FALSE;
    TCHAR szDirectory[MAX_PATH];

    // first, pop up the "please wait" dialog
    
    HWND hwndWait = CreateDialog(m_hInstance, MAKEINTRESOURCE(IDD_WAIT), GetDesktopWindow(), (DLGPROC)s_WaitWndProc);
    if (hwndWait)
    {
        RECT popupSize = {0, 0, 175, 50}; // a good guess
        GetWindowRect(hwndWait, &popupSize);
        SetWindowPos(hwndWait, HWND_TOP, 
                     (m_cDesktopWidth - (popupSize.right - popupSize.left)) / 2 , 
                     (m_cDesktopHeight - (popupSize.bottom - popupSize.top)) / 2, 
                     0, 0, SWP_SHOWWINDOW | SWP_NOSIZE);
    }

    // then launch the app itself
    if (GetModuleFileName(NULL, szDirectory, ARRAYSIZE(szDirectory)) &&
        _PathRemoveFileSpec(szDirectory))
    {
        TCHAR szBuffer[256];
        TCHAR szArgsBuffer[256];
        LoadStringAuto(m_hInstance, IDS_EXECUTABLE, szBuffer, ARRAYSIZE(szBuffer));
        LoadStringAuto(m_hInstance, 
                       m_fDynamicUpdate ? IDS_EXECUTABLE_ARGS_DU : IDS_EXECUTABLE_ARGS_NODU, 
                       szArgsBuffer, ARRAYSIZE(szArgsBuffer));
        fResult = ((INT_PTR)ShellExecute(m_hwnd, NULL, szBuffer, szArgsBuffer, szDirectory, SW_SHOWNORMAL ) > 32);
    }
    
    return fResult;
}

LRESULT CDlgApp::OnNextButton()
{
    switch (m_dwScreen)
    {
    case 4: // on change to last screen, we launch the app
        SetTimer(m_hwnd, LAUNCHTIMER, 100, NULL); 
        break;
    }

    return TRUE;
}

LRESULT CDlgApp::OnCommand(int wID)
{
    BOOL fRetVal = FALSE;

    switch(wID)
    {
    case IDM_MENUITEM0:
    case IDM_MENUITEM1:
    case IDM_MENUITEM2:
    case IDM_MENUITEM3:
    case IDM_MENUITEM4:
        switch (rgdwMenuByPos[m_dwScreen][wID-IDM_MENUITEM0])
        {
        case EXIT_DEX:
        case FINISH_DEX:
            PostQuitMessage(0);
            fRetVal = TRUE;
            break;
        case BACK_DEX:
            OnChangeScreen(-1);
            fRetVal = TRUE;
            break;
        case NEXT_DEX:
            OnNextButton();
            OnChangeScreen(+1);
            fRetVal = TRUE;
            break;
        case RADIO_1_DEX:
            m_fDynamicUpdate = TRUE;
            _DrawMenuIcons(FALSE);
            break;
        case RADIO_0_DEX:
            m_fDynamicUpdate = FALSE;
            _DrawMenuIcons(FALSE);
            break;
        case LINK_DEX:
            {
                TCHAR szLinkBuffer[256];       
                LoadStringAuto( m_hInstance, IDS_LINK, szLinkBuffer, ARRAYSIZE(szLinkBuffer) );
                ShellExecute(m_hwnd, NULL, szLinkBuffer, NULL, NULL, SW_SHOWNORMAL);
            }
            break;
        }
        break;
    }

    return fRetVal;
}

LRESULT CDlgApp::OnQueryNewPalette()
{
    if ( m_hpal )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            UnrealizeObject(m_hpal);
            RealizePalette(hdc);
            UpdateWindow(m_hwnd);
            if(hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
        return TRUE;
    }
    return FALSE;
}

LRESULT CDlgApp::OnPaletteChanged(HWND hwnd)
{
    if ( m_hpal && (m_hwnd != hwnd) )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            RealizePalette(hdc);
            UpdateColors(hdc);
            if (hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
    }
    return TRUE;
}

LRESULT CDlgApp::OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis)
{
    UINT dex = iCtlID - IDM_MENUITEM0;
    RECT rect = pdis->rcItem;
    POINT rectAbs = m_f8by6 ? rgPtIconText[dex] : rgPtIconText640[dex];
    HPALETTE hpalOld = NULL;

    TCHAR szBuffer[256];
    SIZE size;    
    LoadString(m_hInstance, rgdwLabel[rgdwMenuByPos[m_dwScreen][dex]], szBuffer, ARRAYSIZE(szBuffer));
    INT iLogPixelSx = GetDeviceCaps(pdis->hDC, LOGPIXELSX);
    INT iLogPixelSy = GetDeviceCaps(pdis->hDC, LOGPIXELSY);
    GetTextExtentPoint32(pdis->hDC, szBuffer, lstrlen(szBuffer), &size);
    size.cx = (size.cx * iLogPixelSx) / 80;
    size.cy = (size.cy * iLogPixelSy) / 80;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(pdis->hDC, m_hpal, FALSE);
        RealizePalette(pdis->hDC);
    }

    if (LINK_DEX == rgdwMenuByPos[m_dwScreen][dex] ||
        RADIO_1_DEX == rgdwMenuByPos[m_dwScreen][dex] ||
        RADIO_0_DEX == rgdwMenuByPos[m_dwScreen][dex])
    {
        FillRect(pdis->hDC, &rect, m_hbrCenter);
    }
    else if (m_f8by6 && !m_fLowColor)
    {
        BitBlt(pdis->hDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientBottom, rectAbs.x, rectAbs.y - m_cyBottomPanel, SRCCOPY);
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt(pdis->hDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientBottom256, rectAbs.x, rectAbs.y - m_cyBottomPanel, SRCCOPY);
    }
    else
    {
        FillRect(pdis->hDC, &rect, m_hbrPanel);
    }

    SetBkMode(pdis->hDC, TRANSPARENT);
    SetTextColor(pdis->hDC,m_crNormalText);

    UINT nFormat = DT_NOCLIP | DT_WORDBREAK;
    if (BACK_DEX == rgdwMenuByPos[m_dwScreen][dex] ||
        NEXT_DEX == rgdwMenuByPos[m_dwScreen][dex] ||
        EXIT_DEX == rgdwMenuByPos[m_dwScreen][dex] ||
        FINISH_DEX == rgdwMenuByPos[m_dwScreen][dex])
    {
        nFormat |= DT_RIGHT;
    }
    DrawText(pdis->hDC, szBuffer,-1, &rect, nFormat);

    if ( pdis->itemState & ODS_FOCUS )
    {
        if ( m_fHighContrast )
        {
            rect.left -= 1;
            rect.top -= 2;
            rect.right += 1;
            rect.bottom -= 2;
            DrawFocusRect(pdis->hDC,&rect);
        }
    }

    if ( hpalOld )
    {
        SelectPalette(pdis->hDC, hpalOld, FALSE);
    }
    _DrawMenuIcons(FALSE);

    return TRUE;
}


LRESULT CALLBACK CDlgApp::s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);
    int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM0;
    

    switch (uMsg)
    {
    case WM_ERASEBKGND:
        return TRUE;
        break;
    case WM_MOUSEMOVE:
        if (GetForegroundWindow() == GetParent(hwnd))
        {
            int iCurrDex = rgdwMenuByPos[pThis->m_dwScreen][iID];
            if ( iCurrDex != pThis->m_iSelectedItem )
            {
                SetFocus(hwnd);
            }
        }
        else
        {
            return FALSE;
        }
        break;

    case WM_SETFOCUS:
         if (GetForegroundWindow() == GetParent(hwnd))
        {
            int iCurrDex = rgdwMenuByPos[pThis->m_dwScreen][iID];
            if (EMPTY != iCurrDex &&
                pThis->m_iSelectedItem != iCurrDex)
            {
                pThis->m_iSelectedItem = iCurrDex;
                SetFocus(GetDlgItem(GetParent(hwnd), IDM_MENUITEM0+iID));
            }
        }
        else
        {
            return FALSE;
        }
        break;
    }

    return CallWindowProc(g_fnBtnProc, hwnd, uMsg, wParam, lParam);
}


LRESULT CALLBACK CDlgApp::s_WaitWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetTimer(hwnd, WAITTIMER, 10000, NULL); 
        return TRUE;
        break;
    case WM_TIMER:
        if (WAITTIMER == wParam)
        {
            PostMessage(GetParent(hwnd), WM_SETFOCUS, NULL, NULL);
            DestroyWindow(hwnd);            
            return TRUE;
        }
        break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\util.h ===
#pragma once

#include <ntverp.h>


#define ARM_CHANGESCREEN   WM_USER + 2
// Forced to define these myself because they weren't on Win95.
#undef StrRChr
#undef StrChr

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define MAJOR           (VER_PRODUCTMAJORVERSION)       // defined in ntverp.h
#define MINOR           (VER_PRODUCTMINORVERSION)       // defined in ntverp.h
#define BUILD           (VER_PRODUCTBUILD)              // defined in ntverp.h

// winver 0x0500 definition
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000
#endif // NOMIRRORBITMAP

// Relative Version
enum RELVER
{ 
    VER_UNKNOWN,        // we haven't checked the version yet
    VER_INCOMPATIBLE,   // the current os cannot be upgraded using this CD (i.e. win32s)
    VER_OLDER,          // current os is an older version on NT or is win9x
    VER_SAME,           // current os is the same version as the CD
    VER_NEWER,          // the CD contains a newer version of the OS
};


LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LPSTR StrChr(LPCSTR lpStart, WORD wMatch);

// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(HMODULE hModule, UINT wID, LPSTR lpBuffer,  int cchBufferMax);

BOOL Mirror_IsWindowMirroredRTL(HWND hWnd);

BOOL _PathRemoveFileSpec(LPTSTR psz);
void PathAppend(LPTSTR pszPath, LPTSTR pMore);
BOOL PathFileExists(LPTSTR pszPath);
BOOL IsUserRestricted();
BOOL IsCheckableOS();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\exe.cpp ===
#include <windows.h>
#include "resource.h"
#include "dlgapp.h"
#include "util.h"

// Code to ensure only one instance of a particular window is running
HANDLE CheckForOtherInstance(HINSTANCE hInstance)
{
    TCHAR   szCaption[128];
    HANDLE  hMutex;

    LoadStringAuto(hInstance, IDS_TITLEBAR, szCaption, 128);

    // We create a named mutex with our window caption just as a way to check
    // if we are already running autorun.exe.  Only if we are the first to
    // create the mutex do we continue.

    hMutex = CreateMutex (NULL, FALSE, szCaption);

    if ( !hMutex )
    {
        // failed to create the mutex
        return 0;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else, activate that window
        HWND hwnd = FindWindow( WINDOW_CLASS, szCaption );
        SetForegroundWindow(hwnd);
        CloseHandle(hMutex);
        return 0;
    }

    // we are the first
    return hMutex;
}

/**
*  This function is the main entry point into our application.
*
*  @return     int     Exit code.
*/

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLin, int nShowCmd )
{
    HANDLE hMutex = CheckForOtherInstance(hInstance);

    if ( hMutex )
    {
        CDlgApp dlgapp;
        dlgapp.Register(hInstance);
        if ( dlgapp.InitializeData(lpCmdLin) )
        {
            dlgapp.Create(nShowCmd);
            dlgapp.MessageLoop();
        }

        CloseHandle(hMutex);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\accdel.cpp ===
#include "priv.h"
#include "accdel.h"

CDelegateAccessibleImpl::CDelegateAccessibleImpl()
{
    ASSERT(NULL == m_pDelegateAccObj);
}

CDelegateAccessibleImpl::~CDelegateAccessibleImpl()
{ 
    if (NULL != m_pDelegateAccObj)
    {
        m_pDelegateAccObj->Release();
    }
}

HRESULT CDelegateAccessibleImpl::_DefQueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAccessible) ||
        IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IAccessible*);
        AddRef();
    }
    else if ((NULL != m_pDelegateAccObj) && IsEqualIID(riid, IID_IEnumVARIANT))
    {
        //  Yikes! breaking COM identity rules -- trident does it, just following their lead here :)
        m_pDelegateAccObj->QueryInterface(IID_IEnumVARIANT, ppvObj);
    }

    return (NULL == *ppvObj) ? E_NOINTERFACE : S_OK;
}

// *** IDispatch ***
STDMETHODIMP CDelegateAccessibleImpl::GetTypeInfoCount(
    UINT* pctinfo)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetTypeInfoCount(pctinfo);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
    
STDMETHODIMP CDelegateAccessibleImpl::GetTypeInfo(
    UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetTypeInfo(itinfo, lcid, pptinfo);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::GetIDsOfNames(
    REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }
    else
    {
        return E_UNEXPECTED;
    }
}


STDMETHODIMP CDelegateAccessibleImpl::Invoke(
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
    UINT* puArgErr)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->Invoke(dispidMember, riid, lcid, wFlags,
                                 pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

// *** IAccessible ***
STDMETHODIMP CDelegateAccessibleImpl::get_accParent( 
    IDispatch  **ppdispParent)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accParent(ppdispParent);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accChildCount( 
    long  *pcountChildren)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accChildCount(pcountChildren);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accChild( 
    VARIANT varChild,
    IDispatch  **ppdispChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accChild(varChild, ppdispChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accName( 
    VARIANT varChild,
    BSTR  *pszName)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accName(varChild, pszName);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accValue( 
    VARIANT varChild,
    BSTR  *pszValue)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accValue(varChild, pszValue);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accDescription( 
    VARIANT varChild,
    BSTR  *pszDescription)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accDescription(varChild, pszDescription);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accRole( 
    VARIANT varChild,
    VARIANT  *pvarRole)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accRole(varChild, pvarRole);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accState( 
    VARIANT varChild,
    VARIANT  *pvarState)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accState(varChild, pvarState);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accHelp( 
    VARIANT varChild,
    BSTR  *pszHelp)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accHelp(varChild, pszHelp);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accHelpTopic( 
    BSTR  *pszHelpFile,
    VARIANT varChild,
    long  *pidTopic)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accKeyboardShortcut( 
    VARIANT varChild,
    BSTR  *pszKeyboardShortcut)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accFocus( 
    VARIANT  *pvarChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accFocus(pvarChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accSelection( 
    VARIANT  *pvarChildren)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accSelection(pvarChildren);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accDefaultAction( 
    VARIANT varChild,
    BSTR  *pszDefaultAction)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accDefaultAction(varChild, pszDefaultAction);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accSelect( 
    long flagsSelect,
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accSelect(flagsSelect, varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accLocation( 
    long  *pxLeft,
    long  *pyTop,
    long  *pcxWidth,
    long  *pcyHeight,
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accNavigate( 
    long navDir,
    VARIANT varStart,
    VARIANT  *pvarEndUpAt)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accNavigate(navDir, varStart, pvarEndUpAt);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accHitTest( 
    long xLeft,
    long yTop,
    VARIANT  *pvarChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accHitTest(xLeft, yTop, pvarChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accDoDefaultAction( 
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accDoDefaultAction(varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::put_accName( 
    VARIANT varChild,
    BSTR szName)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->put_accName(varChild, szName);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::put_accValue( 
    VARIANT varChild,
    BSTR szValue)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->put_accValue(varChild, szValue);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\util.cpp ===
// util.cpp: Utility functions
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winbase.h>    // for GetCommandLine
#include "util.h"
#include <debug.h>
#include "resource.h"

// I'm doing my own version of these functions because they weren't in win95.
// These come from shell\shlwapi\strings.c.

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    ASSERT(lpStart);
    ASSERT(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart));

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChr(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;
    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

// LoadStringExW and LoadStringAuto are stolen from shell\ext\mlang\util.cpp
//
// Extend LoadString() to to _LoadStringExW() to take LangId parameter
int LoadStringExW(
    HMODULE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return 0;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hModule, (LPCWSTR)RT_STRING,
                                   (LPWSTR)IntToPtr(((USHORT)wID >> 4) + 1), wLangId)) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hModule, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            wID &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
                            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax-1;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

        }
    }

    return cch;
}

#define LCID_ENGLISH 0x409

// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(
    HMODULE    hModule,
    UINT      wID,
    LPSTR     lpBuffer,            
    int       cchBufferMax)
{
    int iRet = 0;

    LPWSTR lpwStr = (LPWSTR) LocalAlloc(LPTR, cchBufferMax*sizeof(WCHAR));

    if (lpwStr)
    {
        iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, GetSystemDefaultLangID());
        if (!iRet)
        {
            iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, LCID_ENGLISH);
        }

        if (iRet)
            iRet = WideCharToMultiByte(CP_ACP, 0, lpwStr, iRet, lpBuffer, cchBufferMax, NULL, NULL);

        if(iRet >= cchBufferMax)
            iRet = cchBufferMax-1;

        lpBuffer[iRet] = 0;

        LocalFree(lpwStr);
    }

    return iRet;
}

#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
BOOL Mirror_IsWindowMirroredRTL(HWND hWnd)
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}

BOOL _PathRemoveFileSpec(LPTSTR psz)
{
    TCHAR * pszT = StrRChr( psz, psz+lstrlen(psz)-1, TEXT('\\') );

    if (pszT)
    {
        *(pszT+1) = NULL;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void PathAppend(LPTSTR pszPath, LPTSTR pMore)
{
    lstrcpy(pszPath+lstrlen(pszPath), pMore);
}

BOOL PathFileExists(LPTSTR pszPath)
{
    BOOL fResult = FALSE;
    DWORD dwErrMode;

    dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    fResult = ((UINT)GetFileAttributes(pszPath) != (UINT)-1);

    SetErrorMode(dwErrMode);

    return fResult;
}

BOOL _IsNT()
{
    BOOL fRet = FALSE;

    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (GetVersionEx(&osv) &&
        VER_PLATFORM_WIN32_NT == osv.dwPlatformId)
    {
        fRet = TRUE;
    }

    return fRet;
}

BOOL _IsNTServer()
{
    BOOL fRet = FALSE;
    
    HKEY hKey;    
    if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"), 0, KEY_QUERY_VALUE, &hKey ))
    {
        TCHAR szProductType[80];
        DWORD dwBufLen = sizeof(szProductType);
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, "ProductType", NULL, NULL, (LPBYTE) szProductType, &dwBufLen))
        {
            if (!lstrcmpi("SERVERNT", szProductType) ||
                !lstrcmpi("LANMANNT", szProductType))
            {
                fRet = TRUE;
            }
        }
        RegCloseKey(hKey);
    }

    return fRet;
}

BOOL IsCheckableOS()
{
    BOOL fCheckable = FALSE;
    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (GetVersionEx(&osv))
    {
        if (VER_PLATFORM_WIN32_WINDOWS == osv.dwPlatformId) // Win9X
        {
            if (osv.dwMinorVersion > 0) // not Win95
            {
                fCheckable = TRUE;
            }
        }
        else if (VER_PLATFORM_WIN32_NT == osv.dwPlatformId) // WinNT
        {
            if ((osv.dwMajorVersion >= 4) &&
                !_IsNTServer())                 // only support NT4 and higher, no server SKUs
            {
                fCheckable = TRUE;
            }
        }
    }
    return fCheckable;
}

BOOL
_IsUserAdmin(
    VOID
    )
 
/*++
 
Routine Description:
 
    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.
 
    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.
 
Arguments:
 
    None.
 
Return Value:
 
    TRUE - Caller has Administrators local group.
 
    FALSE - Caller does not have Administrators local group.
 
--*/
 
{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
 
    //
    // On non-NT platforms the user is administrator.
    //
    if(!_IsNT()) {
        return(TRUE);
    }
 
    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }
 
    b = FALSE;
    Groups = NULL;
 
    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {
 
        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );
 
        if(b) {
 
            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }
 
            FreeSid(AdministratorsGroup);
        }
    }
 
    //
    // Clean up and return.
    //
 
    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }
 
    CloseHandle(Token);
 
    return(b);
}

BOOL
_DoesUserHavePrivilege(
    PTSTR PrivilegeName
    )
 
/*++
 
Routine Description:
 
    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.
 
    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.
 
Arguments:
 
    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).
 
Return Value:
 
    TRUE - Caller has the specified privilege.
 
    FALSE - Caller does not have the specified privilege.
 
--*/
 
{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;
 
    //
    // On non-NT platforms the user has all privileges
    //
    if(!_IsNT()) {
        return(TRUE);
    }
 
    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }
 
    b = FALSE;
    Privileges = NULL;
 
    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
 
        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {
 
            if(!memcmp(&Luid,&Privileges->Privileges[i].Luid,sizeof(LUID))) {
 
                b = TRUE;
                break;
            }
        }
    }
 
    //
    // Clean up and return.
    //
 
    if(Privileges) {
        LocalFree((HLOCAL)Privileges);
    }
 
    CloseHandle(Token);
 
    return(b);
}

BOOL IsUserRestricted()
{
    return (!_IsUserAdmin() ||
            !_DoesUserHavePrivilege(SE_SHUTDOWN_NAME) || 
            !_DoesUserHavePrivilege(SE_BACKUP_NAME) || 
            !_DoesUserHavePrivilege(SE_RESTORE_NAME) || 
            !_DoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\resource.h ===
//////////////////////////////////////////////////////////////////////////
//
//  resource.h
//
//      This file contains all of the resource ids used by the application.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#include <winuser.h>

//
//  icons.
//
#define IDI_WEBAPP             1

//
//  cursors.
//
#define IDC_BRHAND             1

//
//  bitmaps.
//

#define IDB_PANEL              20
#define IDB_CENTER             21

#define IDB_FLAG               40
#define IDB_FLAG_RTL           41

#define IDB_BACK               70
#define IDB_BACK_HOVER         71
#define IDB_NEXT               72
#define IDB_NEXT_HOVER         73
#define IDB_CLOSE              74
#define IDB_CLOSE_HOVER        75
#define IDB_CANCEL             76
#define IDB_CANCEL_HOVER       77
#define IDB_RADIO_ON           78
#define IDB_RADIO_ON_HOVER     79
#define IDB_RADIO_OFF          80
#define IDB_RADIO_OFF_HOVER    81

#define IDB_GRADIENT_TOP      110
#define IDB_GRADIENT_BOTTOM   111

#define IDB_FLAG_256              540
#define IDB_FLAG_RTL_256          541

#define IDB_BACK_256               570
#define IDB_BACK_HOVER_256         571
#define IDB_NEXT_256               572
#define IDB_NEXT_HOVER_256         573
#define IDB_CLOSE_256              574
#define IDB_CLOSE_HOVER_256        575
#define IDB_CANCEL_256             576
#define IDB_CANCEL_HOVER_256       577
#define IDB_RADIO_ON_256           578
#define IDB_RADIO_ON_HOVER_256     579
#define IDB_RADIO_OFF_256          580
#define IDB_RADIO_OFF_HOVER_256    581

#define IDB_GRADIENT_TOP_256      610
#define IDB_GRADIENT_BOTTOM_256   611


//
//  string table entries.
//
#define IDS_TITLE              1000
#define IDS_TITLEBAR           1001

#define IDS_TEXT0_TITLE        1500
#define IDS_TEXT1_TITLE        1501
#define IDS_TEXT2_TITLE        1502
#define IDS_TEXT3_TITLE        1503
#define IDS_TEXT4_TITLE        1504
#define IDS_TEXT5_TITLE        1505
#define IDS_TEXT6_TITLE        1506

#define IDS_TEXT0              1510
#define IDS_TEXT1              1511
#define IDS_TEXT2              1512
#define IDS_TEXT3              1513
#define IDS_TEXT4              1514
#define IDS_TEXT5              1515
#define IDS_TEXT6              1516

#define IDS_TEXT0_SUB          1520
#define IDS_TEXT1_SUB          1521
#define IDS_TEXT2_SUB          1522
#define IDS_TEXT3_SUB          1523
#define IDS_TEXT4_SUB          1524
#define IDS_TEXT5_SUB          1525
#define IDS_TEXT6_SUB          1526

#define IDS_TEXT0_HEADER       1530
#define IDS_TEXT1_HEADER       1531
#define IDS_TEXT2_HEADER       1532
#define IDS_TEXT3_HEADER       1533
#define IDS_TEXT4_HEADER       1534
#define IDS_TEXT5_HEADER       1535
#define IDS_TEXT6_HEADER       1536

#define IDS_EXECUTABLE           2000
#define IDS_EXECUTABLE_ARGS_DU   2001
#define IDS_EXECUTABLE_ARGS_NODU 2002
#define IDS_LINK                 2010

#define IDS_FONTFACE_TITLE          3000
#define IDS_FONTFACE_HEADER         3001
#define IDS_FONTFACE_MENU           3002
#define IDS_FONTFACE_TEXT           3003
#define IDS_FONTFACE_TITLE_BACKUP   3004
#define IDS_FONTFACE_HEADER_BACKUP  3005
#define IDS_FONTFACE_MENU_BACKUP    3006
#define IDS_FONTFACE_TEXT_BACKUP    3007

#define IDS_FONTCY_TITLE            3100
#define IDS_FONTCY_HEADER           3101
#define IDS_FONTCY_MENU             3102
#define IDS_FONTCY_TEXT             3103
#define IDS_FONTCY_TITLE_BACKUP     3104
#define IDS_FONTCY_HEADER_BACKUP    3105
#define IDS_FONTCY_MENU_BACKUP      3106
#define IDS_FONTCY_TEXT_BACKUP      3107

#define IDS_FONTCY_TITLE_LIL         3200
#define IDS_FONTCY_HEADER_LIL        3201
#define IDS_FONTCY_MENU_LIL          3202
#define IDS_FONTCY_TEXT_LIL          3203
#define IDS_FONTCY_TITLE_BACKUP_LIL  3204
#define IDS_FONTCY_HEADER_BACKUP_LIL 3205
#define IDS_FONTCY_MENU_BACKUP_LIL   3206
#define IDS_FONTCY_TEXT_BACKUP_LIL   3207

#define IDS_MENULABEL0           3300
#define IDS_MENULABEL1           3301
#define IDS_MENULABEL2           3302
#define IDS_MENULABEL3           3303
#define IDS_MENULABEL4           3304
#define IDS_MENULABEL5           3305
#define IDS_MENULABEL6           3306

//
//  commands.
//
#define IDM_MENUITEM0          500
#define IDM_MENUITEM1          501
#define IDM_MENUITEM2          502
#define IDM_MENUITEM3          503
#define IDM_MENUITEM4          504

// wait dialog
#define IDD_WAIT                7000
#define IDC_TEXT_WELCOME        7001
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseinfo\makefile.inc ===
$(O)\sbrlist.inc:
    perl.exe gensbrlists.pl .. $(O)

!if "$(BUILD_PASS)" == "PASS2"

!include $(O)\sbrlist.inc

$(O)\shell.bsc: $(SBRLIST) 
    $(MAKEDIR)\tools\x86\bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!else

$(O)\shell.bsc: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\accdel.h ===
#ifndef _ACCDEL_HPP_
#define _ACCDEL_HPP_

// REARCHITECT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

class CDelegateAccessibleImpl : public IAccessible
{
public:
    CDelegateAccessibleImpl();

    // *** IDispatch ***
    STDMETHODIMP GetTypeInfoCount(
        UINT* pctinfo);
        
    STDMETHODIMP GetTypeInfo(
        UINT itinfo, LCID lcid, ITypeInfo** pptinfo);

    STDMETHODIMP GetIDsOfNames(
        REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);

    STDMETHODIMP Invoke(
        DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
        UINT* puArgErr);

    // *** IAccessible ***
    STDMETHODIMP get_accParent( 
        IDispatch  **ppdispParent);
    
    STDMETHODIMP get_accChildCount( 
        long  *pcountChildren);
    
    STDMETHODIMP get_accChild( 
        VARIANT varChild,
        IDispatch  **ppdispChild);
    
    STDMETHODIMP get_accName( 
        VARIANT varChild,
        BSTR  *pszName);
    
    STDMETHODIMP get_accValue( 
        VARIANT varChild,
        BSTR  *pszValue);
    
    STDMETHODIMP get_accDescription( 
        VARIANT varChild,
        BSTR  *pszDescription);
        
    STDMETHODIMP get_accRole( 
        VARIANT varChild,
        VARIANT  *pvarRole);
    
    STDMETHODIMP get_accState( 
        VARIANT varChild,
        VARIANT  *pvarState);
    
    STDMETHODIMP get_accHelp( 
        VARIANT varChild,
        BSTR  *pszHelp);
    
    STDMETHODIMP get_accHelpTopic( 
        BSTR  *pszHelpFile,
        VARIANT varChild,
        long  *pidTopic);
        
    STDMETHODIMP get_accKeyboardShortcut( 
        VARIANT varChild,
        BSTR  *pszKeyboardShortcut);
    
    STDMETHODIMP get_accFocus( 
        VARIANT  *pvarChild);
    
    STDMETHODIMP get_accSelection( 
        VARIANT  *pvarChildren);
    
    STDMETHODIMP get_accDefaultAction( 
        VARIANT varChild,
        BSTR  *pszDefaultAction);
    
    STDMETHODIMP accSelect( 
        long flagsSelect,
        VARIANT varChild);
    
    STDMETHODIMP accLocation( 
        long  *pxLeft,
        long  *pyTop,
        long  *pcxWidth,
        long  *pcyHeight,
        VARIANT varChild);
    
    STDMETHODIMP accNavigate( 
        long navDir,
        VARIANT varStart,
        VARIANT  *pvarEndUpAt);
    
    STDMETHODIMP accHitTest( 
        long xLeft,
        long yTop,
        VARIANT  *pvarChild);
    
    STDMETHODIMP accDoDefaultAction( 
        VARIANT varChild);
    
    STDMETHODIMP put_accName( 
        VARIANT varChild,
        BSTR szName);
    
    STDMETHODIMP put_accValue( 
        VARIANT varChild,
        BSTR szValue);

protected:
    IAccessible     *m_pDelegateAccObj;

    HRESULT _DefQueryInterface(REFIID riid, void **ppvObj);
    virtual ~CDelegateAccessibleImpl();
};



#endif // _ACCDEL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclisf.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclisf.h"
#include "shellurl.h"

#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE

//
// CACLIShellFolder -- An AutoComplete List COM object that
//                  opens an IShellFolder for enumeration.
//



/* IUnknown methods */

HRESULT CACLIShellFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLIShellFolder, IEnumString),
        QITABENT(CACLIShellFolder, IACList),
        QITABENT(CACLIShellFolder, IACList2),
        QITABENT(CACLIShellFolder, IShellService),
        QITABENT(CACLIShellFolder, ICurrentWorkingDirectory),
        QITABENT(CACLIShellFolder, IPersistFolder),
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLIShellFolder::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLIShellFolder::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


/* ICurrentWorkingDirectory methods */
HRESULT CACLIShellFolder::SetDirectory(LPCWSTR pwzPath)
{
    HRESULT hr;
    LPITEMIDLIST pidl = NULL;

    hr = IECreateFromPathW(pwzPath, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = Initialize(pidl);
        ILFree(pidl);
    }

    return hr;
}


/* IPersistFolder methods */
HRESULT CACLIShellFolder::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    hr = _Init();
    if (FAILED(hr))
        return hr;

    if (pidl)
    {
#ifdef DEBUG
        TCHAR szPath[MAX_URL_STRING];
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), NULL);
        TraceMsg(AC_GENERAL, "ACListISF::Initialize(%s), SetCurrentWorking Directory happening", szPath);
#endif // DEBUG

        hr = _pshuLocation->SetCurrentWorkingDir(pidl);

        SetDefaultShellPath(_pshuLocation);

    }
    Pidl_Set(&_pidlCWD, pidl);

    return hr;
}

HRESULT CACLIShellFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_ACListISF;
    return S_OK;
}


/* IEnumString methods */
HRESULT CACLIShellFolder::Reset(void)
{
    HRESULT hr;
    LPITEMIDLIST pidl = NULL;
    TraceMsg(AC_GENERAL, "ACListISF::Reset()");
    _fExpand = FALSE;
    _nPathIndex = 0;

    hr = _Init();

    // See if we should show hidden files
    SHELLSTATE ss;
    ss.fShowAllObjects = FALSE;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS /*| SSF_SHOWSYSFILES*/, FALSE);
    _fShowHidden = BOOLIFY(ss.fShowAllObjects);
//    _fShowSysFiles = BOOLIFY(ss.fShowSysFiles);

    if (SUCCEEDED(hr) && IsFlagSet(_dwOptions, ACLO_CURRENTDIR))
    {
        // Set the Browser's Current Directory.
        if (_pbs)
        {
            _pbs->GetPidl(&pidl);

            if (pidl)
                Initialize(pidl);
        }

        hr = _SetLocation(pidl);
        if (FAILED(hr))
            hr = S_FALSE;   // If we failed, keep going, we will just end up now doing anything.

        ILFree(pidl);
    }
    
    return hr;
}


// If this is an FTP URL, skip it if:
// 1) It's absolute (has a FTP scheme), and
// 2) it contains a '/' after the server name.
BOOL CACLIShellFolder::_SkipForPerf(LPCWSTR pwzExpand)
{
    BOOL fSkip = FALSE;

    if ((URL_SCHEME_FTP == GetUrlScheme(pwzExpand)))
    {
        // If it's FTP, we want to prevent from hitting the server until
        // after the user has finished AutoCompleting the Server name.
        // Since we can't enum server names, the server names will need
        // to come from the MRU.
        if ((7 >= lstrlen(pwzExpand)) ||                    // There's more than 7 chars "ftp://"
            (NULL == StrChr(&(pwzExpand[7]), TEXT('/'))))   // There is a '/' after the server, "ftp://serv/"
        {
            fSkip = TRUE;
        }
    }

    return fSkip;
}



/* IACList methods */
/****************************************************\
    FUNCTION: Expand

    DESCRIPTION:
        This function will attempt to use the pszExpand
    parameter to bind to a location in the Shell Name Space.
    If that succeeds, this AutoComplete List will then
    contain entries which are the display names in that ISF.
\****************************************************/
HRESULT CACLIShellFolder::Expand(LPCOLESTR pszExpand)
{
    HRESULT hr = S_OK;
    SHSTR strExpand;
    LPITEMIDLIST pidl = NULL;
    DWORD dwParseFlags = SHURL_FLAGS_NOUI;

    TraceMsg(AC_GENERAL, "ACListISF::Expand(%ls)", pszExpand);
    _fExpand = FALSE;
    _nPathIndex = 0;

    strExpand.SetStr(pszExpand);
    
    if (Str_SetPtr(&_szExpandStr, strExpand.GetStr()) && _szExpandStr)
    {
        if (_SkipForPerf(pszExpand)) // Do we want to skip this item for perf reasons?
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        else
            hr = _Init();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
        return hr;

    // See if the string points to a location in the Shell Name Space
    hr = _pshuLocation->ParseFromOutsideSource(_szExpandStr, dwParseFlags);
    if (SUCCEEDED(hr))
    {
        // Yes it did, so now AutoComplete from that ISF
        hr = _pshuLocation->GetPidl(&pidl);
        // This may fail if it's something like "ftp:/" and not yet valid".

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(AC_GENERAL, "ACListISF::Expand() Pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    }

    // Set the ISF that we need to enumerate for AutoComplete.
    hr = _SetLocation(pidl);
    if (pidl)
    {
        ILFree(pidl);


        if (SUCCEEDED(hr))
        {
            _fExpand = TRUE;
        }
    }

    return hr;
}

/* IACList2 methods */
//+-------------------------------------------------------------------------
// Enables/disables various autocomplete features (see ACLO_* flags)
//--------------------------------------------------------------------------
HRESULT CACLIShellFolder::SetOptions(DWORD dwOptions)
{
    _dwOptions = dwOptions;
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns the current option settings
//--------------------------------------------------------------------------
HRESULT CACLIShellFolder::GetOptions(DWORD* pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = _dwOptions;
        hr = S_OK;
    }

    return hr;
}


HRESULT CACLIShellFolder::_GetNextWrapper(LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl = NULL;
    ULONG celtFetched = 0;

    // If this directory (ISF) doesn't contain any more items to enum,
    // then go on to the next directory (ISF) to enum.
    do
    {
        BOOL fFilter;

        do
        {
            fFilter = FALSE;
            hr = _peidl->Next(1, &pidl, &celtFetched);
            if (S_OK == hr)
            {
                hr = _PassesFilter(pidl, pszName, cchSize);
                if (FAILED(hr))
                {
                    fFilter = TRUE;
                }

                ILFree(pidl);
            }
        }
        while (fFilter);
    }
    while ((S_OK != hr) && (S_OK == _TryNextPath()));

    return hr;
}


HRESULT CACLIShellFolder::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;
    ULONG celtFetched;
    BOOL fUsingCachePidl = FALSE;
    WCHAR szDisplayName[MAX_PATH];

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    // If there isn't a Current Working Directory, skip to another
    // Path to enum.
    if (!_peidl)
        hr = _TryNextPath();

    if ((!_peidl) || (!rgelt))
        return S_FALSE;

    // Get the next PIDL.
    if (_pidlInFolder)
    {
        // We have a cached, SHGDN_INFOLDER, so lets try that.
        pidl = _pidlInFolder;
        celtFetched = 1;
        _pidlInFolder = NULL;
        fUsingCachePidl = TRUE;

        hr = _GetPidlName(pidl, fUsingCachePidl, szDisplayName, ARRAYSIZE(szDisplayName));
        ILFree(pidl);
        AssertMsg((S_OK == hr), TEXT("CACLIShellFolder::Next() hr doesn't equal S_OK, so we need to call _GetNextWrapper() but we aren't.  Please call BryanSt."));
    }
    else
    {
        hr = _GetNextWrapper(szDisplayName, ARRAYSIZE(szDisplayName));
    }

//         This is giving us entries (favorites without .url extension) that cannot be navigated to.
//         So I'm disabling this for IE5B2. (stevepro)
//
//        else
//            Pidl_Set(&_pidlInFolder, pidl);  // We will try (SHGDN_INFOLDER) next time.

    if (SUCCEEDED(hr))
    {
        LPOLESTR pwszPath;

        // Allocate a return buffer (caller will free it).
        pwszPath = (LPOLESTR)CoTaskMemAlloc((lstrlenW(szDisplayName) + 1) * SIZEOF(WCHAR));
        if (pwszPath)
        {
            StrCpyW(pwszPath, szDisplayName);
            TraceMsg(AC_GENERAL, "ACListISF::Next() Str=%s, _nPathIndex=%d", pwszPath, _nPathIndex);

            if (SUCCEEDED(hr))
            {
                rgelt[0] = pwszPath;
                *pceltFetched = 1;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CACLIShellFolder::_GetPidlName(LPCITEMIDLIST pidl, BOOL fUsingCachePidl, LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    WCHAR szName[MAX_PATH];

    // Get the display name of the PIDL.
    if (!fUsingCachePidl)
    {
        hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szName, ARRAYSIZE(szName));

        // some namespaces don't understand _FORADDRESSBAR -- default to IE4 behavior
        if (FAILED(hr))
            hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName));
    }


    if (fUsingCachePidl || FAILED(hr))
    {
        hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORADDRESSBAR, szName, ARRAYSIZE(szName));

        // some namespaces don't understand _FORADDRESSBAR -- default to IE4 behavior
        if (FAILED(hr))
            hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
    }

    if (SUCCEEDED(hr))
    {
        DWORD cchRemain = cchSize;
        LPTSTR pszInsert = pszName;

        pszName[0] = 0;     // Init the out buffer.

        // First, prepend the _szExpandStr if necessary.
        // This is needed for sections that don't give
        // the entire path, like "My Computer" items
        // which is (3 == _nPathIndex)
        if (_fExpand && ((_nPathIndex == 0) /*|| (_nPathIndex == 3)*/))
        {
            DWORD cchExpand = lstrlen(_szExpandStr);

            // Make sure that for UNC paths the "\\share" is not already
            // prepended.  NT5 returns the name in this final form.
            if ((StrCmpNI(szName, _szExpandStr, cchExpand) != 0) ||
                (szName[0] != L'\\') || (szName[1] != L'\\'))
            {
                StrCpyN(pszInsert, _szExpandStr, cchSize);
                pszInsert += cchExpand;
                cchRemain -= cchExpand;
            }
        }

        // Next, append the display name.
        StrCpyN(pszInsert, szName, cchRemain);
        TraceMsg(AC_GENERAL, "ACListISF::_GetPidlName() Str=%s, _nPathIndex=%d", pszInsert, _nPathIndex);
    }
    return hr;
}


HRESULT CACLIShellFolder::_PassesFilter(LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD dwAttributes = (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM);

    hr = _GetPidlName(pidl, FALSE, pszName, cchSize);
    if (SUCCEEDED(hr))
    {
        if (((ACLO_FILESYSONLY & _dwOptions) || (ACLO_FILESYSDIRS & _dwOptions)) &&
            SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &dwAttributes)))
        {
            if (!(dwAttributes & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM)))
            {
                // We reject it because it's not in the file system.
                hr = E_FAIL;        // Skip this item.

                TraceMsg(AC_GENERAL, "ACListISF::_PassesFilter() We are skipping\"%s\" because it doesn't match the filter", pszName);
            }
            else
            {
                if ((ACLO_FILESYSDIRS & _dwOptions) && !PathIsDirectory(pszName))
                {
                    hr = E_FAIL;        // Skip this item since it's not a directory
                }
            }
        }
    }

    return hr;
}


HRESULT CACLIShellFolder::_Init(void)
{
    HRESULT hr = S_OK;

    if (!_pshuLocation)
    {
        _pshuLocation = new CShellUrl();
        if (!_pshuLocation)
            return E_OUTOFMEMORY;

    }

    return hr;
}


HRESULT CACLIShellFolder::_SetLocation(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // Free old location
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_psf);

    // Set to new location (Valid if NULL)
    Pidl_Set(&_pidl, pidl);
    if (_pidl)
    {
        hr = IEBindToObject(_pidl, &_psf);
        if (SUCCEEDED(hr))
        {
            DWORD grfFlags = (_fShowHidden ? SHCONTF_INCLUDEHIDDEN : 0) |
                             SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

            hr = IShellFolder_EnumObjects(_psf, NULL, grfFlags, &_peidl);
            if (hr != S_OK) 
            {
                hr = E_FAIL;    // S_FALSE -> empty enumerator
            }
        }
    }
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
    {
        // Clear if we could not get all the info
        ATOMICRELEASE(_peidl);
        ATOMICRELEASE(_psf);
        Pidl_Set(&_pidl, NULL);
    }

    //
    // NOTE: This is necessary because this memory is alloced in a ACBG thread, but not
    //       freed until the next call to Reset() or the destructor, which will 
    //       happen in the main thread or another ACBG thread.
    //
    return hr;
}


HRESULT CACLIShellFolder::_TryNextPath(void)
{
    HRESULT hr = S_FALSE;
    if (0 == _nPathIndex)
    {
        _nPathIndex = 1;
        if (_pidlCWD && IsFlagSet(_dwOptions, ACLO_CURRENTDIR))
        {
            hr = _SetLocation(_pidlCWD);
            if (SUCCEEDED(hr))
            {
                goto done;
            }
        }
    }

    if (1 == _nPathIndex)
    {
        _nPathIndex = 2;
        if(IsFlagSet(_dwOptions, ACLO_DESKTOP))
        {
            //  we used to autocomplete g_pidlRoot in the rooted explorer
            //  case, but this was a little weird.  if we want to add this,
            //  we should add ACLO_ROOTED or something.
            
            //  use the desktop...
            hr = _SetLocation(&s_idlNULL);
            if (SUCCEEDED(hr))
            {
                goto done;
            }
        }
    }

    if (2 == _nPathIndex)
    {
        _nPathIndex = 3;
        if (IsFlagSet(_dwOptions, ACLO_MYCOMPUTER))
        {
            LPITEMIDLIST pidlMyComputer;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer)))
            {
                hr = _SetLocation(pidlMyComputer);
                ILFree(pidlMyComputer);
                if (SUCCEEDED(hr))
                {
                    goto done;
                }
            }
        }
    }

    // Also search favorites
    if (3 == _nPathIndex)
    {
        _nPathIndex = 4;
        if (IsFlagSet(_dwOptions, ACLO_FAVORITES))
        {
            LPITEMIDLIST pidlFavorites;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFavorites)))
            {
                hr = _SetLocation(pidlFavorites);
                ILFree(pidlFavorites);
                if (SUCCEEDED(hr))
                {
                    goto done;
                }
            }
        }
    }

    if (FAILED(hr))
        hr = S_FALSE;  // This is how we want our errors returned.

done:

    return hr;
}


//================================
// *** IShellService Interface ***

/****************************************************\
    FUNCTION: SetOwner

    DESCRIPTION:
        Update the connection to the Browser window so
    we can always get the PIDL of the current location.
\****************************************************/
HRESULT CACLIShellFolder::SetOwner(IUnknown* punkOwner)
{
    HRESULT hr = S_OK;
    IBrowserService * pbs = NULL;

    ATOMICRELEASE(_pbs);

    if (punkOwner)
        hr = punkOwner->QueryInterface(IID_IBrowserService, (LPVOID *) &pbs);

    if (EVAL(SUCCEEDED(hr)))
        _pbs = pbs;

    return S_OK;
}


/* Constructor / Destructor / CreateInstance */

CACLIShellFolder::CACLIShellFolder()
{
    DllAddRef();
    ASSERT(!_peidl);
    ASSERT(!_psf);
    ASSERT(!_pbs);
    ASSERT(!_pidl);
    ASSERT(!_pidlCWD);
    ASSERT(!_fExpand);
    ASSERT(!_pshuLocation);
    ASSERT(!_szExpandStr);

    _cRef = 1;

    // Default search paths
    _dwOptions = ACLO_CURRENTDIR | ACLO_MYCOMPUTER;
}

CACLIShellFolder::~CACLIShellFolder()
{
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_pbs);

    Pidl_Set(&_pidl, NULL);
    Pidl_Set(&_pidlCWD, NULL);
    Pidl_Set(&_pidlInFolder, NULL);
    Str_SetPtr(&_szExpandStr, NULL);

    if (_pshuLocation)
        delete _pshuLocation;
    DllRelease();
}

HRESULT CACLIShellFolder_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CACLIShellFolder *paclSF = new CACLIShellFolder();
    if (paclSF)
    {
        *ppunk = SAFECAST(paclSF, IEnumString *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclhist.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLHIST_H_
#define _ACLHIST_H_

// Enum options
enum
{
    ACEO_ALTERNATEFORMS = ACEO_FIRSTUNUSED, // return alternate forms of the url 
};

class CACLHistory
                : public IEnumACString
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

    // *** IEnumACString ***
    virtual STDMETHODIMP NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex);
    virtual STDMETHODIMP SetEnumOptions(DWORD dwOptions);
    virtual STDMETHODIMP GetEnumOptions(DWORD *pdwOptions);

protected:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLHistory(void);
    ~CACLHistory(void);

    // Instance creator
    friend HRESULT CACLHistory_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD               _cRef;              // COM reference count
    IUrlHistoryStg*     _puhs;              // URL History storage
    IEnumSTATURL*       _pesu;              // URL enumerator
    LPOLESTR            _pwszAlternate;     // Alternate string
    FILETIME            _ftAlternate;       // Last visited time for _pwszAlternate
    HDSA                _hdsaAlternateData; // Contains alternate mappings
    DWORD               _dwOptions;         // Options flag

    // Private functions
    HRESULT _Next(LPOLESTR* ppsz, ULONG cch, FILETIME* pftLastVisited);
    void _CreateAlternateData(void);
    void _CreateAlternateItem(LPCTSTR pszUrl);
    void _SetAlternateItem(LPCTSTR pszUrl);
    void _AddAlternateDataItem(LPCTSTR pszProtocol, LPCTSTR pszDomain, BOOL fMoveSlashes);
    void _ReadAndSortHistory(void);
    static int _FreeAlternateDataItem(LPVOID p, LPVOID d);
};

#endif // _ACLHIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclisf.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLISF_H_
#define _ACLISF_H_

#include "shellurl.h"

class CACLIShellFolder
                : public IEnumString
                , public IACList2
                , public ICurrentWorkingDirectory
                , public IShellService
                , public IPersistFolder
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand);

    // *** IACList2 ***
    virtual STDMETHODIMP SetOptions(DWORD dwFlag);
    virtual STDMETHODIMP GetOptions(DWORD* pdwFlag);

    // *** ICurrentWorkingDirectory ***
    virtual STDMETHODIMP GetDirectory(LPWSTR pwzPath, DWORD cchSize) {return E_NOTIMPL;};
    virtual STDMETHODIMP SetDirectory(LPCWSTR pwzPath);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);        // Save as SetDirectory() but for pidls
    virtual STDMETHODIMP GetClassID(CLSID *pclsid);

    // *** IShellService ***
    virtual STDMETHODIMP SetOwner(IUnknown* punkOwner);


private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLIShellFolder();
    ~CACLIShellFolder(void);

    HRESULT _SetLocation(LPCITEMIDLIST pidl);
    HRESULT _TryNextPath(void);
    HRESULT _Init(void);
    BOOL _SkipForPerf(LPCWSTR pwzExpand);
    HRESULT _PassesFilter(LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize);
    HRESULT _GetNextWrapper(LPWSTR pszName, DWORD cchSize);
    HRESULT _GetPidlName(LPCITEMIDLIST pidl, BOOL fUsingCachePidl, LPWSTR pszName, DWORD cchSize);

    // Instance creator
    friend HRESULT CACLIShellFolder_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD           _cRef;          // COM reference count
    IEnumIDList*    _peidl;         // PIDL enumerator
    IShellFolder*   _psf;           // Shell folder
    IBrowserService* _pbs;          // Browser Service to find Current Location in Shell Name Space.
    LPITEMIDLIST    _pidl;          // PIDL of current directory.
    LPITEMIDLIST    _pidlCWD;       // PIDL of current working directory. 
    LPITEMIDLIST    _pidlInFolder;  // Sometimes the user string matches SHGDN_INFOLDER, but not (SHGDN_INFOLDER | SHGDN_FORPARSING).  My Computer for example.
    BOOL            _fExpand;       // Are we expanding?
    LPTSTR          _szExpandStr;   // String we are expanding
    CShellUrl *     _pshuLocation; 
    int             _nPathIndex; 
    DWORD           _dwOptions;     // ACLO_* flags
    BOOL            _fShowHidden;   // Enumerate hidden files?
//    BOOL            _fShowSysFiles; // Enumerate system files?
};

#endif // _ACLISF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclmulti.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLMULTI_H_
#define _ACLMULTI_H_

//
// CACLMulti is an AutoComplete List that simply contains
// other AutoComplete Lists.  Objects are added via IObjMgr
// methods, and each IEnumString method is
// just passed on to each sub list in turn.
//

class CACLMulti
                : public IEnumACString
                , public IObjMgr
                , public IACList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

    // *** IEnumACString **
    virtual STDMETHODIMP NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex);
    virtual STDMETHODIMP SetEnumOptions(DWORD dwOptions) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetEnumOptions(DWORD *pdwOptions) { return E_NOTIMPL; };

    // *** IObjMgr ***
    virtual STDMETHODIMP Append(IUnknown *punk);
    virtual STDMETHODIMP Remove(IUnknown *punk);

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand);

protected:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLMulti(void);
    ~CACLMulti(void);

    // Instance creator
    friend HRESULT CACLMulti_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
    friend HRESULT CACLMulti_Create(IEnumString **ppenum, CACLMulti * paclMultiToCopy);

    // Private variables
    DWORD   _cRef;          // COM reference count
    int     _iSubList;      // Current sublist for Next() operations
    HDSA    _hdsa;          // HDSA of sublists

    // Private methods
    static int _FreeListItem(LPVOID p, LPVOID d);
};

#endif // _ACLMULTI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclmru.cpp ===
/* Copyright 1996-1997 Microsoft */


#include <priv.h>
#include "sccls.h"
#include "aclisf.h"
#include "shellurl.h"

#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE

//
// CACLMRU -- An AutoComplete List COM object that
//                  enumerates the Type-in MRU.
//


class CACLMRU
                : public IEnumString
                , public IACList
                , public IACLCustomMRU
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand) {return E_NOTIMPL;}

    // *** IACLCustomMRU ***
    virtual STDMETHODIMP Initialize(LPCWSTR pszMRURegKey, DWORD dwMax);
    virtual STDMETHODIMP AddMRUString(LPCWSTR pszEntry);
    
private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLMRU();
    ~CACLMRU(void);

    // Instance creator
    friend HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
    friend HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU);
    friend HRESULT CACLCustomMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD           m_cRef;      // COM reference count
    HKEY            m_hKey;      // HKey of MRU Location
    BOOL            m_bBackCompat; //  true for run dialog and address bar
    DWORD           m_nMRUIndex; // Current Index into MRU
    DWORD           m_dwRunMRUSize;
    HANDLE          m_hMRU;
};

/* IUnknown methods */

HRESULT CACLMRU::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLMRU, IEnumString), 
        QITABENT(CACLMRU, IACList), 
        QITABENT(CACLMRU, IACLCustomMRU),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLMRU::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}

ULONG CACLMRU::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

HRESULT CACLMRU::Reset(void)
{
    TraceMsg(AC_GENERAL, "CACLMRU::Reset()");
    m_nMRUIndex = 0;

    return S_OK;
}


HRESULT CACLMRU::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    TCHAR szMRUEntry[MAX_URL_STRING+1];
    LPWSTR pwzMRUEntry = NULL;

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    if (!rgelt)
        return S_FALSE;

    if (!m_hMRU)
    {
        hr = GetMRUEntry(m_hKey, m_nMRUIndex++, szMRUEntry, SIZECHARS(szMRUEntry), NULL);
        if (S_OK != hr)
        {
            hr = S_FALSE; // This will indicate that no more items are in the list.
        }
    }
    else
    {
        hr = S_FALSE;
        if (m_nMRUIndex < m_dwRunMRUSize && EnumMRUList(m_hMRU, m_nMRUIndex++, szMRUEntry, ARRAYSIZE(szMRUEntry)) > 0)
        {
            if (m_bBackCompat)
            {
                // old MRU format has a slash at the end with the show cmd
                LPTSTR pszField = StrRChr(szMRUEntry, NULL, TEXT('\\'));
                if (pszField)
                    pszField[0] = TEXT('\0');
            }
            hr = S_OK;
        }
    }

    if (S_OK == hr)
    {
        hr = SHStrDup(szMRUEntry, rgelt);
        if (SUCCEEDED(hr))
            *pceltFetched = 1;
    }

    return hr;
}

/* Constructor / Destructor / CreateInstance */
CACLMRU::CACLMRU() : m_cRef(1), m_bBackCompat(TRUE)
{
    DllAddRef();
    // Require object to be in heap and Zero-Inited
    ASSERT(!m_hKey);
    ASSERT(!m_nMRUIndex);
    ASSERT(!m_hMRU);
}

CACLMRU::~CACLMRU()
{
    if (m_hKey)
        RegCloseKey(m_hKey);

    if (m_hMRU)
        FreeMRUList(m_hMRU);

    DllRelease();
}

/****************************************************\
    FUNCTION: CACLMRU_CreateInstance

    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  The caller didn't specify which MRU
    list to use, so we default to the TYPE-IN CMD
    MRU, which is used in the Start->Run dialog and
    in AddressBars that are floating or in the Taskbar.
\****************************************************/
HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    return CACLMRU_CreateInstance(punkOuter, ppunk, poi, SZ_REGKEY_TYPEDCMDMRU);
}

/****************************************************\
    FUNCTION: CACLMRU_CreateInstance

    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  This will point to either the MRU for
    a browser or for a non-browser (Start->Run or
    the AddressBar in the Taskbar or floating) depending
    on the pszMRU parameter.
\****************************************************/
HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU)
{
    *ppunk = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    BOOL fUseRunDlgMRU = (StrCmpI(pszMRU, SZ_REGKEY_TYPEDCMDMRU) ? FALSE : TRUE);

    CACLMRU *paclSF = new CACLMRU();
    if (paclSF)
    {
        hr = paclSF->Initialize(pszMRU, 26);
        if (SUCCEEDED(hr))
        {
            paclSF->AddRef();
            *ppunk = SAFECAST(paclSF, IEnumString *);
        }
        paclSF->Release();
    }

    return hr;
}

HRESULT CACLCustomMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CACLMRU *pmru = new CACLMRU();
    if (pmru)
    {
        *ppunk = SAFECAST(pmru, IEnumString *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

#define SZ_REGKEY_TYPEDURLMRUW       L"Software\\Microsoft\\Internet Explorer\\TypedURLs"
#define SZ_REGKEY_TYPEDCMDMRUW       L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"

HRESULT CACLMRU::Initialize(LPCWSTR pszMRURegKey, DWORD dwMax)
{
    HRESULT hr = S_OK;
    BOOL bURL = StrCmpIW(pszMRURegKey, SZ_REGKEY_TYPEDURLMRUW) ? FALSE : TRUE;
    
    if (!bURL)
    {
        MRUINFO mi =  {
            SIZEOF(MRUINFO),
            dwMax,
            MRU_CACHEWRITE,
            HKEY_CURRENT_USER,
            pszMRURegKey,
            NULL        // NOTE: use default string compare
                        // since this is a GLOBAL MRU
        };

        m_bBackCompat = StrCmpIW(pszMRURegKey, SZ_REGKEY_TYPEDCMDMRUW) ? FALSE : TRUE;
        m_hMRU = CreateMRUList(&mi);
        if (m_hMRU)
            m_dwRunMRUSize = EnumMRUList(m_hMRU, -1, NULL, 0);
        else
            hr = E_FAIL;
    }
    else
    {
        m_bBackCompat = TRUE;
        if (ERROR_SUCCESS != RegCreateKey(HKEY_CURRENT_USER, pszMRURegKey, &m_hKey))
            hr = E_FAIL;
    }

    return hr;
}

HRESULT CACLMRU::AddMRUString(LPCWSTR pszEntry)
{
    HRESULT hr = E_FAIL;

    if (m_hMRU)
    {
        if (::AddMRUString(m_hMRU, pszEntry) != -1)
            hr = S_OK;
    }
    //else We don't support saving for address bar MRU

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclmulti.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclmulti.h"

//
// CACLMulti -- An AutoComplete List COM object that
//                  contains other AutoComplete Lists and
//                  has them do all the work.
//

struct _tagListItem
{
    IUnknown        *punk;
    IEnumString     *pes;
    IEnumACString   *peacs;
    IACList         *pacl;
};
typedef struct _tagListItem LISTITEM;

#define MULTILIST_GROWTH_CONST 8

/* IUnknown methods */

HRESULT CACLMulti::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumString))
    {
        *ppvObj = SAFECAST(this, IEnumString*);
    }
    else if (IsEqualIID(riid, IID_IEnumACString))
    {
        *ppvObj = SAFECAST(this, IEnumACString*);
    }
    else if (IsEqualIID(riid, IID_IObjMgr))
    {
        *ppvObj = SAFECAST(this, IObjMgr*);
    }
    else if (IsEqualIID(riid, IID_IACList))
    {
        *ppvObj = SAFECAST(this, IACList*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CACLMulti::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLMulti::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

HRESULT CACLMulti::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;    // nothing found... stop

    *pceltFetched = 0;

    if (celt == 0)
    {
        return S_OK;
    }

    if (!rgelt)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr) && _hdsa)
    {
        //
        // Keep calling Next() starting with the current list
        // until somebody returns something.
        //
        for( ; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;

            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                hr = li.pes->Next(1, rgelt, pceltFetched);
                if (hr == S_OK)
                    break;

                if (FAILED(hr))  // Why is the caller failing? 
                    hr = S_FALSE;   // Probably because it failed to conntect to the source (ftp)
            }
        }
    }
    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CACLMulti::Skip(ULONG)
{
    return E_NOTIMPL;
}

HRESULT CACLMulti::Reset(void)
{
    HRESULT hr = S_OK;
    TraceMsg(TF_BAND|TF_GENERAL, "ACLMulti::Reset() Beginning");

    if (_hdsa)
    {
        // Call Reset() on each sublist.
        for (_iSubList=0; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;
            
            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                hr = li.pes->Reset();
                if (FAILED(hr))
                    break;
            }
        }
    }

    // Reset ourselves to point to the first list.
    _iSubList = 0;

    return hr;
}

HRESULT CACLMulti::Clone(IEnumString **ppenum)
{
    return CACLMulti_Create(ppenum, this);
}

// IEnumAutocomplete methods
HRESULT CACLMulti::NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    HRESULT hr = S_FALSE;    // nothing found... stop

    if (!pszUrl)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr) && _hdsa)
    {
        //
        // Keep calling Next() starting with the current list
        // until somebody returns something.
        //
        for( ; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;

            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                // Use the IEnumACString interface if we have it
                if (NULL != li.peacs)
                {
                    hr = li.peacs->NextItem(pszUrl, cchMax, pulSortIndex);
                }

                // Fall back to the old IEnumString interface
                else
                {
                    LPWSTR pszNext;
                    ULONG ulFetched;

                    hr = li.pes->Next(1, &pszNext, &ulFetched);
                    if (S_OK == hr)
                    {
                        StrCpyN(pszUrl, pszNext, cchMax);
                        if (pulSortIndex)
                        {
                            *pulSortIndex = 0;
                        }
                        CoTaskMemFree(pszNext);
                    }
                }
                if (hr == S_OK)
                    break;

                if (FAILED(hr))  // Why is the caller failing? 
                    hr = S_FALSE;   // Probably because it failed to conntect to the source (ftp)
            }
        }
    }
    ASSERT(SUCCEEDED(hr));

    return hr;
}

/* IObjMgr methods */

HRESULT CACLMulti::Append(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        if (!_hdsa)
        {
            _hdsa = DSA_Create(SIZEOF(LISTITEM), MULTILIST_GROWTH_CONST);
        }

        if (_hdsa)
        {
            LISTITEM li = { 0 };

            //
            // Call QI to get the necessary interfaces,
            // and append the interfaces to the internal list.
            //
            li.punk = punk;
            li.punk->AddRef();

            li.punk->QueryInterface(IID_IEnumString, (LPVOID *)&li.pes);
            li.punk->QueryInterface(IID_IEnumACString, (LPVOID *)&li.peacs);
            li.punk->QueryInterface(IID_IACList, (LPVOID *)&li.pacl);

            if (DSA_AppendItem(_hdsa, &li) != -1)
            {
                hr = S_OK;
            }
            else
            {
                _FreeListItem(&li, 0);
                hr = E_FAIL;
            }
        }
    }

    return hr;
}

HRESULT CACLMulti::Remove(IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    int i;

    if (punk && _hdsa)
    {
        for(i=DPA_GetPtrCount(_hdsa); i>=0; i--)
        {
            LISTITEM li;

            if (DSA_GetItem(_hdsa, i, &li) != -1)
            {
                if (punk == li.punk)
                {
                    _FreeListItem(&li, 0);
                    if (DSA_DeleteItem(_hdsa, i))
                    {
                        hr = S_OK;
                    }
                    break;
                }
            }
        }
    }

    return hr;
}


/* IACList methods */

HRESULT CACLMulti::Expand(LPCOLESTR pszExpand)
{
    HRESULT hr = S_OK;
    int i;

    if (_hdsa)
    {
        // Call Expand() on each sublist.
        for (i=0; i < DSA_GetItemCount(_hdsa); i++)
        {
            LISTITEM li;
            
            if ((DSA_GetItem(_hdsa, i, &li) != -1) && (li.pacl != NULL))
            {
                hr = li.pacl->Expand(pszExpand);
                if (hr == S_OK)
                    break;
            }
        }
    }
    
    if (E_NOTIMPL == hr)
        hr = S_OK;

    return hr;
}

/* Constructor / Destructor / CreateInstance */

CACLMulti::CACLMulti()
{
    DllAddRef();
    ASSERT(!_hdsa);
    ASSERT(!_iSubList);
    _cRef = 1;
}

CACLMulti::~CACLMulti()
{
    if (_hdsa)
    {
        DSA_DestroyCallback(_hdsa, _FreeListItem, 0);
        _hdsa = NULL;
    }

    DllRelease();
}

HRESULT CACLMulti_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory


    *ppunk = NULL;
    CACLMulti * p = new CACLMulti();
    if (p) 
    {
        *ppunk = SAFECAST(p, IEnumString *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}

HRESULT CACLMulti_Create(IEnumString **ppenum, CACLMulti * paclMultiToCopy)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;
    CACLMulti * p = new CACLMulti();
    if (p) 
    {
        if (paclMultiToCopy->_hdsa)
        {
            // Clone data
            int iSize = DSA_GetItemCount(paclMultiToCopy->_hdsa);
            int iIndex;
            LISTITEM li;

            hr = S_OK;
            p->_hdsa = DSA_Create(SIZEOF(LISTITEM), MULTILIST_GROWTH_CONST);

            // We need to copy the source HDSA
            for (iIndex = 0; (iIndex < iSize) && (S_OK == hr); iIndex++)
            {
                if (DSA_GetItem(paclMultiToCopy->_hdsa, iIndex, &li) != -1)
                    hr = p->Append(li.punk);
                else
                    hr = E_FAIL;
            }
            p->_iSubList = paclMultiToCopy->_iSubList;

            if (SUCCEEDED(hr))
                *ppenum = SAFECAST(p, IEnumString *);
            else
                p->Release();
        }
        else
        {
            p->Release();
        }
    }

    return hr;
}

//
// Frees all the contents of one list item.
//
int CACLMulti::_FreeListItem(LPVOID p, LPVOID d)
{
    LISTITEM *pli = (LISTITEM *)p;

    SAFERELEASE(pli->pacl);
    SAFERELEASE(pli->pes);
    SAFERELEASE(pli->peacs);
    SAFERELEASE(pli->punk);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aclhist.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclhist.h"


static const TCHAR c_szSlashSlash[] = TEXT("//");
static const TCHAR c_szEmpty[] = TEXT("");
static const TCHAR c_szFile[] = TEXT("file://");

#define SZ_REGKEY_URLPrefixesKeyA      "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes"

const TCHAR c_szDefaultURLPrefixKey[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix");

/* IUnknown methods */

HRESULT CACLHistory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLHistory, IEnumString),
        QITABENT(CACLHistory, IEnumACString),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLHistory::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLHistory::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;
    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

STDAPI PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, DWORD * pcbOut, BOOL fUTF8Enabled);

HRESULT CACLHistory::_Next(LPOLESTR* ppsz, ULONG cch, FILETIME* pftLastVisited)
{
    ASSERT(ppsz);

    HRESULT hr = S_FALSE;

    if (_pwszAlternate)
    {
        //
        // There is an alternate version of the string we produced last time.
        // Hand them the alternate string now.
        //
        if (cch == 0)
        {
            // Return the allocated memory
            *ppsz = _pwszAlternate;
        }
        else
        {
            // Copy into the caller's buffer
            StrCpyN(*ppsz, _pwszAlternate, cch);
            CoTaskMemFree(_pwszAlternate);
        }
        _pwszAlternate = NULL;
        hr = S_OK;
    }

    else if (NULL != _pesu)
    {
        STATURL rsu[1] = { { SIZEOF(STATURL) } };
        ULONG celtFetched;
        while (SUCCEEDED(_pesu->Next(1, rsu, &celtFetched)) && celtFetched)
        {
            ASSERT(IS_VALID_STRING_PTRW(rsu[0].pwcsUrl, -1));

            // We didn't ask for the title!
            ASSERT(NULL == rsu[0].pwcsTitle);

            //
            // Ignore if a frame or an error URL
            //
            if (!(rsu[0].dwFlags & STATURLFLAG_ISTOPLEVEL) ||
                 IsErrorUrl(rsu[0].pwcsUrl))
            {
                CoTaskMemFree(rsu[0].pwcsUrl);
                rsu[0].pwcsUrl = NULL;
                continue;
            }

            // WARNING (IE #54924): It would look pretty to
            //    unescape the URL but that would incure data-loss
            //    so don't do it!!!  This breaks more things that
            //    you could imagine. -BryanSt
            //
            // Unescape the URL (people don't like to type %F1, etc).
            //
            // Unescaping is definitely a problem for ftp, but it should be
            // safe for http and https (stevepro).

            hr = S_OK; // we're done already, unless we have to muck around with UTF8 decoding

            if (StrChr(rsu[0].pwcsUrl, L'%'))
            {
                DWORD dwScheme = GetUrlScheme(rsu[0].pwcsUrl);
                if ((dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS))
                {
                    WCHAR   szBuf[MAX_URL_STRING];
                    DWORD   cchBuf = ARRAYSIZE(szBuf);

                    HRESULT hr2 = PrepareURLForDisplayUTF8W(rsu[0].pwcsUrl, szBuf, &cchBuf, TRUE);

                    if (SUCCEEDED(hr2))
                    {
                        // normally StrCpyNW's cch limit should be the size of the destination
                        // buffer, but in this case, we know that the number of characters that
                        // were written into szBuf is <= the number of characters in
                        // rsu[0].pwcsUrl since if anything changes, it is the reduction of
                        // URL escaped sequences into single characters, and the reduction of
                        // UTF8 character sequences into single unicode characters.
                    
                        ASSERT(cchBuf <= (DWORD)lstrlenW(rsu[0].pwcsUrl));
                        StrCpyNW(rsu[0].pwcsUrl, szBuf, cchBuf+1);
                    }
                }
            }

            if (cch == 0)
            {
                // Return the allocated memory
                *ppsz = rsu[0].pwcsUrl;
            }
            else
            {
                // Copy into the caller's buffer
                StrCpyN(*ppsz, rsu[0].pwcsUrl, cch);
                CoTaskMemFree(rsu[0].pwcsUrl);
            }

            // Save the time in case an alternate form is needed
            _ftAlternate = rsu[0].ftLastVisited;
            break;
        }
    }

    // Provide alternate forms of the same url
    if ((_dwOptions & ACEO_ALTERNATEFORMS) && hr == S_OK)
    {
        USES_CONVERSION;
        _CreateAlternateItem(W2T(*ppsz));
    }

    if (pftLastVisited)
    {
        *pftLastVisited = _ftAlternate;
    }

    return hr;
}

HRESULT CACLHistory::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;

    *pceltFetched = 0;

    if (!celt)
    {
        return S_OK;
    }

    if (!rgelt)
    {
        return E_FAIL;
    }

    hr = _Next(&rgelt[0], 0, NULL);
    if (S_OK == hr)
    {
        *pceltFetched = 1;
    }
    return hr;
}


HRESULT CACLHistory::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CACLHistory::Reset(void)
{
    HRESULT hr = S_OK;

    //
    // Since Reset() is always called before Next() we will
    // delay opening the History folder until that last 
    // moment.
    //
    if (!_puhs)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, 
                        IID_PPV_ARG(IUrlHistoryStg, &_puhs));
    }

    if ((SUCCEEDED(hr)) && (_puhs) && (!_pesu))
    {
        hr = _puhs->EnumUrls(&_pesu);
    }

    if ((SUCCEEDED(hr)) && (_puhs) && (_pesu))
    {
        hr = _pesu->Reset();

         // We only want top-level pages
        _pesu->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL | STATURL_QUERYFLAG_NOTITLE);
   }

    if (_pwszAlternate)
    {
        CoTaskMemFree(_pwszAlternate);
        _pwszAlternate = NULL;
    }

    return hr;
}

/****************************************************************\
    FUNCTION: Clone

    DESCRIPTION:
        This function will clone the current enumerator.

    WARNING:
        This function will not implement the full functionality
    of Clone().  It will not create an enumerator that is pointing
    to the same location in the list as the original enumerator.
\****************************************************************/
HRESULT CACLHistory::Clone(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;
    CACLHistory * p = new CACLHistory();

    if (p) 
    {
        hr = p->Reset();
        if (FAILED(hr))
            p->Release();
        else
            *ppenum = SAFECAST(p, IEnumString *);
    }

    return hr;
}

// *** IEnumACString ***
HRESULT CACLHistory::NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    if (NULL == pszUrl || cchMax == 0 || NULL == pulSortIndex)
    {
        return E_INVALIDARG;
    }

    *pulSortIndex = 0;

    FILETIME ftLastVisited;
    HRESULT hr = _Next(&pszUrl, cchMax, &ftLastVisited);

    // See if we want the results sorted by most recently used first
    if (S_OK == hr && (_dwOptions & ACEO_MOSTRECENTFIRST))
    {
        // Get the current system time
        FILETIME ftTimeNow;
        CoFileTimeNow(&ftTimeNow);

        ULONGLONG t1=0,t2=0,t3;

        // Put the current time into 64-bit 
        t1 = ((ULONGLONG)ftTimeNow.dwHighDateTime << 32);
        t1 += ftTimeNow.dwLowDateTime;

        // Ditto for the last visited time
        t2 = ((ULONGLONG)ftLastVisited.dwHighDateTime << 32);
        t2 += ftLastVisited.dwLowDateTime;

        // Take the difference and convert into seconds
        t3 = (t1-t2) / 10000000;

        // If t3 overflows, then set the low byte to the highest possible value
        if (t3 > (ULONGLONG)MAXULONG) 
        {
            t3 = MAXULONG;
        }

        *pulSortIndex = (ULONG)t3;
    }
    return hr;
}

STDMETHODIMP CACLHistory::SetEnumOptions(DWORD dwOptions)
{
    _dwOptions = dwOptions;
    return S_OK;
}

STDMETHODIMP CACLHistory::GetEnumOptions(DWORD *pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = _dwOptions;
        hr = S_OK;
    }
    return hr;
}

/* Constructor / Destructor / CreateInstance */

CACLHistory::CACLHistory()
{
    DllAddRef();
    ASSERT(_puhs == 0);
    ASSERT(_pesu == 0);
    _cRef = 1;
    _dwOptions = ACEO_ALTERNATEFORMS;
}

CACLHistory::~CACLHistory()
{
    if (_pesu)
    {
        _pesu->Release();
        _pesu = NULL;
    }

    if (_puhs)
    {
        _puhs->Release();
        _puhs = NULL;
    }

    if (_hdsaAlternateData)
    {
        DSA_DestroyCallback(_hdsaAlternateData, _FreeAlternateDataItem, 0);
        _hdsaAlternateData = NULL;
    }

    DllRelease();
}

HRESULT CACLHistory_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    CACLHistory * p = new CACLHistory();
    if (p) 
    {
        *ppunk = SAFECAST(p, IEnumString *);
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}

/* Private functions */

typedef struct _tagAlternateData
{
    LPTSTR pszProtocol;
    int cchProtocol;
    LPTSTR pszDomain;
    int cchDomain;
} ALTERNATEDATA;


//
// Add one protocol/domain combination to the HDSA.
// Information is stored in the registry as
// Protocol="ftp://" and Domain="ftp." but we want to
// store it as Protocol="ftp:" and Domain="//ftp."
// when fMoveSlashes is TRUE.
//
void CACLHistory::_AddAlternateDataItem(LPCTSTR pszProtocol, LPCTSTR pszDomain, BOOL fMoveSlashes)
{
    ALTERNATEDATA ad;

    ZeroMemory(&ad, SIZEOF(ad));

    ad.cchProtocol = lstrlen(pszProtocol);
    ad.cchDomain = lstrlen(pszDomain);

    if (fMoveSlashes)
    {
        //
        // Validate that there are slashes to move.
        //
        if (ad.cchProtocol > 2 &&
            pszProtocol[ad.cchProtocol - 2] == TEXT('/') &&
            pszProtocol[ad.cchProtocol - 1] == TEXT('/'))
        {
            ad.cchProtocol -= 2;
            ad.cchDomain += 2;
        }
        else
        {
            fMoveSlashes = FALSE;
        }
    }

    ad.pszProtocol = (LPTSTR)LocalAlloc(LPTR, (ad.cchProtocol + 1) * SIZEOF(TCHAR));
    ad.pszDomain = (LPTSTR)LocalAlloc(LPTR, (ad.cchDomain + 1) * SIZEOF(TCHAR));

    if (ad.pszProtocol && ad.pszDomain)
    {
        lstrcpyn(ad.pszProtocol, pszProtocol, ad.cchProtocol + 1);

        if (fMoveSlashes)
        {
            lstrcpy(ad.pszDomain, c_szSlashSlash);
            lstrcpy(ad.pszDomain + 2, pszDomain);
        }
        else
        {
            lstrcpy(ad.pszDomain, pszDomain);
        }

        DSA_AppendItem(_hdsaAlternateData, &ad);
    }
    else
    {
        _FreeAlternateDataItem(&ad, 0);
    }
}

//
// This fills in the HDSA from the registry.
//
void CACLHistory::_CreateAlternateData(void)
{
    HKEY hkey;
    DWORD cbProtocol;
    TCHAR szProtocol[MAX_PATH];
    DWORD cchDomain;
    TCHAR szDomain[MAX_PATH];
    DWORD dwType;

    ASSERT(_hdsaAlternateData == NULL);

    _hdsaAlternateData = DSA_Create(SIZEOF(ALTERNATEDATA), 10);
    if (!_hdsaAlternateData)
    {
        return;
    }

    //
    // Add default protocol.
    //
    cbProtocol = SIZEOF(szProtocol);
    if (SHGetValue(HKEY_LOCAL_MACHINE, c_szDefaultURLPrefixKey, NULL, NULL, (void *)szProtocol, (DWORD *)&cbProtocol) == ERROR_SUCCESS)
    {
        _AddAlternateDataItem(szProtocol, c_szEmpty, TRUE);
    }

    //
    // Add "file://" prefix.  Since "file://foo.txt" doesn't navigate to
    // the same place as "//foo.txt" we have to pass in FALSE to fMoveSlashes.
    //
    _AddAlternateDataItem(c_szFile, c_szEmpty, FALSE);

    //
    // Add all registered prefixes.
    //
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_REGKEY_URLPrefixesKeyA, 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
    {
        cchDomain = ARRAYSIZE(szDomain);
        cbProtocol = SIZEOF(szProtocol);

        for (int i=0;
             SHEnumValue(hkey, i, szDomain, &cchDomain, &dwType,
                          (PBYTE)szProtocol, &cbProtocol) == ERROR_SUCCESS;
             i++)
        {
            _AddAlternateDataItem(szProtocol, szDomain, TRUE);

            cchDomain = ARRAYSIZE(szDomain);
            cbProtocol = SIZEOF(szProtocol);
        }

        RegCloseKey(hkey);
    }
}

//
// Given a pszUrl, attempts to create an alternate URL
// and store it into _pwszAlternate.
//
//  URL                 Alternate
//  =================   ========================
//  http://one.com      //one.com
//  //one.com           one.com
//  one.com             (no alternate available)
//  ftp://ftp.two.com   //ftp.two.com
//  //ftp.two.com       ftp.two.com
//  ftp.two.com         (no alternate available)
//  ftp://three.com     (no alternate available)
//  file://four.txt     four.txt
//  four.txt            (no alternate available)
//
// In a sense, this is the opposite of IURLQualify().
//
void CACLHistory::_CreateAlternateItem(LPCTSTR pszUrl)
{
    ASSERT(_pwszAlternate == NULL);

    //
    // If an URL begins with "//" we can always remove it.
    //
    if (pszUrl[0] == TEXT('/') && pszUrl[1] == TEXT('/'))
    {
        _SetAlternateItem(pszUrl + 2);
        return;
    }

    //
    // Create the HDSA if necessary.
    //
    if (!_hdsaAlternateData)
    {
        _CreateAlternateData();

        if (!_hdsaAlternateData)
        {
            return;
        }
    }

    //
    // Look for matches in the HDSA.
    //
    // For instance, if pszProtocol="ftp:" and pszDomain="//ftp."
    // and the given url is of the format "ftp://ftp.{other stuff}"
    // then we strip off the pszProtocol and offer "//ftp.{other stuff}"
    // as the alternate.
    //
    for (int i=0; i<DSA_GetItemCount(_hdsaAlternateData); i++)
    {
        ALTERNATEDATA ad;

        if (DSA_GetItem(_hdsaAlternateData, i, &ad) != -1)
        {
            if ((StrCmpNI(ad.pszProtocol, pszUrl, ad.cchProtocol) == 0) &&
                (StrCmpNI(ad.pszDomain, pszUrl + ad.cchProtocol, ad.cchDomain) == 0))
            {
                _SetAlternateItem(pszUrl + ad.cchProtocol);
                return;
            }
        }
    }
}

//
// Given an URL, set _pwszAlternate.  This takes care
// of all ANSI/UNICODE issues and allocates memory for
// _pwszAlternate via CoTaskMemAlloc.
//
void CACLHistory::_SetAlternateItem(LPCTSTR pszUrl)
{
    ASSERT(_pwszAlternate == NULL);

    int cch;

#ifdef UNICODE
    cch = lstrlen(pszUrl) + 1;
#else
    cch = MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, NULL, 0);
#endif

    _pwszAlternate = (LPOLESTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
    if (_pwszAlternate)
    {
#ifdef UNICODE
        StrCpy(_pwszAlternate, pszUrl);
#else
        MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, _pwszAlternate, cch);
#endif
    }
}

//
// Handy routine for calling directly or via DSA callback.
//
int CACLHistory::_FreeAlternateDataItem(void * p, void * d)
{
    ALTERNATEDATA *pad = (ALTERNATEDATA *)p;

    if (pad->pszProtocol)
    {
        LocalFree((HANDLE)pad->pszProtocol);
    }
    if(pad->pszDomain)
    {
        LocalFree((HANDLE)pad->pszDomain);
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\acthread.cpp ===
// Copyright 1998 Microsoft

#include "priv.h"
#include "autocomp.h"

#define AC_GIVEUP_COUNT           1000
#define AC_TIMEOUT          (60 * 1000)

//
// Thread messages
//
enum
{
    ACM_FIRST = WM_USER,
    ACM_STARTSEARCH,
    ACM_STOPSEARCH,
    ACM_SETFOCUS,
    ACM_KILLFOCUS,
    ACM_QUIT,
    ACM_LAST,
};


// Special prefixes that we optionally filter out
const struct{
    int cch;
    LPCWSTR psz;
} 
g_rgSpecialPrefix[] =
{
    {4,  L"www."},
    {11, L"http://www."},   // This must be before "http://"
    {7,  L"http://"},
    {8,  L"https://"},
};


//+-------------------------------------------------------------------------
// CACString functions - Hold autocomplete strings
//--------------------------------------------------------------------------
ULONG CACString::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CACString::Release()
{
    ASSERT(m_cRef > 0);

    if (InterlockedDecrement(&m_cRef))
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

CACString* CreateACString(LPCWSTR pszStr, int iIgnore, ULONG ulSortIndex)
{
    ASSERT(pszStr);

    int cChars = lstrlen(pszStr);

    // Allocate the CACString class with enough room for the new string
    CACString* pStr = (CACString*)LocalAlloc(LPTR, cChars * sizeof(WCHAR) + sizeof(CACString));
    if (pStr)
    {
        StrCpy(pStr->m_sz, pszStr);

        pStr->m_ulSortIndex = ulSortIndex;
        pStr->m_cRef  = 1;
        pStr->m_cChars      = cChars;
        pStr->m_iIgnore     = iIgnore;
    }
    return pStr;
}

int CACString::CompareSortingIndex(CACString& r)
{
    int iRet;

    // If the sorting indices are equal, just do a string compare
    if (m_ulSortIndex == r.m_ulSortIndex)
    {
        iRet = StrCmpI(r);
    }
    else
    {
        iRet = (m_ulSortIndex > r.m_ulSortIndex) ? 1 : -1;
    }

    return iRet;
}

HRESULT CACThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACThread::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CACThread::Release(void)
{
    ASSERT(m_cRef > 0);

    if (InterlockedDecrement(&m_cRef))
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

CACThread::CACThread(CAutoComplete& rAutoComp) : m_pAutoComp(&rAutoComp), m_cRef(1)
{
    ASSERT(!m_fWorkItemQueued); 
    ASSERT(!m_idThread);
    ASSERT(!m_hCreateEvent);  
    ASSERT(!m_fDisabled); 
    ASSERT(!m_pszSearch);   
    ASSERT(!m_hdpa_list);    
    ASSERT(!m_pes);
    ASSERT(!m_pacl);

    DllAddRef();
}

CACThread::~CACThread()
{
    SyncShutDownBGThread();  // In case somehow

    // These should have been freed.
    ASSERT(!m_idThread);
    ASSERT(!m_hdpa_list);

    SAFERELEASE(m_pes);
    SAFERELEASE(m_peac);
    SAFERELEASE(m_pacl);

    DllRelease();
}

BOOL CACThread::Init(IEnumString* pes,   // source of the autocomplete strings
                     IACList* pacl)      // optional interface to call Expand
{
    // REARCHITECT: We need to marshal these interfaces to this thread!
    ASSERT(pes);
    m_pes = pes;
    m_pes->AddRef();

    m_peac = NULL;
    pes->QueryInterface(IID_PPV_ARG(IEnumACString, &m_peac));

    if (pacl)
    {
        m_pacl = pacl;
        m_pacl->AddRef();
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
// Called when the edit box recieves focus. We use this event to create
// a background thread or to keep the backgroung thread from shutting down
//--------------------------------------------------------------------------
void CACThread::GotFocus()
{
    TraceMsg(AC_GENERAL, "CACThread::GotFocus()");

    // Should not be NULL if the foreground thread is calling us!
    ASSERT(m_pAutoComp);

    //
    // Check to see if autocomplete is supposed to be enabled.
    //
    if (m_pAutoComp && m_pAutoComp->IsEnabled())
    {
        m_fDisabled = FALSE;

        if (m_fWorkItemQueued)
        {
            // If the thread hasn't started yet, wait for a thread creation event
            if (0 == m_idThread && m_hCreateEvent)
            {
                WaitForSingleObject(m_hCreateEvent, 1000);
            }

            if (m_idThread)
            {
                //
                // Tell the thread to cancel its timeout and stay alive.
                //
                // REARCHITECT: We have a race condition here.  The thread can be
                // in the process of shutting down!
                PostThreadMessage(m_idThread, ACM_SETFOCUS, 0, 0);
            }
        }
        else
        {
            //
            // The background thread signals an event when it starts up.
            // We wait on this event before trying a synchronous shutdown
            // because any posted messages would be lost.
            //
            if (NULL == m_hCreateEvent)
            {
                m_hCreateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            }
            else
            {
                ResetEvent(m_hCreateEvent);
            }

            //
            // Make sure we have a background search thread.
            //
            // If we start it any later, we run the risk of not
            // having its message queue available by the time
            // we post a message to it.
            //
            // AddRef ourselves now, to prevent us getting freed
            // before the thread proc starts running.
            //
            AddRef();

            // Call to Shlwapi thread pool
            if (SHQueueUserWorkItem(_ThreadProc,
                                     this,
                                     0,
                                     (DWORD_PTR)NULL,
                                     NULL,
                                     "browseui.dll",
                                     TPS_LONGEXECTIME | TPS_DEMANDTHREAD
                                     ))
            {
                InterlockedExchange(&m_fWorkItemQueued, TRUE);
            }
            else
            {
                // Couldn't get thread
                Release();
            }
        }
    }
    else
    {
        m_fDisabled = TRUE;
        _SendAsyncShutDownMsg(FALSE);
    }
}   

//+-------------------------------------------------------------------------
// Called when the edit box loses focus.
//--------------------------------------------------------------------------
void CACThread::LostFocus()
{
    TraceMsg(AC_GENERAL, "CACThread::LostFocus()");

    //
    // If there is a thread around, tell it to stop searching.
    //
    if (m_idThread)
    {
        StopSearch();
        PostThreadMessage(m_idThread, ACM_KILLFOCUS, 0, 0);
    }
}

//+-------------------------------------------------------------------------
// Sends the search request to the background thread.
//--------------------------------------------------------------------------
BOOL CACThread::StartSearch
(
    LPCWSTR pszSearch,  // String to search
    DWORD dwOptions     // ACO_* flags
)
{
    BOOL fRet = FALSE;

    // If the thread hasn't started yet, wait for a thread creation event
    if (0 == m_idThread && m_fWorkItemQueued && m_hCreateEvent)
    {
        WaitForSingleObject(m_hCreateEvent, 1000);
    }

    if (m_idThread)
    {
        LPWSTR pszSrch = StrDup(pszSearch);
        if (pszSrch)
        {
            //
            // This is being sent to another thread, remove it from this thread's
            // memlist.
            //
            // 
            // If the background thread is already searching, abort that search
            //
            StopSearch();

            //
            // Send request off to the background search thread.
            //
            if (PostThreadMessage(m_idThread, ACM_STARTSEARCH, dwOptions, (LPARAM)pszSrch))
            {
                fRet = TRUE;
            }
            else
            {
                TraceMsg(AC_GENERAL, "CACThread::_StartSearch could not send message to thread!");
                LocalFree(pszSrch);
            }
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Tells the background thread to stop and pending search
//--------------------------------------------------------------------------
void CACThread::StopSearch()
{
    TraceMsg(AC_GENERAL, "CACThread::_StopSearch()");

    //
    // Tell the thread to stop.
    //
    if (m_idThread)
    {
        PostThreadMessage(m_idThread, ACM_STOPSEARCH, 0, 0);
    }
}

//+-------------------------------------------------------------------------
// Posts a quit message to the background thread
//--------------------------------------------------------------------------
void CACThread::_SendAsyncShutDownMsg(BOOL fFinalShutDown)
{
    if (0 == m_idThread && m_fWorkItemQueued && m_hCreateEvent)
    {
        //
        // Make sure that the thread has started up before posting a quit
        // message or the quit message will be lost!
        //
        WaitForSingleObject(m_hCreateEvent, 3000);
    }

    if (m_idThread)
    {
        // Stop the search because it can hold up the thread for quite a
        // while by waiting for disk data.
        StopSearch();

        // Tell the thread to go away, we won't be needing it anymore.  Note that we pass
        // the dropdown window because during the final shutdown we need to asynchronously
        // destroy the dropdown to avoid a crash.  The background thread will keep browseui
        // mapped in memory until the dropdown is destroyed.
        HWND hwndDropDown = (fFinalShutDown ? m_pAutoComp->m_hwndDropDown : NULL);

        PostThreadMessage(m_idThread, ACM_QUIT, 0, (LPARAM)hwndDropDown);
    }
}

//+-------------------------------------------------------------------------
// Synchroniously shutdown the background thread
//
// Note: this is no longer synchronous because we now orphan this object
// when the associated autocomplet shuts down.
// 
//--------------------------------------------------------------------------
void CACThread::SyncShutDownBGThread()
{
    _SendAsyncShutDownMsg(TRUE);

    // Block shutdown if background thread is about to use this variable
    ENTERCRITICAL;
    m_pAutoComp = NULL;
    LEAVECRITICAL;

    if (m_hCreateEvent)
    {
        CloseHandle(m_hCreateEvent);
        m_hCreateEvent = NULL;
    }
}

void CACThread::_FreeThreadData()
{
    if (m_hdpa_list)
    {
        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
        m_hdpa_list = NULL;
    }

    if (m_pszSearch)
    {
        LocalFree(m_pszSearch);
        m_pszSearch = NULL;
    }

    InterlockedExchange(&m_idThread, 0);
    InterlockedExchange(&m_fWorkItemQueued, 0);
}

DWORD WINAPI CACThread::_ThreadProc(void *pv)
{
    CACThread *pThis = (CACThread *)pv;
    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        pThis->_ThreadLoop();
    }
    pThis->Release();
    SHCoUninitialize(hrInit);

    return 0;
}


HRESULT CACThread::_ProcessMessage(MSG * pMsg, DWORD * pdwTimeout, BOOL * pfStayAlive)
{
    TraceMsg(AC_GENERAL, "AutoCompleteThread: Message %x received.", pMsg->message);

    switch (pMsg->message)
    {
    case ACM_STARTSEARCH:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search started.");
        *pdwTimeout = INFINITE;
        _Search((LPWSTR)pMsg->lParam, (DWORD)pMsg->wParam);
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search completed.");
        break;

    case ACM_STOPSEARCH:
        while (PeekMessage(pMsg, pMsg->hwnd, ACM_STOPSEARCH, ACM_STOPSEARCH, PM_REMOVE))
        {
            NULL;
        }
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search stopped.");
        break;

    case ACM_SETFOCUS:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Got Focus.");
        *pdwTimeout = INFINITE;
        break;

    case ACM_KILLFOCUS:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Lost Focus.");
        *pdwTimeout = AC_TIMEOUT;
        break;

    case ACM_QUIT:
        {
            TraceMsg(AC_GENERAL, "AutoCompleteThread: ACM_QUIT received.");
            *pfStayAlive = FALSE;

            //
            // If a hwnd was passed in then we are shutting down and we need to
            // wait until the dropdown window is destroyed before exiting this
            // thread.  That way browseui will stay mapped in memory.
            //
            HWND hwndDropDown = (HWND)pMsg->lParam;
            if (hwndDropDown)
            {
                //  We wait 5 seconds for the window to go away, checking every 100ms
                int cSleep = 50;
                while (IsWindow(hwndDropDown) && (--cSleep > 0))
                {
                    MsgWaitForMultipleObjects(0, NULL, FALSE, 100, QS_TIMER);
                }
            }
        }
        break;

    default:
        // pump any ole-based window message that might also be on this thread
        TranslateMessage(pMsg);
        DispatchMessage(pMsg);
        break;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Message pump for the background thread
//--------------------------------------------------------------------------
HRESULT CACThread::_ThreadLoop()
{
    MSG Msg;
    DWORD dwTimeout = INFINITE;
    BOOL fStayAlive = TRUE;

    TraceMsg(AC_WARNING, "AutoComplete service thread started.");

    //
    // We need to call a window's api for a message queue to be created
    // so we call peekmessage.  Then we get the thread id and thread handle
    // and we signal an event to tell the forground thread that we are listening.
    //
    while (PeekMessage(&Msg, NULL, ACM_FIRST, ACM_LAST, PM_REMOVE))
    {
        // purge any messages we care about from previous owners of this thread.
    }

    // The forground thread needs this is so that it can post us messages
    InterlockedExchange(&m_idThread, GetCurrentThreadId());

    if (m_hCreateEvent)
    {
        SetEvent(m_hCreateEvent);
    }

    HANDLE hThread = GetCurrentThread();
    int nOldPriority = GetThreadPriority(hThread);
    SetThreadPriority(hThread, THREAD_PRIORITY_BELOW_NORMAL);

    while (fStayAlive)
    {
        while (fStayAlive && PeekMessage(&Msg, NULL, 0, (UINT)-1, PM_NOREMOVE))
        {
            if (-1 != GetMessage(&Msg, NULL, 0, 0))
            {
                if (!Msg.hwnd)
                {
                    // No hwnd means it's a thread message, so it's ours.
                    _ProcessMessage(&Msg, &dwTimeout, &fStayAlive);
                }
                else
                {
                    // It has an hwnd then it's not ours.  We will not allow windows on our thread.
                    // If anyone creates their windows on their thread, file a bug against them
                    // to remove it.
                }
            }
        }

        if (fStayAlive)
        {
            TraceMsg(AC_GENERAL, "AutoCompleteThread: Sleeping for%s.", dwTimeout == INFINITE ? "ever" : " one minute");
            DWORD dwWait = MsgWaitForMultipleObjects(0, NULL, FALSE, dwTimeout, QS_ALLINPUT);
#ifdef DEBUG
            switch (dwWait)
            {
            case 0xFFFFFFFF:
                ASSERT(dwWait != 0xFFFFFFFF);
                break;

            case WAIT_TIMEOUT:
                TraceMsg(AC_GENERAL, "AutoCompleteThread: Timeout expired.");
                break;
            }
#endif
            fStayAlive = (dwWait == WAIT_OBJECT_0);
        }
    }

    TraceMsg(AC_GENERAL, "AutoCompleteThread: Thread dying.");

    _FreeThreadData();
    SetThreadPriority(hThread, nOldPriority);


    // Purge any remaining messages before returning this thread to the pool.
    while (PeekMessage(&Msg, NULL, ACM_FIRST, ACM_LAST, PM_REMOVE))
    {}

    TraceMsg(AC_WARNING, "AutoCompleteThread: Thread dead.");
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns true if the search string matches one or more characters of a
// prefix that we filter out matches to
//--------------------------------------------------------------------------
BOOL CACThread::MatchesSpecialPrefix(LPCWSTR pszSearch)
{
    BOOL fRet = FALSE;
    int cchSearch = lstrlen(pszSearch);
    for (int i = 0; i < ARRAYSIZE(g_rgSpecialPrefix); ++i)
    {
        // See if the search string matches one or more characters of the prefix
        if (cchSearch <= g_rgSpecialPrefix[i].cch && 
            StrCmpNI(g_rgSpecialPrefix[i].psz, pszSearch, cchSearch) == 0)
        {
            fRet = TRUE;
            break;
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Returns the length of the prefix it the string starts with a special
// prefix that we filter out matches to.  Otherwise returns zero.
//--------------------------------------------------------------------------
int CACThread::GetSpecialPrefixLen(LPCWSTR psz)
{
    int nRet = 0;
    int cch = lstrlen(psz);
    for (int i = 0; i < ARRAYSIZE(g_rgSpecialPrefix); ++i)
    {
        if (cch >= g_rgSpecialPrefix[i].cch && 
            StrCmpNI(g_rgSpecialPrefix[i].psz, psz, g_rgSpecialPrefix[i].cch) == 0)
        {
            nRet = g_rgSpecialPrefix[i].cch;
            break;
        }
    }
    return nRet;
}

//+-------------------------------------------------------------------------
// Returns the next autocomplete string
//--------------------------------------------------------------------------
HRESULT CACThread::_Next(LPWSTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    ASSERT(pulSortIndex);

    HRESULT hr;

    // Use the new interface if we have it
    if (m_peac)
    {
        hr = m_peac->NextItem(pszUrl, cchMax, pulSortIndex);
    }

    // Fall back to the old IEnumString interface
    else
    {
        LPWSTR pszNext;
        ULONG ulFetched;

        hr = m_pes->Next(1, &pszNext, &ulFetched);
        if (S_OK == hr)
        {
            StrCpyN(pszUrl, pszNext, cchMax);
            if (pulSortIndex)
            {
                *pulSortIndex = 0;
            }
            CoTaskMemFree(pszNext);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
// Searches for items that match pszSearch.
//--------------------------------------------------------------------------
void CACThread::_Search
(
    LPWSTR pszSearch,   // String to search for (we must free this)
    DWORD dwOptions     // ACO_* flags
)
{
    if (pszSearch)
    {
        TraceMsg(AC_GENERAL, "CACThread(BGThread)::_Search(pszSearch=0x%x)", pszSearch);

        // Save the search string in our thread data so it is still freed if this thread is killed
        m_pszSearch = pszSearch;

        // If we were passed a wildcard string, then everything matches
        BOOL fWildCard = ((pszSearch[0] == CH_WILDCARD) && (pszSearch[1] == L'\0'));

        // To avoid huge number of useless matches, avoid matches
        // to common prefixes
        BOOL fFilter = (dwOptions & ACO_FILTERPREFIXES) && MatchesSpecialPrefix(pszSearch);
        BOOL fAppendOnly = IsFlagSet(dwOptions, ACO_AUTOAPPEND) && IsFlagClear(dwOptions, ACO_AUTOSUGGEST);

        if (m_pes)    // paranoia
        {
            // If this fails, the m_pes->Next() will likely do something
            // bad, so we will avoid it altogether.
            if (SUCCEEDED(m_pes->Reset()))
            {
                BOOL fStopped = FALSE;
                m_dwSearchStatus = 0;

                _DoExpand(pszSearch);
                int cchSearch = lstrlen(pszSearch);

                WCHAR szUrl[MAX_URL_STRING];
                ULONG ulSortIndex;

                while (!fStopped && IsFlagClear(m_dwSearchStatus, SRCH_LIMITREACHED) &&
                       (_Next(szUrl, ARRAYSIZE(szUrl), &ulSortIndex) == S_OK))
                {
                    //
                    // First check for a simple match
                    //
                    if (fWildCard ||
                        (StrCmpNI(szUrl, pszSearch, cchSearch) == 0) &&

                        // Filter out matches to common prefixes
                        (!fFilter || GetSpecialPrefixLen(szUrl) == 0))
                    {
                        _AddToList(szUrl, 0, ulSortIndex);
                    }

                    // If the dropdown is enabled, check for matches after common prefixes.
                    if (!fAppendOnly)
                    {
                        //
                        // Also check for a match if we skip the protocol. We
                        // assume that szUrl has been cononicalized (protocol
                        // in lower case).
                        //
                        LPCWSTR psz = szUrl;
                        if (StrCmpN(szUrl, L"http://", 7) == 0) 
                        {
                            psz += 7;
                        }
                        if (StrCmpN(szUrl, L"https://", 8) == 0 ||
                            StrCmpN(szUrl, L"file:///", 8) == 0)
                        {
                            psz += 8;
                        }

                        if (psz != szUrl &&
                            StrCmpNI(psz, pszSearch, cchSearch) == 0 &&

                            // Filter out "www." prefixes
                            (!fFilter || GetSpecialPrefixLen(psz) == 0))
                        {
                            _AddToList(szUrl, (int)(psz - szUrl), ulSortIndex);
                        }

                        //
                        // Finally check for a match if we skip "www." after
                        // the optional protocol
                        //
                        if (StrCmpN(psz, L"www.", 4) == 0 &&
                            StrCmpNI(psz + 4, pszSearch, cchSearch) == 0)
                        {
                            _AddToList(szUrl, (int)(psz + 4 - szUrl), ulSortIndex);
                        }
                    }

                    // Check to see if the search was canceled
                    MSG msg;
                    fStopped = PeekMessage(&msg, NULL, ACM_STOPSEARCH, ACM_STOPSEARCH, PM_NOREMOVE);
    #ifdef DEBUG
    fStopped = FALSE;
                    if (fStopped)
                        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search TERMINATED");
    #endif
                }

                if (fStopped)
                {
                    // Search aborted so free the results
                    if (m_hdpa_list)
                    { 
                        // clear the list
                        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
                        m_hdpa_list = NULL;
                    }
                }
                else
                {
                    //
                    // Sort the results and remove duplicates
                    //
                    if (m_hdpa_list)
                    {
                        DPA_Sort(m_hdpa_list, _DpaCompare, 0);

                        //
                        // Perge duplicates. 
                        //
                        for (int i = DPA_GetPtrCount(m_hdpa_list) - 1; i > 0; --i)
                        {
                            CACString& rStr1 = *(CACString*)DPA_GetPtr(m_hdpa_list, i-1);
                            CACString& rStr2 = *(CACString*)DPA_GetPtr(m_hdpa_list, i);

                            // Since URLs are case sensitive, we can't ignore case.                    
                            if (rStr1.StrCmpI(rStr2) == 0)
                            {
                                // We have a match, so keep the longest string.
                                if (rStr1.GetLength() > rStr2.GetLength())
                                {
                                    // Use the smallest sort index
                                    if (rStr2.GetSortIndex() < rStr1.GetSortIndex())
                                    {
                                        rStr1.SetSortIndex(rStr2.GetSortIndex());
                                    }
                                    DPA_DeletePtr(m_hdpa_list, i);
                                    rStr2.Release();
                                }
                                else
                                {
                                    // Use the smallest sort index
                                    if (rStr1.GetSortIndex() < rStr2.GetSortIndex())
                                    {
                                        rStr2.SetSortIndex(rStr1.GetSortIndex());
                                    }
                                    DPA_DeletePtr(m_hdpa_list, i-1);
                                    rStr1.Release();
                                }
                            }
                            else
                            {
                                //
                                // Special case: If this is a web site and the entries
                                // are identical except one has an extra slash on the end
                                // from a redirect, remove the redirected one.
                                //
                                int cch1 = rStr1.GetLengthToCompare();
                                int cch2 = rStr2.GetLengthToCompare();
                                int cchDiff = cch1 - cch2;

                                if (
                                    // Length must differ by one
                                    (cchDiff == 1 || cchDiff == -1) &&

                                    // One string must have a terminating slash
                                    ((cch1 > 0 && rStr1[rStr1.GetLength() - 1] == L'/') ||
                                     (cch2 > 0 && rStr2[rStr2.GetLength() - 1] == L'/')) &&

                                    // Must be a web site
                                    ((StrCmpN(rStr1, L"http://", 7) == 0 || StrCmpN(rStr1, L"https://", 8) == 0) ||
                                     (StrCmpN(rStr2, L"http://", 7) == 0 || StrCmpN(rStr2, L"https://", 8) == 0)) &&

                                    // Must be identical up to the slash (ignoring prefix)
                                    StrCmpNI(rStr1.GetStrToCompare(), rStr2.GetStrToCompare(), (cchDiff > 0) ? cch2 : cch1) == 0)
                                {
                                    // Remove the longer string with the extra slash
                                    if (cchDiff > 0)
                                    {
                                        // Use the smallest sort index
                                        if (rStr1.GetSortIndex() < rStr2.GetSortIndex())
                                        {
                                            rStr2.SetSortIndex(rStr1.GetSortIndex());
                                        }
                                        DPA_DeletePtr(m_hdpa_list, i-1);
                                        rStr1.Release();
                                    }
                                    else
                                    {
                                        // Use the smallest sort index
                                        if (rStr2.GetSortIndex() < rStr1.GetSortIndex())
                                        {
                                            rStr1.SetSortIndex(rStr2.GetSortIndex());
                                        }
                                        DPA_DeletePtr(m_hdpa_list, i);
                                        rStr2.Release();
                                    }
                                }
                            }
                        }
                    }

                    // Pass the results to the foreground thread
                    ENTERCRITICAL;
                    if (m_pAutoComp)
                    {
                        HWND hwndEdit = m_pAutoComp->m_hwndEdit;
                        UINT uMsgSearchComplete = m_pAutoComp->m_uMsgSearchComplete;
                        LEAVECRITICAL;

                        // Unix loses keys if we post the message, so we send the message
                        // outside our critical section
                        SendMessage(hwndEdit, uMsgSearchComplete, m_dwSearchStatus, (LPARAM)m_hdpa_list);
                    }
                    else
                    {
                        LEAVECRITICAL;

                        // We've been orphaned, so free the list and bail
                        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
                    }

                    // The foreground thread owns the list now
                    m_hdpa_list = NULL;
                }
            } 
            else
            {
                ASSERT(0);    // m_pes->Reset Failed!!
            }
        }

        // We must free the search string
        m_pszSearch = NULL;

        // Note if the thread is killed here, we leak the string
        // but at least we will not try to free it twice (which is worse)
        // because we nulled m_pszSearch first.
        LocalFree(pszSearch);
    }
}

//+-------------------------------------------------------------------------
// Used to sort items alphabetically
//--------------------------------------------------------------------------
int CALLBACK CACThread::_DpaCompare(void *p1, void *p2, LPARAM lParam)
{
    CACString* ps1 = (CACString*)p1;
    CACString* ps2 = (CACString*)p2;

    return ps1->StrCmpI(*ps2);
}


//+-------------------------------------------------------------------------
// Adds a string to our HDPA.  Returns TRUE is successful.
//--------------------------------------------------------------------------
BOOL CACThread::_AddToList
(
    LPTSTR pszUrl,    // string to add
    int cchMatch,     // offset into string where the match occurred
    ULONG ulSortIndex // controls order of items displayed
)
{
    TraceMsg(AC_GENERAL, "CACThread(BGThread)::_AddToList(pszUrl = %s)", 
        (pszUrl ? pszUrl : TEXT("(null)")));

    BOOL fRet = TRUE;

    //
    // Create a new list if necessary.
    //
    if (!m_hdpa_list)
    {
        m_hdpa_list = DPA_Create(AC_LIST_GROWTH_CONST);
    }

    if (m_hdpa_list && DPA_GetPtrCount(m_hdpa_list) < AC_GIVEUP_COUNT)
    {
        CACString* pStr = CreateACString(pszUrl, cchMatch, ulSortIndex);
        if (pStr)
        {
            if (DPA_AppendPtr(m_hdpa_list, pStr) == -1)
            {
                pStr->Release();
                m_dwSearchStatus |= SRCH_LIMITREACHED;
                fRet = FALSE;
            }

            // If we have a nonzero sort index, the forground thread will need
            // to use it to order the results
            else if (ulSortIndex)
            {
                m_dwSearchStatus |= SRCH_USESORTINDEX;
            }
        }
    }
    else
    {
        m_dwSearchStatus |= SRCH_LIMITREACHED;
        fRet = FALSE;
    }

    return fRet;
}

//+-------------------------------------------------------------------------
// This function will attempt to use the autocomplete list to bind to a
// location in the Shell Name Space. If that succeeds, the AutoComplete List
// will then contain entries which are the display names in that ISF.
//--------------------------------------------------------------------------
void CACThread::_DoExpand(LPCWSTR pszSearch)
{
    LPCWSTR psz;

    if (!m_pacl)
    {
        //
        // Doesn't support IAutoComplete, doesn't have Expand method.
        //
        return;
    }

    if (*pszSearch == 0)
    {
        //
        // No string means no expansion necessary.
        //
        return;
    }

    //
    // psz points to last character.
    //
    psz = pszSearch + lstrlen(pszSearch);
    psz = CharPrev(pszSearch, psz);

    //
    // Search backwards for an expand break character.
    //
    while (psz != pszSearch && *psz != TEXT('/') && *psz != TEXT('\\'))
    {
        psz = CharPrev(pszSearch, psz);
    }

    if (*psz == TEXT('/') || *psz == TEXT('\\'))
    {
        SHSTR ss;

        psz++;
        if (SUCCEEDED(ss.SetStr(pszSearch)))
        {
            //
            // Trim ss so that it contains everything up to the last
            // expand break character.
            //
            LPTSTR pszTemp = ss.GetInplaceStr();

            pszTemp[psz - pszSearch] = TEXT('\0');

            //
            // Call expand on the string.
            //
            m_pacl->Expand(ss);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\address.h ===
/**************************************************************\
    FILE: address.h

    DESCRIPTION:
        The Class CAddressBand exists to support a "Address" Band
    ToolBar.  This will be used in the Browser's toolbar or can
    be used in the Start Menu.
\**************************************************************/

#ifndef _ADDRESS_H
#define _ADDRESS_H

#include "bands.h"
#include "bandprxy.h"


///////////////////////////////////////////////////////////////////
// #DEFINEs

///////////////////////////////////////////////////////////////////
// Data Structures

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CAddressBand

    DESCRIPTION:
        This Class CAddressBand exists to support a "Address" Band
    ToolBar.  This will be used in the Browser's toolbar or can
    be used in the Start Menu/Taskbar.  If the Band is part of
    a Browser toolbar, any modifications made to the AddressBar
    will go the the browser window.  

        By default, the this AddressBand will not point to a
    browser window when it is on the Taskbar or Start Menu.  
    Anything "executed" in the AddressBar will create a new
    browser window.  Future support may allow for the AddressBand
    in the taskbar/start menu to reference a currently existing
    browser window.
\**************************************************************/
class CAddressBand 
                : public CToolBand
                , public IWinEventHandler
                , public IAddressBand
                , public IInputObjectSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                        OLECMD rgCmds[], OLECMDTEXT *pcmdtext);        // Interface forwarding
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);        // Interface forwarding

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO(void);
    
    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IShellToolband methods ***
    STDMETHOD(GetBandInfo)    (THIS_ DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) ;
    
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IAddressBand methods ***
    virtual STDMETHODIMP FileSysChange(DWORD dwEvent, LPCITEMIDLIST * ppidl);        
    virtual STDMETHODIMP Refresh(VARIANT * pvarType);        

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_AddressBand; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressBand();
    virtual ~CAddressBand();

    HRESULT _CreateAddressBand(IUnknown * punkSite);
    static LRESULT CALLBACK _ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _ComboExEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _CreateGoButton();
    void _InitGoButton();
    void _OnGetInfoTip(LPNMTBGETINFOTIP pnmTT);


    // Friend Functions
    friend HRESULT CAddressBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    BOOL                _fVertical :1;

    // Only valid if _fInited == TRUE
    HWND                _hwndEdit;      // Address edit control child Window
    HWND                _hwndCombo;     // Address combo control child Window
    BOOL                _fVisible:1;    // TRUE when the toolbar is visible.
    BOOL                _fGoButton:1;   // TRUE if go button is visible
    IAddressEditBox*    _paeb;          // IAddressEditBox that controls
    IWinEventHandler*   _pweh;          // IWinEventHandler interface for the AddressEditBox object.  (Cached for Perf)
    HIMAGELIST          _himlDefault;   // default gray-scale go button
    HIMAGELIST          _himlHot;       // color go button
    HWND                _hwndTools;     // toolbar containing go button
    WNDPROC             _pfnOldWndProc; // Former WndProc of ComboBoxEx
    WNDPROC             _pfnOldEditProc;// Former WndProc of Edit control in ComboBoxEx
};


#endif /* _ADDRESS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\addrlist.cpp ===
/**************************************************************\
    FILE: addrlist.cpp

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.
\**************************************************************/

#include "priv.h"
#include "util.h"
#include "itbdrop.h"
#include "autocomp.h"
#include "addrlist.h"
#include "apithk.h"
#include "shui.h"
#include "shlguid.h"

CAddressList::CAddressList() : _cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pbp);
}

CAddressList::~CAddressList()
{
    if (_pbp)
        _pbp->Release();
    if (_pbs)
        _pbs->Release();
    if (_pshuUrl)
        delete _pshuUrl;
}

ULONG CAddressList::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CAddressList::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAddressList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IWinEventHandler) ||
        IsEqualIID(riid, IID_IAddressList))
    {
        *ppvObj = SAFECAST(this, IAddressList*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//================================
//  ** IWinEventHandler Interface ***

/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressList::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
        lres = _OnNotify((LPNMHDR)lParam);
        break;
    }

    if (plres)
        *plres = lres;

    return S_OK;
}


//================================
// *** IAddressList Interface ***

/****************************************************\
    FUNCTION: Connect

    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/
HRESULT CAddressList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    HRESULT hr = S_OK;

    ASSERT(hwnd);
    _fVisible = fConnect;
    _hwnd = hwnd;

    // Copy the (IBandProxy *) parameter
    if (_pbp)
        _pbp->Release();
    _pbp = pbp;
    if (_pbp)
        _pbp->AddRef();

    if (_pbs)
        _pbs->Release();
    _pbs = pbs;
    if (_pbs)
        _pbs->AddRef();

    if (fConnect)
    {
        //
        // Initial combobox parameters.
        //
        _InitCombobox();
    }
    else
    {
        // Remove contents of the List
        _PurgeComboBox();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _InitCombobox

    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/
void CAddressList::_InitCombobox()
{
     SendMessage(_hwnd, CB_SETDROPPEDWIDTH, 200, 0L);
     SendMessage(_hwnd, CB_SETEXTENDEDUI, TRUE, 0L);
     SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOSIZELIMIT, CBES_EX_NOSIZELIMIT);
}


/****************************************************\
    FUNCTION: _PurgeComboBox

    DESCRIPTION:
        Removes all items from the combobox.
\****************************************************/
void CAddressList::_PurgeComboBox()
{
    if (_hwnd)
    {
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
    }
}

/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
        This function will handle WM_COMMAND messages.
\****************************************************/
LRESULT CAddressList::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (uCmd)
    {
        case CBN_DROPDOWN:
            {
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                //
                // DOH! The user wants to see the full combo contents.
                // Better go fill it in now.
                //
                _Populate();
                SetCursor(hCursorOld);
            }
            break;
    }
    return 0;
}


void ChangeUrl(LPCTSTR pszUrl, LPTSTR pszDisplayName, DWORD cchSize)
{
    TCHAR szTemp[MAX_URL_STRING];

    StrCpyN(szTemp, pszUrl, ARRAYSIZE(szTemp));     // This is necessary because pszUrl points into the buffer of pszDisplayName
    StrCpyN(pszDisplayName, szTemp, cchSize);
}


/****************************************************\
    FUNCTION: NavigationComplete

    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CAddressList::NavigationComplete(LPVOID pvCShellUrl)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    CShellUrl * psu = (CShellUrl *) pvCShellUrl;
    LPITEMIDLIST pidl;
    ASSERT(pvCShellUrl);
    hr = psu->GetDisplayName(szDisplayName, SIZECHARS(szDisplayName));

    if (SUCCEEDED(hr))
    {
        //
        // Don't display the url to internal error pages.  The url that should get
        // displayed is appended after the #.
        //
        // All error urls start with res:// so do a quick check first.
        //
        BOOL fChangeURL = TRUE;
        if (TEXT('r') == szDisplayName[0] && TEXT('e') == szDisplayName[1])
        {
            if (IsErrorUrl(szDisplayName))
            {
                TCHAR* pszUrl = StrChr(szDisplayName, TEXT('#'));
                if (pszUrl)
                {
                    pszUrl += 1;

                    DWORD dwScheme = GetUrlScheme(pszUrl);
                    fChangeURL = ((URL_SCHEME_HTTP == dwScheme) ||
                                  (URL_SCHEME_HTTPS == dwScheme) ||
                                  (URL_SCHEME_FTP == dwScheme) ||
                                  (URL_SCHEME_GOPHER == dwScheme));

                    // Don't blast in the stuff after the # into address bar
                    // unless it is a 'safe' url.  If it's not safe leave the
                    // addressbar alone to preserve what the user typed in.
                    //
                    // The issue here is that a web page could navigate to our internal
                    // error page with "format c:" after the '#'.  The error page
                    // suggests that the user refreshed the page which would be very bad!
                    if (fChangeURL)
                    {
                        ChangeUrl(pszUrl, szDisplayName, ARRAYSIZE(szDisplayName));
                    }
                }
            }
        }

        if (fChangeURL)
        {
            SHRemoveURLTurd(szDisplayName);
            SHCleanupUrlForDisplay(szDisplayName);
 
            hr = psu->GetPidl(&pidl);
            if (SUCCEEDED(hr))
            {
                COMBOBOXEXITEM cbexItem = {0};
                cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                cbexItem.iItem = -1;
                cbexItem.pszText = szDisplayName;
                cbexItem.cchTextMax = ARRAYSIZE(szDisplayName);

                hr = _GetPidlIcon(pidl, &(cbexItem.iImage), &(cbexItem.iSelectedImage));
                SendMessage(_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);

                ILFree(pidl);
            }
        }
    }

    TraceMsg(TF_BAND|TF_GENERAL, "CAddressList: NavigationComplete(), URL=%s", szDisplayName);
    return hr;
}

/*******************************************************************
    FUNCTION: _MoveAddressToTopOfList

    PARAMETERS:
        iSel - index of item in combo box to move

    DESCRIPTION:
        Moves the specified selection in the combo box
    to be the first item in the combo box
********************************************************************/
BOOL CAddressList::_MoveAddressToTopOfList(int iSel)
{
    BOOL fRet = FALSE;

    ASSERT(iSel >= 0);   // must have valid index

    COMBOBOXEXITEM cbexItem = {0};
    TCHAR szAddress[MAX_URL_STRING+1];

    cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
    cbexItem.pszText = szAddress;
    cbexItem.cchTextMax = ARRAYSIZE(szAddress);
    cbexItem.iItem = iSel;

    
    // get the specified item from combo box
    if (SendMessage(_hwnd,CBEM_GETITEM,0,(LPARAM) &cbexItem)) {

        SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)iSel, (LPARAM)0);

        // re-insert it at index 0 to put it at the top
        cbexItem.iItem = 0;

        // sending CBEM_INSERTITEM should return the index we specified
                // (0) if successful
        fRet = (SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0,
            (LPARAM)(LPVOID)&cbexItem) == 0);
    }

    return fRet;
}



/*******************************************************************
    FUNCTION: _ComboBoxInsertURL

    DESCRIPTION:
        Adds the specified URL to the top of the address bar
    combo box.  Limits the number of URLs in combo box to
    nMaxComboBoxSize.
********************************************************************/
void CAddressList::_ComboBoxInsertURL(LPCTSTR pszURL, int cchStrSize, int nMaxComboBoxSize)
{
    // Since we own it and it's populated,
    // we will add it directly to the ComboBox.
    int iPrevInstance;

    int iImage, iSelectedImage ;

    COMBOBOXEXITEM cbexItem = {0};
    cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
    cbexItem.iItem = 0;

    cbexItem.cchTextMax = cchStrSize;
    cbexItem.pszText = (LPTSTR)pszURL;

    _GetUrlUI(NULL, (LPTSTR)pszURL, &iImage, &iSelectedImage);

    cbexItem.iImage = iImage;
    cbexItem.iSelectedImage = iSelectedImage;


    iPrevInstance = (int)SendMessage(_hwnd, CB_FINDSTRINGEXACT, (WPARAM)-1,  (LPARAM)pszURL);
    if (iPrevInstance != CB_ERR) {
        _MoveAddressToTopOfList(iPrevInstance);
        return;
    }

    // insert the URL as the first item in combo box
    SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);

    // limit number of items in combo box to nMaxComboBoxSize
    if (ComboBox_GetCount(_hwnd) > nMaxComboBoxSize)
    {
        // if we're ever over the limit, we should only be over the limit
        // by exactly one item
        ASSERT(ComboBox_GetCount(_hwnd) == nMaxComboBoxSize+1);

        // if over the limit, delete the least recently used
        // (the one with the highest index)

        SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)nMaxComboBoxSize, (LPARAM)0);

    }
}


/*******************************************************************
    FUNCTION: SetToListIndex

    DESCRIPTION:
        This function will set the CShellUrl parameter to the item
    in the Drop Down list that is indexed by nIndex.
********************************************************************/
HRESULT CAddressList::SetToListIndex(int nIndex, LPVOID pvShelLUrl)
{
    HRESULT hr = S_OK;
    TCHAR szBuffer[MAX_URL_STRING];
    CShellUrl * psuURL = (CShellUrl *) pvShelLUrl;

    if (SUCCEEDED(GetCBListIndex(_hwnd, nIndex, szBuffer, SIZECHARS(szBuffer))))
    {
        hr = psuURL->ParseFromOutsideSource(szBuffer, SHURL_FLAGS_NOUI);
        ASSERT(SUCCEEDED(hr));  // We should not have added it to the Drop Down list if it's invalid.
    }

    return hr;
}

HRESULT CAddressList::FileSysChangeAL(DWORD dw, LPCITEMIDLIST *ppidl)
{
    return S_OK;
}


/****************************************************\
    FUNCTION: GetCBListIndex

    DESCRIPTION:
        This function will get the text of a specified
    element in the combobox.
\****************************************************/
HRESULT GetCBListIndex(HWND hwnd, int iItem, LPTSTR szAddress, int cchAddressSize)
{
    HRESULT hr = E_FAIL;
    COMBOBOXEXITEM cbexItem = {0};

    cbexItem.mask = CBEIF_TEXT;
    cbexItem.pszText = szAddress;
    cbexItem.cchTextMax = cchAddressSize;
    cbexItem.iItem = iItem;

    if (SendMessage(hwnd, CBEM_GETITEM, 0, (LPARAM) &cbexItem))
        hr = S_OK;

    return hr;
}


// Helper Function
// We need to really becareful of perf in this function.
HRESULT CAddressList::_GetUrlUI(CShellUrl *psu, LPCTSTR szUrl, int *piImage, int *piSelectedImage)
{
    CShellUrl * psuUrl;
    HRESULT hr = E_FAIL;

    if (psu)
        psuUrl = psu;
    else
    {
        psuUrl = new CShellUrl();
        if (psuUrl)
        {
            // Set the parent for error messageboxes.  Note that this could end up disabing the taskbar.
            // If this is deemed to be a problem we can first check to see where the addressbar is hosted.
            psuUrl->SetMessageBoxParent(_hwnd);

            SetDefaultShellPath(psuUrl);
        }
    }

    //Initialize the values to 0
    *piImage = 0;
    *piSelectedImage = 0;

    //if object is not created return with default value
    if (!psuUrl)
        return E_OUTOFMEMORY;

#ifdef DISABLED // Why not show the correct icon for removable drives?
    int iDrive;

    // See if we have a drive specified in the path
    if ((iDrive = PathGetDriveNumber(szUrl)) >= 0)
    {
        // See if the drive is removable ?
        if(DriveType(iDrive) == DRIVE_REMOVABLE)
            hr = S_OK;    //Drive is removable so pass the default icons
    }
#endif

    // Do we still need to get the icons?
    if (FAILED(hr))
    {
        // Yes, so try the fast way first.
        hr = _GetFastPathIcons(szUrl, piImage, piSelectedImage);
        if (FAILED(hr))
        {
            LPITEMIDLIST pidl = NULL;

            // If that failed because it the string probably uses advanced parsing, 
            // let CShellUrl do it the slower but more thurough way.
            hr = psuUrl->ParseFromOutsideSource(szUrl, SHURL_FLAGS_NOUI);
            if(SUCCEEDED(hr))
                hr = psuUrl->GetPidl(&pidl);

            if(SUCCEEDED(hr))
            {
                hr = _GetPidlIcon(pidl, piImage, piSelectedImage);
                ILFree(pidl);
            }
        }
    }

    if (psu != psuUrl)
        delete psuUrl;

    return hr;
}


// IECreateFromPath() and CShellUrl::ParseFromOutsideSource() both
// touch the disk which causes unconnected network cases to be really
// slow.  This will create icons for file system paths w/o hitting
// the disk.
HRESULT CAddressList::_GetFastPathIcons(LPCTSTR pszPath, int *piImage, int *piSelectedImage)
{
    SHFILEINFO shFileInfo = {0};

    // SHGetFileInfo() with those flags will be fast because it's won't filter out
    // garbage passed to it.  So it will think URLs are actually relative paths
    // and accept them.  We will fall back to the slow advanced parser which is still
    // fast with URLs.
    if (PathIsRelative(pszPath))
        return E_FAIL;

    HIMAGELIST himl = (HIMAGELIST) SHGetFileInfo(pszPath, FILE_ATTRIBUTE_DIRECTORY, &shFileInfo, sizeof(shFileInfo), (SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES));
    if (!himl || !shFileInfo.iIcon)
        return E_FAIL;

    *piImage = shFileInfo.iIcon;
    *piSelectedImage = shFileInfo.iIcon;
    // I don't need to free himl.

    return S_OK;
}


HRESULT CAddressList::_GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
    if (SUCCEEDED(hr))
    {
        *piImage = IEMapPIDLToSystemImageListIndex(psfParent, pidlChild, piSelectedImage);
        psfParent->Release();
    }
    return hr;
}

LPITEMIDLIST CAddressList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl = NULL;
    CShellUrl *psuUrl = new CShellUrl();
    if (psuUrl)
    {
        // Set the parent for error messageboxes.  Note that this could end up disabing the taskbar.
        // If this is deemed to be a problem we can first check to see where the addressbar is hosted.
        psuUrl->SetMessageBoxParent(_hwnd);

        HRESULT hr = SetDefaultShellPath(psuUrl);
        if (SUCCEEDED(hr))
        {
            hr = psuUrl->ParseFromOutsideSource(pnmcbe->szText, SHURL_FLAGS_NOUI, NULL);
            if (SUCCEEDED(hr))
            {
                hr = psuUrl->GetPidl(&pidl);
            }
        }

        delete psuUrl;
    }
    return pidl;
}

LRESULT CAddressList::_OnDragBeginA(LPNMCBEDRAGBEGINA pnmcbe)
{
    NMCBEDRAGBEGINW  nmcbew;

    nmcbew.hdr = pnmcbe->hdr;
    nmcbew.iItemid = pnmcbe->iItemid;
    SHAnsiToUnicode(pnmcbe->szText, nmcbew.szText, SIZECHARS(nmcbew.szText));

    return _OnDragBeginW(&nmcbew);
}

#ifdef UNIX
extern "C" LPITEMIDLIST UnixUrlToPidl(UINT uiCP, LPCTSTR pszUrl, LPCWSTR pszLocation);
#endif

LRESULT CAddressList::_OnDragBeginW(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl = _GetDragDropPidl(pnmcbe);
#ifdef UNIX
    // for UNIX we fake a URL pidl so we create a .url instead of a .lnk
    if (!IsURLChild(pidl, TRUE))
    {
        LPITEMIDLIST pidl1;
        TCHAR szPath[MAX_PATH];
        StrCpyN(szPath, TEXT("file://"), 8);
        SHGetPathFromIDList(pidl, &szPath[7]);
        pidl1 = UnixUrlToPidl(CP_ACP, szPath, NULL);
        if (pidl1)
    {
            ILFree(pidl);
            pidl = pidl1;
        }
    }
#endif
    if (pidl) 
    {
        IOleCommandTarget *pcmdt = NULL;

        IUnknown *punk;
        if (_pbp && SUCCEEDED(_pbp->GetBrowserWindow(&punk)))
        {
            punk->QueryInterface(IID_IOleCommandTarget, (void **)&pcmdt);
            punk->Release(); 
        }

        DoDragDropWithInternetShortcut(pcmdt, pidl, _hwnd);

        if (pcmdt)
            pcmdt->Release();

        ILFree(pidl);
    }

    return 0;
}

// handle WM_NOTIFY messages.
LRESULT CAddressList::_OnNotify(LPNMHDR pnm)
{
    LRESULT lReturn = 0;

    switch (pnm->code)
    {
    case NM_SETCURSOR:
        if (!SendMessage(_hwnd, CBEM_GETEXTENDEDSTYLE, 0, 0) & CBES_EX_NOEDITIMAGE)
        {
            RECT rc;
            POINT pt;
            int cx, cy;
            GetCursorPos(&pt);
            GetClientRect(_hwnd, &rc);
            MapWindowRect(_hwnd, HWND_DESKTOP, &rc);
            ImageList_GetIconSize((HIMAGELIST)SendMessage(_hwnd, CBEM_GETIMAGELIST, 0, 0), &cx, &cy);

            rc.right = rc.left + cx + GetSystemMetrics(SM_CXEDGE);
            if (PtInRect(&rc, pt)) 
            {
                // this means there's an image, which means we can drag
                SetCursor(LoadHandCursor(0));
                return 1;
            }
        }
        break;

        case CBEN_DRAGBEGINA:
            lReturn = _OnDragBeginA((LPNMCBEDRAGBEGINA)pnm);
            break;

        case CBEN_DRAGBEGINW:
            lReturn = _OnDragBeginW((LPNMCBEDRAGBEGINW)pnm);
            break;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\address.cpp ===
/**************************************************************\
    FILE: address.cpp

    DESCRIPTION:
        The Class CAddressBand exists to support the Address
    ToolBand in either the main browser toolbar or as a
    ShellToolBand.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "aclhist.h"
#include "aclmulti.h"
#include "autocomp.h"
#include "address.h"
#include "shellurl.h"
#include "resource.h"
#include "uemapp.h"
#include <tb_ids.h>
#include "apithk.h"

#include "mluisupp.h"

#define SUPERCLASS CToolBand
#define MIN_DROPWIDTH 200
const static TCHAR c_szAddressBandProp[]   = TEXT("CAddressBand_This");

//=================================================================
// Implementation of CAddressBand
//=================================================================

//===========================
// *** IUnknown Interface ***

HRESULT CAddressBand::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IAddressBand))
    {
        *ppvObj = SAFECAST(this, IAddressBand*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IInputObjectSite))
    {
        *ppvObj = SAFECAST(this, IInputObjectSite*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}


//================================
// *** IDockingWindow Interface ***
/****************************************************\
    FUNCTION: ShowDW

    DESCRIPTION:
        fShow == TRUE means show the window, FALSE means
    remove the window from the view.  The window will
    be created if needed.
\****************************************************/
HRESULT CAddressBand::ShowDW(BOOL fShow)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.

    ShowWindow(_hwnd, fShow ? SW_SHOW : SW_HIDE);

    // Refresh if we are becoming visible because we could have
    // received and ignored FileSysChange() events while
    // we where hidden.
    if (fShow && !_fVisible)
        Refresh(NULL);

    _fVisible = BOOLIFY(fShow);
    return SUPERCLASS::ShowDW(fShow);
}


HRESULT CAddressBand::CloseDW(DWORD dw)
{
    if(_paeb)
        _paeb->Save(0);

    return SUPERCLASS::CloseDW(dw);
}



/****************************************************\
    FUNCTION: SetSite

    DESCRIPTION:
        This function will be called to have this
    Toolband try to obtain enough information about its
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.
\****************************************************/
HRESULT CAddressBand::SetSite(IUnknown *punkSite)
{
    HRESULT hr;
    BOOL fSameHost = punkSite == _punkSite;

    if (!punkSite && _paeb)
    {
        IShellService * pss;

        hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
        if (SUCCEEDED(hr))
        {
            hr = pss->SetOwner(NULL);
            pss->Release();
        }
    }

    hr = SUPERCLASS::SetSite(punkSite);
    if (punkSite && !fSameHost)
    {
        hr = _CreateAddressBand(punkSite);
        // This call failing is expected when the host doesn't have a Browser Window.
    }

    // Set or reset the AddressEditBox's Browser IUnknown.
    if (_paeb)
    {
        IShellService * pss;

        hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
        if (SUCCEEDED(hr))
        {
            // CAddressBand and the BandSite(host) have a ref count cycle.  This cycle
            // is broken when BandSite calls SetSite(NULL) which will cause
            // CAddressBand to break the cycle by releasing it's punk to the BandSite.
            //
            // CAddressEditBox and CAddressBand have the same method of breaking the
            // cycle.  This is accomplished by passing NULL to IAddressEditBox(NULL, NULL)
            // if our caller is breaking the cycle.  This will cause CAddressEditBox to
            // release it's ref count on CAddressBand.
            hr = pss->SetOwner((punkSite ? SAFECAST(this, IAddressBand *) : NULL));
            pss->Release();
        }
    }

    // setsite must succeed
    return S_OK;
}


//================================
// *** IInputObject Methods ***
HRESULT CAddressBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    BOOL fForwardToView = FALSE;
    static CHAR szAccel[2] = "\0"; // Alt-D needs to be localizable

    switch (lpMsg->message)
    {
    case WM_KEYDOWN:    // process these
        if (IsVK_TABCycler(lpMsg))
        {
            // If we are tabbing away, let the edit box know so
            // that it clears its dirty flag.
            SendMessage(_hwndEdit, WM_KEYDOWN, VK_TAB, 0);
        }
        else
        {
            fForwardToView = TRUE;
        }

        switch (lpMsg->wParam)
        {
            case VK_F1:     // help
            {
                //
                // FEATURE: Should add and accelerator for this and simply return S_FALSE, but that
                // causes two instances of the help dialog to come up when focus is in Trident.
                // This is the quick fix for IE5B2.
                //
                IOleCommandTarget* poct;
                IServiceProvider* psp;
                if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_IServiceProvider, (void**)&psp)))
                {
                    if (SUCCEEDED(psp->QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (LPVOID*)&poct)))
                    {
                        poct->Exec(&CGID_ShellBrowser, DVIDM_HELPSEARCH, 0, NULL, NULL);
                        poct->Release();
                    }
                    psp->Release();
                }
                return S_FALSE;
            }
            case VK_F11:    // fullscreen
            {
                return S_FALSE;
            }

            case VK_F4:
            {
                if (_fVisible)
                {
                    if (HasFocusIO() == S_FALSE)
                        SetFocus(_hwnd);

                    // toggle the dropdown state
                    SendMessage(_hwnd, CB_SHOWDROPDOWN,
                                !SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0L), 0);

                    // Leave focus in the edit box so you can keep typing
                    if (_hwndEdit)
                        SetFocus(_hwndEdit);
                }
                else
                {
                    ASSERT(0); // Should this really be ignored?
                }

                return S_OK;
            }
            case VK_TAB:
            {
                // See if the editbox wants the tab character
                if (SendMessage(_hwndEdit, WM_GETDLGCODE, lpMsg->wParam, (LPARAM)lpMsg) == DLGC_WANTTAB)
                {
                    // We want the tab character
                    return S_OK;
                }
                break;
            }

            case VK_RETURN:
            {
                //
                // Ctrl-enter is used for quick complete, so pass it through
                //
                if (GetKeyState(VK_CONTROL) & 0x80000000)
                {
                    TranslateMessage(lpMsg);
                    DispatchMessage(lpMsg);
                    return S_OK;
                }
                break;
            }
        }
        break;
    case WM_KEYUP:      // eat any that WM_KEYDOWN processes
        switch (lpMsg->wParam)
        {
            case VK_F1:     // help
            case VK_F11:    // fullscreen
                return S_FALSE;

            case VK_RETURN:
            case VK_F4:
            case VK_TAB:
                return S_OK;
            default:
                break;
        }
        break;

    case WM_SYSCHAR:
        {
            CHAR   szChar [2] = "\0";
            if ('\0' == szAccel[0]) {
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR,szAccel,ARRAYSIZE(szAccel));
            }
            szChar[0] = (CHAR)lpMsg->wParam;

            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                ASSERT(_fVisible);
                if (_fVisible && (HasFocusIO() == S_FALSE))
                {
                    SetFocus(_hwnd);
                }
                return S_OK;
            }
        }
        break;

    case WM_SYSKEYUP:   // eat any that WM_SYSKEYDOWN processes
        if ('\0' == szAccel[0]) {
            MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR,szAccel,ARRAYSIZE(szAccel));
        }

        if ((CHAR)lpMsg->wParam == szAccel[0]) {
            return S_OK;
        }
        break;
    }

    HRESULT hres = EditBox_TranslateAcceleratorST(lpMsg);

    if (hres == S_FALSE && fForwardToView)
    {
        IShellBrowser *psb;
        // we did not process this try the view before we return
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_IShellBrowser, (void **)&psb)))
        {
            IShellView *psv;

            if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
            {
                hres = psv->TranslateAccelerator(lpMsg);
                psv->Release();
            }
            psb->Release();
        }
    }

    return hres;
}


HRESULT CAddressBand::HasFocusIO()
{
    if ((_hwndEdit&& (GetFocus() == _hwndEdit)) ||
        SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0))
        return S_OK;

    return S_FALSE;
}


//=====================================
// *** IInputObjectSite Interface ***
HRESULT CAddressBand::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    HRESULT hr;

    ASSERT(_punkSite);
    hr = IUnknown_OnFocusChangeIS(_punkSite, punk, fSetFocus);
    return hr;
}


//=====================================
// *** IOleCommandTarget Interface ***
HRESULT CAddressBand::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_paeb);
    return IUnknown_QueryStatus(_paeb, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}


HRESULT CAddressBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {

        switch (nCmdID)
        {
        case SBCMDID_GETADDRESSBARTEXT:
            hr = S_OK;

            TCHAR wz[MAX_URL_STRING];
            UINT   cb = 0;
            BSTR   bstr = NULL;
            VariantInit(pvarargOut);

            if (_hwndEdit)
                cb = Edit_GetText(_hwndEdit, (TCHAR *)&wz, ARRAYSIZE(wz));
            if (cb)
                bstr = SysAllocStringLen(NULL, cb);
            if (bstr)
            {
                SHTCharToUnicode(wz, bstr, cb);
                pvarargOut->vt = VT_BSTR|VT_BYREF;
                pvarargOut->byref = bstr;
            }
            else
            {
                // VariantInit() might do this for us.
                pvarargOut->vt = VT_EMPTY;
                pvarargOut->byref = NULL;
                return E_FAIL;   // Edit_GetText gave us nothing
            }
            break;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_SETWINDOWTHEME:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                if (_hwnd)
                {
                    Comctl32_SetWindowTheme(_hwnd, pvarargIn->bstrVal);
                    Comctl32_SetWindowTheme(_hwndTools, pvarargIn->bstrVal);
                    _BandInfoChanged();
                }
            }

            hr = S_OK;
            break;
        }
    }

    if (FAILED(hr))
    {
        hr = IUnknown_Exec(_paeb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    return(hr);
}

extern HRESULT IsDesktopBrowser(IUnknown *punkSite);

//================================
// *** IDeskBand Interface ***
/****************************************************\
    FUNCTION: GetBandInfo

    DESCRIPTION:
        This function will give the caller information
    about this Band, mainly the size of it.
\****************************************************/
HRESULT CAddressBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                                DESKBANDINFO* pdbi)
{
    HRESULT hr  = S_OK;

    _dwBandID = dwBandID;
    _fVertical = ((fViewMode & (DBIF_VIEWMODE_VERTICAL | DBIF_VIEWMODE_FLOATING)) != 0);

    pdbi->dwModeFlags = DBIMF_FIXEDBMP;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = 0;
    if (_fVertical) {
        pdbi->ptMinSize.y = GetSystemMetrics(SM_CXSMICON);
        pdbi->ptMaxSize.y = -1; // random
        pdbi->ptIntegral.y = 1;
        pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
    } else {
        if (_hwnd) {
            HWND hwndCombo;
            RECT rcCombo;

            hwndCombo = (HWND)SendMessage(_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
            ASSERT(hwndCombo);
            GetWindowRect(hwndCombo, &rcCombo);
            pdbi->ptMinSize.y = RECTHEIGHT(rcCombo);
        }
        ASSERT(pdbi->ptMinSize.y < 200);

    }

    MLLoadStringW(IDS_BAND_ADDRESS2, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (IsDesktopBrowser(_punkSite) != S_FALSE) {
        // non- shell browser host (e.g. desktop or tray)
        //
        // this is slightly (o.k., very) hoaky.  the only time we want to
        // show a mnemonic is when we're in a browser app.  arguably we
        // should generalize this to all bands/bandsites by having a
        // DBIMF_WITHMNEMONIC or somesuch, but that would mean adding a
        // CBandSite::_dwModeFlag=0 and overriding it in itbar::CBandSite.
        // that seems like a lot of work for a special case so instead we
        // hack it in here based on knowledge of our host.
        TraceMsg(DM_TRACE, "cab.gbi: nuke Address mnemonic");
        MLLoadStringW(IDS_BAND_ADDRESS, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    }

    return hr;
}

//================================
//  ** IWinEventHandler Interface ***
/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg)
    {
    case WM_WININICHANGE:
        if (SHIsExplorerIniChange(wParam, lParam) & (EICH_KINET | EICH_KINETMAIN))
        {
            _InitGoButton();
        }

        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            // Tell the combobox so that it can update its font
            SendMessage(_hwnd, uMsg, wParam, lParam);

            // Inform the band site that our height may have changed
            _BandInfoChanged();
        }
        break;

    case WM_COMMAND:
        {
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            if (idCmd == FCIDM_VIEWGOBUTTON)
            {
                // Toggle the go-button visibility
                BOOL fShowGoButton = !SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                    TEXT("ShowGoButton"), FALSE, /*default*/TRUE);

                SHRegSetUSValue(REGSTR_PATH_MAIN,
                            TEXT("ShowGoButton"),
                            REG_SZ,
                            (LPVOID)(fShowGoButton ? L"yes" : L"no"),
                            (fShowGoButton ? 4 : 3)*sizeof(TCHAR),
                            SHREGSET_FORCE_HKCU);

                // Tell the world that something has changed
                SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAIN, 3000);
            }
        }
    }

    if (_pweh)
        return _pweh->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
    else
        return S_OK;
}


/****************************************************\
    FUNCTION: IsWindowOwner

    DESCRIPTION:
        This function will return TRUE if the HWND
    passed in is a HWND owned by this band.
\****************************************************/
HRESULT CAddressBand::IsWindowOwner(HWND hwnd)
{
    if (_pweh)
        return _pweh->IsWindowOwner(hwnd);
    else
        return S_FALSE;
}


//================================
// *** IAddressBand Interface ***
/****************************************************\
    FUNCTION: FileSysChange

    DESCRIPTION:
        This function will handle file system change
    notifications.
\****************************************************/
HRESULT CAddressBand::FileSysChange(DWORD dwEvent, LPCITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    if (_fVisible)
    {
        hr = IUnknown_FileSysChange(_paeb, dwEvent, ppidl);
    }
    return hr;
}


/****************************************************\
    FUNCTION: Refresh

    PARAMETERS:
        pvarType - NULL for a refress of everything.
                   OLECMD_REFRESH_TOPMOST will only update the top most.

    DESCRIPTION:
        This function will force a refress of part
    or all of the AddressBand.
\****************************************************/
HRESULT CAddressBand::Refresh(VARIANT * pvarType)
{
    HRESULT hr = S_OK;
    IAddressBand * pab;

    if (_paeb)
    {
        hr = _paeb->QueryInterface(IID_IAddressBand, (LPVOID *)&pab);
        if (SUCCEEDED(hr))
        {
            hr = pab->Refresh(pvarType);
            pab->Release();
        }
    }

    return hr;
}

/****************************************************\
    Address Band Constructor
\****************************************************/
CAddressBand::CAddressBand()
{
    TraceMsg(TF_SHDLIFE, "ctor CAddressBand %x", this);

    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!_hwndEdit);
    ASSERT(!_paeb);
    ASSERT(!_pweh);

    _fCanFocus = TRUE;      // we accept focus (see CToolBand::UIActivateIO)
}


/****************************************************\
    Address Band destructor
\****************************************************/
CAddressBand::~CAddressBand()
{
    ATOMICRELEASE(_paeb);
    ATOMICRELEASE(_pweh);

    //
    // Make sure the toolbar is destroyed before we free
    // the image lists
    //
    if (_hwndTools && IsWindow(_hwndTools))
    {
        DestroyWindow(_hwndTools);
    }
    if (_himlDefault) ImageList_Destroy(_himlDefault);
    if (_himlHot)  ImageList_Destroy(_himlHot);

    //
    // Our window must be destroyed before we are freed
    // so that the window doesn't try to reference us.
    //
    if (_hwnd && IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);

        // Null out base classes window handle because
        // its destructor is next
        _hwnd = NULL;
    }

    TraceMsg(TF_SHDLIFE, "dtor CAddressBand %x", this);
}


/****************************************************\
    FUNCTION: CAddressBand_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    AddressBand COM object.
\****************************************************/
HRESULT CAddressBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    *ppunk = NULL;
    CAddressBand * p = new CAddressBand();
    if (p)
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: _CreateAddressBand

    DESCRIPTION:
        This function will create the AddressBand window
    with the ComboBox.
\****************************************************/
HRESULT CAddressBand::_CreateAddressBand(IUnknown * punkSite)
{
    HRESULT hr = S_OK;

    if (_hwnd)
    {
        IShellService * pss;

        if (_hwndTools)
        {
            DestroyWindow(_hwndTools);
            _hwndTools = NULL;
        }

        DestroyWindow(_hwnd);
        _hwnd = NULL;

        ASSERT(_punkSite);
        if (_paeb)
        {
            hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
            if (SUCCEEDED(hr))
            {
                hr = pss->SetOwner(NULL);
                pss->Release();
            }
        }
        ATOMICRELEASE(_paeb);
        ATOMICRELEASE(_pweh);
    }

    //
    // Create address window.
    //

    ASSERT(_hwndParent);        // Call us after SetSite()
    if (!_hwndParent)
    {
            // The caller hasn't called SetSite(), so we can't
            // create our window because we can't find out our parent's
            // HWND.
            return E_FAIL;
    }
    _InitComCtl32();    // don't check result, if this fails our CreateWindows will fail


    DWORD dwWindowStyles = WS_TABSTOP | WS_CHILD | WS_CLIPCHILDREN | WS_TABSTOP | CBS_DROPDOWN | CBS_AUTOHSCROLL;

    // WARNING: MSN and other Rooted Explorers may not have implemented all
    // of the ParseDisplayName and other IShellFolder members
    // If we want to continue to support MSN, we will need to turn on the
    // CBS_DROPDOWNLIST if ISROOTEDCLASS() and the clsid is equal to the MSN clsid.

    // dwWindowStyles |= CBS_DROPDOWNLIST; // (This turns off the ComboBox's Editbox)

    DWORD dwExStyle = WS_EX_TOOLWINDOW;

    if (IS_WINDOW_RTL_MIRRORED(_hwndParent))
    {
        // If the parent window is mirrored then the ComboBox window will inheret the mirroring flag
        // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.
        dwExStyle |= WS_EX_RTLREADING;
    }

    _hwnd = CreateWindowEx(dwExStyle, WC_COMBOBOXEX, NULL, dwWindowStyles,
                           0, 0, 100, 250, _hwndParent,
                           (HMENU) FCIDM_VIEWADDRESS, HINST_THISDLL, NULL);

    if (_hwnd)
    {
        // Initial combobox parameters.
        SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE,
                CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
                CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);

        // NOTE: _hwndEdit will be NULL if the CBS_DROPDOWNLIST flag has been turned on
        _hwndEdit  = (HWND)SendMessage(_hwnd, CBEM_GETEDITCONTROL, 0, 0L);
        _hwndCombo = (HWND)SendMessage(_hwnd, CBEM_GETCOMBOCONTROL, 0, 0L);

        // Subclass the Edit control's procedure to handle ModeBias issue.
        if ( _hwndEdit  && SetProp(_hwndEdit, c_szAddressBandProp, this))
        {
           _pfnOldEditProc = (WNDPROC) SetWindowLongPtr(_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _ComboExEditProc);
        }

        ASSERT(!_paeb && !_pweh);
        hr = CoCreateInstance(CLSID_AddressEditBox, NULL, CLSCTX_INPROC_SERVER, IID_IAddressEditBox, (void **)&_paeb);
        // If this object fails to initialize, it won't work!!!  Make sure you REGSVR32ed and RUNDLL32ed shdocvw.dll
        if (SUCCEEDED(hr))
        {
            hr = _paeb->QueryInterface(IID_IWinEventHandler, (LPVOID *)&_pweh);
            ASSERT(SUCCEEDED(hr));
            hr = _paeb->Init(_hwnd, _hwndEdit, AEB_INIT_AUTOEXEC, SAFECAST(this, IAddressBand *));
        }

        // Create the go button if it's enabled
        _InitGoButton();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//================================
// *** IPersistStream Interface ***

/****************************************************\
    FUNCTION: Load

    DESCRIPTION:
        This function will currently only persist the
    CAddressEditBox object.

    HISTORY:
    Ver 1: Contains the CAddressEditBox::Save() stream.
\****************************************************/
#define STREAM_VERSION_CADDRESSBAND      0x00000001

HRESULT CAddressBand::Load(IStream *pstm)
{
    HRESULT hr;
    DWORD dwSize;
    DWORD dwVersion;

    hr = LoadStreamHeader(pstm, STREAMHEADER_SIG_CADDRESSBAND, STREAM_VERSION_CADDRESSBAND,
        STREAM_VERSION_CADDRESSBAND, &dwSize, &dwVersion);
    ASSERT(SUCCEEDED(hr));

    if (S_OK == hr)
    {
        switch (dwVersion)
        {
        case 1:     // Ver 1.
            // Nothing.
            break;
        default:
            ASSERT(0);  // Should never get here.
            break;
        }
    }
    else if (S_FALSE == hr)
        hr = S_OK;  // We already have our default data set.

    return hr;
}


/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        This function will currently only persist the
    CAddressEditBox object.

    HISTORY:
    Ver 1: Contains the CAddressEditBox::Save() stream.
\****************************************************/
HRESULT CAddressBand::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hr;

    hr = SaveStreamHeader(pstm, STREAMHEADER_SIG_CADDRESSBAND,
                STREAM_VERSION_CADDRESSBAND, 0);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        IPersistStream * pps;

        ASSERT(_paeb);
        if (_paeb)
        {
            hr = _paeb->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
            if(EVAL(SUCCEEDED(hr)))
            {
                hr = pps->Save(pstm, fClearDirty);
                pps->Release();
            }
        }
    }

    return hr;
}


void CAddressBand::_OnGetInfoTip(LPNMTBGETINFOTIP pnmTT)
{
    // Format a tooltip: "go to <contents of address bar>"
    WCHAR szAddress[MAX_PATH];
    if (GetWindowText(_hwndEdit, szAddress, ARRAYSIZE(szAddress)))
    {
        WCHAR szFormat[MAX_PATH];
        const int MAX_TOOLTIP_LENGTH = 100;
        int cchMax = (pnmTT->cchTextMax < MAX_TOOLTIP_LENGTH) ? pnmTT->cchTextMax : MAX_TOOLTIP_LENGTH;

        MLLoadString(IDS_GO_TOOLTIP, szFormat, ARRAYSIZE(szFormat));
        int cch = wnsprintf(pnmTT->pszText, cchMax, szFormat, szAddress);

        // Append ellipses?
        if (cch == cchMax - 1)
        {
            // Note that Japan has a single character for ellipses, so we load
            // as a resource.
            WCHAR szEllipses[10];
            cch = MLLoadString(IDS_ELLIPSES, szEllipses, ARRAYSIZE(szEllipses));
            StrCpyN(pnmTT->pszText + cchMax - cch - 1, szEllipses, cch + 1);
        }
    }
    else if (pnmTT->cchTextMax > 0)
    {
        // Use button text for tooltip
        *pnmTT->pszText = L'\0';
    }
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the combobox Edit control in the address band
//--------------------------------------------------------------------------
LRESULT CALLBACK CAddressBand::_ComboExEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAddressBand* pThis = (CAddressBand*)GetProp(hwnd, c_szAddressBandProp);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldEditProc = pThis->_pfnOldEditProc;

    switch (uMsg)
    {
    case WM_KILLFOCUS :

        SetModeBias(MODEBIASMODE_DEFAULT);
        break;

    case WM_SETFOCUS:

        SetModeBias(MODEBIASMODE_URLHISTORY);
        break;

    case WM_DESTROY:
        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, c_szAddressBandProp);
        if (pfnOldEditProc)
        {
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldEditProc);
            pThis->_pfnOldEditProc = NULL;
        }
        break;
    default:
        break;
    }

    return CallWindowProc(pfnOldEditProc, hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the combobox in the address band
//--------------------------------------------------------------------------
LRESULT CALLBACK CAddressBand::_ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAddressBand* pThis = (CAddressBand*)GetProp(hwnd, c_szAddressBandProp);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldWndProc = pThis->_pfnOldWndProc;

    switch (uMsg)
    {
    case WM_NOTIFYFORMAT:
        if (NF_QUERY == lParam)
        {
            return (DLL_IS_UNICODE ? NFR_UNICODE : NFR_ANSI);
        }
        break;

    case WM_WINDOWPOSCHANGING:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Make room for the go button on the right side
            //
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOCOPYBITS;

            WINDOWPOS wp = *(LPWINDOWPOS)lParam;

            // Get the dimensions of our 'go' button
            RECT rc;
            SendMessage(pThis->_hwndTools, TB_GETITEMRECT, 0, (LPARAM)&rc);
            int cxGo = RECTWIDTH(rc);
            int cyGo = RECTHEIGHT(rc);

            // Make room for the go button on the right side
            wp.cx -= cxGo + 2;
            CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, (LPARAM)&wp);

            // Paint underneath the 'go' button
            RECT rcGo = {wp.cx, 0, wp.cx + cxGo + 2, wp.cy};
            InvalidateRect(pThis->_hwnd, &rcGo, TRUE);

            // The outer window can be much higher than the internal combobox.
            // We want to center the go button on the combobox
            int y;
            if (pThis->_hwndCombo)
            {
                // Center vertically with inner combobox
                RECT rcCombo;
                GetWindowRect(pThis->_hwndCombo, &rcCombo);
                y = (rcCombo.bottom - rcCombo.top - cyGo)/2;
            }
            else
            {
                y = (wp.cy - cyGo)/2;
            }

            // Position the 'go' button on the right.  Note that the height will always be ok
            // because the addressbar displays 16x16 icons within it.
            SetWindowPos(pThis->_hwndTools, NULL, wp.cx + 2, y, cxGo, cyGo, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            // Adjust the drop-down width
            SendMessage(pThis->_hwndCombo, CB_SETDROPPEDWIDTH, MIN_DROPWIDTH, 0L);
            return 0;
        }
    case WM_SIZE:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Make room for the go button on the right side
            //
            int cx = LOWORD(lParam);
            int cy = HIWORD(lParam);

            // Get the dimensions of our 'go' button
            RECT rc;
            SendMessage(pThis->_hwndTools, TB_GETITEMRECT, 0, (LPARAM)&rc);
            int cxGo = RECTWIDTH(rc);
            int cyGo = RECTHEIGHT(rc);

            // Make room for the go button on the right side
            LPARAM lParamTemp = MAKELONG(cx - cxGo - 2, cy);
            CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParamTemp);

            // Paint underneath the 'go' button
            RECT rcGo = {cx-cxGo, 0, cx, cy};
            InvalidateRect(pThis->_hwnd, &rcGo, TRUE);

            // The outer window can be much higher than the internal combobox.
            // We want to center the go button on the combobox
            int y;
            if (pThis->_hwndCombo)
            {
                // Center vertically with inner combobox
                RECT rcCombo;
                GetWindowRect(pThis->_hwndCombo, &rcCombo);
                y = (rcCombo.bottom - rcCombo.top - cyGo)/2;
            }
            else
            {
                y = (cy - cyGo)/2;
            }

            // Position the 'go' button on the right.  Note that the height will always be ok
            // because the addressbar displays 16x16 icons within it.
            SetWindowPos(pThis->_hwndTools, NULL, cx - cxGo, y, cxGo, cyGo, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            // Adjust the drop-down width
            SendMessage(pThis->_hwndCombo, CB_SETDROPPEDWIDTH, MIN_DROPWIDTH, 0L);
            return 0;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm->hwndFrom == pThis->_hwndTools)
            {
                switch (pnm->code)
                {
                case NM_CLICK:
                    // Simulate an enter key press in the combobox
                    SendMessage(pThis->_hwndEdit, WM_KEYDOWN, VK_RETURN, 0);
                    SendMessage(pThis->_hwndEdit, WM_KEYUP, VK_RETURN, 0);
                    // n.b. we also got a NAVADDRESS from the simulate
                    UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVGO);
                    break;

                case NM_TOOLTIPSCREATED:
                {
                    //
                    // Make the tooltip show up even when the app is nit active
                    //
                    NMTOOLTIPSCREATED* pnmTTC = (NMTOOLTIPSCREATED*)pnm;
                    SHSetWindowBits(pnmTTC->hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX);
                }
                break;
                case TBN_GETINFOTIP:
                    pThis->_OnGetInfoTip((LPNMTBGETINFOTIP)pnm);
                    break;
                }
                return 0;
            }
            break;
        }
    case WM_ERASEBKGND:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Forward the erase background to the parent so that
            // we appear transparent under the go button
            //
            HDC hdc = (HDC)wParam;
            HWND hwndParent = GetParent(hwnd);
            LRESULT lres = 0;

            if (hwndParent)
            {
                // Adjust the origin so the parent paints in the right place
                POINT pt = {0,0};

                MapWindowPoints(hwnd, hwndParent, &pt, 1);
                OffsetWindowOrgEx(hdc,
                                  pt.x,
                                  pt.y,
                                  &pt);

                lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM)hdc, 0L);

                SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
            }

            if (lres != 0)
            {
                // We handled it
                return lres;
            }

            break;
         }

    case WM_DESTROY:
        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, c_szAddressBandProp);
        if (pfnOldWndProc)
        {
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            pThis->_pfnOldWndProc = NULL;
        }
        break;
    default:
        break;
    }

    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Creates and shows the go button
//--------------------------------------------------------------------------
BOOL CAddressBand::_CreateGoButton()
{
    ASSERT(_hwndTools == NULL);

    BOOL fRet = FALSE;
    BOOL bUseClassicGlyphs = SHUseClassicToolbarGlyphs();
    COLORREF crMask = RGB(255, 0, 255);

    if (_himlDefault == NULL)
    {
        if (bUseClassicGlyphs)
        {
            _himlDefault = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GO), 16, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);

        }
        else
        {
            _himlDefault = ImageList_LoadImage(GetModuleHandle(TEXT("shell32.dll")), MAKEINTRESOURCE(IDB_TB_GO_DEF_20), 20, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
    }
    if (_himlHot == NULL)
    {
        if (bUseClassicGlyphs)
        {
            _himlHot  = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GOHOT), 16, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
        else
        {
            _himlHot  = ImageList_LoadImage(GetModuleHandle(TEXT("shell32.dll")), MAKEINTRESOURCE(IDB_TB_GO_HOT_20), 20, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
    }

    // If we have the image lists, go ahead and create the toolbar control for the go button
    if (_himlDefault && _himlHot)
    {
        //
        // Subclass the comboboxex so that we can place the go botton within it.  The toolbad class
        // assumes one window per band, so this trick allows us to add the button using existing windows.
        // Note that comboex controls have a separate window used to wrap the internal combobox.  This
        // is the window that we use to host our "go" button.  We must subclass before creating the
        // go button so that we respond to WM_NOTIFYFORMAT with NFR_UNICODE.
        //
        //
        if (SetProp(_hwnd, c_szAddressBandProp, this))
        {
           _pfnOldWndProc = (WNDPROC) SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR) _ComboExWndProc);
        }

        // Create the toolbar control for the go button
        _hwndTools = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_CHILD | TBSTYLE_FLAT |
                                TBSTYLE_TOOLTIPS |
                                TBSTYLE_LIST |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 0, 0, _hwnd, NULL, HINST_THISDLL, NULL);
    }

    if (_hwndTools)
    {
        // Init the toolbar control
        SendMessage(_hwndTools, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndTools, TB_SETMAXTEXTROWS, 1, 0L);
        SendMessage(_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, 500));
        SendMessage(_hwndTools, TB_SETIMAGELIST, 0, (LPARAM)_himlDefault);
        SendMessage(_hwndTools, TB_SETHOTIMAGELIST, 0, (LPARAM)_himlHot);

        LRESULT nRet = SendMessage(_hwndTools, TB_ADDSTRING, (WPARAM)MLGetHinst(), (LPARAM)IDS_ADDRESS_TB_LABELS);
        ASSERT(nRet == 0);

        static const TBBUTTON tbb[] =
        {
            {0, 1, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0},
        };
        SendMessage(_hwndTools, TB_ADDBUTTONS, ARRAYSIZE(tbb), (LPARAM)tbb);

        fRet = TRUE;
    }
    else
    {
        // If no toolbar control, don't subclass the comboboxex
        if (_pfnOldWndProc)
        {
            RemoveProp(_hwnd, c_szAddressBandProp);
            SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR) _pfnOldWndProc);
            _pfnOldWndProc = NULL;
        }
    }

    return fRet;
}


//+-------------------------------------------------------------------------
// Shows/hides the go button depending on the current registry settings
//--------------------------------------------------------------------------
void CAddressBand::_InitGoButton()
{
    BOOL fUpdate = FALSE;
    //
    // Create the go button if it's enabled
    //
    // down-level client fix: only show Go in shell areas when NT5 or greater
    // or on a window that was originally IE

    BOOL fShowGoButton = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
        TEXT("ShowGoButton"), FALSE, /*default*/TRUE)
        && (WasOpenedAsBrowser(_punkSite) || GetUIVersion() >= 5);

    if (fShowGoButton && (_hwndTools || _CreateGoButton()))
    {
        ShowWindow(_hwndTools, SW_SHOW);
        _fGoButton = TRUE;
        fUpdate = TRUE;
    }
    else if (_hwndTools && IsWindowVisible(_hwndTools))
    {
        ShowWindow(_hwndTools, SW_HIDE);
        _fGoButton = FALSE;
        fUpdate = TRUE;
    }

    // If the go button was hidden or shown, get the combobox to adjust itself
    if (fUpdate)
    {
        // Resetting the item height gets the combobox to update the size of the editbox
        LRESULT iHeight = SendMessage(_hwnd, CB_GETITEMHEIGHT, -1, 0);
        if (iHeight != CB_ERR)
        {
            SendMessage(_hwnd, CB_SETITEMHEIGHT, -1, iHeight);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\addrlist.h ===
/**************************************************************\
    FILE: addrlist.h

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.
\**************************************************************/

#ifndef _ADDRLIST_H
#define _ADDRLIST_H

#include "shellurl.h"
#define ACP_LIST_MAX_CONST            25

/**************************************************************\
    CLASS: CAddressList

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.

    NOTE:
        This is a virtual class!
\**************************************************************/

class CAddressList 
                : public IAddressList   // (Includes IWinEventHandler)
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd) { return E_NOTIMPL; }

    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP NavigationComplete(LPVOID pvCShellUrl);
    virtual STDMETHODIMP Refresh(DWORD dwType) { return S_OK; }      // Force subclasses to handle.
    virtual STDMETHODIMP Load(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP Save(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP SetToListIndex(int nIndex, LPVOID pvShelLUrl);
    virtual STDMETHODIMP FileSysChangeAL(DWORD dw, LPCITEMIDLIST* ppidl);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressList();
    virtual ~CAddressList(void);        // This is now an OLE Object and cannot be used as a normal Class.


    // Address Band Specific Functions
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void _InitCombobox(void);
    virtual HRESULT _Populate(void) = 0;        // This is a PURE function.
    virtual void _PurgeComboBox();

    // Helper Functions 
    void _ComboBoxInsertURL(LPCTSTR pszURL, int cchStrSize, int nMaxComboBoxSize);
    BOOL _MoveAddressToTopOfList(int iSel);
    HRESULT _GetUrlUI(CShellUrl * psu, LPCTSTR szUrl, int *piImage, int *piImageSelected);
    HRESULT _GetFastPathIcons(LPCTSTR pszPath, int *piImage, int *piSelectedImage);
    HRESULT _GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage);
    virtual LPITEMIDLIST _GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe);
    LRESULT  _OnDragBeginW(LPNMCBEDRAGBEGINW pnmcbe);
    LRESULT  _OnDragBeginA(LPNMCBEDRAGBEGINA pnmcbe) ;
    HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect);

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    int                 _cRef;
    BOOL                _fVisible:1;        // TRUE when the toolbar is visible.
    HWND                _hwnd;              // The window
    IBrowserService *   _pbs;
    IBandProxy *        _pbp;
    CShellUrl *         _pshuUrl;
};



HRESULT GetCBListIndex(HWND hwnd, int iItem, LPTSTR szAddress, int cchAddressSize);


IAddressList * CSNSList_Create(void);
IAddressList * CMRUList_Create(void);
IAddressList * CACPList_Create(void);

//===========================================================================
// IMRU: Interface to CMRUList.  Note that this interface never leaves browseui

#undef INTERFACE
#define INTERFACE IMRU
DECLARE_INTERFACE_(IMRU, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMRU Methods ***
    STDMETHOD(AddEntry) (THIS_ LPCWSTR pszEntry) PURE;
};

#endif // _ADDRLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\apithk.c ===
#ifdef UNICODE
#error start menu won't run on win95 if this apithk.c is compiled unicode
#endif
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "priv.h"       // Don't use precompiled header here
#include "uxtheme.h"

HINSTANCE GetComctl32Hinst()
{
    static HINSTANCE s_hinst = NULL;
    if (!s_hinst)
        s_hinst = GetModuleHandle(TEXT("comctl32.dll"));
    return s_hinst;
}

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }

    return LoadCursor(GetComctl32Hinst(), IDC_HAND_INTERNAL);
}

/*----------------------------------------------------------
Purpose: Use the Microsoft ActiveAccessiblity routines to 
        notify Accessibility programs of events
*/
typedef void (* PFNNOTIFYWINEVENT)(DWORD event, HWND hwnd, LONG idObject, LONG idChild);
#define DONOTHING_WINEVENT (PFNNOTIFYWINEVENT)1
void NT5_NotifyWinEvent(
    IN DWORD event,
    IN HWND hwnd,
    IN LONG idObject,
    IN LONG idChild)
{
    static PFNNOTIFYWINEVENT pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNNOTIFYWINEVENT)GetProcAddress(hmod, "NotifyWinEvent");
        
        if (!pfn)
            pfn = DONOTHING_WINEVENT;
    }

    if (pfn != DONOTHING_WINEVENT)
        pfn(event, hwnd, idObject, idChild);
}


// Use the Microsoft ActiveAccessiblity routines to  return an IAccessible object

typedef LRESULT (* PFNLRESULTFROMOBJECT)(REFIID riid, WPARAM wParam, IUnknown* punk);

LRESULT ACCESSIBLE_LresultFromObject(
    IN REFIID riid,
    IN WPARAM wParam,
    OUT IUnknown* punk)
{
    static PFNLRESULTFROMOBJECT pfn = NULL;
    static BOOL fLoadAttempted = FALSE;
    LRESULT lRet = (LRESULT)E_FAIL;

    if (NULL == pfn && !fLoadAttempted)
    {
        // LoadLibrary here because OLEAcc is not loaded in the process
        HMODULE hmod = LoadLibrary(TEXT("OLEACC"));
        
        if (hmod)
            pfn = (PFNLRESULTFROMOBJECT)GetProcAddress(hmod, "LresultFromObject");
        else
            fLoadAttempted = TRUE;
    }

    if (pfn)
        lRet = pfn(riid, wParam, punk);

    return lRet;
}

// wrapper for NT5/Millennium AllowSetForegroundWindow
typedef BOOL (* PFNALLOWSFW)(DWORD dwProcessId);

BOOL NT5_AllowSetForegroundWindow(IN DWORD dwProcessId )
{
    static PFNALLOWSFW pfn = (PFNALLOWSFW)-1;
    if (((PFNALLOWSFW)-1) == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        pfn = hmod ? (PFNALLOWSFW)GetProcAddress(hmod, "AllowSetForegroundWindow") : NULL;
    }

    return pfn ? pfn(dwProcessId) : FALSE;
}

typedef BOOL (* PFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlags);

// Thunk for NT 5's AnimateWindow.

BOOL NT5_AnimateWindow(IN HWND hwnd, IN DWORD dwTime, IN DWORD dwFlags)
{
    BOOL bRet = FALSE;
    static PFNANIMATEWINDOW pfn = NULL;

    ASSERT(g_bRunOnMemphis || g_bRunOnNT5);

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNANIMATEWINDOW)GetProcAddress(hmod, "AnimateWindow");
    }

    if (pfn)
        bRet = pfn(hwnd, dwTime, dwFlags);

    return bRet;    
}

// Position Menubands using NT5's AnimateWindow if available.

void SlideAnimate(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide)
{
    DWORD dwAnimateFlags = AW_CENTER;
    switch(uSide) 
    {
    case MENUBAR_LEFT:      dwAnimateFlags = AW_HOR_NEGATIVE;
        break;
    case MENUBAR_RIGHT:     dwAnimateFlags = AW_HOR_POSITIVE;
        break;
    case MENUBAR_TOP:       dwAnimateFlags = AW_VER_NEGATIVE;
        break;
    case MENUBAR_BOTTOM:    dwAnimateFlags = AW_VER_POSITIVE;
        break;
    }
    NT5_AnimateWindow(hwnd, 120, dwAnimateFlags | AW_SLIDE);
}

void AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate)
{
    if ((g_bRunOnMemphis || g_bRunOnNT5) && !fNoAnimate)
    {
        BOOL fAnimate = FALSE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
        if (fAnimate)
        {
            SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top,
                    RECTWIDTH(*prc), RECTHEIGHT(*prc), uFlags);
        
            fAnimate = FALSE;
#ifdef WINNT
            SystemParametersInfo(SPI_GETMENUFADE, 0, &fAnimate, 0);
#endif // WINNT
            if (fAnimate)
            {
                NT5_AnimateWindow(hwnd, 175, AW_BLEND);
            }
            else
            {
                SlideAnimate(hwnd, prc, uFlags, uSide);
            }
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        // Enable the show window so that it gets displayed.
        uFlags |= SWP_SHOWWINDOW;

        SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
                     uFlags);
    }
}


/*----------------------------------------------------------
Purpose: Use the Microsoft ActiveAccessiblity routines to 
        return an IAccessible object
*/
typedef LRESULT (* PFNCREATESTDACCESSIBLEOBJECT)(HWND hwnd, LONG idObject, REFIID riid, void** ppvObj);


LRESULT ACCESSIBLE_CreateStdAccessibleObject(
    IN HWND hwnd,
    IN LONG idObject,
    IN REFIID riid,
    OUT void** ppvObj)
{
    static PFNCREATESTDACCESSIBLEOBJECT pfn = NULL;
    static BOOL fLoadAttempted = FALSE;
    LRESULT lRet = (LRESULT)E_FAIL;

    if (NULL == pfn && !fLoadAttempted)
    {
        // LoadLibrary here because OLEAcc is not loaded in the process
        HMODULE hmod = LoadLibrary(TEXT("OLEACC"));
        
        if (hmod)
            pfn = (PFNCREATESTDACCESSIBLEOBJECT)GetProcAddress(hmod, "CreateStdAccessibleObject");
        else
            fLoadAttempted = TRUE;
    }

    if (pfn)
        lRet = pfn(hwnd, idObject, riid, ppvObj);

    return lRet;
}

typedef BOOL (* PFNLOCKSETFOREGROUNDWINDOW)(UINT);

BOOL MyLockSetForegroundWindow(BOOL fLock)
{
    static PFNLOCKSETFOREGROUNDWINDOW pfn = (PFNLOCKSETFOREGROUNDWINDOW)-1;
    BOOL fRet = FALSE;

    if ((PFNLOCKSETFOREGROUNDWINDOW)-1 == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        if (hmod)
            pfn = (PFNLOCKSETFOREGROUNDWINDOW)GetProcAddress(hmod, "LockSetForegroundWindow");
        else
            pfn = NULL;
    }

    if (pfn)
        fRet = pfn(fLock ? LSFW_LOCK : LSFW_UNLOCK);

    return fRet;
}

typedef UINT (* PFNSHEXTRACTICONSW)(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

STDAPI_(UINT) MyExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
    UINT uiRet = 0;
    static PFNSHEXTRACTICONSW pfn = NULL;

    if (GetUIVersion() >= 5)
    {
        if (NULL == pfn)
        {
            HMODULE hmod = GetModuleHandle(TEXT("SHELL32"));
            if (hmod)
                pfn = (PFNSHEXTRACTICONSW)GetProcAddress(hmod, "SHExtractIconsW");
        }

        if (pfn)
            uiRet = pfn(wszFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
    }

    return uiRet;    
}


typedef BOOL (* PFNUPDATELAYEREDWINDOW)
    (HWND hwnd, 
    HDC hdcDst,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags);

BOOL BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst)
{
    BOOL bRet = FALSE;
    static PFNUPDATELAYEREDWINDOW pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        if (hmod)
            pfn = (PFNUPDATELAYEREDWINDOW)GetProcAddress(hmod, "UpdateLayeredWindow");
    }

    if (pfn)
    {
        BLENDFUNCTION blend;
        blend.BlendOp = AC_SRC_OVER;
        blend.BlendFlags = 0;
        blend.AlphaFormat = 0;
        blend.SourceConstantAlpha = bBlendConst;

        bRet = pfn(hwnd, hdcDest, ppt, psize, hdc, pptSrc, 0, &blend, ULW_ALPHA);
    }

    return bRet;    
}

BOOL NT5_SetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags)
{
    static BOOL (*pfn)(HWND, COLORREF, BYTE, DWORD) = NULL;

    if (pfn == NULL)
    {
        HMODULE hMod = LoadLibrary(TEXT("user32.dll"));
        if (hMod)
        {
            pfn = (BOOL (*)(HWND, COLORREF, BYTE, DWORD))GetProcAddress(hMod, "SetLayeredWindowAttributes");
        }
    }

    if (pfn)
        return pfn(hwnd, crKey, bAlpha, dwFlags);
    return 0;
}

typedef HRESULT (* PFNSHPATHPREPAREFORWRITE)(HWND hwnd, IUnknown* punkModless, LPCWSTR pwzPath, DWORD dwFlags);
STDAPI NT5_SHPathPrepareForWrite(HWND hwnd, IUnknown* punkModless, LPCWSTR pwzPath, DWORD dwFlags)
{
    HRESULT hRet = E_FAIL;
    static PFNSHPATHPREPAREFORWRITE pfn = NULL;

    if (GetUIVersion() >= 5)
    {
        if (NULL == pfn)
        {
            HMODULE hmod = GetModuleHandle(TEXT("shell32.dll"));
            if (hmod)
            {
                pfn = (PFNSHPATHPREPAREFORWRITE)GetProcAddress(hmod, "SHPathPrepareForWriteW");
            }
        }

        if (pfn)
        {
            hRet = pfn(hwnd, punkModless, pwzPath, dwFlags);
        }
    }

    return hRet;    
}


void Comctl32_SetWindowTheme(HWND hwnd, LPWSTR psz)
{
    SendMessage(hwnd, CCM_SETWINDOWTHEME, 0, (LPARAM)psz);
}

void Comctl32_GetBandMargins(HWND hwnd, MARGINS* pmar)
{
    SendMessage(hwnd, RB_GETBANDMARGINS, 0, (LPARAM)pmar);
}

void Comctl32_FixAutoBreak(LPNMHDR pnm)
{
    LPNMREBARAUTOBREAK pnmab = (LPNMREBARAUTOBREAK) pnm;
    pnmab->fAutoBreak = !(pnmab->uMsg == RBAB_AUTOSIZE);
}

void Comctl32_SetDPIScale(HWND hwnd)
{
    SendMessage(hwnd, CCM_DPISCALE, TRUE, 0);    
}

// enable the marquee mode. note, this only works on comctl32 v6

STDAPI_(void) ProgressSetMarqueeMode(HWND hwndPrgress, BOOL bOn)
{
    if (IsOS(OS_WHISTLERORGREATER))
    {
        SendMessage(hwndPrgress, PBM_SETMARQUEE, bOn, 0);
        SHSetWindowBits(hwndPrgress, GWL_STYLE, PBS_MARQUEE, bOn ? PBS_MARQUEE : 0);
    }
}



// terminal server session notification:

static HMODULE s_hmodWTSApi = NULL; 

typedef BOOL (* PFNWTS_REGISTER_SESSION_NOTIFICATION)(HWND hwnd, DWORD dwFlags);
static PFNWTS_REGISTER_SESSION_NOTIFICATION s_pfnWTSRegisterSession = NULL;

typedef BOOL (* PFNWTS_UNREGISTER_SESSION_NOTIFICATION)(HWND hwnd);
static PFNWTS_UNREGISTER_SESSION_NOTIFICATION s_pfnWTSUnRegisterSession = NULL;

BOOL DL_WTSRegisterSessionNotification(HWND hwnd, DWORD dwFlags)
{
    if (s_pfnWTSRegisterSession == NULL)
    {
        if (s_hmodWTSApi == NULL)
        {
            s_hmodWTSApi = LoadLibrary(TEXT("wtsapi32"));
        }
        
        if (s_hmodWTSApi)
        {
            s_pfnWTSRegisterSession = (PFNWTS_REGISTER_SESSION_NOTIFICATION)GetProcAddress(s_hmodWTSApi, "WTSRegisterSessionNotification");
        }
    }

    if (s_pfnWTSRegisterSession != NULL)
    {
        return s_pfnWTSRegisterSession(hwnd, dwFlags);
    }
    return FALSE;
}



BOOL DL_WTSUnRegisterSessionNotification(HWND hwnd)
{
    if (s_pfnWTSUnRegisterSession == NULL)
    {
        if (s_hmodWTSApi == NULL)
        {
            s_hmodWTSApi = LoadLibrary(TEXT("wtsapi32"));
        }
        
        if (s_hmodWTSApi)
        {
            s_pfnWTSUnRegisterSession = (PFNWTS_UNREGISTER_SESSION_NOTIFICATION)GetProcAddress(s_hmodWTSApi, "WTSUnRegisterSessionNotification");
        }
    }

    if (s_pfnWTSUnRegisterSession != NULL)
    {
        BOOL fRet = s_pfnWTSUnRegisterSession(hwnd);
        FreeLibrary(s_hmodWTSApi);
        s_hmodWTSApi = NULL;
        s_pfnWTSRegisterSession = NULL;
        s_pfnWTSUnRegisterSession = NULL;
        return fRet;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\admovr2.h ===
/***************************************************************************/
/* WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! */
/***************************************************************************/
/* As part of the shdocvw/browseui split, this file is moving to           */
/* shell32\unicpp\admovr2.h.  Make sure you make your delta to the         */
/* shell32 version if you don't want your changes to be lost!              */
/***************************************************************************/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Apr 03 11:59:43 1997
 */
/* Compiler settings for ADMover.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ADMover_h__
#define __ADMover_h__

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ADMOVERLib_LIBRARY_DEFINED__
#define __ADMOVERLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ADMOVERLib
 * at Thu Apr 03 11:59:43 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 

#ifdef __cplusplus
class DECLSPEC_UUID("72267F6A-A6F9-11D0-BC94-00C04FB67863")
DeskMovr;
#endif


#endif /* __ADMOVERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

#ifndef __ADMOVR2__
#define __ADMOVR2__

#include "mshtml.h"
#include "mshtmdid.h"

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#ifdef __cplusplus

#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    ATOMICRELEASE(ptr)
#define QUICK_RELEASE(ptr)     ATOMICRELEASE(ptr)
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()

#define NEW_HIT_TEST

    
    interface DECLSPEC_UUID("72267F69-A6F9-11D0-BC94-00C04FB67863")
    IDeskMovr : public IUnknown
    {
    public:        
        virtual HRESULT STDMETHODCALLTYPE Duck( 
            BOOL fDuck) = 0;
 
       virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Engaged( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
    };


    interface DECLSPEC_UUID("72267F6C-A6F9-11D0-BC94-00C04FB67863")
    IDeskSizr : public IUnknown
    {
    public:
         
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Target( 
            /* [in] */ LPDISPATCH newVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Engaged( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Duck( 
            BOOL fDuck) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TrackTarget( void) = 0;
        
    };

#endif

#define OLEMISMOVR (OLEMISC_ALWAYSRUN|OLEMISC_NOUIACTIVATE|OLEMISC_SETCLIENTSITEFIRST|OLEMISC_ACTIVATEWHENVISIBLE|OLEMISC_RECOMPOSEONRESIZE|OLEMISC_CANTLINKINSIDE|OLEMISC_INSIDEOUT)
EXTERN_C void PersistTargetPosition( IHTMLElement *pielem,
                            int left,
                            int top,
                            int width,
                            int height,
                            int zIndex,
                            BOOL  fSaveState,
                            DWORD dwNewState);

EXTERN_C BOOL WINAPI DeskMovr_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/);

#endif // __ADMOVR2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\aeditbox.cpp ===
/**************************************************************\
    FILE: aeditbox.cpp

    DESCRIPTION:
        The Class CAddressEditBox exists to support a typical
    set of functionality used in Editboxes or ComboBoxes.  This
    object will add AutoComplete functionality to the EditBox and
    specify default "AutoComplete" Lists.  If the control is a
    ComboBoxEd, this object will populate the drop down list
    appropriately.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "aclhist.h"
#include "aclmulti.h"
#include "autocomp.h"
#include "address.h"
#include "shellurl.h"
#include "bandprxy.h"
#include "uemapp.h"
#include "apithk.h"
#include "accdel.h"

#include "resource.h"
#include "mluisupp.h"

#ifdef UNIX
#include "unixstuff.h"
#include "shalias.h"
#endif

extern DWORD g_dwStopWatchMode;

// Needed in order to track down NTRAID#187504-Bryanst-Tracking Winsta for corruption
HWINSTA g_hWinStationBefore = NULL;
HWINSTA g_hWinStationAfter = NULL;
HWINSTA g_hWinStationAfterEx = NULL;

// Internal message for async processing of the IDList when navigating
UINT    g_nAEB_AsyncNavigation = 0;

///////////////////////////////////////////////////////////////////
// #DEFINEs
#define SZ_ADDRESSCOMBO_PROP            TEXT("CAddressCombo_This")
#define SZ_ADDRESSCOMBOEX_PROP          TEXT("CAddressComboEx_This")
#define SEL_ESCAPE_PRESSED  (-2)



///////////////////////////////////////////////////////////////////
// Data Structures
enum ENUMLISTTYPE
{
    LT_NONE,
    LT_SHELLNAMESPACE,
    LT_TYPEIN_MRU,
};

///////////////////////////////////////////////////////////////////
// class AsyncNav: this object contains all the necessary information
//                 to execute an asynchronous navigation task, so that
//                 the user doesn't have to wait for navigation to
//                 finish before doing anything, and the navigation
//                 can be canceled if it takes too long.

class AsyncNav
{
public:
// Public Functions ***************************************

    AsyncNav()
    {
        _cRef = 1;
        _pShellUrl = NULL;
        _pszUrl = NULL;
    }

    LONG AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    LONG Release()
    {
        if (InterlockedDecrement(&_cRef))
            return _cRef;

        delete this;
        return 0;
    }

// Data members ***************************************
    
    CShellUrl * _pShellUrl;
    DWORD       _dwParseFlags;
    BOOL        _fWasCorrected;
    BOOL        _fPidlCheckOnly;
    HRESULT     _hr;
    LPTSTR      _pszUrl;
    HWND        _hwnd;  // HWND that receives the message when processing is done.
    
    BOOL        _fReady; // This ensures that we will not try to use the object before it's ready
                         // CONSIDER: the memory can be released and then re-used by the same object
                         // CONSIDER: which would have us believe that the navigation should be done.
                         // CONSIDER: But if the navigation had been canceled and the memory re-used by the next AsyncNav alloc
                         // CONSIDER: we would handle the message g_nAEB_AsyncNavigation with an
                         // CONSIDER: unprocessed AsyncNav object. (See the handler for g_nAEB_AsyncNavigation).

private:
    LONG _cRef;
    ~AsyncNav()
    {
        delete _pShellUrl;
        _pShellUrl = NULL;
        Str_SetPtr(&_pszUrl, NULL);
    }
};

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CAddressEditBox
\**************************************************************/
class CAddressEditBox
                : public IWinEventHandler
                , public IDispatch
                , public IAddressBand
                , public IAddressEditBox
                , public IOleCommandTarget
                , public IPersistStream
                , public IShellService
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                        OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) {return E_NOTIMPL;}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_AddressEditBox; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm) {return S_OK;}
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) { Save(0); return S_OK;}
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize) {return E_NOTIMPL;}

    // *** IAddressBand methods ***
    virtual STDMETHODIMP FileSysChange(DWORD dwEvent, LPCITEMIDLIST *ppidl);
    virtual STDMETHODIMP Refresh(VARIANT * pvarType);

    // *** IAddressEditBox methods ***
    virtual STDMETHODIMP Init(HWND hwndComboBox, HWND hwndEditBox, DWORD dwFlags, IUnknown * punkParent);
    virtual STDMETHODIMP SetCurrentDir(LPCOLESTR pwzDir);
    virtual STDMETHODIMP ParseNow(DWORD dwFlags);
    virtual STDMETHODIMP Execute(DWORD dwExecFlags);
    virtual STDMETHODIMP Save(DWORD dwReserved);

    // *** IShellService methods ***
    STDMETHODIMP SetOwner(IUnknown* punkOwner);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressEditBox();
    ~CAddressEditBox(void);        // This is now an OLE Object and cannot be used as a normal Class.

    LRESULT _OnNotify(LPNMHDR pnm);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT _OnBeginEdit(LPNMHDR pnm) ;
    LRESULT _OnEndEditW(LPNMCBEENDEDITW pnmW);
    LRESULT _OnEndEditA(LPNMCBEENDEDITA pnmA);

    HRESULT _ConnectToBrwsrConnectionPoint(BOOL fConnect, IUnknown * punk);
    HRESULT _ConnectToBrwsrWnd(IUnknown* punk);
    HRESULT _UseNewList(ENUMLISTTYPE eltNew);
    HRESULT _CreateCShellUrl(void);

    HRESULT _HandleUserAction(LPCTSTR pszUrl, int iNewSelection);
    HRESULT _NavigationComplete(LPCTSTR pszUrl, BOOL fChangeLists, BOOL fAddToMRU);
    void    _SetAutocompleteOptions();
    void    _GetUrlAndCache(void);
    BOOL _IsShellUrl(void);

    static HRESULT _NavigateToUrlCB(LPARAM lParam, LPTSTR lpUrl);
    static LRESULT CALLBACK _ComboSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    // Functions for keeping dirty contents from getting clobbered
    BOOL    _IsDirty();
    void    _ClearDirtyFlag();
    void    _InstallHookIfDirty();
    void    _RemoveHook();
    LRESULT _MsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs);
    static LRESULT CALLBACK CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _ComboExSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _EditSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK _EnumFindWindow(HWND hwnd, LPARAM lParam);

    HRESULT _FinishNavigate();
    static DWORD WINAPI _AsyncNavigateThreadProc(LPVOID pvData); // do async navigation: figure out the PIDL on a separate thread.

    void _JustifyAddressBarText( void );
    HRESULT _AsyncNavigate(AsyncNav *pAsyncNav);
    HRESULT _CancelNavigation();

    // Friend Functions
    friend HRESULT CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    //////////////////////////////////////////////////////
    //  Private Member Variables
    //////////////////////////////////////////////////////
    int             m_cRef;              // COM Object Ref Count

    IUnknown *      m_punkParent;        // Our Parent that will receive events if something happens.
    DWORD           m_dwFlags;           // Flags that will modify the behavior of this object.
    HWND            m_hwnd;              // Address ComboBoxEx Control if we control a ComboBoxEx.
    HWND            m_hwndEdit;          // Address EditBox Control Window
    WNDPROC         m_lpfnComboWndProc;  // Former WndProc of Combo child
    int             m_nOldSelection;     // Previous Drop Down Selection.

    // Objects for Navigation
    IBandProxy *    m_pbp;               // The BandProxy that will take care of finding the window to Navigate.
    IBrowserService*m_pbs;               // Only valid when we are in a Browser Windows Toolbar. (Not Toolband)
    DWORD           m_dwcpCookie;        // ConnectionPoint cookie for DWebBrowserEvents2 from the Browser Window.
    LPTSTR          m_pszCurrentUrl;     // Needed in case refresh occurs.
    LPTSTR          m_pszPendingURL;     // Pending URL.  We hang on to it until navigation finished before adding to MRU.
    LPTSTR          m_pszUserEnteredURL; // Keep the exact text the user entered just in case we need to do a search.
    LPTSTR          m_pszHttpErrorUrl;
    BOOL            m_fDidShellExec;     // Was the last navigation handled by calleding ShellExec()? (Used when refreshing)
    BOOL            m_fConnectedToBrowser; // Are we connected to a browser?

    AsyncNav *      m_pAsyncNav;

    // AutoComplete Functionality
    IAutoComplete2* m_pac;               // AutoComplete object
    IShellService * m_pssACLISF;         // AutoComplete ISF List.  Needed if we need to change browsers.

    // AddressLists
    ENUMLISTTYPE    m_elt;
    ENUMLISTTYPE    m_eltPrevious;
    IAddressList *  m_palCurrent;        // CurrentList.
    IAddressList *  m_palSNS;            // Shell Name Space List.
    IAddressList *  m_palMRU;            // Type-in MRU List.
    IMRU *          m_pmru;              // MRU List.
    CShellUrl *     m_pshuUrl;

    // Variables for keeping dirty contens from getting clobbered
    static CAssociationList m_al;        // associate thread id with this class
    WNDPROC         m_lpfnComboExWndProc;// Former WndProc of ComboBoxEx
    WNDPROC         m_lpfnEditWndProc;   // Former WndProc of Edit control in ComboBox
    HHOOK           m_hhook;             // mouse message hook
    COMBOBOXEXITEM  m_cbex;              // last change received while dirty
    HWND            m_hwndBrowser;       // top-level browser window
    BOOL            m_fAssociated;       // if we are entered in m_al for this thread
    BOOL            m_fAsyncNavInProgress; // tells if we have a pending async navigate already in progress
};

class CAddressEditAccessible : public CDelegateAccessibleImpl
{
public:
    CAddressEditAccessible(HWND hwndCombo, HWND hwndEdit);

    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IAccessible ***
    STDMETHODIMP get_accName(VARIANT varChild, BSTR  *pszName);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR  *pszValue);

protected:
    virtual ~CAddressEditAccessible();

private:
    DWORD   m_dwRefCount;
    HWND    m_hwndEdit;
    LPWSTR  m_pwszName;
};


//=================================================================
// Static variables
//=================================================================
CAssociationList CAddressEditBox::m_al;

//=================================================================
// Implementation of CAddressEditBox
//=================================================================

//===========================
// *** IUnknown Interface ***

HRESULT CAddressEditBox::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IAddressBand))
    {
        *ppvObj = SAFECAST(this, IAddressBand*);
    }
    else if (IsEqualIID(riid, IID_IAddressEditBox))
    {
        *ppvObj = SAFECAST(this, IAddressEditBox*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IShellService))
    {
        *ppvObj = SAFECAST(this, IShellService*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CAddressEditBox::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}

ULONG CAddressEditBox::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}


//=====================================
// *** IOleCommandTarget Interface ***

HRESULT CAddressEditBox::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (rgCmds == NULL)
    {
        return(E_INVALIDARG);
    }

    if (pguidCmdGroup==NULL)
    {
        hr = S_OK;

        for (UINT i=0; i<cCmds; i++)
        {
            ULONG l;
            rgCmds[i].cmdf = 0;

            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_PASTE:
                if (m_hwndEdit && OpenClipboard(m_hwndEdit))
                {
                    // IDEA: We might want to support CF_URL here (SatoNa)
                    if (GetClipboardData(CF_TEXT))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                    CloseClipboard();
                }
                break;

            case OLECMDID_COPY:
            case OLECMDID_CUT:
                if (m_hwndEdit)
                {
                    l=(ULONG)SendMessage(m_hwndEdit, EM_GETSEL, 0, 0);
                    if (LOWORD(l) != HIWORD(l))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                }
                break;
            case OLECMDID_SELECTALL:
                if (m_hwndEdit)
                {
                    // Select All -- not allowed if there's no text or if everything is
                    // selected.   Latter case takes care of first one.
                    int ichMinSel;
                    int ichMaxSel;
                    int cch = (int)SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
                    SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&ichMinSel, (LPARAM)&ichMaxSel);

                    if ((ichMinSel != 0) || (ichMaxSel != cch))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                }
            }
        }
    }

    return(hr);
}

HRESULT CAddressEditBox::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        hr = S_OK;

        switch(nCmdID)
        {
        case OLECMDID_COPY:
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_COPY, 0, 0);
            break;

        case OLECMDID_PASTE:
            // IDEA: We might want to support CF_URL here (SatoNa)
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_PASTE, 0, 0);
            break;

        case OLECMDID_CUT:
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_CUT, 0, 0);
            break;

        case OLECMDID_SELECTALL:
            if (m_hwndEdit)
                Edit_SetSel(m_hwndEdit, 0, (LPARAM)-1);
            break;

        default:
            hr = OLECMDERR_E_UNKNOWNGROUP;
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        hr = S_OK;

        switch (nCmdID)
        {
#ifdef UNIX
        // We do an OleCmdTarget->Exec() with this command to change the
        // focus to the address bar.
        case SBCMDID_SETADDRESSBARFOCUS:
            if ( m_hwndEdit )
                 SetFocus( m_hwndEdit );
            break;
        case SBCMDID_HASADDRESSBARFOCUS:
            if ( GetFocus() != m_hwndEdit )
                return E_FAIL;
            break;
#endif
        case SBCMDID_ERRORPAGE:
            {
                // We save urls to error pages so that they don't get placed
                // into the MRU
                if (pvarargIn && pvarargIn->vt == VT_BSTR)
                {
                    // Save the location where the error occured
                    Str_SetPtr(&m_pszHttpErrorUrl, pvarargIn->bstrVal);
                }
                break;
            }
        case SBCMDID_AUTOSEARCHING:
            {
                // The address did not resolve so the string is about to be sent
                // to the search engine or autoscanned.  There is a good chance
                // the pending url had "http:\\" prefixed which is a bogus url.
                // So let's put what the user typed into the mru instead.
                //
                Str_SetPtr(&m_pszPendingURL, m_pszUserEnteredURL);
                break;
            }

        case SBCMDID_GETUSERADDRESSBARTEXT:
            UINT cb = (m_pszUserEnteredURL ? (lstrlen(m_pszUserEnteredURL) + 1) : 0);
            BSTR bstr = NULL;

            VariantInit(pvarargOut);

            if (cb)
                bstr = SysAllocStringLen(NULL, cb);
            if (bstr)
            {
                SHTCharToUnicode(m_pszUserEnteredURL, bstr, cb);
                pvarargOut->vt = VT_BSTR|VT_BYREF;
                pvarargOut->byref = bstr;
            }
            else
            {
                // VariantInit() might do this for us.
                pvarargOut->vt = VT_EMPTY;
                pvarargOut->byref = NULL;
                return E_FAIL;   // Edit_GetText gave us nothing
            }
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_AddressEditBox, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case AECMDID_SAVE:
            hr = Save(0);
            break;
        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    return(hr);
}


//================================
//  ** IWinEventHandler Interface ***

/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressEditBox::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_WININICHANGE:
        {
            HWND hwndLocal = (m_hwnd ? m_hwnd : m_hwndEdit);
            if (hwndLocal)
                SendMessage(hwndLocal, uMsg, wParam, lParam);

            // MRU Needs it because it May Need to purge the MRU even if it isn't the current list.
            if ((m_palCurrent != m_palMRU) && m_palMRU)
                m_palMRU->OnWinEvent(m_hwnd, uMsg, wParam, lParam, plres);

            _SetAutocompleteOptions();
        }
        break;

    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
        lres = _OnNotify((LPNMHDR)lParam);
        break;
    }

    if (plres)
        *plres = lres;

    // All Events get all events, and they need to determine
    // if they are active to act on most of the events.

    if (m_hwnd)
    {
        if (m_palCurrent)
        {
            m_palCurrent->OnWinEvent(m_hwnd, uMsg, wParam, lParam, plres);
        }

        // If we are dropping down the list, the above call could have
        // changed the selection, so grab it again...

        if ((uMsg == WM_COMMAND) && (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN))
        {
            m_nOldSelection = ComboBox_GetCurSel(m_hwnd);

            // If nothing selected, and something matches the contents of the editbox, select that
            if (m_nOldSelection == -1)
            {
                TCHAR szBuffer[MAX_URL_STRING];
                GetWindowText(m_hwnd, szBuffer, SIZECHARS(szBuffer));

                m_nOldSelection = (int)SendMessage(m_hwnd, CB_FINDSTRINGEXACT, (WPARAM)-1,  (LPARAM)szBuffer);
                if (m_nOldSelection != CB_ERR)
                {
                    ComboBox_SetCurSel(m_hwnd, m_nOldSelection);
                }
            }
        }
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: IsWindowOwner

    DESCRIPTION:
        This function will return TRUE if the HWND
    passed in is a HWND owned by this band.
\****************************************************/
HRESULT CAddressEditBox::IsWindowOwner(HWND hwnd)
{
    if (hwnd == m_hwnd)
        return S_OK;

    if (m_hwndEdit && (hwnd == m_hwndEdit))
        return S_OK;

    return S_FALSE;
}


void CAddressEditBox::_GetUrlAndCache(void)
{
    TCHAR szTemp[MAX_URL_STRING];

    // This will fail when the browser first opens and the first navigation to the
    // default home page doesn't start downloading yet.
    if (SUCCEEDED(m_pshuUrl->GetUrl(szTemp, SIZECHARS(szTemp))))
    {
        SHRemoveURLTurd(szTemp);
        SHCleanupUrlForDisplay(szTemp);
        Str_SetPtr(&m_pszCurrentUrl, szTemp);      // Used when refreshing
    }
    else
    {
        Str_SetPtr(&m_pszCurrentUrl, NULL);
    }
}


//================================
// *** IDispatch Interface ***
/****************************************************\
    FUNCTION: Invoke

    DESCRIPTION:
        This function will give receive events from
    the Browser Window if this band is connected
    to one.  This will allow this band to remain up
    todate when the browser window changes URL by
    another means.
\****************************************************/
HRESULT CAddressEditBox::Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult,
                  EXCEPINFO * pexcepinfo,UINT * puArgErr)
{
    HRESULT hr = S_OK;

    ASSERT(pdispparams);
    if (!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {
        case DISPID_NAVIGATECOMPLETE: // This is when we have bits back?
            ASSERT(0);      // We didn't ask to synch these.
            break;

        // The event DISPID_NAVIGATECOMPLETE2 may be sent several times during
        // redirects.
        // The event DISPID_DOCUMENTCOMPLETE will only happen after navigation is
        // finished.
        case DISPID_DOCUMENTCOMPLETE:
            Str_SetPtr(&m_pszUserEnteredURL, NULL);
            break;

        case DISPID_NAVIGATECOMPLETE2:
        {
            DWORD dwCurrent;
            BOOL fFound = FALSE;

            ASSERT(m_elt != LT_NONE);
            IBrowserService* pbs = NULL;

            for (dwCurrent = 0; dwCurrent < pdispparams->cArgs; dwCurrent++)
            {
                if (pdispparams->rgvarg[dwCurrent].vt == VT_DISPATCH)
                {
                    // See who's sending us this event
                    hr = IUnknown_QueryService(pdispparams->rgvarg[dwCurrent].pdispVal, SID_SShellBrowser, IID_IBrowserService, (void**)&pbs);
                    if (pbs)
                    {
                        // We don't really need this interface, just its address
                        pbs->Release();
                    }
                    if (FAILED(hr) || pbs != m_pbs)
                    {
                        // Notification must have come from a frame, so ignore it because
                        // it doesn't affect the URL in the address bar.
                        return S_OK;
                    }
                }
                else if (!fFound)
                {
                    if ((pdispparams->rgvarg[dwCurrent].vt == VT_BSTR) ||
                        ((pdispparams->rgvarg[dwCurrent].vt == (VT_VARIANT|VT_BYREF)) &&
                        (pdispparams->rgvarg[dwCurrent].pvarVal->vt == VT_BSTR)))
                    {
                        fFound = TRUE;
                    }
                }
            }
            ASSERT(fFound);
            hr = _CreateCShellUrl();
            if (FAILED(hr))
                return hr;

            // Yes, so let's set our current working directory to the current window.
            ASSERT(m_pbs);
            LPITEMIDLIST pidl;

            if (SUCCEEDED(hr = m_pbs->GetPidl(&pidl)))
            {
                DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
                TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::Invoke(), Current Pidl in TravelLog. PIDL=%s;", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

                ASSERT(pidl);
                // m_pshuUrl will free pshuCurrWorkDir, so we can't.

                hr = m_pshuUrl->SetPidl(pidl);
                ILFree(pidl);

                _GetUrlAndCache();      // We call this function so stack space is only used temporarily.  It will set m_pszCurrentUrl.
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszTempURL = NULL;

                    // WARNING: This code looks really strange, but it is necessary.  Normally,
                    // I would like to pass m_pszCurrentUrl as an arg to _NavigationComplete.  The problem
                    // is that the _NavigationComplete calls m_palCurrent->NavigationComplete() which will replace
                    // the value in m_pszCurrentUrl.  So I need to pass a value that will still be valid when 
                    // m_pszCurrentUrl gets reoplaced.
                    // (That function causes the string to change values indirectly because it ends up sending
                    // a CBEM_SETITEM message to the combobox which will update m_pszCurrentUrl.)
                    //
                    // We put this string on the heap because it can be very large (MAX_URL_STRING) and
                    // this code that calls us and the code we call, use an incredible amount of stack space.
                    // This code needs to highly optimize on how much stack space it uses or it will cause
                    // out of memory faults when trying to grow the stack.
                    Str_SetPtr(&pszTempURL, m_pszCurrentUrl);

                    if (pszTempURL)
                    {
                        hr = _NavigationComplete(pszTempURL, TRUE, TRUE);
                    }
                    Str_SetPtr(&pszTempURL, NULL);
                }
            }
            else
            {
                Str_SetPtr(&m_pszCurrentUrl, NULL);      // Init incase it's null
            }
        }
        break;
        default:
            hr = E_INVALIDARG;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _UseNewList

    DESCRIPTION:
        This function will switch the list we use to
    populate the contents of the combobox.
\****************************************************/
HRESULT CAddressEditBox::_UseNewList(ENUMLISTTYPE eltNew)
{
    HRESULT hr = S_OK;

    ASSERT(m_hwnd);     // It's invalid for use to use a AddressList if we are only and EditBox.
    if (m_elt == eltNew)
        return S_OK;  // We are already using this list.

    if (m_palCurrent)
    {
        m_palCurrent->Connect(FALSE, m_hwnd, m_pbs, m_pbp, m_pac);
        m_palCurrent->Release();
    }

    switch(eltNew)
    {
#ifndef UNIX
    case LT_SHELLNAMESPACE:
        ASSERT(m_palSNS);
        m_palCurrent = m_palSNS;
        break;
#endif
    case LT_TYPEIN_MRU:
        ASSERT(m_palMRU);
        m_palCurrent = m_palMRU;
        break;
    default:
        ASSERT(0); // Someone messed up.
        m_palCurrent = NULL;
        break;
    }
    if (m_palCurrent)
    {
        m_palCurrent->AddRef();
        m_palCurrent->Connect(TRUE, m_hwnd, m_pbs, m_pbp, m_pac);
    }
    m_elt = eltNew;

    return hr;
}


//================================
// *** IAddressEditBox Interface ***

/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
\****************************************************/
HRESULT CAddressEditBox::Save(DWORD dwReserved)
{
    HRESULT hr = S_OK;

    ASSERT(0 == dwReserved);        // Reserved for later.

    if (m_palMRU)
        hr = m_palMRU->Save();

    return hr;
}



/****************************************************\
    FUNCTION: Init

    PARAMETERS:
        hwnd - Points to ComboBoxEx otherwise NULL.
        hwndEditBox - EditBox.
        dwFlags - AEB_INIT_XXXX flags (Defined in iedev\inc\shlobj.w)
        punkParent - Pointer to parent object that should receive events.

    DESCRIPTION:
        This function will Hook this CAddressEditBox
    object to the ComboBoxEx or EditBox control.  If
    this object is being hooked up to a ComboBoxEx control,
    then hwnd is of the ComboBoxEx control and hwndEditBox
    is of that ComboBox's edit control.  If this is
    being hooked up to only an EditBox, then hwnd is NULL
    and hwndEditBox points to the edit box.  If punkParent
    is NULL, we will not be connected to a browser window
    at all.
\****************************************************/
HRESULT CAddressEditBox::Init(HWND hwnd,              OPTIONAL
                        HWND hwndEditBox,
                        DWORD dwFlags,
                        IUnknown * punkParent)  OPTIONAL
{
    HRESULT hr = S_OK;

    ASSERT(!m_hwnd);
    m_hwnd = hwnd;
    m_hwndEdit = hwndEditBox;
    m_dwFlags = dwFlags;
    IUnknown_Set(&m_punkParent, punkParent);

    // Get and save our top-level window
    m_hwndBrowser = hwnd;
    HWND hwndParent;
    while (hwndParent = GetParent(m_hwndBrowser))
    {
        m_hwndBrowser = hwndParent;
    }

    ASSERT(!(AEB_INIT_SUBCLASS &dwFlags));       // We don't support this yet.
    if (hwnd)  // Is this a ComboBox?
    {
        // Yes,

        ASSERT(!m_palSNS && !m_palMRU /*&& !m_palACP*/);

        m_palSNS = CSNSList_Create();
        m_palMRU = CMRUList_Create();
        if (!m_palSNS || !m_palMRU /*|| !m_palACP*/)
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            HWND hwndCombo;

            hwndCombo = (HWND)SendMessage(m_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
            if (!hwndCombo)
                hr = E_FAIL;  // This will happen if the user passed in a ComboBox instead of a ComboBoxEx for hwnd.
            if (hwndCombo && SetProp(hwndCombo, SZ_ADDRESSCOMBO_PROP, this))
            {
                g_hWinStationBefore = GetProcessWindowStation();
                // Subclass combobox for various tweaks.
                ASSERT(!m_lpfnComboWndProc);
                m_lpfnComboWndProc = (WNDPROC) SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG_PTR) _ComboSubclassWndProc);

                TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::Init() wndproc=%x", m_lpfnComboWndProc);

                // Subclass the comboboxex too
                if (SetProp(hwnd, SZ_ADDRESSCOMBOEX_PROP, this))
                {
                    ASSERT(!m_lpfnComboExWndProc);
                    m_lpfnComboExWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_ComboExSubclassWndProc);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Set g_himl*
        //
        ASSERT(!m_pbp);
        hr = QueryService_SID_IBandProxy(punkParent, IID_IBandProxy, &m_pbp, NULL);

        // We need to set the list to MRU for the first time.
        // We need to do this to initialize the list because
        // it will be used even when other lists are selected.
        if (m_hwnd && LT_NONE == m_elt)
            _UseNewList(LT_TYPEIN_MRU);
    }

    if (hwndEditBox) {
        SendMessage(hwndEditBox, EM_SETLIMITTEXT, INTERNET_MAX_PATH_LENGTH - 1, 0);
    }

    return hr;
}


/****************************************************\
    FUNCTION: SetOwner

    PARAMETERS:
        punkOwner - Pointer to the parent object.

    DESCRIPTION:
        This function will be called to have this
    object try to obtain enough information about it's
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.
\****************************************************/
HRESULT CAddressEditBox::SetOwner(IUnknown* punkOwner)
{
    HRESULT hr = S_OK;

    if (m_pbs)
        _ConnectToBrwsrWnd(NULL);    // On-connect from Browser Window.

    if (m_hwnd && !punkOwner)
    {
        if (m_palSNS)
            m_palSNS->Save();
        if (m_palMRU)
            m_palMRU->Save();
    }

    IUnknown_Set(&m_punkParent, punkOwner);     // Needed to break ref count cycle.

    _ConnectToBrwsrWnd(punkOwner);    // On-connect from Browser Window.

    return hr;
}


/****************************************************\
    FUNCTION: SetCurrentDir

    DESCRIPTION:
        Set the Current Working directory so parsing
    will work correctly.
\****************************************************/
HRESULT CAddressEditBox::SetCurrentDir(LPCOLESTR pwzDir)
{
    HRESULT hr;
    SHSTR strWorkingDir;

    hr = strWorkingDir.SetStr(pwzDir);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;

        hr = IECreateFromPath(strWorkingDir.GetStr(), &pidl);
        if (SUCCEEDED(hr))
        {
            hr = _CreateCShellUrl();
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                hr = m_pshuUrl->SetCurrentWorkingDir(pidl);
            ILFree(pidl);
        }
    }
    return hr;
}


/****************************************************\
    FUNCTION: ParseNow

    PARAMETERS:
        dwFlags - Parse Flags

    DESCRIPTION:
        Parse the text that is currently in the EditBox.
\****************************************************/
HRESULT CAddressEditBox::ParseNow(DWORD dwFlags)
{
    HRESULT hr;

    TCHAR szBuffer[MAX_URL_STRING];
    ASSERT(m_hwnd);
    GetWindowText(m_hwnd, szBuffer, SIZECHARS(szBuffer));
    hr = _CreateCShellUrl();

    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        if (m_fConnectedToBrowser && !SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("Use Path"), FALSE, FALSE))
        {
            dwFlags |= SHURL_FLAGS_NOPATHSEARCH;
        }

        if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("AutoCorrect"), FALSE, /*default*/TRUE))
        {
            dwFlags |= SHURL_FLAGS_AUTOCORRECT;
        }

        hr = m_pshuUrl->ParseFromOutsideSource(szBuffer, dwFlags);
    }

    return hr;
}


/****************************************************\
    FUNCTION: Execute

    PARAMETERS:
        dwExecFlags - Execute Flags

    DESCRIPTION:
        This function will execute the last parsed string.
    In most cases, the caller should call ::ParseNow()
    first.
\****************************************************/
HRESULT CAddressEditBox::Execute(DWORD dwExecFlags)
{
    HRESULT hr = E_FAIL;

    ASSERT(m_pshuUrl);
    TCHAR   szShortcutFilePath[MAX_PATH];
    LPITEMIDLIST pidl;

    hr = m_pshuUrl->GetPidlNoGenerate(&pidl);

    if (SUCCEEDED(hr))
    {
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szShortcutFilePath, SIZECHARS(szShortcutFilePath), NULL);
        ILFree(pidl);
    }

    // if this is a .url and we can navigate to it
    // then we need to do that now, otherwise
    // we'll end up with a shell exec happening
    // which will open the .url in whatever
    // browse window the system happens to like

    if (SUCCEEDED(hr))
    {
        ASSERT(m_punkParent != NULL);

        // try navigating in the current browser window
        // NavFrameWithFile will exit without doing
        // anything if we're not dealing with a .url
        hr = NavFrameWithFile(szShortcutFilePath, m_punkParent);
    }

    // it's not a .url or we can't nav to it for some reason
    // let the general handlers have a shot now

    if (FAILED(hr))
    {
        hr = m_pshuUrl->Execute(m_pbp, &m_fDidShellExec,dwExecFlags);
    }
    return hr;
}




//================================
// *** IAddressBand Interface ***

/****************************************************\
    FUNCTION: FileSysChange

    DESCRIPTION:
        This function will handle file system change
    notifications.
\****************************************************/
HRESULT CAddressEditBox::FileSysChange(DWORD dwEvent, LPCITEMIDLIST *ppidl)
{
    // m_hwnd == NULL means we don't need to do anything
    // however we will probably never get that event
    // if that is the case.

    if (m_palSNS)
        m_palSNS->FileSysChangeAL(dwEvent, ppidl);

    return S_OK;
}


/****************************************************\
    FUNCTION: Refresh

    PARAMETERS:
        pvarType - NULL for a refress of everything.
                   OLECMD_REFRESH_TOPMOST will only update the top most.

    DESCRIPTION:
        This function will force a refress of part
    or all of the AddressBand.
\****************************************************/
HRESULT CAddressEditBox::Refresh(VARIANT * pvarType)
{
    //
    // Refreshing does not automatically refresh the contents of the
    // edit window because a DISPID_DOCUMENTCOMPLETE or DISPID_NAVIGATECOMPLETE2
    // is not sent.  So we restore the contents ourselves.
    //
    if (m_hwndEdit && m_pszCurrentUrl && !IsErrorUrl(m_pszCurrentUrl))
    {
        TCHAR szTemp[MAX_URL_STRING];

        StrCpyN(szTemp, m_pszCurrentUrl, ARRAYSIZE(szTemp));
        SendMessage(m_hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)szTemp);
    }

    DWORD dwType = OLECMD_REFRESH_ENTIRELIST; // Default

    if (pvarType)
    {
        if (VT_I4 != pvarType->vt)
            return E_INVALIDARG;

        dwType = pvarType->lVal;
    }

    if (m_hwnd && m_palCurrent && m_pbs)
    {
        if (!m_pszCurrentUrl)
        {
            if (!m_pshuUrl)
            {
                _CreateCShellUrl();
            }

            LPITEMIDLIST pidl;
            if (SUCCEEDED(m_pbs->GetPidl(&pidl)))
            {
                if (SUCCEEDED(m_pshuUrl->SetPidl(pidl)) && m_pshuUrl)
                {
                    TCHAR szDisplayName[MAX_URL_STRING];
                    if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                    {
                        Str_SetPtr(&m_pszCurrentUrl, szDisplayName);
                    }
                }
                ILFree(pidl);
            }
        }

        if (m_pszCurrentUrl)
        {
            _UseNewList(PathIsURL(m_pszCurrentUrl) ? LT_TYPEIN_MRU : LT_SHELLNAMESPACE);
            if (m_palCurrent)
            {
                m_palCurrent->Connect(TRUE, m_hwnd, m_pbs, m_pbp, m_pac);
                m_palCurrent->Refresh(dwType);
            }
        }
    }

    return S_OK;
}


//================================
// *** Internal/Private Methods ***

//=================================================================
// General Band Functions
//=================================================================

/****************************************************\

    Address Band Constructor

\****************************************************/
CAddressEditBox::CAddressEditBox()
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CAddressEditBox %x", this);
    m_cRef = 1;

    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!m_punkParent);
    ASSERT(!m_hwnd);
    ASSERT(!m_hwndEdit);
    ASSERT(!m_lpfnComboWndProc);

    ASSERT(!m_pbp);
    ASSERT(!m_pbs);
    ASSERT(!m_dwcpCookie);
    ASSERT(!m_pszCurrentUrl);
    ASSERT(!m_pszPendingURL);
    ASSERT(!m_pac);
    ASSERT(!m_pssACLISF);
    ASSERT(!m_palCurrent);
    ASSERT(!m_palSNS);
    ASSERT(!m_palMRU);
    ASSERT(!m_pmru);
    ASSERT(!m_pshuUrl);
    ASSERT(!m_fDidShellExec);
    ASSERT(!m_pszUserEnteredURL);
    ASSERT(!m_fConnectedToBrowser);
    ASSERT(!m_pAsyncNav);
    ASSERT(!m_fAsyncNavInProgress);

    ASSERT(AEB_INIT_DEFAULT == m_dwFlags);

    m_nOldSelection = -1;
    m_elt = LT_NONE;
    m_cbex.mask = 0;
    m_cbex.pszText = 0;
    m_cbex.cchTextMax = 0;

    if (!g_nAEB_AsyncNavigation)
        g_nAEB_AsyncNavigation = RegisterWindowMessage(TEXT("CAEBAsyncNavigation"));

}


/****************************************************\

    Address Band destructor

\****************************************************/
CAddressEditBox::~CAddressEditBox()
{
    _CancelNavigation();

    ATOMICRELEASE(m_punkParent);
    ATOMICRELEASE(m_pac);
    ATOMICRELEASE(m_pssACLISF);
    ATOMICRELEASE(m_palSNS);
    ATOMICRELEASE(m_palMRU);
    ATOMICRELEASE(m_palCurrent);
    ATOMICRELEASE(m_pbp);
    ATOMICRELEASE(m_pbs);
    ATOMICRELEASE(m_pmru);

    if (m_pshuUrl)
    {
        delete m_pshuUrl;
    }

    Str_SetPtr(&m_pszCurrentUrl, NULL);
    Str_SetPtr(&m_pszPendingURL, NULL);
    Str_SetPtr(&m_pszUserEnteredURL, NULL);
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);

    _RemoveHook();
    if (m_fAssociated)
    {
        m_al.Delete(GetCurrentThreadId());
    }

    Str_SetPtr(&m_cbex.pszText, NULL);

    TraceMsg(TF_SHDLIFE, "dtor CAddressEditBox %x", this);
    DllRelease();
}

/****************************************************\
    FUNCTION: CAddressEditBox_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    AddressBand COM object.
\****************************************************/
HRESULT CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    *ppunk = NULL;
    CAddressEditBox * p = new CAddressEditBox();
    if (p)
    {
        *ppunk = SAFECAST(p, IAddressBand *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: _OnNotify

    DESCRIPTION:
        This function will handle WM_NOTIFY messages.
\****************************************************/
LRESULT CAddressEditBox::_OnNotify(LPNMHDR pnm)
{
    // HACKHACK: combobox (comctl32\comboex.c) will pass a LPNMHDR, but it's really
    // a PNMCOMBOBOXEX (which has a first element of LPNMHDR).  This function
    // can use this type cast iff it's guaranteed that this will only come from
    // a function that behaves in this perverse way.
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnm;

    ASSERT(pnm);
    switch (pnm->code)
    {
    case CBEN_BEGINEDIT:
        _OnBeginEdit(pnm);
        break;

    case CBEN_ENDEDITA:
        _OnEndEditA((LPNMCBEENDEDITA)pnm);
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_OnNotify(), pnm->code=CBEN_ENDEDITA");
        break;

    case CBEN_ENDEDITW:
        _OnEndEditW((LPNMCBEENDEDITW)pnm);
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_OnNotify(), pnm->code=CBEN_ENDEDITW");
        break;

    default:
        break;
    }

    return 0;
}


LRESULT CAddressEditBox::_OnBeginEdit(LPNMHDR pnm)
{
    if (m_punkParent)
        IUnknown_OnFocusChangeIS(m_punkParent, m_punkParent, TRUE);

    return 0;

}

/****************************************************\
    FUNCTION: _OnEndEditW

    DESCRIPTION:
        Thunk to _OnEndEditA.
\****************************************************/

LRESULT CAddressEditBox::_OnEndEditW(LPNMCBEENDEDITW pnmW)
{
    NMCBEENDEDITA nmA;

    nmA.hdr = pnmW->hdr;
    nmA.fChanged = pnmW->fChanged;
    nmA.iNewSelection = pnmW->iNewSelection;
    nmA.iWhy = pnmW->iWhy;

    // don't we lose unicode information on this transition?!
    // We don't use pnmw->szText so don't bother converting it
    // SHUnicodeToAnsi(pnmW->szText, nmA.szText, ARRAYSIZE(nmA.szText));
    nmA.szText[0] = 0;

    return _OnEndEditA(&nmA);
}




/****************************************************\
    FUNCTION: _OnEndEditA

    DESCRIPTION:
        Handle the WM_NOTIFY/CBEN_ENDEDITA message.
\****************************************************/
LRESULT CAddressEditBox::_OnEndEditA(LPNMCBEENDEDITA pnmA)
{
    BOOL fRestoreIcons = TRUE;
    ASSERT(pnmA);

    //
    // Navigate only if the user pressed enter in the edit control.
    //
    ASSERT(m_hwnd);
    switch (pnmA->iWhy)
    {
        case CBENF_RETURN:
            {
                if (g_dwProfileCAP & 0x00000002) {
                    StartCAP();
                }

                // Use szUrl and ignore pnmA->szText because it truncates to MAX_PATH (=256)
                TCHAR szUrl[MAX_URL_STRING];

                if (m_hwndEdit)
                {
                    // Allow the edit text to be updated
                    _ClearDirtyFlag();

                    GetWindowText(m_hwndEdit, szUrl, SIZECHARS(szUrl));
#ifdef UNIX_FEATURE_ALIAS
                    // IEUNIX: Check for alises and replace the string we got
                    // from the address bar.
                    {
                        CHAR szTemp[MAX_URL_STRING], szUrlAlias[MAX_URL_STRING];

                        HDPA aliasList = GetGlobalAliasList();
                        if (aliasList)
                        {
                            SHUnicodeToAnsi(szUrl, szTemp, SIZECHARS(szTemp));
                            if ( GetURLForAliasA(aliasList, szTemp, szUrlAlias,
                                SIZECHARS(szUrlAlias)) )
                            {
                                SHAnsiToUnicode(szUrlAlias, szUrl, MAX_URL_STRING);
                            }
                        }
                    }
#endif /* UNIX_FEATURE_ALIAS */
                    Str_SetPtr(&m_pszUserEnteredURL, szUrl);

                    // If edit box is empty, don't show icon
                    if (*szUrl == L'\0')
                    {
                        fRestoreIcons = FALSE;
                    }

#ifndef NO_ETW_TRACING
                    // Event trace for windows enable by shlwapi.
                    if (g_dwStopWatchMode & SPMODE_EVENTTRACE) {
                        EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_ADDRESS,
                                          szUrl);
                    }
#endif
                    if (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA))
                    {
                        DWORD dwTime = GetPerfTime();
                        if (g_dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
                            StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Same"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
                        if (g_dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
                            StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Same"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
                    }

                    // If the WindowText matches the last URL we navigated
                    // to, then we need to call Refresh() instead of _HandleUserAction().
                    // This is because IWebBrowser2::Navigate2() ignores any commands that
                    // point to the same URL that it's already navigated to.
                    if (m_pszCurrentUrl && m_hwnd && !m_fDidShellExec &&
                        m_fConnectedToBrowser && (-1 == pnmA->iNewSelection) &&
                        (0 == lstrcmp(m_pszCurrentUrl, szUrl)))
                    {
                        IUnknown *punk = NULL;

                        // Refresh Browser.
                        if (m_pbp)
                        {
                            m_pbp->GetBrowserWindow(&punk);
                        }
                        if (punk) {
                            IWebBrowser* pwb;
                            punk->QueryInterface(IID_IWebBrowser, (LPVOID*)&pwb);
                            if (pwb) {
                                VARIANT v = {0};
                                v.vt = VT_I4;
                                v.lVal = OLECMDIDF_REFRESH_RELOAD|OLECMDIDF_REFRESH_CLEARUSERINPUT;
                                Refresh(NULL);
                                pwb->Refresh2(&v);
                                pwb->Release();
                            }
                            punk->Release();
                        }
                    }
                    else
                    {
                        SendMessage(m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
                        _HandleUserAction(szUrl, pnmA->iNewSelection);
                    }
                    UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVADDRESS);
                }
            }
            break;
        case CBENF_KILLFOCUS:
            fRestoreIcons = FALSE;
            break;

        case CBENF_ESCAPE:
            // Abort and clear the dirty flag
            _ClearDirtyFlag();
            if (m_hwndEdit && m_pszCurrentUrl && m_cbex.mask != 0)
            {
                SendMessage(m_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&m_cbex);
            }

            SendMessage(m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
            if (pnmA->iNewSelection != -1) {
                SendMessage(m_hwnd, CB_SETCURSEL, pnmA->iNewSelection, 0);
            }
            fRestoreIcons = FALSE;
            break;
    }

    if (fRestoreIcons)
    {
        SendMessage(m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, 0);
    }
    return 0;
}


/****************************************************\
    FUNCTION: _ConnectToBrwsrWnd

    DESCRIPTION:
        The IUnknown parameter needs to point to an
    object that supports the IBrowserService and
    IWebBrowserApp interfaces.
\****************************************************/
HRESULT CAddressEditBox::_ConnectToBrwsrWnd(IUnknown* punk)
{
    HRESULT hr = S_OK;

    if (m_pbs) {
        _ConnectToBrwsrConnectionPoint(FALSE, m_punkParent);
        ATOMICRELEASE(m_pbs);
    }

    if (punk)
    {
        IUnknown * punkHack;

        // HACK: We behave differently if we are hosted outside of a browser
        //       than we do if we are in a browser.  This call does nothing
        //       but identify our host.
        if (SUCCEEDED(IUnknown_QueryService(punk, SID_SShellDesktop, IID_IUnknown, (void**)&punkHack)))
            punkHack->Release();
        else
        {
            // No, we are not hosted on the desktop, so we can synch to the events of the browser.

            hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_IBrowserService, (void**)&m_pbs);
            if (SUCCEEDED(hr))
            {
                // We only want notifications if we are the AddressBar.
                _ConnectToBrwsrConnectionPoint(TRUE, punk);
            }
        }
    }

    // TODO: At some point we will need to implement IPropertyBag so
    //       the parent can specify if they want us to behave as though
    //       we are contected or not.  For now, we will use the fact
    //       that we are either have a IBrowserService pointer or not.
    m_fConnectedToBrowser = BOOLIFY(m_pbs);


    if (!m_pac)
    {
        // We need to wait to create the AutoComplete Lists until m_fConnectedToBrowser is set.
        if (m_hwndEdit)
            hr = SHUseDefaultAutoComplete(m_hwndEdit, NULL, &m_pac, &m_pssACLISF, m_fConnectedToBrowser);

        if (SUCCEEDED(hr))
        {
            _SetAutocompleteOptions();
        }
    }

    //
    // Subclass edit control of the combobox.  We do this here rather than when this
    // class is initialized so that we are first in the chain to receive messages.
    //
    if (!m_lpfnEditWndProc && m_hwndEdit && SetProp(m_hwndEdit, SZ_ADDRESSCOMBO_PROP, this))
    {
        m_lpfnEditWndProc = (WNDPROC)SetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _EditSubclassWndProc);
    }

    // This function will be called if: 1) we are becoming connected to a
    // browser, 2) switch from one browser to another, or 3) are
    // becoming unconnected from a browser.  In any case, we need to
    // update the ISF AutoComplete List so it can retrieve
    // the current location from the appropriate browser.
    if (m_pssACLISF)
        m_pssACLISF->SetOwner(m_pbs);

    return hr;
}


/****************************************************\
    FUNCTION: _ConnectToBrwsrConnectionPoint

    DESCRIPTION:
        Connect to Browser Window's ConnectionPoint
    that will provide events to let us keep up to date.
\****************************************************/
HRESULT CAddressEditBox::_ConnectToBrwsrConnectionPoint(BOOL fConnect, IUnknown * punk)
{
    HRESULT hr = S_OK;
    IConnectionPointContainer *pcpContainer;

    if (punk)
    {
        hr = IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_IConnectionPointContainer, (void **)&pcpContainer);
        // Let's now have the Browser Window give us notification when something happens.
        if (SUCCEEDED(hr))
        {
            hr = ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect,
                                          pcpContainer, &m_dwcpCookie, NULL);
            pcpContainer->Release();
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
        Handle WM_COMMAND messages.
\****************************************************/
LRESULT CAddressEditBox::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (uCmd)
    {
        case CBN_EDITCHANGE:
        {
            HWND hwndFocus = GetFocus();
            if ((NULL != hwndFocus) && IsChild(m_hwnd, hwndFocus))
            {
                DWORD dwStyle = _IsDirty() ? CBES_EX_NOEDITIMAGE : 0;
                SendMessage(m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, dwStyle);
            }
            break;
        }

        case CBN_CLOSEUP:
            {
                //
                // Navigate to the selected string when the dropdown is not down.
                //
                int nSel = ComboBox_GetCurSel(m_hwnd);
                if ((m_nOldSelection != SEL_ESCAPE_PRESSED) &&
                    (m_nOldSelection != nSel) && (nSel > -1))
                {
                    _HandleUserAction(NULL, nSel);

                    // RedrawWindow eliminates annoying half-paint that
                    // occurs while navigating from one pidl to a smaller pidl.
                    RedrawWindow(m_hwnd, NULL, NULL, RDW_INTERNALPAINT | RDW_UPDATENOW);
                }
            }

            if (m_pac)
                m_pac->Enable(TRUE);
            break;

        case CBN_DROPDOWN:
            if (m_pac)
                m_pac->Enable(FALSE);
            break;
    }

    return 0;
}

/*******************************************************************
    FUNCTION: _CreateCShellUrl

    DESCRIPTION:
        Create the m_pshuUrl CShellUrl if needed.
********************************************************************/
HRESULT CAddressEditBox::_CreateCShellUrl(void)
{
    HRESULT hr = S_OK;
    // Do we need to create our Shell Url?
    if (!m_pshuUrl)
    {
        // Yes
        m_pshuUrl = new CShellUrl();
        if (!m_pshuUrl)
        {
            return E_FAIL;
        }
        else
        {
            m_pshuUrl->SetMessageBoxParent(m_hwndEdit);

            // We need to set the "Shell Path" which will allow
            // the user to enter Display Names of items in Shell
            // Folders that are frequently used.  We add "Desktop"
            // and "Desktop/My Computer" to the Shell Path because
            // that is what users use most often.
            SetDefaultShellPath(m_pshuUrl);
        }
    }
    return hr;
}



/*******************************************************************
    FUNCTION: _HandleUserAction

    PARAMETERS:
        pszUrl - string of URL to navigate to.
        iNewSelection - index of current selection in address bar combo box

    DESCRIPTION:
        Called when the user types in or selects a URL to navigate
    to through the address bar.
********************************************************************/
HRESULT CAddressEditBox::_HandleUserAction(LPCTSTR pszUrl, int iNewSelection)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    static DWORD dwParseFlags = 0xFFFFFFFF;

    Str_SetPtr(&m_pszPendingURL, NULL);  // Clear if one exists.
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);
    hr = _CreateCShellUrl();
    if (FAILED(hr))
        return hr;

    // Are we connected to a Browser Window?
    if (m_pbs)
    {
        // Yes, so let's set our current working directory to the current window.
        LPITEMIDLIST pidl;
        m_pbs->GetPidl(&pidl);

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_HandleUserAction(), Current Pidl in TravelLog. PIDL=%s;", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

        if (pidl)
        {
            // m_pshuUrl will free pshuCurrWorkDir, so we can't.
            hr = m_pshuUrl->SetCurrentWorkingDir(pidl);
            ILFree(pidl);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Cancel previous pending nav if any
        _CancelNavigation();

        // Did the user select the item from the drop down list?
        if (-1 != iNewSelection)
        {
            // Yes, so point our CShellUrl at the item. (Pidl or URL)
            if (m_palCurrent)
                m_palCurrent->SetToListIndex(iNewSelection, (LPVOID) m_pshuUrl);

            // if the index indicates this was a selection from the combo box,
            // remember which selection it was
            SendMessage(m_hwnd, CB_SETCURSEL, (WPARAM)iNewSelection, 0L);

            *szDisplayName = L'\0';
            GetWindowText(m_hwnd, szDisplayName, ARRAYSIZE(szDisplayName));
            Str_SetPtr(&m_pszUserEnteredURL, szDisplayName);
            pszUrl = NULL;
        }
        else
        {
            // No, the user hit return with some string.
            ASSERT(pszUrl); // must have valid URL

            if (0xFFFFFFFF == dwParseFlags)
            {
                dwParseFlags = SHURL_FLAGS_NONE;
                if (m_fConnectedToBrowser && !SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("Use Path"), FALSE, FALSE))
                    dwParseFlags = SHURL_FLAGS_NOPATHSEARCH;

                if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("AutoCorrect"), FALSE, /*default*/TRUE))
                    dwParseFlags |= SHURL_FLAGS_AUTOCORRECT;
            }
        }

        hr = E_FAIL;
        if (m_hwnd && m_pshuUrl)
        {
            if (!(m_dwFlags & AEB_INIT_NOASYNC))    // Is async navigate enabled?
            {
                // Create and initialize the AsyncNav object used to communicate with the thread
                m_pAsyncNav = new AsyncNav();
                if (m_pAsyncNav)
                {
                    if(m_punkParent)
                    {
                        // Get the globe spinning indicating our processing
                        hr = IUnknown_QueryServiceExec(m_punkParent, SID_SBrandBand, &CGID_BrandCmdGroup, CBRANDIDM_STARTGLOBEANIMATION, 0, NULL, NULL);
                    }

                    m_pAsyncNav->_dwParseFlags = dwParseFlags;
                    m_pAsyncNav->_hwnd = m_hwnd;
 
                    if (pszUrl)
                        Str_SetPtr(&(m_pAsyncNav->_pszUrl), pszUrl);
                    else
                        m_pAsyncNav->_fPidlCheckOnly = TRUE;

                
                    if (!pszUrl || (pszUrl && m_pAsyncNav->_pszUrl))
                    {
                        CShellUrl *pshu = new CShellUrl();

                        if (pshu)
                        {
                            hr = pshu->Clone(m_pshuUrl);
                            m_pAsyncNav->_pShellUrl = pshu;

                            // AddRef here to give it to the thread
                            m_pAsyncNav->AddRef();

                            // Create the thread that will do the PIDL creation
                            if (FAILED(hr) || !SHCreateThread(_AsyncNavigateThreadProc, (LPVOID)m_pAsyncNav, CTF_COINIT, NULL))
                            {
                                hr = E_FAIL;
                            }
                            else
                            {

                                hr = E_PENDING;
                            }
                        }
                    }
                }
            }

            if (FAILED(hr) && hr != E_PENDING)
            {
                // Cancel Async navigation leftovers
                _CancelNavigation();

                if (pszUrl)
                {
                    BOOL fWasCorrected = FALSE;
                    hr = m_pshuUrl->ParseFromOutsideSource(pszUrl, dwParseFlags, &fWasCorrected);

                    // If the URL was autocorrected, put the corrected url in the editbox
                    // so that an invalid url in not added to our MRU if navigation succeeds
                    if (SUCCEEDED(hr) && fWasCorrected)
                    {
                        if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                        {
                            SetWindowText(m_hwndEdit, szDisplayName);
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        _FinishNavigate();
    }

    SetCursor(hCursorOld);
    return hr;
}

HRESULT CAddressEditBox::_FinishNavigate()
{
    HRESULT hr;

    hr = Execute( (m_fConnectedToBrowser ? SHURL_EXECFLAGS_NONE : SHURL_EXECFLAGS_DONTFORCEIE));
    // if we managed to navigate by one means or another, then do all the
    // associated processing
    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[MAX_URL_STRING];
        hr = m_pshuUrl->GetDisplayName(szDisplayName, SIZECHARS(szDisplayName));
        ASSERT(SUCCEEDED(hr));

        Str_SetPtr(&m_pszPendingURL, szDisplayName);
        if (!m_fConnectedToBrowser || m_fDidShellExec)
        {
            // We aren't connected to a browser window
            // so we need to call _NavigationComplete() our selves
            // because it will not come from the Browser window
            // it self.

            // If m_fDidShellExec, we need to manually add this because
            // we won't receive a DISPID_NAVIGATECOMPLETE event, but
            // we pass NULL to indicate

            hr = _NavigationComplete(szDisplayName, !m_fDidShellExec, TRUE);
        }
    }
    return hr;
}

void CAddressEditBox::_JustifyAddressBarText( void )
{
    // Either of the following appear to work:
    //	(a) EM_SETSEL(0,0) followed by EM_SCROLLCARET(0,0)
    //		SendMessage( m_hwndEdit, EM_SETSEL, 0, 0 );
    //		SendMessage( m_hwndEdit, EM_SCROLLCARET, 0, 0 );
    //	(b) WM_KEYDOWN with VK_HOME
    //		SendMessage( m_hwndEdit, WM_KEYDOWN, VK_HOME, 0 );

    // Use the EM_SETSEL method to avoid user keyboard stroke interruption.
    SendMessage( m_hwndEdit, EM_SETSEL, 0, 0 );
    SendMessage( m_hwndEdit, EM_SCROLLCARET, 0, 0 );
}

HRESULT CAddressEditBox::_AsyncNavigate(AsyncNav *pAsyncNav)
{
    HRESULT hr;

    // we should only be called on one thread, but the interlocked can't hurt...
    if (InterlockedCompareExchange((LONG*)&m_fAsyncNavInProgress, TRUE, FALSE) == FALSE)
    {
        // this is the first call to _AsyncNavigate
        hr = pAsyncNav->_hr;

        if (SUCCEEDED(hr))
        {
            // Get the CShellUrl back after processing
            hr = m_pshuUrl->Clone(pAsyncNav->_pShellUrl);
        }

        // If the URL was autocorrected, put the corrected url in the editbox
        // so that an invalid url in not added to our MRU if navigation succeeds
        if (SUCCEEDED(hr) && pAsyncNav->_fWasCorrected)
        {
            TCHAR szDisplayName[MAX_URL_STRING];
            if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
            {
                SetWindowText(m_hwndEdit, szDisplayName);
            }
        }

        if (SUCCEEDED(hr))
            hr = _FinishNavigate();

        if (FAILED(hr) && pAsyncNav->_fPidlCheckOnly)
        {
            // Maybe the user needs to insert the media, format, or
            // reconnect to the disk before this will succeed.  Check for that
            // and prompt now.
            // This fixes the common case where the floppy or CD isn't inserted and
            // we want to display the user friendly dialog.

            LPITEMIDLIST pidl;

            hr = pAsyncNav->_pShellUrl->GetPidlNoGenerate(&pidl);

            // We need to resolve the URL into its path so SHPathPrepareForWrite works correctly
            if (SUCCEEDED(hr))
            {
                TCHAR szShortcutFilePath[MAX_PATH];
                hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szShortcutFilePath, SIZECHARS(szShortcutFilePath), NULL);

                if (SUCCEEDED(hr))
                {
                    HRESULT hrPrompt = SHPathPrepareForWrite(pAsyncNav->_hwnd, NULL, szShortcutFilePath, SHPPFW_DEFAULT);
                    if (SUCCEEDED(hrPrompt))
                    {
                        hr = _FinishNavigate();
                    }
                    else
                    {
                        // Propagate out the fact that the user clicked the cancel button.
                        hr = hrPrompt;
                    }
                }
            
                ILFree(pidl);
            }

            // Never display a err if the user cancelled the operation.
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                TCHAR szDisplayName[MAX_URL_STRING];
                if (SUCCEEDED(pAsyncNav->_pShellUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    MLShellMessageBox(pAsyncNav->_hwnd, MAKEINTRESOURCE(IDS_ADDRBAND_DEVICE_NOTAVAILABLE),
                        MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                        (MB_OK | MB_ICONERROR), szDisplayName);
                }
            }
        }

        // Cleanup async navigation stuff
        _CancelNavigation();

        InterlockedExchange((LONG*)&m_fAsyncNavInProgress, FALSE);
    }
    else
    {
        // we can only do one async navigate at a time
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CAddressEditBox::_CancelNavigation()
{
    if (m_pAsyncNav)
    {
        if(m_punkParent)
        {
            HRESULT hr = IUnknown_QueryServiceExec(m_punkParent, SID_SBrandBand, &CGID_BrandCmdGroup, CBRANDIDM_STOPGLOBEANIMATION, 0, NULL, NULL);
        }
        m_pAsyncNav->Release();
        m_pAsyncNav = NULL;
    }

    return S_OK;
}

DWORD CAddressEditBox::_AsyncNavigateThreadProc(LPVOID pvData)
{
    AsyncNav *pAsyncNav = (AsyncNav *)pvData;

    if (pAsyncNav->_hwnd && g_nAEB_AsyncNavigation)
    {
        if(pAsyncNav->_fPidlCheckOnly)
        {
            LPITEMIDLIST pidl;

            pAsyncNav->_hr = pAsyncNav->_pShellUrl->GetPidlNoGenerate(&pidl);
            if (SUCCEEDED(pAsyncNav->_hr))
            {
                DWORD dwAttrib = SFGAO_VALIDATE;
                pAsyncNav->_hr = IEGetNameAndFlags(pidl, 0, NULL, 0, &dwAttrib);
            }
            else
            {
                // Special case for keywords. We want to proceed if we don't have a pidl
                pAsyncNav->_hr = S_OK;
            }
        }
        else
        {
            pAsyncNav->_hr = pAsyncNav->_pShellUrl->ParseFromOutsideSource(pAsyncNav->_pszUrl, pAsyncNav->_dwParseFlags, &(pAsyncNav->_fWasCorrected));
        }
        pAsyncNav->_fReady = TRUE;
        PostMessage(pAsyncNav->_hwnd, g_nAEB_AsyncNavigation, (WPARAM)pAsyncNav, NULL);
    }

    // We are done with this now.
    // If the navigation was canceled, then the object will destruct now, and the posted
    // message above will be ignored.
    pAsyncNav->Release();


    return 0;
}


BOOL CAddressEditBox::_IsShellUrl(void)
{
    // 1. Check if we need to change the List.
    BOOL fIsShellUrl = !m_pshuUrl->IsWebUrl();

    if (fIsShellUrl)
    {
        // BUG #50703: Users want MRU when about: url is displayed.
        TCHAR szUrl[MAX_URL_STRING];

        if (SUCCEEDED(m_pshuUrl->GetUrl(szUrl, ARRAYSIZE(szUrl))))
        {
            if (URL_SCHEME_ABOUT == GetUrlScheme(szUrl))
            {
                fIsShellUrl = FALSE;  // Make it use the MRU List.
            }
        }
    }

    return fIsShellUrl;
}


/*******************************************************************
    FUNCTION: _NavigationComplete

    PARAMETERS:
        pszUrl - String user entered.
        fChangeLists - Should we modify the Drop Down list?
        fAddToMRU - Should we add it to the MRU?

    DESCRIPTION:
        This function is called when either: 1) a naviation completes,
    or 2) the user entered text into the AddressEditBox that needs
    to be handled but will not cause a NAVIGATION_COMPLETE message.
    This function will change the AddressList being used and will
    add the item to the Type-in MRU.
********************************************************************/
HRESULT CAddressEditBox::_NavigationComplete(LPCTSTR pszUrl /* Optional */, BOOL fChangeLists, BOOL fAddToMRU)
{
    HRESULT hr = S_OK;

    // Are we controlling a ComboBoxEx?
    if (m_hwnd)
    {
        // Yes, so do ComboBoxEx Specific things...

        // If the list is dropped, undrop it so the contents of the editbox and list
        // are properly updated.
        if (m_hwnd  && m_hwndEdit && ComboBox_GetDroppedState(m_hwnd))
        {
            SendMessage(m_hwndEdit, WM_KEYDOWN, VK_ESCAPE, 0);
        }

        if (fChangeLists)
        {
            BOOL fIsShellUrl = _IsShellUrl();

            // 2. Do we need to change lists to MRU List?
            if (!fIsShellUrl && m_elt != LT_TYPEIN_MRU)
            {
                // We need to start using the LT_TYPEIN_MRU list
                // because that list is what is needed for Internet Urls.
                _UseNewList(LT_TYPEIN_MRU);
            }

            // We only want to switch to using the shell name space
            // if we are connected to a browser.
            if (fIsShellUrl && (m_elt != LT_SHELLNAMESPACE) && m_fConnectedToBrowser)
            {
                // We need to start using the LT_SHELLNAMESPACE list
                // because that list is what is needed for File Urls.
                _UseNewList(LT_SHELLNAMESPACE);
            }

            ASSERT(m_palCurrent);
            hr = m_palCurrent ? m_palCurrent->NavigationComplete((LPVOID) m_pshuUrl) : E_FAIL;

            if ( SUCCEEDED( hr ) )
            {
                // Insure that after the navigation completes, the Address Bar Text is left justified.
                _JustifyAddressBarText();
            }
        }

        // Don't display the url to internal error pages. All internal error
        // urls start with res:// and we don't want these in our MRU.
        // We also don't want to display error pages from the server.
        if ((pszUrl && (TEXT('r') == pszUrl[0]) && (TEXT('e') == pszUrl[1]) && IsErrorUrl(pszUrl)) ||
            (m_pszHttpErrorUrl && StrCmp(m_pszHttpErrorUrl, pszUrl) == 0))
        {
            // We don't want this in our MRU!
            fAddToMRU = FALSE;
        }

        // Do we have a Pending URL, meaning the user hand typed it in
        // and the navigation finished (wasn't cancelled or failed).
        //
        // REARCHITECT: Currently there are a few cases when the URL (m_pszPendingURL)
        //         is added to the MRU when it shouldn't.
        // 1. If the user enters an URL and then cancels the navigation, we
        //    don't clear m_pszPendingURL.  If the user then causes the browser
        //    to navigate by some other means (HREF Click, Favorites/QLink navigation
        //    , or Floating AddressBand), we will receive the NAVIGATION_COMPLETE
        //    message and think it was for the originally cancelled URL.

        if (fAddToMRU && m_pszPendingURL)
        {
            // Yes, so add it to the MRU.
            if (SUCCEEDED(hr))
            {
                if (!m_pmru && m_palMRU)
                    hr = m_palMRU->QueryInterface(IID_IMRU, (LPVOID *)&m_pmru);

                if (SUCCEEDED(hr))
                {
                    SHCleanupUrlForDisplay(m_pszPendingURL);
                    hr = m_pmru->AddEntry(m_pszPendingURL); // Add to MRU
                }
            }
        }
    }

    Str_SetPtr(&m_pszPendingURL, NULL);
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);

    return hr;
}

//=================================================================
// AddressEditBox Modification Functions
//=================================================================

/****************************************************\
    _ComboSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.
\****************************************************/
LRESULT CALLBACK CAddressEditBox::_ComboSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndBand = GetParent(hwnd);
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBO_PROP);

    ASSERT(paeb);
    g_hWinStationAfter = GetProcessWindowStation();

    // In stress we see someone will stomp our property with -2.  We need to find out who it is.
    // Call ReinerF if this happens
    AssertMsg(((void *)-2 != paeb), TEXT("Someone corrupted our window property.  Call ReinerF"));
    if (!paeb)
    {
        return DefWindowProcWrap(hwnd, uMessage, wParam, lParam);
    }

    switch (uMessage)
    {
    case WM_SETCURSOR:
        {
            HWND hwndCursor = (HWND)wParam;
            int nHittest = LOWORD(lParam);
            if (hwndCursor == paeb->m_hwndEdit && nHittest == HTCLIENT)
            {
                //
                // If we don't have focus, we want to show an arrow because clicking will select
                // the contents of the edit box.  Otherwise show the I-beam.  Also, if the edit box
                // is empty we show the I-beam because there is nothing to select.
                //
                HWND hwndFocus = GetFocus();
                int cch = GetWindowTextLength(paeb->m_hwndEdit);

                LPCTSTR lpCursorName = (cch == 0 || hwndFocus == paeb->m_hwndEdit) ? IDC_IBEAM : IDC_ARROW;
                SetCursor(LoadCursor(NULL, lpCursorName));
                return TRUE;
            }
            break;
        }
    case WM_SETFOCUS:
        //
        // This is gross, but if the window was destroyed that had the
        // focus this would fail and we would not get this to the
        // combo box.
        //
        // This happens if you click on the combobox while
        // renaming a file in the defview.
        //
        if (wParam && !IsWindow((HWND)wParam))
            wParam = 0;
        break;

    case WM_DESTROY:
        // Unsubclass myself.
        if (!paeb->m_lpfnComboWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnComboWndProc);
        RemoveProp(hwnd, SZ_ADDRESSCOMBO_PROP);

        ASSERT(paeb->m_hwnd); // We don't want to be called twice
        paeb->m_hwnd = NULL;      // We have been destroyed.
        break;

    case WM_COMMAND:
        if (EN_UPDATE == GET_WM_COMMAND_CMD(wParam, lParam))
        {
            paeb->_InstallHookIfDirty();
        }
        break;
    case WM_KEYDOWN:
            switch (wParam)
            {
                //
                // Pressing escape results in the dropdown being hidden.  If
                // the mouse hot-tracks over a different selection than when the
                // combo was first dropped, we get a CBN_SELCHANGE event which
                // causes a false navigation.  We suppress this by setting
                // m_nOldSelection to a special value (-2).
                //
                case VK_ESCAPE:
                {
                    paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;

                    // Pass message on so that the content of the edit box is restored
                    SendMessage(paeb->m_hwndEdit, uMessage, wParam, lParam);
                    break;
                }
            }
            break;
    case WM_SYSKEYDOWN:
            switch (wParam)
            {
                case VK_DOWN:
                {
                    // Alt-down toggles the combobox dropdown.  We don't
                    // want a navigation if this key sequence closes the dropdown.
                    if (HIWORD(lParam) & KF_ALTDOWN)
                    {
                        paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;
                    }
                    break;
                }
            }
            break;
    case CB_SHOWDROPDOWN:
            // If dropdown is hidden, suppress navigation. See comment above for VK_ESCAPE.
            if (!wParam)
            {
                paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;
            }
            break;

    case WM_WINDOWPOSCHANGING:
        {
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOCOPYBITS;
        }
        break;

    case WM_GETOBJECT:
        if (lParam == OBJID_CLIENT)
        {
            CAddressEditAccessible *paea = new CAddressEditAccessible(hwnd, paeb->m_hwndEdit);

            if (NULL != paea)
            {
                LRESULT lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(paea, IAccessible *));
                paea->Release();

                return lres;
            }
        }
        break;


    default:
        // FEATURE: Do we need this?
        if (!(AEB_INIT_SUBCLASS & paeb->m_dwFlags))
        {
            paeb->OnWinEvent(paeb->m_hwnd, uMessage, wParam, lParam, NULL);
        }
        break;
    }

    return CallWindowProc(paeb->m_lpfnComboWndProc, hwnd, uMessage, wParam, lParam);
}

void CAddressEditBox::_SetAutocompleteOptions()
{
    if (m_pac)
    {
        // Set the autocomplete options
        DWORD dwOptions = ACO_SEARCH | ACO_FILTERPREFIXES | ACO_USETAB | ACO_UPDOWNKEYDROPSLIST;
        if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
        {
            dwOptions |= ACO_AUTOAPPEND;
        }

        if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
        {
            dwOptions |= ACO_AUTOSUGGEST;
        }

        m_pac->SetOptions(dwOptions);
    }
}

/****************************************************\

    FUNCTION: _NavigateToUrlCB

    PARAMETERS:
        lParam - The CAddressEditBox this pointer.
        lpUrl - The URL to navigate to.

    DESCRIPTION:
        This function is specifically for AutoComplete
        to call when it needs to navigate.
\****************************************************/

HRESULT CAddressEditBox::_NavigateToUrlCB(LPARAM lParam, LPTSTR lpUrl)
{
//  NOTE: We don't need to navigate because AutoComplete will
//  will send a message to the ComboBoxEx that will carry out
//  the navigation.
    return S_OK;
}


//=================================================================
// Functions to prevent clobbering the address contents while dirty
//=================================================================
#define TF_EDITBOX TF_BAND|TF_GENERAL
//#define TF_EDITBOX TF_ALWAYS

BOOL CAddressEditBox::_IsDirty()
{
    return m_hwndEdit && SendMessage(m_hwndEdit, EM_GETMODIFY, 0, 0L);
}

void CAddressEditBox::_ClearDirtyFlag()
{
    TraceMsg(TF_EDITBOX, "CAddressEditBox::_ClearDirtyFlag()");
    SendMessage(m_hwndEdit, EM_SETMODIFY, FALSE, 0);
    _RemoveHook();
}

void CAddressEditBox::_InstallHookIfDirty()
{
    //
    // We only need to install the hook if we are connected to a browser for update notifications
    //
    if (m_fConnectedToBrowser)
    {
        // Make sure we are associated with the current thread
        if (!m_fAssociated)
        {
            //
            // If a CAddressEditBox is already associated with this thread, remove that
            // association and remove any pending mouse hook.  This can happen if the
            // open dialog comes up and the address bar is visible.
            //
            DWORD dwThread = GetCurrentThreadId();
            CAddressEditBox* pAeb;
            if (SUCCEEDED(m_al.Find(dwThread, (LPVOID*)&pAeb)))
            {
                pAeb->_ClearDirtyFlag();
                pAeb->m_fAssociated = FALSE;
                m_al.Delete(dwThread);
            }

            // There should not be any other CAddressEditBox associated with this thread!
            ASSERT(FAILED(m_al.Find(dwThread, (LPVOID*)&pAeb)));

            //
            // Associate ourselves with the current thread id.  We need this because
            // windows hooks are global and have no data associated with them.
            // On the callback, we use our thread id as the key.
            //
            m_al.Add(dwThread, this);
            m_fAssociated = TRUE;
        }

        if (!m_hhook && _IsDirty())
        {
            // ML: HINST_THISDLL is valid in its use here
            m_hhook = SetWindowsHookEx(WH_MOUSE, _MsgHook, HINST_THISDLL, GetCurrentThreadId());
            TraceMsg(TF_EDITBOX, "CAddressEditBox::_InstallHookIfDirty(), Hook installed");

            //
            // Subclass edit control of the combobox.  We do this here rather than when this
            // class is initialized so that we are first in the chain to receive messages.
            //
            if (!m_lpfnEditWndProc && m_hwndEdit && SetProp(m_hwndEdit, SZ_ADDRESSCOMBO_PROP, this))
            {
                m_lpfnEditWndProc = (WNDPROC)SetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _EditSubclassWndProc);
            }

            // Clear and changes that we previously cached
            m_cbex.mask = 0;
        }
    }
}

void CAddressEditBox::_RemoveHook()
{
    if (m_hhook)
    {
        UnhookWindowsHookEx(m_hhook);
        m_hhook = FALSE;
        TraceMsg(TF_EDITBOX, "CAddressEditBox::_RemoveHook(), Hook removed");
    }
}

LRESULT CALLBACK CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    //
    // Get the CAddressEditBox associated with this thread. We need this because
    // windows hooks are global and have no data associated with them.
    // On the callback, we use our thread id as the key
    //
    CAddressEditBox* pThis;
    if (SUCCEEDED(CAddressEditBox::m_al.Find(GetCurrentThreadId(), (LPVOID*)&pThis)))
    {
        return pThis->_MsgHook(nCode, wParam, (MOUSEHOOKSTRUCT*)lParam);
    }
    return 0;
}

LRESULT CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs)
{
    ASSERT(NULL != pmhs);

    if (nCode >= 0)
    {
        if ((wParam == WM_LBUTTONDOWN) || (wParam == WM_RBUTTONDOWN))
        {
            // Ignore if the button was clicked in our combo box
            RECT rc;
            if (GetWindowRect(m_hwnd, &rc) && !PtInRect(&rc, pmhs->pt))
            {
                _ClearDirtyFlag();
                _RemoveHook();
            }
        }
    }

    return CallNextHookEx(m_hhook, nCode, wParam, (LPARAM)pmhs);
}

/****************************************************\
    _ComboExSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.

    Description:
        We subclass the outer combobox to prevent
        the contents from getting clobbered while
        and edit is in progress (ie dirty).

\****************************************************/
LRESULT CALLBACK CAddressEditBox::_ComboExSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBOEX_PROP);

    if (!paeb)
        return DefWindowProc(hwnd, uMessage, wParam, lParam);

    g_hWinStationAfterEx = GetProcessWindowStation();

    if (uMessage == g_nAEB_AsyncNavigation)
    {
        // If the navigation was not canceled before, then navigate now.
        if ((AsyncNav *)wParam == paeb->m_pAsyncNav && paeb->m_pAsyncNav->_fReady)
        {
            paeb->_AsyncNavigate((AsyncNav *)wParam);
        }
    }

    switch (uMessage)
    {
    case CBEM_SETITEM:
        {
            //
            // If we are still dirty, don't let anyone clobber our edit control contents!
            //
            const COMBOBOXEXITEM* pcCBItem = (const COMBOBOXEXITEM FAR *)lParam;
            if (paeb->_IsDirty() && pcCBItem->iItem == -1)
            {
                //
                // save this info so that if the user hits esc, we restore the right thing
                //
                if (IsFlagSet(pcCBItem->mask, CBEIF_TEXT))
                {
                    Str_SetPtr(&paeb->m_pszCurrentUrl, pcCBItem->pszText);
                }

                Str_SetPtr(&(paeb->m_cbex.pszText), NULL);      // Free the previous value
                paeb->m_cbex = *pcCBItem;
                paeb->m_cbex.pszText = NULL;
                Str_SetPtr(&(paeb->m_cbex.pszText), paeb->m_pszCurrentUrl);
                paeb->m_cbex.cchTextMax = lstrlen(paeb->m_cbex.pszText);
                return 0L;
            }
            else
            {
                // Make sure that the icon is visible
                SendMessage(paeb->m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, 0);
            }
        }
        break;

    case WM_DESTROY:
        // Release the lists now so that they don't try to use our
        // window after we're destroyed
        if (paeb->m_palCurrent)
        {
            paeb->m_palCurrent->Connect(FALSE, paeb->m_hwnd, NULL, NULL, NULL);
            ATOMICRELEASE(paeb->m_palCurrent);
        }
        ATOMICRELEASE(paeb->m_palSNS);
        ATOMICRELEASE(paeb->m_palMRU);

        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, SZ_ADDRESSCOMBOEX_PROP);
        if (!paeb->m_lpfnComboExWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnComboExWndProc);
        break;

    default:
        break;
    }

    return CallWindowProc(paeb->m_lpfnComboExWndProc, hwnd, uMessage, wParam, lParam);
}

/****************************************************\
    _EnumFindWindow

    Description:
        Called by EnumChildWindows to see is the window
        passed in lParam is a child of a given
        parent.

\****************************************************/
BOOL CALLBACK CAddressEditBox::_EnumFindWindow
(
    HWND hwnd,      // handle to child window
    LPARAM lParam   // application-defined value
)
{
    // Stop enumeration when match found
    return (hwnd != (HWND)lParam);
}

/****************************************************\
    _EditSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.

    Description:
        We subclass the edit control in the combobox
        so that we can keep it from losing focus under
        certain conditions.

\****************************************************/
LRESULT CALLBACK CAddressEditBox::_EditSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBO_PROP);

    if (!paeb)
        return DefWindowProc(hwnd, uMessage, wParam, lParam);

    switch (uMessage)
    {
    case WM_SETCURSOR:
        {
            HWND hwndCursor = (HWND)wParam;
            int nHittest = LOWORD(lParam);
            if (hwndCursor == hwnd && nHittest == HTCLIENT)
            {
                //
                // If we don't have focus, we want to show an arrow because clicking will select
                // the contents of the edit box.  Otherwise show the I-beam.  Also, if the edit box
                // is empty we show the I-beam because there is nothing to select.
                //
                int cch = GetWindowTextLength(paeb->m_hwndEdit);
                LPCTSTR lpCursorName = (cch == 0 || GetFocus() == hwnd) ? IDC_IBEAM : IDC_ARROW;
                SetCursor(LoadCursor(NULL, lpCursorName));
                return TRUE;
            }
            break;
        }
    case WM_KILLFOCUS:
        {
            //
            // If we lose focus with the mouse hook installed, the user probably did
            // not initiate the change so we try to grab it back.  The hook is removed
            // when the user clicks outside the edit box or presses a key to finish the edit
            // (tab, enter, or esc)
            //
            HWND hwndGetFocus = (HWND)wParam;

            if ((paeb->m_hhook) && hwndGetFocus && (hwnd != hwndGetFocus))
            {
                //
                // Make sure that this is not the drop-down portion of the combo.
                // Also, if we are in a dialog (open dialog) then we don't see the
                // tab key.  So if focus is going to a sibling we'll let it through.
                //
                HWND hwndGetFocusParent = GetParent(hwndGetFocus);
                HWND hwndSiblingParent = paeb->m_hwnd ? GetParent(paeb->m_hwnd) : GetParent(hwnd);
                if ((paeb->m_hwnd != hwndGetFocusParent) && (hwndGetFocusParent != hwndSiblingParent) &&
                     EnumChildWindows(hwndSiblingParent, _EnumFindWindow, (LPARAM)hwndGetFocus))
                {
                    // Get the top-level window of who's getting focus
                    HWND hwndFrame = hwndGetFocus;
                    HWND hwndParent;
                    while (hwndParent = GetParent(hwndFrame))
                        hwndFrame = hwndParent;

                    // If focus is going somewhere else in our browser window, grab focus back
                    if (hwndFrame == paeb->m_hwndBrowser)
                    {
                        DWORD dwStart, dwEnd;
                        SendMessage(paeb->m_hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);
                        SetFocus(paeb->m_hwndEdit);
                        SendMessage(paeb->m_hwndEdit, EM_SETSEL, dwStart, dwEnd);
                        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_EditSubclassWndProc, Restoring focus");
                        return 0L;
                    }
                }
            }

            //
            // Losing focus so allow others to change our contents
            //
            paeb->_ClearDirtyFlag();
        }
        break;

    case WM_KEYDOWN:
        {
            // If we are tabbing away, clear our dirty flag
            switch (wParam)
            {
                case VK_TAB:
                    paeb->_ClearDirtyFlag();
                    break;

                case VK_ESCAPE:
                {
                    if (paeb->m_hwnd && ComboBox_GetDroppedState(paeb->m_hwnd))
                    {
                        SendMessage(paeb->m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
                    }
                    else
                    {
                        IUnknown *punk = NULL;

                        if (paeb->m_pbp)
                        {
                            paeb->m_pbp->GetBrowserWindow(&punk);
                        }

                        if (punk)
                        {
                            IWebBrowser* pwb;
                            punk->QueryInterface(IID_IWebBrowser, (LPVOID*)&pwb);

                            if (pwb)
                            {
                                pwb->Stop();
                                pwb->Release();
                            }
                            punk->Release();
                        }

                        // Cancel pending navigation, if any
                        paeb->_CancelNavigation();
                    }

                    LRESULT lResult = CallWindowProc(paeb->m_lpfnEditWndProc, hwnd, uMessage, wParam, lParam);

                    // This bit of magic that restores the icon in the combobox.  Otherwise when we
                    // dismiss the dropwown with escape we get the icon last selected in the dropdown.
                    HWND hwndCombo = (HWND)SendMessage(paeb->m_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
                    SendMessage(hwndCombo, CB_SETCURSEL, -1, 0);
                    return lResult;
                }
            }

            break;
        }
    case WM_DESTROY:
        // Unsubclass myself.
        RemoveProp(hwnd, SZ_ADDRESSCOMBO_PROP);
        if (!paeb->m_lpfnEditWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnEditWndProc);
        ASSERT(paeb->m_hwndEdit);
        paeb->m_hwndEdit = NULL;
        break;
    default:
        break;
    }

    return CallWindowProc(paeb->m_lpfnEditWndProc, hwnd, uMessage, wParam, lParam);
}

BOOL GetLabelStringW(HWND hwnd, LPWSTR pwszBuf, DWORD cchBuf)
{
    HWND    hwndLabel;
    LONG    lStyle;
    LRESULT lResult;
    BOOL    result = FALSE;

    ASSERT(pwszBuf && cchBuf);

    *pwszBuf = 0;

    if (IsWindow(hwnd))
    {
        hwndLabel = hwnd;

        while (hwndLabel = GetWindow(hwndLabel, GW_HWNDPREV))
        {
            lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

            //
            // Skip if invisible
            //
            if (!(lStyle & WS_VISIBLE))
                continue;

            //
            // Is this a static dude?
            //
            lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0);
            if (lResult & DLGC_STATIC)
            {
                //
                // Great, we've found our label.
                //
                result = GetWindowTextWrapW(hwndLabel, pwszBuf, cchBuf);
            }

            //
            // Is this a tabstop or group?  If so, bail out now.
            //
            if (lStyle & (WS_GROUP | WS_TABSTOP))
                break;
        }
    }

    return result;
}


CAddressEditAccessible::CAddressEditAccessible(HWND hwndCombo, HWND hwndEdit)
{
    m_dwRefCount = 1;
    m_hwndEdit = hwndEdit;

    WCHAR wszTitle[MAX_PATH];

    if (!GetLabelStringW(GetParent(hwndCombo), wszTitle, ARRAYSIZE(wszTitle)))
    {
        MLLoadStringW(IDS_BAND_ADDRESS, wszTitle, ARRAYSIZE(wszTitle));
    }

    Str_SetPtr(&m_pwszName, wszTitle);

    CreateStdAccessibleObject(hwndCombo, OBJID_CLIENT, IID_IAccessible, (void **)&m_pDelegateAccObj);
}

CAddressEditAccessible::~CAddressEditAccessible()
{
    Str_SetPtr(&m_pwszName, NULL);
}

// *** IUnknown ***
STDMETHODIMP_(ULONG) CAddressEditAccessible::AddRef()
{
    InterlockedIncrement((LPLONG)&m_dwRefCount);
    return m_dwRefCount;
}

STDMETHODIMP_(ULONG) CAddressEditAccessible::Release()
{
    ASSERT(m_dwRefCount > 0);

    if (InterlockedDecrement((LPLONG)&m_dwRefCount))
    {
        return m_dwRefCount;
    }

    delete this;
    return 0;
}

STDMETHODIMP CAddressEditAccessible::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    return _DefQueryInterface(riid, ppvObj);
}

// *** IAccessible ***
STDMETHODIMP CAddressEditAccessible::get_accName(VARIANT varChild, BSTR  *pszName)
{
    *pszName = (m_pwszName != NULL) ? SysAllocString(m_pwszName) : NULL;
    return (*pszName != NULL) ? S_OK : S_FALSE;
}

STDMETHODIMP CAddressEditAccessible::get_accValue(VARIANT varChild, BSTR  *pszValue)
{
    WCHAR wszValue[MAX_URL_STRING];

    if (Edit_GetText(m_hwndEdit, wszValue, ARRAYSIZE(wszValue)))
    {
        *pszValue = SysAllocString(wszValue);
    }
    else
    {
        *pszValue = NULL;
    }

    return (*pszValue != NULL) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_


#include "uxtheme.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PrivateSPI_GETSELECTIONFADE 0x1014
#define PrivateWS_EX_LAYERED        0x00080000
#define PrivateWM_GETOBJECT         0x003D
#define PrivateTPM_HORPOSANIMATION  0x0400L
#define PrivateTPM_HORNEGANIMATION  0x0800L
#define PrivateTPM_VERPOSANIMATION  0x1000L
#define PrivateTPM_VERNEGANIMATION  0x2000L
#define PrivateTPM_NOANIMATION      0x4000L
#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129
#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3
#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2
#define PrivateSPI_GETKEYBOARDCUES  0x100A
#define PrivateWS_EX_LAYERED        0x00080000
#define PrivateSPI_GETCLEARTYPE     116
#define PrivateLWA_COLORKEY        0x00000001
#define PrivateLWA_ALPHA           0x00000002
#define PrivateSPI_GETFLATMENU                     0x1022
#define PrivateSPI_SETFLATMENU                     0x1023
#define PrivateCOLOR_MENUHILIGHT       29
#define PrivateCOLOR_MENUBAR           30
#define PrivateCS_DROPSHADOW           0x00020000
#define PrivateSPI_SETDROPSHADOW                   0x1025
#define PrivateTBSTYLE_EX_DOUBLEBUFFER  0x00000080
#define PrivateRBN_AUTOBREAK       (RBN_FIRST - 22)
#define PrivateRBAB_AUTOSIZE   0x0001
#define PrivateRBAB_ADDBAND    0x0002
#define PrivateRBSTR_CHANGERECT            0x0001
#define PrivateILC_PERITEMMIRROR    0x00008000


#define KEYBOARDCUES

#if (WINVER >= 0x0500)

// for files in nt5api and w5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if SPI_GETSELECTIONFADE != PrivateSPI_GETSELECTIONFADE
#error inconsistant SPI_GETSELECTIONFADE in winuser.h
#endif

#if WS_EX_LAYERED != PrivateWS_EX_LAYERED
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#if WM_GETOBJECT != PrivateWM_GETOBJECT
#error inconsistant WM_GETOBJECT in winuser.h
#endif

#if TPM_HORPOSANIMATION != PrivateTPM_HORPOSANIMATION
#error inconsistant TPM_HORPOSANIMATION in winuser.h
#endif

#if TPM_HORNEGANIMATION != PrivateTPM_HORNEGANIMATION
#error inconsistant TPM_HORNEGANIMATION in winuser.h
#endif

#if TPM_VERPOSANIMATION != PrivateTPM_VERPOSANIMATION
#error inconsistant TPM_VERPOSANIMATION in winuser.h
#endif

#if TPM_VERNEGANIMATION != PrivateTPM_VERNEGANIMATION
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#if TPM_NOANIMATION != PrivateTPM_NOANIMATION
#error inconsistant TPM_NOANIMATION in winuser.h
#endif

// We are checking this in at the same time that user is. This is to prevent
// sync problems.
#ifdef SPI_GETCLEARTYPE
    #if SPI_GETCLEARTYPE != PrivateSPI_GETCLEARTYPE
        #error inconsistant SPI_GETCLEARTYPE in winuser.h
    #endif
#else
    #define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#endif


#else

#define WS_EX_LAYERED           PrivateWS_EX_LAYERED
#define SPI_GETSELECTIONFADE    PrivateSPI_GETSELECTIONFADE
#define WM_GETOBJECT            PrivateWM_GETOBJECT
#define TPM_HORPOSANIMATION     PrivateTPM_HORPOSANIMATION
#define TPM_HORNEGANIMATION     PrivateTPM_HORNEGANIMATION
#define TPM_VERPOSANIMATION     PrivateTPM_VERPOSANIMATION
#define TPM_VERNEGANIMATION     PrivateTPM_VERNEGANIMATION
#define TPM_NOANIMATION         PrivateTPM_NOANIMATION
#define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#define LWA_COLORKEY            PrivateLWA_COLORKEY
#define LWA_ALPHA               PrivateLWA_ALPHA   

#ifdef KEYBOARDCUES
#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE 
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE 
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE  
#define UIS_SET                 PrivateUIS_SET          
#define UIS_CLEAR               PrivateUIS_CLEAR        
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE   
#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL   
#define SPI_GETKEYBOARDCUES     PrivateSPI_GETKEYBOARDCUES
#endif //KEYBOARDCUES

#define SPI_GETFLATMENU         PrivateSPI_GETFLATMENU  
#define SPI_SETFLATMENU         PrivateSPI_SETFLATMENU  
#define COLOR_MENUHILIGHT       PrivateCOLOR_MENUHILIGHT
#define COLOR_MENUBAR           PrivateCOLOR_MENUBAR    
#define CS_DROPSHADOW           PrivateCS_DROPSHADOW
#define SPI_SETDROPSHADOW       PrivateSPI_SETDROPSHADOW                   
#define TBSTYLE_EX_DOUBLEBUFFER PrivateTBSTYLE_EX_DOUBLEBUFFER
#define RBN_AUTOBREAK           PrivateRBN_AUTOBREAK
#define RBAB_AUTOSIZE           PrivateRBAB_AUTOSIZE
#define RBAB_ADDBAND            PrivateRBAB_ADDBAND 
#define RBSTR_CHANGERECT        PrivateRBSTR_CHANGERECT

#if 0
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

typedef HANDLE HTHEME;          // handle to a section of theme data for class

STDAPI_(HTHEME) OpenThemeData(HWND hwnd, LPCWSTR pszClassList);

STDAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList);

STDAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect);

STDAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);

STDAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect);
STDAPI CloseThemeData(HTHEME hTheme);
STDAPI_(BOOL) IsThemeActive();
STDAPI GetThemeMargins(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT MARGINS *pMargins);
#endif

#endif // WINVER >= 0x0500

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);

STDAPI_(LRESULT) ACCESSIBLE_LresultFromObject(
    IN REFIID riid,
    IN WPARAM wParam,
    OUT IUnknown* punk);

STDAPI ACCESSIBLE_CreateStdAccessibleObject(
    IN HWND hwnd,
    IN LONG idObject,
    IN REFIID riid,
    OUT void** ppvObj);

STDAPI_(void) NT5_NotifyWinEvent(
    IN DWORD event,
    IN HWND hwnd,
    IN LONG idObject,
    IN LONG idChild);

#ifdef NotifyWinEvent
#undef NotifyWinEvent
#endif

#ifdef LresultFromObject
#undef LresultFromObject
#endif

#ifdef CreateStdAccessibleObject
#undef CreateStdAccessibleObject
#endif

#ifdef SHPathPrepareForWrite
#undef SHPathPrepareForWrite
#endif

#define AllowSetForegroundWindow NT5_AllowSetForegroundWindow

STDAPI_(BOOL) NT5_AllowSetForegroundWindow( DWORD dwProcessId );
STDAPI_(BOOL) NT5_SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
STDAPI_(HRESULT) NT5_SHPathPrepareForWrite(HWND hwnd, IUnknown *punkModless, LPCWSTR pwzPath, DWORD dwFlags);

void Comctl32_SetWindowTheme(HWND hwnd, LPWSTR psz);
void Comctl32_GetBandMargins(HWND hwnd, MARGINS* mBorders);
void Comctl32_FixAutoBreak(LPNMHDR pnm);
void Comctl32_SetDPIScale(HWND hwnd);

#define SetLayeredWindowAttributes NT5_SetLayeredWindowAttributes
#define NotifyWinEvent NT5_NotifyWinEvent
#define LresultFromObject ACCESSIBLE_LresultFromObject
#define CreateStdAccessibleObject ACCESSIBLE_CreateStdAccessibleObject
#define SHPathPrepareForWrite NT5_SHPathPrepareForWrite

STDAPI_(void) AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate);
STDAPI_(void) MyLockSetForegroundWindow(BOOL fLock);

STDAPI_(BOOL) BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst);

STDAPI_(UINT) MyExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

// terminal server session notification:
#include "wtsapi32.h"
BOOL WINAPI DL_WTSRegisterSessionNotification(HWND hWnd, DWORD dwFlags);
BOOL WINAPI DL_WTSUnRegisterSessionNotification(HWND hWnd);

// current browseui build settings skip definition of this message in winuser.h, need to define "manually"
#ifndef WM_WTSSESSION_CHANGE
#define WM_WTSSESSION_CHANGE            0x02B1

/*
 * codes passed in WPARAM for WM_WTSSESSION_CHANGE
 */
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8

#endif

#define WTSRegisterSessionNotification      DL_WTSRegisterSessionNotification
#define WTSUnRegisterSessionNotification    DL_WTSUnRegisterSessionNotification

#ifdef __cplusplus
}
#endif

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\atl.cpp ===
#include "priv.h"
#include "atl.h"

//ATL support
CComModule _Module;         // ATL module object

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

STDAPI_(void) AtlInit(HINSTANCE hinst)
{
    _Module.Init(ObjectMap, hinst);
}

STDAPI_(void) AtlTerm()
{
    _Module.Term();
}

STDAPI AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = _Module.GetClassObject(rclsid, riid, ppv);

#ifdef DEBUG
    //this object gets freed on DLL_PROCESS_DETACH, which happens AFTER the
    // mem leak check happens on exit.
    if (SUCCEEDED(hr))
    {
        _ASSERTE(_Module.m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;

        while (pEntry->pclsid != NULL)
        {
            if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
            {
                ASSERT(pEntry->pCF);
                break;
            }
            pEntry++;
        }
    }
#endif

    return hr;
}

STDAPI_(LONG) AtlGetLockCount()
{
    return _Module.GetLockCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\browseui\browseui.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\browseui\browseui.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c \
                  ..\nt5.cpp

# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\atl.h ===
STDAPI_(void) AtlInit(HINSTANCE hinst);
STDAPI_(void) AtlTerm();

STDAPI        AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI_(LONG) AtlGetLockCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\autocomp.h ===
/* Copyright 1996 Microsoft */

#ifndef _AUTOCOMP_HPP_
#define _AUTOCOMP_HPP_

#include "accdel.h"

// TODO List:
// 1. Convert AutoComplete to be a Free Threaded object and move it and all it's
//    lists into MultiApartment model.
// 2. Get thread out of ThreadPool API in shlwapi.dll instead of creating thead our
//    selves.
// 3. See if SHWaitForSendMessageThread() will cause a lock if bg thread is in SendMessage().
//    If so, make sure the bg loop's hard loop doesn't call SendMessage() in this case without
//    first looking for QUIT message.



// WARNING On Usage:
//   This object is marked Apartment model and this abuses COM.  These are rules 
// that need to be followed to prevent bugs.  This object will be used within three scopes.  
// The first scope is the caller doing: 1a) CoInitialize(), 1b) CoCreateInstance(). 
// 1c) p->Init(), 1d) p->Release(), 1e) CoUninitialize().
// The second scope is the object doing: 2a) Subclass();AddRef(), 2b) WM_DESTROY;Release();
// 1c) p->Init(), 1d) p->Release(), 1e) CoUninitialize().
// The third scope is the background thread doing: 3a) (in thread proc) CoInitialize(), 
// 3b) CoUninitialize(). 
// This object requires that 1E come after 2B and that should be the only requirement
// for the use of this object.


//
// PRIVATE
//
#define AC_LIST_GROWTH_CONST         50
const WCHAR CH_WILDCARD = L'\1';    // indicates a wildcard search

//
// Debug Flags
//
#define AC_WARNING          TF_WARNING + TF_AUTOCOMPLETE
#define AC_ERROR            TF_ERROR   + TF_AUTOCOMPLETE
#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE
#define AC_FUNC             TF_FUNC    + TF_AUTOCOMPLETE

// Enable test regkey
#define ALLOW_ALWAYS_DROP_UP

//
// WndProc messages to the dropdown window
//
enum
{
    AM_BUTTONCLICK = WM_APP + 400,
    AM_UPDATESCROLLPOS,
    AM_DESTROY
};

//
// Flags passed from background thread when the search is completed
enum
{
    SRCH_LIMITREACHED   = 0x01, // out of memory or we reached our limit
    SRCH_USESORTINDEX   = 0x02, // use sort index to order results
};

#define ACO_UNINITIALIZED       0x80000000    // if autocomplete options have not been initialized

//
// PUBLIC
//
HRESULT SHUseDefaultAutoComplete(HWND hwndEdit, 
                               IBrowserService * pbs,       IN  OPTIONAL
                               IAutoComplete2 ** ppac,      OUT OPTIONAL
                               IShellService ** ppssACLISF, OUT OPTIONAL
                               BOOL fUseCMDMRU);

// Forward references
class CAutoComplete;
class CACString* CreateACString(LPCWSTR pszStr);

//+-------------------------------------------------------------------------
// CACString - Autocomplete string shared by foreground & background threads
//--------------------------------------------------------------------------
class CACString
{
public:
    ULONG AddRef();
    ULONG Release();
    ULONG GetSortIndex() { return m_ulSortIndex; }
    void  SetSortIndex(ULONG ulIndex) { m_ulSortIndex = ulIndex; }
    LPCWSTR GetStr() const { return m_sz; }
    LPCWSTR GetStrToCompare() const { return m_sz + m_iIgnore; }
    int GetLength() const { return m_cChars; }
    int GetLengthToCompare() const { return m_cChars - m_iIgnore; }
    const WCHAR& operator [] (int nIndex) const { return m_sz[nIndex]; }
    operator LPCWSTR() { return m_sz; }
    BOOL HasPrefix() { return m_iIgnore; }
    BOOL PrefixLength() { return m_iIgnore; }

    // Note, the following compare functions ignore the prefix of the CACString
    int CompareSortingIndex(CACString& r);
    int StrCmpI(LPCWSTR psz) { return ::StrCmpI(m_sz + m_iIgnore, psz); }
    int StrCmpI(CACString& r) { return ::StrCmpI(m_sz + m_iIgnore, r.m_sz + r.m_iIgnore); }
    int StrCmpNI(LPCWSTR psz, int cch) { return ::StrCmpNI(m_sz + m_iIgnore, psz, cch); }

protected:
    friend CACString* CreateACString(LPCWSTR pszStr, int iIgnore, ULONG ulSortIndex);

    // Prevent creation on stack
    CACString();

    LONG  m_cRef;           // reference count
    int   m_cChars;         // length of string (excluding null)
    int   m_iIgnore;        // # prefix characters to ignore when comparing strings
    ULONG m_ulSortIndex;    // can be used instead of default alphabetical sorting
    WCHAR m_sz[1];          // first character of the string
};

//+-------------------------------------------------------------------------
// CACThread - Autocomplete thread that runs in the background
//--------------------------------------------------------------------------
class CACThread : public IUnknown
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

                CACThread(CAutoComplete& rAutoComp);
    virtual     ~CACThread();

    BOOL        Init(IEnumString* pes, IACList* pacl);

    void        GotFocus(); 
    void        LostFocus();
    BOOL        HasFocus() { return m_fWorkItemQueued != 0; }
    BOOL        StartSearch(LPCWSTR pszSearch, DWORD dwOptions);
    void        StopSearch();
    void        SyncShutDownBGThread();
    BOOL        IsDisabled() { return m_fDisabled; }

    // Helper functions
    static BOOL MatchesSpecialPrefix(LPCWSTR pszSearch);
    static int  GetSpecialPrefixLen(LPCWSTR psz);

protected:
    LONG            m_cRef;
    CAutoComplete*  m_pAutoComp;     // portion of autocomplete that runs on main thread
    LONG            m_fWorkItemQueued; // if request made to shlwapi thread pool
    LONG            m_idThread;
    HANDLE          m_hCreateEvent;  // thread startup syncronizatrion
    BOOL            m_fDisabled:1;   // is autocomplete disabled?
    LPWSTR          m_pszSearch;     // String we are currently searching for
    HDPA            m_hdpa_list;     // list of completions
    DWORD           m_dwSearchStatus;// see SRCH_* flags
    IEnumString*    m_pes;           // Used internally for real AutoComplete functionality.
    IEnumACString*  m_peac;          // Used with IEnumString to get sort index
    IACList*        m_pacl;          // Additional methods for autocomplete lists (optional).

    void        _SendAsyncShutDownMsg(BOOL fFinalShutDown);
    void        _FreeThreadData();
    HRESULT     _ThreadLoop();
    HRESULT     _Next(LPWSTR szUrl, ULONG cchUrl, ULONG* pulSortIndex);
    HRESULT     _ProcessMessage(MSG * pMsg, DWORD * pdwTimeout, BOOL * pfStayAlive);
    void        _Search(LPWSTR pszSearch, DWORD dwOptions);
    BOOL        _AddToList(LPTSTR pszUrl, int cchMatch, ULONG ulSortIndex);
    void        _DoExpand(LPCWSTR pszSearch);
    static DWORD WINAPI _ThreadProc(LPVOID lpv);
    static int CALLBACK _DpaCompare(LPVOID p1, LPVOID p2, LPARAM lParam);
};

//+-------------------------------------------------------------------------
// CAutoComplete - Main autocomplete class that runs on the main UI thread
//--------------------------------------------------------------------------
class CAutoComplete
                : public IAutoComplete2
                , public IAutoCompleteDropDown
                , public IEnumString
                , public CDelegateAccessibleImpl
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    virtual STDMETHODIMP Reset();
    virtual STDMETHODIMP Clone(IEnumString **ppenum) { return E_NOTIMPL; }

    // *** IAutoComplete ***
    virtual STDMETHODIMP Init(HWND hwnd, IUnknown *punkACL, LPCOLESTR pwszRegKeyPath, LPCOLESTR pwszQuickCompleteString);
    virtual STDMETHODIMP Enable(BOOL fEnable);

    // *** IAutoComplete2 ***
    virtual STDMETHODIMP SetOptions(DWORD dwFlag);
    virtual STDMETHODIMP GetOptions(DWORD* pdwFlag);

    // *** IAutoCompleteDropDown ***
    virtual STDMETHODIMP GetDropDownStatus(DWORD *pdwFlags, LPWSTR *ppwszString);
    virtual STDMETHODIMP ResetEnumerator();

    // *** IAccessible ***
    STDMETHODIMP get_accName(VARIANT varChild, BSTR  *pszName);

protected:
    // Methods called by the background thread
    friend CACThread;
    void SearchComplete(HDPA hdpa, DWORD dwSearchStatus) { PostMessage(m_hwndEdit, m_uMsgSearchComplete, dwSearchStatus, (LPARAM)hdpa); }
    BOOL IsEnabled();

    // Constructor / Destructor (protected so we can't create on stack)
    CAutoComplete();
    virtual ~CAutoComplete();

    // Instance creator
    friend HRESULT CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    BOOL _Init();

    // Private variables
    LONG            m_cRef;

    CACThread*      m_pThread;              // background autocomplete thread
    TCHAR           m_szQuickComplete[MAX_PATH];
    TCHAR           m_szRegKeyPath[MAX_PATH];
    DWORD           m_dwFlags;
    HWND            m_hwndEdit;
    HWND            m_hwndCombo;            // if m_hwndEdit is part of a combobox
    HFONT           m_hfontListView;
    LPTSTR          m_pszCurrent;
    int             m_iCurrent;
    DWORD           m_dwLastSearchFlags;
    WNDPROC         m_pOldListViewWndProc;

    IEnumString *   m_pes;                  // Used internally for real AutoComplete functionality.
    IACList *       m_pacl;                 // Additional methods for autocomplete lists (optional).

    HDPA            m_hdpa;                 // sorted completions list
    HDPA            m_hdpaSortIndex;        // matches from m_hdpa ordered by sort index
    LPWSTR          m_pszLastSearch;        // string last sent for completion
    int             m_iFirstMatch;          // first match in list (-1 if no matches)
    int             m_iLastMatch;           // last match in list (-1 if no matches)
    int             m_iAppended;            // item completed in the edit box
    BITBOOL         m_fEditControlUnicode:1;  // if the edit control is unicode.
    BITBOOL         m_fNeedNewList:1;       // last search was truncated
    BITBOOL         m_fDropDownResized:1;   // user has resized drop down
    BITBOOL         m_fAppended:1;          // if something currently appended
    BITBOOL         m_fSearchForAdded:1;    // if last item in dpa is "Search for <>"
    BITBOOL         m_fSearchFor:1;         // if "Search for <>" is to be displayed
    BITBOOL         m_fImeCandidateOpen:1;  // if the IME's candidate window is visible
    DWORD           m_dwOptions;            // autocomplete options (ACO_*)
    EDITWORDBREAKPROC m_oldEditWordBreakProc; // original word break proc for m_hwndEdit

    // Member variables for drop-down auto-suggest window
    HWND            m_hwndDropDown;         // Shows completions in drop-down window
    HWND            m_hwndList;             // Shows completions in drop-down window
    HWND            m_hwndScroll;           // scrollbar
    HWND            m_hwndGrip;             // gripper for resizing the dropdown
    int             m_nStatusHeight;        // height of status in drop-down
    int             m_nDropWidth;           // width of drop-down window
    int             m_nDropHeight;          // height of drop-down window
    int             m_cxGripper;            // width/height of gripper
    BITBOOL         m_fDroppedUp:1;         // if dropdown is over top the edit box
#ifdef ALLOW_ALWAYS_DROP_UP
    BITBOOL         m_fAlwaysDropUp:1;      // TEST regkey to always drop up
#endif
    BITBOOL         m_fSettingText:1;       // if setting the edit text
    BITBOOL         m_fInHotTracking:1;     // if new selection is due to hot-tracking 

    // Member Variables used for external IEnumString
    IEnumString *   m_pesExtern;            // Used internally for real AutoComplete functionality.
    LPTSTR          m_szEnumString;

    // Registered messages sent to edit window
    UINT            m_uMsgSearchComplete;
    UINT            m_uMsgItemActivate;

    static HHOOK    s_hhookMouse;           // windows hook installed when drop-down visible
    static HWND     s_hwndDropDown;         // dropdown currently visible
    static BOOL     s_fNoActivate;          // keep topmost-window from losing activation

    void        _OnSearchComplete(HDPA hdpa, DWORD dwSearchStatus);
    BOOL        _GetItem(int iIndex, LPWSTR pswText, int cchMax, BOOL fDisplayName);
    void        _UpdateCompletion(LPCWSTR pszTyped, int iChanged, BOOL fAppend);
    void        _HideDropDown();
    void        _ShowDropDown();
    void        _PositionDropDown();
    void        _SeeWhatsEnabled();
    BOOL        _IsAutoSuggestEnabled() { return m_dwOptions & ACO_AUTOSUGGEST; }
    BOOL        _IsRTLReadingEnabled() { return m_dwOptions & ACO_RTLREADING; }
    BOOL        _IsAutoAppendEnabled() { return (m_dwOptions & ACO_AUTOAPPEND) || (m_dwOptions & ACO_UNINITIALIZED); }
    BOOL        _IsComboboxDropped() { return (m_hwndCombo && ComboBox_GetDroppedState(m_hwndCombo)); }
    void        _UpdateGrip();
    void        _UpdateScrollbar();

    static BOOL _IsWhack(TCHAR ch);
    static BOOL _IsBreakChar(WCHAR wch);
    BOOL        _WantToAppendResults();
    int         _JumpToNextBreak(int iLoc, DWORD dwFlags);
    BOOL        _CursorMovement(WPARAM wParam);
    void        _RemoveCompletion();
    void        _GetEditText();
    void        _SetEditText(LPCWSTR psz);
    void        _UpdateText(int iStartSel, int iEndSel, LPCTSTR pszCurrent, LPCTSTR pszNew);
    BOOL        _OnKeyDown(WPARAM wParam);
    LRESULT     _OnChar(WPARAM wParam, LPARAM lParam);
    void        _StartCompletion(BOOL fAppend, BOOL fEvenIfEmpty = FALSE);
    BOOL        _StartSearch(LPCWSTR pszSearch);
    void        _StopSearch();
    BOOL        _ResetSearch();
    void        _GotFocus();
    LPTSTR      _QuickEnter();
    BOOL        _AppendNext(BOOL fAppendToWhack);
    BOOL        _AppendPrevious(BOOL fAppendToWhack);
    void        _Append(CACString& rStr, BOOL fAppendToWhack);
    BOOL        _SetQuickCompleteStrings(LPCOLESTR pcszRegKeyPath, LPCOLESTR pcszQuickCompleteString);
    void        _SubClassParent(HWND hwnd);
    void        _UnSubClassParent(HWND hwnd);

    LRESULT     _DropDownWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT     _EditWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT     _ListViewWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

    void        _DropDownDrawItem(LPDRAWITEMSTRUCT pdis);
    BOOL        _DropDownNotify(LPNMHDR pnmhdr);

    static int  _DPADestroyCallback(LPVOID p, LPVOID d);
    static void _FreeDPAPtrs(HDPA hdpa);
    static int CALLBACK _DPACompareSortIndex(LPVOID p1, LPVOID p2, LPARAM lParam);
    static int CALLBACK EditWordBreakProcW(LPWSTR lpch, int ichCurrent, int cch, int code);
    static LRESULT CALLBACK s_EditWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_DropDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_ListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_ParentWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_GripperWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    static LRESULT CALLBACK s_MouseHook(int nCode, WPARAM wParam, LPARAM lParam);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandobj.h ===
// implements the dataobject for a deskbar band

extern UINT g_cfDeskBand;
extern UINT g_cfDeskBandState;

class CBandDataObject : public IDataObject
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // IDataObject methods

    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);
    
    CBandDataObject();
    HRESULT Init(IUnknown* punkBand, IBandSite *pbs, DWORD dwBandID);
    
protected:
    ~CBandDataObject();
    ULONG _cRef;
    IStream* _pstm;         // band state (IPS::Save)
    DWORD _dwState;         // band's bandsite state (DWORD *)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\autocomp.cpp ===
// Copyright 1996-98 Microsoft
#include "priv.h"
#include "sccls.h"
#include "autocomp.h"
#include "itbar.h"
#include "address.h"
#include "addrlist.h"
#include "resource.h"
#include "mluisupp.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#include "apithk.h"

extern HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU);

#define WZ_REGKEY_QUICKCOMPLETE         L"Software\\Microsoft\\Internet Explorer\\Toolbar\\QuickComplete"
#define WZ_DEFAULTQUICKCOMPLETE         L"http://www.%s.com"


// Statics
const static TCHAR c_szAutoDefQuickComp[]   = TEXT("%s");
const static TCHAR c_szAutoCompleteProp[]   = TEXT("CAutoComplete_This");
const static TCHAR c_szParentWindowProp[]   = TEXT("CParentWindow_This");
const static TCHAR c_szAutoSuggest[]        = TEXT("AutoSuggest Drop-Down");
const static TCHAR c_szAutoSuggestTitle[]   = TEXT("Internet Explorer");

BOOL CAutoComplete::s_fNoActivate = FALSE;
HWND CAutoComplete::s_hwndDropDown = NULL;
HHOOK CAutoComplete::s_hhookMouse = NULL;


#define MAX_QUICK_COMPLETE_STRING   64
#define LISTVIEW_COLUMN_WIDTH   30000

//
// FLAGS for dwFlags
//
#define ACF_RESET               0x00000000
#define ACF_IGNOREUPDOWN        0x00000004

#define URL_SEPARATOR_CHAR      TEXT('/')

#ifdef UNIX
#define DIR_SEPARATOR_CHAR      TEXT('/')
#define DIR_SEPARATOR_STRING    TEXT("/")
#else
#define DIR_SEPARATOR_CHAR      TEXT('\\')
#define DIR_SEPARATOR_STRING    TEXT("\\")
#endif

/////////////////////////////////////////////////////////////////////////////
// Line Break Character Table
//
// This was swipped from mlang.  Special break characters added for URLs
// have an "IE:" in the comment.  Note that this table must be sorted!

const WCHAR g_szBreakChars[] = {
    0x0009, // TAB
    0x0020, // SPACE
    0x0021, // IE: !
    0x0022, // IE: "
    0x0023, // IE: #
    0x0024, // IE: $
    0x0025, // IE: %
    0x0026, // IE: &
    0x0027, // IE: '
    0x0028, // LEFT PARENTHESIS
    0x0029, // RIGHT PARENTHESIS
    0x002A, // IE: *
    0x002B, // IE: +
    0x002C, // IE: ,
    0x002D, // HYPHEN
    0x002E, // IE: .
    0x002F, // IE: /
    0x003A, // IE: :
    0x003B, // IE: ;
    0x003C, // IE: <
    0x003D, // IE: =
    0x003E, // IE: >
    0x003F, // IE: ?
    0x0040, // IE: @
    0x005B, // LEFT SQUARE BRACKET
    0x005C, // IE: '\'
    0x005D, // RIGHT SQUARE BRACKET
    0x005E, // IE: ^
    0x005F, // IE: _
    0x0060, // IE:`
    0x007B, // LEFT CURLY BRACKET
    0x007C, // IE: |
    0x007D, // RIGHT CURLY BRACKET
    0x007E, // IE: ~
    0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x00AD, // OPTIONAL HYPHEN
    0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x02C7, // CARON
    0x02C9, // MODIFIER LETTER MACRON
    0x055D, // ARMENIAN COMMA
    0x060C, // ARABIC COMMA
    0x2002, // EN SPACE
    0x2003, // EM SPACE
    0x2004, // THREE-PER-EM SPACE
    0x2005, // FOUR-PER-EM SPACE
    0x2006, // SIX-PER-EM SPACE
    0x2007, // FIGURE SPACE
    0x2008, // PUNCTUATION SPACE
    0x2009, // THIN SPACE
    0x200A, // HAIR SPACE
    0x200B, // ZERO WIDTH SPACE
    0x2013, // EN DASH
    0x2014, // EM DASH
    0x2016, // DOUBLE VERTICAL LINE
    0x2018, // LEFT SINGLE QUOTATION MARK
    0x201C, // LEFT DOUBLE QUOTATION MARK
    0x201D, // RIGHT DOUBLE QUOTATION MARK
    0x2022, // BULLET
    0x2025, // TWO DOT LEADER
    0x2026, // HORIZONTAL ELLIPSIS
    0x2027, // HYPHENATION POINT
    0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x2045, // LEFT SQUARE BRACKET WITH QUILL
    0x2046, // RIGHT SQUARE BRACKET WITH QUILL
    0x207D, // SUPERSCRIPT LEFT PARENTHESIS
    0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
    0x208D, // SUBSCRIPT LEFT PARENTHESIS
    0x208E, // SUBSCRIPT RIGHT PARENTHESIS
    0x226A, // MUCH LESS THAN
    0x226B, // MUCH GREATER THAN
    0x2574, // BOX DRAWINGS LIGHT LEFT
    0x3001, // IDEOGRAPHIC COMMA
    0x3002, // IDEOGRAPHIC FULL STOP
    0x3003, // DITTO MARK
    0x3005, // IDEOGRAPHIC ITERATION MARK
    0x3008, // LEFT ANGLE BRACKET
    0x3009, // RIGHT ANGLE BRACKET
    0x300A, // LEFT DOUBLE ANGLE BRACKET
    0x300B, // RIGHT DOUBLE ANGLE BRACKET
    0x300C, // LEFT CORNER BRACKET
    0x300D, // RIGHT CORNER BRACKET
    0x300E, // LEFT WHITE CORNER BRACKET
    0x300F, // RIGHT WHITE CORNER BRACKET
    0x3010, // LEFT BLACK LENTICULAR BRACKET
    0x3011, // RIGHT BLACK LENTICULAR BRACKET
    0x3014, // LEFT TORTOISE SHELL BRACKET
    0x3015, // RIGHT TORTOISE SHELL BRACKET
    0x3016, // LEFT WHITE LENTICULAR BRACKET
    0x3017, // RIGHT WHITE LENTICULAR BRACKET
    0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
    0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
    0x301A, // LEFT WHITE SQUARE BRACKET
    0x301B, // RIGHT WHITE SQUARE BRACKET
    0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
    0x301E, // DOUBLE PRIME QUOTATION MARK
    0x3041, // HIRAGANA LETTER SMALL A
    0x3043, // HIRAGANA LETTER SMALL I
    0x3045, // HIRAGANA LETTER SMALL U
    0x3047, // HIRAGANA LETTER SMALL E
    0x3049, // HIRAGANA LETTER SMALL O
    0x3063, // HIRAGANA LETTER SMALL TU
    0x3083, // HIRAGANA LETTER SMALL YA
    0x3085, // HIRAGANA LETTER SMALL YU
    0x3087, // HIRAGANA LETTER SMALL YO
    0x308E, // HIRAGANA LETTER SMALL WA
    0x309B, // KATAKANA-HIRAGANA VOICED SOUND MARK
    0x309C, // KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
    0x309D, // HIRAGANA ITERATION MARK
    0x309E, // HIRAGANA VOICED ITERATION MARK
    0x30A1, // KATAKANA LETTER SMALL A
    0x30A3, // KATAKANA LETTER SMALL I
    0x30A5, // KATAKANA LETTER SMALL U
    0x30A7, // KATAKANA LETTER SMALL E
    0x30A9, // KATAKANA LETTER SMALL O
    0x30C3, // KATAKANA LETTER SMALL TU
    0x30E3, // KATAKANA LETTER SMALL YA
    0x30E5, // KATAKANA LETTER SMALL YU
    0x30E7, // KATAKANA LETTER SMALL YO
    0x30EE, // KATAKANA LETTER SMALL WA
    0x30F5, // KATAKANA LETTER SMALL KA
    0x30F6, // KATAKANA LETTER SMALL KE
    0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0x30FD, // KATAKANA ITERATION MARK
    0x30FE, // KATAKANA VOICED ITERATION MARK
    0xFD3E, // ORNATE LEFT PARENTHESIS
    0xFD3F, // ORNATE RIGHT PARENTHESIS
    0xFE30, // VERTICAL TWO DOT LEADER
    0xFE31, // VERTICAL EM DASH
    0xFE33, // VERTICAL LOW LINE
    0xFE34, // VERTICAL WAVY LOW LINE
    0xFE35, // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    0xFE36, // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    0xFE37, // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    0xFE38, // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    0xFE39, // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
    0xFE3A, // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
    0xFE3B, // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
    0xFE3C, // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
    0xFE3D, // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
    0xFE3E, // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
    0xFE3F, // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
    0xFE40, // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    0xFE41, // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    0xFE42, // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
    0xFE43, // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
    0xFE44, // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
    0xFE4F, // WAVY LOW LINE
    0xFE50, // SMALL COMMA
    0xFE51, // SMALL IDEOGRAPHIC COMMA
    0xFE59, // SMALL LEFT PARENTHESIS
    0xFE5A, // SMALL RIGHT PARENTHESIS
    0xFE5B, // SMALL LEFT CURLY BRACKET
    0xFE5C, // SMALL RIGHT CURLY BRACKET
    0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
    0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
    0xFF08, // FULLWIDTH LEFT PARENTHESIS
    0xFF09, // FULLWIDTH RIGHT PARENTHESIS
    0xFF0C, // FULLWIDTH COMMA
    0xFF0E, // FULLWIDTH FULL STOP
    0xFF1C, // FULLWIDTH LESS-THAN SIGN
    0xFF1E, // FULLWIDTH GREATER-THAN SIGN
    0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
    0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
    0xFF40, // FULLWIDTH GRAVE ACCENT
    0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
    0xFF5C, // FULLWIDTH VERTICAL LINE
    0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
    0xFF5E, // FULLWIDTH TILDE
    0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
    0xFF62, // HALFWIDTH LEFT CORNER BRACKET
    0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
    0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA
    0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
    0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
    0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
    0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
    0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
    0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
    0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
    0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
    0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
    0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0xFF9E, // HALFWIDTH KATAKANA VOICED SOUND MARK
    0xFF9F, // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
    0xFFE9, // HALFWIDTH LEFTWARDS ARROW
    0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
};

/*
//
// AutoComplete Common Functions / Structures
//
const struct {
    UINT    idMenu;
    UINT    idCmd;
} MenuToMessageId[] = {
    { IDM_AC_UNDO, WM_UNDO },
    { IDM_AC_CUT,  WM_CUT },
    { IDM_AC_COPY, WM_COPY },
    { IDM_AC_PASTE, WM_PASTE }
};
*/

//+-------------------------------------------------------------------------
// IUnknown methods
//--------------------------------------------------------------------------
HRESULT CAutoComplete::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAutoComplete) ||
        IsEqualIID(riid, IID_IAutoComplete2))
    {
        *ppvObj = SAFECAST(this, IAutoComplete2*);
    }
    else if (IsEqualIID(riid, IID_IAutoCompleteDropDown))
    {
        *ppvObj = SAFECAST(this, IAutoCompleteDropDown*);
    }
    else if (IsEqualIID(riid, IID_IEnumString))
    {
        *ppvObj = SAFECAST(this, IEnumString*);
    }
    else
    {
        return _DefQueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}

ULONG CAutoComplete::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CAutoComplete::Release(void)
{
    ASSERT(m_cRef > 0);

    if (InterlockedDecrement(&m_cRef))
    {
        TraceMsg(AC_GENERAL, "CAutoComplete::Release() --- m_cRef = %i", m_cRef);
        return m_cRef;
    }

    TraceMsg(AC_GENERAL, "CAutoComplete::Release() --- m_cRef = %i", m_cRef);

    delete this;
    return 0;
}

/* IAutoComplete methods */
//+-------------------------------------------------------------------------
//  This object can be Inited in two ways.  This function will init it in
//  the first way, which works as follows:
//
//  1. The caller called CoInitialize or OleInitialize() and the corresponding
//     uninit will not be called until the control we are subclassing and
//     our selfs are long gone.
//  2. The caller calls us on their main thread and we create and destroy
//     the background thread as needed.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Init
(
    HWND hwndEdit,              // control to be subclassed
    IUnknown *punkACL,          // autocomplete list
    LPCOLESTR pwszRegKeyPath,   // reg location where ctrl-enter completion is stored stored
    LPCOLESTR pwszQuickComplete // default format string for ctrl-enter completion
)
{
    HRESULT hr = S_OK;

    TraceMsg(AC_GENERAL, "CAutoComplete::Init(hwndEdit=0x%x, punkACL = 0x%x, pwszRegKeyPath = 0x%x, pwszQuickComplete = 0x%x)",
        hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete);

#ifdef DEBUG
    // Ensure that the Line Break Character Table is ordered
    WCHAR c = g_szBreakChars[0];
    for (int i = 1; i < ARRAYSIZE(g_szBreakChars); ++i)
    {
        ASSERT(c < g_szBreakChars[i]);
        c = g_szBreakChars[i];
    }
#endif

    if (m_hwndEdit != NULL)
    {
        // Can currently only be initialized once
        ASSERT(FALSE);
        return E_FAIL;
    }

    m_hwndEdit = hwndEdit;

#ifndef UNIX
    // Add our custom word-break callback so that we recognize URL delimitors when
    // ctrl-arrowing around.
    //
    // There is a bug with how USER handles WH_CALLWNDPROC global hooks in Win95 that
    // causes us to blow up if one is installed and a wordbreakproc is set.  Thus,
    // if an app is running that has one of these hooks installed (intellipoint 1.1 etc.) then
    // if we install our wordbreakproc the app will fault when the proc is called.  There
    // does not appear to be any way for us to work around it since USER's thunking code
    // trashes the stack so this API is disabled for Win95.
    //
    m_fEditControlUnicode = g_fRunningOnNT && IsWindowUnicode(m_hwndEdit);
    if (m_fEditControlUnicode)
    {
        m_oldEditWordBreakProc = (EDITWORDBREAKPROC)SendMessage(m_hwndEdit, EM_GETWORDBREAKPROC, 0, 0);
        SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)EditWordBreakProcW);
    }
#endif

    //
    // bug 81414 : To avoid clashing with app messages used by the edit window, we
    // use registered messages.
    //
    m_uMsgSearchComplete  = RegisterWindowMessageA("AC_SearchComplete");
    m_uMsgItemActivate    = RegisterWindowMessageA("AC_ItemActivate");

    if (m_uMsgSearchComplete == 0)
    {
        m_uMsgSearchComplete = WM_APP + 300;
    }
    if (m_uMsgItemActivate == 0)
    {
        m_uMsgItemActivate   = WM_APP + 301;
    }

    _SetQuickCompleteStrings(pwszRegKeyPath, pwszQuickComplete);

    // IEnumString required
    ASSERT(m_pes == NULL);
    EVAL(SUCCEEDED(punkACL->QueryInterface(IID_IEnumString, (void **)&m_pes)));

    // IACList optional
    ASSERT(m_pacl == NULL);
    punkACL->QueryInterface(IID_IACList, (void **)&m_pacl);

    AddRef();       // Hold on to a ref for our Subclass.

    // Initial creation should have failed if the thread object was not allocated!
    ASSERT(m_pThread);
    m_pThread->Init(m_pes, m_pacl);

    // subclass the edit window
    SetWindowSubclass(m_hwndEdit, &s_EditWndProc, 0, (DWORD_PTR)this);

//#define TEST_SETFONT
#ifdef TEST_SETFONT
    HFONT h = CreateFont(20, 5, 0, 0, FW_BOLD, TRUE, FALSE, FALSE, ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                 FF_ROMAN, NULL);
    SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM)h, TRUE);
#endif

    // See what autocomplete features are enabled
    _SeeWhatsEnabled();


    // See if hwndEdit is part of a combobox
    HWND hwndParent = GetParent(m_hwndEdit);
    WCHAR szClass[30];
    int nLen = GetClassName(hwndParent, szClass, ARRAYSIZE(szClass));
    if (nLen != 0 &&
        (StrCmpI(szClass, L"combobox") == 0 || StrCmpI(szClass, L"comboboxex") == 0))
    {
        m_hwndCombo = hwndParent;
    }

    // If we've already got focus, then we need to call GotFocus...
    if (GetFocus() == hwndEdit)
    {
        m_pThread->GotFocus();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Checks to see if autoappend or autosuggest freatures are enabled
//--------------------------------------------------------------------------
void CAutoComplete::_SeeWhatsEnabled()
{
#ifdef ALLOW_ALWAYS_DROP_UP
    m_fAlwaysDropUp = SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE,
                            TEXT("AlwaysDropUp"), FALSE, /*default:*/FALSE);
#endif

    // If autosuggest was just enabled, create the dropdown window
    if (_IsAutoSuggestEnabled() && NULL == m_hwndDropDown)
    {
        // Create the dropdown Window
        WNDCLASS wc = {0};

        wc.lpfnWndProc      = s_DropDownWndProc;
        wc.cbWndExtra       = SIZEOF(CAutoComplete*);
        wc.hInstance        = HINST_THISDLL;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszClassName    = c_szAutoSuggestClass;

        SHRegisterClass(&wc);

        DWORD dwExStyle =  WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_NOPARENTNOTIFY;
        if(_IsRTLReadingEnabled())
        {
            dwExStyle |= WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR;
        }
#ifdef UNIX
        // IEUNIX : Working around window activation problems in mainwin
        // Autocomplete is completely hosed without this flag on UNIX.
        dwExStyle |= WS_EX_MW_UNMANAGED_WINDOW;
#endif
#ifdef AC_TRANSLUCENCY
        if (g_bRunOnNT5 && g_fIE)
        {
            dwExStyle |= WS_EX_LAYERED;
        }
#endif

        // The dropdown holds a ref on this object
        AddRef();
        m_hwndDropDown = CreateWindowEx(dwExStyle,
                                        c_szAutoSuggestClass,
                                        c_szAutoSuggestTitle,   // GPF dialog is picking up this name!
                                        WS_POPUP | WS_BORDER | WS_CLIPCHILDREN,
                                        0, 0, 100, 100,
                                        NULL, NULL, HINST_THISDLL, this);

        if (m_hwndDropDown)
        {
#ifdef AC_TRANSLUCENCY
            if (g_fIE)
            {
                SetLayeredWindowAttributes(m_hwndDropDown, 
                                           0,
                                           230, 
                                           LWA_ALPHA);
            }
#endif
            m_fDropDownResized = FALSE;
        }
        else
        {
            Release();
        }
    }
    else if (!_IsAutoSuggestEnabled() && NULL != m_hwndDropDown)
    {
        // We don't need the dropdown Window.
        if (m_hwndList)
        {
            DestroyWindow(m_hwndList);
        }
        DestroyWindow(m_hwndDropDown);
    }
}

//+-------------------------------------------------------------------------
// Returns TRUE if autocomplete is currently enabled
//--------------------------------------------------------------------------
BOOL CAutoComplete::IsEnabled()
{
    BOOL fRet;

    //
    // If we have not used the new IAutoComplete2 interface, we revert
    // to the old IE4 global registry setting
    //
    if (m_dwOptions & ACO_UNINITIALIZED)
    {
        fRet = SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE,
                            REGSTR_VAL_USEAUTOCOMPLETE, FALSE, TRUE);
    }
    else
    {
        fRet = (m_dwOptions & (ACO_AUTOAPPEND | ACO_AUTOSUGGEST));
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Enables/disables the up down arrow for autocomplete.  Used by comboboxes
// to disable arrow keys when the combo box is dropped. (This function is
// now redundent because we check to see of the combo is dropped.)
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Enable(BOOL fEnable)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::Enable(0x%x)", fEnable);

    HRESULT hr = (m_dwFlags & ACF_IGNOREUPDOWN) ? S_FALSE : S_OK;

    if (fEnable)
        m_dwFlags &= ~ACF_IGNOREUPDOWN;
    else
        m_dwFlags |= ACF_IGNOREUPDOWN;

    return hr;
}

/* IAutocomplete2 methods */
//+-------------------------------------------------------------------------
// Enables/disables various autocomplete features (see ACO_* flags)
//--------------------------------------------------------------------------
HRESULT CAutoComplete::SetOptions(DWORD dwOptions)
{
    m_dwOptions = dwOptions;
    _SeeWhatsEnabled();
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns the current option settings
//--------------------------------------------------------------------------
HRESULT CAutoComplete::GetOptions(DWORD* pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = m_dwOptions;
        hr = S_OK;
    }

    return hr;
}

/* IAutocompleteDropDown methods */
//+-------------------------------------------------------------------------
// Returns the current dropdown status
//--------------------------------------------------------------------------
HRESULT CAutoComplete::GetDropDownStatus(DWORD *pdwFlags, LPWSTR *ppwszString)
{
    if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
    {
        if (pdwFlags)
        {
            *pdwFlags = ACDD_VISIBLE;
        }

        if (ppwszString)
        {
            *ppwszString=NULL;

            if (m_hwndList)
            {
                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (iCurSel != -1)
                {
                    WCHAR szBuf[MAX_URL_STRING];
                    _GetItem(iCurSel, szBuf, ARRAYSIZE(szBuf), FALSE);

                    *ppwszString = (LPWSTR) CoTaskMemAlloc((lstrlenW(szBuf)+1)*sizeof(WCHAR));
                    if (*ppwszString)
                    {
                        StrCpyW(*ppwszString, szBuf);
                    }
                }
            }
        }
    }
    else
    {
        if (pdwFlags)
        {
            *pdwFlags = 0;
        }

        if (ppwszString)
        {
            *ppwszString = NULL;
        }
    }

    return S_OK;
}

HRESULT CAutoComplete::ResetEnumerator()
{
    _StopSearch();
    _ResetSearch();
    _FreeDPAPtrs(m_hdpa);
    m_hdpa = NULL;

    // If the dropdown is currently visible, re-search the IEnumString
    //  and show the dropdown. Otherwise wait for user input.
    if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
    {
        _StartCompletion(FALSE, TRUE);
    }

    return S_OK;
}

/* IEnumString methods */
//+-------------------------------------------------------------------------
// Resets the IEnumString functionality exposed for external users.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Reset()
{
    HRESULT hr = E_FAIL;

    if (!m_szEnumString)        // If we needed it once, we will most likely continue to need it.
        m_szEnumString = (LPTSTR) LocalAlloc(LPTR, MAX_URL_STRING * SIZEOF(TCHAR));

    if (!m_szEnumString)
        return E_OUTOFMEMORY;

    GetWindowText(m_hwndEdit, m_szEnumString, MAX_URL_STRING);
    if (m_pesExtern)
        hr = m_pesExtern->Reset();
    else
    {
        hr = m_pes->Clone(&m_pesExtern);
        if (SUCCEEDED(hr))
            hr = m_pesExtern->Reset();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Returns the next BSTR from the autocomplete enumeration.
//
// For consistant results, the caller should not allow the AutoComplete text
// to change between one call to Next() and another call to Next().
// AutoComplete text should change only before Reset() is called.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Next
(
    ULONG celt,         // number items to fetch, needs to be 1
    LPOLESTR *rgelt,    // returned BSTR, caller must free
    ULONG *pceltFetched // number of items returned
)
{
    HRESULT hr = S_FALSE;
    LPOLESTR pwszUrl;
    ULONG cFetched;

    // Pre-init in case of error
    if (rgelt)
        *rgelt = NULL;
    if (pceltFetched)
        *pceltFetched = 0;

    if (!EVAL(rgelt) || (!EVAL(pceltFetched)) || (!EVAL(1 == celt)) || !EVAL(m_pesExtern))
        return E_INVALIDARG;

    while (S_OK == (hr = m_pesExtern->Next(1, &pwszUrl, &cFetched)))
    {
        if (!StrCmpNI(m_szEnumString, pwszUrl, lstrlen(m_szEnumString)))
        {
            TraceMsg(TF_BAND|TF_GENERAL, "CAutoComplete: Next(). AutoSearch Failed URL=%s.", pwszUrl);
            break;
        }
        else
        {
            // If the string can't be added to our list, we will free it.
            TraceMsg(TF_BAND|TF_GENERAL, "CAutoComplete: Next(). AutoSearch Match URL=%s.", pwszUrl);
            CoTaskMemFree(pwszUrl);
        }
    }

    if (S_OK == hr)
    {
        *rgelt = (LPOLESTR)pwszUrl;
        *pceltFetched = 1;  // We will always only fetch one.
    }

    return hr;
}

CAutoComplete::CAutoComplete() : m_cRef(1)
{
    DllAddRef();
    TraceMsg(AC_GENERAL, "CAutoComplete::CAutoComplete()");

    // This class requires that this COM object be allocated in Zero INITed
    // memory.  If the asserts below go off, then this was violated.
    ASSERT(!m_dwFlags);
    ASSERT(!m_hwndEdit);
    ASSERT(!m_pszCurrent);
    ASSERT(!m_iCurrent);
    ASSERT(!m_dwLastSearchFlags);
    ASSERT(!m_pes);
    ASSERT(!m_pacl);
    ASSERT(!m_pesExtern);
    ASSERT(!m_szEnumString);
    ASSERT(!m_pThread);

    m_dwOptions = ACO_UNINITIALIZED;
    m_hfontListView = NULL;
}

CAutoComplete::~CAutoComplete()
{
    TraceMsg(AC_GENERAL, "CAutoComplete::~CAutoComplete()");

    ASSERT(m_hwndDropDown == NULL)

    SAFERELEASE(m_pes);
    SAFERELEASE(m_pacl);
    SAFERELEASE(m_pesExtern);

    SetStr(&m_pszCurrent, NULL);

    if (m_szEnumString)
        LocalFree(m_szEnumString);

    if (m_hdpaSortIndex)
    {
        // Note that this list pointed to items in m_hdpa, so we don't need
        // to free the items pointed to by this list.
        DPA_Destroy(m_hdpaSortIndex);
        m_hdpaSortIndex = NULL;
    }

    _FreeDPAPtrs(m_hdpa);

    if (m_pThread)
    {
        m_pThread->SyncShutDownBGThread();
        SAFERELEASE(m_pThread);
    }

    DllRelease();
}

STDMETHODIMP CAutoComplete::get_accName(VARIANT varChild, BSTR  *pszName)
{
    HRESULT hr;

    if (varChild.vt == VT_I4)
    {
        if (varChild.lVal > 0)
        {
            WCHAR szBuf[MAX_URL_STRING];

            _GetItem(varChild.lVal - 1, szBuf, ARRAYSIZE(szBuf), TRUE);
            *pszName = SysAllocString(szBuf);
        }
        else
        {
            *pszName = NULL;
        }
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Private initialization
//--------------------------------------------------------------------------
BOOL CAutoComplete::_Init()
{
    m_pThread = new CACThread(*this);

    return (NULL != m_pThread);
}

//+-------------------------------------------------------------------------
// Creates and instance of CAutoComplete
//--------------------------------------------------------------------------
HRESULT CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // Note - Aggregation checking is handled in class factory

    *ppunk = NULL;
    CAutoComplete* p = new CAutoComplete();
    if (p)
    {
        if (p->_Init())
        {
            *ppunk = SAFECAST(p, IAutoComplete *);
            return S_OK;
        }

        delete p;
    }

    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
// Helper function to add default autocomplete functionality to and edit
// window.
//--------------------------------------------------------------------------
HRESULT SHUseDefaultAutoComplete
(
    HWND hwndEdit,
    IBrowserService * pbs,          IN  OPTIONAL
    IAutoComplete2 ** ppac,         OUT OPTIONAL
    IShellService ** ppssACLISF,    OUT OPTIONAL
    BOOL fUseCMDMRU
)
{
    HRESULT hr;
    IUnknown * punkACLMulti;

    if (ppac)
        *ppac = NULL;
    if (ppssACLISF)
        *ppssACLISF = NULL;

    hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLMulti);
    if (SUCCEEDED(hr))
    {

        IObjMgr * pomMulti;

        hr = punkACLMulti->QueryInterface(IID_IObjMgr, (LPVOID *)&pomMulti);
        if (SUCCEEDED(hr))
        {
            BOOL fReady = FALSE;   // Fail only if all we are not able to create at least one list.

            // ADD The MRU List
            IUnknown * punkACLMRU;

            //  MRU for run dialog no longer adds URL MRU automatically
            //   so we have to add it ourselves
            if (fUseCMDMRU)
            {
                hr = CACLMRU_CreateInstance(NULL, &punkACLMRU, NULL, SZ_REGKEY_TYPEDCMDMRU);
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLMRU);
                    punkACLMRU->Release();
                    fReady = TRUE;
                }
            }

            hr = CACLMRU_CreateInstance(NULL, &punkACLMRU, NULL, SZ_REGKEY_TYPEDURLMRU);
            if (SUCCEEDED(hr))
            {
                pomMulti->Append(punkACLMRU);
                punkACLMRU->Release();
                fReady = TRUE;
            }

            // ADD The History List
            IUnknown * punkACLHist;
            hr = CoCreateInstance(CLSID_ACLHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLHist);
            if (SUCCEEDED(hr))
            {
                pomMulti->Append(punkACLHist);
                punkACLHist->Release();
                fReady = TRUE;
            }

            // ADD The ISF List
            IUnknown * punkACLISF;
            hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLISF);
            if (SUCCEEDED(hr))
            {
                // We need to give the ISF AutoComplete List a pointer to the IBrowserService
                // so it can retrieve the current browser location to AutoComplete correctly.
                IShellService * pss;
                hr = punkACLISF->QueryInterface(IID_IShellService, (LPVOID *)&pss);
                if (SUCCEEDED(hr))
                {
                    if (pbs)
                        pss->SetOwner(pbs);

                    if (ppssACLISF)
                        *ppssACLISF = pss;
                    else
                        pss->Release();
                }

                //
                // Set options
                //
                IACList2* pacl;
                if (SUCCEEDED(punkACLISF->QueryInterface(IID_IACList2, (LPVOID *)&pacl)))
                {
                    // Specify directories to search
                    pacl->SetOptions(ACLO_CURRENTDIR | ACLO_FAVORITES | ACLO_MYCOMPUTER | ACLO_DESKTOP);
                    pacl->Release();
                }

                pomMulti->Append(punkACLISF);
                punkACLISF->Release();
                fReady = TRUE;
            }

            if (fReady)
            {
                IAutoComplete2 * pac;

                // Create the AutoComplete Object
                hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete2, (void **)&pac);
                if (SUCCEEDED(hr))
                {
                    // Load the quick complete string.
                    WCHAR szQuickComplete[50]; // US string is 17 characters, 50 should be plenty without blowing the stack

                    MLLoadString(IDS_QUICKCOMPLETE, szQuickComplete, ARRAYSIZE(szQuickComplete));

                    hr = pac->Init(hwndEdit, punkACLMulti, WZ_REGKEY_QUICKCOMPLETE, szQuickComplete);
                    if (ppac)
                        *ppac = pac;
                    else
                        pac->Release();
                }
            }

            pomMulti->Release();
        }
        punkACLMulti->Release();
    }

    return hr;
}

/* Private functions */

//+-------------------------------------------------------------------------
// Removes anything that we appended to the edit text
//--------------------------------------------------------------------------
void CAutoComplete::_RemoveCompletion()
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_RemoveCompletion()");
    if (m_fAppended)
    {
        // Remove any highlighted text that we displayed
        Edit_ReplaceSel(m_hwndEdit, TEXT(""));
        m_fAppended = FALSE;
    }
}

//+-------------------------------------------------------------------------
// Updates the text in the edit control
//--------------------------------------------------------------------------
void CAutoComplete::_SetEditText(LPCWSTR psz)
{
    //
    // We set a flag so that we can distinguish between us setting the text
    // and someone else doing it.  If someone else sets the text we hide our
    // dropdown.
    //
    m_fSettingText = TRUE;

    // Don't display our special wildcard search string
    if (psz[0] == CH_WILDCARD)
    {
        Edit_SetText(m_hwndEdit, L"");
    }
    else
    {
        Edit_SetText(m_hwndEdit, psz);
    }

    m_fSettingText = FALSE;
}

//+-------------------------------------------------------------------------
// Removed anything that we appended to the edit text and then updates
// m_pszCurrent with the current string.
//--------------------------------------------------------------------------
void CAutoComplete::_GetEditText(void)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_GetEditText()");

    _RemoveCompletion();  // remove anything we added

    int iCurrent = GetWindowTextLength(m_hwndEdit);

    //
    // If the current buffer is too small, delete it.
    //
    if (m_pszCurrent &&
         LocalSize(m_pszCurrent) <= (UINT)(iCurrent + 1) * sizeof(TCHAR))
    {
        SetStr(&m_pszCurrent, NULL);
    }

    //
    // If there is no current buffer, try to allocate one
    // with some room to grow.
    //
    if (!m_pszCurrent)
    {
        m_pszCurrent = (LPTSTR)LocalAlloc(LPTR, (iCurrent + (MAX_URL_STRING / 2)) * SIZEOF(TCHAR));
    }

    //
    // If we have a current buffer, get the text.
    //
    if (m_pszCurrent)
    {
        if (!GetWindowText(m_hwndEdit, m_pszCurrent, iCurrent + 1))
        {
            *m_pszCurrent = L'\0';
        }

        // On win9x GetWindowTextLength can return more than the # of characters
        m_iCurrent = lstrlen(m_pszCurrent);
    }
    else
    {
        m_iCurrent = 0;
    }
}

//+-------------------------------------------------------------------------
// Updates the text in the edit control
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateText
(
    int iStartSel,      // start location for selected
    int iEndSel,        // end location of selected text
    LPCTSTR pszCurrent, // unselected text
    LPCTSTR pszNew      // autocompleted (selected) text
)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_UpdateText(iStart=%i;  iEndSel = %i,  pszCurrent=>%s<,  pszNew=>%s<)",
        iStartSel, iEndSel, (pszCurrent ? pszCurrent : TEXT("(null)")), (pszNew ? pszNew : TEXT("(null)")));

    //
    // Restore the old text.
    //
    _SetEditText(pszCurrent);

    //
    // Put the cursor at the insertion point.
    //
    Edit_SetSel(m_hwndEdit, iStartSel, iStartSel);

    //
    // Insert the new text.
    //
    Edit_ReplaceSel(m_hwndEdit, pszNew);

    //
    // Select the newly added text.
    //
    Edit_SetSel(m_hwndEdit, iStartSel, iEndSel);
}

//+-------------------------------------------------------------------------
// If pwszQuickComplete is NULL, we will use our internal default.
// pwszRegKeyValue can be NULL indicating that there is not a key.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_SetQuickCompleteStrings(LPCOLESTR pwszRegKeyPath, LPCOLESTR pwszQuickComplete)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_SetQuickCompleteStrings(pwszRegKeyPath=0x%x, pwszQuickComplete = 0x%x)",
        pwszRegKeyPath, pwszQuickComplete);

    if (pwszRegKeyPath)
    {
        lstrcpyn(m_szRegKeyPath, pwszRegKeyPath, ARRAYSIZE(m_szRegKeyPath));
    }
    else
    {
        // can be empty
        m_szRegKeyPath[0] = TEXT('\0');
    }

    if (pwszQuickComplete)
    {
        lstrcpyn(m_szQuickComplete, pwszQuickComplete, ARRAYSIZE(m_szQuickComplete));
    }
    else
    {
        // use default value
        lstrcpyn(m_szQuickComplete, c_szAutoDefQuickComp, ARRAYSIZE(m_szQuickComplete));
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// Formats the current contents of the edit box with the appropriate prefix
// and endfix and returns the completed string.
//--------------------------------------------------------------------------
LPTSTR CAutoComplete::_QuickEnter()
{
    //
    // If they shift-enter, then do the favorite pre/post-fix.
    //
    TCHAR  szFormat[MAX_QUICK_COMPLETE_STRING];
    TCHAR  szNewText[MAX_URL_STRING];
    int    iLen;

    TraceMsg(AC_GENERAL, "CAutoComplete::_QuickEnter()");

    if (NULL == m_pszCurrent)
    {
        return NULL;
    }

    lstrcpyn(szFormat, m_szQuickComplete, ARRAYSIZE(szFormat));
    DWORD cb = sizeof(szFormat);
    SHGetValue(HKEY_CURRENT_USER, m_szRegKeyPath, TEXT("QuickComplete"), NULL, &szFormat, &cb);

    //
    //  Remove preceeding and trailing white space
    //
    PathRemoveBlanks(m_pszCurrent);

    //
    // Make sure we don't GPF.
    //
    iLen = lstrlen(m_pszCurrent) + lstrlen(szFormat);
    if (iLen < ARRAYSIZE(szNewText))
    {
        // If the quick complete is already present, don't add it again
        LPWSTR pszInsertion = StrStrI(szFormat, L"%s");
        LPWSTR pszFormat = szFormat;
        if (pszInsertion)
        {
            // If prefix is already present, don't add it again.
            // (we could improve this to only add parts of the predfix that are missing)
            int iInsertion = (int)(pszInsertion - pszFormat);
            if (iInsertion == 0 || StrCmpNI(pszFormat, m_pszCurrent, iInsertion) == 0)
            {
                // Skip over prefix
                pszFormat = pszInsertion;
            }

            // If postfix is  already present, don't add it again.
            LPWSTR pszPostFix = pszInsertion + ARRAYSIZE(L"%s") - 1;
            int cchCurrent = lstrlen(m_pszCurrent);
            int cchPostFix = lstrlen(pszPostFix);
            if (cchPostFix > 0 && cchPostFix < cchCurrent &&
                StrCmpI(m_pszCurrent + (cchCurrent - cchPostFix), pszPostFix) == 0)
            {
                // Lop off postfix
                *pszPostFix = 0;
            }
        }

        wnsprintf(szNewText, ARRAYSIZE(szNewText), pszFormat, m_pszCurrent);

        SetStr(&m_pszCurrent, szNewText);
    }

    return m_pszCurrent;
}

BOOL CAutoComplete::_ResetSearch(void)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_ResetSearch()");

    m_dwFlags               = ACF_RESET;
    return TRUE;
}

//+-------------------------------------------------------------------------
// Returns TRUE if the char is a forward or backackwards slash
//--------------------------------------------------------------------------
BOOL CAutoComplete::_IsWhack(TCHAR ch)
{
    return (ch == TEXT('/')) || (ch == TEXT('\\'));
}


//+-------------------------------------------------------------------------
// Returns TRUE if the string points to a character used to separate words
//--------------------------------------------------------------------------
BOOL CAutoComplete::_IsBreakChar(WCHAR wch)
{
    // Do a binary search in our table of break characters
    int iMin = 0;
    int iMax = ARRAYSIZE(g_szBreakChars) - 1;

    while (iMax - iMin >= 2)
    {
        int iTry = (iMax + iMin + 1) / 2;
        if (wch < g_szBreakChars[iTry])
            iMax = iTry;
        else if  (wch > g_szBreakChars[iTry])
            iMin = iTry;
        else
            return TRUE;
    }

    return (wch == g_szBreakChars[iMin] || wch == g_szBreakChars[iMax]);
}

//+-------------------------------------------------------------------------
// Returns TRUE if we want to append to the current edit box contents
//--------------------------------------------------------------------------
BOOL CAutoComplete::_WantToAppendResults()
{
    //
    // Users get annoyed if we append real text after a
    // slash, because they type "c:\" and we complete
    // it to "c:\windows" when they aren't looking.
    //
    // Also, it's annoying to have "\" autocompleted to "\\"
    //
    return (m_pszCurrent &&
            (!(_IsWhack(m_pszCurrent[0]) && m_pszCurrent[1] == NULL) &&
             !_IsWhack(m_pszCurrent[lstrlen(m_pszCurrent)-1])));
}


#ifdef UNIX
extern "C" BOOL MwTranslateUnixKeyBinding( HWND hwnd, DWORD message,
                                           WPARAM *pwParam, DWORD *pModifiers );
#endif


//+-------------------------------------------------------------------------
// Callback routine used by the edit window to determine where to break
// words.  We install this custom callback dor the ctl arrow keys
// recognize our break characters.
//--------------------------------------------------------------------------
int CALLBACK CAutoComplete::EditWordBreakProcW
(
    LPWSTR pszEditText, // pointer to edit text
    int ichCurrent,     // index of starting point
    int cch,            // length in characters of edit text
    int code            // action to take
)
{
    LPWSTR psz = pszEditText + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code)
    {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)_IsBreakChar(*psz);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((psz = CharPrev(pszEditText, psz)) != pszEditText)
            {
                if (_IsBreakChar(*psz))
                {
                    if (fRight || fFoundNonDelimiter)
                        break;
                }
                else
                {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int)(psz - pszEditText);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !_IsBreakChar(*psz);
            if (psz != (pszEditText + cch))
            {
                while ((psz = CharNext(psz)) != (pszEditText + cch))
                {
                    if (_IsBreakChar(*psz))
                    {
                        fFoundNonDelimiter = FALSE;
                    }
                    else
                    {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (psz - pszEditText);
            break;

        default:
            iIndex = 0;
            break;
    }

    return iIndex;
}

//+-------------------------------------------------------------------------
// Returns the index of the next or previous break character in m_pszCurrent
//--------------------------------------------------------------------------
int CAutoComplete::_JumpToNextBreak
(
    int iLoc,       // current location
    DWORD dwFlags   // direction (WB_RIGHT or WB_LEFT)
)
{
    return EditWordBreakProcW(m_pszCurrent, iLoc, lstrlen(m_pszCurrent), dwFlags);
}

//+-------------------------------------------------------------------------
// Handles Horizontal cursor movement.  Returns TRUE if the message should
// passed on to the OS.  Note that we only call this on win9x.  On NT we
// use EM_SETWORDBREAKPROC to set a callback instead because it sets the
// caret correctly. This callback can crash on win9x.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_CursorMovement
(
    WPARAM wParam   // virtual key data from WM_KEYDOWN
)
{
    BOOL  fShift, fControl;
    DWORD dwKey = (DWORD)wParam;
    int iStart, iEnd;

    TraceMsg(AC_GENERAL, "CAutoComplete::_CursorMovement(wParam = 0x%x)",
        wParam);

    fShift   = (0 > GetKeyState(VK_SHIFT)) ;
    fControl = (0 > GetKeyState(VK_CONTROL));

    // We don't do anything special unless the CTRL
    // key is down so we don't want to mess up arrowing around
    // UNICODE character clusters. (INDIC o+d+j+d+k+w)
    if (!fControl)
        return TRUE;   // let OS handle because of UNICODE char clusters


#ifdef UNIX
    {
        DWORD dwModifiers;
        dwModifiers = 0;
        if ( fShift ) {
            dwModifiers |= FSHIFT;
        }
        if ( fControl ) {
            dwModifiers |= FCONTROL;
        }

        MwTranslateUnixKeyBinding( m_hwndEdit, WM_KEYDOWN,
                                   (WPARAM*) &dwKey, &dwModifiers );

        fShift   = ( dwModifiers & FSHIFT );
        fControl = ( dwModifiers & FCONTROL );
    }
#endif

    // get the current selection
    SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);

    // the user is editting the text, so this is now invalid.
    m_dwFlags = ACF_RESET;

    _GetEditText();
    if (!m_pszCurrent)
        return TRUE;    // we didn't handle it... let the default wndproc try

    //  Determine the previous selection direction
    int dwSelectionDirection;
    if (iStart == iEnd)
    {
        // Nothing previously selected, so use new direction
        dwSelectionDirection = dwKey;
    }
    else
    {
        // Base the selection direction on whether the caret is positioned
        // at the beginning or the end of the selection
        POINT pt;
        int cchCaret = iEnd;
        if (GetCaretPos(&pt))
        {
            cchCaret = (int)SendMessage(m_hwndEdit, EM_CHARFROMPOS, 0, (LPARAM)MAKELPARAM(pt.x, 0));
        }

        dwSelectionDirection = (cchCaret >= iEnd) ? VK_RIGHT : VK_LEFT;
    }


    if (fControl)
    {
        if (dwKey == VK_RIGHT)
        {
            // did we orginally go to the left?
            if (dwSelectionDirection == VK_LEFT)
            {
                // yes...unselect
                iStart = _JumpToNextBreak(iStart, WB_RIGHT);
 //               if (!iStart)
 //                   iStart = m_iCurrent;
            }
            else if (iEnd != m_iCurrent)
            {
                // select or "jump over" characters
                iEnd = _JumpToNextBreak(iEnd, WB_RIGHT);
 //               if (!iEnd)
 //                   iEnd = m_iCurrent;
            }
        }
        else // dwKey == VK_LEFT
        {
            // did we orginally go to the right?
            if (dwSelectionDirection == VK_RIGHT)
            {
                // yes...unselect
//                int iRemember = iEnd;
                iEnd = _JumpToNextBreak(iEnd, WB_LEFT);
            }
            else if (iStart)  // != 0
            {
                // select or "jump over" characters
                iStart = _JumpToNextBreak(iStart, WB_LEFT);
            }
        }
    }
    else // if !fControl
    {
        // This code is benign if the SHIFT key isn't down
        // because it has to do with modifying the selection.
        if (dwKey == VK_RIGHT)
        {
            if (dwSelectionDirection == VK_LEFT)
            {
                iStart++;
            }
            else
            {
                iEnd++;
            }
        }
        else // dwKey == VK_LEFT
        {
            LPTSTR pszPrev;
            if (dwSelectionDirection == VK_RIGHT)
            {
                pszPrev = CharPrev(m_pszCurrent, &m_pszCurrent[iEnd]);
                iEnd = (int)(pszPrev - m_pszCurrent);
            }
            else
            {
                pszPrev = CharPrev(m_pszCurrent, &m_pszCurrent[iStart]);
                iStart = (int)(pszPrev - m_pszCurrent);
            }
        }
    }

    // Are we selecting or moving?
    if (!fShift)
    {   // just moving...
        if (dwKey == VK_RIGHT)
        {
            iStart = iEnd;
        }
        else // pachi->dwSelectionDirection == VK_LEFT
        {
            iEnd = iStart;
        }
    }

    //
    // If we are selecting text to the left, we have to jump hoops
    // to get the caret on the left of the selection. Edit_SetSel
    // always places the caret on the right, and if we position the
    // caret ourselves the edit control still uses the old caret
    // position.  So we have to send VK_LEFT messages to the edit
    // control to get it to select things properly.
    //
    if (fShift && dwSelectionDirection == VK_LEFT && iStart < iEnd)
    {
        // Temporarily reset the control key (yuk!)
        BYTE keyState[256];
        BOOL fGetKeyboardState;

        if (fControl)
        {
            fGetKeyboardState = GetKeyboardState(keyState);

            if (fGetKeyboardState )
            {
                keyState[VK_CONTROL] &= 0x7f;
                SetKeyboardState(keyState);
            }
        }

        // Select the last character and select left
        // one character at a time.  Arrrggg.
        SendMessage(m_hwndEdit, WM_SETREDRAW, FALSE, 0);
        Edit_SetSel(m_hwndEdit, iEnd, iEnd);
        while (iEnd > iStart)
        {
            DefSubclassProc(m_hwndEdit, WM_KEYDOWN, VK_LEFT, 0);
            --iEnd;
        }
        SendMessage(m_hwndEdit, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(m_hwndEdit, NULL, FALSE);
        UpdateWindow(m_hwndEdit);

        // Restore the control key
        if (fControl && fGetKeyboardState )
        {
            keyState[VK_CONTROL] |= 0x80;
            SetKeyboardState(keyState);
        }
    }
    else
    {
        Edit_SetSel(m_hwndEdit, iStart, iEnd);
    }

    return FALSE;   // we handled it
}

//+-------------------------------------------------------------------------
// Process WM_KEYDOWN message.  Returns TRUE if the message should be passed
// to the original wndproc.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_OnKeyDown(WPARAM wParam)
{
    WPARAM wParamTranslated;

    TraceMsg(AC_GENERAL, "CAutoComplete::_OnKeyDown(wParam = 0x%x)",
        wParam);

    if (m_pThread->IsDisabled())
    {
        //
        // Let the original wndproc handle it.
        //
        return TRUE;
    }

    wParamTranslated = wParam;

#ifdef UNIX
    // Don't pass in HWND as the edit control will and we don't
    // want translation to cause two SendMessages for the same
    // control
    DWORD dwModifiers;
    dwModifiers = 0;
    if (GetKeyState(VK_CONTROL) < 0) {
        dwModifiers |= FCONTROL;
    }

    MwTranslateUnixKeyBinding( NULL, WM_KEYDOWN,
                               &wParamTranslated, &dwModifiers );
#endif

    switch (wParamTranslated)
    {
    case VK_RETURN:
    {
#ifndef UNIX
        if (0 > GetKeyState(VK_CONTROL))
#else
        if (dwModifiers & FCONTROL)
#endif
        {
            //
            // Ctrl-Enter does some quick formatting.
            //
            _GetEditText();
            _SetEditText(_QuickEnter());
        }
        else
        {
            //
            // Reset the search criteria.
            //
            _ResetSearch();

            //
            // Highlight entire text.
            //
            Edit_SetSel(m_hwndEdit, 0, (LPARAM)-1);
        }

        //
        // Stop any searches that are going on.
        //
        _StopSearch();

        //
        // For intelliforms, if the dropdown is visible and something
        // is selected in the dropdown, we simulate an activation event.
        //
        if (m_hwndList)
        {
            int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if ((iCurSel != -1) && m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                WCHAR szBuf[MAX_URL_STRING];
                _GetItem(iCurSel, szBuf, ARRAYSIZE(szBuf), FALSE);
                SendMessage(m_hwndEdit, m_uMsgItemActivate, 0, (LPARAM)szBuf);
            }
        }

        //
        // Hide the dropdown
        //
        _HideDropDown();

        // APPCOMPAT: For some reason, the original windproc is ignoring the return key.
        //         It should hide the dropdown!
        if (m_hwndCombo)
        {
            SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, FALSE, 0);
        }

        //
        // Let the original wndproc handle it.
        //
        break;
    }
    case VK_ESCAPE:
        _StopSearch();
        _HideDropDown();

        // APPCOMPAT: For some reason, the original windproc is ignoring the enter key.
        //         It should hide the dropdown!
        if (m_hwndCombo)
        {
            SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, FALSE, 0);
        }
        break;

    case VK_LEFT:
    case VK_RIGHT:
        // We do our own cursor movement on win9x because EM_SETWORDBREAKPROC is broken.
        if (!g_fRunningOnNT)
        {
            return _CursorMovement(wParam);
        }
        break;

    case VK_PRIOR:
    case VK_UP:
        if (!(m_dwFlags & ACF_IGNOREUPDOWN) && !_IsComboboxDropped())
        {
            //
            // If the dropdown is visible, the up-down keys navigate our list
            //
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

                if (iCurSel == 0)
                {
                    // If at top, move back up into the edit box
                    // Deselect the dropdown and select the edit box
                    ListView_SetItemState(m_hwndList, 0, 0, 0x000f);
                    if (m_pszCurrent)
                    {
                        // Restore original text if they arrow out of listview
                        _SetEditText(m_pszCurrent);
                    }
                    Edit_SetSel(m_hwndEdit, MAX_URL_STRING, MAX_URL_STRING);
                }
                else if (iCurSel != -1)
                {
                    // If in middle or at bottom, move up
                    SendMessage(m_hwndList, WM_KEYDOWN, wParam, 0);
                    SendMessage(m_hwndList, WM_KEYUP, wParam, 0);
                }
                else
                {
                    int iSelect = ListView_GetItemCount(m_hwndList)-1;

                    // If in edit box, move to bottom
                    ListView_SetItemState(m_hwndList, iSelect, LVIS_SELECTED|LVIS_FOCUSED, 0x000f);
                    ListView_EnsureVisible(m_hwndList, iSelect, FALSE);
                }
                return FALSE;
            }

            //
            // If Autosuggest drop-down enabled but not popped up then start a search
            // based on the current edit box contents.  If the edit box is empty,
            // search for everything.
            //
            else if ((m_dwOptions & ACO_UPDOWNKEYDROPSLIST) && _IsAutoSuggestEnabled())
            {
                // Ensure the background thread knows we have focus
                _GotFocus();
                _StartCompletion(FALSE, TRUE);
                return FALSE;
            }

            //
            // Otherwise we see if we should append the completions in place
            //
            else if (_IsAutoAppendEnabled())
            {
                if (_AppendPrevious(FALSE))
                {
                    return FALSE;
                }
            }
        }
        break;
    case VK_NEXT:
    case VK_DOWN:
        if (!(m_dwFlags & ACF_IGNOREUPDOWN) && !_IsComboboxDropped())
        {
            //
            // If the dropdown is visible, the up-down keys navigate our list
            //
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                ASSERT(m_hdpa);
                ASSERT(DPA_GetPtrCount(m_hdpa) != 0);
                ASSERT(m_iFirstMatch != -1);

                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (iCurSel == -1)
                {
                    // If no item selected, first down arrow selects first item
                    ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, 0x000f);
                    ListView_EnsureVisible(m_hwndList, 0, FALSE);
                }
                else if (iCurSel == ListView_GetItemCount(m_hwndList)-1)
                {
                    // If last item selected, down arrow goes into edit box
                    ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
                    if (m_pszCurrent)
                    {
                        // Restore original text if they arrow out of listview
                        _SetEditText(m_pszCurrent);
                    }
                    Edit_SetSel(m_hwndEdit, MAX_URL_STRING, MAX_URL_STRING);
                }
                else
                {
                    // If first or middle item selected, down arrow selects next item
                    SendMessage(m_hwndList, WM_KEYDOWN, wParam, 0);
                    SendMessage(m_hwndList, WM_KEYUP, wParam, 0);
                }
                return FALSE;
            }

            //
            // If Autosuggest drop-down enabled but not popped up then start a search
            // based on the current edit box contents.  If the edit box is empty,
            // search for everything.
            //
            else if ((m_dwOptions & ACO_UPDOWNKEYDROPSLIST) && _IsAutoSuggestEnabled())
            {
                // Ensure the background thread knows we have focus
                _GotFocus();
                _StartCompletion(FALSE, TRUE);
                return FALSE;
            }

            //
            // Otherwise we see if we should append the completions in place
            //
            else if (_IsAutoAppendEnabled())
            {
                if (_AppendNext(FALSE))
                {
                    return FALSE;
                }
            }
        }
        break;

    case VK_END:
    case VK_HOME:
        _ResetSearch();
        break;

    case VK_BACK:
        //
        // Indicate that selection doesn't match m_psrCurrentlyDisplayed.
        //
#ifndef UNIX
        if (0 > GetKeyState(VK_CONTROL))
#else
        if (dwModifiers & FCONTROL)
#endif
        {
            //
            // Handle Ctrl-Backspace to delete word.
            //
            int iStart, iEnd;
            SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);

            //
            // Nothing else must be selected.
            //
            if (iStart == iEnd)
            {
                _GetEditText();
                if (!m_pszCurrent)
                {
                    //
                    // We didn't handle it, let the
                    // other wndprocs try.
                    //
                    return TRUE;
                }

                //
                // Erase the "word".
                //
                iStart = EditWordBreakProcW(m_pszCurrent, iStart, iStart+1, WB_LEFT);
                Edit_SetSel(m_hwndEdit, iStart, iEnd);
                Edit_ReplaceSel(m_hwndEdit, TEXT(""));
            }

            //
            // We handled it.
            //
            return FALSE;
        }
        break;
    }

    //
    // Let the original wndproc handle it.
    //
    return TRUE;
}

LRESULT CAutoComplete::_OnChar(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;   // means nothing, but we handled the call
    TCHAR   cKey = (TCHAR) wParam;

    if (wParam == VK_TAB)
    {
        // Ignore tab characters
        return 0;
    }

    // Ensure the background thread knows we have focus
    _GotFocus();

    if (m_pThread->IsDisabled())
    {
        //
        // Just follow the chain.
        //
        return DefSubclassProc(m_hwndEdit, WM_CHAR, wParam, lParam);
    }

    if (cKey != 127 && cKey != VK_ESCAPE && cKey != VK_RETURN && cKey != 0x0a)    // control-backspace is ignored
    {
        // let the default edit wndproc do its thing first
        lres = DefSubclassProc(m_hwndEdit, WM_CHAR, wParam, lParam);

        // ctrl-c is generating a VK_CANCEL.  Don't bring up autosuggest in this case.
        if (cKey != VK_CANCEL)
        {
            BOOL fAppend = (cKey != VK_BACK);
            _StartCompletion(fAppend);
        }
    }
    else
    {
        _StopSearch();
        _HideDropDown();
    }

    return lres;
}

//+-------------------------------------------------------------------------
// Starts autocomplete based on the current editbox contents
//--------------------------------------------------------------------------
void CAutoComplete::_StartCompletion
(
    BOOL fAppend,       // Ok to append completion in edit box
    BOOL fEvenIfEmpty   // = FALSE, Completes to everything if edit box is empty
)
{
    // Get the text typed in
    WCHAR szCurrent[MAX_URL_STRING];
    int cchCurrent = GetWindowText(m_hwndEdit, szCurrent, ARRAYSIZE(szCurrent));

    // See if we want a wildcard search
    if (fEvenIfEmpty && cchCurrent == 0)
    {
        cchCurrent = 1;
        szCurrent[0] = CH_WILDCARD;
        szCurrent[1] = 0;
    }

    // If unchanged, we are done
    if (m_pszLastSearch && m_pszCurrent && StrCmpI(m_pszCurrent, szCurrent) == 0)
    {
        if (!(m_hwndDropDown && IsWindowVisible(m_hwndDropDown)) &&
            (-1 != m_iFirstMatch) && _IsAutoSuggestEnabled() &&

            // Don't show drop-down if only one exact match (IForms)
            (m_hdpa &&
             ((m_iLastMatch != m_iFirstMatch) || (((CACString*)DPA_GetPtr(m_hdpa, m_iFirstMatch))->StrCmpI(szCurrent) != 0))))
        {
            _ShowDropDown();
        }
        return;
    }

    // Save the current text
    if (szCurrent[0] == CH_WILDCARD)
    {
        SetStr(&m_pszCurrent, szCurrent);
    }
    else
    {
        _GetEditText();
    }

    //
    // Deselect the current selection in the dropdown
    //
    if (m_hwndList)
    {
        int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
        if (iCurSel != -1)
        {
            ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
        }
    }

    //
    // If nothing typed in, stop any pending search
    //
    if (cchCurrent == 0)
    {
        if (m_pszCurrent)
        {
            _StopSearch();
            if (m_pszCurrent)
            {
                SetStr(&m_pszCurrent, NULL);
            }

            // Free last completion
            _HideDropDown();
        }
    }

    //
    // See if we need to generate a new list
    //
    else
    {
        int iCompleted = m_pszLastSearch ? lstrlen(m_pszLastSearch) : 0;
        int iScheme = URL_SCHEME_UNKNOWN;

        // Get length of common prefix (if any)
        int cchPrefix = IsFlagSet(m_dwOptions, ACO_FILTERPREFIXES) ?
                            CACThread::GetSpecialPrefixLen(szCurrent) : 0;

        if  (
             // If no previous completion, start a new search
             (0 == iCompleted) ||

             // If the list was truncated (reached limit), we need to refetch
             m_fNeedNewList ||

             // We purge matches to common prefixes ("www.", "http://" etc). If the
             // last search may have resulted in items being filtered out, and the
             // new string will not, then we need to refetch.
             (cchPrefix > 0 && cchPrefix < cchCurrent && CACThread::MatchesSpecialPrefix(m_pszLastSearch)) ||

             // If the portion we last completed to was altered, we need to refetch
             (StrCmpNI(m_pszLastSearch, szCurrent, iCompleted) != 0) ||

             // If we have entered a new folder, we need to refetch
             (StrChrI(szCurrent + iCompleted, DIR_SEPARATOR_CHAR) != NULL) ||

             // If we have entered a url folder, we need to refetch (ftp://shapitst/Bryanst/)
             ((StrChrI(szCurrent + iCompleted, URL_SEPARATOR_CHAR) != NULL) &&
              (URL_SCHEME_FTP == (iScheme = GetUrlScheme(szCurrent))))
            )
        {
            // If the last search was truncated, make sure we try the next search with more characters
            int cchMin = cchPrefix + 1;
            if (m_fNeedNewList)
            {
                cchMin = iCompleted + 1;
            }

            // Find the last '\\' (or '/' for ftp)
            int i = cchCurrent - 1;
            while ((szCurrent[i] != DIR_SEPARATOR_CHAR) &&
                    !((szCurrent[i] == URL_SEPARATOR_CHAR) && (iScheme == URL_SCHEME_FTP)) &&
                    (i >= cchMin))
            {
                --i;
            }

            // Start a new search
            szCurrent[i+1] = 0;
            if (_StartSearch(szCurrent))
                SetStr(&m_pszLastSearch, szCurrent);
        }

        // Otherwise we can simply update from our last completion list
        else
        {
            //
            if (m_hdpa)
            {
                _UpdateCompletion(szCurrent, -1, fAppend);
            }
            else
            {
                // Awaiting completion, cache new match...
            }
        }
    }
}

//+-------------------------------------------------------------------------
// Get the background thread to start a new search
//--------------------------------------------------------------------------
BOOL CAutoComplete::_StartSearch(LPCWSTR pszSeatch)
{
    // Empty the dropdown list.  To minimize flash, we don't hide it unless
    // the search comes up empty
    if (m_hwndList)
    {
        ListView_SetItemCountEx(m_hwndList, 0, 0);
    }

    return m_pThread->StartSearch(pszSeatch, m_dwOptions);
}

//+-------------------------------------------------------------------------
// Get the background thread to abort the last search
//--------------------------------------------------------------------------
void CAutoComplete::_StopSearch()
{
    SetStr(&m_pszLastSearch, NULL);
    m_pThread->StopSearch();
}

//+-------------------------------------------------------------------------
// Informs the background thread that we have focus.
//--------------------------------------------------------------------------
void CAutoComplete::_GotFocus()
{
    if (!m_pThread->HasFocus())
    {
        m_pThread->GotFocus();
    }
}

//+-------------------------------------------------------------------------
// Message from background thread indicating that the search was completed
//--------------------------------------------------------------------------
void CAutoComplete::_OnSearchComplete
(
    HDPA hdpa,           // New completion list
    DWORD dwSearchStatus // see SRCH_* flags
)
{
    _FreeDPAPtrs(m_hdpa);
    m_hdpa = hdpa;
    m_fNeedNewList = IsFlagSet(dwSearchStatus, SRCH_LIMITREACHED);

    if (IsFlagSet(dwSearchStatus, SRCH_USESORTINDEX))
    {
        if (NULL == m_hdpaSortIndex)
        {
            m_hdpaSortIndex = DPA_Create(AC_LIST_GROWTH_CONST);
        }
    }
    else if (m_hdpaSortIndex)
    {
        DPA_Destroy(m_hdpaSortIndex);
        m_hdpaSortIndex = NULL;
    }

    // Was it a wildcard search?
    BOOL fWildCard = m_pszLastSearch && (m_pszLastSearch[0] == CH_WILDCARD) && (m_pszLastSearch[1] == L'\0');

    //
    // See if we should add "Search for <stuff typed in>" to the end of
    // the list.
    //
    m_fSearchForAdded = FALSE;

    if (!fWildCard && (m_dwOptions & ACO_SEARCH))
    {
        // Add "Search for <stuff typed in>" to the end of the list

        // First make sure we have a dpa
        if (m_hdpa == NULL)
        {
            m_hdpa = DPA_Create(AC_LIST_GROWTH_CONST);
        }

        if (m_hdpa)
        {
            // Create a bogus entry and add to the end of the list. This place
            // holder makes sure the drop-down does not go away when there are no
            // matching entries.
            CACString* pStr = CreateACString(L"", 0, 0);

            if (pStr)
            {
                if (DPA_AppendPtr(m_hdpa, pStr) != -1)
                {
                    m_fSearchForAdded = TRUE;
                }
                else
                {
                    pStr->Release();
                }
            }
        }
    }

    // If no search results, hide our dropdown
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa))
    {
        _HideDropDown();
        if (m_hwndList)
        {
            ListView_SetItemCountEx(m_hwndList, 0, 0);
        }
        m_iFirstMatch = -1;
    }
    else
    {
        if (m_pszCurrent)
        {
            // If we are still waiting for a completion, then update the completion list
            if (m_pszLastSearch)
            {
                _UpdateCompletion(m_pszCurrent, -1, TRUE);
            }
        }

        if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
        {
            _PositionDropDown();        // Resize based on number of hits
            _UpdateScrollbar();
        }
    }
}

//+-------------------------------------------------------------------------
// Returns the text for an item in the autocomplete list
//--------------------------------------------------------------------------
BOOL CAutoComplete::_GetItem
(
    int iIndex,         // zero-based index
    LPWSTR pszText,     // location to return text
    int cchMax,         // size of pszText buffer
    BOOL fDisplayName   // TRUE = return name to display
                        // FALSE = return name to go to edit box
)
{
    // Check for special "Search for <typed in>" entry at end of the list
    if (m_fSearchFor && iIndex == m_iLastMatch - m_iFirstMatch)
    {
        ASSERT(NULL != m_pszCurrent);

        WCHAR szFormat[MAX_PATH];
        int id = fDisplayName ? IDS_SEARCHFOR : IDS_SEARCHFORCMD;

        MLLoadString(id, szFormat, ARRAYSIZE(szFormat));
        wnsprintf(pszText, cchMax, szFormat, m_pszCurrent);
    }

    // Normal list entry
    else
    {
        CACString* pStr;

        // If we're using Sorting indicies, then we are retrieving our entries
        // out of m_hdpaPrefix sort, which contains only matched entries
        if (m_hdpaSortIndex)
        {
            pStr = (CACString *)DPA_GetPtr(m_hdpaSortIndex, iIndex);
        }
        else
        {
            pStr = (CACString *)DPA_GetPtr(m_hdpa, iIndex + m_iFirstMatch);
        }

        if (pStr)
        {
            StrCpyN(pszText, pStr->GetStr(), cchMax);
        }
        else if (cchMax >= 1)
        {
            pszText[0] = 0;
        }
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
// Frees an item in our autocomplete list
//--------------------------------------------------------------------------
int CAutoComplete::_DPADestroyCallback(LPVOID p, LPVOID d)
{
    ((CACString*)p)->Release();
    return 1;
}

//+-------------------------------------------------------------------------
// Frees our last completion list
//--------------------------------------------------------------------------
void CAutoComplete::_FreeDPAPtrs(HDPA hdpa)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_FreeDPAPtrs(hdpa = 0x%x)", hdpa);

    if (hdpa)
    {
        DPA_DestroyCallback(hdpa, _DPADestroyCallback, 0);
        hdpa = NULL;
    }
}

//+-------------------------------------------------------------------------
// DPA callback used to order the matches by the sort index
//--------------------------------------------------------------------------
int CALLBACK CAutoComplete::_DPACompareSortIndex(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    CACString* ps1 = (CACString*)p1;
    CACString* ps2 = (CACString*)p2;

    return ps1->CompareSortingIndex(*ps2);
}

//+-------------------------------------------------------------------------
// Updates the matching completion
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateCompletion
(
    LPCWSTR pszTyped,   // typed in string to match
    int iChanged,       // char added since last update or -1
    BOOL fAppend        // ok to append completion
)
{
    int iFirstMatch = -1;
    int iLastMatch = -1;
    int nChars = lstrlen(pszTyped);

    // Was it a wildcard search?
    BOOL fWildCard = pszTyped && (pszTyped[0] == CH_WILDCARD) && (pszTyped[1] == L'\0');
    if (fWildCard && DPA_GetPtrCount(m_hdpa))
    {
        // Everything matches
        iFirstMatch = 0;
        iLastMatch = DPA_GetPtrCount(m_hdpa) - 1;
    }
    else
    {
        // PERF: Special case where current == search string
    /*
        //
        // Find the first matching index
        //
        if (iChanged > 0)
        {
            // PERF: Get UC and LC versions of WC for compare below?
            WCHAR wc = pszTyped[iChanged];

            // A character was added so search from current location
            for (int i = m_iFirstMatch; i < DPA_GetPtrCount(m_hdpa); ++i)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, i);
                ASSERT(pStr);
                if (pStr && pStr->GetLength() >= iChanged && ChrCmpI((*pStr)[iChanged], wc) == 0)
                {
                    // This is the first match
                    iFirstMatch = i;
                    break;
                }
            }
        }
        else
    */
        {
            // We have to search the whole list
            // PERF: Switch to a binary search.
            for (int i = 0; i < DPA_GetPtrCount(m_hdpa); ++i)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, i);
                ASSERT(pStr);
                if (pStr &&
                    (pStr->StrCmpNI(pszTyped, nChars) == 0))
                {
                    iFirstMatch = i;
                    break;
                }
            }
        }

        if (-1 != iFirstMatch)
        {
            //
            // Find the last match
            //
            // PERF: Should we binary search up to the last end of list?
            for (iLastMatch = iFirstMatch; iLastMatch + 1 < DPA_GetPtrCount(m_hdpa); ++iLastMatch)
            {
                CACString* pStr;

                pStr = (CACString*)DPA_GetPtr(m_hdpa, iLastMatch + 1);
                ASSERT(pStr);
                if (NULL == pStr || (pStr->StrCmpNI(pszTyped, nChars) != 0))
                {
                    break;
                }
            }
        }
    }

    //
    // See if we should add "Search for <stuff typed in>" to the end of
    // the list.
    //
    int iSearchFor = 0;
    int nScheme;

    if (m_fSearchForAdded &&

        // Not a drive letter
        (*pszTyped && pszTyped[1] != L':') &&

        // Not a UNC path
        (pszTyped[0] != L'\\' && pszTyped[1] != L'\\') &&

        // Not a known scheme
        ((nScheme = GetUrlScheme(pszTyped)) == URL_SCHEME_UNKNOWN ||
        nScheme == URL_SCHEME_INVALID) &&

        // Ignore anything theat begins with "www"
        !(pszTyped[0] == L'w' && pszTyped[1] == L'w' && pszTyped[2] == L'w')

        // Not a search keyword
//        !Is
        )
    {
        // Add "Search for <stuff typed in>"
        iSearchFor = 1;
    }
    m_fSearchFor = iSearchFor;

    m_iLastMatch = iLastMatch + iSearchFor;
    m_iFirstMatch = iFirstMatch;
    if (iSearchFor && iFirstMatch == -1)
    {
        // There is one entry - the special "search for <>" entry
        m_iFirstMatch = 0;
    }

    // Sort the matches using the sort index
    if (m_hdpaSortIndex && iFirstMatch != -1)
    {
        // First put the matches in this sorted dpa
        DPA_GetPtrCount(m_hdpaSortIndex) = 0;
        for (int i=0; i <= m_iLastMatch-m_iFirstMatch; i++)
        {
            CACString *pStr = (CACString *)DPA_GetPtr(m_hdpa, m_iFirstMatch+i);
            DPA_InsertPtr(m_hdpaSortIndex, i, (LPVOID)pStr);
        }

        // Now order it by sort index (rather than alphabetically)
        DPA_Sort(m_hdpaSortIndex, _DPACompareSortIndex, 0);
    }

    if (_IsAutoSuggestEnabled())
    {
        // Update our drop-down list
        if ((m_iFirstMatch == -1) ||                // Hide if there are no matches
            ((m_iLastMatch == m_iFirstMatch) &&     // Or if only one match which we've already typed (IForms)
                (((CACString*)DPA_GetPtr(m_hdpa, m_iFirstMatch))->StrCmpI(pszTyped) == 0)))
        {
            _HideDropDown();
        }
        else
        {
            if (m_hwndList)
            {
                int cItems = m_iLastMatch - m_iFirstMatch + 1;
                ListView_SetItemCountEx(m_hwndList, cItems, 0);
            }

            _ShowDropDown();
            _UpdateScrollbar();
        }
    }

    if (_IsAutoAppendEnabled() && fAppend && m_iFirstMatch != -1 && !fWildCard)
    {
        // If caret is not at the end of the string, don't append
        DWORD dwSel = Edit_GetSel(m_hwndEdit);
        int iStartSel = LOWORD(dwSel);
        int iEndSel = HIWORD(dwSel);
        int iLen = lstrlen(pszTyped);
        if (iStartSel == iStartSel && iStartSel != iLen)
        {
            return;
        }

        // FEATURE: Should use the shortest match
        m_iAppended = -1;
        _AppendNext(TRUE);
    }
}

//+-------------------------------------------------------------------------
// Appends the next completion to the current edit text.  Returns TRUE if
// successful.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_AppendNext
(
    BOOL fAppendToWhack  // Apend to next whack (false = append entire match)
)
{
    // Nothing to complete?
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa) ||
        m_iFirstMatch == -1 || !_WantToAppendResults())
        return FALSE;

    //
    // If nothing currently appended, init to the
    // last item so that we will wrap around to the
    // first item
    //
    if (m_iAppended == -1)
    {
        m_iAppended = m_iLastMatch;
    }

    int iAppend = m_iAppended;
    CACString* pStr;

    //
    // Loop through the items until we find one without a prefix
    //
    do
    {
        if (++iAppend > m_iLastMatch)
        {
            iAppend = m_iFirstMatch;
        }
        pStr = (CACString*)DPA_GetPtr(m_hdpa, iAppend);
        if (pStr &&

            // Don't append if match has as www. prefix
            (pStr->PrefixLength() < 4 || StrCmpNI(pStr->GetStr() + pStr->PrefixLength() - 4, L"www.", 4) != 0) &&

            // Ignore the "Search for" if present
            !(m_fSearchFor && iAppend == m_iLastMatch))
        {
            // We found one so append it
            _Append(*pStr, fAppendToWhack);
            m_iAppended = iAppend;
        }
    }
    while (iAppend != m_iAppended);
    return TRUE;
}

//+-------------------------------------------------------------------------
// Appends the previous completion to the current edit text.  Returns TRUE
// if successful.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_AppendPrevious
(
    BOOL fAppendToWhack  // Append to next whack (false = append entire match)
)
{
    // Nothing to complete?
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa) ||
        m_iFirstMatch == -1 || !_WantToAppendResults())
        return FALSE;

    //
    // If nothing currently appended, init to the
    // first item so that we will wrap around to the
    // last item
    //
    if (m_iAppended == -1)
    {
        m_iAppended = m_iFirstMatch;
    }

    int iAppend = m_iAppended;
    CACString* pStr;

    //
    // Loop through the items until we find one without a prefix
    //
    do
    {
        if (--iAppend < m_iFirstMatch)
        {
            iAppend = m_iLastMatch;
        }
        pStr = (CACString*)DPA_GetPtr(m_hdpa, iAppend);
        if (pStr &&

            // Don't append if match has as www. prefix
            (pStr->PrefixLength() < 4 || StrCmpNI(pStr->GetStr() + pStr->PrefixLength() - 4, L"www.", 4) != 0) &&

            // Ignore the "Search for" if present
            !(m_fSearchFor && iAppend == m_iLastMatch))
        {
            // We found one so append it
            _Append(*pStr, fAppendToWhack);
            m_iAppended = iAppend;
        }
    }
    while (iAppend != m_iAppended);

    return TRUE;
}

//+-------------------------------------------------------------------------
// Appends the completion to the current edit text
//--------------------------------------------------------------------------
void CAutoComplete::_Append
(
    CACString& rStr,    // item to append to the editbox text
    BOOL fAppendToWhack  // Apend to next whack (false = append entire match)
)
{
    ASSERT(_IsAutoAppendEnabled());

    if (m_pszCurrent)
    {
        int cchCurrent = lstrlen(m_pszCurrent);
        LPCWSTR pszAppend = rStr.GetStrToCompare() + cchCurrent;
        int cchAppend;

        if (fAppendToWhack)
        {
            //
            // Advance to the whacks.
            //
            const WCHAR *pch = pszAppend;
            cchAppend = 0;

            while (*pch && !_IsWhack(*pch))
            {
                ++cchAppend;
                pch++;
            }

            //
            // Advance past the whacks.
            //
            while (*pch && _IsWhack(*pch))
            {
                ++cchAppend;
                pch++;
            }
        }
        else
        {
            // Append entire match
            cchAppend = lstrlen(pszAppend);
        }

        WCHAR szAppend[MAX_URL_STRING];
        StrCpyN(szAppend, pszAppend, cchAppend + 1);
        _UpdateText(cchCurrent, cchCurrent + cchAppend, m_pszCurrent, szAppend);

        m_fAppended = TRUE;
    }
}

//+-------------------------------------------------------------------------
// Hides the AutoSuggest dropdown
//--------------------------------------------------------------------------
void CAutoComplete::_HideDropDown()
{
    if (m_hwndDropDown)
    {
        ShowWindow(m_hwndDropDown, SW_HIDE);
    }
}

//+-------------------------------------------------------------------------
// Shows and positions the autocomplete dropdown
//--------------------------------------------------------------------------
void CAutoComplete::_ShowDropDown()
{
    if (m_hwndDropDown && !_IsComboboxDropped() && !m_fImeCandidateOpen)
    {
        // If the edit window is visible, it better have focus!
        // (Intelliforms uses an invisible window that doesn't
        // get focus.)
        if (IsWindowVisible(m_hwndEdit) && m_hwndEdit != GetFocus())
        {
            ShowWindow(m_hwndDropDown, SW_HIDE);
            return;
        }

        if (!IsWindowVisible(m_hwndDropDown))
        {
            // It should not be possible to open a new dropdown while
            // another dropdown is visible!  But to be safe we'll check ...
            if (s_hwndDropDown)
            {
                ASSERT(FALSE);
                ShowWindow(s_hwndDropDown, SW_HIDE);
            }

            s_hwndDropDown = m_hwndDropDown;

            //
            // Install a thread hook so that we can detect when something
            // happens that should hide the dropdown.
            //
            ENTERCRITICAL;
            if (s_hhookMouse)
            {
                // Should never happen because the hook is removed when the dropdown
                // is hidden.  But we can't afford to orphan a hook so we check just
                // in case!
                ASSERT(FALSE);
                UnhookWindowsHookEx(s_hhookMouse);
            }
            s_hhookMouse = SetWindowsHookEx(WH_MOUSE, s_MouseHook, HINST_THISDLL, NULL);
            LEAVECRITICAL;

            //
            // Subclass the parent windows so that we can detect when something
            // happens that should hide the dropdown
            //
            _SubClassParent(m_hwndEdit);
        }

        _PositionDropDown();
    }
}

//+-------------------------------------------------------------------------
// Positions dropdown based on edit window position
//--------------------------------------------------------------------------
void CAutoComplete::_PositionDropDown()
{
    RECT rcEdit;
    GetWindowRect(m_hwndEdit, &rcEdit);
    int x = rcEdit.left;
    int y = rcEdit.bottom;

    // Don't resize if user already has
    if (!m_fDropDownResized)
    {
#ifndef UNIX
        m_nDropHeight = 100;
#else
        m_nDropHeight = 150;
#endif
        MINMAXINFO mmi = {0};
        SendMessage(m_hwndDropDown, WM_GETMINMAXINFO, 0, (LPARAM)&mmi);
        m_nDropWidth = max(RECTWIDTH(rcEdit), mmi.ptMinTrackSize.x);

        // Calculate dropdown height based on number of string matches
        if (m_hdpa)
        {
/*
            int iDropDownHeight =
                    m_nStatusHeight +
                    ListView_GetItemSpacing(m_hwndList, FALSE) * DPA_GetPtrCount(m_hdpa);
*/

            int iDropDownHeight =
                    m_nStatusHeight - GetSystemMetrics(SM_CYBORDER) +
                    HIWORD(ListView_ApproximateViewRect(m_hwndList, -1, -1, -1));

            if (m_nDropHeight > iDropDownHeight)
            {
                m_nDropHeight = iDropDownHeight;
            }
        }
    }

    int w = m_nDropWidth;
    int h = m_nDropHeight;

    BOOL fDroppedUp = FALSE;

    //
    // Make sure we don't go off the screen
    //
    HMONITOR hMonitor = MonitorFromWindow(m_hwndEdit, MONITOR_DEFAULTTONEAREST);
    if (hMonitor)
    {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (GetMonitorInfo(hMonitor, &mi))
        {
            RECT rcMon = mi.rcMonitor;
            int cxMax = rcMon.right - rcMon.left;
            if (w > cxMax)
            {
                w = cxMax;
            }

/*
            if (x < rcMon.left)
            {
                // Off the left edge, so move right
                x += rcMon.left - x;
            }
            else if (x + w > rcMon.right)
            {
                // Off the right edge, so move left
                x -= (x + w - rcMon.right);
            }
*/
            int cyMax = (RECTHEIGHT(rcMon) - RECTHEIGHT(rcEdit));
            if (h > cyMax)
            {
                h = cyMax;
            }

            if (y + h > rcMon.bottom

#ifdef ALLOW_ALWAYS_DROP_UP
                || m_fAlwaysDropUp
#endif

                )
            {
                // Off the bottom of the screen, so see if there is more
                // room in the up direction
                if (rcEdit.top > rcMon.bottom - rcEdit.bottom)
                {
                    // There's more room to pop up
                    y = max(rcEdit.top - h, 0);
                    h = rcEdit.top - y;
                    fDroppedUp = TRUE;
                }
                else
                {
                    // Don't let it go past the bottom
                    h = rcMon.bottom - y;
                }
            }
        }
    }

    BOOL fFlipped = BOOLIFY(m_fDroppedUp) ^ BOOLIFY(fDroppedUp);
    m_fDroppedUp = fDroppedUp;

    SetWindowPos(m_hwndDropDown, HWND_TOP, x, y, w, h, SWP_SHOWWINDOW | SWP_NOACTIVATE);

    if (fFlipped)
    {
        _UpdateGrip();
    }
}

//+-------------------------------------------------------------------------
// Window procedure for the subclassed edit box
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_EditWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_SETTEXT:
        //
        // If the text is changed programmatically, we hide the dropdown.
        // This fixed a bug in the dialog at:
        //
        // Internet Options\security\Local Intranet\Sites\Advanced
        //
        //   - If you select something in the dropdown the press enter,
        //     the enter key is intercepeted by the dialog which clears
        //     the edit field, but the drop-down is not hidden.
        //
        if (!m_fSettingText)
        {
            _HideDropDown();
        }
        break;

    case WM_GETDLGCODE:
        {
            //
            // If the auto-suggest drop-down if up, we process
            // the tab key.
            //
            BOOL fDropDownVisible = m_hwndDropDown && IsWindowVisible(m_hwndDropDown);

            if (wParam == VK_TAB && IsFlagSet(m_dwOptions, ACO_USETAB))
            {
#ifndef UNIX
                if ((GetKeyState(VK_CONTROL) < 0) ||
                    !fDropDownVisible)
                {
                    break;
                }

#else
                //
                // On unix, an unmodified tab key is processed even if autosuggest
                // is not visible.
                //

                if ((GetKeyState(VK_CONTROL) < 0) ||
                    ((GetKeyState(VK_SHIFT) < 0) && !fDropDownVisible))
                {
                    break;
                }

                if (!fDropDownVisible)
                {
                    //
                    // Make tab key autocomplete key if at end of edit control
                    //
                    UINT cchTotal = SendMessage(m_hwndEdit, EM_LINELENGTH, 0, 0L);
                    DWORD ichMinSel;
                    SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM) &ichMinSel, 0L);

                    if (ichMinSel == cchTotal)
                    {
                        break;
                    }
                }
#endif  // UNIX

                // We want the tab key
                return DLGC_WANTTAB;
            }
            else if (wParam == VK_ESCAPE && fDropDownVisible)
            {
                // eat escape so that dialog boxes (e.g. File Open) are not closed
                return DLGC_WANTALLKEYS;
            }
            break;
        }

    case WM_KEYDOWN:
        if (wParam == VK_TAB)
        {
            BOOL fDropDownVisible = m_hwndDropDown && IsWindowVisible(m_hwndDropDown);
#ifdef UNIX
            if (!fDropDownVisible &&
                (GetKeyState(VK_CONTROL) >= 0) &&
                (GetKeyState(VK_SHIFT) >= 0)
               )
            {
                wParam = VK_END;
            }
            else
#endif
            if (fDropDownVisible &&
                GetKeyState(VK_CONTROL) >= 0)
            {
                // Map tab to down-arrow and shift-tab to up-arrow
                wParam = (GetKeyState(VK_SHIFT) >= 0) ? VK_DOWN : VK_UP;
            }
            else
            {
                return 0;
            }
        }

        // Ensure the background thread knows we have focus
        _GotFocus();

//            ASSERT(m_hThread || m_pThread->IsDisabled());  // If this occurs then we didn't process a WM_SETFOCUS when we should have.  BryanSt.
        if (_OnKeyDown(wParam) == 0)
        {
            //
            // We handled it.
            //
            return 0;
        }

        if (wParam == VK_DELETE)
        {
            LRESULT lRes = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);
            _StartCompletion(FALSE);
            return lRes;
        }
        break;

    case WM_CHAR:
        return _OnChar(wParam, lParam);

    case WM_CUT:
    case WM_PASTE:
    case WM_CLEAR:
    {
        LRESULT lRet = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);

        // See if we need to update the completion
        if (!m_pThread->IsDisabled())
        {
            _GotFocus();
            _StartCompletion(TRUE);
        }
        return lRet;
    }
    case WM_SETFOCUS:
        m_pThread->GotFocus();
        break;

    case WM_KILLFOCUS:
        {
            HWND hwndGetFocus = (HWND)wParam;

            // Ignore focus change to ourselves
            if (m_hwndEdit != hwndGetFocus)
            {
                if (m_hwndDropDown && GetFocus() != m_hwndDropDown)
                {
                    _HideDropDown();
                }
                m_pThread->LostFocus();
            }
            break;
        }
    case WM_DESTROY:
        {
            HWND hwndEdit = m_hwndEdit;
            TraceMsg(AC_GENERAL, "CAutoComplete::_WndProc(WM_DESTROY) releasing subclass.");

            RemoveWindowSubclass(hwndEdit, s_EditWndProc, 0);

            if (m_hwndDropDown)
            {
                //
                // If the dropdown and its associated listview are fully created, we can simply
                // destroy them.
                //
                if (m_hwndList)
                {
                    DestroyWindow(m_hwndDropDown);
                }

                //
                // We are likely in the middle of creating the listview and destroy the dropdown now
                // can result in a crash (another thread probably destroyed the edit window).  So we
                // post a message to get the dropdown to destroy itself.  The background thread will
                // hold this dll in memory until the dropdown is gone.
                //
                else
                {
                    // Don't call DestroyWindow. See AM_DESTROY comment in dropdown's wndproc.
                    _GotFocus();
                    if (m_pThread->HasFocus())
                    {
                        PostMessage(m_hwndDropDown, AM_DESTROY, 0, 0);
                    }
                    else
                    {
                        // If the background thread is not running, we can't rely on it to
                        // keep us in memory during shutdown, so synchronously destroy the
                        // window and cross your fingers.
                        DestroyWindow(m_hwndDropDown);
                    }
                }
            }

            m_pThread->SyncShutDownBGThread();
            SAFERELEASE(m_pThread);
            Release();      // Release subclass Ref.

            // Pass it onto the old wndproc.
            return DefSubclassProc(hwndEdit, uMsg, wParam, lParam);
        }
        break;
    case WM_MOVE:
        {
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                // Follow edit window, for example when intelliforms window scrolls w/intellimouse
                _PositionDropDown();
            }
        }
        break;

/*
    case WM_COMMAND:
        if (m_pThread->IsDisabled())
        {
            break;
        }
        return _OnCommand(wParam, lParam);
*/
/*
    case WM_CONTEXTMENU:
        if (m_pThread->IsDisabled())
        {
            break;
        }
        return _ContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
*/

#ifndef UNIX
    case WM_LBUTTONDBLCLK:
    {
        //
        // Bypass our word break routine.  We only register this callback on NT because it
        // doesn't work right on win9x.
        //
        if (m_fEditControlUnicode)
        {
            //
            // We break words at url delimiters for ctrl-left & ctrl-right, but
            // we want double-click to use standard word selection so that it is easy
            // to select the URL.
            //
            SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)m_oldEditWordBreakProc);

            LRESULT lres = DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);

            // Restore our word-break callback
            SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)EditWordBreakProcW);
            return lres;
        }
        break;
    }
#endif // !UNIX

    case WM_SETFONT:
    {
        // If we have a dropdown, recreate it with the latest font
        m_hfontListView = (HFONT)wParam;
        if (m_hwndDropDown)
        {
            _StopSearch();
            DestroyWindow(m_hwndDropDown);
            m_hwndDropDown = NULL;
            _SeeWhatsEnabled();
        }
        break;
    }
    case WM_IME_NOTIFY:
        {
            // We don't want autocomplete to obsure the IME candidate window
            DWORD dwCommand = (DWORD)wParam;
            if (dwCommand == IMN_OPENCANDIDATE)
            {
                m_fImeCandidateOpen = TRUE;
                _HideDropDown();
            }
            else if (dwCommand == IMN_CLOSECANDIDATE)
            {
                m_fImeCandidateOpen = FALSE;
            }
        }
        break;
    default:
        // Handle registered messages
        if (uMsg == m_uMsgSearchComplete)
        {
            _OnSearchComplete((HDPA)lParam, (BOOL)wParam);
            return 0;
        }

        // Pass mouse wheel messages to the drop-down if it is visible
        else if ((uMsg == WM_MOUSEWHEEL || uMsg == g_msgMSWheel) &&
            m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
        {
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            return 0;
        }
        break;
    }


    return DefSubclassProc(m_hwndEdit, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Static window procedure for the subclassed edit box
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_EditWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CAutoComplete
)
{
    CAutoComplete* pac = (CAutoComplete*)dwRefData;
    if (pac)
    {
        ASSERT(pac->m_hwndEdit == hwnd);
        return pac->_EditWndProc(uMsg, wParam, lParam);
    }
    else
    {
        TraceMsg(TF_WARNING, "CAutoComplete::s_EditWndProc() --- pac == NULL");
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// Draws the sizing grip. We do this ourselves rather than call
// DrawFrameControl because the standard API does not flip upside down on
// all platforms.  (NT and win98 seem to use a font and thus ignore the map
// mode)
//--------------------------------------------------------------------------
BOOL DrawGrip(register HDC hdc, LPRECT lprc, BOOL fEraseBackground)
{
    int x, y;
    int xMax, yMax;
    int dMin;
    HBRUSH hbrOld;
    HPEN hpen, hpenOld;
    DWORD rgbHilight, rgbShadow;

    //
    // The grip is really a pattern of 4 repeating diagonal lines:
    //      One glare
    //      Two raised
    //      One empty
    // These lines run from bottom left to top right, in the bottom right
    // corner of the square given by (lprc->left, lprc->top, dMin by dMin.
    //
    dMin = min(lprc->right-lprc->left, lprc->bottom-lprc->top);
    xMax = lprc->left + dMin;
    yMax = lprc->top + dMin;

    //
    // Setup colors
    //
    hbrOld      = GetSysColorBrush(COLOR_3DFACE);
    rgbHilight  = GetSysColor(COLOR_3DHILIGHT);
    rgbShadow   = GetSysColor(COLOR_3DSHADOW);

    //
    // Fill in background of ENTIRE rect
    //
    if (fEraseBackground)
    {
        hbrOld = SelectBrush(hdc, hbrOld);
        PatBlt(hdc, lprc->left, lprc->top, lprc->right-lprc->left,
                lprc->bottom-lprc->top, PATCOPY);
        SelectBrush(hdc, hbrOld);
    }
    else
    {
/*
        hpen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOW));
        if (hpen == NULL)
            return FALSE;
        hpenOld = SelectPen(hdc, hpen);

        x = lprc->left - 1;
        y = lprc->top - 1;
        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        SelectPen(hdc, hpenOld);
        DeletePen(hpen);
*/

        //
        // Draw background color directly under grip:
        //
        hpen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
        if (hpen == NULL)
            return FALSE;
        hpenOld = SelectPen(hdc, hpen);

        x = lprc->left + 3;
        y = lprc->top + 3;
        while (x < xMax)
        {
            //
            // Since dMin is the same horz and vert, x < xMax and y < yMax
            // are interchangeable...
            //
            MoveToEx(hdc, x, yMax, NULL);
            LineTo(hdc, xMax, y);

            // Skip 3 lines in between
            x += 4;
            y += 4;
        }

        SelectPen(hdc, hpenOld);
        DeletePen(hpen);
    }

    //
    // Draw glare with COLOR_3DHILIGHT:
    //      Create proper pen
    //      Select into hdc
    //      Starting at lprc->left, draw a diagonal line then skip the
    //          next 3
    //      Select out of hdc
    //
    hpen = CreatePen(PS_SOLID, 1, rgbHilight);
    if (hpen == NULL)
        return FALSE;
    hpenOld = SelectPen(hdc, hpen);

    x = lprc->left;
    y = lprc->top;
    while (x < xMax)
    {
        //
        // Since dMin is the same horz and vert, x < xMax and y < yMax
        // are interchangeable...
        //

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        // Skip 3 lines in between
        x += 4;
        y += 4;
    }

    SelectPen(hdc, hpenOld);
    DeletePen(hpen);

    //
    // Draw raised part with COLOR_3DSHADOW:
    //      Create proper pen
    //      Select into hdc
    //      Starting at lprc->left+1, draw 2 diagonal lines, then skip
    //          the next 2
    //      Select outof hdc
    //
    hpen = CreatePen(PS_SOLID, 1, rgbShadow);
    if (hpen == NULL)
        return FALSE;
    hpenOld = SelectPen(hdc, hpen);

    x = lprc->left+1;
    y = lprc->top+1;
    while (x < xMax)
    {
        //
        // Draw two diagonal lines touching each other.
        //

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        x++;
        y++;

        MoveToEx(hdc, x, yMax, NULL);
        LineTo(hdc, xMax, y);

        //
        // Skip 2 lines inbetween
        //
        x += 3;
        y += 3;
    }

    SelectPen(hdc, hpenOld);
    DeletePen(hpen);

    return TRUE;
}

//+-------------------------------------------------------------------------
// Update the visible characteristics of the gripper depending on whether
// the dropdown is "dropped up" or the scrollbar is visible
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateGrip()
{
    if (m_hwndGrip)
    {
        //
        // If we have a scrollbar the gripper has a rectangular shape.
        //
        if (m_hwndScroll && IsWindowVisible(m_hwndScroll))
        {
            SetWindowRgn(m_hwndGrip, NULL, FALSE);
        }
        //
        // Otherwise, give it  a trinagular window region
        //
        else
        {
            int nWidth = GetSystemMetrics(SM_CXVSCROLL);
            int nHeight = GetSystemMetrics(SM_CYHSCROLL);
            POINT rgpt[3] =
            {
                {nWidth, 0},
                {nWidth, nHeight},
                {0, nHeight},
            };

            //
            // If dropped up, convert the "bottom-Right" tringle into
            // a "top-right" triangle
            //
            if (m_fDroppedUp)
            {
                rgpt[2].y = 0;
            }

            HRGN hrgn = CreatePolygonRgn(rgpt, ARRAYSIZE(rgpt), WINDING);
            if (hrgn && !SetWindowRgn(m_hwndGrip, hrgn, TRUE))
                DeleteObject(hrgn);
        }
        InvalidateRect(m_hwndGrip, NULL, TRUE);
    }
}

//+-------------------------------------------------------------------------
// Transfer the listview scroll info into our scrollbar control
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateScrollbar()
{
    if (m_hwndScroll)
    {
        SCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SIF_ALL;
        BOOL fScrollVisible = IsWindowVisible(m_hwndScroll);

        if (GetScrollInfo(m_hwndList, SB_VERT, &si))
        {
            SetScrollInfo(m_hwndScroll, SB_CTL, &si, TRUE);
            UINT nRange = si.nMax - si.nMin;
            BOOL fShow = (nRange != 0) && (nRange != (UINT)(si.nPage - 1));
            ShowScrollBar(m_hwndScroll, SB_CTL, fShow);
            if (BOOLIFY(fScrollVisible) ^ BOOLIFY(fShow))
            {
                _UpdateGrip();
            }
        }
    }
}

//+-------------------------------------------------------------------------
// Window procedure for the AutoSuggest drop-down
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_DropDownWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_NCCREATE:
        {
            //
            // Add a listview to the dropdown
            //
            m_hwndList = CreateWindowEx(0,
                                        WC_LISTVIEW,
                                        c_szAutoSuggestTitle,
                                        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SINGLESEL | LVS_OWNERDATA | LVS_OWNERDRAWFIXED,
                                        0, 0, 30000, 30000,
                                        m_hwndDropDown, NULL, HINST_THISDLL, NULL);

            if (m_hwndList)
            {
                SetWindowTheme(m_hwndList, L"AutoComplete", NULL);

                // Subclass the listview window
                if (SetProp(m_hwndList, c_szAutoCompleteProp, this))
                {
                    // point it to our wndproc and save the old one
                    m_pOldListViewWndProc = (WNDPROC)SetWindowLongPtr(m_hwndList, GWLP_WNDPROC, (LONG_PTR) &s_ListViewWndProc);
                }

                ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TRACKSELECT);

                LV_COLUMN lvColumn;
                lvColumn.mask = LVCF_FMT | LVCF_WIDTH;
                lvColumn.fmt = LVCFMT_LEFT;
                lvColumn.cx = LISTVIEW_COLUMN_WIDTH;
                ListView_InsertColumn(m_hwndList, 0, &lvColumn);

                // We'll get the default dimensions when we first show it
                m_nDropWidth = 0;
                m_nDropHeight = 0;

                // Add a scrollbar
                m_hwndScroll = CreateWindowEx(0, WC_SCROLLBAR, NULL,
                                WS_CHILD | SBS_VERT | SBS_RIGHTALIGN,
                                0, 0, 20, 100, m_hwndDropDown, 0, HINST_THISDLL, NULL);

                SetWindowTheme(m_hwndScroll, L"AutoComplete", NULL);

                // Add a sizebox
                m_hwndGrip = CreateWindowEx(0, WC_SCROLLBAR, NULL,
                                WS_CHILD | WS_VISIBLE | SBS_SIZEBOX | SBS_SIZEBOXBOTTOMRIGHTALIGN,
                                0, 0, 20, 100, m_hwndDropDown, 0, HINST_THISDLL, NULL);
                if (m_hwndGrip)
                {
                    SetWindowSubclass(m_hwndGrip, s_GripperWndProc, 0, (ULONG_PTR)this);
                    _UpdateGrip();

                    SetWindowTheme(m_hwndGrip, L"AutoComplete", NULL);
                }
            }
            return (m_hwndList != NULL);
        }
        case WM_DESTROY:
        {
            //
            // I'm paranoid - should happen when we're hidden
            //
            if (s_hwndDropDown != NULL && s_hwndDropDown == m_hwndDropDown)
            {
                // Should never happen, but we take extra care not to leak a window hook!
                ASSERT(FALSE);

                ENTERCRITICAL;
                if (s_hhookMouse)
                {
                    UnhookWindowsHookEx(s_hhookMouse);
                    s_hhookMouse = NULL;
                }
                LEAVECRITICAL;
                s_hwndDropDown = NULL;
            }
            _UnSubClassParent(m_hwndEdit);

            // Unsubclass this window
            SetWindowLongPtr(m_hwndDropDown, GWLP_USERDATA, (LONG_PTR)NULL);

            HWND hwnd = m_hwndDropDown;
            m_hwndDropDown = NULL;

            if (m_hwndList)
            {
                DestroyWindow(m_hwndList);
                m_hwndList = NULL;
            }
            if (m_hwndScroll)
            {
                DestroyWindow(m_hwndScroll);
                m_hwndScroll = NULL;
            }
            if (m_hwndGrip)
            {
                DestroyWindow(m_hwndGrip);
                m_hwndGrip = NULL;
            }

            // The dropdown incremented the autocomplete object's ref count.
            Release();
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        }
        case WM_SYSCOLORCHANGE:
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            break;

        case WM_WININICHANGE:
            SendMessage(m_hwndList, uMsg, wParam, lParam);
            if (wParam == SPI_SETNONCLIENTMETRICS)
            {
                _UpdateGrip();
            }
            break;

        case WM_GETMINMAXINFO:
        {
            //
            // Don't shrink smaller than the size of the gripper
            //
            LPMINMAXINFO pMmi = (LPMINMAXINFO)lParam;

            pMmi->ptMinTrackSize.x = GetSystemMetrics(SM_CXVSCROLL);
            pMmi->ptMinTrackSize.y = GetSystemMetrics(SM_CYHSCROLL);
            return 0;
        }
        case WM_MOVE:
        {
            //
            // Reposition the list view in case we switch between dropping-down
            // and dropping up.
            //
            RECT rc;
            GetClientRect(m_hwndDropDown, &rc);
            int nWidth = RECTWIDTH(rc);
            int nHeight = RECTHEIGHT(rc);

            int cxGrip = GetSystemMetrics(SM_CXVSCROLL);
            int cyGrip = GetSystemMetrics(SM_CYHSCROLL);

            if (m_fDroppedUp)
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, 0, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, cyGrip, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            else
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, nHeight - cyGrip, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, 0, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            break;
        }
        case WM_SIZE:
        {
            int nWidth  = LOWORD(lParam);
            int nHeight = HIWORD(lParam);

            int cxGrip = GetSystemMetrics(SM_CXVSCROLL);
            int cyGrip = GetSystemMetrics(SM_CYHSCROLL);

            if (m_fDroppedUp)
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, 0, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, cyGrip, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }
            else
            {
                SetWindowPos(m_hwndGrip, HWND_TOP, nWidth - cxGrip, nHeight - cyGrip, cxGrip, cyGrip, SWP_NOACTIVATE);
                SetWindowPos(m_hwndScroll, HWND_TOP, nWidth - cxGrip, 0, cxGrip, nHeight-cyGrip, SWP_NOACTIVATE);
            }

            // Save the new dimensions
            m_nDropWidth = nWidth + 2*GetSystemMetrics(SM_CXBORDER);
            m_nDropHeight = nHeight + 2*GetSystemMetrics(SM_CYBORDER);

            MoveWindow(m_hwndList, 0, 0, LISTVIEW_COLUMN_WIDTH + 10*cxGrip, nHeight, TRUE);
            _UpdateScrollbar();
            InvalidateRect(m_hwndList, NULL, FALSE);
            break;
        }

        case WM_NCHITTEST:
            {
                RECT rc;
                POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

                // If the in the grip, show the sizing cursor
                if (m_hwndGrip)
                {
                    GetWindowRect(m_hwndGrip, &rc);

                    if (PtInRect(&rc, pt))
                    {
                        if(IS_WINDOW_RTL_MIRRORED(m_hwndDropDown))
                        {
                            return (m_fDroppedUp) ? HTTOPLEFT : HTBOTTOMLEFT;
                        }
                        else
                        {
                            return (m_fDroppedUp) ? HTTOPRIGHT : HTBOTTOMRIGHT;
                        }
                    }
                }
            }
            break;

        case WM_SHOWWINDOW:
            {
                s_fNoActivate = FALSE;

                BOOL fShow = (BOOL)wParam;
                if (!fShow)
                {
                    //
                    // We are being hidden so we no longer need to
                    // subclass the parent windows.
                    //
                    _UnSubClassParent(m_hwndEdit);

                    //
                    // Remove the mouse hook.  We shouldn't need to protect this global with
                    // a critical section because another dropdown cannot be shown
                    // before we are hidden.  But we don't want to chance orphaning a hook
                    // so to be safe we protect write access to this variable.
                    //
                    ENTERCRITICAL;
                    if (s_hhookMouse)
                    {
                        UnhookWindowsHookEx(s_hhookMouse);
                        s_hhookMouse = NULL;
                    }
                    LEAVECRITICAL;

                    s_hwndDropDown = NULL;

                    // Deselect the current selection
                    int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                    if (iCurSel)
                    {
                        ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
                    }
                }
            }
            break;

        case WM_MOUSEACTIVATE:
            //
            // We don't want mouse clicks to activate us and
            // take focus from the edit box.
            //
            return (LRESULT)MA_NOACTIVATE;

        case WM_NCLBUTTONDOWN:
            //
            // We don't want resizing to activate us and deactivate the app.
            // The WM_MOUSEACTIVATE message above prevents mouse downs from
            // activating us, but mouse up after a resize still activates us.
            //
            if (wParam == HTBOTTOMRIGHT ||
                wParam == HTTOPRIGHT)
            {
                s_fNoActivate = TRUE;
            }
            break;

        case WM_VSCROLL:
        {
            ASSERT(m_hwndScroll);

            //
            // Pass the scroll messages from our control to the listview
            //
            WORD nScrollCode = LOWORD(wParam);
            if (nScrollCode == SB_THUMBTRACK || nScrollCode == SB_THUMBPOSITION)
            {
                //
                // The listview ignores the 16-bit position passed in and
                // queries the internal window scrollbar for the tracking
                // position.  Since this returns the wrong track position,
                // we have to handle thumb tracking ourselves.
                //
                WORD nPos = HIWORD(wParam);

                SCROLLINFO si;
                si.cbSize = sizeof(si);
                si.fMask = SIF_ALL;

                if (GetScrollInfo(m_hwndScroll, SB_CTL, &si))
                {
                    //
                    // The track position is always at the top of the list.
                    // So, if we are scrolling up, make sure that the track
                    // position is visible.  Otherwise we need to ensure
                    // that a full page is visible below the track positon.
                    //
                    int nEnsureVisible = si.nTrackPos;
                    if (si.nTrackPos > si.nPos)
                    {
                        nEnsureVisible += si.nPage - 1;
                    }
                    SendMessage(m_hwndList, LVM_ENSUREVISIBLE, nEnsureVisible, FALSE);
                }
            }
            else
            {
                // Let listview handle it
                SendMessage(m_hwndList, uMsg, wParam, lParam);
            }
            _UpdateScrollbar();
            return 0;
        }
        case WM_EXITSIZEMOVE:
            //
            // Resize operation is over so permit the app to lose acitvation
            //
            s_fNoActivate = FALSE;
            m_fDropDownResized = TRUE;
            return 0;

        case WM_DRAWITEM:
            _DropDownDrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_NOTIFY:
            if (_DropDownNotify((LPNMHDR)lParam))
            {
                return TRUE;
            }
            break;

        case AM_UPDATESCROLLPOS:
        {
            if (m_hwndScroll)
            {
                int nTop = ListView_GetTopIndex(m_hwndList);
                SetScrollPos(m_hwndScroll, SB_CTL, nTop, TRUE);
            }
            return 0;
        }
        case AM_BUTTONCLICK:
        {
            //
            // This message is sent by the thread hook when a mouse click is detected outside
            // the drop-down window.  Unless the click occurred inside the combobox, we will
            // hide the dropdown.
            //
            MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT*)lParam;
            HWND hwnd = pmhs->hwnd;
            RECT rc;

            if (hwnd != m_hwndCombo && hwnd != m_hwndEdit &&

                // See if we clicked within the bounds of the editbox.  This is
                // necessary for intelliforms.
                // FEATURE: This assumes that the editbox is entirely visible!
                GetWindowRect(m_hwndEdit, &rc) && !PtInRect(&rc, pmhs->pt))
            {
                _HideDropDown();
            }
            return 0;
        }
        case AM_DESTROY:
        {
            //
            // We post this message to destroy the dropdown to avoid a strange crash
            // that happens if we call DestroyWindow when the edit window is destroyed.
            // The crash happens when a parent of the endit window is on another thread
            // and that parent is destroyed in the middle of us creating a listview
            // child of the dropdown.
            //
            DestroyWindow(m_hwndDropDown);
            return 0;
        }
    }

    return DefWindowProcWrap(m_hwndDropDown, uMsg, wParam, lParam);
}


void CAutoComplete::_DropDownDrawItem(LPDRAWITEMSTRUCT pdis)
{
    //
    // We need to draw the contents of the list view ourselves
    // so that we can show items in the selected state even
    // when the edit control has focus.
    //

    if (pdis->itemID != -1)
    {
        HDC hdc = pdis->hDC;
        RECT rc = pdis->rcItem;
        BOOL fTextHighlight = pdis->itemState & ODS_SELECTED;

        // Setup the dc before we use it.
        BOOL fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
        UINT uiOldTextAlign;
        if (fRTLReading)
        {
            uiOldTextAlign = GetTextAlign(hdc);
            SetTextAlign(hdc, uiOldTextAlign | TA_RTLREADING);
        }

        if (m_hfontListView)
        {
            SelectObject(hdc, m_hfontListView);
        }
        SetBkColor(hdc, GetSysColor(fTextHighlight ?
                        COLOR_HIGHLIGHT : COLOR_WINDOW));
        SetTextColor(hdc, GetSysColor(fTextHighlight ?
                        COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

        // Center the string vertically within rc
        SIZE sizeText;
        WCHAR szText[MAX_URL_STRING];
        _GetItem(pdis->itemID, szText, ARRAYSIZE(szText), TRUE);
        int cch = lstrlen(szText);
        GetTextExtentPoint(hdc, szText, cch, &sizeText);
        int yMid = (rc.top + rc.bottom) / 2;
        int yString = yMid - (sizeText.cy/2);
        int xString = 5;

        //
        // If this is a .url string, don't display the extension
        //
        if (cch > 4 && StrCmpNI(szText + cch - 4, L".url", 4) == 0)
        {
            cch -= 4;
        }

        ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, cch, NULL);

        // Restore the text align in the dc.
        if (fRTLReading)
        {
            SetTextAlign(hdc, uiOldTextAlign);
        }
    }
}

BOOL CAutoComplete::_DropDownNotify(LPNMHDR pnmhdr)
{
    WCHAR szBuf[MAX_URL_STRING];        // Just one instance of the buffer

    //
    // Respond to notification messages from the list view
    //
    switch (pnmhdr->code)
    {
        case LVN_GETDISPINFO:
        {
            //
            // Return the text for an autosuggest item
            //
            ASSERT(pnmhdr->hwndFrom == m_hwndList);
            LV_DISPINFO* pdi = (LV_DISPINFO*)pnmhdr;
            if (pdi->item.mask & LVIF_TEXT)
            {
                _GetItem(pdi->item.iItem, pdi->item.pszText, pdi->item.cchTextMax, TRUE);
            }
            break;
        }
        case LVN_GETDISPINFOA:
        {
            //
            // For win9x support (added for automated testing)
            //
            ASSERT(pnmhdr->hwndFrom == m_hwndList);
            LV_DISPINFOA* pdi = (LV_DISPINFOA*)pnmhdr;
            if (pdi->item.mask & LVIF_TEXT)
            {
                _GetItem(pdi->item.iItem, szBuf, ARRAYSIZE(szBuf), TRUE);
                SHUnicodeToAnsi(szBuf, pdi->item.pszText, pdi->item.cchTextMax);
            }
            break;
        }
        case LVN_ITEMCHANGED:
        {
            //
            // When an item is selected in the list view, we transfer it to the
            // edit control.  But only if the selection was not caused by the
            // mouse passing over an element (hot tracking).
            //
            if (!m_fInHotTracking)
            {
                LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pnmhdr;
                if ((pnmv->uChanged & LVIF_STATE) && (pnmv->uNewState & (LVIS_FOCUSED | LVIS_SELECTED)))
                {
                    _GetItem(pnmv->iItem, szBuf, ARRAYSIZE(szBuf), FALSE);

                    // Copy the selection to the edit box and place caret at the end
                    _SetEditText(szBuf);
                    int cch = lstrlen(szBuf);
                    Edit_SetSel(m_hwndEdit, cch, cch);
                }
            }

            //
            // Update the scrollbar.  Note that we have to post a message to do this
            // after returning from this function.  Otherwise we get old info
            // from the listview about the scroll positon.
            //
            PostMessage(m_hwndDropDown, AM_UPDATESCROLLPOS, 0, 0);
            break;
        }
        case LVN_ITEMACTIVATE:
        {
            //
            // Someone activated an item in the listview. We want to make sure that
            // the items is selected (without hot tracking) so that the contents
            // are moved to the edit box, and then simulate and enter key press.
            //

            LPNMITEMACTIVATE lpnmia = (LPNMITEMACTIVATE)pnmhdr;
            _GetItem(lpnmia->iItem, szBuf, ARRAYSIZE(szBuf), FALSE);

            // Copy the selection to the edit box and place caret at the end
            _SetEditText(szBuf);
            int cch = lstrlen(szBuf);
            Edit_SetSel(m_hwndEdit, cch, cch);

            //
            // Intelliforms don't want an enter key because this would submit the
            // form, so first we try sending a notification.
            //
            if (SendMessage(m_hwndEdit, m_uMsgItemActivate, 0, (LPARAM)szBuf) == 0)
            {
                // Not an intelliform, so simulate an enter key instead.
                SendMessage(m_hwndEdit, WM_KEYDOWN, VK_RETURN, 0);
                SendMessage(m_hwndEdit, WM_KEYUP, VK_RETURN, 0);
            }
            _HideDropDown();
            break;
        }
        case LVN_HOTTRACK:
        {
            //
            // Select items as we mouse-over them
            //
            LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW)pnmhdr;
            LVHITTESTINFO lvh;
            lvh.pt = lpnmlv->ptAction;
            int iItem = ListView_HitTest(m_hwndList, &lvh);
            if (iItem != -1)
            {
                // Update the current selection. The m_fInHotTracking flag prevents the
                // edit box contents from being updated
                m_fInHotTracking = TRUE;
                ListView_SetItemState(m_hwndList, iItem, LVIS_SELECTED|LVIS_FOCUSED, 0x000f);
                SendMessage(m_hwndList, LVM_ENSUREVISIBLE, iItem, FALSE);
                m_fInHotTracking = FALSE;
            }

            // We processed this...
            return TRUE;
        }
    }
    return FALSE;
}


//+-------------------------------------------------------------------------
// Static window procedure for the AutoSuggest drop-down
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_DropDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoComplete* pThis;
    if (uMsg == WM_NCCREATE)
    {
        pThis = (CAutoComplete*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pThis);
        pThis->m_hwndDropDown = hwnd;
    }
    else
    {
        pThis = (CAutoComplete*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pThis && (pThis->m_hwndDropDown == hwnd))
    {
        return pThis->_DropDownWndProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// We subclass the listview to prevent it from activating the drop-down
// when someone clicks on it.
//--------------------------------------------------------------------------
LRESULT CAutoComplete::_ListViewWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;
    switch (uMsg)
    {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
        case WM_MBUTTONUP:
            //
            // Prevent mouse clicks from activating this view
            //
            s_fNoActivate = TRUE;
            lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
            s_fNoActivate = FALSE;
            return 0;

        case WM_DESTROY:
            // Restore old wndproc.
            RemoveProp(m_hwndList, c_szAutoCompleteProp);
            if (m_pOldListViewWndProc)
            {
                SetWindowLongPtr(m_hwndList, GWLP_WNDPROC, (LONG_PTR) m_pOldListViewWndProc);
                lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
                m_pOldListViewWndProc = NULL;
            }
            return 0;

        case WM_GETOBJECT:
            if (lParam == OBJID_CLIENT)
            {
                SAFERELEASE(m_pDelegateAccObj);

                if (SUCCEEDED(CreateStdAccessibleObject(m_hwndList,
                                                        OBJID_CLIENT,
                                                        IID_IAccessible,
                                                        (void **)&m_pDelegateAccObj)))
                {
                    return LresultFromObject(IID_IAccessible, wParam, SAFECAST(this, IAccessible *));
                }
            }
            break;

        case WM_NCHITTEST:
        {
            RECT rc;
            POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

            // If in the grip area, let our parent handle it
            if (m_hwndGrip)
            {
                GetWindowRect(m_hwndGrip, &rc);

                if (PtInRect(&rc, pt))
                {
                    return HTTRANSPARENT;
                }
            }
            break;
        }
    }
    lRet = CallWindowProc(m_pOldListViewWndProc, m_hwndList, uMsg, wParam, lParam);
    return lRet;
}

//+-------------------------------------------------------------------------
// Static window procedure for the subclassed listview
//--------------------------------------------------------------------------
LRESULT CAutoComplete::s_ListViewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAutoComplete* pac = (CAutoComplete*)GetProp(hwnd, c_szAutoCompleteProp);
    if (pac)
    {
        return pac->_ListViewWndProc(uMsg, wParam, lParam);
    }
    else
    {
        TraceMsg(TF_WARNING, "CAutoComplete::s_ListViewWndProc() --- pac == NULL");
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}

//+-------------------------------------------------------------------------
// This message hook is only installed when the AutoSuggest dropdown
// is visible.  It hides the dropdown if you click on any window other than
// the dropdown or associated editbox/combobox.
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_MouseHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode >= 0)
    {
        MOUSEHOOKSTRUCT *pmhs = (MOUSEHOOKSTRUCT*)lParam;
        ASSERT(pmhs);

        switch (wParam)
        {
            case WM_LBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_NCLBUTTONDOWN:
            case WM_NCMBUTTONDOWN:
            case WM_NCRBUTTONDOWN:
            {
                HWND hwnd = pmhs->hwnd;

                // If the click was outside the edit/combobox/dropdown, then
                // hide the dropdown.
                if (hwnd != s_hwndDropDown)
                {
                    // Ignore if the button was clicked in the dropdown
                    RECT rc;
                    if (GetWindowRect(s_hwndDropDown, &rc) && !PtInRect(&rc, pmhs->pt))
                    {
                        // Inform the dropdown
                        SendMessage(s_hwndDropDown, AM_BUTTONCLICK, 0, (LPARAM)pmhs);
                    }
                }
                break;
            }
        }
    }

    return CallNextHookEx(s_hhookMouse, nCode, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclasses all of the parents of hwnd so we can determine when they
// are moved, deactivated, or clicked on.  We use these events to signal
// the window that has focus to hide its autocomplete dropdown. This is
// similar to the CB_SHOWDROPDOWN message sent to comboboxes, but we cannot
// assume that we are autocompleting a combobox.
//--------------------------------------------------------------------------
void CAutoComplete::_SubClassParent
(
    HWND hwnd   // window to notify of events
)
{
    //
    // Subclass all the parent windows because any of them could cause
    // the position of hwnd to change which should hide the dropdown.
    //
    HWND hwndParent = hwnd;
    DWORD dwThread = GetCurrentThreadId();

    while (hwndParent = GetParent(hwndParent))
    {
        // Only subclass if this window is owned by our thread
        if (dwThread == GetWindowThreadProcessId(hwndParent, NULL))
        {
            SetWindowSubclass(hwndParent, s_ParentWndProc, 0, (ULONG_PTR)this);
        }
    }
}

//+-------------------------------------------------------------------------
// Unsubclasses all of the parents of hwnd.  We use the helper functions in
// comctl32 to safely unsubclass a window even if someone else subclassed
// the window after us.
//--------------------------------------------------------------------------
void CAutoComplete::_UnSubClassParent
(
    HWND hwnd   // window to notify of events
)
{
    HWND hwndParent = hwnd;
    DWORD dwThread = GetCurrentThreadId();

    while (hwndParent = GetParent(hwndParent))
    {
        // Only need to unsubclass if this window is owned by our thread
        if (dwThread == GetWindowThreadProcessId(hwndParent, NULL))
        {
            RemoveWindowSubclass(hwndParent, s_ParentWndProc, 0);
        }
    }
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the parents ot the editbox being
// autocompleted.  This intecepts messages that should case the autocomplete
// dropdown to be hidden.
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_ParentWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CParentWindow
)
{
    CAutoComplete* pThis = (CAutoComplete*)dwRefData;

    if (!pThis)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
        case WM_WINDOWPOSCHANGED:
        {
            //
            // Check the elapsed time since this was last called.  We want to avoid an infinite loop
            // with another window that also wants to be on top.
            //
            static DWORD s_dwTicks = 0;
            DWORD dwTicks = GetTickCount();
            DWORD dwEllapsed = dwTicks - s_dwTicks;
            s_dwTicks = dwTicks;

            if (dwEllapsed > 100)
            {
                // Make sure our dropdown stays on top
                LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
                if (IsFlagClear(pwp->flags, SWP_NOZORDER) && IsWindowVisible(pThis->m_hwndDropDown))
                {
                    SetWindowPos(pThis->m_hwndDropDown, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
                }
            }
            break;
        }
        case WM_ACTIVATE:
        {
            // Ignore if we are not being deactivated
            WORD fActive = LOWORD(wParam);
            if (fActive != WA_INACTIVE)
            {
                break;
            }
            // Drop through
        }
        case WM_MOVING:
        case WM_SIZE:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            pThis->_HideDropDown();
            break;

        case WM_NCACTIVATE:
            //
            // While clicking on the autosuggest dropdown, we
            // want to prevent the dropdown from being activated.
            //
            if (s_fNoActivate)
                return FALSE;
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwnd, s_ParentWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclassed window procedure fir the grip re-sizer control
//--------------------------------------------------------------------------
LRESULT CALLBACK CAutoComplete::s_GripperWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,   // always zero for us
    DWORD_PTR dwRefData     // -> CParentWindow
)
{
    CAutoComplete* pThis = (CAutoComplete*)dwRefData;

    if (!pThis)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
        case WM_NCHITTEST:
            return HTTRANSPARENT;

        case WM_PAINT:
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            EndPaint(hwnd, &ps);
            break;

        case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            int nOldMapMode = 0;
            BOOL fScrollVisible = pThis->m_hwndScroll && IsWindowVisible(pThis->m_hwndScroll);

            //
            // See if we need to vertically flip the grip
            //
            if (pThis->m_fDroppedUp)
            {
                nOldMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
                SetWindowOrgEx(hdc, 0, 0, NULL);
                SetWindowExtEx(hdc, 1, 1, NULL);
                SetViewportOrgEx(hdc, 0, GetSystemMetrics(SM_CYHSCROLL), NULL);
                SetViewportExtEx(hdc, 1, -1, NULL);
            }
            // The standard DrawFrameControl API does not draw upside down on all platforms
//            DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
            DrawGrip(hdc, &rc, fScrollVisible);
            if (nOldMapMode)
            {
                SetViewportOrgEx(hdc, 0, 0, NULL);
                SetViewportExtEx(hdc, 1, 1, NULL);
                SetMapMode(hdc, nOldMapMode);
            }
            return 1;
        }
        case WM_DESTROY:
            RemoveWindowSubclass(hwnd, s_GripperWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bands.cpp ===
#include "priv.h"
#include "bands.h"
#include "util.h"
#include "resource.h"

#include "..\inc\bands.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandprxy.h ===
/**************************************************************\
    FILE: bandprxy.h

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/

#ifndef _BANDPRXY_H
#define _BANDPRXY_H

#include "bands.h"


///////////////////////////////////////////////////////////////////
// #DEFINEs
#define    SEC_DEFAULT             0x0000
#define    SEC_WAIT                0x0002
#define    SEC_SHELLSERVICEOBJECTS 0x0004
#define    SEC_NOUI                0x0008


/**************************************************************\
    CLASS: CBandProxy

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/
class CBandProxy
                : public IBandProxy // (Includes IUnknown)
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IBandProxy methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);        
    virtual STDMETHODIMP CreateNewWindow(IUnknown** ppunk);        
    virtual STDMETHODIMP GetBrowserWindow(IUnknown** ppunk);        
    virtual STDMETHODIMP IsConnected();
    virtual STDMETHODIMP NavigateToPIDL(LPCITEMIDLIST pidl);        
    virtual STDMETHODIMP NavigateToURL(LPCWSTR wzUrl, VARIANT * Flags);        

    // Constructor / Destructor
    CBandProxy();
    ~CBandProxy(void);

    // Friend Functions
    friend HRESULT CBandProxy_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   

protected:
    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    int             _cRef;

    BITBOOL         _fHaveBrowser : 1;  // We haven't tried to get _pwb
    IWebBrowser2 *  _pwb;
    IUnknown *      _punkSite;

    HRESULT _NavigateToUrlOLE(BSTR bstrURL, VARIANT * Flags);
    HRESULT MakeBrowserVisible(IUnknown* punk);
    IWebBrowser2* _GetBrowserWindow();
    IWebBrowser2* _GetBrowser();
};


#endif /* _BANDPRXY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandobj.cpp ===
#include "priv.h"
#include "bandobj.h"


UINT g_cfDeskBand = 0;
UINT g_cfDeskBandState = 0;

void InitCFDeskBand()
{
    if (!g_cfDeskBand) 
        g_cfDeskBand = RegisterClipboardFormat(TEXT("DeskBand"));
    if (!g_cfDeskBandState) 
        g_cfDeskBandState = RegisterClipboardFormat(TEXT("DeskBandState"));
}

CBandDataObject::CBandDataObject()
    : _cRef(1)
{
    InitCFDeskBand();
}

HRESULT CBandDataObject::Init(IUnknown* punkBand, IBandSite *pbs, DWORD dwBandID)
{
    HRESULT hres = E_FAIL;
    _pstm = SHCreateMemStream(NULL, 0);

    if (_pstm) {

        IPersistStream *ppstm;
        punkBand->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
        if (ppstm) {
            LARGE_INTEGER li = {0};
            OleSaveToStream(ppstm, _pstm);
            _pstm->Seek(li, STREAM_SEEK_SET, NULL);
            ppstm->Release();

            // bandsite state flags
            _dwState = 0;  // (if we fail just do w/o the state flags)
            if (pbs)
                pbs->QueryBand(dwBandID, NULL, &_dwState, NULL, 0);

            hres = S_OK;
            
        }
    }

    return hres;
}

CBandDataObject::~CBandDataObject()
{
    if (_pstm)
        _pstm->Release();
}

ULONG CBandDataObject::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBandDataObject::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}



HRESULT CBandDataObject::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IDataObject))
    {
        *ppvObj = SAFECAST(this, IDataObject*);
        AddRef();
        return S_OK;
    } 

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

// *** IDataObject ***

HRESULT CBandDataObject::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hres = E_FAIL;
    if (pformatetcIn->cfFormat == g_cfDeskBand)
    {
        if (pformatetcIn->tymed & TYMED_ISTREAM && EVAL(_pstm))
        {
            ASSERT(_pstm);
            
            pmedium->tymed = TYMED_ISTREAM;
            pmedium->pstm = _pstm;  // no AddRef since we xfer ownership
            _pstm = NULL;           // can only use it 1x (read causes seek)
            pmedium->pUnkForRelease = NULL;

            hres = S_OK;
        }
    }        
    else if (pformatetcIn->cfFormat == g_cfDeskBandState)
    {
        if (pformatetcIn->tymed & TYMED_HGLOBAL)
        {
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GPTR, sizeof (DWORD));
            if (pmedium->hGlobal)
            {
                DWORD *pdw = (DWORD*)(pmedium->hGlobal);

                *pdw = _dwState;

                pmedium->pUnkForRelease = NULL;

                hres = S_OK;
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }

    return hres;
}

HRESULT CBandDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::QueryGetData(FORMATETC *pformatetc)
{
    HRESULT hres = S_FALSE;
    // TODO: (reuse, perf) use rgfmtetc table lookup
    if ((pformatetc->cfFormat == g_cfDeskBand) &&
      (pformatetc->tymed & TYMED_ISTREAM) ||
        (pformatetc->cfFormat == g_cfDeskBandState) &&
      (pformatetc->tymed & TYMED_HGLOBAL))
    {
        hres = S_OK;
    }
    return hres;
}

HRESULT CBandDataObject::GetCanonicalFormatEtc(FORMATETC *pformatetcIn, FORMATETC *pformatetcOut)
{
    *pformatetcOut = *pformatetcIn;
    return DATA_S_SAMEFORMATETC;
}

HRESULT CBandDataObject::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
    HRESULT hr = E_FAIL;

    if (dwDirection == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            { g_cfDeskBand,            NULL, 0, -1, TYMED_ISTREAM },
            { g_cfDeskBandState,       NULL, 0, -1, TYMED_HGLOBAL },
        };

        hr = SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppenumFormatEtc);
    }
    
    return hr;
}

HRESULT CBandDataObject::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

HRESULT CBandDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}

//***   IDataObject_GetDeskBandState -- get band's bandsite state flags from BandDataObject
// NOTES
//  'paired' w/ DragBandState (inline in CBandDataObject::Init)
DWORD IDataObject_GetDeskBandState(IDataObject *pdtobj)
{
    DWORD dwState = 0;      // (if we fail just do w/o the state flags)

    FORMATETC fmte = {g_cfDeskBandState, NULL, 0, -1, TYMED_HGLOBAL};
    STGMEDIUM stg;
    HRESULT hrTmp;

    hrTmp = pdtobj->GetData(&fmte, &stg);
    if (SUCCEEDED(hrTmp))
    {
        DWORD *p = (DWORD *)(stg.hGlobal);

        dwState = *p;

        ReleaseStgMedium(&stg);
    }

    return dwState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandprxy.cpp ===
/**************************************************************\
    FILE: bandprxy.cpp

    DESCRIPTION:
        The CBandProxy class will allow bands to navigate a
    generic browser window.  This will work correctly if the
    band is tied to the Browser Window because it's a ToolBar.
    Or if it's a toolband, each time a navigation happens,
    the top most browser window needs to be found or a new window 
    created.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include <varutil.h>
#include "bandprxy.h"

#define DM_PERSIST      DM_TRACE        // trace IPS::Load, ::Save, etc.


//================================================================= 
// Implementation of CBandProxy
//=================================================================

/****************************************************\
    FUNCTION: CBandProxy_CreateInstance
  
    DESCRIPTION:
        This function will create an instance of the
    CBandProxy COM object.
\****************************************************/
HRESULT CBandProxy_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBandProxy * p = new CBandProxy();
    if (p) 
    {
        *ppunk = SAFECAST(p, IBandProxy *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: Address Band Constructor
\****************************************************/
CBandProxy::CBandProxy() : _cRef(1)
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CBandProxy %x", this);

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pwb);
    ASSERT(!_punkSite);
}


/****************************************************\
    FUNCTION: Address Band destructor
\****************************************************/
CBandProxy::~CBandProxy()
{
    ATOMICRELEASE(_pwb);
    ATOMICRELEASE(_punkSite);

    TraceMsg(TF_SHDLIFE, "dtor CBandProxy %x", this);
    DllRelease();
}



//===========================
// *** IUnknown Interface ***
/****************************************************\
    FUNCTION: AddRef
\****************************************************/
ULONG CBandProxy::AddRef()
{
    _cRef++;
    return _cRef;
}

/****************************************************\
    FUNCTION: Release
\****************************************************/
ULONG CBandProxy::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/****************************************************\
    FUNCTION: QueryInterface
\****************************************************/
HRESULT CBandProxy::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IBandProxy))
    {
        *ppvObj = SAFECAST(this, IBandProxy*);
    } 
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//================================
//  ** IBandProxy Interface ***

/****************************************************\
    FUNCTION: SetSite
  
    DESCRIPTION:
        This function will be called to have this
    Toolband try to obtain enough information about it's
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.  
\****************************************************/
HRESULT CBandProxy::SetSite(IUnknown * punk)
{
    HRESULT hr = S_OK;

    // On UNIX, we always have a browser.
    // Note, that there's no memory leak happened, 
    // because we get the browser only once 
    // and release it once too (in destructor).
#ifndef DISABLE_ACTIVEDESKTOP_FOR_UNIX
    _fHaveBrowser = FALSE;
    ATOMICRELEASE(_pwb);
#endif

    IUnknown_Set(&_punkSite, punk);
    return hr;
}


/****************************************************\
    FUNCTION: CreateNewWindow
  
    DESCRIPTION:
        If this function succeeds, the caller must
    use and release the returned interface quickly.  The
    caller cannot hold on to the Interface because
    the user may close the window and make releasing
    it impossible.
\****************************************************/
HRESULT CBandProxy::CreateNewWindow(IUnknown** ppunk)
{
#ifndef UNIX
    return CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                 IID_IUnknown, (void **)ppunk);
#else
    return CoCreateInternetExplorer( IID_IUnknown, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                     (void **) ppunk );
#endif
    // ZekeL: Add code to prep new Browser here.
}


IWebBrowser2* CBandProxy::_GetBrowser()
{
    if (!_fHaveBrowser)
    {
        IUnknown * punkHack;

        _fHaveBrowser = TRUE;

        // HACK: Bands docked on the side of the screen besides the Taskbar will be
        //       able to get a IWebBrowser2 interface pointer.  But we expect this
        //       to be pointing to a valid browser that we are attached to.  Navigating
        //       this interface appears to create new windows, which is not what we
        //       want, because we will try to recycle windows and do special behavior
        //       if the shift key is down.  This QS will detect this case and prevent
        //       it from confusing us.
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellDesktop, IID_IUnknown, (void**)&punkHack)))
            punkHack->Release();
        else
            IUnknown_QueryService(_punkSite, SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&_pwb);
    }

    return _pwb;
}


// this does the default UI work of opening a new window if the shift
// key is down
// or creating a browser if one isn't available already
IWebBrowser2* CBandProxy::_GetBrowserWindow()
{
    IUnknown* punk = NULL;
    IWebBrowser2* pwb = NULL;

    GetBrowserWindow(&punk);

    if (punk) {
        punk->QueryInterface(IID_IWebBrowser2, (LPVOID*)&pwb);

        // Always make browser visible.
        MakeBrowserVisible(punk);
        punk->Release();
    }
    
    return pwb;
}

/****************************************************\
    FUNCTION: GetBrowserWindow
  
    DESCRIPTION:
        this is to just *GET* the browser.  It does not
    do any auto-creating work.
        If this function succseeds, the caller must
    use and release the returned interface quickly.  The
    caller cannot hold on to the Interface because
    the user may close the window and make releasing
    it impossible.

\****************************************************/
HRESULT CBandProxy::GetBrowserWindow(IUnknown** ppunk)
{
    HRESULT hr;

    *ppunk = _GetBrowser();
    if (*ppunk)
    {
        (*ppunk)->AddRef();
        hr =  S_OK;
    } 
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************\
    FUNCTION: IsConnected
  
    DESCRIPTION:
        Indicate if we have a direct connection to the
    browser window.
    S_FALSE == no
    S_OK == yes.
\****************************************************/
HRESULT CBandProxy::IsConnected()
{
    return _GetBrowser() ? S_OK : S_FALSE;
}


/****************************************************\
    FUNCTION: MakeBrowserVisible
  
    DESCRIPTION:
        Make browser visible.
\****************************************************/
HRESULT CBandProxy::MakeBrowserVisible(IUnknown* punk)
{
    IWebBrowserApp * pdie;

    if (SUCCEEDED(punk->QueryInterface(IID_IWebBrowserApp, (void**)&pdie)))
    {
        pdie->put_Visible(TRUE);
        
        HWND hwnd;
        if (SUCCEEDED(SHGetTopBrowserWindow(punk, &hwnd)))
        {
            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
        }
        
        pdie->Release();
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: NavigateToPIDL
  
    DESCRIPTION:
        The caller needs to free the PIDL parameter and
    it can be done at any time.  (No need to worry
    about async navigation)  
\****************************************************/
HRESULT CBandProxy::NavigateToPIDL(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    IWebBrowser2* pwb = _GetBrowserWindow();
    if (pwb)
    {
        VARIANT varThePidl;

        hr = InitVariantFromIDList(&varThePidl, pidl);
        if (SUCCEEDED(hr))
        {
            hr = pwb->Navigate2(&varThePidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
            VariantClear(&varThePidl);
        }
        pwb->Release();
    }
    else
    {
        LPCITEMIDLIST pidlTemp;
        IShellFolder* psf;
        
        if (SUCCEEDED(IEBindToParentFolder(pidl, &psf, &pidlTemp)))
        {
            IContextMenu* pcm;

            hr = psf->GetUIObjectOf(NULL, 1, &pidlTemp, IID_PPV_ARG_NULL(IContextMenu, &pcm));
            if (SUCCEEDED(hr))
            {
                hr = IContextMenu_Invoke(pcm, NULL, NULL, 0);
                pcm->Release();
            }
            psf->Release();
        }
    }

    return hr;
}




/****************************************************\
    FUNCTION: NavigateToUrlOLE
  
    DESCRIPTION:
        Navigate to the Specified URL.  
\****************************************************/
HRESULT CBandProxy::_NavigateToUrlOLE(BSTR bstrURL, VARIANT * pvFlags)
{
    HRESULT hr = S_OK;

    ASSERT(bstrURL); // must have valid URL to browse to

    IWebBrowser2* pwb = _GetBrowserWindow();
    // This will assert if someone was hanging around in the debugger
    // too long.  While will cause the call to timing out.
    if (pwb) 
    {
        VARIANT varURL;
        varURL.vt = VT_BSTR;
        varURL.bstrVal = bstrURL;

        hr = pwb->Navigate2(&varURL, pvFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
        // VariantClear() not called because caller will free the allocated string.
        pwb->Release();
    } else {
        SHELLEXECUTEINFO sei;
        USES_CONVERSION;

        FillExecInfo(sei, NULL, //hwnd, 
                     NULL, W2T(bstrURL), NULL, NULL, SW_SHOWNORMAL);
        if (ShellExecuteEx(&sei))
            hr = S_OK;
        else
            hr = E_FAIL;

    }


    return hr;
}


/****************************************************\
    FUNCTION: NavigateToURLW
  
    DESCRIPTION:
        Navigate to the Specified URL.
\****************************************************/
HRESULT CBandProxy::NavigateToURL(LPCWSTR lpwzURL, VARIANT * Flags)
{
    HRESULT hr;

    LBSTR::CString          strPath( lpwzURL );

    hr = _NavigateToUrlOLE( strPath, Flags );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandsite.cpp ===
#include "priv.h"
#include "sccls.h"
#include <uxtheme.h>
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "bandobj.h"
#include "caggunk.h"
#include "droptgt.h"
#include "resource.h"
#include "bands.h"
#include "legacy.h"
#include "apithk.h"

#include "mluisupp.h"

#define TF_BANDDD   0x00400000
#define DM_INIT     0               //
#define DM_PERSIST  0               // trace IPS::Load, ::Save, etc.
#define DM_MENU     0               // menu code
#define DM_DRAG     0               // drag&drop
#define DM_FOCUS    0               // focus
#define DM_PERF     0               // perf tune
#define DM_PERF2    0               // perf tune (verbose)

#define IDM_DRAGDROP    1

#define ISMOVEDDISABLED(dwBandID)   ((S_OK == _IsRestricted(dwBandID, RA_MOVE, BAND_ADMIN_NOMOVE)) ? TRUE : FALSE)
#define ISDDCLOSEDISABLED(dwBandID) ((S_OK == _IsRestricted(dwBandID, RA_DRAG, BAND_ADMIN_NODDCLOSE)) ? TRUE : FALSE)

// drag state (NOTE from dockbar.h)
#define DRAG_NIL        0       // nil
#define DRAG_MOVE       1       // moving
#define DRAG_SIZE       2       // sizing

typedef struct {
    UINT cx;
    UINT fStyle;
    UINT cxMinChild;
    UINT cyMinChild;
    UINT cyIntegral;
    UINT cyMaxChild;
    UINT cyChild;
} PERSISTBANDINFO_V3;


typedef struct {
    UINT cx;
    UINT fStyle;
    UINT cxMinChild;  // UNUSED. reclaim!
    UINT cyMinChild;
    UINT cyIntegral;   // UNUSED
    UINT cyMaxChild;    // UNUSED.
    UINT cyChild;
    DWORD dwAdminSettings;
    BITBOOL fNoTitle:1;
} PERSISTBANDINFO;
#define RBBIM_XPERSIST  (RBBIM_SIZE | RBBIM_CHILDSIZE | RBBIM_STYLE)

#ifdef DEBUG

extern unsigned long DbStreamTell(IStream *pstm);

#else

#define DbStreamTell(pstm)      ((ULONG) 0)

#endif

UINT _FixMenuIndex(HMENU hmenu, UINT indexMenu)
{
    UINT i;

    i = GetMenuItemCount(hmenu);
    if (indexMenu > i)
        indexMenu = i;
    return indexMenu;
}

#define SUPERCLASS CAggregatedUnknown


HRESULT CBandSite::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CBandSite, IBandSite),             // IID_IBandSite
        QITABENT(CBandSite, IInputObject),          // IID_IInputObject
        QITABENT(CBandSite, IServiceProvider),      // IID_IServiceProvider
        QITABENT(CBandSite, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENTMULTI(CBandSite, IOleWindow, IDeskBarClient),   // IID_IOleWindow
        QITABENT(CBandSite, IWinEventHandler),      // IID_IWinEventHandler
        QITABENT(CBandSite, IInputObjectSite),      // IID_IInputObjectSite
        QITABENT(CBandSite, IDeskBarClient),        // IID_IDeskBarClient
        QITABENTMULTI(CBandSite, IPersist, IPersistStream),     // rare IID_IPersist
        QITABENT(CBandSite, IPersistStream),        // rare IID_IPersistStream
        QITABENT(CBandSite, IBandSiteHelper),       // rare IBandSiteHelper
        QITABENT(CBandSite, IDropTarget),           // rare IID_IDropTarget
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}

DWORD _SetDataListFlags(IUnknown *punk, DWORD dwMaskBits, DWORD dwValue)
{
    DWORD dw = 0;
    IShellLinkDataList *pdl;
    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &pdl))))
    {
        pdl->GetFlags(&dw);
        dw = (dw & ~dwMaskBits) | (dwValue & dwMaskBits);
        pdl->SetFlags(dw);
        pdl->Release();
    }
    return dw;
}


/////  impl of IServiceProvider
HRESULT CBandSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_IBandProxy)) 
    {
        hres =  QueryService_SID_IBandProxy(_punkSite, riid, &_pbp, ppvObj);
        if(!_pbp)
        {
            // We need to create it ourselves since our parent couldn't help
            ASSERT(FALSE == _fCreatedBandProxy);

            hres = CreateIBandProxyAndSetSite(_punkSite, riid, &_pbp, ppvObj);
            if(_pbp)
            {
                ASSERT(S_OK == hres);
                _fCreatedBandProxy = TRUE;   
            }
        }
    } 
    else if (IsEqualIID(guidService, SID_ITopViewHost)) 
    {
        return QueryInterface(riid, ppvObj);
    } 
    else if (IsEqualIID(guidService, IID_IBandSite))
    {
        // It is common for bands to save/load pidls for persistence.
        // CShellLink is a robust way to do this, so let's share one
        // among all the bands.
        //
        // NOTE: This is shared between bands, so if you request it
        // you must complete your use of it within the scope of your
        // function call!
        //
        if (IsEqualIID(riid, IID_IShellLinkA) ||
            IsEqualIID(riid, IID_IShellLinkW))
        {
            if (NULL == _plink)
                CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &_plink));
            if (_plink)
            {
                // we know that the bandsite is going to be pointing to local folders
                // to avoid a perf hit we get in loading the LINKINFO.DLL we explictly
                // disable that functionality here.
                _SetDataListFlags(_plink, SLDF_FORCE_NO_LINKINFO, SLDF_FORCE_NO_LINKINFO);
                hres = _plink->QueryInterface(riid, ppvObj);
            }
        }
    } 
    else
    {
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }
    return hres;
}

HRESULT CBandSite::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    return *lphwnd ?  S_OK : E_FAIL;
}

CBandSite::CBandSite(IUnknown* punkAgg) : SUPERCLASS(punkAgg)
{
    DWORD dwData = 0;
    DWORD dwSize = SIZEOF(dwData);

    // We assume this object was zero inited.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
    SHRegGetUSValue(SZ_REGKEY_GLOBALADMINSETTINGS, SZ_REGVALUE_GLOBALADMINSETTINGS,
        NULL, (LPVOID) &dwData, &dwSize, FALSE, NULL, 0);

    if (IsFlagSet(dwData, BAND_ADMIN_ADMINMACHINE))
        _fIEAKInstalled = TRUE;
    else
        _fIEAKInstalled = FALSE;

    _dwStyle = BSIS_AUTOGRIPPER;

    //
    //  We check whether or not this succeeded in CBandSite::_Initialize
    //
    _QueryOuterInterface(IID_PPV_ARG(IBandSite, &_pbsOuter));
    DllAddRef();
}

void CBandSite::_ReleaseBandItemData(LPBANDITEMDATA pbid, int iIndex)
{
    if (pbid->pdb) 
    {
        REBARBANDINFO rbbi;

        pbid->pdb->CloseDW(0);

        if (-1 != iIndex)
        {
            // The band's hwnd is typically destroyed in CloseDW
            rbbi.cbSize = sizeof(rbbi);
            rbbi.fMask = RBBIM_CHILD | RBBIM_LPARAM;
            rbbi.hwndChild = NULL;
            rbbi.lParam = NULL;
            EVAL( SendMessage(_hwnd, RB_SETBANDINFO, iIndex, (LPARAM) &rbbi) );
        }

        // this is called from remove and the destroy.
        IUnknown_SetSite(pbid->pdb, NULL);
        ATOMICRELEASE(pbid->pdb);
    }

    if (pbid->pweh == _pwehCache)
        ATOMICRELEASE(_pwehCache);

    ATOMICRELEASE(pbid->pweh);
    LocalFree(pbid);
}

CBandSite::~CBandSite()
{
    ATOMICRELEASE(_pdtobj);

    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);
        
    ATOMICRELEASE(_pbp);

    ATOMICRELEASE(_pwehCache);
    _CacheActiveBand(NULL);

    _Close();

    SetDeskBarSite(NULL);

    if (_plink)
        _plink->Release();

    RELEASEOUTERINTERFACE(_pbsOuter);
    DllRelease();
}

//***   _IsBandDeleteable --
// ENTRY/EXIT
//  idBand  band ID
//  ret     TRUE if deletable, o.w. FALSE (also FALSE on bogus band)
BOOL CBandSite::_IsBandDeleteable(DWORD dwBandID)
{
    DWORD dwState;

    if (FAILED(_pbsOuter->QueryBand(dwBandID, NULL, &dwState, NULL, 0))
      || (dwState & BSSF_UNDELETEABLE))
    {
        return FALSE;
    }

    ASSERT(dwBandID != (DWORD)-1);  // make sure QueryBand catches this

    return TRUE;
}

DWORD CBandSite::_GetAdminSettings(DWORD dwBandID)
{
    LPBANDITEMDATA pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 

    if (EVAL(pbid))
        return pbid->dwAdminSettings;

    return BAND_ADMIN_NORMAL;
}


void CBandSite::_SetAdminSettings(DWORD dwBandID, DWORD dwNewAdminSettings)
{
    LPBANDITEMDATA pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 

    if (EVAL(pbid))
        pbid->dwAdminSettings = dwNewAdminSettings;
}


//***   CBandSite::IBandSite::* {

/*----------------------------------------------------------
Purpose: IBandSite::EnumBands method

*/
HRESULT CBandSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    ASSERT((NULL == pdwBandID && (UINT)-1 == uBand) || 
           IS_VALID_WRITE_PTR(pdwBandID, DWORD));

    if (uBand == (UINT)-1)
        return _GetBandItemCount();      // query count

    LPBANDITEMDATA pbid = _GetBandItem(uBand);
    if (pbid)
    {
        *pdwBandID = pbid->dwBandID;
        return S_OK;
    }
    return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand method

*/
HRESULT CBandSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    ASSERT(NULL == ppstb || IS_VALID_WRITE_PTR(ppstb, IDeskBand));
    ASSERT(NULL == pdwState || IS_VALID_WRITE_PTR(pdwState, DWORD));
    ASSERT(NULL == pszName || IS_VALID_WRITE_BUFFER(pszName, WCHAR, cchName));

    if (ppstb)
        *ppstb = NULL;

    LPBANDITEMDATA pbid = _GetBandItemDataStructByID(dwBandID);
    if (!pbid)
        return E_FAIL;
    if (pszName)
    {
        StrCpyNW(pszName, pbid->szTitle, cchName);
    }

    if (ppstb)
    {
        *ppstb = pbid->pdb;
        if (pbid->pdb)
        {
            pbid->pdb->AddRef();
        }
    }
    
    if (pdwState)
    {
        *pdwState = 0;
        if (pbid->fShow)
            *pdwState = BSSF_VISIBLE;
        if (pbid->fNoTitle)
            *pdwState |= BSSF_NOTITLE;
        if (pbid->dwModeFlags & DBIMF_UNDELETEABLE)
            *pdwState |= BSSF_UNDELETEABLE;
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

* NOTES
*   failure handling is inconsistent (1 band vs. all bands case)
*/
HRESULT CBandSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    LPBANDITEMDATA pbid;
    HRESULT hr;

    if (dwBandID == (DWORD) -1)
    {
        BOOL fChange = FALSE;
        for (int i = _GetBandItemCount() - 1; i >= 0; i--)
        {
            pbid = _GetBandItem(i);
            if (pbid)
            {
                hr = _SetBandStateHelper(pbid->dwBandID, dwMask, dwState);
                ASSERT(SUCCEEDED(hr));
                fChange |= (hr != S_OK);
            }
            else
            {
                return E_FAIL;
            }
        }
        if (fChange)
            _UpdateAllBands(FALSE, FALSE);
        return S_OK;
    }
    else
    {
        hr = _SetBandStateHelper(dwBandID, dwMask, dwState);
        if (SUCCEEDED(hr) && hr != S_OK)
        {
            _UpdateBand(dwBandID);
            return S_OK;
        }
    }
    return E_FAIL;
}

//***
// ENTRY/EXIT
//  ret     S_OK|changed on success, o.w. E_*.
// NOTES
//  only a helper for SetBandState, don't call directly
HRESULT CBandSite::_SetBandStateHelper(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    LPBANDITEMDATA pbid;

    pbid = _GetBandItem(_BandIDToIndex(dwBandID));
    if (pbid)
    {
        DWORD dwOldState;

        if (FAILED(QueryBand(dwBandID, NULL, &dwOldState, NULL, 0)))
        {
            ASSERT(0);  // 'impossible'
            dwOldState = (DWORD)-1;
        }

        if (dwMask & BSSF_VISIBLE)
            _ShowBand(pbid, dwState & BSSF_VISIBLE);

        if (dwMask & BSSF_NOTITLE)
            pbid->fNoTitle = BOOLIFY(dwState & BSSF_NOTITLE);
            
        // FEATURE: (kkahl): BSSF_UNDELETABLE cannot currently be modified with
        // this interface.

        return ResultFromShort((dwOldState ^ dwState) & dwMask);
    }
    return E_FAIL;
}

//***   _CheckNotifyOnAddRemove -- handle notifies for add/remove/empty
// DESCRIPTION
//  add/remove always sends a BSID_BANDADDED/BSID_BANDREMOVED.
//  remove of last always sends a DBCID_EMPTY.
//  in floating mode, a transition to/from 1 band does a refresh.
//
void CBandSite::_CheckNotifyOnAddRemove(DWORD dwBandID, int iCode)
{
    int cBands;
    if (!_pct)
        return;

    if (iCode == CNOAR_CLOSEBAR)
    {
        // Shut down the whole thing
        cBands = 0;
    }
    else
    {
        VARIANTARG var;
        int nCmdID;

        cBands = _GetBandItemCount();   // post-op # (since op happened in caller)

        VariantInit(&var);
        var.vt = VT_UI4;
        var.ulVal = dwBandID;

        BOOL fOne = FALSE;
        switch (iCode)
        {
        case CNOAR_ADDBAND:
            fOne = (cBands == 2);   // 1->2
            nCmdID = BSID_BANDADDED;
            break;
        case CNOAR_REMOVEBAND:
            fOne = (cBands == 1);   // 2->1
            nCmdID = BSID_BANDREMOVED;
            break;
        default:
            ASSERT(0);
            return;
        }

        if ((fOne && (_dwMode & DBIF_VIEWMODE_FLOATING)))
        {
            // n.b. fBSOnly *must* be TRUE for perf
            _UpdateAllBands(TRUE, TRUE);  // force refresh of optional gripper/title
        }

        _pct->Exec(&CGID_BandSite, nCmdID, 0, &var, NULL);
    }

    if (cBands == 0)
    {
        ASSERT(iCode != CNOAR_ADDBAND);     // sanity check
        _pct->Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
    }

    return;
}

/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand method

*/
HRESULT CBandSite::RemoveBand(DWORD dwBandID)
{
    int iIndex = _BandIDToIndex(dwBandID);
    LPBANDITEMDATA pbid = _GetBandItem(iIndex);
    if (pbid)
    {
        // Release the banditem data first, while it can still
        // receive cleanup notifications from its control.  *Then*
        // delete the band item.
        _ReleaseBandItemData(pbid, iIndex);
        _DeleteBandItem(iIndex);    // unhook from host (rebar)
        _CheckNotifyOnAddRemove(dwBandID, CNOAR_REMOVEBAND);
        return S_OK;
    }
    return E_FAIL;
}


void CBandSite::_OnCloseBand(DWORD dwBandID)
{
    if (dwBandID == -1)
    {
        // Close everything
        _CheckNotifyOnAddRemove(dwBandID, CNOAR_CLOSEBAR);
    }
    else
    {
        // Close just this band

        LPBANDITEMDATA pbid = _GetBandItemDataStructByID(dwBandID);
        USES_CONVERSION;

        if (EVAL(pbid) && ConfirmRemoveBand(_hwnd, IDS_CONFIRMCLOSEBAND,W2T(pbid->szTitle)))
            RemoveBand(dwBandID);
    }
}

void CBandSite::_MinimizeBand(DWORD dwBandID)
{
    SendMessage(_hwnd, RB_MINIMIZEBAND, _BandIDToIndex(dwBandID), TRUE);
}

void CBandSite::_MaximizeBand(DWORD dwBandID)
{
    SendMessage(_hwnd, RB_MAXIMIZEBAND, _BandIDToIndex(dwBandID), TRUE);
}

//
// private insert a band into the container control by ID
// returns the band ID in ShortFromResult(hres)
//

HRESULT CBandSite::_AddBandByID(IUnknown *punk, DWORD dwID)
{
    IDeskBand *pdb;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
    if (SUCCEEDED(hr)) 
    {
        ASSERT(pdb);
        BANDITEMDATA *pbid = (BANDITEMDATA *)LocalAlloc(LPTR, sizeof(BANDITEMDATA));
        if (pbid)
        {
            pbid->dwBandID = dwID;
            pbid->pdb = pdb;      // ref held by QI above
            pbid->fShow = TRUE;     // initially visible

            pbid->pdb->QueryInterface(IID_PPV_ARG(IWinEventHandler, &pbid->pweh));
            hr = IUnknown_SetSite(pbid->pdb, SAFECAST(this, IBandSite*));
            if (SUCCEEDED(hr))
            {
                hr = pbid->pdb->GetWindow(&pbid->hwnd);
                if (SUCCEEDED(hr))
                {
                    if (_AddBandItem(pbid))
                    {
                        if (_dwShowState == DBC_SHOW) 
                        {
                            ASSERT(pbid->fShow);
                            pbid->pdb->ShowDW(TRUE);
                            _MinimizeBand(pbid->dwBandID);
                        }
                
                        _CheckNotifyOnAddRemove(pbid->dwBandID, CNOAR_ADDBAND);
                        hr = ResultFromShort(pbid->dwBandID); // success
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }

            if (FAILED(hr))
            {
                // clean up
                _ReleaseBandItemData(pbid, -1);
            }

            //
            // Now that we've added the band, clear the _SendToToolband cache.
            //
            // We need to do this because we might have gotten a message for
            // the band before it was inserted, in which case we'll have cached
            // a NULL handler for the band's hwnd (preventing the band from
            // getting any messages thereafter).
            //
            ATOMICRELEASE(_pwehCache);
            _hwndCache = NULL;
        } 
        else
        {
            hr = E_OUTOFMEMORY;
            pdb->Release();    // don't hold on to this
        }
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand method.

         Insert a band into the container control.

Returns: the band ID in ShortFromResult(hres)

*/
HRESULT CBandSite::AddBand(IUnknown *punk)
{
    HRESULT hres = _AddBandByID(punk, _dwBandIDNext);
    if (SUCCEEDED(hres))
    {
        _dwBandIDNext++;
    }
    return hres;
}

void CBandSite::_UpdateBand(DWORD dwBandID)
{
    LPBANDITEMDATA pbid = _GetBandItem(_BandIDToIndex(dwBandID)); 
    if (pbid)
    {
        _UpdateBandInfo(pbid, FALSE);
        _OnRBAutoSize(NULL);
    }
}

void CBandSite::_UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize)
{
    BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

    for (int i = _GetBandItemCount() - 1; i >= 0; i--)
    {
        LPBANDITEMDATA pbid = _GetBandItem(i);
        if (pbid)
            _UpdateBandInfo(pbid, fBSOnly);
    }    

    SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);

    if (!fNoAutoSize)
    {
        SendMessage(_hwnd, RB_SIZETORECT, 0, 0);
        _OnRBAutoSize(NULL);
    }
}

// *** IOleCommandTarget ***
HRESULT CBandSite::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup)
    {
        if (IsEqualIID(*pguidCmdGroup, IID_IDockingWindow))
        {
            for (ULONG i=0 ; i<cCmds ; i++)
            {
                switch (rgCmds[i].cmdID)
                {
                case DBID_BANDINFOCHANGED:
                case DBID_PUSHCHEVRON:
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                    break;

                case DBID_PERMITAUTOHIDE:
                    // defer decision to the bands
                    for (int iBand = _GetBandItemCount() - 1; iBand >= 0; iBand--)
                    {
                        LPBANDITEMDATA pbid = _GetBandItem(iBand);
                        if (pbid)
                        {
                            if (SUCCEEDED(IUnknown_QueryStatus(pbid->pdb, pguidCmdGroup, 1, &rgCmds[i], pcmdtext)) &&
                                ((rgCmds[i].cmdf & OLECMDF_SUPPORTED) && !(rgCmds[i].cmdf & OLECMDF_ENABLED)))
                            {
                                break;
                            }
                        }
                    }
                    break;
    
                default:
                    rgCmds[i].cmdf = 0;
                    break;
                }
            }
            return S_OK;
        }
        else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
        {
            return IUnknown_QueryStatus(_ptbActive, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
        }
    }

    // if we got here, we didn't handle it
    // forward it down
    return MayQSForward(_ptbActive, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}


int _QueryServiceCallback(LPBANDITEMDATA pbid, void *pv)
{
    QSDATA* pqsd = (QSDATA*)pv;

    if (pbid->fShow)
        pqsd->hres = IUnknown_QueryService(pbid->pdb, *(pqsd->pguidService), *(pqsd->piid), pqsd->ppvObj);

    // stop if we found the service
    return SUCCEEDED(pqsd->hres) ? FALSE : TRUE;
}


typedef struct {
    HRESULT hres;
    const GUID *pguidCmdGroup;
    DWORD nCmdID;
    DWORD nCmdexecopt;
    VARIANTARG *pvarargIn;
    VARIANTARG *pvarargOut;
} EXECDATA;

int _ExecCallback(LPBANDITEMDATA pbid, void *pv)
{
    EXECDATA* ped = (EXECDATA*)pv;
    
    ped->hres = IUnknown_Exec(pbid->pdb, ped->pguidCmdGroup, ped->nCmdID, ped->nCmdexecopt,
        ped->pvarargIn, ped->pvarargOut);
    return 1;
}

HRESULT CBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    HRESULT hresTmp;

    if (pguidCmdGroup == NULL)
    {
        /*NOTHING*/
        ;
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBand))
    {
        switch (nCmdID)
        {
        case DBID_BANDINFOCHANGED:
            if (!pvarargIn)
                _UpdateAllBands(FALSE, FALSE);
            else if (pvarargIn->vt == VT_I4) 
                _UpdateBand(pvarargIn->lVal);
            hres = S_OK;
            
            // forward this up.
            if (_pct)
            {
                _pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            goto Lret;

        case DBID_PUSHCHEVRON:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                int iIndex = _BandIDToIndex(nCmdexecopt);
                SendMessage(_hwnd, RB_PUSHCHEVRON, iIndex, pvarargIn->lVal);
                hres = S_OK;
            }
            goto Lret;

        case DBID_MAXIMIZEBAND:
            if (pvarargIn && pvarargIn->vt == VT_UI4)
                _MaximizeBand(pvarargIn->ulVal);
            hres = S_OK;
            goto Lret;
#if 1 // { FEATURE: temporary until add cbs::Select() mfunc
        case DBID_SHOWONLY:
            {
                int iCount = _GetBandItemCount();
                
                // pvaIn->punkVal:
                //  punk hide everyone except me
                //  0    hide everyone
                //  1    show everyone
                // FEATURE: we should use pvaIn->lVal not punkVal since we're
                // allowing 0 & 1 !!! (and not doing addref/release)
                ASSERT(pvarargIn && pvarargIn->vt == VT_UNKNOWN);
                if (pvarargIn->punkVal == NULL || pvarargIn->punkVal == (IUnknown*)1)
                    TraceMsg(TF_BANDDD, "cbs.e: (id=DBID_SHOWONLY, punk=%x)", pvarargIn->punkVal);
                // show myself, hide everyone else
                TraceMsg(TF_BANDDD, "cbs.Exec(DBID_SHOWONLY): n=%d", _GetBandItemCount());

                // wait to show this band until we've hidden the others
                LPBANDITEMDATA pbidShow = NULL;
                // FEATURE: this (IUnknown*)1 is bogus! Also mentioned above.
                BOOL bShowAll = (pvarargIn->punkVal == (IUnknown*)1);
                for (int i = iCount - 1; i >= 0; i--)
                {
                    LPBANDITEMDATA pbid = _GetBandItem(i);

                    if (pbid)
                    {
                        BOOL fShow;

                        fShow = bShowAll || SHIsSameObject(pbid->pdb, pvarargIn->punkVal);
                        if (!fShow || bShowAll)
                            _ShowBand(pbid, fShow);
                        else
                            pbidShow = pbid;
                    }
                }
                if (pbidShow)
                {
                    _ShowBand(pbidShow, TRUE);
                    // nash:37290 set focus to band on open
                    if (_dwShowState == DBC_SHOW)
                        IUnknown_UIActivateIO(pbidShow->pdb, TRUE, NULL);
                    else
                        ASSERT(0);
                }
            }
            break;
#endif // }
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_Explorer))
    {
        return IUnknown_Exec(_ptbActive, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBarClient))
    {
        switch (nCmdID)
        {
        case DBCID_ONDRAG:
            if (EVAL(pvarargIn->vt == VT_I4))
            {
                ASSERT(pvarargIn->lVal == 0 || pvarargIn->lVal == DRAG_MOVE);
                TraceMsg(DM_TRACE, "cbs.e: DBCID_ONDRAG i=%d", pvarargIn->lVal);
                _fDragging = pvarargIn->lVal;
            }
            break;

        case DBCID_GETBAR:
            // return IUnkown of my IDeskBar host
            if ((pvarargOut != NULL) && _pdb)
            {
                ::VariantInit(pvarargOut);
                V_VT(pvarargOut)      = VT_UNKNOWN;
                V_UNKNOWN(pvarargOut) = _pdb;
                _pdb->AddRef();
                hres = S_OK;
                goto Lret;
            }
            break;
        }
    }


    // if we got here, we didn't handle it
    // see if we should forward it down
    hresTmp = IsExecForward(pguidCmdGroup, nCmdID);
    if (SUCCEEDED(hresTmp) && HRESULT_CODE(hresTmp) > 0)
    {
        // down (singleton or broadcast)
        if (HRESULT_CODE(hresTmp) == OCTD_DOWN)
        {
            // down (singleton)

            hres = IUnknown_Exec(_ptbActive, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut);
        }
        else
        {
            // down (broadcast)
            // n.b. hres is a bit weird: 'last one wins'
            // FEATURE: should we just return S_OK?
            ASSERT(HRESULT_CODE(hresTmp) == OCTD_DOWNBROADCAST);

            EXECDATA ctd = { hres, pguidCmdGroup, nCmdID, nCmdexecopt,
                pvarargIn, pvarargOut };

            _BandItemEnumCallback(1, _ExecCallback, &ctd);
            hres = ctd.hres;
        }
    }

Lret:
    return hres;
}

/***    _ShowBand -- show/hide band (cached state, band, and rebar band)
 */
void CBandSite::_ShowBand(LPBANDITEMDATA pbid, BOOL fShow)
{
    int i;

    pbid->fShow = BOOLIFY(fShow);
    if (pbid->pdb)
    {
        pbid->pdb->ShowDW(fShow && (_dwShowState == DBC_SHOW));
    }
    
    i = _BandIDToIndex(pbid->dwBandID);
    SendMessage(_hwnd, RB_SHOWBAND, i, fShow);

    // get me a window to draw D&D curosors on. . .
    SHGetTopBrowserWindow(SAFECAST(this, IBandSite*), &_hwndDD);
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CBandSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    ASSERT(IS_VALID_WRITE_PTR(pbsinfo, BANDSITEINFO));

    if (pbsinfo->dwMask & BSIM_STATE)
        pbsinfo->dwState = _dwMode;

    if (pbsinfo->dwMask & BSIM_STYLE)
        pbsinfo->dwStyle = _dwStyle;

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CBandSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    ASSERT(IS_VALID_READ_PTR(pbsinfo, BANDSITEINFO));

    if (pbsinfo->dwMask & BSIM_STATE)
        _dwMode = pbsinfo->dwState;

    if (pbsinfo->dwMask & BSIM_STYLE)
    {
        // If the BSIS_SINGLECLICK style changed, change the rebar style
        if ( _hwnd && ((_dwStyle ^ pbsinfo->dwStyle) & BSIS_SINGLECLICK) )
            SHSetWindowBits(_hwnd, GWL_STYLE, RBS_DBLCLKTOGGLE, (pbsinfo->dwStyle & BSIS_SINGLECLICK)?0:RBS_DBLCLKTOGGLE);
            
        _dwStyle = pbsinfo->dwStyle;
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CBandSite::GetBandObject(DWORD dwBandID, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IDataObject)) 
    {
        *ppvObj = _DataObjForBand(dwBandID);
        if (*ppvObj)
            hres = S_OK;
    }
    else 
    {
        LPBANDITEMDATA pbid = _GetBandItemDataStructByID(dwBandID);
        if (pbid && pbid->pdb)
        {
            hres = pbid->pdb->QueryInterface(riid, ppvObj);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Returns a pointer to the band item data given an
         externally known band ID.

Returns: NULL if band ID is illegal
*/
LPBANDITEMDATA CBandSite::_GetBandItemDataStructByID(DWORD uID)
{
    int iBand = _BandIDToIndex(uID);
    if (iBand == -1)
        return NULL;
    return _GetBandItem(iBand);
}


__inline HRESULT _FwdWinEvent(IWinEventHandler* pweh, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    ASSERT(pweh);
    ASSERT(hwnd == HWND_BROADCAST || pweh->IsWindowOwner(hwnd) == S_OK);

    return pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}

/*----------------------------------------------------------
Purpose: Forwards messages to the band that owns the window.

Returns: TRUE if the message was forwarded

*/
BOOL CBandSite::_SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    BOOL fSent = FALSE;
    LRESULT lres = 0;

    if (hwnd)
    {
        if (hwnd == _hwndCache)
        {
            ASSERT(hwnd != HWND_BROADCAST);

            if (_pwehCache)
            {
                _FwdWinEvent(_pwehCache, hwnd, uMsg, wParam, lParam, &lres);
                fSent = TRUE;
            }
        }
        else
        {
            LPBANDITEMDATA pbid = NULL;
            int i;

            for (i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                pbid = _GetBandItem(i);
                if (pbid)
                {
                    if (pbid->pweh)
                    {
                        if (hwnd == HWND_BROADCAST || 
                          (pbid->pweh->IsWindowOwner(hwnd) == S_OK))
                        {
                            _FwdWinEvent(pbid->pweh, hwnd, uMsg, wParam, lParam, &lres);
                            fSent = TRUE;

                            if (hwnd != HWND_BROADCAST)
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (hwnd == HWND_BROADCAST && pbid->hwnd)
                        {
                            lres = SendMessage(pbid->hwnd, uMsg, wParam, lParam);
                            fSent = TRUE;
                        }
                    }
                }
            }

            if (hwnd != HWND_BROADCAST)
            {
                ATOMICRELEASE(_pwehCache);
                _hwndCache = hwnd;
                if (fSent && pbid)
                {
                    _pwehCache = pbid->pweh;
                    _pwehCache->AddRef();
                }
            }
        }
    }

    if (plres)
        *plres = lres;
    
    return fSent;
}

typedef struct {
    HWND hwnd;
    HRESULT hres;
} WINDOWOWNERDATA;

int _IsWindowOwnerCallback(LPBANDITEMDATA pbid, void *pv)
{
    WINDOWOWNERDATA* pwod = (WINDOWOWNERDATA*)pv;
    
    if (pbid->pweh && (pbid->pweh->IsWindowOwner(pwod->hwnd) == S_OK)) 
    {
        pwod->hres = S_OK;
        return 0;
    }
    return 1;
}

HRESULT CBandSite::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    
    WINDOWOWNERDATA wod = { hwnd, S_FALSE };
    _BandItemEnumCallback(1, _IsWindowOwnerCallback, &wod);
    return wod.hres;
}

//***   CBandSite::IDeskBarClient::* {
HRESULT CBandSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    HRESULT hres = E_FAIL;
    switch (dwWhich)
    {
    case DBC_GS_IDEAL:
        {
            prc->right = 0;
            prc->bottom = 0;
            
            BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
            for (int i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                LPBANDITEMDATA pbid = _GetBandItem(i);
                if (pbid)
                {
                    RECT rc;
                    
                    SendMessage(_hwnd, RB_GETBANDBORDERS, _BandIDToIndex(pbid->dwBandID), (LPARAM) &rc);
                    _UpdateBandInfo(pbid, FALSE);
                    
                    if (pbid->fShow)
                    {
                        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
                        {
                            prc->right = max(prc->right, pbid->ptActual.x + (rc.left + rc.right));
                            prc->bottom += pbid->ptActual.y + rc.top + rc.bottom;
                        }
                        else
                        {
                            prc->bottom = max(prc->right, pbid->ptActual.x + (rc.left + rc.right));
                            prc->right += pbid->ptActual.y + rc.top + rc.bottom;
                        }
                    }
                    hres = S_OK;
                }
            }
            SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);
        }
        break;
        
    case DBC_GS_SIZEDOWN:
        {
            // Used to make a band change size in chuncks
            SendMessage(_hwnd, RB_SIZETORECT, RBSTR_CHANGERECT, (LPARAM)prc);
            hres = S_OK;
        }
        break;
    }
    return hres;
}


void CBandSite::_Close() 
{        
    if (_hwnd)
    {
        //  (scotth): This method is getting called by the destructor,
        //  and calls _DeleteAllBandItems, which sends messages to _hwnd.
        //  _hwnd is already destroyed by this time.  If you hit this assert
        //  it is because in debug windows it RIPs like crazy.
        // 970508 (adp): pblm was that we weren't doing DestroyWnd etc.
        //  
        //  Do no remove this assert....please fix the root problem.
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));
        SendMessage(_hwnd, WM_SETREDRAW, 0, 0);
        _DeleteAllBandItems(); 

        DestroyWindow(_hwnd);
        _hwnd = 0;
    }
}

    
HRESULT CBandSite::UIActivateDBC(DWORD dwState)
{
    if (dwState != _dwShowState)
    {
        BOOL fShow = dwState;

        _dwShowState = dwState;
        // map UIActivateDBC to ShowDW
        if (DBC_SHOWOBSCURE == dwState)
            fShow = FALSE;

        BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
        for (int i = _GetBandItemCount() - 1; i >= 0; i--)
        {
            LPBANDITEMDATA pbid = _GetBandItem(i);
            if (pbid && pbid->pdb)
                pbid->pdb->ShowDW(fShow && pbid->fShow);
        }

        // do this now intead of at creation so that 
        // rebar doesn't keep trying to autosize us while
        // we're not even visible
        SHSetWindowBits(_hwnd, GWL_STYLE, RBS_AUTOSIZE, RBS_AUTOSIZE);
        SendMessage(_hwnd, WM_SIZE, 0, 0);
        SendMessage(_hwnd, WM_SETREDRAW, (DBC_SHOW == dwState) ? TRUE : fRedraw, 0);
    }
    return S_OK;
}

DWORD CBandSite::_GetWindowStyle(DWORD* pdwExStyle)
{
    *pdwExStyle = WS_EX_TOOLWINDOW;
    DWORD dwStyle = RBS_REGISTERDROP | RBS_VARHEIGHT | RBS_BANDBORDERS |
                    WS_VISIBLE |  WS_CHILD | WS_CLIPCHILDREN |
                    WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN;
    if (_dwStyle & BSIS_LEFTALIGN)
    {
        dwStyle |= RBS_VERTICALGRIPPER;
    }

    if (!(_dwStyle & BSIS_SINGLECLICK))
    {
        dwStyle |= RBS_DBLCLKTOGGLE;
    }

    return dwStyle;
}

HRESULT CBandSite::_Initialize(HWND hwndParent)
{
    //
    //  I hope we have an IBandSite to talk to.
    //
    if (!_pbsOuter)
        return E_FAIL;

    if (!_hwnd) 
    {
        DWORD dwExStyle;
        DWORD dwStyle = _GetWindowStyle(&dwExStyle);

        _hwnd = CreateWindowEx(dwExStyle, REBARCLASSNAME, NULL, dwStyle,
                               0, 0, 0, 0, hwndParent, (HMENU) FCIDM_REBAR, HINST_THISDLL, NULL);

        if (_hwnd)
        {
            SendMessage(_hwnd, RB_SETTEXTCOLOR, 0, CLR_DEFAULT);
            SendMessage(_hwnd, RB_SETBKCOLOR, 0, CLR_DEFAULT);
            SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
        }
    }
    
    return _hwnd ? S_OK : E_OUTOFMEMORY;
}

HRESULT CBandSite::SetDeskBarSite(IUnknown* punkSite)
{
    HRESULT hr = S_OK;

    if (!punkSite)
    {
        // Time to tell the bands to free their
        // back pointers on us or we never get freed...

        // 970325 for now bs::SetDeskBarSite(NULL) is 'overloaded'
        // to mean do both a CloseDW and a SetSite.
        // when we clean up our act and have a bs::Close iface
        // we'll go back to the '#else' code below.
        if (_hwnd)
            _Close();
    }

    ATOMICRELEASE(_pct);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_punkSite);

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(punkSite);

    if (punkSite)
    {
        _punkSite = punkSite;
        _punkSite->AddRef();

        if (!_hwnd) 
        {
            HWND hwndParent;
            IUnknown_GetWindow(punkSite, &hwndParent);
            hr = _Initialize(hwndParent);
        }

        punkSite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_pct));
        punkSite->QueryInterface(IID_PPV_ARG(IDeskBar, &_pdb));
    }
    
    return hr;
}

HRESULT CBandSite::SetModeDBC(DWORD dwMode)
{
    if (dwMode != _dwMode)
    {
        _dwMode = dwMode;

        if (_hwnd)
        {
            DWORD dwStyle = 0;
            if (dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
            {
                dwStyle |= CCS_VERT;
            }
            SHSetWindowBits(_hwnd, GWL_STYLE, CCS_VERT, dwStyle);
        }

        _UpdateAllBands(FALSE, FALSE);
    }
    return S_OK;
}

// }

IDropTarget* CBandSite::_WrapDropTargetForBand(IDropTarget* pdtBand)
{
    if (!pdtBand || (_dwStyle & BSIS_NODROPTARGET))
    {
        // addref it for the new pointer
        if (pdtBand)
            pdtBand->AddRef();
        return pdtBand;
    }
    else
    {
        return DropTargetWrap_CreateInstance(pdtBand, SAFECAST(this, IDropTarget*), _hwndDD);
    }
}

LRESULT CBandSite::_OnNotify(LPNMHDR pnm)
{
    NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnm;
    
    switch (pnm->code)
    {
    case RBN_GETOBJECT:
    {
        pnmon->hResult = E_FAIL;
        
        // if we're the drag source, then a band is dragging... we want to only
        // give out the bandsite's drop target
        if (pnmon->iItem != -1 && !_fDragSource) 
        {
            LPBANDITEMDATA pbid = _GetBandItemDataStructByID(pnmon->iItem);
            if (EVAL(pbid) && pbid->pdb)
            {
                pnmon->hResult = pbid->pdb->QueryInterface(*pnmon->piid, &pnmon->pObject);

                // give a wrapped droptarget instead of the band's droptarget
                if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
                {
                    IDropTarget* pdtBand;
                    BOOL fNeedReleasePdtBand = FALSE;

                    if (SUCCEEDED(pnmon->hResult))
                    {
                        pdtBand = (IDropTarget*)(pnmon->pObject);
                    }
                    else
                    {
                        CDropDummy *pdtgt = new CDropDummy(_hwndDD);
                        pdtBand = SAFECAST(pdtgt, IDropTarget*);
                        fNeedReleasePdtBand = TRUE;
                    }

                    IDropTarget* pdt = _WrapDropTargetForBand(pdtBand);
                    if (pdt)
                    {
                        pnmon->pObject = pdt;
                        pnmon->hResult = S_OK;

                        // we've handed off pdtBand to pdt
                        fNeedReleasePdtBand = TRUE;
                    }

                    if (fNeedReleasePdtBand && pdtBand)
                        pdtBand->Release();
                }

                if (FAILED(pnmon->hResult) && !(_dwStyle & BSIS_NODROPTARGET)) 
                    pnmon->hResult = QueryInterface(*pnmon->piid, &pnmon->pObject);
            }
        } 
        break;
    }

    case RBN_BEGINDRAG:
        return _OnBeginDrag((NMREBAR*)pnm);

    case RBN_AUTOSIZE:
        _OnRBAutoSize((NMRBAUTOSIZE*)pnm);
        break;

    case RBN_CHEVRONPUSHED:
    {
        LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnm;
        LPBANDITEMDATA pbid = _GetBandItem(pnmch->uBand);
        if (EVAL(pbid))
        {
            MapWindowPoints(_hwnd, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
            ToolbarMenu_Popup(_hwnd, &pnmch->rc, pbid->pdb, pbid->hwnd, 0, (DWORD)pnmch->lParamNM);
        }
        break;
    }

    case RBN_AUTOBREAK:
    {
        if (_dwStyle & BSIS_PREFERNOLINEBREAK)
        {
            Comctl32_FixAutoBreak(pnm);
        }
        break;
    }
    }

    return 0;
}

void CBandSite::_OnRBAutoSize(NMRBAUTOSIZE* pnm)
{
    // DRAG_MOVE: we turn off autosize during (most of) a move because
    // fVertical is out of sync until the very end
    if (_pdb && _GetBandItemCount() && _fDragging != DRAG_MOVE)
    {
        RECT rc;
        int iHeightCur;
        int iHeight = (int)SendMessage(_hwnd, RB_GETBARHEIGHT, 0, 0);

#ifdef DEBUG
        DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
#endif

        GetWindowRect(_hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, GetParent(_hwnd), &rc);

        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL))
        {
            ASSERT((dwStyle & CCS_VERT));
            iHeightCur = RECTWIDTH(rc);
            rc.right = rc.left + iHeight;
        }
        else
        {
            ASSERT(!(dwStyle & CCS_VERT));
            iHeightCur = RECTHEIGHT(rc);
            rc.bottom = rc.top + iHeight;
        }

        if ((iHeightCur != iHeight) || (IsOS(OS_WHISTLERORGREATER)))
        {
            _pdb->OnPosRectChangeDB(&rc);
        }
    }
}

IDataObject* CBandSite::_DataObjForBand(DWORD dwBandID)
{
    IDataObject* pdtobjReturn = NULL;

    LPBANDITEMDATA pbid = _GetBandItemDataStructByID(dwBandID);
    if (EVAL(pbid) && pbid->pdb)
    {
        HRESULT hres;
        
        CBandDataObject* pdtobj = new CBandDataObject();
        if (pdtobj)
        {
            hres = pdtobj->Init(pbid->pdb, this, dwBandID);

            if (SUCCEEDED(hres))
            {
                pdtobjReturn = pdtobj;
                pdtobjReturn->AddRef();
            }
            
            pdtobj->Release();
        }
    }
    return pdtobjReturn;
}

LRESULT CBandSite::_OnBeginDrag(NMREBAR* pnm)
{
    LRESULT lres = 0;
    DWORD dwBandID = _IndexToBandID(pnm->uBand);

    IDataObject* pdtobj = _DataObjForBand(dwBandID);

    ATOMICRELEASE(_pdtobj);

    _uDragBand = pnm->uBand;
    _pdtobj = pdtobj;
    // because the RBN_BEGINDRAG is synchronous and so is SHDoDragDrop
    // post this message to ourselves instead of calling dragdrop directly.
    // note that we don't have a window of our own, so we post to our parent
    // and let the message reflector send it back to us
    PostMessage(GetParent(_hwnd), WM_COMMAND, MAKELONG(0, IDM_DRAGDROP), (LPARAM)_hwnd);
    return 1;
}

// return TRUE if the user drags out of the rect of the rebar meaning that we should
// go into ole drag drop.
BOOL CBandSite::_PreDragDrop()
{
    BOOL f = FALSE;
    RECT rc;
    POINT pt;
    DWORD dwBandID = _IndexToBandID(_uDragBand);    // Find the BandID before an reordering that may happen.
    
    GetWindowRect(_hwnd, &rc);
    SetCapture(_hwnd);

    InflateRect(&rc, GetSystemMetrics(SM_CXEDGE) * 3, GetSystemMetrics(SM_CYEDGE) * 3);
    while (GetCapture() == _hwnd)
    {
        MSG msg;
        
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            switch (msg.message)
            {
            case WM_MOUSEMOVE:
                GetCursorPos(&pt);
                if (!ISMOVEDDISABLED(dwBandID))
                {
                    if (PtInRect(&rc, pt))
                    {
                        SendMessage(_hwnd, RB_DRAGMOVE, 0, (LPARAM)-1);
                    } else if (!ISDDCLOSEDISABLED(dwBandID) && _pdtobj)
                    {
                        // we've moved out of the bounds of the rebar..  switch to ole drag
                        f = TRUE;
                        SetCapture(NULL);
                    }
                }
                break;

            case WM_LBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_RBUTTONDOWN:
                // bail on any mouse button action
                SetCapture(NULL);
                break;
                
            case WM_KEYDOWN:
                switch (msg.wParam)
                {
                case VK_ESCAPE:
                    SetCapture(NULL);
                    break;
                }
                // fall through
                
            default:
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    if (ISDDCLOSEDISABLED(dwBandID) || !_IsBandDeleteable(dwBandID))
    {
        /// if don't allow close, never return true for ole drag.
        f = FALSE;
    }

    return f;
}

void CBandSite::_DoDragDrop()
{
    DWORD dwBandID = _IndexToBandID(_uDragBand);
    DWORD dwEffect = DROPEFFECT_MOVE;

    _fDragSource = TRUE;

    SendMessage(_hwnd, RB_BEGINDRAG, _uDragBand, (LPARAM)-2);

    HRESULT hres = S_OK;

    // first check to see if we even need to go into Ole drag, or if
    // it can all be contained within the rebar
    if (_PreDragDrop())
    {
        SHLoadOLE(SHELLNOTIFY_OLELOADED); // Browser Only - our shell32 doesn't know ole has been loaded
        hres = SHDoDragDrop(_hwnd, _pdtobj, NULL, dwEffect, &dwEffect);
    }
    else
    {
        // if we kept it all within win32 dragging, then set no drop effect
        dwEffect = DROPEFFECT_NONE;
    }

    SendMessage(_hwnd, RB_ENDDRAG, 0, 0);
    _fDragSource = FALSE;
    if (dwEffect & DROPEFFECT_MOVE) 
    {
        RemoveBand(dwBandID);
    } 
    else if (!dwEffect && hres == DRAGDROP_S_DROP) 
    {
        // if the drop was done, but the target didn't allow
        // then we float the band.
    }

    ATOMICRELEASE(_pdtobj);
}

HMENU CBandSite::_LoadContextMenu()
{
    return LoadMenuPopup_PrivateNoMungeW(MENU_BANDSITE1);
}

HRESULT CBandSite::_OnBSCommand(int idCmd, DWORD idBandActive, LPBANDITEMDATA pbid)
{
    HRESULT hr = S_OK;

    switch (idCmd)
    {
    case BSIDM_CLOSEBAND:
        _OnCloseBand(idBandActive);
        break;

    case BSIDM_SHOWTITLEBAND:
        ASSERT(idBandActive != (DWORD)-1 && pbid);
        if (pbid)
        {
            pbid->fNoTitle = !pbid->fNoTitle;
            _UpdateBandInfo(pbid, FALSE);
        }
        break;

    case BSIDM_IEAK_DISABLE_MOVE:
    case BSIDM_IEAK_DISABLE_DDCLOSE:
        ASSERT(idBandActive != (DWORD)-1);
        if (idBandActive != (DWORD)-1)
        {
            static const int idCmds[]  = { BSIDM_IEAK_DISABLE_MOVE,   BSIDM_IEAK_DISABLE_DDCLOSE  };
            static const int idFlags[] = { BAND_ADMIN_NOMOVE,         BAND_ADMIN_NODDCLOSE        };

            DWORD dwFlag = SHSearchMapInt(idCmds, idFlags, ARRAYSIZE(idCmds), idCmd);
            DWORD dwAdminSettings = _GetAdminSettings(idBandActive);

            // Toggle Setting.
            ToggleFlag(dwAdminSettings, dwFlag);

            // Set Menu Item Check Mark appropriately.
            _SetAdminSettings(idBandActive, dwAdminSettings);
        }
        break;

    default:
        ASSERT(0);
        hr = E_FAIL;
        break;
    }

    return hr;
}

// returns the index of the band hit by lParam using context menu semantics (lParam == -1 for keyboard)
int CBandSite::_ContextMenuHittest(LPARAM lParam, POINT* ppt)
{
    int iBandIndex;

    if (lParam == (LPARAM) -1)
    {
        // Keyboard activation.  Use active band.
        DWORD dwBandID = _BandIDFromPunk(_ptbActive);
        iBandIndex = _BandIDToIndex(dwBandID);

        LPBANDITEMDATA pbid = _GetBandItem(iBandIndex);
        if (pbid)
        {
            RECT rc;
            GetWindowRect(pbid->hwnd, &rc);
            ppt->x = rc.left;
            ppt->y = rc.top;
        }
    }
    else
    {
        // Mouse activation.  Figure out which band got clicked.
        RBHITTESTINFO rbht;

        ppt->x = GET_X_LPARAM(lParam);
        ppt->y = GET_Y_LPARAM(lParam);
        rbht.pt = *ppt;
        ScreenToClient(_hwnd, &rbht.pt);
        SendMessage(_hwnd, RB_HITTEST, 0, (LPARAM)&rbht);
        iBandIndex = rbht.iBand;
    }

    return iBandIndex;
}

HRESULT CBandSite::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_OK;

    HMENU hmenu = CreatePopupMenu();

    if (hmenu)
    {
        HRESULT hresT;
        int idCmd = 1;
        IContextMenu *pcm, *pcmParent = NULL, *pcmChild = NULL;

        POINT pt;
        int iBandIndex = _ContextMenuHittest(lParam, &pt);

        // map rebar index to band id
        // get band info for that band id
        DWORD idBandActive = _IndexToBandID(iBandIndex);
        LPBANDITEMDATA pbid = _GetBandItemDataStructByID(idBandActive);

        //
        // self (top)
        //
        int idCmdBS1 = idCmd;

        HMENU hmenuMe = _LoadContextMenu();
        if (hmenuMe)
        {
            BOOL fDeleteShowTitle = TRUE;
            if (pbid && !(_dwStyle & BSIS_LOCKED))
            {
                DESKBANDINFO dbi;

                CheckMenuItem(hmenuMe, BSIDM_SHOWTITLEBAND,
                    pbid->fNoTitle ? MF_BYCOMMAND|MF_UNCHECKED : MF_BYCOMMAND|MF_CHECKED);
                dbi.dwMask = 0;     // paranoia (and needed for taskband!)
                _GetBandInfo(pbid, &dbi);
                // make sure pbid in sync
                ASSERT((dbi.dwMask & DBIM_TITLE) || pbid->fNoTitle);
                if ((dbi.dwMask & DBIM_TITLE) && _IsEnableTitle(pbid))
                {
                    fDeleteShowTitle = FALSE;
                }
            }

            if (fDeleteShowTitle)
            {
                DeleteMenu(hmenuMe, BSIDM_SHOWTITLEBAND, MF_BYCOMMAND);
            }

            idCmd += Shell_MergeMenus(hmenu, hmenuMe, 0, idCmd, 0x7fff, 0) - (idCmd);
            DestroyMenu(hmenuMe);
        }

        //
        // child
        //
        int idCmdChild = idCmd;

        if (pbid && pbid->pdb)
        {
            // merge in band's menu (at front)
            hresT = pbid->pdb->QueryInterface(IID_PPV_ARG(IContextMenu, &pcmChild));
            if (SUCCEEDED(hresT))
            {
                // 0=at front
                hresT = pcmChild->QueryContextMenu(hmenu, 0, idCmd, 0x7fff, 0);
                if (SUCCEEDED(hresT))
                    idCmd += HRESULT_CODE(hresT);
            }
        }

        //
        // self (bottom)
        //
        int idCmdBS2 = idCmd;

        if (!(_dwStyle & BSIS_NOCONTEXTMENU))
        {
            hmenuMe = LoadMenuPopup_PrivateNoMungeW(MENU_BANDSITE2);
            if (hmenuMe)
            {
                // disable 'Close Band' if it's marked undeleteable
                // nash:17821: don't disable when 0 bands (so user can easily
                // get out of toasted mode)
                if ((idBandActive == (DWORD)-1) || // if mouse not over a band, delete close menu item
                    (!_IsBandDeleteable(idBandActive) ||
                     ISDDCLOSEDISABLED(idBandActive)) ||
                     (_dwStyle & BSIS_LOCKED))
                {
                    DeleteMenu(hmenuMe, BSIDM_CLOSEBAND, MF_BYCOMMAND);
                }

                if (!_fIEAKInstalled)
                {
                    DeleteMenu(hmenuMe, BSIDM_IEAK_DISABLE_DDCLOSE, MF_BYCOMMAND);
                    DeleteMenu(hmenuMe, BSIDM_IEAK_DISABLE_MOVE, MF_BYCOMMAND);
                }
                else
                {
                    DWORD dwAdminSettings = _GetAdminSettings(idBandActive);

                    if (IsFlagSet(dwAdminSettings, BAND_ADMIN_NODDCLOSE))
                        _CheckMenuItem(hmenuMe, BSIDM_IEAK_DISABLE_DDCLOSE, TRUE);

                    if (IsFlagSet(dwAdminSettings, BAND_ADMIN_NOMOVE))
                        _CheckMenuItem(hmenuMe, BSIDM_IEAK_DISABLE_MOVE, TRUE);
                }

                idCmd += Shell_MergeMenus(hmenu, hmenuMe, (UINT) -1, idCmd, 0x7fff, 0) - (idCmd);
                DestroyMenu(hmenuMe);
            }
        }

        //
        // parent
        //
        int idCmdParent = idCmd;
        
        if (_punkSite)
        {
            UINT uFlags = 0;
            ASSERT(_pcm3Parent == NULL);
            if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3Parent))))
            {
                uFlags |= CMF_ICM3;
            }

            hresT = _punkSite->QueryInterface(IID_PPV_ARG(IContextMenu, &pcmParent));
            if (SUCCEEDED(hresT))
            {
                // APPCOMPAT: fix parents and kids to handle...
                // we'd like to pass in -1 but not everyone handles that.
                // workaround: use _FixMenuIndex...
                hresT = pcmParent->QueryContextMenu(hmenu, _FixMenuIndex(hmenu, -1), idCmd, 0x7fff, uFlags);

                ASSERT(SUCCEEDED(hresT));
                idCmd += HRESULT_CODE(hresT);
            }
        }

        //
        // do it
        //
        {
            HWND hwndParent = GetParent(_hwnd);
            if (!hwndParent)
                hwndParent = _hwnd;
            idCmd = TrackPopupMenu(hmenu,
                                   TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                   pt.x, pt.y, 0, hwndParent, NULL);
        }

        if (idCmd)
        {
            // must test from smallest to largest
            ASSERT(idCmdBS1 <= idCmdChild);
            ASSERT(idCmdChild <= idCmdBS2);    // o.w. test in wrong order
            ASSERT(idCmdBS2 <= idCmdParent);

            if ((idCmd>= idCmdBS1) && (idCmd < idCmdChild))
            {
                idCmd -= idCmdBS1;
                hres = _OnBSCommand(idCmd, idBandActive, pbid);
            }
            else if ((idCmd>= idCmdBS2) && (idCmd < idCmdParent))
            {
                idCmd -= idCmdBS2;
                hres = _OnBSCommand(idCmd, idBandActive, pbid);
            }
            else
            {
                // A parent or child command
                if (idCmd < idCmdParent)
                {
                    pcm = pcmChild;
                    idCmd -= idCmdChild;
                }
                else
                {
                    pcm = pcmParent;
                    idCmd -= idCmdParent;
                }

                ASSERT(pcm);

                //
                // Call InvokeCommand
                //
                CMINVOKECOMMANDINFOEX ici =
                {
                    SIZEOF(CMINVOKECOMMANDINFOEX),
                    0L,
                    _hwnd,
                    (LPSTR)MAKEINTRESOURCE(idCmd),
                    NULL, NULL,
                    SW_NORMAL,
                };

                hres = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
            }
        }

        ATOMICRELEASE(_pcm3Parent);

        if (pcmParent)
            pcmParent->Release();
        if (pcmChild)
            pcmChild->Release();
        
        DestroyMenu(hmenu);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

         Processes messages passed on from the bar.  Forward
         messages to the bands as appropriate.

*/
HRESULT CBandSite::OnWinEvent(HWND h, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = E_FAIL;
    HWND hwnd = HWND_BROADCAST;
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        _UpdateAllBands(FALSE, FALSE);
        goto L_WM_SYSCOLORCHANGE;

    case WM_SYSCOLORCHANGE:
    case WM_PALETTECHANGED:
    L_WM_SYSCOLORCHANGE:
        // propagate to rebar
        if (_hwnd)
            SendMessage(_hwnd, uMsg, wParam, lParam);

        // by not returning here, it will get forwarded to the bands also... 
        break;
        
    case WM_CONTEXTMENU:
        // if it came from the keyboard, wParam is somewhat useless.  it's always out hwnd
        if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
            hwnd = GetFocus();
        else
            hwnd = (HWND)wParam;
        break;

    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
            
    case WM_NOTIFY:
        if (lParam)
            hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;

    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        if (_pcm3Parent)
        {
            //
            // If _pcm3Parent, then we've got a context menu up and 
            // an ICM3 client who might care about this message.
            //
            hwnd = _hwnd;
        }
        break;

    default:
        return E_FAIL;
    }
    
    LRESULT lres = 0;
    
    if (hwnd)
    {
        if (_hwnd == hwnd)
        {
            // a message for us
            switch (uMsg)
            {
            case WM_NOTIFY:
                lres = _OnNotify((LPNMHDR)lParam);
                hres = S_OK;
                break;

            case WM_COMMAND:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case IDM_DRAGDROP:
                    _DoDragDrop();
                    break;
                }
                break;

            case WM_INITMENUPOPUP:
            case WM_MEASUREITEM:
            case WM_DRAWITEM:
            case WM_MENUCHAR:
                ASSERT(_pcm3Parent);
                hres = _pcm3Parent->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
                break;
            }
        }
        else
        {
            if (_SendToToolband(hwnd, uMsg, wParam, lParam, &lres))
                hres = S_OK;
        }
    }
    
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        SendMessage(_hwnd, WM_SIZE, 0, 0);
        break;

    case WM_CONTEXTMENU:
        if (!lres)
            return _OnContextMenu(wParam, lParam);
        break;
    }

    if (plres)
        *plres = lres;
    
    return hres;
}

HRESULT CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CBandSite *pbs = new CBandSite(pUnkOuter);
    if (pbs)
    {
        *ppunk = pbs->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

//*** CBandSite::IPersistStream*::* {
//

HRESULT CBandSite::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_RebarBandSite;
    return S_OK;
}

HRESULT CBandSite::IsDirty(void)
{
    ASSERT(0);
    return S_FALSE; // FEATURE: never be dirty?
}

HRESULT CBandSite::_AddBand(IUnknown* punk)
{
    if (_pbsOuter)
    {
        // Give the outer guy first crack
        return _pbsOuter->AddBand(punk);
    }
    else
    {
        return AddBand(punk);
    }
}

//
// Persisted CBandSite, use types that have fixes sizes
//
struct SBandSite
{
    DWORD   cbSize;
    DWORD   cbVersion;
    DWORD   cBands;
    // ...followed by length-preceded bands
};

#define SBS_WOADMIN_VERSION 3   // Before we added admin settings.
#define SBS_VERSION 8

//***   CBandSite::Load, Save -- 
// DESCRIPTION
//  for each band...
//  Load            Read (i); OLFS(obj)+AddBand; Read (rbbi); RB_SBI
//  Save    RB_GBI; Write(i); OSTS(obj)+nil    ; Write(rbbi)
// NOTES
//  FEATURE: needs error recovery
//  WARNING: we might have done a CreateBand w/o an AddBand; if so our
//  assumption about the rebar bands and the iunknowns being 'parallel'
//  is bogus.

HRESULT CBandSite::Load(IStream *pstm)
{
    HRESULT hres;
    SBandSite sfoo;

    hres = IStream_Read(pstm, &sfoo, SIZEOF(sfoo));     // pstm->Read
    if (hres == S_OK)
    {
        if (!(sfoo.cbSize == SIZEOF(SBandSite) &&
          (sfoo.cbVersion == SBS_VERSION || sfoo.cbVersion == SBS_WOADMIN_VERSION)))
        {
            hres = E_FAIL;
        }

        IBandSiteHelper *pbsh;
        hres = QueryInterface(IID_PPV_ARG(IBandSiteHelper, &pbsh));
        if (EVAL(SUCCEEDED(hres)))
        {
            BOOL_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
            for (DWORD i = 0; i < sfoo.cBands && SUCCEEDED(hres); ++i)
            {
                DWORD j;
                hres = IStream_Read(pstm, &j, SIZEOF(j));   // pstm->Read
                if (hres == S_OK)
                {
                    if (j == i)             // for sanity check
                    {
                        IUnknown* punk;
                        hres = pbsh->LoadFromStreamBS(pstm, IID_PPV_ARG(IUnknown, &punk));
                        if (SUCCEEDED(hres))
                        {
                            hres = _AddBand(punk);
                            if (SUCCEEDED(hres))
                            {
                                hres = _LoadBandInfo(pstm, i, sfoo.cbVersion);
                            }
                            punk->Release();
                        }
                    }
                    else
                    {
                        hres = E_FAIL;
                    }
                }
            }
            SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);

            pbsh->Release();
        }

        _UpdateAllBands(FALSE, TRUE);     // force refresh
    }

    return hres;
}

HRESULT CBandSite::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SBandSite sfoo;
    
    TraceMsg(DM_PERSIST, "cbs.s enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    sfoo.cbSize = SIZEOF(SBandSite);
    sfoo.cbVersion = SBS_VERSION;
    sfoo.cBands = _GetBandItemCount();
    TraceMsg(DM_PERSIST, "cdb.s: cbands=%d", sfoo.cBands);

    hres = pstm->Write(&sfoo, SIZEOF(sfoo), NULL);
    if (SUCCEEDED(hres))
    {
        for (DWORD i = 0; i < sfoo.cBands; i++) 
        {
            // FEATURE: put seek ptr so can resync after bogus streams
            hres = pstm->Write(&i, SIZEOF(i), NULL);    // for sanity check
            if (SUCCEEDED(hres))
            {
                LPBANDITEMDATA pbid = _GetBandItem(i);
                if (EVAL(pbid) && pbid->pdb)
                {
                    IBandSiteHelper *pbsh;
                    hres = QueryInterface(IID_PPV_ARG(IBandSiteHelper, &pbsh));
                    if (SUCCEEDED(hres)) 
                    {
                        hres = pbsh->SaveToStreamBS(SAFECAST(pbid->pdb, IUnknown*), pstm);
                        pbsh->Release();
                    }
                }

                hres = _SaveBandInfo(pstm, i);
                ASSERT(SUCCEEDED(hres));
            }
        }
    }

    TraceMsg(DM_PERSIST, "cbs.s leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CBandSite::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    static const ULARGE_INTEGER cbMax = { SIZEOF(SBandSite), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

BOOL CBandSite::_IsHeightReasonable(UINT cy)
{
    static UINT s_cyMon = 0;
    if (s_cyMon == 0)
    {
        HMONITOR hmon = MonitorFromWindow(_hwnd, MONITOR_DEFAULTTONEAREST);
        if (hmon)
        {
            RECT rc;
            if (GetMonitorRect(hmon, &rc))
            {
                s_cyMon = RECTHEIGHT(rc);
            }
        }
    }

    return (s_cyMon != 0) ? (cy < 4 * s_cyMon) : TRUE;
}

// returns: IStream::Read() semantics, S_OK means complete read

HRESULT CBandSite::_LoadBandInfo(IStream *pstm, int i, DWORD dwVersion)
{
    PERSISTBANDINFO bi;
    HRESULT hres;
    DWORD dwSize = SIZEOF(bi);
    bi.dwAdminSettings = BAND_ADMIN_NORMAL;     // Assume Normal since it's not specified

    if (SBS_WOADMIN_VERSION == dwVersion)
        dwSize = SIZEOF(PERSISTBANDINFO_V3);

    hres = IStream_Read(pstm, &bi, dwSize);     // pstm->Read
    if (hres == S_OK)
    {
        //
        // Sanity-check the height specified by PERSISTBANDINFO before proceeding.
        // Some people are hitting a stress scenario where a bad height gets
        // persisted out.  If the height is not reasonable, then just discard
        // the sizing values (leaving the defaults in place).
        //
        if (_IsHeightReasonable(bi.cyChild))
        {
            REBARBANDINFO rbbi;

            rbbi.cbSize = SIZEOF(rbbi);
            rbbi.fMask = RBBIM_XPERSIST;
            rbbi.cx = bi.cx;
            rbbi.fStyle = bi.fStyle;
            
            // these things can change from instantiation to instantiation.
            // we want to restore the visual state, not the sizing rules.
            // the sizing rules re retreived each time in getbandinfo
            rbbi.cyMinChild = -1;
            rbbi.cyMaxChild = -1;
            rbbi.cyIntegral = -1;
            rbbi.cxMinChild = -1;

            if (rbbi.fStyle & RBBS_VARIABLEHEIGHT)
            {
                rbbi.cyChild = bi.cyChild;
            }
            else
            {
                rbbi.cyMinChild = bi.cyMinChild;
            }

            SendMessage(_hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
        }

        LPBANDITEMDATA pbid = _GetBandItem(i);
        if (pbid)
        {
            pbid->dwAdminSettings = bi.dwAdminSettings;
            pbid->fNoTitle = bi.fNoTitle;
        }
    }
    return hres;
}

HRESULT CBandSite::_SaveBandInfo(IStream *pstm, int i)
{
    REBARBANDINFO rbbi = {0};
    PERSISTBANDINFO bi = {0};
    LPBANDITEMDATA pbid;

    rbbi.cbSize = SIZEOF(rbbi);
    rbbi.fMask = RBBIM_XPERSIST;
    SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi);

    ASSERT((rbbi.fMask & RBBIM_XPERSIST) == RBBIM_XPERSIST);

    bi.cx = rbbi.cx;
    bi.fStyle = rbbi.fStyle;
    bi.cyMinChild = rbbi.cyMinChild;
    bi.cyChild = rbbi.cyChild;

    pbid = _GetBandItem(i);
    if (pbid)
    {
        bi.dwAdminSettings = pbid->dwAdminSettings;
        bi.fNoTitle = pbid->fNoTitle;
    }

    return pstm->Write(&bi, SIZEOF(bi), NULL);
}

void CBandSite::_CacheActiveBand(IUnknown *ptb)
{
    if (ptb == _ptbActive)
        return;

    if (SHIsSameObject(ptb, _ptbActive))
        return;

    ATOMICRELEASE(_ptbActive);

    if (ptb != NULL) 
    {
#ifdef DEBUG
        // better be an IInputObject or else why did you call us?
        IInputObject *pio;
        if (EVAL(SUCCEEDED(ptb->QueryInterface(IID_PPV_ARG(IInputObject, &pio)))))
            pio->Release();

        // overly strict, but in our case it's true...
        IDeskBand *pdb;
        if (EVAL(SUCCEEDED(ptb->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb)))))
            pdb->Release();
#endif
        _ptbActive = ptb;
        _ptbActive->AddRef();
    }

    return;
}

DWORD CBandSite::_BandIDFromPunk(IUnknown* punk)
{
    DWORD dwBandID = -1;
    DWORD dwBandIDTest;
    int cBands = EnumBands(-1, NULL);
    IUnknown* punkTest;

    if (punk)
    {
        for (int i = 0; i < cBands; i++)
        {
            if (SUCCEEDED(EnumBands(i, &dwBandIDTest)))
            {
                if (SUCCEEDED(GetBandObject(dwBandIDTest, IID_PPV_ARG(IUnknown, &punkTest))))
                {
                    BOOL fEq = SHIsSameObject(punk, punkTest);

                    punkTest->Release();

                    if (fEq)
                    {
                        dwBandID = dwBandIDTest;
                        break;
                    }
                }
            }
        }
    }

    return dwBandID;
}

//*** IInputObjectSite methods ***

HRESULT CBandSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    if (_ptbActive)
    {
        if (!SHIsSameObject(_ptbActive, punk))
        {
            // Deactivate current band since the current band is 
            // not the caller
            TraceMsg(TF_ACCESSIBILITY, "CBandSite::OnFocusChangeIS (hwnd=0x%08X) deactivate band", _hwnd);
            UIActivateIO(FALSE, NULL);
        }
    }

    if (fSetFocus)
        _CacheActiveBand(punk);

    return IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), fSetFocus);
}


//*** IInputObject methods ***

HRESULT CBandSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres = E_FAIL;

    TraceMsg(TF_ACCESSIBILITY, "CBandSite::UIActivateIO (hwnd=0x%08X) fActivate=%d", _hwnd, fActivate);
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (_ptbActive)
    {
        hres = IUnknown_UIActivateIO(_ptbActive, fActivate, lpMsg);
    }
    else
    {
        hres = OnFocusChangeIS(NULL, fActivate);
    }

    if (fActivate)
    {
        if (!_ptbActive)
        {
            if (IsVK_TABCycler(lpMsg))
                hres = _CycleFocusBS(lpMsg);
            else
                hres = S_OK;
        }
    }
    else
    {
        _CacheActiveBand(NULL);
    }

    return hres;
}

HRESULT CBandSite::HasFocusIO()
{
    // Rebar should never get focus
    // NT #288832 Is one case where (GetFocus() == _hwnd)
    //    which is caused when the "Folder Bar" disappears.
    //    CExplorerBand::ShowDW() calls ShowWindow(hwndTreeView, SW_HIDE)
    //    which by default sets focus to the parent (us).
    //    This is ok because when this function is called,
    //    it will return E_FAIL which the caller will treat
    //    as S_FALSE and give the focus to the next deserving
    //    dude in line.
    return IUnknown_HasFocusIO(_ptbActive);
}

HRESULT CBandSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, lpMsg->wParam);
    if (IUnknown_TranslateAcceleratorIO(_ptbActive, lpMsg) == S_OK)
    {
        TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d; handled by active band", _hwnd, lpMsg->wParam);
        // active band handled it
        return S_OK;
    }
    else if (IsVK_TABCycler(lpMsg))
    {
        TraceMsg(TF_ACCESSIBILITY, "CBandSite::TranslateAcceleratorIO (hwnd=0x%08X) cycle focus", _hwnd);
        // it's a tab; cycle focus
        return _CycleFocusBS(lpMsg);
    }

    return S_FALSE;
}

int CBandSite::_BandIndexFromPunk(IUnknown *punk)
{
    for (int i = 0; i < _GetBandItemCount(); i++)
    {
        LPBANDITEMDATA pbid = _GetBandItem(i);

        if (EVAL(pbid) && SHIsSameObject(pbid->pdb, punk))
            return i;
    }

    return -1;
}

BOOL CBandSite::_IsBandTabstop(LPBANDITEMDATA pbid)
{
    // A band is a tabstop if it is visible and has WS_TABSTOP

    if (pbid->fShow && pbid->hwnd && IsWindowVisible(pbid->hwnd))
    {
        if (WS_TABSTOP & GetWindowStyle(pbid->hwnd))
            return TRUE;
    }

    return FALSE;
}

#define INCDEC(i, fDec)   (fDec ? i - 1 : i + 1)

IUnknown* CBandSite::_GetNextTabstopBand(IUnknown* ptb, BOOL fBackwards)
{
    // Find the first tabstop candidate
    int iBandCount = _GetBandItemCount();
    int iBand = _BandIndexFromPunk(ptb);
    
    if (iBand == -1)
    {
        // Start at the end/beginning
        if (fBackwards)
            iBand = iBandCount - 1;
        else
            iBand = 0;
    }
    else
    {
        // Start one off the current band
        iBand = INCDEC(iBand, fBackwards);
    }

    // Loop til we find a tabstop band or we run off the end
    while (0 <= iBand && iBand < iBandCount)
    {
        LPBANDITEMDATA pbid = _GetBandItem(iBand);
        if (EVAL(pbid))
        {
            if (_IsBandTabstop(pbid))
                return pbid->pdb;
        }

        // Try the next band
        iBand = INCDEC(iBand, fBackwards);
    }

    return NULL;
}

HRESULT CBandSite::_CycleFocusBS(LPMSG lpMsg)
{
    HRESULT hr = S_FALSE;

    IUnknown* ptbSave = NULL;

    if (_ptbActive)
    {
        // Save off the active band in ptbSave
        ptbSave = _ptbActive;
        ptbSave->AddRef();

        // Deactivate active band and clear cache
        IUnknown_UIActivateIO(_ptbActive, FALSE, NULL);
        _CacheActiveBand(NULL);
    }

    if (ptbSave && IsVK_CtlTABCycler(lpMsg))
    {
        // If ctl-tab and a band was active, then reject focus
        ASSERT(hr == S_FALSE);
    }
    else
    {
        BOOL fShift = (GetKeyState(VK_SHIFT) < 0);

        // Loop til we find a tabstop and successfully activate it
        // or til we run out of bands.

        // FEATURE: todo -- call SetFocus if UIActivateIO fails?

        IUnknown* ptbNext = ptbSave;
        while (ptbNext = _GetNextTabstopBand(ptbNext, fShift))
        {
            if (IUnknown_UIActivateIO(ptbNext, TRUE, lpMsg) == S_OK)
            {
                hr = S_OK;
                break;
            }
        }
    }

    ATOMICRELEASE(ptbSave);

    return hr;
}

//*** CBandSite::IBandSiteHelper::* {

// stuff to make it possible to overload the OleLoad/Save stuff so the
// taskbar band does not have to be CoCreat able. kinda a hack...

HRESULT CBandSite::LoadFromStreamBS(IStream *pstm, REFIID riid, void **ppv)
{
    return OleLoadFromStream(pstm, riid, ppv);
}

HRESULT CBandSite::SaveToStreamBS(IUnknown *punk, IStream *pstm)
{
    IPersistStream *ppstm;
    HRESULT hres = punk->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
    if (SUCCEEDED(hres)) 
    {
        hres = OleSaveToStream(ppstm, pstm);
        ppstm->Release();
    }
    return hres;
}

// }


// *** IDropTarget *** {

HRESULT CBandSite::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(TF_BANDDD, "CBandSite::DragEnter %d %d", pt.x, pt.y);

    if (!_fDragSource)
    {
        FORMATETC fmte = {g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        _dwDropEffect = DROPEFFECT_NONE;
        
        if (pdtobj->QueryGetData(&fmte) == S_OK)
        {
            _dwDropEffect = DROPEFFECT_MOVE;
        }
        else
        {

            LPITEMIDLIST pidl;

            if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
            {
                ASSERT(pidl && IS_VALID_PIDL(pidl));

                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;
                IEGetAttributesOf(pidl, &dwAttrib);
                ILFree(pidl);

                DWORD   dwRAction;
        
                if (FAILED(IUnknown_HandleIRestrict(_punkSite, &RID_RDeskBars, RA_DROP, NULL, &dwRAction)))
                    dwRAction = RR_ALLOW;

                if (dwRAction == RR_DISALLOW)
                    _dwDropEffect = DROPEFFECT_NONE;
                else
                {                
                    // if it's not a folder nor a browseable object, we can't host it.
                    if ((dwAttrib & SFGAO_FOLDER) ||
                        (dwAttrib & SFGAO_BROWSABLE) && (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT)) 
                        _dwDropEffect = DROPEFFECT_LINK | DROPEFFECT_COPY;

                    _dwDropEffect |= GetPreferedDropEffect(pdtobj);
                }
            }
        }
        *pdwEffect &= _dwDropEffect;
    }
    
    return S_OK;
}

HRESULT CBandSite::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    TraceMsg(TF_BANDDD, "CBandSite::DragOver %d %d", ptl.x, ptl.y);
    if (_fDragSource)
    {
        RECT rc;
        POINT pt;
        pt.x = ptl.x;
        pt.y = ptl.y;
        GetWindowRect(_hwnd, &rc);
        if (PtInRect(&rc, pt))
            SendMessage(_hwnd, RB_DRAGMOVE, 0, (LPARAM)-1);
    }
    else
    {
        *pdwEffect &= _dwDropEffect;
    }
    return S_OK;    
}

HRESULT CBandSite::DragLeave(void)
{
    return S_OK;
}

HRESULT CBandSite::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = E_FAIL;
    
    TraceMsg(TF_BANDDD, "CBandSite::Drop");
    if (_fDragSource)
    {
        SendMessage(_hwnd, RB_ENDDRAG, 0, 0);
        *pdwEffect = DROPEFFECT_NONE;
        hres = S_OK;
    }
    else
    {
        FORMATETC fmte = {g_cfDeskBand, NULL, 0, -1, TYMED_ISTREAM};
        STGMEDIUM stg;
        IUnknown *punk = NULL;
        LPITEMIDLIST pidl;
        
        // if it was an object of our type, create it!
        if ((*pdwEffect & DROPEFFECT_MOVE) &&
            SUCCEEDED(pdtobj->GetData(&fmte, &stg)))
        {

            hres = OleLoadFromStream(stg.pstm, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hres))
            {
                *pdwEffect = DROPEFFECT_MOVE;
            }

            ReleaseStgMedium(&stg);
        } 
        else if ((*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_LINK)) &&
                 SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {

            hres = SHCreateBandForPidl(pidl, &punk, (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT));
            ILFree(pidl);

            if (SUCCEEDED(hres))
            {
                if (*pdwEffect & DROPEFFECT_LINK)
                    *pdwEffect = DROPEFFECT_LINK;
                else
                    *pdwEffect = DROPEFFECT_COPY;
            }
        }
    
        if (punk)
        {
            hres = _AddBand(punk);

            if (SUCCEEDED(hres))
            {
                DWORD dwState;

                dwState = IDataObject_GetDeskBandState(pdtobj);
                SetBandState(ShortFromResult(hres), BSSF_NOTITLE, dwState & BSSF_NOTITLE);
            }

            punk->Release();
        }
    }
    
    if (FAILED(hres)) 
        *pdwEffect = DROPEFFECT_NONE;
    return hres;
}

// }

//***   ::_MergeBS -- merge two bandsites into one
// ENTRY/EXIT
//  pdtDst  [INOUT] destination DropTarget (always from bandsite)
//  pbsSrc  [INOUT] source bandsite; deleted if all bands moved successfully
//  ret     S_OK if all bands moved; S_FALSE if some moved; E_* o.w.
// NOTES
//  note that if all the bands are moved successfully, pbsSrc will be deleted
//  as a side-effect.
//  pdtDst is assumed to accept multiple drops (bandsite does).
//  pdtDst may be from marshal/unmarshal (tray bandsite).
HRESULT _MergeBS(IDropTarget *pdtDst, IBandSite *pbsSrc)
{
    HRESULT hres = E_FAIL;
    DWORD idBand;

    pbsSrc->AddRef();           // don't go away until we're all done!

    // drag each band in turn
    while (SUCCEEDED(pbsSrc->EnumBands(0, &idBand)))
    {
        // note our (bogus?) assumption that bands which can't be
        // dragged will percolate down to a contiguous range of
        // iBands 0..n.  if that's bogus i'm not sure how we can
        // keep track of where we are.

        IDataObject *pdoSrc;
        hres = pbsSrc->GetBandObject(idBand, IID_PPV_ARG(IDataObject, &pdoSrc));
        if (SUCCEEDED(hres))
        {
            DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;
            hres = SHSimulateDrop(pdtDst, pdoSrc, 0, NULL, &dwEffect);
            pdoSrc->Release();

            if (SUCCEEDED(hres) && (dwEffect & DROPEFFECT_MOVE))
            {
                hres = pbsSrc->RemoveBand(idBand);
                ASSERT(SUCCEEDED(hres));
            }
        }

        // we failed to move the band, bail

        if (FAILED(hres))
        {
            ASSERT(0);
            break;
        }
    }

    pbsSrc->Release();

    TraceMsg(DM_DRAG, "dba.ms: ret hres=%x", hres);
    return hres;
}


void CBandSite::_BandItemEnumCallback(int dincr, PFNBANDITEMENUMCALLBACK pfnCB, void *pv)
{
    UINT iFirst = 0;

    ASSERT(dincr == 1 || dincr == -1);
    if (dincr < 0)
    {
        iFirst = _GetBandItemCount() - 1;  // start from last
    }

    for (UINT i = iFirst; i < (UINT) _GetBandItemCount(); i += dincr)
    {
        LPBANDITEMDATA pbid = _GetBandItem(i);
        if (pbid && !pfnCB(pbid, pv))
            break;
    }
}

void CBandSite::_DeleteAllBandItems()
{
    for (int i = _GetBandItemCount() - 1; i >= 0; i--)
    {
        LPBANDITEMDATA pbid = _GetBandItem(i);

        // Release the banditem data first, while it can still
        // receive cleanup notifications from its control.  *Then*
        // delete the band item.
        if (pbid)
            _ReleaseBandItemData(pbid, i);

        // REARCHITECT: chrisfra 5/13/97 if you skip deleting, rebar can
        // rearrange on delete, moving a band so that it is never seen
        // and consequently we leak BrandBand and much else
        _DeleteBandItem(i);    // unhook from host (rebar)
    }
}

LPBANDITEMDATA CBandSite::_GetBandItem(int i)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = SIZEOF(rbbi);
    rbbi.fMask = RBBIM_LPARAM;
    rbbi.lParam = NULL; // in case of failure below

    if (_hwnd)
        SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi);
    return (LPBANDITEMDATA)rbbi.lParam;
}

int CBandSite::_GetBandItemCount()
{
    int cel = 0;

    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));

        cel = (int)SendMessage(_hwnd, RB_GETBANDCOUNT, 0, 0);
    }
    return cel;
}

void CBandSite::_GetBandInfo(LPBANDITEMDATA pbid, DESKBANDINFO *pdbi)
{
    pdbi->dwMask = DBIM_MINSIZE | DBIM_MAXSIZE | DBIM_INTEGRAL | DBIM_ACTUAL | DBIM_TITLE | DBIM_MODEFLAGS | DBIM_BKCOLOR;
                 
    pdbi->ptMinSize = pbid->ptMinSize;
    pdbi->ptMaxSize = pbid->ptMaxSize;
    pdbi->ptIntegral = pbid->ptIntegral;
    pdbi->ptActual = pbid->ptActual;
    StrCpyW(pdbi->wszTitle, pbid->szTitle);
    pdbi->dwModeFlags = pbid->dwModeFlags;
    pdbi->crBkgnd = pbid->crBkgnd;
    
    if (pbid->pdb)
    {
        pbid->pdb->GetBandInfo(pbid->dwBandID, _dwMode, pdbi);
    }
    if (pdbi->wszTitle[0] == 0)
    {
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    pbid->ptMinSize = pdbi->ptMinSize;
    pbid->ptMaxSize = pdbi->ptMaxSize;
    pbid->ptIntegral = pdbi->ptIntegral;
    pbid->ptActual = pdbi->ptActual;
    StrCpyW(pbid->szTitle, pdbi->wszTitle);
    pbid->dwModeFlags = pdbi->dwModeFlags;
    pbid->crBkgnd = pdbi->crBkgnd;

    if (!(pdbi->dwMask & DBIM_TITLE))   // title not supported
        pbid->fNoTitle = TRUE;

    ASSERT(pdbi->dwModeFlags & DBIMF_VARIABLEHEIGHT ? pbid->ptIntegral.y : TRUE);
}

void CBandSite::_BandInfoFromBandItem(REBARBANDINFO *prbbi, LPBANDITEMDATA pbid, BOOL fBSOnly)
{
    // REVIEW: could be optimized more
    DESKBANDINFO dbi;

    if (!fBSOnly)
        _GetBandInfo(/*INOUT*/ pbid, &dbi);

    // now add the view as a band in the rebar
    // add links band
    prbbi->fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_IDEALSIZE | RBBIM_TEXT;
    if (fBSOnly)
        prbbi->fMask = RBBIM_STYLE|RBBIM_TEXT;

    // clear the bits the are band settable
    prbbi->fStyle |= RBBS_FIXEDBMP;
    prbbi->fStyle &= ~(RBBS_NOGRIPPER | RBBS_GRIPPERALWAYS | RBBS_VARIABLEHEIGHT | RBBS_USECHEVRON);

    if (_dwStyle & BSIS_NOGRIPPER)    
        prbbi->fStyle |= RBBS_NOGRIPPER;
    else if (_dwStyle & BSIS_ALWAYSGRIPPER)    
        prbbi->fStyle |= RBBS_GRIPPERALWAYS;
    else
    {
        // BSIS_AUTOGRIPPER...
        if (!(prbbi->fStyle & RBBS_FIXEDSIZE) &&
            !(_dwMode & DBIF_VIEWMODE_FLOATING))
            prbbi->fStyle |= RBBS_GRIPPERALWAYS;
    }

    if (pbid->dwModeFlags & DBIMF_VARIABLEHEIGHT) 
        prbbi->fStyle |= RBBS_VARIABLEHEIGHT;

    if (pbid->dwModeFlags & DBIMF_USECHEVRON)
        prbbi->fStyle |= RBBS_USECHEVRON;

    if (pbid->dwModeFlags & DBIMF_BREAK)
        prbbi->fStyle |= RBBS_BREAK;

    if (pbid->dwModeFlags & DBIMF_TOPALIGN)
        prbbi->fStyle |= RBBS_TOPALIGN;

    if (!fBSOnly)
    {
        prbbi->hwndChild = pbid->hwnd;
        prbbi->wID = pbid->dwBandID;

        // set up the geometries
        prbbi->cxMinChild = pbid->ptMinSize.x;
        prbbi->cyMinChild = pbid->ptMinSize.y;
        prbbi->cyMaxChild = pbid->ptMaxSize.y;
        prbbi->cyIntegral = pbid->ptIntegral.y;

        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL)) 
        {
            // after we're up, it's the "ideal" point
            prbbi->cxIdeal = pbid->ptActual.y;
        } 
        else 
        {
            // after we're up, it's the "ideal" point
            prbbi->cxIdeal = pbid->ptActual.x;
        }

        if (prbbi->cxIdeal == (UINT)-1)
            prbbi->cxIdeal = 0;

        if (pbid->dwModeFlags & DBIMF_BKCOLOR)
        {
            if (dbi.dwMask & DBIM_BKCOLOR)
            {
                prbbi->fMask |= RBBIM_COLORS;
                prbbi->clrFore = CLR_DEFAULT;
                prbbi->clrBack = dbi.crBkgnd;
            }
        }
        ASSERT(pbid->fNoTitle || (dbi.dwMask & DBIM_TITLE));    // pbid in sync?
    }

    SHUnicodeToTChar(pbid->szTitle, prbbi->lpText, prbbi->cch);
    if (!pbid->fNoTitle && _IsEnableTitle(pbid) && !(_dwStyle & BSIS_NOCAPTION))
    {
        prbbi->fStyle &= ~RBBS_HIDETITLE;
    }
    else
    {
        // No text please
        prbbi->fStyle |= RBBS_HIDETITLE;
    }
        

    // Make this band a tabstop.  Itbar will override v_SetTabstop
    // since for the browser we don't want every band to be a tabstop.
    v_SetTabstop(prbbi);
}

void CBandSite::v_SetTabstop(LPREBARBANDINFO prbbi)
{
    // We specify that a band should be a tabstop by setting the WS_TABSTOP
    // bit.  Never make RBBS_FIXEDSIZE bands (i.e., the brand) tabstops.
    if (prbbi && prbbi->hwndChild && !(prbbi->fStyle & RBBS_FIXEDSIZE))
        SHSetWindowBits(prbbi->hwndChild, GWL_STYLE, WS_TABSTOP, WS_TABSTOP);
}

//***   cbs::_IsEnableTitle -- should we enable (ungray) title
// DESCRIPTION
//  used for handing back title and for enabling menu
// NOTES
//  pbid unused...
//
#ifndef UNIX
_inline
#endif
BOOL CBandSite::_IsEnableTitle(LPBANDITEMDATA pbid)
{
    ASSERT(pbid);
    return (/*pbid && !pbid->fNoTitle &&*/
      !((_dwMode & DBIF_VIEWMODE_FLOATING) && _GetBandItemCount() <= 1));
}

BOOL CBandSite::_UpdateBandInfo(LPBANDITEMDATA pbid, BOOL fBSOnly)
{
    REBARBANDINFO rbbi = {SIZEOF(rbbi)};
    int iRB = _BandIDToIndex(pbid->dwBandID);

    // now update the info
    rbbi.fMask = RBBIM_ID | RBBIM_CHILDSIZE | RBBIM_SIZE | RBBIM_STYLE;
    if (fBSOnly)
        rbbi.fMask = RBBIM_STYLE;

    SendMessage(_hwnd, RB_GETBANDINFO, iRB, (LPARAM)&rbbi);

    if (!fBSOnly)
    {
        if (_dwMode & (DBIF_VIEWMODE_FLOATING | DBIF_VIEWMODE_VERTICAL)) 
        {
            pbid->ptActual.x = rbbi.cyChild;
            pbid->ptActual.y = rbbi.cxIdeal;
        } 
        else 
        {
            pbid->ptActual.x = rbbi.cxIdeal;
            pbid->ptActual.y = rbbi.cyChild;
        }
        pbid->ptMinSize.x = rbbi.cxMinChild;
        pbid->ptMinSize.y = rbbi.cyMinChild;
        pbid->ptMaxSize.y = rbbi.cyMaxChild;
    }

    TCHAR szBand[40];
    rbbi.lpText = szBand;
    rbbi.cch = ARRAYSIZE(szBand);

    _BandInfoFromBandItem(&rbbi, pbid, fBSOnly);
    
    return BOOLFROMPTR(SendMessage(_hwnd, RB_SETBANDINFO, (UINT)iRB, (LPARAM)&rbbi));
}

BOOL CBandSite::_AddBandItem(LPBANDITEMDATA pbid)
{
    REBARBANDINFO rbbi = {SIZEOF(rbbi)};

    pbid->ptActual.x = -1;
    pbid->ptActual.y = -1;

    TCHAR szBand[40];
    rbbi.lpText = szBand;
    rbbi.cch = ARRAYSIZE(szBand);

    _BandInfoFromBandItem(&rbbi, pbid, FALSE);

    rbbi.cyChild = pbid->ptActual.y;
    rbbi.fMask |= RBBIM_LPARAM;
    rbbi.lParam = (LPARAM)pbid;

    ASSERT(rbbi.fMask & RBBIM_ID);

    return BOOLFROMPTR(SendMessage(_hwnd, RB_INSERTBAND, (UINT) (pbid->dwModeFlags & DBIMF_ADDTOFRONT) ? 0 : -1, (LPARAM)&rbbi));
}

void CBandSite::_DeleteBandItem(int i)
{
    SendMessage(_hwnd, RB_DELETEBAND, i, 0);
}

DWORD CBandSite::_IndexToBandID(int i)
{
    REBARBANDINFO rbbi = {SIZEOF(rbbi)};
    rbbi.fMask = RBBIM_ID;

    if (SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi))
        return rbbi.wID;
    else
        return -1;
}


/*----------------------------------------------------------
Purpose: Given the band ID, returns the internal band index.

*/
int CBandSite::_BandIDToIndex(DWORD dwBandID)
{
    int nRet = -1;

    if (_hwnd)
        nRet = (int)SendMessage(_hwnd, RB_IDTOINDEX, (WPARAM) dwBandID, (LPARAM) 0);
    return nRet;
}


/*----------------------------------------------------------
Purpose: The Parent Site may want to override what the admin
         specified.

Return Values:
    S_OK: Do lock band.
    S_FALSE: Do NOT Lock band.

*/
HRESULT CBandSite::_IsRestricted(DWORD dwBandID, DWORD dwRestrictAction, DWORD dwBandFlags)
{
    HRESULT hr;
    DWORD dwRestrictionAction;

    hr = IUnknown_HandleIRestrict(_punkSite, &RID_RDeskBars, dwRestrictAction, NULL, &dwRestrictionAction);
    if (RR_NOCHANGE == dwRestrictionAction)    // If our parent didn't handle it, we will.
        dwRestrictionAction = IsFlagSet(_GetAdminSettings(dwBandID), dwBandFlags) ? RR_DISALLOW : RR_ALLOW;

    if (RR_DISALLOW == dwRestrictionAction)
        hr = S_OK;
    else
        hr = S_FALSE;

    ASSERT(SUCCEEDED(hr));  // FAIL(hr) other than hr == E_NOTIMPLE; is not good.
    return hr;
}

BOOL ConfirmRemoveBand(HWND hwnd, UINT uID, LPCTSTR pszName)
{
    TCHAR szTemp[1024], *pszTemp2, *pszStr, szTitle[80];
    BOOL bRet = TRUE;
    DWORD dwLen;


    MLLoadString(IDS_CONFIRMCLOSETITLE, szTitle, ARRAYSIZE(szTitle));

    // Calling FormatMessage with FORMAT_MESSAGE_FROM_HMODULE fails
    MLLoadString(uID, szTemp, ARRAYSIZE(szTemp));

    dwLen = (lstrlen(szTemp) + lstrlen(pszName) + 1) * sizeof(TCHAR);
    if((pszTemp2 = (TCHAR *)LocalAlloc(LPTR, dwLen)) != NULL)
    {
        _FormatMessage(szTemp, pszTemp2, dwLen, pszName);

        MLLoadString(IDS_CONFIRMCLOSETEXT, szTemp, ARRAYSIZE(szTemp));

        dwLen = (lstrlen(szTemp) + lstrlen(pszTemp2) + 1) * sizeof(TCHAR);
        if((pszStr = (TCHAR *)LocalAlloc(LPTR, dwLen)) != NULL)
        {
            _FormatMessage(szTemp, pszStr, dwLen, pszTemp2);

            bRet = (IDOK == SHMessageBoxCheck(hwnd, pszStr, szTitle, MB_OKCANCEL, IDOK, TEXT("WarnBeforeCloseBand")));

            LocalFree(pszStr);
        }

        LocalFree(pszTemp2);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\brand.h ===
#ifndef __BRANDBAR_H__
#define __BRANDBAR_H__

#include "bands.h"

void Brand_InitBrandContexts();

#endif // __BRANDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\basebar.cpp ===
#include "priv.h"
#include "apithk.h"
#include "mshtmhst.h"
#include "basebar.h"

#ifdef MAINWIN
#include <mainwin.h>
EXTERN_C MwPaintSpecialEOBorder( HWND hWnd, HDC hDC );
#endif

#define DBM_ONPOSRECTCHANGE  (WM_USER)


//*** CBaseBar::IDeskBar::* {
//


/*----------------------------------------------------------
Purpose: IDeskBar::SetClient

         Usually the function that composes a bar/bandsite/band
         union is responsible for calling this method to inform
         the bar what the client (bandsite) is.

*/
HRESULT CBaseBar::SetClient(IUnknown *punkChild)
{
    if (_punkChild != NULL)
    {
        // 4, 3, 2, 1 Release
        _hwndChild = NULL;

        if (_pDBC)
        {
            // This must happen first, before _pWEH becomes NULL so cleanup
            // notifications can still go thru
            _pDBC->SetDeskBarSite(NULL);
        }

        ATOMICRELEASE(_pDBC);

        ATOMICRELEASE(_pWEH);

        ATOMICRELEASE(_punkChild);
    }

    _punkChild = punkChild;

    HRESULT hr = S_OK;
    if (_punkChild != NULL)
    {
        // 1, 2, 3, 4 QI/AddRef/etc.
        _punkChild->AddRef();
        if (!_hwnd)
        {
            _RegisterDeskBarClass();
            _CreateDeskBarWindow();
            if (!_hwnd)
            {
                return E_OUTOFMEMORY;
            }

            // can't do CBaseBar::_Initialize yet (haven't done SetSite yet)
        }

        hr = _punkChild->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pWEH));
        if (SUCCEEDED(hr))
        {
            hr = _punkChild->QueryInterface(IID_PPV_ARG(IDeskBarClient, &_pDBC));
            if (SUCCEEDED(hr))
            {
                // nothing to cache yet due to lazy CreateWindow
                hr = _pDBC->SetDeskBarSite(SAFECAST(this, IDeskBar*));

                IUnknown_GetWindow(_punkChild, &_hwndChild);
            }
        }
    }

    return hr;
}

HRESULT CBaseBar::GetClient(IUnknown **ppunk)
{
    *ppunk = _punkChild;
    if (_punkChild)
        _punkChild->AddRef();
    return _punkChild ? S_OK : E_FAIL;
}

HRESULT CBaseBar::OnPosRectChangeDB(LPRECT prc)
{
    _szChild.cx = RECTWIDTH(*prc);
    _szChild.cy = RECTHEIGHT(*prc);

    // We can't change our size right away because we haven't returned from processing
    // this WM_SIZE message. If we resize right now, USER gets confused...
    //
    // We cannot use PeekMessage to determine if there is already a pending
    // DBM_ONPOSRECTCHANGE because that allows incoming SendMessage's to
    // arrive, and then we can get into a bad recursive situation when there
    // are a lot of SHChangeNotify's arriving in rapid succession.
    //
    if (!_fPosRectChangePending)
    {
        _fPosRectChangePending = TRUE;
        PostMessage(_hwnd, DBM_ONPOSRECTCHANGE, 0, 0);
    }

    return S_OK;
}

//  Derived classes are expected to implement this method and do something
//  interesting...
void CBaseBar::_OnPostedPosRectChange()
{
}

// }

HRESULT CBaseBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);

    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (_pDBC)
        return _pDBC->UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);
    else
        return E_UNEXPECTED;
}

void CBaseBar::_OnCreate()
{
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
}

LRESULT CBaseBar::_OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}


/***
 */
LRESULT CBaseBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_CREATE:
        _OnCreate();
        break;

    case WM_COMMAND:
        return _OnCommand(uMsg, wParam, lParam);
        

    case WM_SIZE:     
        _OnSize();    
        break;

    case WM_NOTIFY:
        return _OnNotify(uMsg, wParam, lParam);

#if 0
    // we'd like to set focus to the 1st band when somebody clicks in
    // 'dead space' on the bar (i.e. make it look like they TABed in).
    // however for some reason the below code has the bad effect of
    // de-selecting text in (e.g.) the addr edit control (it's as if
    // the control thinks we've clicked there 2x rather than 1x).
    case WM_SETFOCUS:
        if (IUnknown_HasFocusIO(_pDBC) == S_FALSE)
            IUnknown_UIActivateIO(_pDBC, TRUE, NULL);
        break;
#endif
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
    case WM_PALETTECHANGED:
        _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        break;

    case DBM_ONPOSRECTCHANGE:
        _fPosRectChangePending = FALSE;
        _OnPostedPosRectChange();
        break;

#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
#endif

    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

/***
 */
CBaseBar::CBaseBar() : _cRef(1)
{
    DllAddRef();
}

/***
 */
CBaseBar::~CBaseBar()
{
    // see Release, where we call virtuals (which can't be called from dtor)
    DllRelease();
}

/***
 */
void CBaseBar::_RegisterDeskBarClass()
{
    WNDCLASS  wc = {0};
    wc.style            = _GetClassStyle();
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CBaseBar*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("BaseBar");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);
}

DWORD CBaseBar::_GetExStyle()
{
    return WS_EX_TOOLWINDOW;
}

DWORD CBaseBar::_GetClassStyle()
{
    return CS_HREDRAW | CS_VREDRAW;
}

void CBaseBar::_CreateDeskBarWindow()
{
#ifndef UNIX
    // _hwnd is set in s_WndProc
    DWORD dwExStyle = _GetExStyle();    
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;
    HWND hwndDummy = CreateWindowEx(
                                    dwExStyle,
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    0,0,100,100,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
#else
    // This change removes a flash at the corner of the
    // screen. We create a small 1,1 window.

    HWND hwndDummy = CreateWindowEx(
                                    _GetExStyle(),
                                    TEXT("BaseBar"), NULL,
                                    _hwndSite ? WS_CHILD | WS_CLIPCHILDREN : WS_POPUP | WS_CLIPCHILDREN,
                                    -100,-100,1,1,
                                    _hwndSite, NULL, HINST_THISDLL,
                                    (LPVOID)SAFECAST(this, CImpWndProc*));
#endif
}


void CBaseBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);
    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
}

void CBaseBar::_NotifyModeChange(DWORD dwMode)
{
    if (_pDBC) {
        _dwMode = dwMode;
        // FEATURE: should we add an STBBIF_VIEWMODE_FLOAT?
        _pDBC->SetModeDBC(_dwMode);
    }
}

BOOL CBaseBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    *plres = 0;
    switch (uMsg)
    {
    case WM_CONTEXTMENU:
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        hwnd = _hwndChild;
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwnd = _hwndChild;
        break;
    }
    
    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK)
    {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return FALSE;
}

/***
 */
LRESULT CBaseBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);

    return lres;
}

HRESULT CBaseBar::CloseDW(DWORD dwReserved)
{
    SetClient(NULL);
    if (_hwnd) {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    return S_OK;
}


HRESULT CBaseBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBaseBar, IOleWindow),
        QITABENT(CBaseBar, IDeskBar),
        QITABENT(CBaseBar, IInputObject),
        QITABENT(CBaseBar, IInputObjectSite),
        QITABENT(CBaseBar, IServiceProvider),
        QITABENT(CBaseBar, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, (LPCQITAB)qit, riid, ppvObj);
}


ULONG CBaseBar::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBaseBar::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    // 'virtual dtor'
    // gotta do virtual stuff here (not in dtor) because can't call
    // any virtuals in the dtor
    // CBaseBar::Destroy() {
    CloseDW(0);
    // }

    delete this;
    return 0;
}

//*** CBaseBar::IOleWindow::* {
//

HRESULT CBaseBar::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return (_hwnd) ? S_OK : E_FAIL;
}

HRESULT CBaseBar::ContextSensitiveHelp(BOOL fEnterMode)
{
    // FEATURE: Visit here later.
    return E_NOTIMPL;
}
// }


// }
// some helpers... {

// What's the point of having
// these empty implementations in the base class?
//

//*** CBaseBar::IServiceProvider::*
//
HRESULT CBaseBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;

    return hres;
}

//*** CBaseBar::IOleCommandTarget::*
//
HRESULT CBaseBar::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pDBC, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBaseBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return MayExecForward(_pDBC, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}

// }


//*** CDeskBar::IInputObject::* {

HRESULT CBaseBar::HasFocusIO()
{
    HRESULT hres;

    hres = IUnknown_HasFocusIO(_pDBC);
    return hres;
}

HRESULT CBaseBar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_TranslateAcceleratorIO(_pDBC, lpMsg);
    return hres;
}

HRESULT CBaseBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;

    hres = IUnknown_UIActivateIO(_pDBC, fActivate, lpMsg);
    return hres;
}

// }

//***   CDeskBar::IInputObjectSite::* {

HRESULT CBaseBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bindcb.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _BINDCB_H_

// the CStubBindStatusCallback implements IBindStatusCallback and
// IHttpNegotiate.  We use it to make a "fake" bind status callback
// object when we have headers and post data we would like to apply
// to a navigation.  We supply this IBindStatusCallback object, and
// the URL moniker asks us for headers and post data and use those in
// the transaction.

class CStubBindStatusCallback : public IBindStatusCallback,
                                       IHttpNegotiate,
                                       IMarshal
{
private:
    UINT      _cRef;         // ref count on this COM object
    LPCSTR    _pszHeaders;   // headers to use
    HGLOBAL   _hszPostData;  // post data to use
    DWORD     _cbPostData;   // size of post data
    BOOL      _bFrameIsOffline : 1; // Indicates if Offline property is set
    BOOL      _bFrameIsSilent : 1;  // Indicates if Silent property is set
    BOOL      _bHyperlink : 1;  // This is a hyperlink or top level request
    DWORD     _grBindFlags; //  optional additional bindinfo flags

public:
    CStubBindStatusCallback(LPCWSTR pwzHeaders,LPCBYTE pPostData,DWORD cbPostData,
                            VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent, BOOL bHyperlink, DWORD grBindFlags);
    ~CStubBindStatusCallback();

    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBindStatusCallback ***
    virtual STDMETHODIMP OnStartBinding(
        /* [in] */ DWORD grfBSCOption,
        /* [in] */ IBinding *pib);

    virtual STDMETHODIMP GetPriority(
        /* [out] */ LONG *pnPriority);

    virtual STDMETHODIMP OnLowResource(
        /* [in] */ DWORD reserved);

    virtual STDMETHODIMP OnProgress(
        /* [in] */ ULONG ulProgress,
        /* [in] */ ULONG ulProgressMax,
        /* [in] */ ULONG ulStatusCode,
        /* [in] */ LPCWSTR szStatusText);

    virtual STDMETHODIMP OnStopBinding(
        /* [in] */ HRESULT hresult,
        /* [in] */ LPCWSTR szError);

    virtual STDMETHODIMP GetBindInfo(
        /* [out] */ DWORD *grfBINDINFOF,
        /* [unique][out][in] */ BINDINFO *pbindinfo);

    virtual STDMETHODIMP OnDataAvailable(
        /* [in] */ DWORD grfBSCF,
        /* [in] */ DWORD dwSize,
        /* [in] */ FORMATETC *pformatetc,
        /* [in] */ STGMEDIUM *pstgmed);

    virtual STDMETHODIMP OnObjectAvailable(
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ IUnknown *punk);

    /* *** IHttpNegotiate ***  */
    virtual STDMETHODIMP BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR __RPC_FAR *pszAdditionalHeaders);

    virtual STDMETHODIMP OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
            LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders);

    // IMarshal methods
                    
    STDMETHODIMP GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid);
    STDMETHODIMP GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize);
    STDMETHODIMP MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags);
    STDMETHODIMP UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj);
    STDMETHODIMP ReleaseMarshalData(IStream *pStm);
    STDMETHODIMP DisconnectObject(DWORD dwReserved);

    // helper methods
    STDMETHODIMP _FreeHeadersAndPostData();
    BOOL _CanMarshalIID(REFIID riid);
    HRESULT _ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags);

};

// private flags between shdocvw and mshtml
// -> should be done via bind context
//
#define BINDF_INLINESGETNEWESTVERSION   0x10000000
#define BINDF_INLINESRESYNCHRONIZE      0x20000000
#define BINDF_CONTAINER_NOWRITECACHE    0x40000000


// global helper functions
BOOL fOnProxy();
HRESULT BuildBindInfo(DWORD *grfBINDF,BINDINFO *pbindinfo,HGLOBAL hszPostData,
    DWORD cbPostData, BOOL bFrameIsOffline, BOOL bFrameIsSilent, BOOL bHyperlink, LPUNKNOWN pUnkForRelease);
HRESULT BuildAdditionalHeaders(LPCSTR pszOurExtraHeaders,LPCWSTR * ppwzCombinedHeadersOut);
HRESULT CStubBindStatusCallback_Create(LPCWSTR pwzHeaders, LPCBYTE pPostData,
    DWORD cbPostData, VARIANT_BOOL bFrameIsOffline, VARIANT_BOOL bFrameIsSilent,BOOL bHyperlink,
    DWORD grBindFlags,
    CStubBindStatusCallback ** ppBindStatusCallback);
HRESULT GetHeadersAndPostData(IBindStatusCallback * pBindStatusCallback,
    LPSTR * ppszHeaders, STGMEDIUM * pstgPostData, DWORD * pdwPostData, BOOL * pfUseCache);
HRESULT GetTopLevelBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);
HRESULT GetTopLevelPendingBindStatusCallback(IServiceProvider * psp,
    IBindStatusCallback ** ppBindStatusCallback);

#endif // _BINDCB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\brand.cpp ===
#include "priv.h"
#include "sccls.h"
#include "legacy.h"
#include "itbar.h"
#include "itbdrop.h"
#include "brand.h"
#include "theater.h"
#include "resource.h"
#include <tb_ids.h>

#include "mluisupp.h"

typedef struct {
    HPALETTE    hpal;
    HBITMAP     hbm;

    int         cyBrand;
    int         cxBrandExtent;
    int         cyBrandExtent;
    int         cyBrandLeadIn;

    COLORREF    clrBkStat;
    COLORREF    clrBkAnim;

    LPTSTR      pszBitmap;
    LPTSTR      pszStaticBitmap;
} BRANDCONTEXT;    

class CBrandBand :  public CToolBand,
                    public IWinEventHandler,
                    public IDispatch
{
public:
    // IUnknown
    virtual STDMETHODIMP_(ULONG) AddRef(void)   { return CToolBand::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)  { return CToolBand::Release(); }
    virtual STDMETHODIMP         QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IObjectWithSite
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    
    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi);
    // IOleCommandTarget
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // IPersist
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // IPersistStream
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // IWinEventHandler
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // IDispatch
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid){return(E_NOTIMPL);}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);
    
protected:    
    CBrandBand();
    virtual ~CBrandBand();

    friend HRESULT CBrandBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor

    BITBOOL        _fVertical:1;
    BITBOOL        _fAnimating:1;
    BITBOOL        _fMinAlways:1;
    BITBOOL        _fTheater :1;

    BOOL _fShellView;
    
    BRANDCONTEXT *_pbc;
    int         _yOrg;
    
    static HDC          s_hdc;
    static BRANDCONTEXT s_bcWebSmall;     // BrandContext for the small web view bitmap
    static BRANDCONTEXT s_bcWebLarge;     // BrandContext for the large web view bitmap
    static BRANDCONTEXT s_bcWebMicro;     // BrandContext for the micro web view bitmap
    static BRANDCONTEXT s_bcShellSmall;   // BrandContext for the small shell view bitmap
    static BRANDCONTEXT s_bcShellLarge;   // BrandContext for the large shell view bitmap
    

    IWebBrowserApp *    _pdie;          // Used when Navigating a Browser Window with a URL String
    IBrowserService *   _pbs;           // Only valid when we are in a Browser Windows Toolbar. (Not Toolband)
    IWebBrowser2 *      _pwb2;          // Only valid when we are a Toolband (not toolbar).
    DWORD               _dwcpCookie;    // ConnectionPoint cookie for DWebBrowserEvents from the Browser Window.

    DWORD               _dwCookieServiceBrandBand;    // Service cookie for SID_SBrandBand

    LONG                _lAnimateCount; // Keep track of how many StartAnimation/StopAnimation were requested

    // Helper functions
    void _UpdateCompressedSize();
    HRESULT _CreateBrandBand();
    HRESULT _LoadBrandingBitmap();
    void    _DrawBranding(HDC hdc);
    int     _GetLinksExtent();
    void    _OnTimer(WPARAM id);
    void    _StartAnimation();
    void    _StopAnimation();

    static void _InitGlobals();
    static void _InitBrandContexts();
    static void _InitBrandContext(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight,
        LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap);

    HRESULT _ConnectToBrwsrWnd(IUnknown* punk);        
    HRESULT _ConnectToBrwsrConnectionPoint(BOOL fConnect);

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CBrandBand_CleanUp();
    friend void Brand_InitBrandContexts();

    static void _GetBrandContextHeight(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
        LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap);

private:
};


#define SUPERCLASS  CToolBand

#define BM_BANDINFOCHANGED  (WM_USER + 1)

#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif
extern HRESULT VariantClearLazy(VARIANTARG *pvarg);

#define ANIMATION_TIMER         5678

#define MICROBITMAPID()     (IDB_IEMICROBRAND)
#define SMALLBITMAPID()     (IDB_IESMBRAND)
#define LARGEBITMAPID()     (IDB_IEBRAND)


BRANDCONTEXT CBrandBand::s_bcWebMicro   = {NULL};   // BrandContext for the micro web view bitmap
BRANDCONTEXT CBrandBand::s_bcWebSmall   = {NULL};   // BrandContext for the small web view bitmap
BRANDCONTEXT CBrandBand::s_bcWebLarge   = {NULL};   // BrandContext for the large web view bitmap
BRANDCONTEXT CBrandBand::s_bcShellSmall = {NULL};   // BrandContext for the small shell view bitmap
BRANDCONTEXT CBrandBand::s_bcShellLarge = {NULL};   // BrandContext for the large shell view bitmap


// The heights of the bitmaps (each frame!) stored is this module's resources

// ** NOTE **
// If you change the animated brands that are stored in browseui:
// MAKE SURE THESE HEIGHTS are correct!!
// ** - dsheldon - **

#define BRANDHEIGHT_WEBLARGE    38
#define BRANDHEIGHT_WEBSMALL    26
#define BRANDHEIGHT_WEBMICRO    22

HDC CBrandBand::s_hdc = NULL;
BOOL g_fUseMicroBrand = TRUE;
UINT g_cySmBrand = 0;
static const TCHAR szRegKeyIE20[]           = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main");

static const TCHAR szValueLargeBitmap[]     = TEXT("BigBitmap");
static const TCHAR szValueSmallBitmap[]     = TEXT("SmallBitmap");
static const TCHAR szValueBrandBitmap[]     = TEXT("BrandBitmap");
static const TCHAR szValueBrandHeight[]     = TEXT("BrandHeight");
static const TCHAR szValueBrandLeadIn[]     = TEXT("BrandLeadIn");
static const TCHAR szValueSmBrandBitmap[]   = TEXT("SmBrandBitmap");
static const TCHAR szValueSmBrandHeight[]   = TEXT("SmBrandHeight");
static const TCHAR szValueSmBrandLeadIn[]   = TEXT("SmBrandLeadIn");

static const TCHAR szValueSHLargeBitmap[]     = TEXT("SHBigBitmap");
static const TCHAR szValueSHSmallBitmap[]     = TEXT("SHSmallBitmap");
static const TCHAR szValueSHBrandBitmap[]     = TEXT("SHBrandBitmap");
static const TCHAR szValueSHBrandHeight[]     = TEXT("SHBrandHeight");
static const TCHAR szValueSHBrandLeadIn[]     = TEXT("SHBrandLeadIn");
static const TCHAR szValueSHSmBrandBitmap[]   = TEXT("SHSmBrandBitmap");
static const TCHAR szValueSHSmBrandHeight[]   = TEXT("SHSmBrandHeight");
static const TCHAR szValueSHSmBrandLeadIn[]   = TEXT("SHSmBrandLeadIn");

static const TCHAR szRegKeyCoolbar[]        = TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar");
    // NOTE: szRegKeyCoolbar is duplicated from itbar.cpp!

void CBrandBand_CleanUp()
{
    if (CBrandBand::s_hdc)
    {
        HDC     hdcT;
        HBITMAP hbmT, * pbmp = NULL;

        // pick out any old bitmap to flush dc with
        if (CBrandBand::s_bcWebLarge.hbm)
            pbmp = &CBrandBand::s_bcWebLarge.hbm;
        else if (CBrandBand::s_bcWebSmall.hbm)
            pbmp = &CBrandBand::s_bcWebSmall.hbm;        

        // We need to get rid of the branding bitmap from the s_hdc
        // before we delete it else we leak. Do this the hard way since
        // we don't have a stock bitmap available to us.
        if (pbmp)
        {
            hdcT = CreateCompatibleDC(NULL);

            if (hdcT)
            {
                hbmT = (HBITMAP)SelectObject(hdcT, *pbmp);
                SelectObject(CBrandBand::s_hdc, hbmT);
                SelectObject(hdcT, hbmT);
                DeleteDC(hdcT);
            }
        }
        
        DeleteDC(CBrandBand::s_hdc);
    }

    // no palette to delete as we use the global one..
    // delete the shared palette
    
    if (CBrandBand::s_bcWebSmall.hbm)
        DeleteObject(CBrandBand::s_bcWebSmall.hbm);

    if (CBrandBand::s_bcWebLarge.hbm)
        DeleteObject(CBrandBand::s_bcWebLarge.hbm);

    if (!g_fUseMicroBrand) {
        if (CBrandBand::s_bcShellSmall.hbm)
            DeleteObject(CBrandBand::s_bcShellSmall.hbm);

        if (CBrandBand::s_bcShellLarge.hbm)
            DeleteObject(CBrandBand::s_bcShellLarge.hbm);
    } else {
        if (CBrandBand::s_bcWebMicro.hbm)
            DeleteObject(CBrandBand::s_bcWebMicro.hbm);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CBrandBand
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrandBand_CreateInstance( IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // Aggregation checking is handled in class factory

    HRESULT hr;

    *ppunk = NULL;

    CBrandBand * p = new CBrandBand();
    if (p != NULL) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

CBrandBand::CBrandBand() : SUPERCLASS()
{
    ASSERT(_fAnimating == FALSE);
    ASSERT(_hwnd == NULL);
    _pbc = &s_bcShellLarge;
}

CBrandBand::~CBrandBand()
{
    ASSERT(!_pdie || !_pwb2 || !_pbs);

    if (IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);
    }
}

// IUnknown::QueryInterface
HRESULT CBrandBand::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}

// IDockingWindow::SetSite
HRESULT CBrandBand::SetSite(IUnknown * punkSite)
{
    if (_pdie || _pwb2 || _pbs)
        _ConnectToBrwsrWnd(NULL);    // On-connect from Browser Window.

    // Make sure we proffer the service only once
    // This is important since we get created multiple times,
    IUnknown *punk = NULL;

    // Check if we need to revoke our service, or if our service was already proffered by
    // another instance of CBrandBand
    if ((!punkSite && _dwCookieServiceBrandBand) || 
            (punkSite && FAILED(IUnknown_QueryService(punkSite, SID_SBrandBand, IID_IUnknown, (void **)&punk))))
    {
        // Proffer or Revoke BrandBand service as appropriate
        IUnknown_ProfferService(punkSite ? punkSite : _punkSite, 
                                SID_SBrandBand, 
                                punkSite ? SAFECAST(this, IServiceProvider *) : NULL, 
                                &_dwCookieServiceBrandBand);
        // Failure here does not require special handling
    }
    ATOMICRELEASE(punk);

    SUPERCLASS::SetSite(punkSite);

    if (punkSite)
    {
        _CreateBrandBand();

        // This call will fail if the host doesn't have a Browser Window.
        _ConnectToBrwsrWnd(punkSite);
    }

    return S_OK;
}

// IDeskBand::GetBandInfo
HRESULT CBrandBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;

    _fVertical = ((fViewMode & DBIF_VIEWMODE_VERTICAL) != 0);

    _LoadBrandingBitmap();
    pdbi->dwModeFlags = DBIMF_FIXEDBMP;
    if (!_fMinAlways)
        pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;

    int cxWidth = _fTheater ? CX_FLOATERSHOWN : _GetLinksExtent();
    
    pdbi->ptMinSize.x = max(s_bcWebSmall.cxBrandExtent, max(s_bcShellSmall.cxBrandExtent, cxWidth));
    pdbi->ptMaxSize.x = max(s_bcWebLarge.cxBrandExtent, max(s_bcShellLarge.cxBrandExtent, cxWidth));
    
    pdbi->ptMaxSize.y = max(s_bcWebLarge.cyBrand, s_bcShellLarge.cyBrand);
    
    if (g_fUseMicroBrand)
        pdbi->ptMinSize.y = s_bcWebMicro.cyBrand;
    else
        pdbi->ptMinSize.y = max(s_bcWebSmall.cyBrand, s_bcShellSmall.cyBrand);
    
    pdbi->ptIntegral.y = -1;


    return S_OK;
}

// IWinEventHandler::OnWinEvent
HRESULT CBrandBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    *plres = 0;
    
    switch (uMsg)
    {
    case WM_WININICHANGE:
        if (SHIsExplorerIniChange(wParam, lParam))
        {
            _InitBrandContexts();
            InvalidateRect(_hwnd, NULL, TRUE);
        }
        *plres = SendMessage(_hwnd, uMsg, wParam, lParam);
        break;
    }
    
    return S_OK;
} 

// IWinEventHandler::IsWindowOwner
HRESULT CBrandBand::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    
    return S_FALSE;
}

// IPersistStream::GetClassID
HRESULT CBrandBand::GetClassID(CLSID * pClassID)
{
    *pClassID = CLSID_BrandBand;
    return S_OK;
}

// IPersistStream::Load
HRESULT CBrandBand::Load(IStream *pstm)
{
    return S_OK;
}

// IPersistStream::Load
HRESULT CBrandBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

#define ANIMATION_PERIOD       30
#define ANIMATION_PERIOD_FAST  15

// IDispatch::Invoke
HRESULT CBrandBand::Invoke
(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
)
{
    ASSERT(pdispparams);
    if (!pdispparams)
        return E_INVALIDARG;

    switch (dispidMember)
    {
        case DISPID_DOWNLOADBEGIN:
        {
            _StartAnimation();
            break;
        }

        case DISPID_DOWNLOADCOMPLETE:
        {
            _StopAnimation();
            break;
        }

        default:
            return E_INVALIDARG;
    }
    
    return S_OK;
}

void CBrandBand::_InitGlobals()
{
    if (!s_hdc) {
        ENTERCRITICAL;
        if (!s_hdc)
        {
            s_hdc = CreateCompatibleDC(NULL);
            if (s_hdc && GetDeviceCaps(s_hdc, RASTERCAPS) & RC_PALETTE)
            {
                // share the global palette ....
                ASSERT( g_hpalHalftone );
                s_bcWebMicro.hpal = g_hpalHalftone;
                s_bcWebSmall.hpal = s_bcShellSmall.hpal = g_hpalHalftone;
                s_bcWebLarge.hpal = s_bcShellLarge.hpal = g_hpalHalftone;
            }   
        }        
        LEAVECRITICAL;
    }
}

HRESULT CBrandBand::_CreateBrandBand()
{
    HRESULT hr;

    ASSERT(_hwndParent);        // Call us after SetSite()
    if (!_hwndParent)
    {
        // The caller hasn't called SetSite(), so we can't
        // create our window because we can't find out our parent's
        // HWND.
        return E_FAIL;
    }

    // create branding window
    _hwnd = SHCreateWorkerWindow(WndProc, _hwndParent, 0, WS_CHILD, NULL, this);
    if (_hwnd)
    {
        _InitGlobals();
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceMsg(TF_ERROR, "CBrandBand::_CreateBrandBand() - Could not create Brand Band!");
    }

    return hr;
}

void Brand_InitBrandContexts()
{
    CBrandBand::_InitGlobals();
    CBrandBand::_InitBrandContexts();
}

void CBrandBand::_InitBrandContexts()
{
    // note: these calls set g_fUseMicroBrand
    _GetBrandContextHeight(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
            szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
    _GetBrandContextHeight(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
            szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());

    // if no third party brands found
    if (g_fUseMicroBrand) {
        // init micro brand
        _GetBrandContextHeight(&s_bcWebMicro, NULL, NULL,
            NULL, NULL, MICROBITMAPID());
    } else {
        // init shell brands
        _GetBrandContextHeight(&s_bcShellSmall, szValueSHSmBrandLeadIn, szValueSHSmBrandHeight,
                szValueSHSmBrandBitmap, szValueSHSmallBitmap, SMALLBITMAPID());
        _GetBrandContextHeight(&s_bcShellLarge, szValueSHBrandLeadIn, szValueSHBrandHeight,
                szValueSHBrandBitmap, szValueSHLargeBitmap, LARGEBITMAPID());
    }
}


/****************************************************************************
CBrandBand::_GetBrandContextHeight

  Sets the cyBrand member of the supplied brand context. This function
  uses the height information stored in the registry if it is available.
  If an alternate source for bitmaps is found and the height information
  is available in the registry, it is assumed we will not be using our
  micro brand (g_fUseMicroBrand = FALSE).

  Otherwise, it is assumed that no custom bitmaps are available and
  the cyBrand will be set to constant values representing the height
  of our standard branding.

  Note that if it appears that there are custom bitmaps available but the
  height cannot be read, we will attempt to read the custom bitmaps and
  determine the height that way (by delegating to _InitBrandContext)
****************************************************************************/
void CBrandBand::_GetBrandContextHeight(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
    LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap)
{
    HKEY hKey;
    DWORD cbData;
    DWORD dwType;
    BOOL fThirdPartyBitmap = FALSE;
    TCHAR szScratch[MAX_PATH];
    szScratch[0] = 0;

    // try to determine if there is a third party bitmap available for the specified
    // brand... Check if the anitmated bitmap exists
    if (pszBrandBitmap && ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        // See if an alternate file was specified for the animated bmp
        cbData = sizeof(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &cbData)))
        {
            if (szScratch[0] != 0)
                fThirdPartyBitmap = TRUE;
        }


        // It appears there are third party bitmaps

        // try to find the height of the animated bitmap
        if (pszBrandHeight && fThirdPartyBitmap)
        {
            cbData = sizeof(pbc->cyBrand);

            if (ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandHeight, NULL, &dwType,
                (LPBYTE)&pbc->cyBrand, &cbData))
            {
                // Third party brands probably exist
                g_fUseMicroBrand = FALSE;
            }
            else
            {
                // In this case, we know there should be 3rd party bitmaps but no
                // height was specified in the registry. We have to bite the bullet
                // and load the bitmaps now: Delegate to _InitBrandContext()
                _InitBrandContext(pbc, pszBrandLeadIn, pszBrandHeight, 
                    pszBrandBitmap, pszBitmap, idBrandBitmap);
            }
        }

        RegCloseKey(hKey);
    }

    if (!fThirdPartyBitmap && pszBitmap && 
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        // See if an alternate file was specified for the static bmp
        cbData = sizeof(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &cbData)))
        {
            if (szScratch[0] != 0)
            {
                // In this case, we know there is a 3rd party static bitmap but no
                // animated bitmap was specified in the registry. We have to bite the bullet
                // and load the bitmaps now: Delegate to _InitBrandContext()
                fThirdPartyBitmap = TRUE;
                _InitBrandContext(pbc, pszBrandLeadIn, pszBrandHeight, 
                    pszBrandBitmap, pszBitmap, idBrandBitmap);
            }
        }

        RegCloseKey(hKey);
    }

    // If we didn't find any third party bitmaps, we need to set it the height 
    // to the size of the bitmaps in this module's resources
    if (!fThirdPartyBitmap)
    {
        // Set the height based on which bitmap ID is requested
        switch (idBrandBitmap)
        {
        case IDB_IEMICROBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBMICRO;
            break;
        case IDB_IESMBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBSMALL;
            break;
        case IDB_IEBRAND:
            pbc->cyBrand = BRANDHEIGHT_WEBLARGE;
            break;
        default:
            // bad ID passed in!
            ASSERT(FALSE);
        }
    }
}

void CBrandBand::_InitBrandContext(BRANDCONTEXT* pbc, LPCTSTR pszBrandLeadIn, LPCTSTR pszBrandHeight, 
    LPCTSTR pszBrandBitmap, LPCTSTR pszBitmap, int idBrandBitmap)
{
    ENTERCRITICAL;

    HKEY        hKey = NULL;
    DWORD       dwType = 0;
    TCHAR       szScratch[MAX_PATH];
    DWORD       dwcbData;

    BOOL        fBitmapInvalid = !pbc->hbm;
    LPTSTR      pszNewBitmap = NULL;
    LPTSTR      pszOldBitmap = pbc->pszBitmap;
    HBITMAP     hbmp = NULL;
    BOOL        fExternalAnimatedBitmap = FALSE;
    BOOL        fUseWindowsXPBranding = FALSE;

    // process animated brand bitmap
    
    // see if the location spec for the bitmap has been changed    
    if (pszBrandBitmap && ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        dwcbData = SIZEOF(szScratch);
        if ((ERROR_SUCCESS == SHQueryValueEx(hKey, pszBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &dwcbData)))
        {               
            pszNewBitmap = szScratch;
            fExternalAnimatedBitmap = TRUE;
        }
    }

    if (!(pszNewBitmap == pszOldBitmap || (pszNewBitmap && pszOldBitmap && !lstrcmpi(pszNewBitmap, pszOldBitmap))))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid) {
        Str_SetPtr(&pbc->pszBitmap, pszNewBitmap);

        if (pszNewBitmap) {
            if (pszNewBitmap[0]) {    // not empty string

                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, 
                                           LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            }
        }

        if (!hbmp) 
        {
            if (hKey != NULL)
            {
                RegCloseKey(hKey); 
                hKey = NULL;
            }

            HINSTANCE hInstDll = HINST_THISDLL;
            INT iBitmapID = idBrandBitmap;

            if (GetUIVersion() > 5)
            {
                BOOL bHighColor = (SHGetCurColorRes() > 8) ? TRUE : FALSE;

                if (idBrandBitmap == MICROBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_MICRO;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_MICRO;

                    fUseWindowsXPBranding = TRUE;
                }
                else if (idBrandBitmap == SMALLBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_SMALL;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_SMALL;

                    fUseWindowsXPBranding = TRUE;
                }
                else if (idBrandBitmap == LARGEBITMAPID())
                {
                    if (bHighColor)
                        iBitmapID = IDB_BRAND_BITMAP_LARGE;
                    else
                        iBitmapID = IDB_BRAND256_BITMAP_LARGE;

                    fUseWindowsXPBranding = TRUE;
                }

                if (fUseWindowsXPBranding)
                {
                    hInstDll = GetModuleHandle (TEXT("shell32.dll"));
                }
            }

            hbmp = (HBITMAP) LoadImage(hInstDll, MAKEINTRESOURCE(iBitmapID), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
        } else
            g_fUseMicroBrand = FALSE;

        if (!hbmp) goto ErrorDone;

        if (pbc->hbm) DeleteObject(pbc->hbm);
        pbc->hbm = hbmp;

        // set the background to be the first pixel
        SelectObject(s_hdc, pbc->hbm);
        pbc->clrBkAnim = GetPixel(s_hdc, 0, 0);

        if (fUseWindowsXPBranding)
        {
            pbc->clrBkStat = pbc->clrBkAnim;
        }

        DIBSECTION  dib;
        GetObject(pbc->hbm, sizeof(DIBSECTION), &dib);
        pbc->cxBrandExtent = dib.dsBm.bmWidth;
        pbc->cyBrandExtent = dib.dsBm.bmHeight;

        dwcbData = sizeof(DWORD);

        // APPCOMPAT:: hkey is not setup when the second instance calls in
        if (!hKey || (ERROR_SUCCESS != SHQueryValueEx(hKey, pszBrandHeight, NULL, &dwType,
            (LPBYTE)&pbc->cyBrand, &dwcbData)))
            pbc->cyBrand = pbc->cxBrandExtent;

#define EXTERNAL_IMAGE_OFFSET   4
#define INTERNAL_IMAGE_OFFSET   0

        if (!hKey || (ERROR_SUCCESS != SHQueryValueEx(hKey, pszBrandLeadIn, NULL, &dwType,
            (LPBYTE)&pbc->cyBrandLeadIn, &dwcbData)))
        {
#ifndef UNIX
            if (fExternalAnimatedBitmap)
                // use old 4-image offset for back compat
                pbc->cyBrandLeadIn = EXTERNAL_IMAGE_OFFSET;
            else                
                pbc->cyBrandLeadIn = INTERNAL_IMAGE_OFFSET;
#else
            // IEUNIX : We use a different branding bitmap.   
            pbc->cyBrandLeadIn = EXTERNAL_IMAGE_OFFSET;
#endif
        }

        pbc->cyBrandLeadIn *= pbc->cyBrand;
    }

    if (hKey)
        RegCloseKey(hKey);

    // process the static bitmap

    pszNewBitmap = NULL;
    pszOldBitmap = pbc->pszStaticBitmap;
    hbmp = NULL;

    // see if the location spec for the bitmap has been changed
    dwcbData = SIZEOF(szScratch);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szRegKeyCoolbar, pszBitmap, &dwType, szScratch, &dwcbData))
    {
        pszNewBitmap = szScratch;
    }

    if (!(pszNewBitmap == pszOldBitmap || (pszNewBitmap && pszOldBitmap && !lstrcmpi(pszNewBitmap, pszOldBitmap))))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid) {
        Str_SetPtr(&pbc->pszStaticBitmap, pszNewBitmap);

        if (pszNewBitmap) {
            if (pszNewBitmap[0]) {    // not empty string

                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, 
                                           LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            }
        }

        if (hbmp) {

            DIBSECTION  dib;

            HDC hdcOld = CreateCompatibleDC(s_hdc);

            if (hdcOld)
            {
                SelectObject(s_hdc, pbc->hbm);
                GetObject(hbmp, sizeof(DIBSECTION), &dib);
                SelectObject(hdcOld, hbmp);
                // Set background to color of first pixel
                pbc->clrBkStat = GetPixel(hdcOld, 0, 0);
                StretchBlt(s_hdc, 0, 0, pbc->cxBrandExtent, pbc->cyBrand, hdcOld, 0, 0,
                           dib.dsBm.bmWidth, dib.dsBm.bmHeight, SRCCOPY);
                DeleteDC(hdcOld);
            }

            DeleteObject(hbmp);
            
            // If there was a custom brand, we can't use our micro brand
            g_fUseMicroBrand = FALSE;
        }        

        if (pbc == &s_bcShellSmall)
            g_cySmBrand = pbc->cyBrand;       
    }

ErrorDone:
    LEAVECRITICAL;
}

void CBrandBand::_UpdateCompressedSize()
{
    RECT rc;
    BOOL fCompressed = FALSE;
    BRANDCONTEXT *pbcOld = _pbc;

    GetClientRect(_hwnd, &rc);
    if (RECTHEIGHT(rc) < max(s_bcWebLarge.cyBrand, s_bcShellLarge.cyBrand)) {
        if (g_fUseMicroBrand && RECTHEIGHT(rc) < s_bcWebSmall.cyBrand)
        {
            if (s_bcWebMicro.hbm == NULL)
            {
                _InitBrandContext(&s_bcWebMicro, NULL, NULL,
                    NULL, NULL, MICROBITMAPID());
            }
            _pbc = &s_bcWebMicro;

        }
        else
        {
            if (_fShellView)
            {
                if (s_bcShellSmall.hbm == NULL)
                {
                    if (g_fUseMicroBrand)
                    {
                        // In this case, the shell and web bitmaps are always the same;
                        // load the web bitmap and use it for the shell also
                        if (s_bcWebSmall.hbm == NULL)
                        {
                            _InitBrandContext(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
                                szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
                        }

                        s_bcShellSmall = s_bcWebSmall;
                    }
                    else
                    {
                        // We have different web and shell bitmaps; load the shell one
                        _InitBrandContext(&s_bcShellSmall, szValueSHSmBrandLeadIn, szValueSHSmBrandHeight,
                                szValueSHSmBrandBitmap, szValueSHSmallBitmap, SMALLBITMAPID());
                    }
                }

                _pbc = &s_bcShellSmall;
            }
            else
            {
                // We are in web view mode
                if (s_bcWebSmall.hbm == NULL)
                {
                    _InitBrandContext(&s_bcWebSmall, szValueSmBrandLeadIn, szValueSmBrandHeight,
                        szValueSmBrandBitmap, szValueSmallBitmap, SMALLBITMAPID());
                }

                _pbc = &s_bcWebSmall;
            }
        }
    } 
    else
    {
        if (_fShellView)
        {
            if (s_bcShellLarge.hbm == NULL)
            {
                if (g_fUseMicroBrand)
                {
                    // Shell and Web bitmaps are the same. Load the web one and copy it
                    if (s_bcWebLarge.hbm == NULL)
                    {
                        _InitBrandContext(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
                            szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());
                    }
                    s_bcShellLarge = s_bcWebLarge;
                }
                else
                {
                    // Need to load the shell bitmap separately
                    _InitBrandContext(&s_bcShellLarge, szValueSHBrandLeadIn, szValueSHBrandHeight,
                        szValueSHBrandBitmap, szValueSHLargeBitmap, LARGEBITMAPID());
                }
            }
            _pbc = &s_bcShellLarge;
        }
        else
        {
            // We're in web view
            if (s_bcWebLarge.hbm == NULL)
            {
                _InitBrandContext(&s_bcWebLarge, szValueBrandLeadIn, szValueBrandHeight,
                    szValueBrandBitmap, szValueLargeBitmap, LARGEBITMAPID());
            }
            _pbc = &s_bcWebLarge;
        }
    }

    if (_pbc != pbcOld) {
        MSG msg;
        
        _yOrg = 0;
        InvalidateRect(_hwnd, NULL, TRUE);
        if (!PeekMessage(&msg, _hwnd, BM_BANDINFOCHANGED, BM_BANDINFOCHANGED, PM_NOREMOVE))
            PostMessage(_hwnd, BM_BANDINFOCHANGED, 0, 0);                   
    }
}

HRESULT CBrandBand::_LoadBrandingBitmap()
{
    if (_pbc->hbm)
        return S_OK;    // Nothing to do, already loaded.

    _yOrg = 0;

    _InitBrandContexts();

    return(S_OK);
}

void CBrandBand::_DrawBranding(HDC hdc)
{
    HPALETTE    hpalPrev;
    RECT        rcPaint;
    COLORREF    clrBk = _fAnimating? _pbc->clrBkAnim : _pbc->clrBkStat;
    int         x, y, cx, cy;
    int         yOrg = 0;
    DWORD       dwRop = SRCCOPY;

    if (_fAnimating)
        yOrg = _yOrg;

    if (_pbc->hpal)
    {
        // select in our palette so the branding will get mapped to 
        // whatever the current system palette is. Note we do not
        // pass FALSE, so we will no actually select this palette into
        // system palette FG. Otherwise the branding will flash the
        // palette
        hpalPrev = SelectPalette(hdc, _pbc->hpal, TRUE);
        RealizePalette(hdc);
    }

    GetClientRect(_hwnd, &rcPaint);

    x  = rcPaint.left;
    cx = RECTWIDTH(rcPaint);
    y  = rcPaint.top;
    cy = RECTHEIGHT(rcPaint);
    
    if (cx > _pbc->cxBrandExtent)
    {
        RECT rc = rcPaint;
        int dx = ((cx - _pbc->cxBrandExtent) / 2) + 1;
        rc.right = rc.left + dx;
        SHFillRectClr(hdc, &rc, clrBk);
        rc.right = rcPaint.right;
        rc.left = rc.right - dx;
        SHFillRectClr(hdc, &rc, clrBk);        
    }
    if (cy > _pbc->cyBrand)
    {
        RECT rc = rcPaint;
        int dy = ((cy - _pbc->cyBrand) / 2) + 1;
        rc.bottom = rc.top + dy;
        SHFillRectClr(hdc, &rc, clrBk);
        rc.bottom = rcPaint.bottom;
        rc.top = rc.bottom - dy;
        SHFillRectClr(hdc, &rc, clrBk);
    }
    
    // center it
    if (cx > _pbc->cxBrandExtent)
        x += (cx - _pbc->cxBrandExtent) / 2;
    if (cy > _pbc->cyBrand)     
        y += (cy - _pbc->cyBrand) / 2;    

    //
    // To prevent the transform from flipping
    // calculations should be based on the bm width
    // when the DC is Right-To-Left mirrored and
    // not to flip the IE logo bitmap [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwnd))
    {
        // Actual width
        cx = _pbc->cxBrandExtent;

        // Don't flip the logo here
        dwRop |= DONTMIRRORBITMAP;
    }


    ENTERCRITICAL;
    SelectObject(s_hdc, _pbc->hbm);
    BitBlt(hdc, x, y, cx, _pbc->cyBrand, s_hdc, 0, yOrg, dwRop);
    LEAVECRITICAL;

    if (_pbc->hpal)
    {
        // reselect in the old palette
        SelectPalette(hdc, hpalPrev, TRUE);
        RealizePalette(hdc);
    }
}

int CBrandBand::_GetLinksExtent()
{
    return 0x26;
}

void CBrandBand::_OnTimer(WPARAM id)
{
    _yOrg += _pbc->cyBrand;
    if (_yOrg >= _pbc->cyBrandExtent)
        _yOrg = _pbc->cyBrandLeadIn;
    RedrawWindow(_hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
}

void CBrandBand::_StartAnimation()
{
    // We need to be called on the UI thread, as we are not thread-safe.
    ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());

    if (++_lAnimateCount == 1)
    {
        // The timer does a invalidate of _hwnd which in cases
        // of no toolbar showing caused the entire desktop to
        // repaint and repaint and...
        if (_hwnd)
        {
            if (GetUIVersion() > 5)
                SetTimer(_hwnd, ANIMATION_TIMER, ANIMATION_PERIOD, NULL);
             else
                SetTimer(_hwnd, ANIMATION_TIMER, ANIMATION_PERIOD_FAST, NULL);
        }
        _yOrg = 0;
        _fAnimating = TRUE;
    
        IUnknown_Exec(_punkSite, &CGID_Theater, THID_ACTIVATE, 0, NULL, NULL);
    }
}

void CBrandBand::_StopAnimation()
{
    // We need to be called on the UI thread, as we are not thread-safe.
    ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());

    if (--_lAnimateCount == 0)
    {
        _fAnimating = FALSE;

        KillTimer(_hwnd, ANIMATION_TIMER);
        InvalidateRect(_hwnd, NULL, FALSE);
        UpdateWindow(_hwnd);
        IUnknown_Exec(_punkSite, &CGID_Theater, THID_DEACTIVATE, 0, NULL, NULL);
    }
}



// The IUnknown parameter needs to point to an object that supports the
// IBrowserService and IWebBrowserApp interfaces.
HRESULT CBrandBand::_ConnectToBrwsrWnd(IUnknown * punk)
{
    HRESULT hr = S_OK;

    if (_pdie)
    {
        // Remove the tie from the AddressBand to the Browser Window
        _ConnectToBrwsrConnectionPoint(FALSE);
        ATOMICRELEASE(_pdie);
    }
    
    ATOMICRELEASE(_pwb2);
    ATOMICRELEASE(_pbs);

    if (punk)
    {
        // Tie the AddressBand to the Browser Window passed in.
        IServiceProvider*   psp     = NULL;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **)&psp);

        if (SUCCEEDED(hr))
        {
            // NOTE: We are either a Toolbar, in which case _pbs is valid
            //       and _pwb2 is NULL, or we are a Toolband and _pbs is
            //       NULL and _pwb2 is valid. Both will be NULL when the
            //       Toolband has yet to create a Browser Window.

            if (FAILED(psp->QueryService(SID_STopLevelBrowser, IID_IBrowserService, (void**)&_pbs)))
                hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**)&_pwb2);
            hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowserApp, (void**)&_pdie);
            psp->Release();

            if (_pdie && (_pwb2 || _pbs))
                _ConnectToBrwsrConnectionPoint(TRUE);
            else
            {
                ATOMICRELEASE(_pdie);
                ATOMICRELEASE(_pwb2);
                ATOMICRELEASE(_pbs);

                hr = E_FAIL;
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Connect to Browser Window's ConnectionPoint that will provide events
// to let us keep up to date.
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrandBand::_ConnectToBrwsrConnectionPoint(BOOL fConnect)
{
    return ConnectToConnectionPoint(SAFECAST(this, IDeskBand*), 
        DIID_DWebBrowserEvents, fConnect, _pdie, &_dwcpCookie, NULL);
}


LRESULT CALLBACK CBrandBand::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBrandBand * ptc= (CBrandBand *)GetWindowPtr0(hwnd);   // GetWindowLong(hwnd, 0)

    switch (uMsg)
    {
        case WM_TIMER:
            ptc->_OnTimer(wParam);
            break;

        case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, ptc->_fAnimating ? ptc->_pbc->clrBkAnim : ptc->_pbc->clrBkStat);
            break;
        }
            
        case WM_PAINT:
            ptc->_UpdateCompressedSize();
            if (GetUpdateRect(hwnd, NULL, FALSE))
            {
                PAINTSTRUCT ps;

                BeginPaint(hwnd, &ps);
                ptc->_DrawBranding(ps.hdc);
                EndPaint(hwnd, &ps);
            }
            break;
            
        case WM_SIZE:
            InvalidateRect(ptc->_hwnd, NULL, TRUE);
            ptc->_UpdateCompressedSize();
            break;

        case BM_BANDINFOCHANGED:
            ptc->_BandInfoChanged();
            break;

        default:
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
 
    return 0;       
}

HRESULT CBrandBand::Exec(const GUID *pguidCmdGroup,
                         DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;  // assume failure
    if (pguidCmdGroup) {
        
        if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
        {
            hr = S_OK;
            switch (nCmdID)
            {
            case CITIDM_BRANDSIZE:
                if (pvarargIn && pvarargIn->vt == VT_I4) {
                    BOOL fMin = BOOLIFY(pvarargIn->lVal);
                    if (fMin != BOOLIFY(_fMinAlways)) {
                        _fMinAlways = fMin;
                        _BandInfoChanged();
                    }
                }
                break;

            case CITIDM_ONINTERNET:
                switch (nCmdexecopt)
                {                
                case CITE_SHELL:
                    _fShellView = TRUE;
                    if (_pbs)
                    {
                        LPITEMIDLIST pidl;
                        
                        hr = _pbs->GetPidl(&pidl);
                        if (SUCCEEDED(hr))
                        {
                            // We may really be an IShellView for an internet NSE (like FTP)
                            // Find out if they want this feature
                            _fShellView = !IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_IE_LOGOBANDING);
                            ILFree(pidl);
                        }
                    }
                    break;

                case CITE_INTERNET:
                    _fShellView = FALSE;
                    break;
                }
                _UpdateCompressedSize();
                break;
            
            case CITIDM_THEATER:
                switch(nCmdexecopt) {
                case THF_ON:
                    _fTheater = TRUE;
                    break;

                case THF_OFF:
                    _fTheater = FALSE;
                    break;

                default:
                    goto Bail;
                }

                _BandInfoChanged();
                break;                       
            
            case CITIDM_GETDEFAULTBRANDCOLOR:
                if (pvarargOut && pvarargOut->vt == VT_I4)
                    pvarargOut->lVal = g_fUseMicroBrand ? s_bcWebSmall.clrBkStat : s_bcShellSmall.clrBkStat;
                break;
            }
        }
        else if (IsEqualGUID(CGID_BrandCmdGroup, *pguidCmdGroup))
        {
            hr = S_OK;
            switch (nCmdID)
            {
            case CBRANDIDM_STARTGLOBEANIMATION:
                _StartAnimation();
                break;

            case CBRANDIDM_STOPGLOBEANIMATION:
                _StopAnimation();
                break;

            default:
                hr = OLECMDERR_E_NOTSUPPORTED;
                break;
            }
        }
    }
Bail:
    return hr;
}


// IQueryService implementation
HRESULT CBrandBand::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    HRESULT hres = E_NOTIMPL;

    if (IsEqualIID(guidService, SID_SBrandBand))
    {
        hres = QueryInterface(riid, ppvObj);
    }
    else
    {
        hres = CToolBand::QueryService(guidService, riid, ppvObj);
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bandsite.h ===
#ifndef _bandsite_h
#define _bandsite_h

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define SZ_REGKEY_GLOBALADMINSETTINGS TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\IEAK")
#define SZ_REGVALUE_GLOBALADMINSETTINGS TEXT("Admin Band Settings")

// Admin Settings (dwAdminSettings)
#define BAND_ADMIN_NORMAL       0x00000000
#define BAND_ADMIN_NODDCLOSE    0x00000001  // Disable Drag & Drop, and Close
#define BAND_ADMIN_NOMOVE       0x00000002  // Disable Moving within a Bar.
#define BAND_ADMIN_ADMINMACHINE 0x80000000  // This is an admin machine and this bit displays the two Admin Context Menu items

BOOL BandSite_HandleMessage(IUnknown *punk, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
void BandSite_SetMode(IUnknown *punk, DWORD dwMode);

BOOL ConfirmRemoveBand(HWND hwnd, UINT uID, LPCTSTR szName);

#ifdef WANT_CBANDSITE_CLASS

// UIActivateIO callback instance data
typedef struct tagACTDATA {
    LPMSG   lpMsg;  // IN
    HRESULT hres;
    IUnknown *punk;
} ACTDATA;


typedef struct tagBANDITEMDATA
{
    HWND hwnd;
    IDeskBand *pdb;
    IWinEventHandler *pweh;
    POINTL ptMinSize;
    POINTL ptMaxSize;
    POINTL ptIntegral;
    POINTL ptActual;
    WCHAR szTitle[256];
    DWORD dwModeFlags;
    DWORD dwBandID;
    BITBOOL fShow:1;            // current show state
    BITBOOL fNoTitle:1;         // 1:don't show title
    DWORD dwAdminSettings;
    COLORREF crBkgnd;
} BANDITEMDATA, *LPBANDITEMDATA;

typedef int (*PFNBANDITEMENUMCALLBACK)(LPBANDITEMDATA pbid, LPVOID pData);

int     _UIActIOCallback(LPBANDITEMDATA pbid, void *pv);

typedef struct {
    HRESULT hres;
    const GUID * pguidService;
    const IID * piid;
    void ** ppvObj;
} QSDATA;

int     _QueryServiceCallback(LPBANDITEMDATA pbid, void *pv);

#include "caggunk.h"

class CBandSite : public CAggregatedUnknown
                , public IBandSite
                , public IInputObjectSite
                , public IInputObject
                , public IDeskBarClient
                , public IWinEventHandler
                , public IPersistStream
                , public IDropTarget
                , public IServiceProvider
                , public IBandSiteHelper
                , public IOleCommandTarget
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IBandSite methods ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }
    
    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(THIS_ IUnknown* punkSite) ;
    virtual STDMETHODIMP SetModeDBC (THIS_ DWORD dwMode) ;
    virtual STDMETHODIMP UIActivateDBC(THIS_ DWORD dwState) ;
    virtual STDMETHODIMP GetSize    (THIS_ DWORD dwWhich, LPRECT prc);
    
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    
    // *** IDropTarget ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IBandSiteHelper methods ***
    virtual STDMETHODIMP LoadFromStreamBS(IStream *pstm, REFIID riid, LPVOID *ppv);
    virtual STDMETHODIMP SaveToStreamBS(IUnknown *punk, IStream *pstm);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CBandSite(IUnknown *punkAgg);

protected:
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    IDeskBar* _pdb;
    IUnknown* _punkSite;
    IBandSite* _pbsOuter; // the aggregating bandsite
    
    virtual HRESULT _Initialize(HWND hwndParent);
    virtual void _OnCloseBand(DWORD dwBandID);
    virtual LRESULT _OnBeginDrag(NMREBAR* pnm);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual IDropTarget* _WrapDropTargetForBand(IDropTarget* pdtBand);
    virtual DWORD _GetWindowStyle(DWORD* pdwExStyle);
    virtual HMENU _LoadContextMenu();
    HRESULT _OnBSCommand(int idCmd, DWORD idBandActive, LPBANDITEMDATA pbid);

    HRESULT _AddBand(IUnknown* punk);

    virtual HRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    IDataObject* _DataObjForBand(DWORD dwBandID);
    LPBANDITEMDATA _GetBandItemDataStructByID(DWORD uID);
    virtual int _ContextMenuHittest(LPARAM lParam, POINT* ppt);

    // container specific (rebar) members

    virtual BOOL            _AddBandItem(LPBANDITEMDATA pbid);
    virtual void            _DeleteBandItem(int i);
    LPBANDITEMDATA  _GetBandItem(int i);
    int             _GetBandItemCount();
    void            _BandItemEnumCallback(int dincr, PFNBANDITEMENUMCALLBACK pfnCB, void *pv);
    void            _DeleteAllBandItems();
    virtual void    _ShowBand(LPBANDITEMDATA pbid, BOOL fShow);

    int             _BandIDToIndex(DWORD dwBandID);
    DWORD           _IndexToBandID(int i);
    DWORD           _BandIDFromPunk(IUnknown* punk);

    HRESULT         _SetBandStateHelper(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual void    _UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize);
    void            _UpdateBand(DWORD dwBandID);
    BOOL            _UpdateBandInfo(LPBANDITEMDATA pbid, BOOL fBSOnly);

    void            _GetBandInfo(LPBANDITEMDATA pbid, DESKBANDINFO *pdbi);
    virtual void    _BandInfoFromBandItem(REBARBANDINFO *prbbi, LPBANDITEMDATA pbid, BOOL fBSOnly);
    virtual void    v_SetTabstop(LPREBARBANDINFO prbbi);
    BOOL            _IsEnableTitle(LPBANDITEMDATA pbid);

    BOOL            _IsHeightReasonable(UINT cy);
    HRESULT         _LoadBandInfo(IStream *pstm, int i, DWORD dwVersion);
    HRESULT         _SaveBandInfo(IStream *pstm, int i);

    HRESULT _AddBandByID(IUnknown *punk, DWORD dwID);
    BOOL _SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    BOOL _HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    int _BandIndexFromPunk(IUnknown *punk);
    BOOL _IsBandTabstop(LPBANDITEMDATA pbid);
    IUnknown* _GetNextTabstopBand(IUnknown* ptb, BOOL fBackwards);
    virtual HRESULT _CycleFocusBS(LPMSG lpMsg);
    void _OnRBAutoSize(NMRBAUTOSIZE* pnm);
    void _DoDragDrop();
    BOOL _PreDragDrop();
    virtual void _Close();

    
    BOOL _IsBandDeleteable(DWORD dwBandID);
    void _MinimizeBand(DWORD dwBandID);
    void _MaximizeBand(DWORD dwBandID);
    void _CheckNotifyOnAddRemove(DWORD dwBandID, int iCode);

    DWORD _GetAdminSettings(DWORD dwBandID);
    void _SetAdminSettings(DWORD dwBandID, DWORD dwNewAdminSettings);

    void _ReleaseBandItemData(LPBANDITEMDATA pbid, int iIndex);    

    void _CacheActiveBand(IUnknown* ptb);
    HRESULT _IsRestricted(DWORD dwBandID, DWORD dwRestrictAction, DWORD dwBandFlags);

    virtual ~CBandSite();
    
    HWND  _hwnd;
    HDSA  _hdsaBandItemData;
    DWORD _dwMode;
    DWORD _dwShowState;
    DWORD _dwBandIDNext;
    DWORD _dwStyle;

    IDataObject* _pdtobj;   // the stored drag drop data object;
    UINT    _uDragBand;
    DWORD   _dwDropEffect;
    
    IOleCommandTarget *_pct;
    IUnknown *_ptbActive;

    // cache for message reflector stuff
    HWND    _hwndCache;
    IWinEventHandler *_pwehCache;

    // Stuff we need to remember while our context menu is up
    IContextMenu3* _pcm3Parent;

    IShellLinkA *_plink;
    IBandProxy * _pbp;
    BITBOOL _fCreatedBandProxy:1;
    BITBOOL _fDragSource :1;
    BITBOOL _fNoDropTarget :1;
    BITBOOL _fIEAKInstalled :1;    // If TRUE, then display 2 extra contex menu items for Admins to use.
    UINT    _fDragging:2;           // we're dragging (0:FALSE 1:move [2:size])
    HWND    _hwndDD;                // window for cool D&D cursor drawing.
    
    friend HRESULT CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

typedef enum {
    CNOAR_ADDBAND       =   1,
    CNOAR_REMOVEBAND    =   2,
    CNOAR_CLOSEBAR      =   3,
} CNOAR_CODES;

#endif // WANT_CBANDSITE_CLASS


#ifdef __cplusplus
};       /* End of extern "C" { */
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "bands.h"
#include "util.h"
#include "resource.h"
#include "dhuihand.h"
#include "droptgt.h"
#include "iface.h"
#include "isfband.h"
#include "itbdrop.h"
#include "browband.h"
#include <varutil.h>
#include "legacy.h"
#include "mnbandid.h"

#include "mluisupp.h"

#include "inetsmgr.h"
#ifdef UNIX
#include "unixstuff.h"
#endif

#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

//***   CBrowserBand {
//

////////////////
///  BrowserOC band

CBrowserBand::CBrowserBand() :
    CToolBand()
{
    _fBlockSIDProxy = TRUE;
    _dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    _sizeMin.cx = _sizeMin.cy = 0;
    _sizeMax.cx = _sizeMax.cy = 32000;
    _fCustomTitle = FALSE;
    return;
}

CBrowserBand::~CBrowserBand()
{
    if (_pidl)
        ILFree(_pidl);

}

HRESULT CBrowserBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserBand, IContextMenu),          // IID_IContextMenu
        QITABENT(CBrowserBand, IWinEventHandler),      // IID_IWinEventHandler
        QITABENT(CBrowserBand, IDispatch),             // IID_IDispatch
        QITABENT(CBrowserBand, IPersistPropertyBag),   // IID_IPersistPropertyBag
        QITABENT(CBrowserBand, IBrowserBand),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

HRESULT CBrowserBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBrowserBand * p = new CBrowserBand();
    if (p) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT SHCreateBandForPidl(LPCITEMIDLIST pidl, IUnknown** ppunk, BOOL fAllowBrowserBand)
{
    IDeskBand *ptb = NULL;
    BOOL fBrowserBand;    
    DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;
    
    // if it's on the file system, we still might want to create a browser
    // band if it's a docobj (including .htm file)
    IEGetAttributesOf(pidl, &dwAttrib);    
    switch (dwAttrib & (SFGAO_FOLDER | SFGAO_BROWSABLE))
    {  
    case (SFGAO_FOLDER | SFGAO_BROWSABLE):
        TraceMsg(TF_WARNING, "SHCreateBandForPidl() Find out what the caller wants.  Last time we checked, nobody would set this - what does the caller want?");
    case SFGAO_BROWSABLE:
        fBrowserBand = TRUE;
        break;

    case SFGAO_FOLDER:
        fBrowserBand = FALSE;
        break;
        
    default:
        // if it's not a folder nor a browseable object, we can't host it.
        // Happens when use drags a text file and we want to turn off the
        // drop to create a band.
        return E_FAIL;

    }
    
    // this was a drag of a link or folder
    if (fBrowserBand)
    {
        if (fAllowBrowserBand)
        {
            // create browser to show web sites                        
            ptb = CBrowserBand_Create(pidl);
        }
    }
    else
    {
        // create an ISF band to show folders as hotlinks
        CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IDeskBand, &ptb));
    }

    *ppunk = ptb;

    if (ptb)
        return S_OK;

    return E_OUTOFMEMORY;

}


HRESULT CBrowserBand::CloseDW(DWORD dw)
{
    _Connect(FALSE);
    
    return CToolBand::CloseDW(dw);
}

void CBrowserBand::_Connect(BOOL fConnect)
{
    ConnectToConnectionPoint(SAFECAST(this, IDeskBand*), DIID_DWebBrowserEvents2, fConnect, 
                             _pauto, &_dwcpCookie, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch::Invoke
/////////////////////////////////////////////////////////////////////////////
HRESULT CBrowserBand::Invoke
(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
)
{
    ASSERT(pdispparams);
    if(!pdispparams)
        return E_INVALIDARG;

    //
    // NOTES: If we have a custom title, we don't need to process this call.
    //  This code assumes DISPID_TITLECHANGE is the only id we support.
    //  If somebody add any other, move this check below. 
    //  
    if (_fCustomTitle)
        return (S_OK);

    switch (dispidMember)
    {
    case DISPID_TITLECHANGE:
    {
        int iArg = pdispparams->cArgs -1;
        if (iArg == 0 &&
            (pdispparams->rgvarg[iArg].vt == VT_BSTR)) {

            BSTR pTitle = pdispparams->rgvarg[iArg].bstrVal;
            StrCpyNW(_wszTitle, pTitle, ARRAYSIZE(_wszTitle));
            _BandInfoChanged();
        }
        break;
    }
    }

    return S_OK;
}


/////  impl of IServiceProvider
HRESULT CBrowserBand::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    *ppvObj = NULL; // assume error

    if (_fBlockSIDProxy && IsEqualGUID(guidService, SID_SProxyBrowser)) {
        return E_FAIL;
    } 
    else if (IsEqualGUID(guidService, SID_STopFrameBrowser)) {
        // block this so SearchBand doesn't end up in global history
        return E_FAIL;
    }
    else if (_fBlockDrop && IsEqualGUID(guidService, SID_SDropBlocker))
    {
        return QueryInterface(riid, ppvObj);
    }

    return CToolBand::QueryService(guidService, riid, ppvObj);
}


HRESULT CBrowserBand::SetSite(IUnknown* punkSite)
{
    
    CToolBand::SetSite(punkSite);

    if (punkSite != NULL) {
        
        if (!_hwnd)
            _CreateOCHost();
    } else {

        ATOMICRELEASE(_pauto);
        ATOMICRELEASE(_poipao);
    }

    return S_OK;
}

//***   CBrowserBand::IInputObject::* {

HRESULT CBrowserBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
#ifdef DEBUG
    if (lpMsg && lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F12) {
        // temp debug test code
        _DebugTestCode();
    }
#endif

    if (_poipao)
        return _poipao->TranslateAccelerator(lpMsg);

    return S_FALSE;
}

HRESULT CBrowserBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    int iVerb = fActivate ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE;

    HRESULT hr = OCHost_DoVerb(_hwnd, iVerb, lpMsg);

    // OCHost UIActivate is different than IInputObject::UIActivateIO.  It
    // doesn't do anything with the lpMsg parameter.  So, we need to pass
    // it to them via TranslateAccelerator.  Since the only case we care
    // about is when they're getting tabbed into (we want them to highlight
    // the first/last link), just do this in the case of a tab.  However,
    // don't give it to them if it's a ctl-tab.  The rule is that you shouldn't
    // handle ctl-tab when UI-active (ctl-tab switches between contexts), and
    // since Trident is always UI-active (for perf?), they'll always reject
    // ctl-tab.

    if (IsVK_TABCycler(lpMsg) && !IsVK_CtlTABCycler(lpMsg) && _poipao)
        hr = _poipao->TranslateAccelerator(lpMsg);

    return hr;
}

// }

//***   CBrowserBand::IOleCommandTarget::* {

HRESULT CBrowserBand::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return MayQSForward(_pauto, OCTD_DOWN, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CBrowserBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //  These are broadcast messages to the TRIDENT doc for GUID CGID_MSTHML
    if (pguidCmdGroup && IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup))
    {
        if (_pauto)
        {
            LPTARGETFRAME2 ptgf;

            if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
            {
                LPOLECONTAINER pocDoc;
                if (SUCCEEDED(ptgf->GetFramesContainer(&pocDoc)) && pocDoc)
                {
                    IUnknown_Exec(pocDoc, &CGID_MSHTML, nCmdID, nCmdexecopt, 
                                    pvarargIn, pvarargOut);
                    pocDoc->Release();
                }
                ptgf->Release();
            }
        }
        return S_OK;
    }
    else
    {
        return MayExecForward(_pauto, OCTD_DOWN, pguidCmdGroup, nCmdID, nCmdexecopt,
            pvarargIn, pvarargOut);
    }
}

// }

HRESULT CBrowserBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{

    _dwBandID = dwBandID;

    // nt5:192868 make sure can't size to smaller than title/scrollbars
    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = _sizeMin.cx;
    pdbi->ptMinSize.y = max(16, _sizeMin.cy);   // FEATURE: 16 is bogus
#ifdef DEBUG
    if (pdbi->ptMinSize.x != 0 || pdbi->ptMinSize.y != 0)
        TraceMsg(DM_TRACE, "cbb.gbi: ptMinSize.(x,y)=%x,%x", pdbi->ptMinSize.x, pdbi->ptMinSize.y);
#endif
    pdbi->ptMaxSize.x = _sizeMax.cx;
    pdbi->ptMaxSize.y = _sizeMax.cy;
    pdbi->dwModeFlags = _dwModeFlags;

    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;
    
    if (_wszTitle[0]) {
        StrCpyNW(pdbi->wszTitle, _wszTitle, ARRAYSIZE(pdbi->wszTitle));
    } else if ( _fCustomTitle) {
        pdbi->dwMask &= ~DBIM_TITLE;
    }    
    else{
        SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pdbi->wszTitle, SIZECHARS(pdbi->wszTitle), NULL);
    }
    
    return S_OK;
} 


void CBrowserBand::_InitBrowser(void)
{
    ASSERT(IsWindow(_hwnd));

    OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IWebBrowser2, &_pauto));
    OCHost_SetOwner(_hwnd, SAFECAST(this, IContextMenu*));

    if (EVAL(_pauto))
    {
        LPTARGETFRAME2 ptgf;

        if (SUCCEEDED(_pauto->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            DWORD dwOptions;

            if (SUCCEEDED(ptgf->GetFrameOptions(&dwOptions)))
            {
                dwOptions |= FRAMEOPTIONS_BROWSERBAND | FRAMEOPTIONS_SCROLL_AUTO;
                ptgf->SetFrameOptions(dwOptions);
            }
            ptgf->Release();
        }

        _pauto->put_RegisterAsDropTarget(VARIANT_FALSE);

        // BUG do OCHost_QI
        // note only 1 active object (proxy)
        _pauto->QueryInterface(IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
        ASSERT(_poipao != NULL);
        
        // set up the connection point
        _Connect(TRUE);
    }
}

HRESULT CBrowserBand::_NavigateOC()
{
    HRESULT hres = E_FAIL;
    if (_hwnd)
    {
        ASSERT(IsWindow(_hwnd));
        if (!_pidl) {
            if (_pauto) {
                hres = _pauto->GoHome();
            }
        } else {
            IServiceProvider* psp = NULL;

            OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IServiceProvider, &psp));
            if (psp)
            {
                IShellBrowser* psb;
                if (EVAL(SUCCEEDED(psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb)))))
                {
                    hres = psb->BrowseObject(_pidl, SBSP_SAMEBROWSER);
                    psb->Release();
                }
                psp->Release();
            }

        }
    }

    return hres;
}


HRESULT CBrowserBand::_CreateOCHost()
{
    HRESULT hres = E_FAIL; // assume error

    // Register the OCHost window class
    SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
    shdrc.cbSize = sizeof (SHDRC);
    shdrc.dwFlags |= SHDRCF_OCHOST;
    if (DllRegisterWindowClasses(&shdrc))
    {
        // Create an OCHost window
        _hwnd = CreateWindow(OCHOST_CLASS, NULL,
            WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
            0, 0, 1, 1,
            _hwndParent, NULL, HINST_THISDLL, NULL);

        if (_hwnd)
        {
            OCHINITSTRUCT ocs;
            ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDeskBand*);

            hres = OCHost_InitOC(_hwnd, (LPARAM)&ocs);        

            _InitBrowser();
            _NavigateOC();
            OCHost_DoVerb(_hwnd, OLEIVERB_INPLACEACTIVATE, FALSE);
        }
    }
    return hres;
}

//***   CBrowserBand::IWinEventHandler::* {

HRESULT CBrowserBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg) {
    case WM_NOTIFY:
        _OnNotify((LPNMHDR)lParam);
        return S_OK;
        
    default:
        break;
    }

    return E_FAIL;
}

HRESULT CBrowserBand::IsWindowOwner(HWND hwnd)
{
    HRESULT hres;

    hres = SHIsChildOrSelf(_hwnd, hwnd);
    ASSERT(hwnd != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);
    return hres;
}

#if 0
static void HackFocus(HWND hwndFrom)
{
    TraceMsg(DM_FOCUS, "HackFocus: GetFocus()=%x hwndOCHost=%x", GetFocus(), hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // OCHost->shembed
    TraceMsg(DM_FOCUS, "HackFocus: hwndShEmbed=%x", hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // shembed->shdocvw
    TraceMsg(DM_FOCUS, "HackFocus: hwndShDocVw=%x", hwndFrom);
    hwndFrom = GetWindow(hwndFrom, GW_CHILD);   // shdocvw->iesvr
    TraceMsg(DM_FOCUS, "HackFocus: hwndIESvr=%x", hwndFrom);
    if (hwndFrom != 0) {
        TraceMsg(DM_FOCUS, "HackFocus: SetFocus(%x)", hwndFrom);
        SetFocus(hwndFrom);
    }
    return;
}
#endif

LRESULT CBrowserBand::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case OCN_ONUIACTIVATE:  // UIActivate
        ASSERT(SHIsSameObject(((LPOCNONUIACTIVATEMSG)pnm)->punk, _poipao));
        
        // n.b. we pass up 'this' not pnm->punk, since we always want to
        // be the intermediary (e.g. for UIActivateIO calls to us)

        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        return OCNONUIACTIVATE_HANDLED;

    case OCN_ONSETSTATUSTEXT:
        {
            HRESULT hr = E_FAIL;
            IShellBrowser *psb;

            hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hr)) {
                hr = psb->SetStatusTextSB(((LPOCNONSETSTATUSTEXTMSG)pnm)->pwszStatusText);
                psb->Release();
            }
        }
        break;

    case OCN_ONPOSRECTCHANGE:
        {
            LPCRECT lprcPosRect = ((LPOCNONPOSRECTCHANGEMSG)pnm)->prcPosRect;
            _sizeMin.cx = lprcPosRect->right - lprcPosRect->left;
            _sizeMin.cy = lprcPosRect->bottom - lprcPosRect->top;

            _BandInfoChanged();

            break;
        }

    default:
        break;
    }

    ASSERT(OCNONUIACTIVATE_HANDLED != 0);
    return 0;
}

// }

//***   CBrowserBand::IPersistStream::* {

HRESULT CBrowserBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_BrowserBand;

    return S_OK;
}


// mask flags for BrowserBand persistence
//
#define BB_ILSTREAM   0x00000001
#define BB_PIDLASLINK 0x00000002

// FEATURE: REVIEW: it seems to me like we should let the WebBrowserOC
// persist it's location, not us...
//
HRESULT CBrowserBand::Load(IStream *pstm)
{
    HRESULT hres;
    DWORD dw;
    
    if (_pidl) {
        ILFree(_pidl);
    }

    hres = pstm->Read(&dw, SIZEOF(DWORD), NULL);
    if (SUCCEEDED(hres))
    {
        if (dw & BB_PIDLASLINK)
        {
            hres = LoadPidlAsLink(_punkSite, pstm, &_pidl);
        }
        else if (dw & BB_ILSTREAM) // for backwards compat
        {
            hres = ILLoadFromStream(pstm, &_pidl);
        }
    }
        
    if (SUCCEEDED(hres))
        _NavigateOC();
    
    return hres;
}

HRESULT CBrowserBand::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    DWORD dw = 0;
    BSTR bstrUrl = NULL;

    if (_pauto && SUCCEEDED(_pauto->get_LocationURL(&bstrUrl)) && bstrUrl) {
        TraceMsg(DM_PERSIST, "cbb.s: current/new url=%s", bstrUrl);
        if (_pidl) {
            ILFree(_pidl);
            _pidl = NULL;       // paranoia
        }
        IECreateFromPath(bstrUrl, &_pidl);
        SysFreeString(bstrUrl);
    }

    if (_pidl)
        dw |= BB_PIDLASLINK;

    hres = pstm->Write(&dw, SIZEOF(DWORD), NULL);

    if (SUCCEEDED(hres) && (dw & BB_PIDLASLINK))
        hres = SavePidlAsLink(_punkSite, pstm, _pidl);
    
    return hres;
}

// }

//***   CBrowserBand::IPersistPropertyBag::* {

HRESULT CBrowserBand::Load(IPropertyBag *pPBag, IErrorLog *pErrLog)
{
    HRESULT hres;
    TCHAR szUrl[MAX_URL_STRING];

    TraceMsg(DM_TRACE, "cbb.l(bag): enter");

    if (_pidl) {
        ILFree(_pidl);
    }

    hres = SHPropertyBag_ReadStr(pPBag, L"Url", szUrl, ARRAYSIZE(szUrl));
    if (SUCCEEDED(hres)) {
        TCHAR * pszFinalUrl;
        TCHAR   szPlug[MAX_PATH];
        TCHAR   szMuiPath[MAX_PATH];

        pszFinalUrl = szUrl;

        hres = SHPropertyBag_ReadStr(pPBag, L"Pluggable", szPlug, ARRAYSIZE(szPlug));

        if (SUCCEEDED(hres) && !StrCmpNI(TEXT("yes"), szPlug, ARRAYSIZE(szPlug)))
        {
            TCHAR * pszFile;

            // if this is loading html out of the windows\web folder
            // then we need to call SHGetWebFolderFilePath in order
            // to support pluggable UI

            pszFile = PathFindFileName(szUrl);
            hres = SHGetWebFolderFilePath(pszFile, szMuiPath, ARRAYSIZE(szMuiPath));
            if (SUCCEEDED(hres))
            {
                pszFinalUrl = szMuiPath;
            }
        }

        hres = IECreateFromPath(pszFinalUrl, &_pidl);
        if (SUCCEEDED(hres)) {
            _NavigateOC();
        }
    }
    
    return hres;
}

// }

//***   CBrowserBand::IContextMenu::* {

HRESULT CBrowserBand::QueryContextMenu(HMENU hmenu,
    UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    int i = 0;
    HMENU hmenuMe = LoadMenuPopup_PrivateNoMungeW(MENU_BROWBAND);

    i += Shell_MergeMenus(hmenu, hmenuMe, indexMenu, idCmdFirst + i, idCmdLast, MM_ADDSEPARATOR) - (idCmdFirst + i);
    DestroyMenu(hmenuMe);

    // aka (S_OK|i)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, i);
}

HRESULT CBrowserBand::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    TraceMsg(DM_MENU, "cbb.ic");

    HRESULT hres;
    int idCmd = -1;

    // FEATURE: todo: id -= _idCmdFirst ???

    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);

    //
    // Low memory paranoia safety check
    //
    if (!_pauto) {
        TraceMsg(DM_ERROR, "CBrowserBand::InvokeCommand: _pauto IS NULL");
        return E_OUTOFMEMORY;
    }

    switch (idCmd) {
    case IDM_BROWBAND_REFRESH:
#ifdef DEBUG
        if (GetKeyState(VK_SHIFT) < 0)
            hres = _pauto->GoHome();
        else
#endif
        hres = _pauto->Refresh();
        break;
    case IDM_BROWBAND_OPENNEW:   // clone window into 'real' browser
        {
        BSTR bstrURL = NULL;

        // n.b. this clones the *current page* into a 'real' browser,
        // not the link.

        // FEATURE: todo: we'd really rather get and navigate to
        // a PIDL, but that isn't supported yet in ie4.
        hres = _pauto->get_LocationURL(&bstrURL);
        if (SUCCEEDED(hres)) {
            VARIANT varFlags;

            VariantInit(&varFlags);
            varFlags.vt = VT_I4;
            varFlags.lVal = (navOpenInNewWindow|navNoHistory);

            // n.b. we drop the post data etc. on the floor, oh well...
            hres = _pauto->Navigate(bstrURL, /*flags*/&varFlags, /*targ*/NULL, /*post*/NULL, /*hdrs*/NULL);

            VariantClear(&varFlags);
        }

        if (bstrURL)
            SysFreeString(bstrURL);

        ASSERT(SUCCEEDED(hres));

        break;
        }
    default:
        TraceMsg(DM_ERROR, "cbb::ic cmd=%d not handled", idCmd);
        break;
    }

    return S_OK;
}

// }

SIZE CBrowserBand::_GetCurrentSize()
{
    SIZE size;

    RECT rc;
    GetWindowRect(_hwnd, &rc);

    size.cx = RECTWIDTH(rc);
    size.cy = RECTHEIGHT(rc);

    return size;
}

// *** IBrowserBand methods ***
HRESULT CBrowserBand::GetObjectBB(REFIID riid, LPVOID *ppv)
{
    return _pauto ? _pauto->QueryInterface(riid, ppv) : E_UNEXPECTED;
}

#ifdef DEBUG
void CBrowserBand::_DebugTestCode()
{
    DWORD dwMask = 0x10000000;  // non-NULL bogus mask

    BROWSERBANDINFO bbi;
    bbi.cbSize = SIZEOF(BROWSERBANDINFO);

    GetBrowserBandInfo(dwMask, &bbi);
}
#endif // DEBUG

void CBrowserBand::_MakeSizesConsistent(LPSIZE psizeCur)
{
    // _sizeMin overrules _sizeMax

    if (_dwModeFlags & DBIMF_FIXED) {
        // if they specified a current size, use that instead
        // of min size
        if (psizeCur)
            _sizeMin = *psizeCur;
        _sizeMax = _sizeMin;
    } else {
        _sizeMax.cx = max(_sizeMin.cx, _sizeMax.cx);
        _sizeMax.cy = max(_sizeMin.cy, _sizeMax.cy);

        if (psizeCur) {
            psizeCur->cx = max(_sizeMin.cx, psizeCur->cx);
            psizeCur->cy = max(_sizeMin.cy, psizeCur->cy);

            psizeCur->cx = min(_sizeMax.cx, psizeCur->cx);
            psizeCur->cy = min(_sizeMax.cy, psizeCur->cy);
        }
    }
}

HRESULT CBrowserBand::SetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
{
    if (!pbbi || pbbi->cbSize != SIZEOF(BROWSERBANDINFO))
        return E_INVALIDARG;

    if (!dwMask || (dwMask & BBIM_MODEFLAGS))
        _dwModeFlags = pbbi->dwModeFlags;

    if (!dwMask || (dwMask & BBIM_TITLE)) {
        if (pbbi->bstrTitle) {
            _fCustomTitle = TRUE;
            // Change the internal _wszTitle used by Browser band
            StrCpyNW(_wszTitle, pbbi->bstrTitle, ARRAYSIZE(_wszTitle));
        } else {
            _fCustomTitle = FALSE;
        }
    }

    if (!dwMask || (dwMask & BBIM_SIZEMIN))
        _sizeMin = pbbi->sizeMin;

    if (!dwMask || (dwMask & BBIM_SIZEMAX))
        _sizeMax = pbbi->sizeMax;

    if (!dwMask || (dwMask & BBIM_SIZECUR)) {
        SIZE sizeCur = pbbi->sizeCur;
        _MakeSizesConsistent(&sizeCur);

        // HACKHACK: the only way to tell bandsite to change the height of a horizontal
        // band is to give it a new min/max height pair at the desired height.  the same
        // holds for setting the width of a vertical band.  so we temporarily give bandsite
        // new min/max size info, then restore old min/max.

        SIZE sizeMinOld = _sizeMin;
        SIZE sizeMaxOld = _sizeMax;
        _sizeMin = _sizeMax = sizeCur;

        _BandInfoChanged();

        _sizeMin = sizeMinOld;
        _sizeMax = sizeMaxOld;
    } else {
        _MakeSizesConsistent(NULL);
    }

    _BandInfoChanged();

    return S_OK;
}

// we don't have a client to test BBIM_TITLE, so leave it unimplemented for now.
#define BBIM_INVALIDFLAGS (~(BBIM_SIZEMIN | BBIM_SIZEMAX | BBIM_SIZECUR | BBIM_MODEFLAGS))

HRESULT CBrowserBand::GetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
{
    if (!pbbi || pbbi->cbSize != SIZEOF(BROWSERBANDINFO))
        return E_INVALIDARG;

    if (dwMask & BBIM_INVALIDFLAGS)
        return E_INVALIDARG;

    pbbi->dwModeFlags = _dwModeFlags;
    pbbi->sizeMin = _sizeMin;
    pbbi->sizeMax = _sizeMax;
    pbbi->sizeCur =_GetCurrentSize();

    return S_OK;
}

IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl)
{
    CBrowserBand *p = new CBrowserBand();
    if(p) {
        if (pidl)
            p->_pidl = ILClone(pidl);
    }
    return p;
}

// }

class CSearchSecurityMgrImpl : public CInternetSecurityMgrImpl 
{
    // *** IID_IInternetSecurityManager ***
    
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
    {
        HRESULT hres = INET_E_DEFAULT_ACTION;

        switch (dwAction)
        {
            case URLACTION_ACTIVEX_RUN:
            case URLACTION_SCRIPT_RUN:
            case URLACTION_SCRIPT_SAFE_ACTIVEX:
            case URLACTION_HTML_SUBMIT_FORMS:
                if (_IsSafeUrl(pwszUrl))
                {
                    if (cbPolicy >= SIZEOF(DWORD))
                    {
                        *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                        hres = S_OK;
                    }
                    else
                    {
                        hres = S_FALSE;
                    }
                }
                break;
        }
        
        return hres;
    }
};

class CCustomizeSearchHelper : public CInternetSecurityMgrImpl,
                               public IServiceProvider
{
public:

    CCustomizeSearchHelper() : _cRef(1) { }
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IID_IInternetSecurityManager ***
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);

    // *** IServiceProvider ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl) { return TRUE; }

private:
    ~CCustomizeSearchHelper() {};
    
    ULONG   _cRef;
};

STDMETHODIMP_(ULONG) CCustomizeSearchHelper::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CCustomizeSearchHelper::Release(void)
{
    if( 0L != --_cRef )
        return _cRef;

    delete this;
    return 0L;
}

HRESULT CCustomizeSearchHelper::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CCustomizeSearchHelper, IServiceProvider),
        QITABENT(CCustomizeSearchHelper, IInternetSecurityManager),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CCustomizeSearchHelper::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, 
                                                 DWORD cbPolicy, BYTE *pContext, DWORD cbContext, 
                                                 DWORD dwFlags, DWORD dwReserved)
{
   HRESULT hres = INET_E_DEFAULT_ACTION;

    switch (dwAction)
    {
        case URLACTION_ACTIVEX_RUN:
        case URLACTION_SCRIPT_RUN:
        case URLACTION_SCRIPT_SAFE_ACTIVEX:
        case URLACTION_HTML_SUBMIT_FORMS:
            if (cbPolicy >= SIZEOF(DWORD))
            {
                *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                hres = S_OK;
            }
            else
            {
                hres = S_FALSE;
            }
            break;
    }
    
    return hres;
}

STDMETHODIMP CCustomizeSearchHelper::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    if (IID_IInternetSecurityManager == guidService)
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
}


//***   CSearchBand {
//

////////////////
///  Search (BrowserOC) band

//  If you change this, change shdocvw also.
const WCHAR c_wszThisBandIsYourBand[] = L"$$SearchBand$$";

#define SEARCH_MENUID_OFFSET    100

class CSearchBand : public CBrowserBand, 
                    public IBandNavigate,
                    public ISearchBandTBHelper,
                    public CSearchSecurityMgrImpl
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IBandNavigate ***
    virtual STDMETHODIMP Select(LPCITEMIDLIST pidl);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

    // *** ISearchBandTBHelper methods ***
    virtual STDMETHODIMP AddNextMenuItem(LPCWSTR pwszText, int idItem);
    virtual STDMETHODIMP ResetNextMenu();
    virtual STDMETHODIMP SetOCCallback(IOleCommandTarget *pOleCmdTarget);
    virtual STDMETHODIMP NavigateToPidl(LPCITEMIDLIST pidl);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IWinEventHandler ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

protected:
    CSearchBand();
    virtual ~CSearchBand();

    virtual void _Connect(BOOL fConnect);
    virtual void _InitBrowser(void);
    virtual HRESULT _NavigateOC();
    
    void _AddButtons(BOOL fAdd);
    void _OnNextButtonSelect(int x, int y);
    void _OnNew();
    void _DoNext(int newPos);
    void _OnNextButtonClick();
    void _OnCustomize();
    void _OnHelp();
    void _NavigateToUrl(LPCTSTR pszUrl);
    void _EnsureImageListsLoaded();
    void _EnableNext(BOOL bEnable);
    void _NavigateToSearchUrl();

    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl);
    
    BOOL _fStrsAdded;
    LONG_PTR _lStrOffset;

    IOleCommandTarget *_pOCCmdTarget;

    HIMAGELIST  _himlNormal;
    HIMAGELIST  _himlHot;

    friend HRESULT CSearchBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor
    friend IDeskBand* CSearchBand_Create();

    HMENU _hmenuNext;
    HWND _hwndParent;
    int _nextPos;

    BOOL _bNewUrl; // set to true when we are QS'd for IInternetSecurityMgr, i.e. when pane is renavigated
    BOOL _bUseDefault; // true if we should not use our security mgr
    WCHAR _wszCache[MAX_URL_STRING];
    DWORD _nCmpLength;
    BOOL  _bIsCacheSafe;
};

CSearchBand::CSearchBand() :
    CBrowserBand()
{
    _fBlockSIDProxy = FALSE;
    _fBlockDrop = TRUE;
    _bNewUrl    = TRUE;
    ASSERT(_wszCache[0] == TEXT('\0'));
    ASSERT(_nCmpLength == 0);  
    ASSERT(_bIsCacheSafe == FALSE);
}

CSearchBand::~CSearchBand()
{
    ResetNextMenu();

    if (NULL != _himlNormal)
    {
        ImageList_Destroy(_himlNormal);
    }
    
    if (NULL != _himlHot)  
    {
        ImageList_Destroy(_himlHot);
    }

    ATOMICRELEASE(_pOCCmdTarget);
}

void CSearchBand::_NavigateToUrl(LPCTSTR pszUrl)
{
    if (NULL != _pidl)
    {
        ILFree(_pidl);
    }

    IECreateFromPath(pszUrl, &_pidl);
    _NavigateOC();
}

void CSearchBand::_NavigateToSearchUrl()
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    BOOL bFound;
    BOOL bWebSearch = FALSE;
    IBrowserService2 *pbs;
        
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IBrowserService2, &pbs))))
    {
        ITEMIDLIST *pidl;

        if (SUCCEEDED(pbs->GetPidl(&pidl)))
        {
            // FEATURE: This code should be using IShellFolder2::GetDefaultSearchGUID() and
            //     keying off SRCID_SWebSearch (vs. SRCID_SFileSearch/SRCID_SFindComputer/SRCID_SFindPrinter)
            bWebSearch = ILIsWeb(pidl);
            ILFree(pidl);
        }
        pbs->Release();
    }

    ResetNextMenu();

    if (bWebSearch)
    {
        bFound = GetDefaultInternetSearchUrl(szUrl, ARRAYSIZE(szUrl), TRUE);
    }
    else
    {
        bFound = GetSearchAssistantUrl(szUrl, ARRAYSIZE(szUrl), TRUE, FALSE);
    }

    if (bFound)
    {
        _NavigateToUrl(szUrl);
    }
}

void CSearchBand::_OnNew()
{
    VARIANT var;
    var.vt = VT_BOOL;
    var.boolVal = VARIANT_FALSE;

    if (NULL != _pOCCmdTarget)
    {
        HRESULT hr = _pOCCmdTarget->Exec(NULL, SBID_SEARCH_NEW, 0, NULL, &var);
        
        if (FAILED(hr))
        {
            var.boolVal = VARIANT_FALSE;
        }
    }

    if ((var.vt != VT_BOOL) || (!var.boolVal))
    {
        _NavigateToSearchUrl();
    }
}

void CSearchBand::_OnNextButtonSelect(int x, int y)
{
    HWND hwnd;

    if (SUCCEEDED(IUnknown_GetWindow(_punkSite, &hwnd)))
    {
        int idItem = TrackPopupMenu(_hmenuNext, TPM_RETURNCMD, x, y, 0, hwnd, NULL);

        if (0 != idItem)
        {
            _DoNext(GetMenuPosFromID(_hmenuNext, idItem));
        }        
    }
}

void CSearchBand::_DoNext(int newPos)
{
    if (NULL != _pOCCmdTarget)
    {
        CheckMenuItem(_hmenuNext, _nextPos, MF_BYPOSITION | MF_UNCHECKED);

        _nextPos = newPos;

        CheckMenuItem(_hmenuNext, _nextPos, MF_BYPOSITION | MF_CHECKED);

        VARIANT var;
        
        var.vt = VT_I4;
        var.lVal = GetMenuItemID(_hmenuNext, _nextPos) - SEARCH_MENUID_OFFSET;
        
        HRESULT hr = _pOCCmdTarget->Exec(NULL, SBID_SEARCH_NEXT, 0, &var, NULL);
        
        ASSERT(SUCCEEDED(hr));
    }
}

void CSearchBand::_OnNextButtonClick()
{
    int newPos = _nextPos + 1;
    
    if (newPos >= GetMenuItemCount(_hmenuNext))
    {
        newPos = 0;
    }

    _DoNext(newPos);
}

void CSearchBand::_OnCustomize()
{
    TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
    HWND hwnd;

    IUnknown_GetWindow(_punkSite, &hwnd);

    if (GetSearchAssistantUrl(szUrl, ARRAYSIZE(szUrl), TRUE, TRUE))
    {
        if (InternetGoOnline(szUrl, hwnd, 0))
        {
            IMoniker *pmk;

            if (SUCCEEDED(CreateURLMoniker(NULL, szUrl, &pmk)))
            {
                IHostDialogHelper *pTridentAPI;
                
                if (SUCCEEDED(CoCreateInstance(CLSID_HostDialogHelper, NULL, CLSCTX_INPROC_SERVER,
                                               IID_PPV_ARG(IHostDialogHelper, &pTridentAPI))))
                {
                    IUnknown *punkCustHelper = NULL;

                    if (_IsSafeUrl(szUrl))
                    {
                        punkCustHelper = (IUnknown *)(IServiceProvider *)new CCustomizeSearchHelper;
                    }

                    pTridentAPI->ShowHTMLDialog(hwnd, pmk, NULL, L"help:no;resizable:1", NULL, punkCustHelper);

                    if (NULL != punkCustHelper)
                    {
                        punkCustHelper->Release();
                    }

                    pTridentAPI->Release();
                }

                pmk->Release();
            }
        }
    }
}

void CSearchBand::_OnHelp()
{
    HWND hwnd;

    IUnknown_GetWindow(_punkSite, &hwnd);

#ifndef UNIX
    SHHtmlHelpOnDemandWrap(hwnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("srchasst.htm"), ML_CROSSCODEPAGE);
#else
    {
        IServiceProvider* psp = NULL;

        OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IServiceProvider, &psp));
        if (psp)
        {
            IShellBrowser* psb;
            if (EVAL(SUCCEEDED(psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IShellBrowser, &psb)))))
            {
                UnixHelp(L"Search Help", psb);
                psb->Release();
            }
            psp->Release();
        }
    }
#endif
}

HRESULT CSearchBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_SearchBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBID_SEARCH_NEW:
            _OnNew();
            return S_OK;

        case SBID_SEARCH_NEXT:
            if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
            {
                if ((NULL != pvarargIn) && (pvarargIn->vt == VT_I4))
                {
                    ASSERT(NULL != _hmenuNext);
                    _OnNextButtonSelect(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
                }
            }
            else
            {
                _OnNextButtonClick();
            }
            return S_OK;

        case SBID_SEARCH_CUSTOMIZE:
            _OnCustomize();
            return S_OK;

        case SBID_SEARCH_HELP:
            _OnHelp();
            return S_OK;

        case SBID_HASPIDL:
            // Simply return whether or not the band has a pidl
            if (_pidl)
                return S_OK;
            else
                return S_FALSE;
            
        case SBID_GETPIDL:
            {
                HRESULT hres = E_INVALIDARG;
                
                if (pvarargOut)
                {
                    hres = E_OUTOFMEMORY;
                    VariantInit(pvarargOut); // zero init it
                    if (!_pidl || SUCCEEDED(InitVariantFromIDList(pvarargOut, _pidl)))
                        hres = S_OK;
                }
                return hres;
            }
        }
    }
    return CBrowserBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define INDEX_NEXT          1
#define INDEX_CUSTOMIZE     3
static const TBBUTTON c_tbSearch[] =
{
    {  0,           SBID_SEARCH_NEW,       TBSTATE_ENABLED,   BTNS_AUTOSIZE | BTNS_SHOWTEXT,                 {0, 0}, 0, 0},
    {  1,           SBID_SEARCH_NEXT,      0,                 BTNS_AUTOSIZE | BTNS_DROPDOWN | BTNS_SHOWTEXT, {0, 0}, 0, 1},
    {  0,           0,                     TBSTATE_ENABLED,   BTNS_SEP,                                      {0, 0}, 0, 0},
    {  I_IMAGENONE, SBID_SEARCH_CUSTOMIZE, TBSTATE_ENABLED,   BTNS_AUTOSIZE | BTNS_SHOWTEXT,                 {0, 0}, 0, 2}
};

void CSearchBand::_EnableNext(BOOL bEnable)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        UINT state;

        if (SUCCEEDED(piet->GetState(&CGID_SearchBand, SBID_SEARCH_NEXT, &state)))
        {
            if (bEnable)
            {
                state |= TBSTATE_ENABLED;
            }
            else
            {
                state &= ~TBSTATE_ENABLED;
            }
            piet->SetState(&CGID_SearchBand, SBID_SEARCH_NEXT, state);
        }

        piet->Release();
    }
}

void CSearchBand::_AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CGID_SearchBand, 0);

            if (!_fStrsAdded)
            {
                LONG_PTR   cbOffset;
                piet->AddString(&CGID_SearchBand, MLGetHinst(), IDS_SEARCH_BAR_LABELS, &cbOffset);
                _lStrOffset = cbOffset;
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CGID_SearchBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbSearch[ARRAYSIZE(c_tbSearch)];
            UpdateButtonArray(tbSearch, c_tbSearch, ARRAYSIZE(c_tbSearch), _lStrOffset);

            if (SHRestricted2(REST_NoSearchCustomization, NULL, 0))
            {
                tbSearch[INDEX_CUSTOMIZE].fsState &= ~TBSTATE_ENABLED;
            }

            if (NULL != _hmenuNext)
            {
                tbSearch[INDEX_NEXT].fsState |= TBSTATE_ENABLED;
            }

            piet->AddButtons(&CGID_SearchBand, ARRAYSIZE(tbSearch), tbSearch);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

void CSearchBand::_EnsureImageListsLoaded()
{
    if (_himlNormal == NULL)
    {
        _himlNormal = ImageList_LoadImage(HINST_THISDLL, 
                                          MAKEINTRESOURCE(IDB_SEARCHBANDDEF), 
                                          18, 
                                          0, 
                                          RGB(255, 0, 255),
                                          IMAGE_BITMAP, 
                                          LR_CREATEDIBSECTION);
    }

    if (_himlHot == NULL)
    {
        _himlHot = ImageList_LoadImage(HINST_THISDLL, 
                                       MAKEINTRESOURCE(IDB_SEARCHBANDHOT), 
                                       18, 
                                       0, 
                                       RGB(255, 0, 255),
                                       IMAGE_BITMAP, 
                                       LR_CREATEDIBSECTION);
    }
}

HRESULT CSearchBand::AddNextMenuItem(LPCWSTR pwszText, int idItem)
{
    if (NULL == _hmenuNext)
    {
        _hmenuNext = CreatePopupMenu();
    }

    ASSERT(NULL != _hmenuNext);

    if (NULL != _hmenuNext)
    {

#ifdef DEBUG
        //  Check to see if an item with this ID has already been added
        MENUITEMINFO dbgMii = { sizeof(dbgMii) };
        dbgMii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hmenuNext, idItem + SEARCH_MENUID_OFFSET, FALSE, &dbgMii))
        {
            TraceMsg(DM_ERROR, "Adding duplicate menu item in CSearchBand::AddNextMenuItem");
        }
#endif

        int nItems = GetMenuItemCount(_hmenuNext);
        
        MENUITEMINFOW mii = { sizeof(mii) };

        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.wID = (WORD)idItem + SEARCH_MENUID_OFFSET;
        mii.fType = MFT_RADIOCHECK | MFT_STRING;
        mii.dwTypeData = (LPWSTR)pwszText;
        mii.cch = lstrlenW(pwszText);

        BOOL result = InsertMenuItemW(_hmenuNext, nItems, TRUE, &mii);

        if (result)
        {
            if (0 == nItems)
            {
                CheckMenuItem(_hmenuNext, 0, MF_BYPOSITION | MF_CHECKED);
                _EnableNext(TRUE);
            }
        }
    }
    
    return S_OK;
}

HRESULT CSearchBand::ResetNextMenu()
{
    if (NULL != _hmenuNext)
    {
        _nextPos = 0;
        _EnableNext(FALSE);
        DestroyMenu(_hmenuNext);
        _hmenuNext = NULL;
    }
    return S_OK;
}

HRESULT CSearchBand::SetOCCallback(IOleCommandTarget *pOleCmdTarget)
{
    ResetNextMenu();

    ATOMICRELEASE(_pOCCmdTarget);

    _pOCCmdTarget = pOleCmdTarget;

    if (NULL != _pOCCmdTarget)
    {
        _pOCCmdTarget->AddRef();
    }
    
    return S_OK;
}

//
// CSearchBand::NavigateToPidl
//
// Implements ISearchBandTBHelper::NavigateToPidl
//
// This is *almost* the same as CSearchBand::Select, except that it always navigates, whereas
// CSearchBand::Select will skip navigation if the search band is already displaying that pidl.
// We need that function to retain that behavior so that the search pane retains its results when
// opened.
//
HRESULT CSearchBand::NavigateToPidl(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    _pidl = ILClone(pidl);
    return _NavigateOC();
}

HRESULT CSearchBand::ShowDW(BOOL fShow)
{
#ifdef UNIX
    // We overide this method in order to provide renavigation if our earlier navigation
    // was cancelled for some reason.

    if (fShow)
    {
         // Should be there.
         // Just being sure we are able to navigate.

         ASSERT(IsWindow(_hwnd));
         ASSERT( _pidl );

         if (_pauto)
         {
             BSTR bstrURL = NULL;
             TCHAR szLocation[MAX_URL_STRING];

             // SHUnicodeToTChar does this - no memset 
             // memset(szLocation, 0, SIZEOF(szLocation));

             if( SUCCEEDED(_pauto->get_LocationURL(&bstrURL)) && bstrURL )
             {
                 // Fire navigation again if the navigation was canceled earlier for
                 // some reason (Maybe the proxy was not set).

                 SHUnicodeToTChar(bstrURL, szLocation, ARRAYSIZE(szLocation));
                 if( !StrCmpI( szLocation, NAVCANCELLED_URL ) ||
                     !StrCmpI( szLocation, OFFLINEINFO_URL  ) )
                     _NavigateOC();

                 SysFreeString(bstrURL);
             }

         }
    }
#endif

    HRESULT hres = CBrowserBand::ShowDW(fShow);
    _AddButtons(fShow);
    return hres;
}

HRESULT CSearchBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    // aggregation checking is handled in class factory
    HRESULT hr = CreateFromRegKey(REGSTR_PATH_EXPLORER, TEXT("WebFindBandHook"), IID_PPV_ARG(IUnknown, ppunk));
    if (FAILED(hr))
    {
        CSearchBand *p = new CSearchBand();
        if (p)
        {
            *ppunk = SAFECAST(p, IDeskBand*);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

IDeskBand* CSearchBand_Create()
{
    IDeskBand* pistb = NULL;

    IUnknown *punk;
    HRESULT hr = CSearchBand_CreateInstance(NULL, &punk, NULL);
    if (SUCCEEDED(hr))
    {
        punk->QueryInterface(IID_PPV_ARG(IDeskBand, &pistb));
        ASSERT(pistb);
        punk->Release();
    }
    return pistb;
}

HRESULT CSearchBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSearchBand, IContextMenu),
        QITABENT(CSearchBand, IBandNavigate),
        QITABENT(CSearchBand, ISearchBandTBHelper),
        QITABENT(CSearchBand, IServiceProvider),
        QITABENT(CSearchBand, IInternetSecurityManager),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CBrowserBand::QueryInterface(riid, ppvObj);

    return hres;
}

ULONG CSearchBand::AddRef()
{
    return CBrowserBand::AddRef();
}

ULONG CSearchBand::Release()
{
    return CBrowserBand::Release();
}

void CSearchBand::_Connect(BOOL fConnect)
{
    CBrowserBand::_Connect(fConnect);

    //  Now we need to expose ourselves so the control in the search assistant
    //  can talk to us.

    if (_pauto) 
    {
        IWebBrowserApp *pWebBrowserApp;
        HRESULT hr = _pauto->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pWebBrowserApp));

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pWebBrowserApp);
            
            BSTR bstrProp = SysAllocString(c_wszThisBandIsYourBand);
    
            if (NULL != bstrProp)
            {
                VARIANT varThis;
    
                if (fConnect)
                {
                    varThis.vt = VT_UNKNOWN;
                    varThis.punkVal = (IBandNavigate *)this;
                }
                else
                {
                    varThis.vt = VT_EMPTY;
                }           
    
                pWebBrowserApp->PutProperty(bstrProp, varThis);
                
                SysFreeString(bstrProp);
            }
    
            pWebBrowserApp->Release();
        }
    }
}

void CSearchBand::_InitBrowser(void)
{
    CBrowserBand::_InitBrowser();
}

HRESULT CSearchBand::_NavigateOC()
{
    HRESULT hres = E_FAIL;

    if (_pidl) // don't want search pane to be navigated to home.
        return CBrowserBand::_NavigateOC();

    return hres;
}

HRESULT CSearchBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    pdbi->ptMinSize.x = 16;
    pdbi->ptMinSize.y = 0;
    pdbi->ptMaxSize.x = 32000; // random
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;

    MLLoadStringW(IDS_BAND_SEARCH, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    
    return S_OK;
} 

//***   CSearchBand::IPersistStream::* {

HRESULT CSearchBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_SearchBand;

    return S_OK;
}

HRESULT CSearchBand::Load(IStream *pstm)
{
    _NavigateOC();
    
    return S_OK;
}

HRESULT CSearchBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

HRESULT CSearchBand::Select(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;
    IServiceProvider *psp = NULL;
    LPITEMIDLIST pidlTemp = NULL;

    OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IServiceProvider, &psp));
    if (psp)
    {
        IBrowserService * pbs;
        if (EVAL(SUCCEEDED(psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs)))))
        {
            pbs->GetPidl(&pidlTemp);
            pbs->Release();
        }
        psp->Release();
    }

    if ((!pidlTemp) || (!ILIsEqual(pidlTemp, pidl)))
    {
        ILFree(_pidl);
        _pidl = ILClone(pidl);
        hres = _NavigateOC();
    }
    ILFree(pidlTemp);
    return hres;
}

STDMETHODIMP CSearchBand::QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hres;
    
    if (IsEqualGUID(guidService, SID_SInternetSecurityManager))
    {
        _bNewUrl = TRUE;
        hres = QueryInterface(riid, ppvObj);
    }
    else
        hres = CBrowserBand::QueryService(guidService, riid, ppvObj);

    return hres;
}

HRESULT CSearchBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if ((WM_WININICHANGE == uMsg) && lParam &&
        ((0 == StrCmpW((LPCWSTR)lParam, SEARCH_SETTINGS_CHANGEDW)) ||
         (0 == StrCmpA((LPCSTR) lParam, SEARCH_SETTINGS_CHANGEDA))))
    {
        _NavigateToSearchUrl();
    }   

    return CBrowserBand::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}



BOOL CSearchBand::_IsSafeUrl(LPCWSTR pwszUrl)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    if (_bNewUrl || !_bUseDefault)
    {
        WCHAR wsz[MAX_URL_STRING];
        DWORD cch = ARRAYSIZE(wsz);

        if (SUCCEEDED(UrlCanonicalizeW(pwszUrl, wsz, &cch, 0)) && cch > 0)
        {
            // the first time this f-n is called, url passed in is the url of
            // the top most frame -- if that's not one of our 'safe' urls we
            // don't want to use this security mgr because it is possible 
            // that the outer frame hosts iframe w/ 'safe' site and scripts
            // shell dispatch from the outside thus being able to do anything
            // it wants.
            if (_wszCache[0] != L'\0')
            {
                if ((_nCmpLength && StrCmpNIW(wsz, _wszCache, _nCmpLength) == 0)
                || (!_nCmpLength && StrCmpIW(wsz, _wszCache) == 0))
                    return _bIsCacheSafe;
            }
            
            if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SafeSites", 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {        
                WCHAR wszValue[MAX_PATH];
                WCHAR wszData[MAX_URL_STRING];
                DWORD cbData = SIZEOF(wszData);
                DWORD cchValue = ARRAYSIZE(wszValue);

                for (int i=0; RegEnumValueW(hkey, i, wszValue, &cchValue, NULL, NULL, (LPBYTE)wszData, &cbData) == ERROR_SUCCESS; i++)
                {
                    if (SHExpandEnvironmentStringsW(wszData, _wszCache, ARRAYSIZE(_wszCache)) > 0)
                    {
                        cchValue = ARRAYSIZE(_wszCache);
                        if (SUCCEEDED(UrlCanonicalizeW(_wszCache, _wszCache, &cchValue, 0)) && (cchValue > 0))
                        {
                            if (_wszCache[cchValue - 1] == L'*')
                            {
                                _nCmpLength = cchValue - 1;
                                bRet = StrCmpNIW(wsz, _wszCache, _nCmpLength) == 0;
                            }
                            else
                            {
                                _nCmpLength = 0;
                                bRet = StrCmpIW(wsz, _wszCache) == 0;
                            }

                            _bIsCacheSafe = bRet;
                            if (bRet)
                                break;
                        }
                        cbData = SIZEOF(_wszCache);
                        cchValue = ARRAYSIZE(wszValue);
                    }
                }
                RegCloseKey(hkey);        
            }

            // we did not find the url in the list of 'safe' sites
            // _wszCache now point to the last url read from the registry
            // ajdust it to point pwszUrl, _bIsCacheSafe is correct already
            if (!bRet)
                lstrcpynW(_wszCache, wsz, ARRAYSIZE(_wszCache));

            if (_bNewUrl)
            {
                _bNewUrl = FALSE;
                _bUseDefault = !bRet;
            }
        }
    }
        
    return bRet;
}



//***   CCommBand {
//

////////////////
///  Comm (BrowserOC) band

class CCommBand : public CBrowserBand
{

public:    
    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

protected:
    CCommBand();
    virtual ~CCommBand();

    friend HRESULT CCommBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor

};

CCommBand::CCommBand() :
    CBrowserBand()
{
    _fBlockSIDProxy = FALSE;
    _fBlockDrop = TRUE;
    _fCustomTitle = TRUE;
    _wszTitle[0] = L'\0';

    _dwModeFlags = DBIMF_VARIABLEHEIGHT;

    return;
}

CCommBand::~CCommBand()
{
}

HRESULT CCommBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    LPITEMIDLIST pidlNew;
    HRESULT hr = IECreateFromPath(L"about:blank", &pidlNew);
    if (SUCCEEDED(hr))
    {
        CCommBand *p = new CCommBand();
        if (p)
        {
            p->_pidl = pidlNew;
            *ppunk = SAFECAST(p, IDeskBand*);
            hr = S_OK;
        }
        else
        {
            ILFree(pidlNew);
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}



//***   CCommBand::IPersistStream::* {

HRESULT CCommBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_CommBand;

    return S_OK;
}

HRESULT CCommBand::Load(IStream *pstm)
{
//    _NavigateOC();
    
    return S_OK;
}

HRESULT CCommBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

HRESULT CCommBand::ShowDW(BOOL fShow)
{
    // so that the contained Browser OC event gets fired
    if (_pauto) {
        _pauto->put_Visible(fShow);
    }

    return CBrowserBand::ShowDW(fShow);
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\basebar.h ===
#ifndef BaseBar_H_
#define BaseBar_H_
#include "cwndproc.h"

#ifdef __cplusplus

//========================================================================
// class CBaseBar (CBaseBar* pwbar)
//========================================================================
class CBaseBar : public IOleCommandTarget
               , public IServiceProvider
               , public IDeskBar
                ,public IInputObjectSite
                ,public IInputObject
               , public CImpWndProc
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk);
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient);
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

protected:
    // Constructor & Destructor
    CBaseBar();
    virtual ~CBaseBar();
    friend HRESULT CBaseBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    
    BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);    

    virtual void _NotifyModeChange(DWORD dwMode); // NOTE: we may be abhe to get rid of this virtual...
    void _GetBorderRect(RECT* prc);

    virtual STDMETHODIMP ShowDW(BOOL fShow); // match IDockingWindow::ShowDW
    virtual STDMETHODIMP CloseDW(DWORD dwReserved); // match IDockingWindow::CloseDW
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual LRESULT _OnNotify(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnSize(void);
    virtual void _OnCreate();
    virtual void _OnPostedPosRectChange();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Member variables
    UINT            _cRef;                  // reference count
    IUnknown*       _punkChild;             // ptr to IUnknown  for client area
    IDeskBarClient*     _pDBC;              // cached BaseBarClient for _punkChild
    IWinEventHandler*   _pWEH;              // cached IWenEventHandler for _punkChild
    HWND            _hwndChild;             // cached HWND      for _punkChild
    HWND            _hwndSite;              // hwnd of the site

    BOOL            _fShow :1;
    BOOL            _fPosRectChangePending;

    DWORD           _dwMode;

    SIZE            _szChild;               // last requested size from child

private:
    // Private members
    void _RegisterDeskBarClass();
    void _CreateDeskBarWindow();

};

#endif // __cplusplus
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browband.h ===
#ifndef _BROWBAND_H_
#define _BROWBAND_H_


class CBrowserBand :
    public CToolBand
    ,public IContextMenu
    ,public IWinEventHandler
    ,public IDispatch
    ,public IBrowserBand
    ,public IPersistPropertyBag
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    
    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) ;

    // *** IPersistPropertyBag methods ***
    virtual STDMETHODIMP InitNew()
        { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IPropertyBag* pPBag, IErrorLog *pErrLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
        { return E_NOTIMPL; };

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo){return(E_NOTIMPL);}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid){return(E_NOTIMPL);}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IBrowserBand methods ***
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHOD(SetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi);
    STDMETHOD(GetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi);

protected:
    CBrowserBand();
    virtual ~CBrowserBand();

    friend HRESULT CBrowserBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);       // for ctor
    friend IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl);

    virtual void _Connect(BOOL fConnect);
    HRESULT _CreateOCHost();
    virtual void _InitBrowser(void);
    virtual HRESULT _NavigateOC();
    LRESULT _OnNotify(LPNMHDR pnm);
    SIZE _GetCurrentSize();

#ifdef DEBUG
    void _DebugTestCode();
#endif
    void _MakeSizesConsistent(LPSIZE psizeCur);

    IWebBrowser2 * _pauto;
    IOleInPlaceActiveObject * _poipao;
    LPITEMIDLIST _pidl;
    DWORD _dwcpCookie;
    WCHAR _wszTitle[40];
    BOOL    _fBlockSIDProxy:1; // SID_SProxyBrowser
    BOOL    _fBlockDrop:1;     // should we block drop on contents

    BOOL    _fCustomTitle:1;
    DWORD   _dwModeFlags;
    SIZE    _sizeMin;
    SIZE    _sizeMax;
};


#endif // _BROWBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browbar.cpp ===
// coming soon: new deskbar (old deskbar moved to browbar base class)

#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "browbs.h"
#include "browbar.h"
#include "theater.h"
#include "shbrows2.h"
#include "varutil.h"

#ifdef UNIX
#include <mainwin.h>
#endif

#define SUPERCLASS  CDockingBar

static const WCHAR c_szExplorerBars[]  = TEXT("Software\\Microsoft\\Internet Explorer\\Explorer Bars\\");

//***   CBrowserBar_CreateInstance --
//
STDAPI CBrowserBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBrowserBar *pwbar = new CBrowserBar();
    if (pwbar) {
        *ppunk = SAFECAST(pwbar, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//***
// NOTES
// this creates the BrowserBar (infobar) and sets up it's specific style
// such as captionless rebar and such
HRESULT BrowserBar_Init(CBrowserBar* pdb, IUnknown** ppbs, int idBar)
{
    HRESULT hr;
    
    if (ppbs)
        *ppbs = NULL;
    
    CBrowserBandSite *pcbs = new CBrowserBandSite();
    if (pcbs)
    {
        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        
        BANDSITEINFO bsinfo;
        
        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_LEFTALIGN;
        
        pcbs->SetBandSiteInfo(&bsinfo);
        
        hr = pdb->SetClient(pdbc);
        if (SUCCEEDED(hr))
        {
            if (ppbs) 
            {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
        }
        pdbc->Release();
        
        ASSERT(idBar == IDBAR_VERTICAL || idBar == IDBAR_HORIZONTAL);
        pdb->SetIdBar(idBar);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//*** CBrowserBar::IPersistStream*::* {

HRESULT CBrowserBar::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_BrowserBar;
    return S_OK;
}

HRESULT CBrowserBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        return IUnknown_Exec(_punkChild, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID) {
        case DBCID_EMPTY:
            if (_ptbSite) {
                // if we have no bands left, hide
                VARIANT var = {VT_UNKNOWN};
                var.punkVal = SAFECAST(this, IDeskBar*);
                AddRef();

                _StopCurrentBand();
                
                IUnknown_Exec(_ptbSite, &CGID_Explorer, SBCMDID_TOOLBAREMPTY, nCmdexecopt, &var, NULL);
                VariantClearLazy(&var);
            }
            break;

        case DBCID_RESIZE:
            goto ForwardUp;
            break;

        case DBCID_CLSIDOFBAR:
            ASSERT(nCmdexecopt == 0 || nCmdexecopt == 1);
            
            if (nCmdexecopt == 0)
            {
                //bar is being hidden
                _StopCurrentBand();
                _clsidCurrentBand = GUID_NULL;
            }
            else if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                CLSID clsidTemp;

                GUIDFromString(pvarargIn->bstrVal, &clsidTemp);

                //if given a clsid and it's a new one, save the old one's settings
                //then set it as the current clsid
                if (!IsEqualIID(clsidTemp, _clsidCurrentBand))
                {
                    _PersistState(_hwnd, TRUE);
                    _StopCurrentBand();
                }
                _clsidCurrentBand = clsidTemp;

                if (_hwnd && IsWindow(_hwnd))
                {
                    UINT uiNewWidthOrHeight = _PersistState(_hwnd, FALSE);
                    RECT rc = {0};

                    GetWindowRect(_hwnd, &rc);
        
                    if (_idBar == IDBAR_VERTICAL)
                        rc.right = rc.left + uiNewWidthOrHeight;
                    else
                        rc.top = rc.bottom - uiNewWidthOrHeight;
                    SetWindowPos(_hwnd, NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
                }
            }
            else if (!pvarargIn && pvarargOut)
            {
                return InitBSTRVariantFromGUID(pvarargOut, _clsidCurrentBand);
            }
            else
                ASSERT(FALSE);
            break;
        }
        return S_OK;
    } 
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) {
        switch (nCmdID) {
        case THID_ACTIVATE:
            // if we're on a small monitor, start off as autohide
            _fTheater = TRUE;
            ResizeBorderDW(NULL, NULL, FALSE);
            _OnSize();

            // pass back pin button's state
            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = !_fNoAutoHide;

            break;

        case THID_DEACTIVATE:
            _fTheater = FALSE;
            // if we're on a small monitor, restore to theater default width
            _szChild.cx = _iTheaterWidth;
            _AdjustToChildSize();
            break;

        case THID_SETBROWSERBARAUTOHIDE:
            // pvarargIn->lVal contains new _fAutoHide.
            // fake message pin button was pressed only when _fNoAutoHide == pvarargIn->lVal
            // which means new _fNoAutoHide != old _fNoAutoHide
            if ((_fNoAutoHide && pvarargIn->lVal) || !(_fNoAutoHide || pvarargIn->lVal)) {
                // first update state and change bitmap
                _fNoAutoHide = !pvarargIn->lVal;

                // then notify theater mode manager because it owns the msg hook and does 
                // the hiding
                IUnknown_Exec(_ptbSite, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, pvarargIn, NULL);

                // negotiate with the browser for space
                _Recalc();
                _PersistState(_hwnd, FALSE);
            }
            break;
                
        default:
            goto ForwardUp;
        }
        
        IUnknown_Exec(_punkChild, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    }
    
ForwardUp:
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define ABS(i)  (((i) < 0) ? -(i) : (i))

void CBrowserBar::_HandleWindowPosChanging(LPWINDOWPOS pwp)
{
    if (_fDragging) {
        int cxMin = GetSystemMetrics(SM_CXVSCROLL) * 4;
        
        if (pwp->cx < cxMin)
            pwp->cx = cxMin;
    }
}

LRESULT CBrowserBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_NCHITTEST:
    {
        LRESULT lres = _OnNCHitTest(wParam, lParam);
#ifdef DEBUG
        // non-LHS bar useful for testing discussion bar etc. stuff
        // so allow drag to get it there
        if (0)
#endif
        {
            // don't allow drag in browbar
            if (lres == HTCAPTION)
                lres = HTCLIENT;
        }
        return lres;
    }
        
    case WM_ERASEBKGND:
        if (_fTheater) {
            HDC hdc = (HDC) wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, RGB(0,0,0));
            return 1;
        }
        break;
        
    case WM_EXITSIZEMOVE:
        {  // save explorer bar's new width to registry
            _PersistState(hwnd, TRUE);
        }
        break;

    case WM_SIZE:
        {
            // browser bandsite needs to hear about resizing
            LRESULT lres;
            _CheckForwardWinEvent(uMsg, wParam, lParam, &lres);
        }
        break;
    } 
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

BOOL CBrowserBar::_CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwnd = NULL;

    switch (uMsg) {
    case WM_SIZE:
        {
            // HACKHACK: munge the size so that width is browbandsite's 
            // new width.  bbs needs to hear about resizing so that it
            // can reposition its close/autohide window.
            POINT pt = {LOWORD(lParam), HIWORD(lParam)};
            pt.x -= 4 * GetSystemMetrics(SM_CXEDGE);
            lParam = MAKELONG(pt.x, pt.y);
            hwnd = _hwndChild;
            break;
        }
    }

    if (hwnd && _pWEH && _pWEH->IsWindowOwner(hwnd) == S_OK) {
        _pWEH->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
        return TRUE;
    }
    return SUPERCLASS::_CheckForwardWinEvent(uMsg, wParam, lParam, plres);
}

void CBrowserBar::_GetChildPos(LPRECT prc)
{
    GetClientRect(_hwnd, prc);
    if (_fTheater)
        prc->right--;
    else 
    {
        // Make room for the resizing bar and make sure the right scrollbar is
        // tucked under the right edge of the parent if we are on the top or bottom
        switch(_uSide)
        {
            case ABE_TOP:
                prc->bottom -= GetSystemMetrics(SM_CYFRAME);
                prc->right += GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_BOTTOM:
                prc->top += GetSystemMetrics(SM_CYFRAME);
                prc->right += GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_LEFT:
                prc->right -= GetSystemMetrics(SM_CXFRAME);
                break;
            case ABE_RIGHT:
                prc->left += GetSystemMetrics(SM_CXFRAME);
                break;
        }
    }

    if (prc->left > prc->right)
        prc->right = prc->left;
    if (prc->top > prc->bottom)
        prc->bottom = prc->top;
}

void CBrowserBar::_GetStyleForMode(UINT eMode, LONG* plStyle, LONG *plExStyle, HWND* phwndParent)
{
    *plStyle = WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
    *plExStyle= 0;
    *phwndParent = PARENT_BBTMMOST();
}


// bSetNewRect controls whether we override the current rect or autohide setting
UINT CBrowserBar::_PersistState(HWND hwnd, BOOL bSetNewRect)
{
    BROWBARSAVE bbs = {0};
    RECT rc = {0};
    UINT retval = 0;

    if (IsEqualIID(_clsidCurrentBand, GUID_NULL))
    {
        //FEATURE: this assert is getting hit, why?
        //ASSERT(FALSE);  //do we even need to check this anymore?
        return 0;
    }

    // use current uiWidthOrHeight and fAutoHide in case there is no value in registry yet
    if (hwnd)
    {
        GetWindowRect(hwnd, &rc); // bad hack
        if (_idBar == IDBAR_VERTICAL)
            bbs.uiWidthOrHeight = RECTWIDTH(rc);
        else
            bbs.uiWidthOrHeight = RECTHEIGHT(rc);
    }
    bbs.fAutoHide = !_fNoAutoHide; 

    WCHAR wszClsid[GUIDSTR_MAX];
    DWORD dwType = REG_BINARY;
    DWORD cbSize = SIZEOF(BROWBARSAVE);
    SHStringFromGUID(_clsidCurrentBand, wszClsid, ARRAYSIZE(wszClsid));

    WCHAR wszKeyPath[MAX_PATH];
    StrCpyN(wszKeyPath, c_szExplorerBars, ARRAYSIZE(wszKeyPath));
    StrCatBuff(wszKeyPath, wszClsid, ARRAYSIZE(wszKeyPath));
    
    SHRegGetUSValueW(wszKeyPath, L"BarSize", &dwType, (LPBYTE)&bbs, &cbSize, FALSE, NULL, 0);

    //if there is no window yet and no saved size, pick a reasonable default
    if (bbs.uiWidthOrHeight == 0)
        bbs.uiWidthOrHeight = (IDBAR_VERTICAL == _idBar) ? COMMBAR_HEIGHT : INFOBAR_WIDTH;

    if (bSetNewRect)
    {
        if (_idBar == IDBAR_VERTICAL)
        {
            bbs.uiWidthOrHeight = RECTWIDTH(rc);
            retval = RECTWIDTH(rc);
        }
        else
        {
            bbs.uiWidthOrHeight = RECTHEIGHT(rc);
            retval = RECTHEIGHT(rc);
        }
    }        
    else
    {
        bbs.fAutoHide = !_fNoAutoHide;
        retval = bbs.uiWidthOrHeight;
    }

    if (bSetNewRect)
        SHRegSetUSValueW(wszKeyPath, L"BarSize", dwType, (LPBYTE)&bbs, cbSize, SHREGSET_FORCE_HKCU);

    return retval;
}

void CBrowserBar::_StopCurrentBand()
{
    //stop any streaming content or navigations, except for the search band if we stop it
    // then we could have incompletely loaded ui
    if (!IsEqualGUID(CLSID_SearchBand, _clsidCurrentBand))
    {
        IUnknown_Exec(_punkChild, NULL, OLECMDID_STOP, 0, NULL, NULL);
    }
}


// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browbs.cpp ===
#include "priv.h"
#include "theater.h"
#include "browbs.h"
#include "resource.h"
#include "legacy.h"
#include "uxtheme.h"        // needed for Margin.
#include "mluisupp.h"
#include "apithk.h"

#define SUPERCLASS CBandSite

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault);

#define ABS(x) (((x) < 0) ? -(x) : (x))
#define CX_TEXTOFFSET   6
#define CY_TEXTOFFSET   4
#define CX_TBOFFSET     1
#define CY_TBPADDING    1
#define CY_ETCH         2
#define CY_FLUFF        7


// *** IInputObject methods ***
HRESULT CBrowserBandSite::HasFocusIO()
{
    HWND hwnd = GetFocus();
    if (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB))
        return S_OK;
    else
        return SUPERCLASS::HasFocusIO();
}

// *** IDeskBarClient methods ***
HRESULT CBrowserBandSite::SetModeDBC(DWORD dwMode)
{
    if ((dwMode ^ _dwMode) & DBIF_VIEWMODE_VERTICAL) {
        // switching horizontal/vertical; need to toggle toolbar
        // since we hide toolbar for horizontal bars
        if (_hwndTBRebar) {
            if (dwMode & DBIF_VIEWMODE_VERTICAL) {
                ShowWindow(_hwndTBRebar, SW_SHOW);
                _fToolbar = _pCmdTarget ? TRUE : FALSE;
            } else {
                ShowWindow(_hwndTBRebar, SW_HIDE);
                _fToolbar = FALSE;
            }
        }
    }

    return SUPERCLASS::SetModeDBC(dwMode);
}

HRESULT CBrowserBandSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CBrowserBandSite::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, lpMsg->wParam);

    HRESULT hr = S_FALSE;

    ASSERT((lpMsg->message >= WM_KEYFIRST) && (lpMsg->message <= WM_KEYLAST));

#if 0   //Disabled until a better key combination can be determined
    // check for Control-Shift arrow keys and resize if necessary
    if ((GetKeyState(VK_SHIFT) < 0)  && (GetKeyState(VK_CONTROL) < 0))
    {
        switch (lpMsg->wParam)
        {
            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
                IUnknown_Exec(_punkSite, &CGID_DeskBarClient, DBCID_RESIZE, (DWORD)lpMsg->wParam, NULL, NULL);
                return S_OK;
        }
    }
#endif

    if (!g_fRunningOnNT && (lpMsg->message == WM_SYSCHAR))
    {
        // See AnsiWparamToUnicode for why this character tweak is needed
        
        lpMsg->wParam = AnsiWparamToUnicode(lpMsg->wParam);
    }

    //  Give toolbar a crack
    if (hr != S_OK && _hwndTB && SendMessage(_hwndTB, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;
    else if (hr != S_OK && SendMessage(_hwndOptionsTB, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    // to get a mapping, forward system characters to toolbar (if any) or xBar
    if (WM_SYSCHAR == lpMsg->message)
    {
        if (hr == S_OK)
        {
            return S_OK;
        }

        if ((NULL != _hwndTB) && (NULL != _pCmdTarget))
        {
            UINT idBtn;

            if (SendMessage(_hwndTB, TB_MAPACCELERATOR, lpMsg->wParam, (LPARAM)&idBtn))
            {
                TCHAR szButtonText[MAX_PATH];

                //  comctl says this one is the one, let's make sure we aren't getting
                //  one of the unwanted "use the first letter" accelerators that it
                //  will return.
    
                if ((SendMessage(_hwndTB, TB_GETBUTTONTEXT, idBtn, (LPARAM)szButtonText) > 0) &&
                    (GetAccelerator(szButtonText, FALSE) != (TCHAR)-1))
                {
                    //  (tnoonan) - it feels kinda cheesy to send mouse messages, but 
                    //  I don't know of a cleaner way which will accomplish what we
                    //  want (like deal with split buttons, mutually exclusive 
                    //  buttons, etc.).
        
                    RECT rc;

                    SendMessage(_hwndTB, TB_GETRECT, idBtn, (LPARAM)&rc);

                    SendMessage(_hwndTB, WM_LBUTTONDOWN, MK_LBUTTON, MAKELONG(rc.left, rc.top));
                    SendMessage(_hwndTB, WM_LBUTTONUP, 0, MAKELONG(rc.left, rc.top));

                    hr = S_OK;
                }
            }
        }
    }

    if (hr != S_OK)
        hr = SUPERCLASS::TranslateAcceleratorIO(lpMsg);

    return hr;
}

HRESULT CBrowserBandSite::_TrySetFocusTB(int iDir)
{
    HRESULT hres = S_FALSE;
    if (_hwndTB)
    {
        int cBtns = (int) SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (cBtns > 0)
        {
            // Set focus on tb.  This will also set the first button to hottracked,
            // generating a hot item change notify, but _OnHotItemChange will ignore
            // the notify as neither HICF_RESELECT, HICF_ARROWKEYS nor HICF_ACCELERATOR will be set.
            SetFocus(_hwndTB);

            // If going back, make rightmost button hottracked,
            // else make first button hottracked.
            int iHotPos = (iDir == -1) ? cBtns - 1 : 0;

            // Pass HICF_RESELECT so that if we're reselecting the same item, another notify
            // is generated, and so that the filter in _OnHotItemChange will let the notification
            // through (and pop down the chevron menu if necessary).
            SendMessage(_hwndTB, TB_SETHOTITEM2, iHotPos, HICF_RESELECT);

            hres = S_OK;
        }
    }
    return hres;
}

HRESULT CBrowserBandSite::_CycleFocusBS(LPMSG lpMsg)
{
    //
    // Tab order goes: (out)->_hwndOptionsTB->bands->(out)
    //
    // The order is reversed when shift is pressed.
    // 
    // When control is pressed, and we have focus (i.e., have already been tabbed
    // into), we reject focus since ctl-tab is supposed to tab between contexts.
    //
    // Once _hwndOptionsTB gets focus, user can arrow over to _hwndTB.  If
    // that happens, replace _hwndOptionsTB with _hwndTB in order above.
    //

    BOOL fHasFocus = (HasFocusIO() == S_OK);
    ASSERT(fHasFocus || !_ptbActive);

    if (fHasFocus && IsVK_CtlTABCycler(lpMsg))
    {
        // Bail on ctl-tab if one of our guys already has focus
        return S_FALSE;
    }

    HWND hwnd = GetFocus();
    BOOL fHasTBFocus = (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB));
    BOOL fShift = (GetKeyState(VK_SHIFT) < 0);
    HRESULT hres = S_FALSE;

    // hidden options toolbar, bandsite cannot set focus to it (e.g. iBar)
    BOOL fStdExplorerBar = IsWindowVisible(_hwndOptionsTB); 

    if (fHasTBFocus)
    {
        if (!fShift)
            hres = SUPERCLASS::_CycleFocusBS(lpMsg);
    }
    else
    {
        // Here, since !fHasTBFocus, fHasFocus => a band has focus

        if (fHasFocus || fShift || (!fHasFocus && !fStdExplorerBar))
            hres = SUPERCLASS::_CycleFocusBS(lpMsg);

        if (hres != S_OK && (!fHasFocus || (fHasFocus && fShift)))
        {
            // try passing focus to options toolbar if visible;
            if (fStdExplorerBar)
            {
                SetFocus(_hwndOptionsTB);
                TraceMsg(TF_ACCESSIBILITY, "CBrowserBandSite::_CycleFocusBS (hwnd=0x%08X) setting focus to optionsTB (=0x%08X)", _hwnd, _hwndOptionsTB);
                hres = S_OK;
            }
        }
    }

    return hres;
}

// this class subclasses the CBandSite class and adds functionality specific to
// being hosted in the browser....
//
// it implements close as hide 
// it has its own title drawing

void CBrowserBandSite::_OnCloseBand(DWORD dwBandID)
{
    int iIndex = _BandIDToIndex(dwBandID);
    LPBANDITEMDATA pbid = _GetBandItem(iIndex);
    if (pbid)
    {
        _ShowBand(pbid, FALSE);
        if (_pct) 
        {
            BOOL fShowing = FALSE;

            for (int i = _GetBandItemCount() - 1; i >= 0; i--)
            {
                LPBANDITEMDATA pbid = _GetBandItem(i);
                if (pbid)
                {
                    fShowing |= pbid->fShow;
                }
            }    
            if (!fShowing)
            {
                _pct->Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
            }
        }
    }
}

// don't allow d/d of any band in here
LRESULT CBrowserBandSite::_OnBeginDrag(NMREBAR* pnm)
{
    return 1;
}

CBrowserBandSite::CBrowserBandSite() : CBandSite(NULL)
{
    _dwBandIDCur = -1;
}

CBrowserBandSite::~CBrowserBandSite()
{
    ATOMICRELEASE(_pCmdTarget);
}


HFONT CBrowserBandSite::_GetTitleFont(BOOL fForceRefresh)
{
    if (_hfont && fForceRefresh)
        DeleteObject(_hfont);

    if (!_hfont || fForceRefresh) {
        // create our font to use for title & toolbar text
        // use A version for win9x compat
        NONCLIENTMETRICSA ncm;

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        if (!(_dwMode & DBIF_VIEWMODE_VERTICAL)) {
            // horizontal band w/ vertical caption, so rotate the font
            ncm.lfMenuFont.lfEscapement = 900;  // rotate by 90 degrees
            ncm.lfMenuFont.lfOutPrecision = OUT_TT_ONLY_PRECIS; // TT can be rotated
        }

        _hfont = CreateFontIndirectA(&ncm.lfMenuFont);
    }

    return _hfont;
}

void CBrowserBandSite::_InitLayout()
{
    // force update font
    _GetTitleFont(TRUE);
 
    // update toolbar font
    _UpdateToolbarFont();

    // recalc title and toolbar heights
    _CalcHeights();

    _UpdateLayout();
}

void CBrowserBandSite::_UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize)
{
    if (!fBSOnly && !fNoAutoSize)
        _InitLayout();

    SUPERCLASS::_UpdateAllBands(fBSOnly, fNoAutoSize);
}

HRESULT CBrowserBandSite::_Initialize(HWND hwndParent)
{
    HRESULT hres = SUPERCLASS::_Initialize(hwndParent);
    SendMessage(_hwnd, CCM_SETUNICODEFORMAT, DLL_IS_UNICODE, 0);

    _CreateOptionsTB();
    _InitLayout();

    return hres;
}

void CBrowserBandSite::_CalcHeights()
{
    // calc title height
    // calc height of captionless bandsites, too, needed to calc toolband height
    // HACKHACK: use height of 'All Folders' as standard title height
    TCHAR szTitle[64];

    if (MLLoadStringW(IDS_TREETITLE, szTitle, ARRAYSIZE(szTitle))) {
        HDC hdc = GetDC(_hwnd);

        if (hdc)
        {
            HFONT hfont = _GetTitleFont(FALSE);
            HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);

            int iLen = lstrlen(szTitle);

            SIZE size;
            GetTextExtentPoint32(hdc, szTitle, iLen, &size);
            _uTitle = size.cy;

            // make space for etch line + space
            _uTitle += CY_ETCH + CY_FLUFF;

            SelectObject(hdc, hfontOld);

            ReleaseDC(_hwnd, hdc);
        }
    } else {
        // no string; use a default height
        _uTitle = BROWSERBAR_TITLEHEIGHT;
    }

    // calc toolbar height
    _uToolbar = _uTitle + (2 * CY_TBPADDING) + CY_ETCH;

    if (_dwStyle & BSIS_NOCAPTION)
    {
        // rebar has no caption
        _uTitle = 0;
    }
}

void CBrowserBandSite::_UpdateToolbarFont()
{
    if (_hwndTB && (_dwMode & DBIF_VIEWMODE_VERTICAL)) {
        // use same font for title and toolbar
        HFONT hfont = _GetTitleFont(FALSE);
        if (hfont)
            SendMessage(_hwndTB, WM_SETFONT, (WPARAM)hfont, TRUE);
    }
}

void CBrowserBandSite::_ShowBand(LPBANDITEMDATA pbid, BOOL fShow)
{
    if (fShow && (_dwBandIDCur != pbid->dwBandID)) {
        _dwBandIDCur = pbid->dwBandID;
        _UpdateLayout();
    } else if (!fShow && _dwBandIDCur == pbid->dwBandID) {
        _dwBandIDCur = -1;
    }

    SUPERCLASS::_ShowBand(pbid, fShow);
}

void CBrowserBandSite::_UpdateLayout()
{
    // update toolbar button size
    if (_hwndTB && SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0) > 0)
    {
        // try to set button height to title height
        LONG lSize = MAKELONG(0, _uTitle);
        SendMessage(_hwndTB, TB_SETBUTTONSIZE, 0, lSize);

        // see what toolbar actually gave us
        RECT rc;
        SendMessage(_hwndTB, TB_GETITEMRECT, 0, (LPARAM)&rc);

        // calc toolbar height (final version)
        _uToolbar = RECTHEIGHT(rc) + CY_ETCH + 2 * CY_TBPADDING;
    }

    // update header height for the current band
    if (_dwBandIDCur != -1)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(rbbi);
        rbbi.fMask = RBBIM_HEADERSIZE;
        rbbi.cxHeader = _uTitle + (_fToolbar ? _uToolbar : 0);
        SendMessage(_hwnd, RB_SETBANDINFO, _BandIDToIndex(_dwBandIDCur), (LPARAM)&rbbi);
    }

    // update toolbar size
    _UpdateToolbarBand();

    // reposition toolbars
    _PositionToolbars(NULL);
}

void CBrowserBandSite::_BandInfoFromBandItem(REBARBANDINFO *prbbi, LPBANDITEMDATA pbid, BOOL fBSOnly)
{
    SUPERCLASS::_BandInfoFromBandItem(prbbi, pbid, fBSOnly);
    if (prbbi) 
    {
        // we override header width so we can fit browbs's fancy ui (title,
        // toolbar, close & autohide buttons) in the band's header area.
        prbbi->cxHeader = _uTitle + (_fToolbar ? _uToolbar : 0);
    }
}

void CBrowserBandSite::_DrawEtchline(HDC hdc, LPRECT prc, int iOffset, BOOL fVertEtch)
{
    RECT rc;
    CopyRect(&rc, prc);

    if (fVertEtch) {
        rc.left += iOffset - CY_ETCH;
        rc.right = rc.left + 1;
    } else {
        rc.top += iOffset - CY_ETCH;
        rc.bottom = rc.top + 1;
    }
    SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));

    if (fVertEtch) {
        rc.left++;
        rc.right++;
    } else {
        rc.bottom++;
        rc.top++;
    }
    SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNHILIGHT));
}

LRESULT CBrowserBandSite::_OnCDNotify(LPNMCUSTOMDRAW pnm)
{
    switch (pnm->dwDrawStage) {
    case CDDS_PREPAINT:
        return CDRF_NOTIFYITEMDRAW;

    case CDDS_PREERASE:
        return CDRF_NOTIFYITEMDRAW;

    case CDDS_ITEMPREPAINT:
        if (!(_dwStyle & BSIS_NOCAPTION))
        {
            // horz bar has vert caption and vice versa
            BOOL fVertCaption = (_dwMode&DBIF_VIEWMODE_VERTICAL) ? FALSE:TRUE;
        
            LPBANDITEMDATA pbid = (LPBANDITEMDATA)pnm->lItemlParam;
            if (pbid) 
            {
                int iLen;
                HFONT hfont, hfontOld = NULL;
                LPCTSTR pszTitle;
                SIZE size;
                USES_CONVERSION;

                hfont = _GetTitleFont(FALSE);
                hfontOld = (HFONT)SelectObject(pnm->hdc, hfont);
                pszTitle = W2CT(pbid->szTitle);
                iLen = lstrlen(pszTitle);
                GetTextExtentPoint32(pnm->hdc, pszTitle, iLen, &size);

                // center text inside caption and draw edge at bottom/right.
                if (!fVertCaption) 
                {
                    // vertical bar, has horizontal text
                    int x = pnm->rc.left + CX_TEXTOFFSET;
                    int y = pnm->rc.top + ((_uTitle - CY_ETCH) - size.cy) / 2;
                    ExtTextOut(pnm->hdc, x, y, NULL, NULL, pszTitle, iLen, NULL);

                    _DrawEtchline(pnm->hdc, &pnm->rc, RECTHEIGHT(pnm->rc), fVertCaption);
                    if (_fToolbar)
                        _DrawEtchline(pnm->hdc, &pnm->rc, _uTitle, fVertCaption);
                }
                else 
                {
                    // horizontal bar, has vertical text
                    UINT nPrevAlign = SetTextAlign(pnm->hdc, TA_BOTTOM);
                    int x = pnm->rc.right - ((_uTitle - CY_ETCH) - size.cy) / 2;
                    int y = pnm->rc.bottom - CY_TEXTOFFSET;
                    ExtTextOut(pnm->hdc, x, y, NULL, NULL, pszTitle, iLen, NULL);
                    SetTextAlign(pnm->hdc, nPrevAlign);

                    _DrawEtchline(pnm->hdc, &pnm->rc, RECTWIDTH(pnm->rc), fVertCaption);
                    ASSERT(!_fToolbar);
                }

                if (hfontOld)
                    SelectObject(pnm->hdc, hfontOld);
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}

LRESULT CBrowserBandSite::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->idFrom) 
    {
    case FCIDM_REBAR:
        switch (pnm->code) 
        {
        case NM_CUSTOMDRAW:
            return _OnCDNotify((LPNMCUSTOMDRAW)pnm);

        case NM_NCHITTEST:
            {
                NMMOUSE *pnmMouse = (NMMOUSE*)pnm;
                RECT rc;
                GetClientRect(_hwnd, &rc);
                if (pnmMouse->dwItemSpec == (DWORD)-1) {
Lchktrans:      
                    //
                    // Edges are mirrored if the window is mirrored. [samera]
                    //
                    if (IS_WINDOW_RTL_MIRRORED(_hwnd)) {
                        int iTmp = rc.right;
                        rc.right = rc.left;
                        rc.left  = iTmp;
                    }

                    // gotta check all 4 edges or non-left-side bars (e.g.
                    // commbar) won't work.
                    // (we separate this into 2 checks to give a trace,
                    // since the old code only checked the right side)
                    if (pnmMouse->pt.x > rc.right)  {
                        return HTTRANSPARENT;
                    }
                    if (pnmMouse->pt.x < rc.left ||
                        pnmMouse->pt.y > rc.bottom || pnmMouse->pt.y < rc.top) {
                        return HTTRANSPARENT;
                    }
                } else if (pnmMouse->dwHitInfo == RBHT_CLIENT) {
                    InflateRect(&rc, -(GetSystemMetrics(SM_CXFRAME)),
                        -(GetSystemMetrics(SM_CYFRAME)));
                    goto Lchktrans;
                }

                return SUPERCLASS::_OnNotify(pnm);
            }

        default:
            return SUPERCLASS::_OnNotify(pnm);
        }

    default:
        return SUPERCLASS::_OnNotify(pnm);
    }

    return 0;
}


IDropTarget* CBrowserBandSite::_WrapDropTargetForBand(IDropTarget* pdtBand)
{
    pdtBand->AddRef();
    return pdtBand;
}


HRESULT CBrowserBandSite::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBrowserBandSite, IExplorerToolbar),
        { 0 },
    };
    HRESULT hr;
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if (FAILED(hr))
            hr = SUPERCLASS::v_InternalQueryInterface(riid, ppv);
    }
    return hr;
}


DWORD CBrowserBandSite::_GetWindowStyle(DWORD *pdwExStyle)
{
    *pdwExStyle = 0;
    return RBS_REGISTERDROP |
            RBS_VERTICALGRIPPER | 
            RBS_VARHEIGHT | RBS_DBLCLKTOGGLE |
            WS_VISIBLE |  WS_CHILD | WS_CLIPCHILDREN | WS_BORDER |
            WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN;
}

// *** IOleCommandTarget ***

HRESULT CBrowserBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
#ifdef UNIX
    // IEUNIX: Special case to handle the case where the band wants to
    // close itself. Used in Cache Warning pane (msgband.cpp)
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case SBCMDID_MSGBAND: 
            {
                IDockingWindow * pdw;
                if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IDockingWindow, &pdw)))) 
                {
                    pdw->ShowDW((BOOL)nCmdexecopt);
                    pdw->Release();
                }
            }
        }
    }
#endif
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case THID_ACTIVATE:
            _fTheater = TRUE;
            SHSetWindowBits(_hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, 0);
            // fall through
        case THID_SETBROWSERBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _fNoAutoHide = !(pvarargIn->lVal);
            SendMessage(_hwndOptionsTB, TB_CHANGEBITMAP, IDM_AB_AUTOHIDE, _fNoAutoHide ? 2 : 0);
            break;

        case THID_DEACTIVATE:
            _fTheater = FALSE;
            SHSetWindowBits(_hwnd, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);
            break;
        }
        SetWindowPos(_hwnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
        _SizeOptionsTB();

        return S_OK;
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

#define BBSC_REBAR      0x00000001
#define BBSC_TOOLBAR    0x00000002

void CBrowserBandSite::_CreateTBRebar()
{
    ASSERT(!_hwndTBRebar);

    _hwndTBRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                           0, 0, 100, 36,
                           _hwnd, (HMENU) BBSC_REBAR, HINST_THISDLL, NULL);

    if (_hwndTBRebar)
        SendMessage(_hwndTBRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);
}

void CBrowserBandSite::_InsertToolbarBand()
{
    if (_hwndTBRebar && _hwndTB)
    {
        // Assert that we haven't added the toolbar band yet
        ASSERT(SendMessage(_hwndTBRebar, RB_GETBANDCOUNT, 0, 0) == 0);

        // Assert that we've calculated toolbar height
        ASSERT(_uToolbar);

        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE;

        // RBBIM_CHILD
        rbbi.hwndChild = _hwndTB;

        // RBBIM_CHILDSIZE
        rbbi.cxMinChild = 0;
        rbbi.cyMinChild = _uToolbar - (CY_ETCH + 2 * CY_TBPADDING);

        // RBBIM_STYLE
        rbbi.fStyle = RBBS_NOGRIPPER | RBBS_USECHEVRON;

        SendMessage(_hwndTBRebar, RB_INSERTBAND, -1, (LPARAM)&rbbi);
    }
}

void CBrowserBandSite::_UpdateToolbarBand()
{
    if (_hwndTBRebar && _hwndTB)
    {
        // Assert that we've added the toolbar band
        ASSERT(SendMessage(_hwndTBRebar, RB_GETBANDCOUNT, 0, 0) == 1);

        // Assert that we've calculated toolbar height
        ASSERT(_uToolbar);

        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILDSIZE;

        SIZE size = {0, _uToolbar};
        if (SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size))
        {
            // RBBIM_IDEALSIZE
            rbbi.fMask |= RBBIM_IDEALSIZE;
            rbbi.cxIdeal = size.cx;
        }

        // RBBIM_CHILDSIZE
        rbbi.cxMinChild = 0;
        rbbi.cyMinChild = _uToolbar - (CY_ETCH + 2 * CY_TBPADDING);

        SendMessage(_hwndTBRebar, RB_SETBANDINFO, 0, (LPARAM)&rbbi);
    }
}

void CBrowserBandSite::_CreateTB()
{
    ASSERT(!_hwndTB);

    // Create a rebar too so we get the chevron
    _CreateTBRebar();

    if (_hwndTBRebar)
    {
        _hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS |
                        TBSTYLE_FLAT | TBSTYLE_LIST | CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                        0, 0, 0, 0,
                        _hwndTBRebar, (HMENU) BBSC_TOOLBAR, HINST_THISDLL, NULL);
    }

    if (_hwndTB)
    {
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(_hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // FEATURE: use TBSTYLE_EX_HIDECLIPPEDBUTTONS here?  looks kinda goofy so i'm leaving it out for now.
        SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_MIXEDBUTTONS);

        SendMessage(_hwndTB, TB_SETMAXTEXTROWS, 1, 0L);

        _UpdateToolbarFont();

        _InsertToolbarBand();
    }
}

void CBrowserBandSite::_RemoveAllButtons()
{
    if (!_hwndTB || !_hwndTBRebar)
        return;

    ShowWindow(_hwndTBRebar, SW_HIDE);
    _fToolbar = FALSE;

    INT_PTR nCount = SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0L);
    while (nCount-- > 0)
        SendMessage(_hwndTB, TB_DELETEBUTTON, nCount, 0L);

    _UpdateLayout();
}

void CBrowserBandSite::_Close()
{
    ATOMICRELEASE(_pCmdTarget);

    //
    // Destroying _hwndTBRebar will take care of _hwndTB too
    //
    ASSERT(!_hwndTB || IsChild(_hwndTBRebar, _hwndTB));

    DESTROY_OBJ_WITH_HANDLE(_hwndTBRebar, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hwndOptionsTB, DestroyWindow);

    DESTROY_OBJ_WITH_HANDLE(_hfont, DeleteObject);

    SUPERCLASS::_Close();
}

LRESULT CBrowserBandSite::_OnHotItemChange(LPNMTBHOTITEM pnmtb)
{
    LRESULT lres = 0;

    // We might want to drop down the chevron menu if the hot item change
    // flags has these characteristics:
    //
    //  - not HICF_LEAVING, since if HICF_LEAVING, the hot item should instead wrap to _hwndClose
    //  - and not HICF_MOUSE, since we only drop down on keyboard hot item change
    //  - HICF_ACCELERATOR | HICF_ARROWKEYS, since we only drop down on keyboard hot item change
    //  - or HICF_RESELECT, since we force a reselect in _TrySetFocusTB
    //
    if (!(pnmtb->dwFlags & (HICF_LEAVING | HICF_MOUSE)) &&
        (pnmtb->dwFlags & (HICF_RESELECT | HICF_ACCELERATOR | HICF_ARROWKEYS)))
    {
        // Check to see if new hot button is clipped.  If it is,
        // then we pop down the chevron menu.
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        int iButton = (int)SendMessage(_hwndTB, TB_COMMANDTOINDEX, pnmtb->idNew, 0);

        if (SHIsButtonObscured(_hwndTB, &rc, iButton))
        {
            // Clear hot item
            SendMessage(_hwndTB, TB_SETHOTITEM, -1, 0);

            // Figure out whether to highlight first or last item in menu
            UINT uSelect;
            int cButtons = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
            if (iButton == cButtons - 1)
                uSelect = DBPC_SELECTLAST;
            else
                uSelect = DBPC_SELECTFIRST;

            // Pop it down
            SendMessage(_hwndTBRebar, RB_PUSHCHEVRON, 0, uSelect);

            lres = 1;
        }
    }

    return lres;
}

LRESULT CBrowserBandSite::_OnNotifyBBS(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        if (EVAL(_pCmdTarget))
        {
            LPNMTOOLBAR pnmtoolbar = (LPNMTOOLBAR)pnm;
            VARIANTARG  var;
            RECT rc = pnmtoolbar->rcButton;
            
            var.vt = VT_I4;
            MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
            var.lVal = MAKELONG(rc.left, rc.bottom);
            
            _pCmdTarget->Exec(&_guidButtonGroup, pnmtoolbar->iItem, OLECMDEXECOPT_PROMPTUSER, &var, NULL);
        }
        break;

    case TBN_WRAPHOTITEM:
        {
            LPNMTBWRAPHOTITEM pnmwh = (LPNMTBWRAPHOTITEM) pnm;

            if (pnmwh->nReason & HICF_ARROWKEYS) {
                if (pnm->hwndFrom == _hwndOptionsTB) {
                    if (_TrySetFocusTB(pnmwh->iDir) != S_OK)
                        return 0;
                } else {
                    ASSERT(pnm->hwndFrom == _hwndTB);
                    SetFocus(_hwndOptionsTB);
                }
                return 1;
            }
        }
        break;

    case TBN_HOTITEMCHANGE:
        if (pnm->hwndFrom == _hwndTB)
            return _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;

    case TBN_GETINFOTIP:
        //  [scotthan] We'll ask the toolbar owner for tip text via
        //  IOleCommandTarget::QueryStatus, like we do w/ defview for itbar buttons
        if (_pCmdTarget && pnm->hwndFrom == _hwndTB)
        {
            NMTBGETINFOTIP* pgit = (NMTBGETINFOTIP*)pnm ;

            OLECMDTEXTV<MAX_TOOLTIP_STRING> cmdtv;
            OLECMDTEXT *pcmdText = &cmdtv;
 
            pcmdText->cwBuf    = MAX_TOOLTIP_STRING;
            pcmdText->cmdtextf = OLECMDTEXTF_NAME;
            pcmdText->cwActual = 0;
 
            OLECMD rgcmd = {pgit->iItem, 0};
 
            HRESULT hr = _pCmdTarget->QueryStatus(&_guidButtonGroup, 1, &rgcmd, pcmdText);
            if (SUCCEEDED(hr) && (pcmdText->cwActual))
            {
                SHUnicodeToTChar(pcmdText->rgwz, pgit->pszText, pgit->cchTextMax);
                return 1;
            }
        }
        break ;

    case RBN_CHEVRONPUSHED:
        LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnm;

        MapWindowPoints(pnmch->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
        ToolbarMenu_Popup(_hwnd, &pnmch->rc, NULL, _hwndTB, 0, (DWORD)pnmch->lParamNM);

        return 1;
    }

    return 0;
}

// *** IWinEventHandler ***
HRESULT CBrowserBandSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg)
    {
    case WM_COMMAND:
        {
            HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

            if (hwndControl && hwndControl == _hwndTB)
            {
                if (EVAL(_pCmdTarget))
                {
                    RECT rc;
                    VARIANTARG var;

                    var.vt = VT_I4;
                    SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                    MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
                    var.lVal = MAKELONG(rc.left, rc.bottom);

                    _pCmdTarget->Exec(&_guidButtonGroup, idCmd, 0, &var, NULL);
                }
                return S_OK;
            }
            else if (hwndControl == _hwndOptionsTB) {
                switch (idCmd) {
                case IDM_AB_CLOSE:
                    IUnknown_Exec(_punkSite, &CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
                    break;

                case IDM_AB_AUTOHIDE:
                    { 
                        VARIANTARG v = {0};
                        v.vt = VT_I4;
                        v.lVal = _fNoAutoHide;
                        IUnknown_Exec(_punkSite, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, &v, NULL);

                        break;
                    }
                }
                return S_OK;
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm && (pnm->hwndFrom == _hwndTB || pnm->hwndFrom == _hwndOptionsTB || pnm->hwndFrom == _hwndTBRebar)) {
                *plres = _OnNotifyBBS(pnm);
                return S_OK;
            }
        }
        break;

    case WM_SIZE:
        {
            POINT pt = {LOWORD(lParam), HIWORD(lParam)};
            _PositionToolbars(&pt);
        }
        break;
    }

    return SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}

HRESULT CBrowserBandSite::IsWindowOwner(HWND hwnd)
{
    if (hwnd && (hwnd == _hwndTB) || (hwnd == _hwndOptionsTB) || (hwnd == _hwndTBRebar))
        return S_OK;

    return SUPERCLASS::IsWindowOwner(hwnd);
}

// *** IBandSite ***
HRESULT CBrowserBandSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    // recompute our layout if vertical viewmode is changing
    BOOL fUpdate = ((pbsinfo->dwMask & BSIM_STATE) && 
                    ((pbsinfo->dwState ^ _dwMode) & DBIF_VIEWMODE_VERTICAL));
    // ...or if caption is turned on or off
    BOOL fCaptionStyleChanged = (   (pbsinfo->dwMask & BSIM_STYLE)
                                 && ((pbsinfo->dwStyle ^ _dwStyle) & BSIS_NOCAPTION));

    HRESULT hres = SUPERCLASS::SetBandSiteInfo(pbsinfo);

    if (fCaptionStyleChanged && _hwndOptionsTB)
    {
        if (_fToolbar) {
            // don't know if "new" band requires buttons or not, expect band to add buttons again if needed
            _RemoveAllButtons();
        }
        // show or hide close/hide toolbar; is always created since bandsites get reused!
        ::ShowWindow(_hwndOptionsTB, (_dwStyle & BSIS_NOCAPTION) ? SW_HIDE : SW_SHOW);
    }

    if (fUpdate || fCaptionStyleChanged) {
        _InitLayout();
    }

    return hres;
}


// *** IExplorerToolbar ***
HRESULT CBrowserBandSite::SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags)
{
    HRESULT hres = S_OK;
    BOOL fRemoveButtons = TRUE;

    // dwFlags is not used
    ASSERT(!(dwFlags));

    ATOMICRELEASE(_pCmdTarget);
    if (punkCmdTarget && pguidButtonGroup)
    {
        hres = punkCmdTarget->QueryInterface(IID_IOleCommandTarget, (void**)&(_pCmdTarget));

        if (!_hwndTB)
        {
            _CreateTB();
        }
        else if (_fToolbar && IsEqualGUID(_guidButtonGroup, *pguidButtonGroup))
        {
            fRemoveButtons = FALSE;
            hres = S_FALSE;
        }

        _guidButtonGroup = *pguidButtonGroup;
    }
    else
        ASSERT(!punkCmdTarget);

    if (fRemoveButtons)
        _RemoveAllButtons();

    ASSERT(SUCCEEDED(hres));
    return hres;
}

// client should have already called AddString
HRESULT CBrowserBandSite::AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON* lpButtons)
{
    if (!_hwndTB || !nButtons)
        return E_FAIL;

    _RemoveAllButtons();

    if (SendMessage(_hwndTB, TB_ADDBUTTONS, nButtons, (LPARAM)lpButtons))
    {
        ShowWindow(_hwndTBRebar, SW_SHOW);
        _fToolbar = TRUE;

        _UpdateLayout();

        return S_OK;
    }

    return E_FAIL;
}

HRESULT CBrowserBandSite::AddString(const GUID* pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LRESULT* pOffset)
{
    *pOffset = -1;
    if (!_hwndTB)
        return E_FAIL;

    *pOffset = SendMessage(_hwndTB, TB_ADDSTRING, (WPARAM)hInst, (LPARAM)uiResID);

    if (*pOffset != -1)
        return S_OK;

    return E_FAIL;
}

HRESULT CBrowserBandSite::GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    if (!_hwndTB)
        return E_FAIL;

    UINT_PTR uiIndex = SendMessage(_hwndTB, TB_COMMANDTOINDEX, uiCommand, 0L);
    if (SendMessage(_hwndTB, TB_GETBUTTON, uiIndex, (LPARAM)lpButton))
        return S_OK;

    return E_FAIL;
}

HRESULT CBrowserBandSite::GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT* pfState)
{
    if (!_hwndTB)
        return E_FAIL;

    *pfState = (UINT)SendMessage(_hwndTB, TB_GETSTATE, uiCommand, 0L);
    return S_OK;
}

HRESULT CBrowserBandSite::SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState)
{
    if (!_hwndTB)
        return E_FAIL;

    UINT_PTR uiState = SendMessage(_hwndTB, TB_GETSTATE, uiCommand, NULL);
    uiState ^= fState;
    if (uiState)
        SendMessage(_hwndTB, TB_SETSTATE, uiCommand, (LPARAM)fState);

    return S_OK;
}

HRESULT CBrowserBandSite::SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled)
{
    if (IsEqualGUID(*pguidCmdGroup, _guidButtonGroup)) {
        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himlNormal);
        SendMessage(_hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);
        SendMessage(_hwndTB, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)himlDisabled);
    }
    return S_OK;
};

BYTE TBStateFromIndex(HWND hwnd, int iIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(TBBUTTONINFO);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_STATE;
    tbbi.fsState = 0;
    SendMessage(hwnd, TB_GETBUTTONINFO, iIndex, (LPARAM)&tbbi);

    return tbbi.fsState;
}

int CBrowserBandSite::_ContextMenuHittest(LPARAM lParam, POINT* ppt)
{
    if (lParam == (LPARAM)-1)
    {
        //
        // Keyboard activation.  If one of our toolbars has
        // focus, and it has a hottracked button, put up the
        // context menu below that button.
        //
        HWND hwnd = GetFocus();
        if (hwnd && (hwnd == _hwndTB || hwnd == _hwndOptionsTB))
        {
            INT_PTR iHot = SendMessage(hwnd, TB_GETHOTITEM, 0, 0);
            if (iHot == -1)
            {
                // couldn't find a hot item, just use the first visible button
                iHot = 0;
                while (TBSTATE_HIDDEN & TBStateFromIndex(hwnd, (int)iHot))
                    iHot++;

                ASSERT(iHot < SendMessage(hwnd, TB_BUTTONCOUNT, 0, 0));
            }

            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, iHot, (LPARAM)&rc);

            ppt->x = rc.left;
            ppt->y = rc.bottom;

            MapWindowPoints(hwnd, HWND_DESKTOP, ppt, 1);

            return -1;
        }
    }

    return SUPERCLASS::_ContextMenuHittest(lParam, ppt);
}

HMENU CBrowserBandSite::_LoadContextMenu()
{
    HMENU hmenu = SUPERCLASS::_LoadContextMenu();
    DeleteMenu(hmenu, BSIDM_SHOWTITLEBAND, MF_BYCOMMAND);
    return hmenu;
}

// create the options (close/hide) buttons
void CBrowserBandSite::_CreateOptionsTB()
{
    // create toolbar for close/hide button always since band site is reused
    // for captionless band sites (iBar), this toolbar is only hidden
    _hwndOptionsTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | 
                                WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 30, 18, _hwnd, 0, HINST_THISDLL, NULL);

    _PrepareOptionsTB();
}

// init as toolbar and load bitmaps
void CBrowserBandSite::_PrepareOptionsTB()
{
    if (_hwndOptionsTB)
    {
        static const TBBUTTON c_tb[] =
        {
            { 0, IDM_AB_AUTOHIDE, TBSTATE_ENABLED, TBSTYLE_CHECK, {0,0}, 0, 0 },
            { 1, IDM_AB_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 1 }
        };

        SendMessage(_hwndOptionsTB, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);
        SendMessage(_hwndOptionsTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        SendMessage(_hwndOptionsTB, TB_SETBITMAPSIZE, 0, (LPARAM) MAKELONG(13, 11));
        TBADDBITMAP tbab = { HINST_THISDLL, IDB_BROWSERTOOLBAR };
        SendMessage(_hwndOptionsTB, TB_ADDBITMAP, 3, (LPARAM)&tbab);

        LONG_PTR cbOffset = SendMessage(_hwndOptionsTB, TB_ADDSTRING, (WPARAM)MLGetHinst(), (LPARAM)IDS_BANDSITE_CLOSE_LABELS);
        TBBUTTON tb[ARRAYSIZE(c_tb)];
        UpdateButtonArray(tb, c_tb, ARRAYSIZE(c_tb), cbOffset);

        SendMessage(_hwndOptionsTB, TB_SETMAXTEXTROWS, 0, 0);

        SendMessage(_hwndOptionsTB, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);

        SendMessage(_hwndOptionsTB, TB_SETINDENT, (WPARAM)0, 0);
        
        _SizeOptionsTB();
    }    
}

void CBrowserBandSite::_PositionToolbars(LPPOINT ppt)
{
    RECT rc;

    if (ppt) 
    {
        rc.left = 0;
        rc.right = ppt->x;
    } 
    else 
    {
        GetClientRect(_hwnd, &rc);
    }

    if (_hwndOptionsTB) 
    {
        // always put the close restore at the top right of the floater window
        int x;

        if (_dwMode & DBIF_VIEWMODE_VERTICAL) 
        {
            RECT rcTB;
            GetWindowRect(_hwndOptionsTB, &rcTB);
            x = rc.right - RECTWIDTH(rcTB) - 1;
        }
        else
        {
            x = rc.left;
        }

        MARGINS mBorders = {0, 1, 0, 0};        // 1 mimics old behavior downlevel.
        Comctl32_GetBandMargins(_hwnd, &mBorders);

        SetWindowPos(_hwndOptionsTB, HWND_TOP, x - mBorders.cxRightWidth, mBorders.cyTopHeight, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }

    if (_hwndTBRebar)
    {
        if (_fToolbar) 
        {
            // toolbar goes on its own line below title
            SetWindowPos(_hwndTBRebar, HWND_TOP, 
                            rc.left + CX_TBOFFSET,
                            _uTitle + CX_TBOFFSET,
                            rc.right - 2 * CX_TBOFFSET,
                            _uToolbar,
                            SWP_SHOWWINDOW);

        } 
        else 
        {
            ASSERT(!IsWindowVisible(_hwndTBRebar));
        }
    }
}

// sets the size of the toolbar.  if we're in theater mode, we need to show the pushpin.
// otherwise just show the close
void CBrowserBandSite::_SizeOptionsTB()
{
    RECT rc;
    GetWindowRect(_hwndOptionsTB, &rc);
    LRESULT lButtonSize = SendMessage(_hwndOptionsTB, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(_hwndOptionsTB, NULL, 0, 0, LOWORD(lButtonSize) * (_fTheater ? 2 : 1),
                 RECTHEIGHT(rc), SWP_NOMOVE | SWP_NOACTIVATE);

    DWORD_PTR dwState = SendMessage(_hwndOptionsTB, TB_GETSTATE, IDM_AB_AUTOHIDE, 0);
    dwState &= ~(TBSTATE_HIDDEN | TBSTATE_CHECKED);
    if (!_fTheater)
        dwState |= TBSTATE_HIDDEN;
    if (_fNoAutoHide)
        dwState |= TBSTATE_CHECKED;
    SendMessage(_hwndOptionsTB, TB_SETSTATE, IDM_AB_AUTOHIDE, dwState);
    _PositionToolbars(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browmenu.h ===
#ifndef _BROWMENU_H_
#define _BROWMENU_H_

#include "cowsite.h"

// IShellMenuCallback implementation
class CFavoritesCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** CObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk);

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CFavoritesCallback();
private:
    virtual ~CFavoritesCallback();
    int     _cRef;
    BOOL    _fOffline;
    BOOL    _fRefresh;
    BOOL    _fExpandoMenus;
    BOOL    _fShowingTip;

    HRESULT _GetHmenuInfo(HMENU hMenu, UINT uId, SMINFO* psminfo);
    HRESULT _SelectItem(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl);
    HRESULT _Init(HMENU hMenu, UINT uIdParent, IUnknown* punk);
    HRESULT _Exit();
    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _GetDefaultIcon(TCHAR* psz, int* piIndex);
    HRESULT _GetSFInfo(SMDATA* psmd, SMINFO* psminfo);
    HRESULT _Demote(LPSMDATA psmd);
    HRESULT _Promote(LPSMDATA psmd);
    HRESULT _HandleNew(LPSMDATA psmd);
    DWORD   _GetDemote(SMDATA* psmd);
    HRESULT _GetTip(LPTSTR pstrTitle, LPTSTR pstrTip);
    HRESULT _ProcessChangeNotify(SMDATA* psmd, LONG lEvent, 
                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    BOOL _AllowDrop(IDataObject* pIDataObject, HWND hwnd);

    IShellMenu* _psmFavCache;

    void _RefreshItem(HMENU hmenu, int idCmd, IShellMenu* psm);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browbar.h ===
// coming soon: new deskbar (old deskbar moved to browbar base class)
#ifndef BROWBAR_H_
#define BROWBAR_H_

#include "dockbar.h"

class CBrowserBar : public CDockingBar
{
public:
    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

        // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
protected:
    virtual BOOL _CheckForwardWinEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual void _HandleWindowPosChanging(LPWINDOWPOS pwp) ;
    virtual void _GetChildPos(LPRECT prc);
    virtual void _GetStyleForMode(UINT eMode, LONG* plStyle, LONG *plExStyle, HWND* phwndParent);
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _StopCurrentBand();

    CLSID _clsidCurrentBand;
    int   _idBar;                //vertical or horizontal bar

public:
    void SetIdBar(int idBar) { _idBar = idBar; };
    UINT _PersistState(HWND hwnd, BOOL bSetNewRect);
};

class CBrowserBarPropertyBag : public CDockingBarPropertyBag
{
};

HRESULT BrowserBar_Init(CBrowserBar* pdb, IUnknown** ppbs, int idBar);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browbs.h ===
#ifndef _browbs_h
#define _browbs_h

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

class CBrowserBandSite :
    public CBandSite,
    public IExplorerToolbar
{
public:
    CBrowserBandSite();
    virtual ~CBrowserBandSite();

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return CBandSite::QueryInterface(riid, ppvObj);};
    STDMETHODIMP_(ULONG) AddRef(void) { return CBandSite::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CBandSite::Release();};

    // *** IOleCommandTarget ***
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IWinEventHandler ***
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IInputObject methods ***
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    STDMETHODIMP HasFocusIO();

    // *** IBandSite methods ***
    STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);

    // *** IDeskBarClient methods ***
    STDMETHODIMP SetModeDBC(DWORD dwMode);

    // *** IExplorerToolbar ***
    STDMETHODIMP SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags);
    STDMETHODIMP AddStdBrowserButtons(void) { return E_NOTIMPL; };
    STDMETHODIMP AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON* lpButtons);
    STDMETHODIMP AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset);
    STDMETHODIMP GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);
    STDMETHODIMP GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT* pfState);
    STDMETHODIMP SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState);
    STDMETHODIMP AddBitmap(const GUID* pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP* ptb,
                                    LRESULT* pOffset, COLORREF rgbMask) { return E_NOTIMPL; };
    STDMETHODIMP GetBitmapSize(UINT* uiID) { return E_NOTIMPL; };
    STDMETHODIMP SendToolbarMsg(const GUID* pguidButtonGroup, UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, LRESULT *plRes) { return E_NOTIMPL; };
    STDMETHODIMP SetImageList(const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled);
    STDMETHODIMP ModifyButton( const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) { return E_NOTIMPL; };
   
protected:

    virtual void _OnCloseBand(DWORD dwBandID);
    virtual LRESULT _OnBeginDrag(NMREBAR* pnm);            
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _Initialize(HWND hwndParent);
    virtual IDropTarget* _WrapDropTargetForBand(IDropTarget* pdtBand);
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    virtual DWORD _GetWindowStyle(DWORD* pdwExStyle);
    virtual HMENU _LoadContextMenu();
    LRESULT _OnCDNotify(LPNMCUSTOMDRAW pnm);
    virtual void _Close();
    HRESULT _TrySetFocusTB(int iDir);
    virtual HRESULT _CycleFocusBS(LPMSG lpMsg);
    LRESULT _OnHotItemChange(LPNMTBHOTITEM pnmtb);
    LRESULT _OnNotifyBBS(LPNMHDR pnm);
    virtual void _BandInfoFromBandItem(REBARBANDINFO *prbbi, LPBANDITEMDATA pbid, BOOL fBSOnly);
    virtual void _ShowBand(LPBANDITEMDATA pbid, BOOL fShow);
    virtual void _UpdateAllBands(BOOL fBSOnly, BOOL fNoAutoSize);

    virtual int _ContextMenuHittest(LPARAM lParam, POINT* ppt);

    HFONT   _GetTitleFont(BOOL fForceRefresh);
    virtual void  _CalcHeights();
    void    _InitLayout();
    void    _UpdateLayout();
    void    _UpdateToolbarFont();

    void _CreateTBRebar();
    void _InsertToolbarBand();
    void _UpdateToolbarBand();
    void _CreateTB();
    void _RemoveAllButtons();

    void _UpdateHeaderHeight(int iBand);

    virtual void _PositionToolbars(LPPOINT ppt);
    void _CreateOptionsTB();
    virtual void _PrepareOptionsTB();
    virtual void _SizeOptionsTB();

    void _DrawEtchline(HDC hdc, LPRECT prc, int iOffset, BOOL fVertical);

    BITBOOL _fTheater:1;
    BITBOOL _fNoAutoHide:1;
    BITBOOL _fToolbar:1;    // do we have a toolbar for the current band?

    HWND                _hwndTBRebar;
    HWND                _hwndTB;
    HWND                _hwndOptionsTB;
    IOleCommandTarget*  _pCmdTarget;
    GUID                _guidButtonGroup;

    HFONT   _hfont;
    UINT    _uTitle;
    UINT    _uToolbar;
    DWORD   _dwBandIDCur;   // the currently visible band
};

#define BROWSERBAR_ICONWIDTH 16
#define BROWSERBAR_FONTSIZE 18

#ifndef UNIX
#define BROWSERBAR_TITLEHEIGHT 22
#else
#define BROWSERBAR_TITLEHEIGHT 24
#endif

#define BROWSERBAR_TOOLBARHEIGHT 24

#endif // _browbs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browseui.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DIN_SHDOCVW \
                  -DFAVORITESTOSHDOCVW \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# We don't define _ATL_MIN_CRT because we implement the functions ourselves
# (crtfree.h).

# Define _MERGE_PROXYSTUB to merge the proxy/stub code into the DLL
#C_DEFINES       = $(C_DEFINES) -D_MERGE_PROXYSTUB

# Bring in the ATL headers
USE_STATIC_ATL = 1

# Bring in the WTL headers
USE_WTL=1
WTL_VER=10

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL = 1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES       = $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

!include $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

USE_MSVCRT      = 1

# be careful here-- browseui has to run downlevel. Don't add anything to
# the delayload line that you absolutely depend on having downlevel!
DELAYLOAD       = mpr.dll;shell32.dll;imm32.dll;wininet.dll;urlmon.dll;\
                  shdocvw.dll;msimg32.dll;oleaut32.dll;uxtheme.dll

DLOAD_ERROR_HANDLER = shlwapi

#BUGBUG (reinerf) - I promised bryant that I would fix these
LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4217 

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

#
# Skip these files when checking for dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  emdef.h    \
                  emrule.h   \
                  mso.h      \
                  msoem.h    \
                  statreg.h  \
                  statreg.cpp \

INCLUDES=$(INCLUDES) \
    $(INETCORE_INC_PATH);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\browmenu.cpp ===
#include "priv.h"
#include "browmenu.h"
#include "resource.h"
#include "uemapp.h"
#include "mluisupp.h"
#include <varutil.h>
#include "legacy.h"

#define UEM_NEWITEMCOUNT 2
// Exported by shdocvw
STDAPI GetLinkInfo(IShellFolder* psf, LPCITEMIDLIST pidlItem, BOOL* pfAvailable, BOOL* pfSticky);

#define REG_STR_MAIN TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main")

BOOL AreIntelliMenusEnbaled()
{
    // This is only garenteed to work on version 5 shell because the session 
    // incrementer is located in the tray
    if (GetUIVersion() >= 5)
    {
        DWORD dwRest = SHRestricted(REST_INTELLIMENUS);
        if (dwRest != RESTOPT_INTELLIMENUS_USER)
            return (dwRest == RESTOPT_INTELLIMENUS_ENABLED);

        return SHRegGetBoolUSValue(REG_STR_MAIN, TEXT("FavIntelliMenus"),
                                   FALSE, FALSE); // Don't ignore HKCU, Disable Menus by default
    }
    else
        return FALSE;
}


CFavoritesCallback::CFavoritesCallback() : _cRef(1)
{
    _fOffline = BOOLIFY(SHIsGlobalOffline());
}

CFavoritesCallback::~CFavoritesCallback()
{
    ASSERT(_punkSite == NULL);

    ASSERT(_psmFavCache == NULL);
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CFavoritesCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFavoritesCallback, IShellMenuCallback),
        QITABENT(CFavoritesCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CFavoritesCallback::AddRef ()
{
    return ++_cRef;
}

/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CFavoritesCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CFavoritesCallback::SetSite(IUnknown* punk)
{
    ATOMICRELEASE(_punkSite);
    _punkSite = punk;
    if (_punkSite)
    {
        _punkSite->AddRef();
    }
    else if (_psmFavCache)
    {
        // Since the top level menu is being destroyed, they are removing
        // our site. We should cleanup.
        DWORD dwFlags;
        UINT uId;
        UINT uIdA;

        _psmFavCache->GetMenuInfo(NULL, &uId, &uIdA, &dwFlags);

        // Tell menuband we're no longer caching it. We need to do this so ClowseDW
        // cleans up the menus.
        dwFlags &= ~SMINIT_CACHED;
        _psmFavCache->Initialize(NULL, uId, uIdA, dwFlags); 

        IDeskBand* pdesk;
        if (SUCCEEDED(_psmFavCache->QueryInterface(IID_IDeskBand, (LPVOID*)&pdesk)))
        {
            pdesk->CloseDW(0);
            pdesk->Release();
        }

        ATOMICRELEASE(_psmFavCache);
    }

    return NOERROR;

}

/*----------------------------------------------------------
Purpose: IShellMenuCallback::CallbackSM method

*/
STDMETHODIMP CFavoritesCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_FALSE;
    switch (uMsg)
    {
    case SMC_INITMENU:
        hres = _Init(psmd->hmenu, psmd->uIdParent, psmd->punk);
        break;

    case SMC_EXITMENU:
        hres = _Exit();
        break;

    case SMC_CREATE:
        if (psmd->uIdParent == FCIDM_MENU_FAVORITES)
            _fExpandoMenus = AreIntelliMenusEnbaled();
        break;

     case SMC_DEMOTE:
         hres = _Demote(psmd);
         break;
 
     case SMC_PROMOTE:
         hres = _Promote(psmd);
         break;
 
     case SMC_NEWITEM:
         hres = _HandleNew(psmd);
         break;

    case SMC_SFEXEC:
        hres = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETINFO:
        hres = _GetHmenuInfo(psmd->hmenu, psmd->uId, (SMINFO*)lParam);
        break;

    case SMC_SFSELECTITEM:
        hres = _SelectItem(psmd->pidlFolder, psmd->pidlItem);
        break;

    case SMC_GETOBJECT:
        hres = _GetObject(psmd, (GUID)*((GUID*)wParam), (void**)lParam);
        break;

    case SMC_DEFAULTICON:
        hres = _GetDefaultIcon((LPTSTR)wParam, (int*)lParam);
        break;

    case SMC_GETSFINFO:
        hres = _GetSFInfo(psmd, (SMINFO*)lParam);
        break;

    case SMC_SHCHANGENOTIFY:
        {
            PSMCSHCHANGENOTIFYSTRUCT pshf = (PSMCSHCHANGENOTIFYSTRUCT)lParam;
            hres = _ProcessChangeNotify(psmd, pshf->lEvent, pshf->pidl1, pshf->pidl2);
        }
        break;

    case SMC_REFRESH:
        _fExpandoMenus = AreIntelliMenusEnbaled();
        break;

    case SMC_CHEVRONGETTIP:
        hres = _GetTip((LPTSTR)wParam, (LPTSTR)lParam);
        break;

    case SMC_CHEVRONEXPAND:
        {
            if (_fShowingTip)
            {
                LPTSTR pszExpanded = TEXT("NO");

                SHRegSetUSValue(REG_STR_MAIN, TEXT("FavChevron"),
                    REG_SZ, pszExpanded, lstrlen(pszExpanded) * sizeof(TCHAR), SHREGSET_FORCE_HKCU);
            }

            _fShowingTip = FALSE;

            hres = S_OK;
        }
        break;

    case SMC_DISPLAYCHEVRONTIP:

        // Should we show the tip?
        _fShowingTip = SHRegGetBoolUSValue(REG_STR_MAIN, TEXT("FavChevron"), FALSE, TRUE);    // Default to YES.

        if (_fShowingTip)
        {
            hres = S_OK;
        }
        break;

    case SMC_SFDDRESTRICTED:
        hres = _AllowDrop((IDataObject*)wParam, (HWND)lParam) ? S_FALSE : S_OK;
        break;
    }

    return hres;
}


HRESULT CFavoritesCallback::_Init(HMENU hMenu, UINT uIdParent, IUnknown* punk)
{
#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0)
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
    }
#endif

    HRESULT hres = S_FALSE;

    if (SUCCEEDED(IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, &CGID_MenuBand, MBANDCID_ENTERMENU, 0, NULL, NULL)))
        hres = S_OK;

    // Only do this for the favorites dropdown. This was causing 
    // the chevron menu to be invalidated before it was created. This caused some
    // resize problems because the metrics were unavailable.
    if (uIdParent == FCIDM_MENU_FAVORITES)
    {
        // If we switched between online and offline, we need to re-init the menu
        BOOL fOffline = BOOLIFY(SHIsGlobalOffline());
        if (fOffline ^ _fOffline || _fRefresh)
        {
            _fOffline = fOffline;
            IShellMenu* psm;
            if (SUCCEEDED(punk->QueryInterface(IID_IShellMenu, (void**)&psm)))
            {
                psm->InvalidateItem(NULL, SMINV_REFRESH);
                psm->Release();
            }
            _fRefresh = FALSE;
        }
    }
    return hres;
}


HRESULT CFavoritesCallback::_Exit()
{
    HRESULT hr = IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, &CGID_MenuBand, MBANDCID_EXITMENU, 0, NULL, NULL);

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

HRESULT CFavoritesCallback::_GetHmenuInfo(HMENU hMenu, UINT uId, SMINFO* psminfo)
{
    if (uId == FCIDM_MENU_FAVORITES)
    {
        if (psminfo->dwMask & SMIM_FLAGS)
            psminfo->dwFlags |= SMIF_DROPCASCADE;
    }
    else
    {
        if (psminfo->dwMask & SMIM_FLAGS)
            psminfo->dwFlags |= SMIF_TRACKPOPUP;
    }

    // No item has icons
    if (psminfo->dwMask & SMIM_ICON)
        psminfo->iIcon = -1;
    
    return S_OK;
}


HRESULT CFavoritesCallback::_GetSFInfo(SMDATA* psmd, SMINFO* psminfo)
{
    BOOL fAvailable;

    //
    // If we are offline and the item is not available, we set the
    // SMIF_ALTSTATE so that the menu item is greyed
    //
    if (psminfo->dwMask & SMIM_FLAGS)
    {
        if (_fOffline &&
            SUCCEEDED(GetLinkInfo(psmd->psf, psmd->pidlItem, &fAvailable, NULL)) &&
            fAvailable == FALSE)
        {
            // Not available, so grey the item
            psminfo->dwFlags |= SMIF_ALTSTATE;
        }

        if (_fExpandoMenus)
            psminfo->dwFlags |= _GetDemote(psmd);
    }
    return S_OK;
}

HRESULT CFavoritesCallback::_SelectItem(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl)
{
    HRESULT hres = S_FALSE;
    LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidl);
    if (pidlFull)
    {
        VARIANTARG vargIn;
        hres = InitVariantFromIDList(&vargIn, pidlFull);
        if (SUCCEEDED(hres))
        {
            hres = IUnknown_QueryServiceExec(_punkSite, SID_SMenuBandHandler,
                &CGID_MenuBandHandler, MBHANDCID_PIDLSELECT, 0, &vargIn, NULL);
            VariantClearLazy(&vargIn);
        }
        ILFree(pidlFull);
    }
    return hres;
}

void CFavoritesCallback::_RefreshItem(HMENU hmenu, int idCmd, IShellMenu* psm)
{
    SMDATA smd;
    smd.dwMask = SMDM_HMENU;
    smd.hmenu = hmenu;
    smd.uId = idCmd;

    psm->InvalidateItem(&smd, SMINV_ID | SMINV_REFRESH);
}

HRESULT CFavoritesCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvOut)
{
    HRESULT hres = S_FALSE;
    *ppvOut = NULL;

    if (IsEqualIID(IID_IShellMenu, riid))
    {
        if (psmd->uId == FCIDM_MENU_FAVORITES)
        {
            // Do we have a cached Favorites menu?
            if (_psmFavCache)
            {
                // Yes we do, return it
                _psmFavCache->AddRef();
                *ppvOut = (LPVOID)_psmFavCache;
                hres = S_OK;
            }
            else
            {
                // Nope; We need to create one...
                hres = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC, 
                    IID_IShellMenu, (void**)&_psmFavCache);

                if (SUCCEEDED(hres))
                {
                    HMENU hmenu = NULL;
                    HWND hwnd;

                    _psmFavCache->Initialize(this, FCIDM_MENU_FAVORITES, ANCESTORDEFAULT, 
                        SMINIT_CACHED | SMINIT_VERTICAL); 

                    // We need to grab the Top HMENU portion of the Favorites menu from the current band
                    IShellMenu* psm;
                    if (SUCCEEDED(psmd->punk->QueryInterface(IID_IShellMenu, (LPVOID*)&psm)))
                    {
                        psm->GetMenu(&hmenu, &hwnd, NULL);

                        hmenu = GetSubMenu(hmenu, GetMenuPosFromID(hmenu, FCIDM_MENU_FAVORITES));

                        // Delete the placeholder item (there to keep the separator from getting
                        // lost during shbrowse menu merging, which deletes trailing separators).
                        int iPos = GetMenuPosFromID(hmenu, FCIDM_FAVPLACEHOLDER);
                        if (iPos >= 0)
                            DeleteMenu(hmenu, iPos, MF_BYPOSITION);

                        psm->Release();
                    }

                    if (hmenu)
                    {
                        hres = _psmFavCache->SetMenu(hmenu, hwnd, SMSET_TOP | SMSET_DONTOWN);
                    }
 
                    LPITEMIDLIST pidlFav;
                    if (SUCCEEDED(hres) &&
                        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFav)))
                    {
                        IShellFolder* psf;
                        if (SUCCEEDED(IEBindToObject(pidlFav, &psf)))
                        {
                            HKEY hMenuKey;
                            DWORD dwDisp;

                            RegCreateKeyEx(HKEY_CURRENT_USER, STRREG_FAVORITES, NULL, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                NULL, &hMenuKey, &dwDisp);

                            hres = _psmFavCache->SetShellFolder(psf, pidlFav, hMenuKey, 
                                SMSET_BOTTOM | SMSET_USEBKICONEXTRACTION | SMSET_HASEXPANDABLEFOLDERS);
                            psf->Release();
                        }
                        ILFree(pidlFav);
                    }

                    if (SUCCEEDED(hres))
                    {
                        _psmFavCache->AddRef(); // We're caching this.
                        *ppvOut = _psmFavCache;
                    }
                }
            }
        }
    }
    else if (IsEqualIID(IID_IShellMenuCallback, riid))
    {
        IShellMenuCallback* psmcb = (IShellMenuCallback*) new CFavoritesCallback;

        if (psmcb)
        {
            *ppvOut = (LPVOID)psmcb;
            hres = S_OK;
        }
    }

    return hres;
}


// Short circuit the looking up of a default icon. We're going to assume that all of them
// are URLs, even folders, for the sake of speed. It gives the user feedback directly, then
// we asyncronously render the real icons.
HRESULT CFavoritesCallback::_GetDefaultIcon(TCHAR* psz, int* piIndex)
{
    HRESULT hr;
    DWORD cchSize = MAX_PATH;
    
    if (SUCCEEDED(hr = AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cchSize)))
        *piIndex = PathParseIconLocation(psz);
        
    return hr;
}

DWORD CFavoritesCallback::_GetDemote(SMDATA* psmd)
{
    UEMINFO uei;
    DWORD dwFlags = 0;
    if (_fExpandoMenus)
    {
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        if (SUCCEEDED(UEMQueryEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei)))
        {
            if (uei.cHit == 0) 
            {
                dwFlags |= SMIF_DEMOTED;
            }
        }
    }

    return dwFlags;
}

HRESULT CFavoritesCallback::_Demote(LPSMDATA psmd)
{
    HRESULT hres = S_FALSE;

    if (_fExpandoMenus)
    {
        UEMINFO uei;
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = 0;
        hres = UEMSetEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }
    return hres;
}

HRESULT CFavoritesCallback::_Promote(LPSMDATA psmd)
{
    if (_fExpandoMenus) 
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem);
    }
    return S_OK;
}

HRESULT CFavoritesCallback::_HandleNew(LPSMDATA psmd)
{
    HRESULT hres = S_FALSE;
    if (_fExpandoMenus)
    {
        UEMINFO uei;
        uei.cbSize = SIZEOF(uei);
        uei.dwMask = UEIM_HIT;
        uei.cHit = UEM_NEWITEMCOUNT;
        hres = UEMSetEvent(&UEMIID_BROWSER, UEME_RUNPIDL, (WPARAM)psmd->psf, (LPARAM)psmd->pidlItem, &uei);
    }

    return hres;
}

HRESULT CFavoritesCallback::_GetTip(LPTSTR pstrTitle, LPTSTR pstrTip)
{
    MLLoadString(IDS_CHEVRONTIPTITLE, pstrTitle, MAX_PATH);
    MLLoadString(IDS_CHEVRONTIP, pstrTip, MAX_PATH);

    // Why would this fail?
    if (EVAL(pstrTitle[0] != TEXT('\0') && pstrTip[0] != TEXT('\0')))
        return S_OK;

    return S_FALSE;
}

// There is a duplicate of this helper in shell32\unicpp\startmnu.cpp
//                   When modifying this, rev that one as well.
void UEMRenamePidl(const GUID *pguidGrp1, IShellFolder* psf1, LPCITEMIDLIST pidl1,
                   const GUID *pguidGrp2, IShellFolder* psf2, LPCITEMIDLIST pidl2)
{
    UEMINFO uei;
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;
    if (SUCCEEDED(UEMQueryEvent(pguidGrp1, 
                                UEME_RUNPIDL, (WPARAM)psf1, 
                                (LPARAM)pidl1, &uei)) &&
                                uei.cHit > 0)
    {
        UEMSetEvent(pguidGrp2, 
            UEME_RUNPIDL, (WPARAM)psf2, (LPARAM)pidl2, &uei);

        uei.cHit = 0;
        UEMSetEvent(pguidGrp1, 
            UEME_RUNPIDL, (WPARAM)psf1, (LPARAM)pidl1, &uei);
    }
}

// There is a duplicate of this helper in shell32\unicpp\startmnu.cpp
//                   When modifying this, rev that one as well.
void UEMDeletePidl(const GUID *pguidGrp, IShellFolder* psf, LPCITEMIDLIST pidl)
{
    UEMINFO uei;
    uei.cbSize = SIZEOF(uei);
    uei.dwMask = UEIM_HIT;
    uei.cHit = 0;
    UEMSetEvent(pguidGrp, UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
}

HRESULT CFavoritesCallback::_ProcessChangeNotify(SMDATA* psmd, LONG lEvent, 
                                                 LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        {
            LPITEMIDLIST pidlFavorites;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFavorites)))
            {
                if (ILIsParent(pidlFavorites, pidl1, FALSE))
                {
                    IShellFolder* psfFrom;
                    LPCITEMIDLIST pidlFrom;
                    if (SUCCEEDED(IEBindToParentFolder(pidl1, &psfFrom, &pidlFrom)))
                    {
                        if (ILIsParent(pidlFavorites, pidl2, FALSE))
                        {
                            IShellFolder* psfTo;
                            LPCITEMIDLIST pidlTo;

                            if (SUCCEEDED(IEBindToParentFolder(pidl2, &psfTo, &pidlTo)))
                            {
                                // Then we need to rename it
                                UEMRenamePidl(&UEMIID_BROWSER, psfFrom, pidlFrom, 
                                              &UEMIID_BROWSER, psfTo, pidlTo);
                                psfTo->Release();
                            }
                        }
                        else
                        {
                            // Otherwise, we delete it.
                            UEMDeletePidl(&UEMIID_BROWSER, psfFrom, pidlFrom);
                        }

                        psfFrom->Release();
                    }
                }

                ILFree(pidlFavorites);
            }
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(IEBindToParentFolder(pidl1, &psf, &pidl)))
            {
                UEMDeletePidl(&UEMIID_BROWSER, psf, pidl);
                psf->Release();
            }

        }
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidl;

            if (SUCCEEDED(IEBindToParentFolder(pidl1, &psf, &pidl)))
            {
                UEMINFO uei;
                uei.cbSize = SIZEOF(uei);
                uei.dwMask = UEIM_HIT;
                uei.cHit = UEM_NEWITEMCOUNT;
                UEMSetEvent(&UEMIID_BROWSER, 
                    UEME_RUNPIDL, (WPARAM)psf, (LPARAM)pidl, &uei);
            }

        }
        break;
    case SHCNE_EXTENDED_EVENT:
        {
            // We get this event when we are offline and the cache was changed.
            // We need to refresh the favorites menu when we next show it so the 
            // correct items are greyed.

            SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;

            int iEvent = pdwidl->dwItem1;

            if (iEvent == SHCNEE_WININETCHANGED &&
                (pdwidl->dwItem2 & (CACHE_NOTIFY_ADD_URL |
                        CACHE_NOTIFY_DELETE_URL |   
                        CACHE_NOTIFY_DELETE_ALL |
                        CACHE_NOTIFY_URL_SET_STICKY |
                        CACHE_NOTIFY_URL_UNSET_STICKY)))
            {
                _fRefresh = TRUE;
            }
        }
        break;
    }

    return S_FALSE;
}

//
// _Disallow drop returns S_OK if the drop shold not be allowed.  S_FALSE if
// the drop should be allowed.
//
BOOL CFavoritesCallback::_AllowDrop(IDataObject* pIDataObject, HWND hwnd)
{
    ASSERT(NULL == hwnd || IsWindow(hwnd));

    BOOL fRet = True;  // Allow drop.

    if (hwnd && pIDataObject)
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pIDataObject, &pidl, NULL, 0)))
        {
            fRet = IEIsLinkSafe(hwnd, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bsmenu.cpp ===
#include "priv.h"
#include "sccls.h"
#include "bands.h"
#include "bsmenu.h"
#include "isfband.h"
#include "legacy.h"
#include "resource.h"
#include "uemapp.h"
#include "enumband.h"

#include "mluisupp.h"

static const CLSID g_clsidNull = {0};

#define DPA_SafeGetPtrCount(hdpa)   (hdpa ? DPA_GetPtrCount(hdpa) : 0)

HRESULT CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CBandSiteMenu *p = new CBandSiteMenu();
    if (p)
    {
        *ppunk = SAFECAST(p, IShellService*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CBandSiteMenu::CBandSiteMenu() : _cRef(1)
{
    DllAddRef();
}

CBandSiteMenu::~CBandSiteMenu()
{
    DPA_DestroyCallback(_hdpaBandClasses, _DPA_FreeBandClassInfo, 0);
    _hdpaBandClasses = NULL;
    SetOwner(NULL);
    DllRelease();
}

int CBandSiteMenu::_DPA_FreeBandClassInfo(LPVOID p, LPVOID d)
{
    BANDCLASSINFO *pbci = (BANDCLASSINFO*)p;

    // req'd
    ASSERT(pbci->pszName || (*(int *)&pbci->clsid == 0));
    
    if (pbci->pszName)
        LocalFree(pbci->pszName);

    // optional
    if (pbci->pszIcon != NULL)
        LocalFree(pbci->pszIcon);
    if (pbci->pszMenu != NULL)
        LocalFree(pbci->pszMenu);
    if (pbci->pszHelp != NULL)
        LocalFree(pbci->pszHelp);
    if (pbci->pszMenuPUI != NULL)
        LocalFree(pbci->pszMenuPUI);
    if (pbci->pszHelpPUI != NULL)
        LocalFree(pbci->pszHelpPUI);

    LocalFree(pbci);

    return 1;
}


ULONG CBandSiteMenu::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CBandSiteMenu::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CBandSiteMenu::SetOwner(IUnknown* punk)
{
    ATOMICRELEASE(_pbs);
    
    if (punk)
    {
        punk->QueryInterface(IID_IBandSite, (LPVOID*)&_pbs);
    }
    
    return S_OK;
}

HRESULT CBandSiteMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg, wParam, lParam, NULL);
}

UINT CBandSiteMenu::_IDToInternal(UINT uID)
{
    if (uID != -1)
    {
        uID -= _idCmdFirst;
    }

    return uID;
}

UINT CBandSiteMenu::_IDToExternal(UINT uID)
{
    if (uID != -1)
    {
        uID += _idCmdFirst;
    }

    return uID;
}

LRESULT CBandSiteMenu::_OnInitMenuPopup(HMENU hmenu, UINT uPos)
{
    //
    // Is this is the "Toolbars >" submenu (which we populate
    // lazily), and has it not yet been populated?
    //
    UINT uID = GetMenuItemID(hmenu, 0);
    uID = _IDToInternal(uID);
    if (uID == DBIDM_DESKTOPBAND)
    {
        // Yes
        _PopulateSubmenu(hmenu);
    }

    return 0;
}

HRESULT CBandSiteMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        lres = _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam));
        break;
    }

    if (plres)
        *plres = lres;

    return S_OK;
}

HRESULT CBandSiteMenu::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CBandSiteMenu, IContextMenu3),
        QITABENTMULTI(CBandSiteMenu, IContextMenu2, IContextMenu3),
        QITABENTMULTI(CBandSiteMenu, IContextMenu, IContextMenu3),
        QITABENT(CBandSiteMenu, IShellService),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        if (IsEqualIID(riid, CLSID_BandSiteMenu))
        {
            *ppvObj = (void *) this;
            AddRef();
            return S_OK;
        }
    }

    return hres;
} 

#define MAX_BANDS  50

void CBandSiteMenu::_PopulateSubmenu(HMENU hmenuSub)
{
    // the start id is the last of the fixed bands.
    // when we do the Shell_MergeMenus below, it will be incremented by idCmdFirst

    ASSERT(hmenuSub);

    CATID catid = CATID_DeskBand;

    if (_hdpaBandClasses)
    {
        DPA_DestroyCallback(_hdpaBandClasses, _DPA_FreeBandClassInfo, 0);
        _hdpaBandClasses = NULL;
    }

    LoadFromComCat(&catid);

    // Kick off an asynchronous update of the comcat cache
    SHWriteClassesOfCategories(1, &catid, 0, NULL, TRUE, FALSE, NULL);

    _idCmdEnumFirst = CreateMergeMenu(hmenuSub, MAX_BANDS, 0, _IDToExternal(DBIDM_NEWBANDFIXEDLAST), 0, FALSE);

    _AddEnumMenu(hmenuSub, GetMenuItemCount(hmenuSub) - 2); // -2 to go before "New Toolbar" and separator
    
    int iIndex = GetMenuItemCount(hmenuSub);
    if (SHRestricted(REST_NOCLOSE_DRAGDROPBAND) || SHRestricted(REST_CLASSICSHELL))
    {
        // We also need to disable turning On or Off the Bands.
        // In classic mode, don't allow them either.
        int nIter;
        for (nIter = 0; nIter < iIndex; nIter++)
            EnableMenuItem(hmenuSub, nIter, MF_BYPOSITION | MF_GRAYED);
    }

    if (SHRestricted(REST_CLASSICSHELL))
    {
        // Disable New Toolbar menu also.
        EnableMenuItem(hmenuSub, DBIDM_NEWFOLDERBAND, MF_BYCOMMAND | MF_GRAYED);
    }
}

HRESULT CBandSiteMenu::QueryContextMenu(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    if (!_pbs)
        return E_FAIL;

    if (SHRestricted(REST_NOTOOLBARSONTASKBAR))
    {
        return E_FAIL;
    }

    HMENU hmenuSrc = LoadMenuPopup_PrivateNoMungeW(MENU_DESKBARAPP);
    if (hmenuSrc)
    {
        _idCmdFirst = idCmdFirst;

        Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        DestroyMenu(hmenuSrc);

        if (_SHIsMenuSeparator(hmenu, indexMenu))
        {
            //
            // Adjust indexMenu to point to the spot where the Toolbars
            // submenu was actually inserted.
            //
            indexMenu++;
        }

        if (!(uFlags & CMF_ICM3))
        {
            //
            // Caller doesn't speak ICM3, so won't give us a chance to
            // populate submenu on WM_INITMENUPOPUP.  Thus we need to
            // populate it now.
            //
            HMENU hmenuSub = GetSubMenu(hmenu, indexMenu);

            if (hmenuSub)
                _PopulateSubmenu(hmenuSub);
        }
#ifdef DEBUG
        else
        {
            //
            // _OnInitMenuPopup assumes DBIDM_DESKTOPBAND is the first item
            // in the "Toolbars >" submenu.  If that assumption breaks (and
            // you see this ASSERT rip), be sure to fix up the code there.
            //
            HMENU hmenuSub = GetSubMenu(hmenu, indexMenu);
            ASSERT(GetMenuItemID(hmenuSub, 0) == _IDToExternal(DBIDM_DESKTOPBAND));
        }
#endif

        //
        // Assert that our caller gave us enough room to accomodate
        // the worst-case count.
        //
        ASSERT((idCmdFirst + DBIDM_NEWBANDFIXEDLAST + MAX_BANDS) < idCmdLast);

        return idCmdFirst + DBIDM_NEWBANDFIXEDLAST + MAX_BANDS;
    }

    return E_FAIL;
}

BOOL CBandSiteMenu::_CheckUnique(IDeskBand* pdb, HMENU hmenu) 
{
    // check to see if this band is unique. (not already added by comcat list or
    // hard coded list
    // if it is unique, return TRUE.
    // if it's not, check the other menu item
    CLSID clsid;
    DWORD dwPrivID;
    BOOL fRet = TRUE;
    UINT idCmd = (UINT)-1;
    
    if (SUCCEEDED(_GetBandIdentifiers(pdb, &clsid, &dwPrivID)))
    {
        // check the comcat list
        if (dwPrivID == (DWORD)-1)
        {
            for (int i = 0; i < DPA_SafeGetPtrCount(_hdpaBandClasses) ; i++)
            {
                BANDCLASSINFO *pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, i);
                if (IsEqualGUID(clsid, pbci->clsid))
                {
                    idCmd = i + DBIDM_NEWBANDFIXEDLAST;
                    goto FoundIt;
                }
            }
        }
        else if (IsEqualGUID(clsid, CLSID_ISFBand))
        {
            // check our hardcoded list

            switch (dwPrivID)
            {
            case CSIDL_DESKTOP:
                idCmd = DBIDM_DESKTOPBAND;
                break;
                
            case CSIDL_APPDATA:
                idCmd = DBIDM_LAUNCHBAND;
                break;
                
            }
        }
    }

FoundIt:
    if (idCmd != (UINT)-1)
    {
        // we found a menu for this already.... if it wasn't already checked,
        // check it now and it will represent us
        if (!(GetMenuState(hmenu, _IDToExternal(idCmd), MF_BYCOMMAND) & MF_CHECKED))
        {
            CheckMenuItem(hmenu, _IDToExternal(idCmd), MF_BYCOMMAND | MF_CHECKED);
            fRet = FALSE;
        }
    }
    return fRet;
}

void CBandSiteMenu::_AddEnumMenu(HMENU hmenu, int iInsert)
{
    DWORD dwID;

    int iMax = MAX_BANDS - (_IDToInternal(_idCmdEnumFirst) - DBIDM_NEWBANDFIXEDLAST);

    for (int i = 0; i < iMax && SUCCEEDED(_pbs->EnumBands(i, &dwID)); i++)
    {
        HRESULT hr;
        WCHAR szName[80];
        DWORD dwFlags = MF_BYPOSITION;
        DWORD dwState;
        IDeskBand *pdb;

        hr = _pbs->QueryBand(dwID, &pdb, &dwState, szName, ARRAYSIZE(szName));
        if (EVAL(SUCCEEDED(hr)))
        {
            if (_CheckUnique(pdb, hmenu))
            {
                if (dwState & BSSF_VISIBLE)
                    dwFlags |= MF_CHECKED;

                if (!(dwState & BSSF_UNDELETEABLE))
                {
                    InsertMenu(hmenu, iInsert, dwFlags, _idCmdEnumFirst + i, szName);
                    iInsert++;
                }
            }
        }
        
        if (pdb)
            pdb->Release();
    }
}

HRESULT CBandSiteMenu::_GetBandIdentifiers(IUnknown *punk, CLSID* pclsid, DWORD* pdwPrivID)
{
    HRESULT hr = E_FAIL;
    IPersist* pp;

    if (SUCCEEDED(punk->QueryInterface(IID_IPersist, (LPVOID*)&pp)))
    {
        pp->GetClassID(pclsid);

        VARIANTARG v = {0};
        *pdwPrivID = (DWORD) -1;
        if (SUCCEEDED(IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_PRIVATEID, 0, NULL, &v)))
        {
            if (v.vt == VT_I4)
            {
                *pdwPrivID = (DWORD)v.lVal;
            }
        }
        hr = S_OK;
        pp->Release();
    }
    return hr;
}

// we use IPersist to find the class id of bands.
// we have a few special case bands (such as Quick Launch and Desktop) that are 
// the same band, but pointing to different objects.
HRESULT CBandSiteMenu::_FindBand(const CLSID* pclsid, DWORD dwPrivID, DWORD* pdwBandID)
{
    int i = 0;
    BOOL fFound = FALSE;
    HRESULT hr = E_FAIL;
    DWORD dwBandID = -1;

    while (hr == E_FAIL && SUCCEEDED(_pbs->EnumBands(i, &dwBandID)))
    {
        IDeskBand* pdb;

        if (SUCCEEDED(_pbs->QueryBand(dwBandID, &pdb, NULL, NULL, 0)))
        {
            CLSID clsid;
            DWORD dwPrivData;
            if (SUCCEEDED(_GetBandIdentifiers(pdb, &clsid, &dwPrivData)))
            {
                // special case for differentiating between all of the isfbands
                // find out if the private id this holds is the same as what we're asking for
                if (IsEqualIID(clsid, *pclsid) && (dwPrivData == dwPrivID))
                {
                    hr = S_OK;
                }
            }
            pdb->Release();
        }
        i++;
    }
    
    if (pdwBandID)
        *pdwBandID = dwBandID;
    return hr;
}

HRESULT CBandSiteMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    int idCmd;
    
    if (!_pbs)
        return E_FAIL;
    
    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);
    else
        return E_FAIL;

    //
    // N.B.: Caller has mapped idCmd to internal for us
    //

    int idCmdEnumFirstInt = _IDToInternal(_idCmdEnumFirst);

    if (idCmd >= idCmdEnumFirstInt)
    {
        // these are the bands that they're turning on and off
        
        DWORD dwID;
        if (SUCCEEDED(_pbs->EnumBands(idCmd - idCmdEnumFirstInt, &dwID)))
        {
            _pbs->RemoveBand(dwID);
        }
    }
    else
    {
        // these are our merged menus from MENU_DESKBARAPP
        switch (idCmd)
        {
        case DBIDM_NEWFOLDERBAND:
            _BrowseForNewFolderBand();
            break;
            
        case DBIDM_DESKTOPBAND:
            _ToggleSpecialFolderBand(CSIDL_DESKTOP, NULL, FALSE);
            break;
            
        case DBIDM_LAUNCHBAND:
        {
            TCHAR szSubDir[MAX_PATH];
            MLLoadString(IDS_QLAUNCHAPPDATAPATH, szSubDir, ARRAYSIZE(szSubDir));
            // Microsoft\\Internet Explorer\\Quick Launch
            _ToggleSpecialFolderBand(CSIDL_APPDATA, szSubDir, TRUE);
            break;
        }
            
        default:
            ASSERT(idCmd >= DBIDM_NEWBANDFIXEDLAST);
            _ToggleComcatBand(idCmd - DBIDM_NEWBANDFIXEDLAST);
            break;
        }
    }
    return S_OK;
}

HRESULT CBandSiteMenu::_BandClassEnum(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam)
{
    TCHAR szName[128],
          szRegName[128],
          szClass[GUIDSTR_MAX];
    DWORD cbName;

    HDPA  hdpa = (HDPA)lParam;
    ASSERT(NULL != hdpa);

    // IE4 introduced this band, suppress it since we cut support for it in IE6
    if (IsEqualCLSID(CLSID_ChannelBand, rclsid))
    {
        return S_OK;
    }

    BANDCLASSINFO *pbci = (BANDCLASSINFO*)LocalAlloc(LPTR, sizeof(*pbci));
    if (NULL == pbci)
    {
        return E_OUTOFMEMORY;
    }

    pbci->clsid = rclsid;
    pbci->catid = rcatid;
    // now that we have the clsid, 
    // look in the registry for the display name
    SHStringFromGUID(pbci->clsid, szClass, ARRAYSIZE(szClass));
    wnsprintf(szRegName, ARRAYSIZE(szRegName), TEXT("CLSID\\%s"), szClass);

    cbName = ARRAYSIZE(szName);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szRegName, NULL, NULL, szName, &cbName))
    {
        HKEY hkey;

        pbci->pszName = StrDup(szName);
        if (NULL == pbci->pszName)
        {
            return E_OUTOFMEMORY;
        }

        if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, szRegName, &hkey))
        {
            const struct regstrs rstab[] =
            {
                { TEXT("DefaultIcon"), FIELD_OFFSET(BANDCLASSINFO, pszIcon)    },
                { TEXT("MenuText")   , FIELD_OFFSET(BANDCLASSINFO, pszMenu)    },
                { TEXT("HelpText")   , FIELD_OFFSET(BANDCLASSINFO, pszHelp)    },
                { TEXT("MenuTextPUI"), FIELD_OFFSET(BANDCLASSINFO, pszMenuPUI) },
                { TEXT("HelpTextPUI"), FIELD_OFFSET(BANDCLASSINFO, pszHelpPUI) },
                { 0, 0 },
            };

            // szBuf big enough for "path,-32767" or for status text
            TCHAR szBuf[MAX_PATH+7];

            Reg_GetStrs(hkey, rstab, szBuf, (int)ARRAYSIZE(szBuf), (LPVOID)pbci);
            RegCloseKey(hkey);
        }

        DPA_AppendPtr(hdpa, pbci);
    }

    return S_OK;
}

//***
//  Collect band class info from registry...
int CBandSiteMenu::LoadFromComCat(const CATID *pcatid )
{
    if (NULL == _hdpaBandClasses)
    {
        _hdpaBandClasses = DPA_Create(4);
    }

    if (NULL != _hdpaBandClasses && NULL != pcatid)
    {
        SHEnumClassesImplementingCATID(*pcatid, CBandSiteMenu::_BandClassEnum, (LPARAM)_hdpaBandClasses);
    }

    return DPA_SafeGetPtrCount(_hdpaBandClasses);
}


int CBandSiteMenu::CreateMergeMenu(HMENU hmenu, UINT cMax, UINT iPosition, UINT idCmdFirst, UINT iStart, BOOL fMungeAllowed)
{
    int j = 0;
    int iMax = DPA_SafeGetPtrCount(_hdpaBandClasses);

    for (int i = iStart; i < iMax; i++)
    {
        if ((UINT)j >= cMax)
        {
            TraceMsg(DM_WARNING, "cbsm.cmm: cMax=%u menu overflow, truncated", cMax);
            break;
        }

        BANDCLASSINFO *pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, i);
        DWORD         dwFlags = IsEqualCLSID(g_clsidNull,pbci->clsid) ? MF_BYPOSITION|MF_SEPARATOR : MF_BYPOSITION;
        LPTSTR        pszMenuText = pbci->pszMenuPUI ? pbci->pszMenuPUI : (pbci->pszMenu ? pbci->pszMenu : pbci->pszName) ;

        if (pszMenuText && *pszMenuText)
        {
            BOOL fInsert;

            if (fMungeAllowed)
            {
                fInsert = InsertMenu(hmenu, iPosition + j, dwFlags, idCmdFirst + j, pszMenuText);
            }
            else
            {
                fInsert = InsertMenu_PrivateNoMungeW(hmenu, iPosition + j, dwFlags, idCmdFirst + j, pszMenuText);
            }

            if (fInsert)
            {
                //  update menuitem cmd ID:
                pbci->idCmd = idCmdFirst + j;
                j++;
            }
        }
    }

    return j + idCmdFirst;
}


BANDCLASSINFO * CBandSiteMenu::GetBandClassDataStruct(UINT uBand)
{
    BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_GetPtr(_hdpaBandClasses, uBand);
    return pbci;
}

BOOL CBandSiteMenu::DeleteBandClass( REFCLSID rclsid )
{
    if( _hdpaBandClasses )
    {
        for( int i = 0, cnt = GetBandClassCount( NULL, FALSE ); i< cnt; i++ )
        {
            BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_GetPtr( _hdpaBandClasses, i );
            ASSERT( pbci );
        
            if( IsEqualCLSID( rclsid, pbci->clsid ) )
            {
                EVAL( DPA_DeletePtr( _hdpaBandClasses, i ) == (LPVOID)pbci );

                if( pbci->pszName )
                    LocalFree(pbci->pszName);
                LocalFree( pbci );
                return TRUE;
            }

        }
    }
    return FALSE;
}

int CBandSiteMenu::GetBandClassCount(const CATID* pcatid /*NULL*/, BOOL bMergedOnly /*FALSE*/)
{
    int cRet = 0; 

    if( _hdpaBandClasses != NULL )
    {
        int cBands = DPA_GetPtrCount(_hdpaBandClasses);
    
        if( pcatid || bMergedOnly ) // filter request
        {
            for( int i = 0; i < cBands; i++ )
            {
                BANDCLASSINFO * pbci = (BANDCLASSINFO *)DPA_FastGetPtr( _hdpaBandClasses, i );

                if( pbci->idCmd || !bMergedOnly )
                {
                    if( pcatid )
                    {
                        if( IsEqualGUID( pbci->catid, *pcatid )  )
                            cRet++;    
                    }
                    else
                        cRet++;
                }
            }
        }
        else
            cRet = cBands;
    }
    return cRet;
}

void CBandSiteMenu::_AddNewFSBand(LPCITEMIDLIST pidl, BOOL fNoTitleText, DWORD dwPrivID)
{
    IDeskBand *ptb = NULL;
    BOOL fISF = FALSE;

    // this was a drag of a link or folder
    // FEATURE: We should use a different test:
    //    DWORD dwAttrib = (SFGAO_FOLDER | SFGAO_BROWSABLE);
    //    IEGetAttributesOf(pidl, &dwAttrib);
    //    if (SFGAO_BROWSABLE != dwAttrib) 
    //    or we could reuse SHCreateBandForPidl().
    if (IsURLChild(pidl, TRUE))
    {
        // create browser to show web sites                        
        ptb = CBrowserBand_Create(pidl);
    }
    else
    {
        IFolderBandPriv *pfbp;
        // create an ISF band to show folders as hotlinks
        fISF = TRUE;
        ASSERT(pidl);       // o.w. CISFBand_CreateEx will fail
        if (FAILED(CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IFolderBandPriv, &pfbp))))
        {
            // we need to give a pretty
            // generic message: "can't create toolbar for %1".
            TCHAR szName[MAX_URL_STRING];
            
            szName[0] = 0;
            SHGetNameAndFlags(pidl, SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
            MLShellMessageBox(NULL,
                MAKEINTRESOURCE(IDS_CANTISFBAND),
                MAKEINTRESOURCE(IDS_WEBBARTITLE),
                MB_OK|MB_ICONERROR, szName);
        }
        else
        {
            pfbp->SetNoText(fNoTitleText);
            if (SUCCEEDED(pfbp->QueryInterface(IID_PPV_ARG(IDeskBand, &ptb))))
            {
                if (dwPrivID != -1)
                {
                    VARIANTARG v;
                    v.vt = VT_I4;
                    v.lVal = dwPrivID;
                    // find out if the private id this holds is the same as what we're asking for
                    IUnknown_Exec(ptb, &CGID_ISFBand, ISFBID_PRIVATEID, 0, &v, NULL);
                    // qlaunch and qlinks get logged
                    // (should we key off of host or CSIDL or both?) 
                    // FEATURE: UASSIST todo: qlinks NYI
                    if (dwPrivID == CSIDL_APPDATA)
                    {
                        ASSERT(v.vt == VT_I4);
                        v.lVal = UEMIND_SHELL;  // UEMIND_SHELL/BROWSER
                        IUnknown_Exec(ptb, &CGID_ShellDocView, SHDVID_UEMLOG, 0, &v, NULL);
                    }
                }
            }
            pfbp->Release();
        }
    }

    if (ptb)
    {
        HRESULT hr = _pbs->AddBand(ptb);
        if (SUCCEEDED(hr) && fISF)
            _pbs->SetBandState(ShortFromResult(hr), BSSF_NOTITLE, fNoTitleText ? BSSF_NOTITLE : 0);
        ptb->Release();
    }
}

void CBandSiteMenu::_ToggleSpecialFolderBand(int iFolder, LPTSTR pszSubPath, BOOL fNoTitleText)
{

    DWORD dwBandID;
    if (SUCCEEDED(_FindBand(&CLSID_ISFBand, iFolder, &dwBandID)))
    {
        _pbs->RemoveBand(dwBandID);
    }
    else
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, iFolder, &pidl)))
        {
            if (pszSubPath)
            {
                TCHAR szPath[MAX_PATH];
                SHGetPathFromIDList(pidl, szPath);
                PathCombine(szPath, szPath, pszSubPath);
                ILFree(pidl);
                pidl = ILCreateFromPath(szPath);
                ASSERT(pidl);       // o.w. AddNewFSBand will fail
            }
            _AddNewFSBand(pidl, fNoTitleText, iFolder);
            ILFree(pidl);
        }
    }
}

int CALLBACK SetCaptionCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg) 
    {
    case BFFM_INITIALIZED:
        TCHAR szTitle[80];
        MLLoadShellLangString(IDS_NEWFSBANDCAPTION, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(hwnd, szTitle);
        break;
    
    case BFFM_VALIDATEFAILEDA:
    case BFFM_VALIDATEFAILEDW:
        MLShellMessageBox(hwnd,
            uMsg == BFFM_VALIDATEFAILEDA ? MAKEINTRESOURCE(IDS_ERROR_GOTOA)
                                         : MAKEINTRESOURCE(IDS_ERROR_GOTOW),
            MAKEINTRESOURCE(IDS_WEBBARTITLE),
            MB_OK|MB_ICONERROR, (LPVOID)lParam);
        return 1;   // 1:leave dialog up for another try...
        /*NOTREACHED*/

    }

    return 0;
}


void CBandSiteMenu::_BrowseForNewFolderBand()
{
    BROWSEINFO bi = {0};
    LPITEMIDLIST pidl;
    TCHAR szTitle[256];
    TCHAR szPath[MAX_URL_STRING];

    if (_pbs)
        IUnknown_GetWindow(_pbs, &bi.hwndOwner);

    ASSERT(bi.pidlRoot == NULL);

    MLLoadShellLangString(IDS_NEWFSBANDTITLE, szTitle, ARRAYSIZE(szTitle));
    bi.lpszTitle = szTitle;

    bi.pszDisplayName = szPath;
    bi.ulFlags = (BIF_EDITBOX | BIF_VALIDATE | BIF_USENEWUI | BIF_BROWSEINCLUDEURLS);
    bi.lpfn = SetCaptionCallback;

    pidl = SHBrowseForFolder(&bi);
    if (pidl) 
    {
        _AddNewFSBand(pidl, FALSE, -1);
        ILFree(pidl);
    }
}

void CBandSiteMenu::_ToggleComcatBand(UINT idCmd)
{
    BANDCLASSINFO* pbci = (BANDCLASSINFO*)DPA_GetPtr(_hdpaBandClasses, idCmd);
    IUnknown* punk;
    DWORD dwBandID;
    
    if (SUCCEEDED(_FindBand(&pbci->clsid, -1, &dwBandID)))
    {
        _pbs->RemoveBand(dwBandID);
    }
    else if (S_OK == CoCreateInstance(pbci->clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&punk))
    {
        // Language returns S_FALSE and doesn't initialize punk leave us to fault
        IPersistStreamInit * ppsi;

        // Some Bands don't work if IPersistStreamInit::InitNew() isn't called.
        // This includes the QuickLinks Band.
        if (SUCCEEDED(punk->QueryInterface(IID_IPersistStreamInit, (LPVOID*)&ppsi)))
        {
            ppsi->InitNew();
            ppsi->Release();
        }

        _pbs->AddBand(punk);
        punk->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\button.cpp ===
#include "priv.h"
#include "button.h"

const static TCHAR c_szCoolButtonProp[]   = TEXT("CCoolButton_This");

/////////////////////////////////////////////////////////////////////////////
// CCoolButton

BOOL CCoolButton::Create(HWND hwndParent, INT_PTR nID, DWORD dwExStyle, DWORD dwStyle)
{
    m_hwndButton  = ::CreateWindowEx( dwExStyle, WC_BUTTON, NULL, dwStyle | WS_CHILD | WS_VISIBLE,
                                      0, 0, 0, 0, hwndParent, (HMENU)nID, HINST_THISDLL, NULL);

    if (m_hwndButton && SetProp(m_hwndButton, c_szCoolButtonProp, this))
    {
        SetWindowLongPtr(m_hwndButton, GWLP_USERDATA, (LPARAM)(WNDPROC)(GetWindowLongPtr(m_hwndButton, GWLP_WNDPROC)));
        SetWindowLongPtr(m_hwndButton, GWLP_WNDPROC,  (LPARAM)s_ButtonWndSubclassProc);
    }

    DWORD dwBtnStyle = GetWindowLong(m_hwndButton, GWL_STYLE);
    dwBtnStyle |= BS_PUSHBUTTON | BS_OWNERDRAW;
    SetWindowLong(m_hwndButton, GWL_STYLE, dwBtnStyle);

    ShowWindow(m_hwndButton, SW_SHOW);
    return m_hwndButton == NULL ? FALSE : TRUE;
}

CCoolButton::~CCoolButton()
{
    if (m_hwndButton)
        DestroyWindow(m_hwndButton);

    if (m_hImageList) 
        ImageList_Destroy(m_hImageList);

    if (m_bstrText)
        SysFreeString(m_bstrText);

    if (m_fIsCapture)
        ReleaseCapture();

    if (m_hFont)
        DeleteObject(m_hFont);
}


LRESULT CALLBACK CCoolButton::s_ButtonWndSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCoolButton* pThis = (CCoolButton*)GetProp(hwnd, c_szCoolButtonProp);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldWndProc = (WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
         case WM_ERASEBKGND:
            return (LRESULT)1;

         case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT)lParam;

                IMAGEINFO  imgInfo ;
                ImageList_GetImageInfo(pThis->m_hImageList, 0, &imgInfo);

                if (!pThis->m_bstrText)
                {
                    lpmis->itemWidth = RECTWIDTH(imgInfo.rcImage) ;
                    lpmis->itemHeight= RECTHEIGHT(imgInfo.rcImage) ;
                }
                else
                {
                    lpmis->itemWidth = RECTWIDTH(imgInfo.rcImage)  + 200;
                    lpmis->itemHeight= RECTHEIGHT(imgInfo.rcImage) ;
                }
            }
            return TRUE;
        
         case WM_DRAWITEM:
            {
                LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam;
                HDC hdc = lpdis->hDC;

                int  nIndex =     ((lpdis->itemState & ODS_DISABLED) ? 2 :
                                  ((lpdis->itemState & ODS_SELECTED) ? 1 :
                                  ((lpdis->itemState & ODS_FOCUS) ? 1 :
                                  (pThis->m_fHover) ?  1 : 0)));
                RECT rcClient;
                GetClientRect(hwnd,&rcClient);

                HDC     hdcMem = CreateCompatibleDC(hdc);

                HBITMAP hbmp = CreateCompatibleBitmap(hdc, RECTWIDTH(rcClient),RECTHEIGHT(rcClient));

                HBITMAP hOldBmp = (HBITMAP)SelectObject(hdcMem, hbmp);

                // fill rgn
                HBRUSH hBrush = CreateSolidBrush(RGB(244,244,240));
                if (hBrush)
                {
                    FillRect(hdcMem, &rcClient, hBrush);
                    DeleteObject(hBrush);
                }

                BOOL fEnabled = (lpdis->itemState & ODS_DISABLED) ? FALSE : TRUE  ;

                // Draw Button to the screen
                IMAGEINFO  imgInfo ;
                ImageList_GetImageInfo(pThis->m_hImageList, nIndex, &imgInfo);
                ImageList_Draw(pThis->m_hImageList, nIndex, hdcMem, RECTWIDTH(rcClient) -  RECTWIDTH(imgInfo.rcImage), 0, ILD_NORMAL);

                RECT rcFormat = { rcClient.left+2, rcClient.top , RECTWIDTH(rcClient)- RECTWIDTH(imgInfo.rcImage)-8, RECTHEIGHT(rcClient) };

                if (pThis->m_bstrText)
                {
                    // Get the caption to draw
                    LPWSTR pszText = L"";
                    pszText = pThis->m_bstrText;
 
                    int nBkMode = SetBkMode(hdcMem, TRANSPARENT);

                    HFONT hFontOld = (HFONT) SelectObject(hdcMem, pThis->m_hFont);
                    int   nOldTextColor = SetTextColor(hdcMem, RGB(0,255,0));
                    ::DrawText(hdcMem, pszText, -1, &rcFormat, pThis->GetDrawTextFlags());
                /*
                    int   nOldTextColor = 0;

                    // draw button caption depending upon button state
                    if (fEnabled) 
                    {
                        nOldTextColor = SetTextColor(hdcMem, GetSysColor(COLOR_BTNTEXT));
                        ::DrawText(hdcMem, pszText, -1, &rcFormat, pThis->GetDrawTextFlags());
                    }
                    else
                    {
                        nOldTextColor = SetTextColor(hdcMem, GetSysColor(COLOR_3DHILIGHT));
                        ::DrawText(hdcMem, pszText, -1, &rcFormat, pThis->GetDrawTextFlags());
                        SetTextColor(hdcMem, nOldTextColor);

                        nOldTextColor = SetTextColor(hdcMem, GetSysColor(COLOR_3DSHADOW));
                        ::DrawText(hdcMem, pszText, -1, &rcFormat, pThis->GetDrawTextFlags());
                        SetTextColor(hdcMem, nOldTextColor);
                    }
                 */
                    SelectObject(hdcMem, hFontOld);
                    SetBkMode(hdcMem, nBkMode);
                }

                BitBlt(hdc, 0, 0, RECTWIDTH(rcClient), RECTHEIGHT(rcClient),hdcMem, 0, 0,SRCCOPY);

                SelectObject(hdcMem, hOldBmp);

                DeleteObject(hbmp);
                DeleteDC(hdcMem);  
            }
            return TRUE;

        case WM_LBUTTONDBLCLK : 
        case WM_LBUTTONDOWN:
            {
                POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
                pThis->CheckHover(pt);

                if (pThis->m_fHover && (UINT)wParam & MK_LBUTTON && !pThis->m_fMouseDown)
                {
                    pThis->m_fMouseDown = TRUE;
                    CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
                    if (BT_MENU == pThis->GetButtonType())
                    {
                        SendMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(hwnd),BN_CLICKED), (LPARAM)(hwnd));
                    }
                    return 0;
                }
            }
            break;

        case WM_LBUTTONUP:
            {
                CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);

                pThis->m_fMouseDown = FALSE;
                if (pThis->m_fIsCapture)
                {
                    ReleaseCapture();
                    pThis->m_fIsCapture = FALSE;
                }
                POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
                pThis->CheckHover(pt);
            }
            return 0;

        case WM_MOUSEMOVE:
            {
                CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
                POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
                pThis->CheckHover(pt);
                if (pThis->m_fHover && (UINT)wParam & MK_LBUTTON)
                {
                    pThis->m_fMouseDown = TRUE;
                }
                RedrawWindow(hwnd,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
            }
            break;

       case WM_KEYDOWN:
           {
                SendMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(hwnd),BN_CLICKED), (LPARAM)(pThis->m_hwndButton));
                RedrawWindow(hwnd,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
           }
           break;

       case WM_KILLFOCUS:
           {
                if (pThis->m_fIsCapture)
                {
                    ReleaseCapture();
                    pThis->m_fIsCapture = FALSE;
                }
                pThis->m_fHover     = FALSE ;
                pThis->m_fHasFocus  = FALSE ;
                pThis->m_fMouseDown = FALSE ;
                RedrawWindow(hwnd,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
            }
            break;

       case WM_SETFOCUS:
            {
                if (!pThis->m_fIsCapture)
                {
                    SetCapture(hwnd);
                    pThis->m_fIsCapture = TRUE;
                }
                pThis->m_fHasFocus  = TRUE ;
                RedrawWindow(hwnd,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
            }
            break;

        case WM_DESTROY:
            {
                //
                // Unsubclass myself.
                //
                RemoveProp(hwnd, c_szCoolButtonProp);
                if (pfnOldWndProc)
                {
                    SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
                }
            }
            break;
    }
    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}

BOOL CCoolButton::LoadBitmaps(UINT nImageList, UINT iImageWidth)
{
    if (m_hImageList)
        ImageList_Destroy(m_hImageList);

    m_hImageList = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(nImageList), 
                                       iImageWidth, 0, CLR_NONE, IMAGE_BITMAP,  LR_CREATEDIBSECTION);

    SizeToContent();
    
    return m_hImageList != NULL;
}

// SizeToContent will resize the button to the size of the bitmap
HRESULT
CCoolButton::SizeToContent()
{
    SIZE sizeContent ;
    GetButtonSize(sizeContent);
    
    if (SetWindowPos(m_hwndButton,HWND_TOP, 0, 0, sizeContent.cx,sizeContent.cy,
                     SWP_NOMOVE|SWP_NOZORDER|SWP_NOREDRAW|SWP_NOACTIVATE))
    {
        return S_OK;
    }
    return S_FALSE;
}

VOID
CCoolButton::CheckHover(POINT pt)
{
    if (HitTest(pt))
    {
        if (!m_fIsCapture || GetCapture() != m_hwndButton)
        {
            SetCapture(m_hwndButton);
            m_fIsCapture = TRUE;
        }
        if (!m_fHover)
        {
            m_fHover = TRUE;
            RedrawWindow(m_hwndButton,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
        }
    }
    else
    {
        if (m_fIsCapture)
        {
            m_fIsCapture = FALSE;
            ReleaseCapture();
        }
        m_fHover = FALSE;
        RedrawWindow(m_hwndButton,NULL,NULL,RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
    }
}

BOOL CCoolButton::HitTest(POINT point)
{
    RECT rcClient;
    GetClientRect(m_hwndButton, &rcClient);

    return ::PtInRect(&rcClient, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\chanbar.cpp ===
#include "priv.h"
#ifdef ENABLE_CHANNELS
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "deskbar.h"
#include "bands.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include "chanbar.h"

#ifdef UNIX
#include <mainwin.h>
#endif

#include "mluisupp.h"

#define TBHEIGHT 20 // default height of the toolbar inside channel bar
#define TBWIDTH  20 // default width  of the toolbar inside channel bar


CChannelDeskBarApp::CChannelDeskBarApp() : _hwndDummy(NULL)
{
}

CChannelDeskBarApp::~CChannelDeskBarApp()
{
    if (IsWindow(_hwndDummy))
    {
        DestroyWindow(_hwndDummy);
    }
}

void CChannelDeskBarApp::_OnCreate()
{
    CDeskBarApp::_OnCreate();

    // remember screen resolution
    _cxScreen = GetSystemMetrics(SM_CXSCREEN);
    _cyScreen = GetSystemMetrics(SM_CYSCREEN);

    // create the dummy for receiving and forwarding broadcast messages 
    if (!_hwndDummy)
    {
        _hwndDummy = SHCreateWorkerWindow(DummyWndProc, 0, 0, 0, 0, this);
    }

    if (_hwndDummy)
    {
        // make sure we so a select a realize of a palette in this 
        // window so that we will get palette change notifications..
        HDC hdc = GetDC( _hwndDummy );
        if (hdc)
        {
            HPALETTE hpal = SHCreateShellPalette( hdc );

            if (hpal)
            {
                HPALETTE hpalOld = SelectPalette( hdc, hpal, TRUE );
                RealizePalette( hdc );

                // now select the old one back in
                SelectPalette( hdc, hpalOld, TRUE );
                DeletePalette( hpal );
            }

            ReleaseDC( _hwndDummy, hdc );
        }
    }
        
}

void CChannelDeskBarApp::_OnDisplayChange()
{
    // do not use lParam, since it may give us (0,0).
    UINT cxScreen = GetSystemMetrics(SM_CXSCREEN);
    UINT cyScreen = GetSystemMetrics(SM_CYSCREEN);
    UINT cxOldScreen = _cxScreen;
    UINT cyOldScreen = _cyScreen;
    
    _cxScreen = cxScreen;
    _cyScreen = cyScreen;
    
    if (_hwnd) {
        RECT rc;
        
        GetWindowRect(_hwnd, &rc);
        if (cxOldScreen) 
            rc.left = (rc.left * _cxScreen) / cxOldScreen;
        if (cyOldScreen)
            rc.top  = (rc.top  * _cyScreen) / cyOldScreen;

        SetWindowPos(_hwnd, NULL, rc.left, rc.top, 0, 0, 
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

        // we need to change the cached pos/size. 
        OffsetRect(&_rcFloat, rc.left - _rcFloat.left, rc.top - _rcFloat.top);

    }
}

LRESULT CChannelDeskBarApp::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    
    switch (uMsg) {
    case WM_CONTEXTMENU:    // disable context menu MENU_DESKBARAPP
    case WM_NCRBUTTONUP:    // disable context menu MENU_WEBBAR
        break;

    case WM_GETMINMAXINFO:  // prevent it from getting too small
        ((MINMAXINFO *)lParam)->ptMinTrackSize.x = TBWIDTH  + 10;
        ((MINMAXINFO *)lParam)->ptMinTrackSize.y = TBHEIGHT + 10;
        break;
        
    default:

        lRes = CDeskBarApp::v_WndProc(hwnd, uMsg, wParam, lParam);

        if (_hwnd) { // If our window is still alive
            switch (uMsg) {
            case WM_DISPLAYCHANGE:
                _OnDisplayChange(); // reposition when window resolution changes
                break;

            case WM_EXITSIZEMOVE:
                _PersistState();    // persist pos/size
                break;
            }
        }
    }
    
    return lRes;
}

LRESULT CALLBACK CChannelDeskBarApp::DummyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CChannelDeskBarApp* pcba = (CChannelDeskBarApp*)GetWindowPtr0(hwnd);
    
    switch (uMsg) {

        case WM_PALETTECHANGED :
            return SendMessage(pcba->_hwnd, uMsg, wParam, lParam );
            
        case WM_DISPLAYCHANGE  :
            // this message must be sent to the channel bar itself
            PostMessage(pcba->_hwnd, uMsg, wParam, lParam);
            // fall through ;
        
        case WM_WININICHANGE   :
        case WM_SYSCOLORCHANGE :
            PropagateMessage(pcba->_hwnd, uMsg, wParam, lParam, InSendMessage());
            // fall through ;
        default:
            return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }
}    

// overload CDeskBarApp::_UpdateCaptionTitle() to set title to "ChanApp"
void CChannelDeskBarApp::_UpdateCaptionTitle()
{
    SetWindowText(_hwnd, TEXT("ChanApp"));
}

// create the close button
void CChannelDeskBarApp::_CreateToolbar()
{
    _hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | 
                                WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOMOVEY | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 2, TBWIDTH, TBHEIGHT, _hwnd, 0, HINST_THISDLL, NULL);

    if (_hwndTB) {
        static const TBBUTTON tb[] =
        {
            { 1, IDM_AB_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }
        };

#ifndef UNIX
        HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                              MAKEINTRESOURCE(IDB_BROWSERTOOLBAR),
                                              13, 0, RGB(255,0,255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
#else
        HIMAGELIST himl;
        COLORREF crTextColor = GetSysColor( COLOR_BTNTEXT );
        crTextColor = MwGetTrueRGBValue( crTextColor );

        himl = ImageList_LoadImage(HINST_THISDLL,
                                   crTextColor == RGB(255,255,255) ?
                                     MAKEINTRESOURCE(IDB_WHITEBROWSERTOOLBAR) :
                                     MAKEINTRESOURCE(IDB_BROWSERTOOLBAR),
                                   13, 0, RGB(255,0,255),
                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
#endif        
        ImageList_SetBkColor(himl, RGB(0,0,0));

        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndTB, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);
        SendMessage(_hwndTB, TB_SETINDENT, (WPARAM)0, 0);

        _SizeTB();
    }    
}

HRESULT CChannelDeskBarApp::ShowDW(BOOL fShow)
{
    if (fShow && !_hwndTB) {
        _CreateToolbar();
    }
    
    HRESULT hres = CDeskBarApp::ShowDW(fShow);
    return hres;
}

void CChannelDeskBarApp::_PositionTB()
{
    // position the toolbar 
    if (_hwndTB) {
        // always put the close restore at the top right of the floater window

        RECT rc;
        RECT rcTB;
        GetClientRect(_hwnd, &rc);
        GetWindowRect(_hwndTB, &rcTB);

        rc.left = rc.right - RECTWIDTH(rcTB) - 2;
        SetWindowPos(_hwndTB, HWND_TOP, rc.left, 2, 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }
}


void CChannelDeskBarApp::_SizeTB()
{
    RECT rc;
    GetWindowRect(_hwndTB, &rc);
    LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L);
    SetWindowPos(_hwndTB, NULL, 0, 0, LOWORD(lButtonSize),
                 RECTHEIGHT(rc), SWP_NOMOVE | SWP_NOACTIVATE);
    _PositionTB();
}

void CChannelDeskBarApp::_OnSize()
{
    RECT rc, rcTB;

    if (!_hwndChild)
        return;

    ASSERT(IsWindow(_hwndChild));

    GetClientRect(_hwnd, &rc);
    if (_hwndTB) {
        GetWindowRect(_hwndTB, &rcTB);
        SetWindowPos(_hwndTB, HWND_TOP, rc.right - RECTWIDTH(rcTB) - 2, 2, 0, 0,
                     SWP_NOSIZE | SWP_NOACTIVATE);
        SetWindowPos(_hwndChild, 0, rc.left, rc.top + RECTHEIGHT(rcTB) + 3,
                     RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE|SWP_NOZORDER);
    }
    else {
        // how could there be no toolbar? 
        ASSERT(0);
        SetWindowPos(_hwndChild, 0, rc.left, rc.top + TBHEIGHT + 3,
                     RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE|SWP_NOZORDER);
    }

    rc.bottom = rc.top + TBHEIGHT + 3; 
    InvalidateRect(_hwnd, &rc, TRUE);
}

#define ABS(i)  (((i) < 0) ? -(i) : (i))

LRESULT CChannelDeskBarApp::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
    
    if (hwnd == _hwndTB) {
        switch (idCmd) {
        case IDM_AB_CLOSE:
            Exec(&CGID_DeskBarClient, DBCID_EMPTY, 0, NULL, NULL);
            break;
        }
        
    } else {
        return CDeskBarApp::_OnCommand(uMsg, wParam, lParam);
    }
    return 0;
}


BOOL CChannelDeskBarApp::_OnCloseBar(BOOL fConfirm)
{
    return CDeskBarApp::_OnCloseBar(FALSE);
}

HRESULT CChannelDeskBarApp::CloseDW(DWORD dwReserved)
{
    // close the toolbar window
    if (_hwndTB) {
        HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndTB, TB_SETIMAGELIST, 0, 0);
        ImageList_Destroy(himl);

        DestroyWindow(_hwndTB);
        _hwndTB = NULL;
    }

    if (_hwnd) {
        CDeskBarApp::CloseDW(dwReserved);
        
        // Check the active desktop is ON. If so, do not ask for the confirmation.
        // we need to kill the channel bar silently.
        if (WhichPlatform() == PLATFORM_INTEGRATED)    // SHGetSetSettings is not supported in IE3
        {
            SHELLSTATE ss = { 0 };

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
            if (ss.fDesktopHTML)  //Active desktop is ON. Die silently.
                return S_OK;
        }

        // set AutoLaunch reg value -- 
        // decide whether to launch channel bar when machine is rebooted next time 
        int iRes = MLShellMessageBox(_hwnd,
                                     MAKEINTRESOURCE(IDS_CHANBAR_SHORTCUT_MSG),
                                     MAKEINTRESOURCE(IDS_CHANBAR_SHORTCUT_TITLE),
                                     MB_YESNO | MB_SETFOREGROUND);
        ChanBarSetAutoLaunchRegValue(iRes == IDYES);
    }
    
    return S_OK;
}

// store position and size to registry
void CChannelDeskBarApp::_PersistState()
{
    if (_hwnd) {
        CISSTRUCT cis;
        cis.iVer = 1;
        GetWindowRect(_hwnd, &cis.rc);
        SHRegSetUSValue(SZ_REGKEY_CHANBAR, SZ_REGVALUE_CHANBAR, REG_BINARY, 
                        (LPVOID)&cis, sizeof(CISSTRUCT), SHREGSET_HKCU | SHREGSET_FORCE_HKCU );
    }
}



void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch)
{
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("Show_ChannelBand"), REG_SZ, 
                    fAutoLaunch ? TEXT("yes") : TEXT("no"),
                    sizeof(fAutoLaunch ? TEXT("yes") : TEXT("no")), 
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
}

//***
// NOTES
//  REARCHITECT: nuke this, fold it into CChannelDeskBarApp_CreateInstance
HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs)
{
    HRESULT hres;

    *ppunk = NULL;
    if (ppbs)
        *ppbs = NULL;
    
    CChannelDeskBarApp *pdb = new CChannelDeskBarApp();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    CBandSite *pcbs = new CBandSite(NULL);
    if (pcbs)
    {

        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            if (ppbs) {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
            
            pdb->_pbs = pcbs;
            pcbs->AddRef();
            
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    if (FAILED(hres))
    {
        pdb->Release();
    }

    return hres;
}



HRESULT CChannelDeskBarApp::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hres = CDeskBarApp::Load(pPropBag, pErrorLog);

    BANDSITEINFO bsinfo;
    bsinfo.dwMask = BSIM_STYLE;
    bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
    _pbs->SetBandSiteInfo(&bsinfo);
    
    return hres;
}

#endif  // ENABLE_CHANNELS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\chanbar.h ===
#ifndef _CHANBAR_H
#define _CHANBAR_H

#include "dbapp.h"

#define SZ_REGKEY_CHANBAR   TEXT("Software\\Microsoft\\Internet Explorer\\Channels")
#define SZ_REGVALUE_CHANBAR TEXT("window_placement")

typedef struct tagCISSTRUCT {
    UINT iVer; 
    RECT rc; 
} CISSTRUCT;

class CChannelDeskBarApp : public CDeskBarApp
{
public:
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);


    // *** IPersistPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK DummyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    virtual void _OnDisplayChange();
    virtual void _OnCreate();
    virtual void _OnSize(void);
    virtual void _UpdateCaptionTitle();
    void _CreateToolbar();
    void _PositionTB();
    void _SizeTB();
    void _PersistState();

    CChannelDeskBarApp();
    ~CChannelDeskBarApp();
    
    BOOL _OnCloseBar(BOOL fConfirm);
    
    HWND _hwndTB;
    HWND _hwndDummy; // for propagating WM_PALETTE* messages

    LONG _cxScreen, _cyScreen;   // the screen resolution

    friend HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
} ;

HRESULT ChannelDeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);
void ChanBarSetAutoLaunchRegValue(BOOL);
void DesktopChannel();


#endif // _CHANBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\bsmenu.h ===
#ifndef _BSMENU_H
#define _BSMENU_H

#include "comcatex.h"

typedef struct {
    CLSID  clsid;
    CATID  catid;
    UINT   idCmd;
    LPTSTR pszName;
    LPTSTR pszIcon;
    LPTSTR pszMenu;
    LPTSTR pszHelp;
    LPTSTR pszMenuPUI;
    LPTSTR pszHelpPUI;
} BANDCLASSINFO;

class CBandSiteMenu : 
        public IContextMenu3,
        public IShellService
{
public:
    CBandSiteMenu();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);
    
    
    // *** IContextMenu3 methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    STDMETHOD(SetOwner)(IUnknown* punk);
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plres);


    BOOL GetMergeMenu() { return (_hdpaBandClasses ? TRUE:FALSE) ; }
    int  LoadFromComCat(const CATID *pcatid);
    int  GetBandClassCount(const  CATID* pcatid, BOOL bMergedOnly );
    BANDCLASSINFO * GetBandClassDataStruct(UINT uBand);
    BOOL DeleteBandClass( REFCLSID rclsid );
    int CreateMergeMenu(HMENU hmenu, UINT cMax, UINT iPosition, UINT idCmdFirst, UINT iStart, BOOL fMungeAllowed = TRUE);

protected:
    ~CBandSiteMenu();
    
    HDPA _hdpaBandClasses; // what bands are insertable here?
    int _idCmdEnumFirst;    // this is in EXTERNAL units
    UINT _idCmdFirst;
    UINT _cRef;
    IBandSite* _pbs;
    
    static int _DPA_FreeBandClassInfo(LPVOID p, LPVOID d);
    
    BOOL _CheckUnique(IDeskBand* pdb, HMENU hmenu) ;
    HRESULT _GetBandIdentifiers(IUnknown *punk, CLSID* pcslid, DWORD* pdwPrivID);
    void _AddNewFSBand(LPCITEMIDLIST pidl, BOOL fNoTitle, DWORD dwPrivID);
    void _ToggleSpecialFolderBand(int i, LPTSTR pszSubPath, BOOL fNoTitle);
    void _BrowseForNewFolderBand();
    void _ToggleComcatBand(UINT idCmd);
    void _AddEnumMenu(HMENU hmenu, int iInsert);

    static HRESULT _BandClassEnum(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam);

    HRESULT _FindBand(const CLSID* pclsid, DWORD dwPrivID, DWORD* pdwBandID);

    UINT _IDToInternal(UINT uID);
    UINT _IDToExternal(UINT uID);

    LRESULT _OnInitMenuPopup(HMENU hmenu, UINT uPos);

    void _PopulateSubmenu(HMENU hmenuSub);
};

#endif  // _BSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\comcatex.cpp ===
#include "priv.h"
#include "comcatex.h"
#include "runtask.h"


//------------------//
//  Misc constants
static LPCTSTR
#ifdef _WIN64
    REGKEY_COMCATEX              = STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories64"),
#else
    REGKEY_COMCATEX              = STRREG_DISCARDABLE STRREG_POSTSETUP TEXT("\\Component Categories"),
#endif
    REGKEY_COMCATEX_ENUM         = TEXT("Enum"),        // HKCR\ComponentClasses\{catid}\Enum
    REGVAL_COMCATEX_IMPLEMENTING = TEXT("Implementing"),// HKCR\ComponentClasses\{catid}\Enum\Implementing
    REGVAL_COMCATEX_REQUIRING    = TEXT("Requiring");   // HKCR\ComponentClasses\{catid}\Enum\Requiring

static const ULONG 
    COMCAT_CACHE_CURRENTVERSION = MAKELONG(1,0); // current cache version.

//-------------//
//  Cache header
typedef struct {
    ULONG       cbStruct;      // structure size
    ULONG       ver;           // version string (COMCAT_CACHE_CURRENTVERSION)
    SYSTEMTIME  stLastUpdate;  // UTC date, time of last update.
    ULONG       cClsid;        // number of CLSIDs to follow
    CLSID       clsid[];       // array of CLSIDs
} COMCAT_CACHE_HEADER;

//----------------//
//  Impl helpers
STDMETHODIMP _EnumerateGuids( IN IEnumGUID* pEnumGUID, OUT HDSA* phdsa );
STDMETHODIMP _ComCatCacheFromDSA( IN HDSA hdsa, OUT LPBYTE* pBuf, OUT LPDWORD pcbBuf );
STDMETHODIMP _DSAFromComCatCache( IN LPBYTE pBuf, IN ULONG cbBuf, OUT HDSA* phdsa );
STDMETHODIMP _MakeComCatCacheKey( IN REFCATID refcatid, OUT LPTSTR pszKey, IN ULONG cchKey );
STDMETHODIMP _ReadClassesOfCategory( IN REFCATID refcatid, OUT HDSA* phdsa, LPCTSTR pszRegValueName );
STDMETHODIMP _WriteImplementingClassesOfCategory( IN REFCATID refcatid, IN HDSA hdsa );
STDMETHODIMP _WriteRequiringClassesOfCategory( IN REFCATID refcatid, IN HDSA hdsa );
STDMETHODIMP _WriteClassesOfCategories( IN ULONG, IN CATID [], IN ULONG, IN CATID [], BOOL );
STDMETHODIMP _BuildCacheIfNecessary( IN REFCATID refcatid, BOOL fImplementing);
STDAPI       _CComCatCache_CommonCreateInstance( BOOL, OUT void**);

//-----------------------//
//  Higher-level methods
STDMETHODIMP SHReadImplementingClassesOfCategory( REFCATID refcatid, OUT HDSA* phdsa );
STDMETHODIMP SHReadRequiringClassesOfCategory( REFCATID refcatid, OUT HDSA* phdsa );
STDMETHODIMP SHWriteImplementingClassesOfCategory( REFCATID refcatid );
STDMETHODIMP SHWriteRequiringClassesOfCategory( REFCATID refcatid );

#define SAFE_DESTROY_CLSID_DSA(hdsa) \
    if((hdsa)) { DSA_Destroy((hdsa)); (hdsa)=NULL; }

//-------------------------------------------------------------------------//
//  Cache-aware component categories enumerator object
class CSHEnumClassesOfCategories : public IEnumGUID
//-------------------------------------------------------------------------//
{
public:
    //  IUnknown methods
    STDMETHOD_ (ULONG, AddRef)()    { 
        return InterlockedIncrement( &_cRef );
    }
    STDMETHOD_ (ULONG, Release)()   { 
        if( InterlockedDecrement( &_cRef )==0 ) {
            delete this; return 0;
        }
        return _cRef; 
    }
    STDMETHOD  (QueryInterface)( REFIID riid, void **ppvObj);

    //  IEnum methods
    STDMETHOD (Next)( ULONG celt, GUID* rgelt, ULONG* pceltFetched );
    STDMETHOD (Skip)( ULONG celt );
    STDMETHOD (Reset)();
    STDMETHOD (Clone)( IEnumGUID ** ppenum );

protected:
    CSHEnumClassesOfCategories();
    virtual ~CSHEnumClassesOfCategories();

    STDMETHOD (Initialize)( ULONG cImpl, CATID rgcatidImpl[], ULONG cReq, CATID rgcatidReq[]); 
        // invoke immediately after construction for arg validation.
    
    LONG      _cRef,        // ref count
              _iEnum;      // enumerator index
    HDSA      _hdsa;       // CLSID DSA handle

    ULONG     _cImpl,        // count of catids to enumerate for implementing classes
              _cReq;        // count of catids to enumerate for requiring classes
    CATID     *_rgcatidImpl, // catids to enumerate for implementing classes
              *_rgcatidReq; // catids to enumerate for requiring classes
              
    friend STDMETHODIMP SHEnumClassesOfCategories( ULONG, CATID[], ULONG, CATID[], IEnumGUID**);
};

//-------------------------------------------------------------------------//
//  IRunnableTask derivative for asynchronous update of 
//  component categories cache.
class CComCatCacheTask : public CRunnableTask
//-------------------------------------------------------------------------//
{
public:
    CComCatCacheTask();
    virtual ~CComCatCacheTask();

    STDMETHOD   (Initialize)( ULONG cImplemented,
                              CATID rgcatidImpl[],
                              ULONG cRequired,
                              CATID rgcatidReq[],
                              BOOL  bForceUpdate,
                              HANDLE hEvent );

    STDMETHOD   (Go)();

protected:
    STDMETHOD   (RunInitRT)()
    {
        HRESULT hr = _WriteClassesOfCategories( _cImpl, _rgcatidImpl,
                                          _cReq, _rgcatidReq, _bForceUpdate );
        if (_hEvent)
            SetEvent(_hEvent);
        return hr;
    }

    ULONG _cImpl, _cReq;
    CATID *_rgcatidImpl,
          *_rgcatidReq;
    BOOL  _bForceUpdate;
    HANDLE _hEvent;

    friend HRESULT _CComCatCache_CommonCreateInstance( BOOL, OUT void**);
};

//-------------------------------------------------------------------------//
//  Entrypoint: retrieves cache-aware enumerator over classes which require or 
//  implement the specified component catagory(ies).
STDMETHODIMP SHEnumClassesOfCategories(
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],        //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],         //Array of category identifiers
      IEnumGUID** ppenumGUID )  //Location in which to return an IEnumGUID interface
{
    HRESULT hr = S_OK;
    CSHEnumClassesOfCategories* pEnum = NULL;
    
    if( NULL == ppenumGUID )
        return E_INVALIDARG;

    *ppenumGUID = NULL;

    //  Construct and initialize enumerator object
    if( NULL == (pEnum = new CSHEnumClassesOfCategories) )
        return E_OUTOFMEMORY;

    if( FAILED( (hr = pEnum->Initialize( 
                    cImplemented, rgcatidImpl, cRequired, rgcatidReq )) ) )
    {
        pEnum->Release();
        return hr;
    }

    *ppenumGUID = pEnum;
    return hr;
}

//-------------------------------------------------------------------------//
//  Determines whether a cache exists for the indicated CATID.
//  If bImplementing is TRUE, the function checks for a cache of
//  implementing classes; otherwise the function checks for a cache of
//  requiring classes.
STDMETHODIMP SHDoesComCatCacheExist( REFCATID refcatid, BOOL bImplementing )
{
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY  hkeyCache;
        
        DWORD dwRet = RegOpenKeyEx( HKEY_CURRENT_USER, szKey, 0L, KEY_READ, &hkeyCache );
        hr = S_FALSE;

        if( ERROR_SUCCESS == dwRet )
        {
            DWORD   dwType, cbData = 0;

            dwRet = RegQueryValueEx( hkeyCache, 
                                     bImplementing ? REGVAL_COMCATEX_IMPLEMENTING : 
                                                     REGVAL_COMCATEX_REQUIRING,
                                     0L, &dwType, NULL, &cbData );

            //  We'll confirm only on value type and size of data.
            if( ERROR_SUCCESS == dwRet && 
                dwType == REG_BINARY &&  
                sizeof(COMCAT_CACHE_HEADER) <= cbData )
            {
                hr = S_OK;
            }

            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Entrypoint: Caches implementing and requiring classes for the 
//  specified categories with asynchronous option.
STDMETHODIMP SHWriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate,       // TRUE: Unconditionally update the cache; FALSE: create cache iif doesn't exist.
      BOOL  bWait,              //If FALSE, the function returns immediately and the
                                //   caching occurs asynchronously; otherwise
                                //   the function returns only after the caching
                                //   operation has completed.
      HANDLE hEvent             //(optional) Event to be signalled when cache update is done
)
{
    HRESULT hr;

    if( bWait )
    {
        //  Synchronous update
        hr = _WriteClassesOfCategories( cImplemented, rgcatidImpl, cRequired, rgcatidReq, bForceUpdate );
        if (hEvent)
            SetEvent(hEvent);
    }
    else
    {
        //  Asynchronous update
        CComCatCacheTask* pTask = new CComCatCacheTask();
        if (pTask)
        {
            //  Initialize with caller's args:
            if( SUCCEEDED( (hr = pTask->Initialize( 
                    cImplemented, rgcatidImpl, cRequired, rgcatidReq, bForceUpdate, hEvent )) ) )
            {
                hr = pTask->Go();
            }
        
            pTask->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  CSHEnumClassesOfCategories class implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
inline CSHEnumClassesOfCategories::CSHEnumClassesOfCategories()
    :   _cImpl(0), _rgcatidImpl(NULL),
        _cReq(0), _rgcatidReq(NULL),
        _cRef(1),  _iEnum(0), _hdsa(NULL)
{
    DllAddRef();
}

//-------------------------------------------------------------------------//
CSHEnumClassesOfCategories::~CSHEnumClassesOfCategories()
{
    delete [] _rgcatidImpl;
    delete [] _rgcatidReq;
    SAFE_DESTROY_CLSID_DSA( _hdsa );
    DllRelease();
}

//-------------------------------------------------------------------------//
STDMETHODIMP CSHEnumClassesOfCategories::QueryInterface( REFIID riid, void **ppvObj )
{
    static const QITAB qit[] = {
        QITABENT(CSHEnumClassesOfCategories, IEnumGUID),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

//-------------------------------------------------------------------------//
STDMETHODIMP CSHEnumClassesOfCategories::Initialize(
    ULONG cImplemented, 
    CATID rgcatidImpl[], 
    ULONG cRequired, 
    CATID rgcatidReq[]
)
{
    //  Disallow multiple initialization.
    if( _hdsa || _rgcatidImpl || _rgcatidReq )
        return S_FALSE;
    
    //  Superficial arg validation:
    if( (0==cImplemented && 0==cRequired) ||
        (cImplemented && NULL == rgcatidImpl) ||
        (cRequired && NULL == rgcatidReq) )
    {
        return E_INVALIDARG;
    }

    //  Allocate and make copies of CATID arrays
    if( cImplemented )
    {
        if( NULL == (_rgcatidImpl = new CATID[cImplemented]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidImpl, rgcatidImpl, sizeof(CATID) * cImplemented );
    }
    _cImpl = cImplemented;

    if( cRequired )
    {
        if( NULL == (_rgcatidReq = new CATID[cRequired]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidReq, rgcatidReq, sizeof(CATID) * cRequired );
    }
    _cReq = cRequired;

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Iterates implementing and/or requiring classes for the caller-specified
//  component categories.
STDMETHODIMP CSHEnumClassesOfCategories::Next( 
    ULONG celt, 
    GUID* rgelt, 
    ULONG* pceltFetched )
{
    if( pceltFetched )
        *pceltFetched = 0;
    
    HRESULT hr = S_FALSE;
    ULONG celtFetched = 0;

    //  Have we assembled our collection?
    if( NULL == _hdsa )
    {
        _iEnum = 0;

        ULONG i;
        for( i=0; SUCCEEDED( hr ) && i < _cImpl; i++ )
        {
            //  Try reading implementing classes from cache
            if( FAILED( (hr = SHReadImplementingClassesOfCategory( _rgcatidImpl[i], &_hdsa )) ) )
            {
                //  Uncached; try caching and then re-read.
                if( FAILED( (hr = SHWriteImplementingClassesOfCategory( _rgcatidImpl[i] )) ) ||
                    FAILED( (hr = SHReadImplementingClassesOfCategory( _rgcatidImpl[i], &_hdsa )) ) )
                    break;
            }
        }

        for( i=0; SUCCEEDED( hr ) && i < _cReq; i++ )
        {
            //  Try reading requiring classes from cache
            if( FAILED( (hr = SHReadRequiringClassesOfCategory( _rgcatidReq[i], &_hdsa )) ) )
            {
                //  Uncached; try caching and then re-read.
                if( FAILED( (hr = SHWriteRequiringClassesOfCategory( _rgcatidReq[i] )) ) ||
                    FAILED( (hr = SHReadRequiringClassesOfCategory( _rgcatidReq[i], &_hdsa )) ) )
                    break;
            }
        }
    }

    if( NULL != _hdsa )
    {
        LONG count = DSA_GetItemCount( _hdsa );
        while( celtFetched < celt && _iEnum < count  )
        {
            if( DSA_GetItem( _hdsa, _iEnum, &rgelt[celtFetched] ) )
                celtFetched++;

            _iEnum++;
        }

        return celtFetched == celt ? S_OK : S_FALSE;
    }

    return SUCCEEDED( hr ) ? S_FALSE : hr;
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Skip( ULONG celt )      
{ 
    InterlockedExchange( &_iEnum, _iEnum + celt );
    return S_OK; 
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Reset( void )      
{ 
    InterlockedExchange( &_iEnum, 0 );
    return S_OK; 
}

//-------------------------------------------------------------------------//
inline STDMETHODIMP CSHEnumClassesOfCategories::Clone( IEnumGUID ** ppenum )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------//
//  CComCatCacheTask class implementation
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDAPI CComCatConditionalCacheTask_CreateInstance( IN IUnknown*, OUT void** ppOut, LPCOBJECTINFO )
{
    return _CComCatCache_CommonCreateInstance( FALSE /* iif not exists */, ppOut );
}

//-------------------------------------------------------------------------//
STDAPI CComCatCacheTask_CreateInstance( IN IUnknown*, OUT void** ppOut, LPCOBJECTINFO poi )
{
    return _CComCatCache_CommonCreateInstance( TRUE /* unconditionally update */, ppOut );
}

//-------------------------------------------------------------------------//
STDAPI _CComCatCache_CommonCreateInstance( 
    BOOL bForceUpdate, 
    OUT void** ppOut )
{
    CComCatCacheTask* pTask;
    if( NULL == (pTask = new CComCatCacheTask) )
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    //  We're being CoCreated without args, so we'll use
    //  a hard-coded list of likely suspects (catids) to cache.
    static CATID rgcatid[2];
    rgcatid[0] = CATID_InfoBand;
    rgcatid[1] = CATID_CommBand;
    if( FAILED( (hr = pTask->Initialize( ARRAYSIZE(rgcatid), rgcatid, 0, NULL, bForceUpdate, NULL )) ) )
    {
        pTask->Release();
        return hr;
    }

    *ppOut = SAFECAST( pTask, IRunnableTask*);
    return hr;
}

//-------------------------------------------------------------------------//
inline CComCatCacheTask::CComCatCacheTask()
    :  CRunnableTask( RTF_DEFAULT ), 
       _cImpl(0), _cReq(0), _rgcatidImpl(NULL), _rgcatidReq(NULL), _bForceUpdate(TRUE)
{
}

//-------------------------------------------------------------------------//
inline CComCatCacheTask::~CComCatCacheTask()
{
    delete [] _rgcatidImpl;
    delete [] _rgcatidReq;
    if (_hEvent)
        CloseHandle(_hEvent);
}

//-------------------------------------------------------------------------//
STDMETHODIMP CComCatCacheTask::Initialize(
    ULONG cImplemented,
    CATID rgcatidImpl[],
    ULONG cRequired,
    CATID rgcatidReq[],
    BOOL  bForceUpdate,
    HANDLE hEvent)
{
    //  Superficial arg validation:
    if( (0==cImplemented && 0==cRequired) ||
        (cImplemented && NULL == rgcatidImpl) ||
        (cRequired && NULL == rgcatidReq) )
    {
        return E_INVALIDARG;
    }

    //  Disallow multiple initialization.
    if( _rgcatidImpl || _rgcatidReq )
        return S_FALSE;

    //  Allocate and make copies of CATID arrays
    if( cImplemented )
    {
        if( NULL == (_rgcatidImpl = new CATID[cImplemented]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidImpl, rgcatidImpl, sizeof(CATID) * cImplemented );
    }
    _cImpl = cImplemented;

    if( cRequired )
    {
        if( NULL == (_rgcatidReq = new CATID[cRequired]) )
            return E_OUTOFMEMORY;
        CopyMemory( _rgcatidReq, rgcatidReq, sizeof(CATID) * cRequired );
    }
    _cReq = cRequired;

    _bForceUpdate = bForceUpdate;

    if (hEvent)
    {
        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess, hEvent, hProcess, &_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS);
    }

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Initiates asynchronous update of component categories cache.
STDMETHODIMP CComCatCacheTask::Go()
{
    //  Run the task from the shared thread pool
    IShellTaskScheduler* pScheduler;
    HRESULT hr = CoCreateInstance( CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, 
                                   IID_IShellTaskScheduler, (LPVOID*)&pScheduler );

    if( SUCCEEDED( hr ) )
    {
        hr = pScheduler->AddTask( this, CLSID_ComCatCacheTask, 0L, ITSAT_DEFAULT_PRIORITY );
        
        // heap alloc'd memory belongs to scheduler thread.
        pScheduler->Release(); // OK to release shared scheduler before task has completed.
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Component cache implementation
//-------------------------------------------------------------------------//

STDMETHODIMP _BuildCacheIfNecessary(
    IN REFCATID refcatid, 
    BOOL fImplementing)
{
    HRESULT hr = S_OK;

    if (S_OK != SHDoesComCatCacheExist(refcatid, fImplementing))
    {
        hr = fImplementing ? SHWriteImplementingClassesOfCategory(refcatid)
                           : SHWriteRequiringClassesOfCategory(refcatid);
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Reads a series of CLSIDs from a registry-based cache of
//  implementing classes for the specified component category into a DSA.
//  If the DSA is NULL, a new DSA is created; otherwise the CLSIDS are appended to
//  the provided DSA.
inline STDMETHODIMP SHReadImplementingClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa )
{
    HRESULT hr = _BuildCacheIfNecessary(refcatid, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = _ReadClassesOfCategory( refcatid, phdsa, REGVAL_COMCATEX_IMPLEMENTING );
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Reads a series of CLSIDs from a registry-based cache of
//  requiring classes for the specified component category into a DSA.
//  If the DSA is NULL, a new DSA is created; otherwise the CLSIDS are appended to
//  the provided DSA.
inline STDMETHODIMP SHReadRequiringClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa )
{
    HRESULT hr = _BuildCacheIfNecessary(refcatid, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = _ReadClassesOfCategory( refcatid, phdsa, REGVAL_COMCATEX_REQUIRING );
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Caches a list of classes which implement the indicated component category.
STDMETHODIMP SHWriteImplementingClassesOfCategory( IN REFCATID refcatid )
{
    HRESULT hr;
    
    //  Retrieve OLE component category manager
    ICatInformation* pci;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_StdComponentCategoriesMgr, 
                                           NULL, CLSCTX_INPROC_SERVER, 
                                           IID_ICatInformation, (LPVOID*)&pci)) ) )
    {
        //  Retrieve enumerator over classes that implement the category
        IEnumGUID* pEnumGUID;
        if( SUCCEEDED( (hr = pci->EnumClassesOfCategories( 1, (CATID*)&refcatid, 
                                                           0, NULL, &pEnumGUID )) ) )
        {
            HDSA  hdsa = NULL;
            if( SUCCEEDED( (hr = _EnumerateGuids( pEnumGUID, &hdsa )) ) )
            {
                //  Write to cache
                hr = _WriteImplementingClassesOfCategory( refcatid, hdsa );
                SAFE_DESTROY_CLSID_DSA( hdsa );
            }
            pEnumGUID->Release();
        }
        pci->Release();
    }        
    return hr;
}

//-------------------------------------------------------------------------//
//  Caches a list of classes which require the indicated component category.
STDMETHODIMP SHWriteRequiringClassesOfCategory( IN REFCATID refcatid )
{
    HRESULT hr;
    
    //  Retrieve OLE component category manager
    ICatInformation* pci;
    if( SUCCEEDED( (hr = CoCreateInstance( CLSID_StdComponentCategoriesMgr, 
                                           NULL, CLSCTX_INPROC_SERVER, 
                                           IID_ICatInformation, (LPVOID*)&pci)) ) )
    {
        //  Retrieve enumerator over classes that require the category
        IEnumGUID* pEnumGUID;
        if( SUCCEEDED( (hr = pci->EnumClassesOfCategories( 0, NULL, 1, 
                                                           (CLSID*)&refcatid, 
                                                           &pEnumGUID )) ) )
        {
            HDSA  hdsa = NULL;
            if( SUCCEEDED( (hr = _EnumerateGuids( pEnumGUID, &hdsa )) ) )
            {
                //  Write to cache
                hr = _WriteRequiringClassesOfCategory( refcatid, hdsa );
                SAFE_DESTROY_CLSID_DSA( hdsa );
            }
            pEnumGUID->Release();
        }
        pci->Release();
    }        
    return hr;
}

//-------------------------------------------------------------------------//
//  Accepts a valid GUID enumerator and constructs an HDSA containing the GUIDS.
//  The caller is responsible for freeing the HDSA which may or may not
//  have been allocated.
STDMETHODIMP _EnumerateGuids( IEnumGUID* pEnumGUID, OUT HDSA* phdsa )
{
    ASSERT( pEnumGUID );
    ASSERT( phdsa );
    
    ULONG   celtFetched;
    CLSID   clsid;
    HRESULT hr;

    while( SUCCEEDED( (hr = pEnumGUID->Next( 1, &clsid, &celtFetched )) ) &&
           celtFetched > 0 )
    {
        if( NULL == *phdsa &&
            NULL == (*phdsa = DSA_Create( sizeof(CLSID), 4 )) )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        DSA_AppendItem( *phdsa, &clsid );
    }

    // translate S_FALSE.
    return SUCCEEDED( hr ) ? S_OK : hr;
}     

//-------------------------------------------------------------------------//
//  Generates a persistable cache of CLSIDs derived from the CLSID* DSA.
STDMETHODIMP _ComCatCacheFromDSA( IN HDSA hdsa, OUT LPBYTE* pBuf, OUT LPDWORD pcbBuf )
{
    ASSERT( pBuf );
    ASSERT( pcbBuf );

    ULONG   cClsid = hdsa ? DSA_GetItemCount( hdsa ) : 0,
            cbBuf = sizeof(COMCAT_CACHE_HEADER) + (cClsid * sizeof(CLSID));
    HRESULT hr = S_OK;

    //  Allocate blob
    *pcbBuf = 0;
    if( NULL != (*pBuf = new BYTE[cbBuf]) )
    {
        //  Initialize header
        COMCAT_CACHE_HEADER* pCache = (COMCAT_CACHE_HEADER*)(*pBuf);
        pCache->cbStruct = sizeof(*pCache);
        pCache->ver      = COMCAT_CACHE_CURRENTVERSION;
        pCache->cClsid   = 0;
        GetSystemTime( &pCache->stLastUpdate );

        //  Copy CLSIDs
        for( ULONG i = 0; i< cClsid; i++ )
            DSA_GetItem( hdsa, i, &pCache->clsid[pCache->cClsid++] );

        //  Adjust output size.
        *pcbBuf = sizeof(*pCache) + (pCache->cClsid * sizeof(CLSID));
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//-------------------------------------------------------------------------//
//  Appends CLSIDS from the cache buffer to the specified DSA.  If the DSA is
//  NULL, a new DSA is created.
STDMETHODIMP _DSAFromComCatCache( IN LPBYTE pBuf, IN ULONG cbBuf, OUT HDSA* phdsa )
{
    ASSERT( pBuf );
    ASSERT( phdsa );

    HRESULT hr = S_OK;
    COMCAT_CACHE_HEADER* pCache = (COMCAT_CACHE_HEADER*)pBuf;

    //  Validate header
    if( !( sizeof(*pCache) <= cbBuf && 
           sizeof(*pCache) == pCache->cbStruct &&
           COMCAT_CACHE_CURRENTVERSION == pCache->ver ) )
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    //  Create the DSA if necessary
    if( 0 == pCache->cClsid )
        return S_FALSE;

    if( NULL == *phdsa && NULL == (*phdsa = DSA_Create( sizeof(CLSID), 4 )) )
        return E_OUTOFMEMORY;

    //  Copy CLSIDs from the cache to the DSA.
    for( ULONG i = 0; i< pCache->cClsid; i++ )
        DSA_AppendItem( *phdsa, &pCache->clsid[i] );

    return hr;
}

//-------------------------------------------------------------------------//
//  Constructs a component category registry cache key based on the 
//  specified CATID.
STDMETHODIMP _MakeComCatCacheKey( 
    IN REFCATID refcatid, 
    OUT LPTSTR pszKey, 
    IN ULONG cchKey )
{
    TCHAR szCLSID[GUIDSTR_MAX];
    
    if( SHStringFromGUID( refcatid, szCLSID, ARRAYSIZE(szCLSID) )<=0 )
        return E_INVALIDARG;

    ASSERT( cchKey > (ULONG)(lstrlen( REGKEY_COMCATEX ) + GUIDSTR_MAX) );

    //  "Component Categories\{clsid}\Enum"
    if( wnsprintf( pszKey, cchKey, TEXT("%s\\%s\\%s"),
                   REGKEY_COMCATEX, szCLSID, REGKEY_COMCATEX_ENUM ) > 0 )
        return S_OK;

    return E_FAIL;
}

//-------------------------------------------------------------------------//
//  Reads a cache of implementing or requiring classes info a CLSID DSA.
STDMETHODIMP _ReadClassesOfCategory( 
    IN REFCATID refcatid, 
    OUT HDSA* phdsa, 
    LPCTSTR pszRegValueName /*REGVAL_COMCATEX_IMPLEMENTING/REQUIRING*/ )
{
    TCHAR szKey[MAX_PATH];
    HRESULT hr;
    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        DWORD dwRet = RegOpenKeyEx( HKEY_CURRENT_USER, szKey, 0L, KEY_READ, &hkeyCache );
        hr = HRESULT_FROM_WIN32( dwRet );

        if( SUCCEEDED( hr ) )
        {
            //  Determine required buffer size.
            LPBYTE  pBuf = NULL;
            ULONG   cbBuf = 0,
                    dwType,
                    dwRet = RegQueryValueEx( hkeyCache, pszRegValueName, 0L,
                                             &dwType, NULL, &cbBuf );

            hr = HRESULT_FROM_WIN32( dwRet );

            if (SUCCEEDED(hr))
            {
                //  Allocate buffer and read
                if( NULL != (pBuf = new BYTE[cbBuf]) )
                {
                    dwRet = RegQueryValueEx( hkeyCache, pszRegValueName, 0L,
                                             &dwType, pBuf, &cbBuf );
                    hr = HRESULT_FROM_WIN32( dwRet );
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            if( SUCCEEDED( hr ) )
            {
                //  Gather CLSIDs into the DSA
                hr = REG_BINARY == dwType ? 
                     _DSAFromComCatCache( pBuf, cbBuf, phdsa ) : E_ABORT;
            }
                
            if( pBuf ) delete [] pBuf;
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Writes a series of CLSIDs from a DSA to a registry-based cache of
//  implementing classes for the specified component category.
STDMETHODIMP _WriteImplementingClassesOfCategory( 
    IN REFCATID refcatid, 
    IN HDSA hdsa )
{
    
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        ULONG dwRet, dwDisposition;

        dwRet = RegCreateKeyEx( HKEY_CURRENT_USER, szKey, 0L, 
                                NULL, 0L, KEY_WRITE, NULL,
                                &hkeyCache, &dwDisposition );
        hr = HRESULT_FROM_WIN32( dwRet );

        if( SUCCEEDED( hr ) )
        {
            //  Construct a blob containing cache data.
            LPBYTE pBuf;
            ULONG  cbBuf;
            if( SUCCEEDED( (hr = _ComCatCacheFromDSA( hdsa, &pBuf, &cbBuf )) ) )
            {
                //  Write it to 'Implementing' reg value
                hr = RegSetValueEx( hkeyCache, REGVAL_COMCATEX_IMPLEMENTING, 0L,
                                    REG_BINARY, pBuf, cbBuf );
                if( pBuf )
                    delete [] pBuf;
            }
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Writes a series of CLSIDs from a DSA to a registry-based cache of
//  requiring classes for the specified component category.
STDMETHODIMP _WriteRequiringClassesOfCategory( 
    IN REFCATID refcatid, 
    IN HDSA hdsa )
{
    
    TCHAR szKey[MAX_PATH];
    HRESULT hr;

    //  Create/Open key HKCR\Component Categories\{catid}\Enum
    if( SUCCEEDED( (hr = _MakeComCatCacheKey( refcatid, szKey, ARRAYSIZE(szKey) )) ) )
    {
        HKEY hkeyCache = NULL;
        ULONG dwRet, 
              dwDisposition;

        dwRet = RegCreateKeyEx( HKEY_CURRENT_USER, szKey, 0L, 
                                NULL, 0L, KEY_WRITE, NULL,
                                &hkeyCache, &dwDisposition );
        hr = HRESULT_FROM_WIN32( dwRet ); 

        if( SUCCEEDED( hr ) )
        {
            //  Construct a blob containing cache data.
            LPBYTE pBuf;
            ULONG  cbBuf;
            if( SUCCEEDED( (hr = _ComCatCacheFromDSA( hdsa, &pBuf, &cbBuf )) ) )
            {
                //  Write it to 'Requirng' reg value
                hr = RegSetValueEx( hkeyCache, REGVAL_COMCATEX_REQUIRING, 0L,
                                    REG_BINARY, pBuf, cbBuf );
                if( pBuf )
                    delete [] pBuf;
            }
            RegCloseKey( hkeyCache );
        }
    }
    return hr;
}

//-------------------------------------------------------------------------//
//  Does work of caching implementing and requiring classes for the specified categories
STDMETHODIMP _WriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate )      //TRUE: unconditionally update the cache; otherwise
                                // update iif the cache doesn't exist.
{
    HRESULT hr = S_OK;
    ULONG   i;

    //  Cache implementing classes of each category.
    for( i = 0; i< cImplemented; i++ )
    {
        if( bForceUpdate || S_OK != SHDoesComCatCacheExist( rgcatidImpl[i], TRUE ) )
        {
            HRESULT hrCatid;
            if( FAILED( (hrCatid = SHWriteImplementingClassesOfCategory( rgcatidImpl[i] )) ) )
                hr = hrCatid;
        }
    }

    //  Cache requiring classes of each category.
    for( i = 0; i< cRequired; i++ )
    {
        if( bForceUpdate || S_OK != SHDoesComCatCacheExist( rgcatidReq[i], FALSE ) )
        {
            HRESULT hrCatid;
            if( FAILED( (hrCatid = SHWriteRequiringClassesOfCategory( rgcatidReq[i] )) ) )
                hr = hrCatid;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\cwndproc.cpp ===
#include "priv.h"
#include "..\inc\cwndproc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\comcatex.h ===
#ifndef __COMCATEX_H__
#define __COMCATEX_H__

#include <comcat.h>

//-------------------------------------------------------------------------//
//  Retrieves cache-aware enumerator over classes which require or 
//  implement the specified component catagory(ies).
//  See docs on ICatInformation::EnumClassesOfCategories() for more information
//  on arguments and usage.
STDMETHODIMP SHEnumClassesOfCategories(
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      IEnumGUID** ppenumGUID ) ;//Address to receive a pointer to an IEnumGUID interface

//-------------------------------------------------------------------------//
//  Determines whether a cache exists for the indicated CATID.
//  If bImplementing is TRUE, the function checks for a cache of
//  implementing classes; otherwise the function checks for a cache of
//  requiring classes.  Returns S_OK if the cache exists, S_FALSE if
//  it does not exist, or an error indicating a failure occurred.
STDMETHODIMP SHDoesComCatCacheExist( REFCATID refcatid, BOOL bImplementing ) ;

//-------------------------------------------------------------------------//
//  Caches implementing and/or requiring classes for the specified categories
//  See docs on ICatInformation::EnumClassesOfCategories() for more information
//  on arguments.
STDMETHODIMP SHWriteClassesOfCategories( 
      ULONG cImplemented,       //Number of category IDs in the rgcatidImpl array
      CATID rgcatidImpl[],      //Array of category identifiers
      ULONG cRequired,          //Number of category IDs in the rgcatidReq array
      CATID rgcatidReq[],       //Array of category identifiers
      BOOL  bForceUpdate,       //TRUE: Unconditionally update the cache; 
                                //otherwise create cache iif doesn't exist.
      BOOL  bWait,              //If FALSE, the function returns immediately and the
                                //   caching occurs asynchronously; otherwise
                                //   the function returns only after the caching
                                //   operation has completed.
      HANDLE hEvent ) ;         //(optional) Event to be signalled when cache update is done

#endif __COMCATEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\commonsb.cpp ===
#include "priv.h"

#include "sccls.h"

#include "resource.h"

#include "commonsb.h"
#include "dockbar.h"        // for DRAG_MOVE etc.

#include "mluisupp.h"

#define DM_HTTPEQUIV        TF_SHDNAVIGATE
#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   TF_SHDNAVIGATE
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_PERSIST          0       // trace IPS::Load, ::Save, etc.
#define DM_VIEWSTREAM       DM_TRACE
#define DM_FOCUS            0
#define DM_FOCUS2           0           // like DM_FOCUS, but verbose
#define DM_ACCELERATOR      0
#define TF_PERF             TF_CUSTOM2
#define DM_MISC             DM_TRACE    // misc/tmp stuff

PZONEICONNAMECACHE g_pZoneIconNameCache = NULL;
DWORD g_dwZoneCount = 0;

//***   create, ctor/init/dtor, QI/AddRef/Release {

// So CDesktopBrowser can access us...
HRESULT CCommonBrowser_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CCommonBrowser *pcb = new CCommonBrowser(punkOuter);
    if (pcb)
    {
        *ppunk = pcb->_GetInner();
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

CCommonBrowser::CCommonBrowser(IUnknown* punkAgg) :
   CAggregatedUnknown(punkAgg)
{
    // cache "out" pointers
    _QueryOuterInterface(IID_PPV_ARG(IBrowserService2, &_pbsOuter));

    // warning: can't call SUPER/_psbInner until _Initialize has been called
    // (since that's what does the aggregation)
}

HRESULT CCommonBrowser::_Initialize(HWND hwnd, IUnknown *pauto)
{
    //  I hope we have an IBrowserService2 to talk to.
    if (!_pbsOuter) 
    {
        return E_FAIL;
    }

    IUnknown* punk;
    HRESULT hr = CoCreateInstance(CLSID_CBaseBrowser, SAFECAST(this, IShellBrowser*), CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr)) 
    {
        hr = SetInner(punk);  // paired w/ Release in outer (TBS::Release)
        if (EVAL(SUCCEEDED(hr))) 
        {
            hr = _pbsInner->_Initialize(hwnd, pauto);
        }
    }

    EVAL(FDSA_Initialize(sizeof(TOOLBARITEM), ITB_CGROW, &_fdsaTBar, _aTBar, ITB_CSTATIC));

    return hr;
}

CCommonBrowser::~CCommonBrowser()
{
    // First, release outer interfaces, since the
    // outer object is in the process of destroying itself.
    RELEASEOUTERINTERFACE(_pbsOuter);
    RELEASEOUTERINTERFACE(_pbsOuter3);

    // Second, release the inner guy so it knows to clean up
    // Note: this should come third, but the inner guy's cached
    // outer interfaces are already dead (they point to our
    // aggregator) and we don't have the compiler to fix up
    // the vtables for us...
    // (I have no idea what that comment means -raymondc)
    RELEASEINNERINTERFACE(_GetOuter(), _pbsInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pbsInner3);
    RELEASEINNERINTERFACE(_GetOuter(), _psbInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pdtInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pspInner);
    RELEASEINNERINTERFACE(_GetOuter(), _pctInner);
    RELEASEINNERINTERFACE(_GetOuter(), _piosInner);   // FEATURE: split: nuke this

    // _punkInner goes last because it is the one that really destroys
    // the inner.
    ATOMICRELEASE(_punkInner);   // paired w/ CCI aggregation
    
    // Last, clean up our stuff. Better make sure
    // none of the below use any of the above vtables...
    _CloseAndReleaseToolbars(FALSE);

    SetAcceleratorMenu(NULL);

    FDSA_Destroy(&_fdsaTBar);

}

HRESULT CCommonBrowser::v_InternalQueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CCommonBrowser, IServiceProvider),     // IID_IServiceProvider
        QITABENT(CCommonBrowser, IOleCommandTarget),    // IID_IOleCommandTarget
        QITABENTMULTI(CCommonBrowser, IBrowserService, IBrowserService3), // IID_IBrowserService
        QITABENTMULTI(CCommonBrowser, IBrowserService2, IBrowserService3), // IID_IBrowserService2
        QITABENT(CCommonBrowser, IBrowserService3),     // IID_IBrowserService3
        QITABENT(CCommonBrowser, IShellBrowser),        // IID_IShellBrowser
        QITABENT(CCommonBrowser, IShellBrowserService), // IID_IShellBrowserService
        QITABENTMULTI(CCommonBrowser, IOleWindow, IShellBrowser),     // rare IID_IOleWindow
        QITABENT(CCommonBrowser, IDockingWindowSite),   // rare IID_IDockingWindowSite
        QITABENT(CCommonBrowser, IDockingWindowFrame),  // rare IID_IDockingWindowFrame
        QITABENT(CCommonBrowser, IInputObjectSite),     // rare IID_IInputObjectSite
        QITABENT(CCommonBrowser, IDropTarget),          // rare IID_IDropTarget

        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr))
    {
        if (_punkInner)
        {
            return _punkInner->QueryInterface(riid, ppvObj);
        }
    }
    return hr;
}

//
//  Accept punk as our inner (contained) object to which we forward a lot of
//  things we don't want to deal with.
//
//  Warning!  The refcount on the punk is *transferred* to us through this
//  method.  This is contrary to OLE convention.
//
HRESULT CCommonBrowser::SetInner(IUnknown* punk)
{
    HRESULT hres;

    //
    //  It's okay to shove the interesting things directly into
    //  our members, because if any of them go wrong, we fail
    //  the _Initialize and our destructor will release them all.

#define INNERCACHE(iid, p) do { \
    hres = SHQueryInnerInterface(_GetOuter(), punk, iid, (void **)&p); \
    if (!EVAL(SUCCEEDED(hres))) return E_FAIL; \
    } while (0)

    // Do not AddRef; the caller is tranferring the ref to us
    _punkInner = punk;

    INNERCACHE(IID_IBrowserService2, _pbsInner);
    INNERCACHE(IID_IBrowserService3, _pbsInner3);
    INNERCACHE(IID_IShellBrowser, _psbInner);
    INNERCACHE(IID_IDropTarget, _pdtInner);
    INNERCACHE(IID_IServiceProvider, _pspInner);
    INNERCACHE(IID_IOleCommandTarget, _pctInner);
    INNERCACHE(IID_IInputObjectSite, _piosInner);

#undef INNERCACHE

    _pbsInner->GetBaseBrowserData(&_pbbd);
    if (!EVAL(_pbbd)) 
        return E_FAIL; // o.w. zillions-o-GPFs on _pbbd->foo

    return S_OK;
}

// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pbsInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)
 

// *** IBrowserService2 specific methods ***
CALL_INNER_HRESULT(GetParentSite, ( IOleInPlaceSite** ppipsite), ( ppipsite));
CALL_INNER_HRESULT(SetTitle, (IShellView* psv, LPCWSTR pszName), (psv, pszName));
CALL_INNER_HRESULT(GetTitle, (IShellView* psv, LPWSTR pszName, DWORD cchName), (psv, pszName, cchName));
CALL_INNER_HRESULT(GetOleObject, ( IOleObject** ppobjv), ( ppobjv));

// think about this one.. I'm not sure we want to expose this -- Chee
// NOTE:: Yep soon we should have interface instead.
// My impression is that we won't document this whole interface???
CALL_INNER_HRESULT(GetTravelLog, (ITravelLog** pptl), (pptl));

CALL_INNER_HRESULT(ShowControlWindow, (UINT id, BOOL fShow), (id, fShow));
CALL_INNER_HRESULT(IsControlWindowShown, (UINT id, BOOL *pfShown), (id, pfShown));
CALL_INNER_HRESULT(IEGetDisplayName, (LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags), (pidl, pwszName, uFlags));
CALL_INNER_HRESULT(IEParseDisplayName, (UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut), (uiCP, pwszPath, ppidlOut));
CALL_INNER_HRESULT(DisplayParseError, (HRESULT hres, LPCWSTR pwszPath), (hres, pwszPath));
CALL_INNER_HRESULT(NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF), (pidl, grfHLNF));

CALL_INNER_HRESULT(SetNavigateState, (BNSTATE bnstate), (bnstate));
CALL_INNER_HRESULT(GetNavigateState,  (BNSTATE *pbnstate), (pbnstate));

CALL_INNER_HRESULT(NotifyRedirect,  ( IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse), ( psv, pidl, pfDidBrowse));
CALL_INNER_HRESULT(UpdateWindowList,  (), ());

CALL_INNER_HRESULT(UpdateBackForwardState,  (), ());

CALL_INNER_HRESULT(SetFlags, (DWORD dwFlags, DWORD dwFlagMask), (dwFlags, dwFlagMask));
CALL_INNER_HRESULT(GetFlags, (DWORD *pdwFlags), (pdwFlags));

// Tells if it can navigate now or not.
CALL_INNER_HRESULT(CanNavigateNow,  (), ());

CALL_INNER_HRESULT(GetPidl,  (LPITEMIDLIST *ppidl), (ppidl));
CALL_INNER_HRESULT(SetReferrer,  (LPITEMIDLIST pidl), (pidl));
CALL_INNER(DWORD,  GetBrowserIndex ,(), ());
CALL_INNER_HRESULT(GetBrowserByIndex, (DWORD dwID, IUnknown **ppunk), (dwID, ppunk));
CALL_INNER_HRESULT(GetHistoryObject, (IOleObject **ppole, IStream **pstm, IBindCtx **ppbc), (ppole, pstm, ppbc));
CALL_INNER_HRESULT(SetHistoryObject, (IOleObject *pole, BOOL fIsLocalAnchor), (pole, fIsLocalAnchor));

CALL_INNER_HRESULT(CacheOLEServer, (IOleObject *pole), (pole));

CALL_INNER_HRESULT(GetSetCodePage, (VARIANT* pvarIn, VARIANT* pvarOut), (pvarIn, pvarOut));
CALL_INNER_HRESULT(OnHttpEquiv, (IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut), (psv, fDone, pvarargIn, pvarargOut));

CALL_INNER_HRESULT(GetPalette, ( HPALETTE * hpal), ( hpal));

CALL_INNER_HRESULT(RegisterWindow, (BOOL fUnregister, int swc), (fUnregister, swc));
CALL_INNER(LRESULT,  WndProcBS ,(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam), (hwnd, uMsg, wParam, lParam));
CALL_INNER_HRESULT(OnSize, (WPARAM wParam), (wParam));
CALL_INNER_HRESULT(OnCreate, (LPCREATESTRUCT pcs), (pcs));
CALL_INNER(LRESULT,  OnCommand, (WPARAM wParam, LPARAM lParam), (wParam, lParam));
CALL_INNER_HRESULT(OnDestroy, (), ());
CALL_INNER(LRESULT,  OnNotify, (NMHDR * pnm), (pnm));
CALL_INNER_HRESULT(OnSetFocus, (), ());
CALL_INNER_HRESULT(GetBaseBrowserData,(LPCBASEBROWSERDATA* ppbd), (ppbd));
CALL_INNER(LPBASEBROWSERDATA, PutBaseBrowserData,(), ());
CALL_INNER_HRESULT(CreateViewWindow, (IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd), (psvNew, psvOld, prcView, phwnd));;
CALL_INNER_HRESULT(SetTopBrowser, (), ());
CALL_INNER_HRESULT(OnFrameWindowActivateBS, (BOOL fActive), (fActive));
CALL_INNER_HRESULT(ReleaseShellView, (), ());
CALL_INNER_HRESULT(ActivatePendingView, (), ());
CALL_INNER_HRESULT(InitializeDownloadManager, (), ());
CALL_INNER_HRESULT(InitializeTransitionSite, (), ());
CALL_INNER_HRESULT(Offline, (int iCmd), (iCmd));
CALL_INNER_HRESULT(AllowViewResize, (BOOL f), (f));
CALL_INNER_HRESULT(SetActivateState, (UINT u), (u));
CALL_INNER_HRESULT(UpdateSecureLockIcon, (int eSecureLock), (eSecureLock));
CALL_INNER_HRESULT(CreateBrowserPropSheetExt, (REFIID riid, void **ppvOut), (riid, ppvOut));

CALL_INNER_HRESULT(SetAsDefFolderSettings,(), ());
CALL_INNER_HRESULT(GetViewRect,(RECT* prc), (prc));
CALL_INNER_HRESULT(GetViewWindow,(HWND * phwnd), (phwnd));
CALL_INNER_HRESULT(InitializeTravelLog,(ITravelLog* ptl, DWORD dw), (ptl, dw));

CALL_INNER_HRESULT(_UIActivateView, (UINT uState), (uState));

CALL_INNER_HRESULT(_UpdateViewRectSize,(), ());

CALL_INNER_HRESULT(_GetEffectiveClientArea, (LPRECT prcBorder, HMONITOR hmon), (prcBorder, hmon));
CALL_INNER_HRESULT(_ResizeView,(), ());

    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
CALL_INNER_HRESULT(_CancelPendingNavigationAsync, (), ());
CALL_INNER_HRESULT(_MaySaveChanges, (), ()); 
CALL_INNER_HRESULT(_PauseOrResumeView, (BOOL fPaused), (fPaused));
CALL_INNER_HRESULT(_DisableModeless, (), ());
    
    // rethink these... are all of these necessary?
CALL_INNER_HRESULT(_NavigateToPidl, (LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags), (pidl, grfHLNF, dwFlags));
CALL_INNER_HRESULT(_TryShell2Rename, (IShellView* psv, LPCITEMIDLIST pidlNew), (psv, pidlNew));
CALL_INNER_HRESULT(_SwitchActivationNow, () , ());
CALL_INNER_HRESULT(_CancelPendingView, (), ());

    //END REVIEW:

// overridden by cdesktopbrowser
CALL_INNER(IStream*, v_GetViewStream, (LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName), (pidl, grfMode, pwszName));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pbsInner3-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

CALL_INNER_HRESULT(_PositionViewWindow, (HWND hwnd, LPRECT prc), (hwnd, prc));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _psbInner-> _function _args ; }                                            

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IShellBrowser (same as IOleInPlaceFrame)
    // IOleWindow
CALL_INNER_HRESULT(GetWindow, (HWND * lphwnd), (lphwnd));
CALL_INNER_HRESULT(ContextSensitiveHelp, (BOOL fEnterMode), (fEnterMode));

CALL_INNER_HRESULT(InsertMenusSB, (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths), (hmenuShared, lpMenuWidths));
CALL_INNER_HRESULT(SetMenuSB, (HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd), (hmenuShared, holemenu, hwnd));
CALL_INNER_HRESULT(RemoveMenusSB, (HMENU hmenuShared), (hmenuShared));
CALL_INNER_HRESULT(SetStatusTextSB, (LPCOLESTR lpszStatusText), (lpszStatusText));
CALL_INNER_HRESULT(EnableModelessSB, (BOOL fEnable), (fEnable));
CALL_INNER_HRESULT(BrowseObject, (LPCITEMIDLIST pidl, UINT wFlags), (pidl, wFlags));
CALL_INNER_HRESULT(GetControlWindow, (UINT id, HWND * lphwnd), (id, lphwnd));
CALL_INNER_HRESULT(SendControlMsg, (UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret), (id, uMsg, wParam, lParam, pret));
CALL_INNER_HRESULT(QueryActiveShellView, (struct IShellView ** ppshv), (ppshv));
CALL_INNER_HRESULT(OnViewWindowActive, (struct IShellView * ppshv), (ppshv));
CALL_INNER_HRESULT(SetToolbarItems, (LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags), (lpButtons, nButtons, uFlags));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pdtInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // *** IDropTarget ***
CALL_INNER_HRESULT(DragEnter, (IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (pdtobj, grfKeyState, pt, pdwEffect));
CALL_INNER_HRESULT(DragOver, (DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (grfKeyState, pt, pdwEffect));
CALL_INNER_HRESULT(DragLeave, (void), ());
CALL_INNER_HRESULT(Drop, (IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect), (pdtobj, grfKeyState, pt, pdwEffect));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pspInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IServiceProvider
CALL_INNER_HRESULT(QueryService, (REFGUID guidService, REFIID riid, void **ppvObj), (guidService, riid, ppvObj));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _pctInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)

    // IOleCommandTarget
CALL_INNER_HRESULT(QueryStatus, (const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext), (pguidCmdGroup, cCmds, rgCmds, pcmdtext));

#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }

HRESULT CCommonBrowser::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        if (nCmdID == SBCMDID_CACHEINETZONEICON)
        {
            if (!pvarargIn || pvarargIn->vt != VT_BOOL || !pvarargOut)
                return ERROR_INVALID_PARAMETER;
            pvarargOut->vt = VT_UI4;
            ENTERCRITICAL;
            pvarargOut->ulVal = _CacheZonesIconsAndNames(pvarargIn->boolVal);
            LEAVECRITICAL;
            return S_OK;
        }    
    }

    return _pctInner->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

// {
#define CALL_INNER(_result, _function, _arglist, _args) \
_result CCommonBrowser:: _function _arglist { return _piosInner-> _function _args ; }

#define CALL_INNER_HRESULT(_function, _arglist, _args) CALL_INNER(HRESULT, _function, _arglist, _args)


#undef CALL_INNER
#undef CALL_INNER_HRESULT
// }


HRESULT CCommonBrowser::TranslateAcceleratorSB(LPMSG lpmsg, WORD wID)
{
    HRESULT hres = S_FALSE;
    
    TraceMsg(0, "ief TR CCommonBrowser::TranslateAcceleratorSB called");

    if (!_CanHandleAcceleratorNow())
    {
        TraceMsg(0, "Ignoring TranslateAccelerator, not active");
        return S_FALSE;
    }
    
    // If we're NOT top level, assume virtual TranslateAcceleratorSB
    // handles this request. (See CVOCBrowser.)

    // CDefView may call this before it passes it down to extended view
    if (_hacc && ::TranslateAcceleratorWrap(_pbbd->_hwnd, _hacc, lpmsg)) 
    {
        TraceMsg(DM_ACCELERATOR, "CSB::TranslateAcceleratorSB TA(_hacc) ate %x,%x",
                 lpmsg->message, lpmsg->wParam);

        // We don't want to eat this escape because some controls on the
        // page rely on ESC getting dispatched. Besides, dispatching it won't
        // hurt us...
        if (lpmsg->wParam != VK_ESCAPE)
            hres = S_OK;
    }

    return hres;
}
//////////////////////////////////////////////////////////////////////////////////
//
// Code to get the ViewStateStream of the "Explorer" OCX
//
//////////////////////////////////////////////////////////////////////////////////

HRESULT CCommonBrowser::GetViewStateStream(DWORD grfMode, IStream **ppstm)
{
    // NOTE: We can't use _pidlCur or _pidlPending here. Both are NULL
    // when we goto a new directory. _pidlPending is initialized later in
    // _CreateNewShellView. So, we use for which the NewShellView is created.
    LPCITEMIDLIST pidl = _pbbd->_pidlNewShellView;
    
    if (!pidl)
        pidl = _pbbd->_pidlPending;
    
    if (!pidl)
        pidl = _pbbd->_pidlCur;

    *ppstm = _pbsOuter->v_GetViewStream(pidl, grfMode, L"ViewView2");

    // If getting the new one (for read) failed, try the old one.
    if ((grfMode == STGM_READ) && (!*ppstm || SHIsEmptyStream(*ppstm)))
    {
        if (*ppstm)
            (*ppstm)->Release();
        *ppstm = _pbsOuter->v_GetViewStream(pidl, grfMode, L"ViewView");
        TraceMsg(DM_VIEWSTREAM, "CBB::GetViewStateStream tried old stream (%x)", *ppstm);
    }
    
    return *ppstm ? S_OK : E_OUTOFMEMORY;
}

//
// Returns the border rectangle for the shell view.
//
HRESULT CCommonBrowser::_GetViewBorderRect(RECT* prc)
{
    _pbsOuter->_GetEffectiveClientArea(prc, NULL);  // FEATURE: hmon?
    
    //
    // Extract the border taken by all "frame" toolbars
    //
    for (int i=0; i < _GetToolbarCount(); i++) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(i);
        prc->left += ptbi->rcBorderTool.left;
        prc->top += ptbi->rcBorderTool.top;
        prc->right -= ptbi->rcBorderTool.right;
        prc->bottom -= ptbi->rcBorderTool.bottom;
    }
    
    return S_OK;
}

// NOTE: these toolbar functions are still part of CBaseBrowser2
// so they keep working. right now they are in IBrowserService2 and
// forwarded down.

void CCommonBrowser::_ReleaseToolbarItem(int itb, BOOL fClose)
{
    // grab it and NULL it out to eliminate race condition.
    // (actually, there's still a v. small window btwn the 2 statements).
    //
    // e.g. if you close a WebBar and then quickly shutdown windows,
    // the close destroys the window etc. but then the shutdown code
    // does _SaveToolbars which tries to do ->Save on that destroyed guy.
    //
    // note however that this now means that the entry is marked
    // 'free' so someone else might grab it out from under us and start
    // trashing it.
    TOOLBARITEM *ptbi = _GetToolbarItem(itb);
    IDockingWindow *ptbTmp = ptbi->ptbar;
    ptbi->ptbar = NULL;

    if (fClose)
    {
        ptbTmp->CloseDW(0);
    }

    IUnknown_SetSite(ptbTmp, NULL);

    // Check for NULL for BoundsChecker with Pageheap enabled functionality.
    if ( ptbi->pwszItem )
    {
        LocalFree(ptbi->pwszItem);
        ptbi->pwszItem = NULL;
    }

    ptbTmp->Release();
}


//***   CBB::_AllocToolbarItem -- find/create free slot in _aTBar toolbar array
// ENTRY/EXIT
//  hres    [out] S_OK|itb on success; o.w. E_FAIL
//  _aTBar  [inout] possibly grown
int CCommonBrowser::_AllocToolbarItem()
{
    TOOLBARITEM *ptbi;

    // try to recycle a dead one
    int iCount = FDSA_GetItemCount(&_fdsaTBar);
    for (int itb = 0; itb < iCount; ++itb) 
    {
        ptbi = (LPTOOLBARITEM)FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);
        ASSERT(ptbi != NULL);
        if (ptbi && ptbi->ptbar == NULL) 
        {
            ASSERT(itb < ITB_MAX);
            return itb;
        }
    }

    // no luck recycling, create a new one
    static TOOLBARITEM tbiTmp /*=0*/;
    int i = FDSA_AppendItem(&_fdsaTBar, &tbiTmp);
    if (i == -1) 
    {
        TraceMsg(DM_WARNING, "cbb._ati: ret=-1");
        return -1;  // warning: same as ITB_VIEW (!)
    }
    ASSERT(i == itb);
#ifdef DEBUG
    {
        ptbi = (LPTOOLBARITEM) FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);
        ASSERT(ptbi != NULL);
        for (int j = 0; j < sizeof(*ptbi); ++j)
            ASSERT(*(((char *)ptbi) + j) == 0);
    }
#endif

    ASSERT(i < ITB_MAX);
    return i;
}

HRESULT CCommonBrowser::_CloseAndReleaseToolbars(BOOL fClose)
{
    for (int itb = 0; itb < _GetToolbarCount(); itb++)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        if (ptbi->ptbar)
        {
            _ReleaseToolbarItem(itb, fClose);
        }
    }

    return S_OK;
}

//
// Implementation of CBaseBrowser2::ShowToolbar
//
// Make toolbar visible or not and update our conception of whether it
// should be shown
//
// Returns: S_OK, if successfully done.
//          E_INVALIDARG, duh.
//
HRESULT CCommonBrowser::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1) 
    {
        return E_INVALIDARG;
    }

    TOOLBARITEM *ptbi = _GetToolbarItem(itb);

    // The _FindTBar function should assure us that ptbi->ptbar is non-NULL.
    ASSERT(ptbi->ptbar);

    ptbi->ptbar->ShowDW(fShow);
    ptbi->fShow = fShow;

    return S_OK;
}

//***   IDockingWindowFrame::* {

//
// Implementation of IDockingWindowFrame::AddToolbar
//
//  Add the specified toolbar (as punkSrc) to this toolbar site and
// make it visible.
//
// Returns: S_OK, if successfully done.
//          E_FAIL, if failed (exceeded maximum).
//          E_NOINTERFACE, the toolbar does not support an approriate interface.
//
HRESULT CCommonBrowser::AddToolbar(IUnknown* punk, LPCWSTR pszItem, DWORD dwAddFlags)
{
    HRESULT hr = E_FAIL;
    int itb = _AllocToolbarItem();  // Find the first empty spot. 
    if (itb != -1) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        ASSERT(ptbi != NULL);

        ASSERT(ptbi->ptbar == NULL);

        hr = punk->QueryInterface(IID_PPV_ARG(IDockingWindow, &ptbi->ptbar));
        if (SUCCEEDED(hr)) 
        {
            if (pszItem) 
            {
                ptbi->pwszItem = StrDupW(pszItem);
                if (NULL == ptbi->pwszItem) 
                {
                    hr = E_OUTOFMEMORY;
                    ATOMICRELEASE(ptbi->ptbar);
                    return hr;
                }
            }

            ptbi->fShow = (! (dwAddFlags & DWFAF_HIDDEN)); // shown
            IUnknown_SetSite(ptbi->ptbar, SAFECAST(this, IShellBrowser*));
            ptbi->ptbar->ShowDW(ptbi->fShow);
        } 
        else 
        {
            // ERROR: all toolbars should implement IDockingWindow
            // call tjgreen if this rips
            ASSERT(0);
        }
    }

    return hr;
}

//
// Implementation of IDockingWindowFrame::RemoveToolbar
//
HRESULT CCommonBrowser::RemoveToolbar(IUnknown* punkSrc, DWORD dwRemoveFlags)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1) 
    {
        return E_INVALIDARG;
    }

    _ReleaseToolbarItem(itb, TRUE);

    // Clear the rect and resize the inner ones (including the view).
    // note the semi-hoaky post-release partying on rcBorderTool
    SetRect(&_GetToolbarItem(itb)->rcBorderTool, 0, 0, 0, 0);
    _pbsOuter->_ResizeNextBorder(itb + 1);

    return S_OK;
}

//
// Implementation of IDockingWindowFrame::FindToolbar
//
HRESULT CCommonBrowser::FindToolbar(LPCWSTR pwszItem, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_INVALIDARG;
    *ppvObj = NULL;

    if (pwszItem)
    {
        hr = S_FALSE;
        for (int itb = 0; itb < _GetToolbarCount(); itb++)
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->pwszItem && StrCmpIW(ptbi->pwszItem, pwszItem)==0)
            {
                if (ptbi->ptbar)
                {
                    hr = ptbi->ptbar->QueryInterface(riid, ppvObj);
                }
                else
                {
                    TraceMsg(TF_WARNING, "ptbi->ptbar is NULL in FindToolbar");
                    hr = E_FAIL;
                }
                break;
            }
        }
    }

    return hr;
}

// }

UINT CCommonBrowser::_FindTBar(IUnknown* punkSrc)
{
#ifdef DEBUG
    static long nQuick = 0;
    static long nSlow = 0;
#endif

    ASSERT(punkSrc);

    // Quick check without QI
    TOOLBARITEM *ptbi;
    for (int i=0; i < _GetToolbarCount(); i++) 
    {
        ptbi = _GetToolbarItem(i);
        if (punkSrc==ptbi->ptbar) 
        {
#ifdef DEBUG
            // I wonder if we ever hit this case...
            InterlockedIncrement(&nQuick);
            TraceMsg(TF_PERF, "_FindTBar QUICK=%d SLOW=%d", nQuick, nSlow);
#endif            
            return i;
        }
    }

    // If failed, do the real COM object identity check. 
    for (i=0; i < _GetToolbarCount(); i++) 
    {
        ptbi = _GetToolbarItem(i);
        if (ptbi->ptbar) 
        {
            if (SHIsSameObject(ptbi->ptbar, punkSrc)) 
            {
#ifdef DEBUG        
                InterlockedIncrement(&nSlow);
                TraceMsg(TF_PERF, "_FindTBar QUICK=%d SLOW=%d", nQuick, nSlow);
#endif            
                return i;
            }
        }
    }

    return (UINT)-1;
}

HRESULT CCommonBrowser::v_ShowHideChildWindows(BOOL fChildOnly)
{
    for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(itb);
        if (ptbi->ptbar) 
        {
            ptbi->ptbar->ShowDW(ptbi->fShow);
        }
    }

    if (!fChildOnly) 
    {
        _pbsInner->v_ShowHideChildWindows(fChildOnly);
    }

    return S_OK;
}

//***   _Load/_SaveToolbars {
#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif

const static DWORD c_BBSVersion = 0x00000011; // Increment when the stream is changed.

#define MAX_ITEMID 128 // enough for item id

HRESULT CCommonBrowser::_SaveToolbars(IStream* pstm)
{
    HRESULT hres = S_OK;
    DWORD count = 0;

    TraceMsg(DM_PERSIST, "cbb.stb enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    if (pstm==NULL) 
    {
        for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar) 
            {
                IPersistStream* ppstm;
                HRESULT hresT = ptbi->ptbar->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                if (SUCCEEDED(hresT)) 
                {
                    ppstm->Release();
                    count++;
                }
            }
        }
        TraceMsg(DM_PERSIST, "cbb.stb leave count=%d", count);
        return (count>0) ? S_OK : S_FALSE;
    }

    ULARGE_INTEGER liStart;

    pstm->Write(&c_BBSVersion, sizeof(c_BBSVersion), NULL);

    // Remember the current location, where we writes count. 
    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liStart);
    TraceMsg(DM_PERSIST, "cbb.stb seek(count)=%x", liStart.LowPart);

    hres = pstm->Write(&count, sizeof(count), NULL);
    if (hres==S_OK) 
    {
        for (UINT itb = 0; itb < (UINT)_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar) 
            {
                IPersistStream* ppstm;
                HRESULT hresT = ptbi->ptbar->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstm));
                if (SUCCEEDED(hresT)) 
                {
                    DWORD cchName = 0;
                    if (ptbi->pwszItem &&
                        (cchName=lstrlenW(ptbi->pwszItem)) &&
                        cchName < MAX_ITEMID)
                    {
                        TraceMsg(DM_PERSIST, "cbb.stb pwszItem=<%ls>", ptbi->pwszItem);
                        pstm->Write(&cchName, sizeof(cchName), NULL);
                        pstm->Write(ptbi->pwszItem, cchName*sizeof(WCHAR), NULL);
                    } 
                    else 
                    {
                        TraceMsg(DM_PERSIST, "cbb.stb lstrlenW(pwszItem)=%d", cchName);
                        pstm->Write(&cchName, sizeof(cchName), NULL);
                    }

                    TraceMsg(DM_PERSIST, "cbb.stb enter OleSaveToStream tell()=%x", DbStreamTell(pstm));
                    hres = OleSaveToStream(ppstm, pstm);
                    TraceMsg(DM_PERSIST, "cbb.stb leave OleSaveToStream tell()=%x", DbStreamTell(pstm));
                    ppstm->Release();
    
                    if (FAILED(hres)) 
                    {
                        break;
                    }
                    count++;
                }
            }
        }

        // Remember the end
        ULARGE_INTEGER liEnd;
        pstm->Seek(c_li0, STREAM_SEEK_CUR, &liEnd);
        TraceMsg(DM_PERSIST, "cbb.stb seek(end save)=%x", DbStreamTell(pstm));

        // Seek back to the original location
        TraceMsg(DM_PERSIST, "cbb.stb fix count=%d", count);
        LARGE_INTEGER liT;
        liT.HighPart = 0;
        liT.LowPart = liStart.LowPart; 
        pstm->Seek(liT, STREAM_SEEK_SET, NULL);
        hres = pstm->Write(&count, sizeof(count), NULL);

        // Seek forward to the end
        liT.LowPart = liEnd.LowPart;
        pstm->Seek(liT, STREAM_SEEK_SET, NULL);

        TraceMsg(DM_PERSIST, "cbb.stb seek(end restore)=%x", DbStreamTell(pstm));
    }

    TraceMsg(DM_PERSIST, "cbb.stb leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT IUnknown_GetClientDB(IUnknown *punk, IUnknown **ppdbc)
{
    *ppdbc = NULL;

    IDeskBar *pdb;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IDeskBar, &pdb));
    if (SUCCEEDED(hr)) 
    {
        hr = pdb->GetClient(ppdbc);
        pdb->Release();
    }
    return hr;
}

HRESULT CCommonBrowser::_LoadToolbars(IStream* pstm)
{
    DWORD dwVersion;

    TraceMsg(DM_PERSIST, "cbb.ltb enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    HRESULT hres = pstm->Read(&dwVersion, sizeof(dwVersion), NULL);

    if (hres == S_OK && dwVersion == c_BBSVersion) 
    {
        DWORD count;
        hres = pstm->Read(&count, sizeof(count), NULL);
        if (hres == S_OK) 
        {
            for (UINT i=0; i<count && SUCCEEDED(hres); i++) 
            {
                DWORD cchName = 0;
                hres = pstm->Read(&cchName, sizeof(cchName), NULL);
                if (hres == S_OK)
                {
                    WCHAR wszName[MAX_ITEMID];
                    wszName[0] = 0;
                    // if cchName >= ARRAYSIZE(wszName) then we're misaligned in the stream!
                    if (cchName && cchName<ARRAYSIZE(wszName)) 
                    {
                        hres = pstm->Read(wszName, cchName*sizeof(WCHAR), NULL);
                    }
                    TraceMsg(DM_PERSIST, "cbb.ltb name=<%ls>", wszName);
    
                    if (hres==S_OK) 
                    {
                        IDockingWindow* pstb;
                        TraceMsg(DM_PERSIST, "cbb.ltb enter OleLoadFromStream tell()=%x", DbStreamTell(pstm));
                        hres = OleLoadFromStream(pstm, IID_PPV_ARG(IDockingWindow, &pstb));
                        TraceMsg(DM_PERSIST, "cbb.ltb leave OleLoadFromStream tell()=%x", DbStreamTell(pstm));
                        if (SUCCEEDED(hres)) 
                        {
                            IUnknown *pDbc = NULL;

                            // nt5:216944: turn off size negotiation during
                            // load.  o.w. persisted size gets nuked.
                            IUnknown_GetClientDB(pstb, &pDbc);
                            if (pDbc)
                                DBC_ExecDrag(pDbc, DRAG_MOVE);

                            hres = AddToolbar(pstb, wszName[0] ? wszName : NULL, NULL);
                            if (pDbc) 
                            {
                                DBC_ExecDrag(pDbc, 0);
                                pDbc->Release();
                            }
                            pstb->Release();
                        }
                    }
                }
            }
        }
    } 
    else 
    {
        hres = E_FAIL;
    }

    TraceMsg(DM_PERSIST, "cbb.ltb leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

// }

//  *** IDockingWindowSite methods ***

HRESULT CCommonBrowser::_GetBorderDWHelper(IUnknown* punkSrc, LPRECT prcBorder, BOOL bUseHmonitor)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1)
    {
        RIPMSG(0, "GetBorderDW: invalid punkSrc");
        return E_INVALIDARG;
    }
    else if (!prcBorder)
    {
        RIPMSG(0, "GetBorderDW: invalid prcBorder");
        return E_INVALIDARG;
    }

    TOOLBARITEM *ptbThis = _GetToolbarItem(itb);
    if (bUseHmonitor && ptbThis && ptbThis->hMon)
    {
        _pbsOuter->_GetEffectiveClientArea(prcBorder, ptbThis->hMon);
    }
    else
    {
        _pbsOuter->_GetEffectiveClientArea(prcBorder, NULL);
    }

    //
    // Subtract border area taken by "outer toolbars"
    //
    for (UINT i = 0; i < itb; i++)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(i);
        if (!bUseHmonitor || (ptbThis && (ptbi->hMon == ptbThis->hMon)))
        {
            prcBorder->left += ptbi->rcBorderTool.left;
            prcBorder->top += ptbi->rcBorderTool.top;
            prcBorder->right -= ptbi->rcBorderTool.right;
            prcBorder->bottom -= ptbi->rcBorderTool.bottom;
        }
    }

    return S_OK;
}

//
// This is an implementation of IDockingWindowSite::GetBorderDW.
//
//  This function returns a bounding rectangle for the specified toolbar
// (by punkSrc). It gets the effective client area, then subtract border
// area taken by "outer" toolbars. 
// 
HRESULT CCommonBrowser::GetBorderDW(IUnknown* punkSrc, LPRECT prcBorder)
{
    return _GetBorderDWHelper(punkSrc, prcBorder, FALSE);
}


HRESULT CCommonBrowser::RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw)
{
    RIP(IS_VALID_READ_PTR(pbw, BORDERWIDTHS));
    return S_OK;
}

HRESULT CCommonBrowser::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == (UINT)-1)
    {
        RIPMSG(0, "GetBorderDW: invalid punkSrc");
        return E_INVALIDARG;
    }

    _GetToolbarItem(itb)->rcBorderTool = *pbw;
    _pbsOuter->_ResizeNextBorder(itb + 1);

    return S_OK;
}

HRESULT CCommonBrowser::_ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor)
{
    //
    // Starting with itb, look for the next toolbar on the same
    // monitor (if we care about the monitor).
    //
    IDockingWindow* ptbarNext = NULL;

    if ((int) itb < _GetToolbarCount())
    {
        TOOLBARITEM *ptbThis = _GetToolbarItem(itb);
        for (int i = itb; i < _GetToolbarCount(); i++)
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(i);
            if (ptbi->ptbar && (!bUseHmonitor || (ptbi->hMon == ptbThis->hMon)))
            {
                //
                // Found it, we're done
                //
                ptbarNext = ptbi->ptbar;
                break;
            }
        }
    }

    if (ptbarNext)
    {
        //
        // Get the toolbar's docking window rect and resize the
        // border to that.
        //
        RECT rc;

        GetBorderDW(ptbarNext, &rc);
        ptbarNext->ResizeBorderDW(&rc, (IShellBrowser*)this, TRUE);
    }
    else
    {
        //
        // We didn't find a toolbar, so we must be at the end
        // of the list.  Finish up by resizing the view.
        //
        _pbsOuter->_ResizeView();
    }

    return S_OK;
} 

HRESULT CCommonBrowser::_ResizeNextBorder(UINT itb)
{
    _ResizeNextBorderHelper(itb, FALSE);
    return S_OK;
}


//
// Hack alert!
//
// IE grabs the focus via _FixToolbarFocus when it shouldn't.  For example if a
// java app in a seperate window contains an edit control and the address bar
// had focus before the java app.  In this scenario the first time a user types
// in the edit control IE grabs back the focus.  IE bug#59007.
//
// To prevent IE from incorrectly grabbing the focus this fuction checks that
// top level parent of the toolbar is the same as the top level parent of the 
// window that has focus.
// 

BOOL CCommonBrowser::_TBWindowHasFocus(UINT itb)
{
    ASSERT(itb < ITB_MAX);

    BOOL fRet = TRUE;

    HWND hwndFocus = GetFocus();

    while (GetWindowLong(hwndFocus, GWL_STYLE) & WS_CHILD)
        hwndFocus = GetParent(hwndFocus);

    if (hwndFocus)
    {
        TOOLBARITEM *pti = _GetToolbarItem(itb);

        if (pti && pti->ptbar)
        {
            HWND hwndTB;
            if (SUCCEEDED(pti->ptbar->GetWindow(&hwndTB)) && hwndTB)
            {
                fRet = (S_OK == SHIsChildOrSelf(hwndFocus, hwndTB));
            }
        }
    }

    return fRet;
}

void DestroyZoneIconNameCache(void)
{
    if (g_pZoneIconNameCache)
    {
        PZONEICONNAMECACHE pzinc = g_pZoneIconNameCache;
        for (DWORD i = 0; i < g_dwZoneCount; i++)
        {
            if (pzinc->hiconZones)
                DestroyIcon((HICON)pzinc->hiconZones);
            pzinc++;
        }
        LocalFree(g_pZoneIconNameCache);
        g_pZoneIconNameCache = NULL;
        g_dwZoneCount = 0;
    }
}

DWORD CCommonBrowser::_CacheZonesIconsAndNames(BOOL fRefresh)
{
    ASSERTCRITICAL;
    if (g_pZoneIconNameCache)      // If we've already cached the zones, just return the zone count unless we want to refresh cache
    {
        if (fRefresh)
        {
            DestroyZoneIconNameCache();
        }
        else
            return(g_dwZoneCount);
    }

    // Create ZoneManager
    if (!_pizm)
        CoCreateInstance(CLSID_InternetZoneManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetZoneManager, &_pizm));

    if (_pizm)
    {
        DWORD dwZoneEnum;

        if (SUCCEEDED(_pizm->CreateZoneEnumerator(&dwZoneEnum, &g_dwZoneCount, 0)))
        {
            if ((g_pZoneIconNameCache = (PZONEICONNAMECACHE)LocalAlloc(LPTR, g_dwZoneCount * sizeof(ZONEICONNAMECACHE))) == NULL)
            {
                g_dwZoneCount = 0;
                return 0;
            }
                
            for (int nIndex=0; (DWORD)nIndex < g_dwZoneCount; nIndex++)
            {
                DWORD           dwZone;
                ZONEATTRIBUTES  za = {sizeof(ZONEATTRIBUTES)};

                _pizm->GetZoneAt(dwZoneEnum, nIndex, &dwZone);

                // get the zone attributes for this zone
                _pizm->GetZoneAttributes(dwZone, &za);

                StrCpyW(g_pZoneIconNameCache[nIndex].szZonesName, za.szDisplayName);
                StrCpyW(g_pZoneIconNameCache[nIndex].szIconPath, za.szIconPath);
                g_pZoneIconNameCache[nIndex].hiconZones = 0; // Load the hIcon on demand
            }
            _pizm->DestroyZoneEnumerator(dwZoneEnum);
        }
    }

    return g_dwZoneCount;
}

// zero's out pIcon & pszName on failure
BOOL CCommonBrowser::_GetCachedZoneIconAndName(DWORD lZone, HICON *pIcon, LPTSTR pszName, DWORD cch)
{
    BOOL bRet = FALSE;

    *pIcon = NULL;
    pszName[0] = 0;

    ENTERCRITICAL;
    if (lZone < _CacheZonesIconsAndNames(FALSE))
    {
        ZONEICONNAMECACHE *pzinc = &g_pZoneIconNameCache[lZone];

        // if we haven't yet cached the icon for this zone, extract it now
        // REVIEW: worth pulling the extraction outside the critsec?
        if (!pzinc->hiconZones)
        {
            // Zone icons are in two formats.
            // wininet.dll#1200 where 1200 is the res id.
            // or foo.ico directly pointing to an icon file.
            // search for the '#'
            // # is a valid filename character
            LPWSTR pwsz = StrChrW(pzinc->szIconPath, TEXTW('#'));
            WORD iIcon = 0;

            if (pwsz)
            {
                // if we found it, then we have the foo.dll#00001200 format
                pwsz[0] = TEXTW('\0');
                iIcon = (WORD)StrToIntW(pwsz+1);
                ExtractIconExW(pzinc->szIconPath,(UINT)(-1*iIcon), NULL, &pzinc->hiconZones, 1);
            }
            else
                pzinc->hiconZones = (HICON)ExtractAssociatedIconExW(HINST_THISDLL, pzinc->szIconPath, (LPWORD)&iIcon, &iIcon);

            // If mirrored system, mirror icon so that it get unmirrored again when displayed
            if (IS_BIDI_LOCALIZED_SYSTEM())
            {        
               MirrorIcon(&pzinc->hiconZones, NULL);
            }                    

        }

        *pIcon = CopyIcon(pzinc->hiconZones);
        StrCpyNW(pszName, pzinc->szZonesName, cch);
        bRet = TRUE;
    }
    LEAVECRITICAL;

    return bRet;
}


BOOL _QITest(IUnknown* punk, REFIID riid);

BOOL CCommonBrowser::_ShouldTranslateAccelerator(MSG* pmsg)
{
    //
    // We should only translate an acclerator if
    //
    // (a) the window is the frame or a child of the frame
    //     or a child of a defview window (NT5 Bug # 357186).
    //     (need to check this because you can have, for
    //     example, a toplevel java applet window running
    //     on our thread)
    //
    //     and
    //
    // (b) it's on our thread (need to check this because
    //     old-style OLE controls on a web page can run
    //     on the desktop thread)
    //

    BOOL fTranslate = FALSE;

    fTranslate = (SHIsChildOrSelf(_pbbd->_hwnd, pmsg->hwnd) == S_OK);

    if (!fTranslate) 
    {
       HWND hwnd = NULL;

       if (_pbbd->_psv && (_QITest(SAFECAST(_pbbd->_psv, IUnknown*), IID_CDefView))
            &&  SUCCEEDED(_pbbd->_psv->GetWindow(&hwnd)))
       {
          fTranslate = (SHIsChildOrSelf(hwnd, pmsg->hwnd) == S_OK);
       }
    }
    

    if (fTranslate)
    {
        DWORD dwThread = GetWindowThreadProcessId(_pbbd->_hwnd, NULL);

        HWND hwndMsg = pmsg->hwnd;
        while (GetWindowLong(hwndMsg, GWL_STYLE) & WS_CHILD)
        {
            hwndMsg = GetParent(hwndMsg);
        }
        DWORD dwMsgThread = hwndMsg ? GetWindowThreadProcessId(hwndMsg, NULL) : 0;

        if (dwThread == dwMsgThread)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT CCommonBrowser::v_MayTranslateAccelerator(MSG* pmsg)
{
    if (!(WM_KEYFIRST <= pmsg->message && pmsg->message <= WM_KEYLAST))
        return S_FALSE;

    BOOL fToolbarHasFocus = _HasToolbarFocus();

    if (fToolbarHasFocus)
    {
        ASSERT(_get_itbLastFocus() < (UINT)_GetToolbarCount());
        // toolbar has focus -- give it first chance to translate
        //
        // Notes:
        //  Notice that we don't give a chance to translate its accelerators
        // to other toolbars. This is by-design right now. We might want to
        // change it later, but it will be tricky to do it right. 
        //
        if (IUnknown_TranslateAcceleratorIO(_GetToolbarItem(_get_itbLastFocus())->ptbar, pmsg) == S_OK)
            return(S_OK);

    }
    else
    {
        UINT itbLastFocus = _get_itbLastFocus();

        if (itbLastFocus != ITB_VIEW && _TBWindowHasFocus(itbLastFocus))
        {
            // view got focus back, update cache
            _FixToolbarFocus();
        }

        // view has focus -- give it first chance to translate
        // View doesn't necessarily have focus.  Added a check.
        //
        if (_pbbd->_psv)                 // If we have a shell view
        {
            HWND hwnd;

            // Note: Not everyone supports GetWindow (go figure)
            // In which case, we try the GetFocus() window.
            if (FAILED(_pbbd->_psv->GetWindow(&hwnd)))
            {
                hwnd = GetFocus();
            }

            // check if view or its child has focus
            // before it checked for browser or a child but if user
            // clicked on Show Desktop in quick launch
            // defview is deparented from the desktop and this call
            // fails which prevents tabbing to Active Desktop
            // (done in CDefView::TranslateAccelerator
            if (SHIsChildOrSelf(hwnd, pmsg->hwnd) == S_OK)
            {
                if (_pbbd->_psv->TranslateAccelerator(pmsg) == S_OK)  // and the shell view translated the message
                {
                    return S_OK;
                }
            }
        }
    }

    // Then, handle our own accelerators (with special code for TAB key).
    if (_ShouldTranslateAccelerator(pmsg))
    {
        if (IsVK_TABCycler(pmsg))
            return _CycleFocus(pmsg);

        BOOL fFwdItbar = FALSE;

        // FEATURE: Why not just include F4 and Alt-D in ACCEL_MERGE,
        // which gets localized?


        if (pmsg->message == WM_KEYDOWN && pmsg->wParam == VK_F4)
        {
            fFwdItbar = TRUE;
        }

        if (pmsg->message == WM_SYSCHAR)
        {
            static CHAR szAccel[2] = "\0";
            CHAR   szChar [2] = "\0";
            
            
            if ('\0' == szAccel[0])
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR, szAccel, ARRAYSIZE(szAccel));

            szChar[0] = (CHAR)pmsg->wParam;
            
            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                fFwdItbar = TRUE;
            }    
        }

        if (fFwdItbar)
        {
            IDockingWindow *ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            if (IUnknown_TranslateAcceleratorIO(ptbar, pmsg) == S_OK)
                return S_OK;
        } 

        if (TranslateAcceleratorSB(pmsg, 0) == S_OK)
            return S_OK;
    }

    // If a toolbar has focus, we ask the view last. 
    if (fToolbarHasFocus)
    {
        if (_pbbd->_psv && _pbbd->_psv->TranslateAccelerator(pmsg) == S_OK)
            return S_OK;
    }

    return S_FALSE;
}

HRESULT CCommonBrowser::_CycleFocus(LPMSG lpMsg)
{
    UINT citb = 1;

    if (GetKeyState(VK_SHIFT) < 0)
    {
        // go backward
        citb = (UINT)-1;
    }

    UINT itbCur = _get_itbLastFocus();

    //
    //  Find the next visible toolbar and set the focus to it. Otherwise,
    // set the focus to the view window.
    //
    HWND hwndFocusNext;
    TOOLBARITEM *ptbi;

    if (_pbsOuter->v_MayGetNextToolbarFocus(lpMsg, itbCur, citb, &ptbi, &hwndFocusNext) == S_OK)
    {
        // Found a toolbar to take focus, nothing more to do.
        // FEATURE: do we (or caller) need to do SetStatusTextSB?
        // It looks like no one is doing it right now.
        return S_OK;
    }

    if (!(hwndFocusNext && IsWindowVisible(hwndFocusNext)))
    {
        // Didn't find anyone.  Set focus on the view.
        hwndFocusNext = _pbbd->_hwndView;
    }

    _SetFocus(ptbi, hwndFocusNext, lpMsg);

    return S_OK;
}

//***   _MayUIActTAB -- attempt TAB-activation of IOleWindow/IInputObject
// ENTRY/EXIT
//  powEtc      IOleWindow/IInputObject pair.
//  lpMsg       msg causing activation (may be NULL) (typically TAB)
//  fShowing    currently showing?
//  phwnd       [OUT] hwnd for object
//  hr          [RET] UIActivateIO result, plus E_FAIL
// DESCRIPTION
//  when TABing we only want to activate certain guys, viz. those who are
// currently showing, visible, and willing to accept activation.
HRESULT _MayUIActTAB(IOleWindow *pow, LPMSG lpMsg, BOOL fShowing, HWND *phwnd)
{
    HRESULT hr = E_FAIL;
    HWND hwnd = 0;

    if (pow && fShowing)
    {
        hr = pow->GetWindow(&hwnd);
        if (IsWindowVisible(hwnd))
            hr = IUnknown_UIActivateIO(pow, TRUE, lpMsg);
    }

    if (phwnd)
        *phwnd = hwnd;

    return hr;
}

//***   v_MayGetNextToolbarFocus -- get next in TAB order (and maybe SetFocus)
// ENTRY/EXIT
//  hres    E_FAIL for no candidate, S_FALSE for candidate, S_OK for 100% done
//          (S_OK only used by derived class for now)
HRESULT CCommonBrowser::v_MayGetNextToolbarFocus(LPMSG lpMsg,
    UINT itbCur, int citb,
    TOOLBARITEM ** pptbi, HWND * phwnd)
{
    HWND hwnd = 0;
    TOOLBARITEM *ptbi = NULL;

    if (itbCur == ITB_VIEW)
    {
        ASSERT(citb == 1 || citb == -1);
        if (citb == 1)
            itbCur = 0;
        else
            itbCur = _GetToolbarCount() - 1;
    }
    else
    {
        itbCur += citb;
    }

    // (semi-tricky: loop on an unsigned so get 0..n or n..0 w/ single loop)
    for (UINT i = itbCur; i < (UINT)_GetToolbarCount(); i += citb)
    {
        ptbi = _GetToolbarItem(i);
        // NOTE: _MayUIActTAB checks ptbi->ptbar for NULL
        if (_MayUIActTAB(ptbi->ptbar, lpMsg, ptbi->fShow, &hwnd) == S_OK)
        {
            *pptbi = ptbi;
            *phwnd = hwnd;
            return S_FALSE;
        }
    }

    *pptbi = NULL;
    *phwnd = 0;
    return E_FAIL;
}

BOOL _QITest(IUnknown* punk, REFIID riid)
{
    ASSERT(punk);

    BOOL fRet = FALSE;

    if (SUCCEEDED(punk->QueryInterface(riid, (void**)&punk)))
    {
        punk->Release();
        fRet = TRUE;
    }

    return fRet;
}

__inline BOOL _IsV4DefView(IShellView* psv)
{
    if (GetUIVersion() < 5)
        return _QITest(SAFECAST(psv, IUnknown*), IID_CDefView);

    return FALSE;
}

__inline BOOL _IsOldView(IShellView* psv)
{
    //
    // Current CDocObjectView and v4 and greater CDefView
    // implement IShellView2
    //
    return (FALSE == _QITest(SAFECAST(psv, IUnknown*), IID_IShellView2));
}

HRESULT CCommonBrowser::_SetFocus(TOOLBARITEM *ptbi, HWND hwnd, LPMSG lpMsg)
{
    // Clear the upper layer of status text
    SetStatusTextSB(NULL);

    if (hwnd == _pbbd->_hwndView)
    {
        if (_pbbd->_psv)
        {
            BOOL fTranslate = TRUE, fActivate = TRUE;

            if (!lpMsg)
            {
                // NULL message, so nothing to translate
                fTranslate = FALSE;
            }
            else if (_IsV4DefView(_pbbd->_psv) || _IsOldView(_pbbd->_psv))
            {
                // These views expect only to be UI-activated
                fTranslate = FALSE;
            }
            else if (IsVK_CtlTABCycler(lpMsg))
            {
                // Don't let trident translate ctl-tab.  Since it's always
                // UI-active, it will reject focus.
                fTranslate = FALSE;
            }
            else
            {
                // Normal case - do not activate the view.  TranslateAccelerator will do the right thing.
                fActivate = FALSE;
            }

            if (fActivate)
                _UIActivateView(SVUIA_ACTIVATE_FOCUS);

            if (fTranslate)
                _pbbd->_psv->TranslateAccelerator(lpMsg);
        }
        else
        {
            // IE3 compat (we used to do for all hwnd's)
            SetFocus(hwnd);
        }

        // Update our cache
        _OnFocusChange(ITB_VIEW);
    }

    return S_OK;
}

HRESULT CCommonBrowser::_FindActiveTarget(REFIID riid, void **ppvOut)
{
    HRESULT hres = E_FAIL;
    *ppvOut = NULL;

    BOOL fToolbarHasFocus = _HasToolbarFocus();
    if (fToolbarHasFocus) 
    {
        hres = _GetToolbarItem(_get_itbLastFocus())->ptbar->QueryInterface(riid, ppvOut);
    }
    else if (_pbbd->_psv) 
    {
        if (_get_itbLastFocus() != ITB_VIEW) 
        {
            // view got focus back, update cache
            _FixToolbarFocus();
        }

        if (_pbbd->_psv != NULL)
        {
            hres = _pbbd->_psv->QueryInterface(riid, ppvOut);
        }
    }

    return hres;
}

BOOL CCommonBrowser::_HasToolbarFocus(void)
{
    UINT uLast = _get_itbLastFocus();
    if (uLast < ITB_MAX)
    {
        TOOLBARITEM *ptbi = _GetToolbarItem(uLast);
        if (ptbi)
        {
            // NOTE: IUnknown_HasFocusIO checks ptbi->ptbar for NULL
            return (IUnknown_HasFocusIO(ptbi->ptbar) == S_OK);
        }
    }
    return FALSE;
}

//***   _FixToolbarFocus -- fake a UIActivate from the view
// NOTES
//  The view never goes 'truly' non-UIActive so we never get notified when 
//  it goes 'truly' UIActive.  we fake it here by mucking w/ our cache.
//
HRESULT CCommonBrowser::_FixToolbarFocus(void)
{
    _OnFocusChange(ITB_VIEW);               // ... and update cache
    _UIActivateView(SVUIA_ACTIVATE_FOCUS);  // steal the focus

    return S_OK;
}

HRESULT CCommonBrowser::_OnFocusChange(UINT itb)
{
    UINT itbPrevFocus = _get_itbLastFocus();

    if (itbPrevFocus != itb)
    {
        //
        //  If the view is losing the focus (within the explorer),
        // we should let it know. We should update _itbLastFocus before
        // calling UIActivate, because it will call our InsertMenu back.
        //
        _put_itbLastFocus(itb);

        if (itbPrevFocus == ITB_VIEW)
        {
            // DocHost will ignore this (since deactivating the view is taboo).
            // ShellView will respect it (so menu merge works).
            _UIActivateView(SVUIA_ACTIVATE_NOFOCUS);
        }
        else
        {
            IDockingWindow *ptb;

            // FEATURE: uh-oh not sure what we do if NULL
            // we do get NULL the 1st time we click on the SearchBand
            ptb = _GetToolbarItem(itbPrevFocus)->ptbar;

            IUnknown_UIActivateIO(ptb, FALSE, NULL);
        }
    }

    return S_OK;
}

HRESULT CCommonBrowser::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    UINT itb = _FindTBar(punkSrc);
    if (itb == ITB_VIEW)
    {
        return E_INVALIDARG;
    }

    //
    //  Note that we keep track of which toolbar got the focus last.
    // We can't reliably monitor the kill focus event because OLE's
    // window procedure hook (for merged menu dispatching code) changes
    // focus around. 
    //
    if (fSetFocus)
    {
        _OnFocusChange(itb);

        // Then, notify it to the shellview. 
        if (_pbbd->_pctView)
        {
            _pbbd->_pctView->Exec(NULL, OLECMDID_ONTOOLBARACTIVATED, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }
    }
    else if (itb == _get_itbLastFocus())
    {
        //
        // The toolbar which currently has focus is giving it up.
        // Move focus to the view when this happens.
        //
        _FixToolbarFocus();
    }

    return S_OK;
}

//***   toolbar/view broadcast {

//***   _ExecChildren -- broadcast Exec to view and toolbars
// NOTES
//  we might do *both* punkBar and fBroadcast if we want to send stuff
//  to both the view and to all toolbars, e.g. 'stop' or 'refresh'.
//
//  NOTE: n.b. the tray isn't a real toolbar, so it won't get called (sigh...).
HRESULT CCommonBrowser::_ExecChildren(IUnknown *punkBar, BOOL fBroadcast, const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    // 1st, send to specified guy (if requested)
    if (punkBar != NULL) 
    {
        // send to specified guy
        _pbsInner->_ExecChildren(punkBar, FALSE, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    // 2nd, broadcast to all (if requested)
    if (fBroadcast) 
    {
        for (int itb = 0; itb<_GetToolbarCount(); itb++) 
        {
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            // NOTE: IUnknown_Exec checks ptbi->ptbar for NULL
            IUnknown_Exec(ptbi->ptbar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    return S_OK;
}

HRESULT CCommonBrowser::_SendChildren(HWND hwndBar, BOOL fBroadcast, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // 1st, send to specified guy (if requested)
    if (hwndBar != NULL) 
    {
        // send to specified guy
        _pbsInner->_SendChildren(hwndBar, FALSE, uMsg, wParam, lParam);
    }

    // 2nd, broadcast to all (if requested)
    if (fBroadcast) 
    {
        for (int itb = 0; itb < _GetToolbarCount(); itb++) 
        {
            HWND hwndToolbar;
            TOOLBARITEM *ptbi = _GetToolbarItem(itb);
            if (ptbi->ptbar && SUCCEEDED(ptbi->ptbar->GetWindow(&hwndToolbar)))
                SendMessage(hwndToolbar, uMsg, wParam, lParam);
        }
    }

    return S_OK;
}

LRESULT CCommonBrowser::ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
     return _pbbd->_hwndView ? SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam) : 0;
}

// }

TOOLBARITEM *CCommonBrowser::_GetToolbarItem(int itb)
{
    ASSERT(itb != ITB_VIEW);
    ASSERT(itb < ITB_MAX);
    // ==0 for semi-bogus CBB::_OnFocusChange code
    ASSERT(itb < FDSA_GetItemCount(&_fdsaTBar) || itb == 0);

    TOOLBARITEM *ptbi = FDSA_GetItemPtr(&_fdsaTBar, itb, TOOLBARITEM);

    ASSERT(ptbi != NULL);

    return ptbi;
}

HRESULT CCommonBrowser::SetAcceleratorMenu(HACCEL hacc)
{
    if (hacc != _hacc)
    {
        if (_hacc)
        {
            DestroyAcceleratorTable(_hacc);
        }
        _hacc = hacc;
    }
    return S_OK;
}

HRESULT _ConvertPathToPidl(IBrowserService2 *pbs, HWND hwnd, LPCTSTR pszPath, LPITEMIDLIST * ppidl)
{
    HRESULT hres = E_FAIL;
    WCHAR wszCmdLine[MAX_URL_STRING]; // must be with pszPath
    TCHAR szParsedUrl[MAX_URL_STRING] = {'\0'};
    TCHAR szFixedUrl[MAX_URL_STRING];
    DWORD dwUrlLen = ARRAYSIZE(szParsedUrl);
    LPCTSTR pUrlToUse = pszPath;

    // Copy the command line into a temporary buffer
    // so we can remove the surrounding quotes (if 
    // they exist)
    StrCpyN(szFixedUrl, pszPath, ARRAYSIZE(szFixedUrl));
    PathUnquoteSpaces(szFixedUrl);
    
    if (ParseURLFromOutsideSource(szFixedUrl, szParsedUrl, &dwUrlLen, NULL))
        pUrlToUse = szParsedUrl;
    
    SHTCharToUnicode(pUrlToUse, wszCmdLine, ARRAYSIZE(wszCmdLine));
    
    hres = pbs->IEParseDisplayName(CP_ACP, wszCmdLine, ppidl);
    pbs->DisplayParseError(hres, wszCmdLine);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\cwndproc.h ===
#include "..\inc\cwndproc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dbapp.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "deskbar.h"
#include "bands.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include <trayp.h>      // TM_*
#include <desktray.h>   // IDeskTray

#include "dbapp.h"

#include "mluisupp.h"

/*
 this virtual app implments DeskBars that you have on the desktop.
 it has the glue that combines CDeskBar with CBandSite and populates the 
 bands (as well as persistance and such)
 
 -Chee
 */

#define DM_INIT         0       
#define DM_PERSIST      0               // trace IPS::Load, ::Save, etc.
#define DM_MENU         0               // menu code
#define DM_DRAG         0               // drag&drop
#define DM_TRAY         0               // tray: marshal, side, etc.

#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
#else
#define DbStreamTell(pstm)      ((ULONG) 0)
#endif


#define SUPERCLASS CDeskBar

/* 
 Instead of just 4 Deskbars on the whole desktop, we now have 4 deskbars for
 each monitor, however, this brings problem whenever a monitor goes away, we 
 need to clean up the following datastructure.  
 - dli
 */

// FEATURE: (dli) maybe this should be moved into multimon.h
// however, people should not get into the habbit of depending on this. 
// and it's really not used anywhere else, so, keep it here for now. 
#define DSA_MONITORSGROW 1

typedef struct DeskBarsPerMonitor {
    HMONITOR        hMon; 
    IDeskBar*       Deskbars[4];
} DESKBARSPERMONITOR, *LPDESKBARSPERMONITOR;

HDSA g_hdsaDeskBars = NULL;

enum ips_e {
    IPS_FALSE,    // reserved, must be 0 (FALSE)
    IPS_LOAD,
    IPS_INITNEW
};

CASSERT(IPS_FALSE == 0);

CDeskBarApp::~CDeskBarApp()
{
    _LeaveSide();
    
    if (_pbs)
        _pbs->Release();
    
    if (_pcm)
        _pcm->Release();
    
}

LRESULT CDeskBarApp::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

    if (!_hwnd) {
        return lres;                        // destroyed by superclass
    }

    if (_eMode == WBM_BFLOATING) {
        switch (uMsg) {
        case WM_NOTIFY:
        {
            //
            // override the hittest value to be HTCAPTION if we're docked browser based
            //
            NMHDR* pnm = (NMHDR*)lParam;
            
            if (pnm->code == NM_NCHITTEST && 
                pnm->hwndFrom == _hwndChild) {
                //
                // in the floating bug docked int he browser, we don't do
                // mdi child stuff, so we make the gripper work as the caption
                // 
                NMMOUSE* pnmm = (NMMOUSE*)pnm;
                if (pnmm->dwHitInfo == RBHT_CAPTION ||
                    pnmm->dwHitInfo == RBHT_GRABBER) 
                    lres = HTTRANSPARENT;
            }
        }
        break;
        
        case WM_NCHITTEST:
            // all "client" areas are captions in this mode
            if (lres == HTCLIENT)
                lres = HTCAPTION;
            break;
        
        case WM_SETCURSOR:
            DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
            return TRUE;
        }
    }
    
    return lres;
}

BOOL CDeskBarApp::_OnCloseBar(BOOL fConfirm)
{
    // if we are closing a bar with no bands in it, don't pop up the dialog
    if ((_pbs && (_pbs->EnumBands(-1,NULL)==0)) ||
        (!fConfirm || ConfirmRemoveBand(_hwnd, IDS_CONFIRMCLOSEBAR, TEXT(""))) )
        return SUPERCLASS::_OnCloseBar(FALSE);
    return FALSE;
}

// Gets the Deskbars on a specific monitor 
// DBPM -- DeskBars Per Monitor 
LPDESKBARSPERMONITOR GetDBPMWithMonitor(HMONITOR hMon, BOOL fCreate)
{
    int ihdsa;
    LPDESKBARSPERMONITOR pdbpm;

    if (!g_hdsaDeskBars) {
        if (fCreate)
            g_hdsaDeskBars = DSA_Create(SIZEOF(DESKBARSPERMONITOR), DSA_MONITORSGROW);
    }

    if (!g_hdsaDeskBars)
        return NULL;
    
    // If we find the DBPM with this HMONITOR, return it. 
    for (ihdsa = 0; ihdsa < DSA_GetItemCount(g_hdsaDeskBars); ihdsa++) {
        pdbpm = (LPDESKBARSPERMONITOR)DSA_GetItemPtr(g_hdsaDeskBars, ihdsa);
        if (pdbpm->hMon == hMon)
            return pdbpm;
    }

    if (fCreate) {
        DESKBARSPERMONITOR dbpm = {0};
        // This monitor is not setup, so set it, and set us the
        // the ownder of _uSide
        dbpm.hMon = hMon;
        ihdsa = DSA_AppendItem(g_hdsaDeskBars, &dbpm);
        pdbpm = (LPDESKBARSPERMONITOR)DSA_GetItemPtr(g_hdsaDeskBars, ihdsa);
        return pdbpm;
    }
    
    // When all else fails, return NULL
    return NULL;
}
    
void CDeskBarApp::_LeaveSide()
{
    if (ISABE_DOCK(_uSide) && !ISWBM_FLOAT(_eMode)) {
        // remove ourselves from the array list of where we were
        LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(_hMon, FALSE);
        if (pdbpm && (pdbpm->Deskbars[_uSide] == this)) {
            ASSERT(pdbpm->hMon);
            ASSERT(pdbpm->hMon == _hMon);
            pdbpm->Deskbars[_uSide] = NULL;
        }
    }
}

//***
// NOTES
//  FEATURE: should we create/use IDeskTray::AppBarGetState?
UINT GetTraySide(HMONITOR * phMon)
{
    LRESULT lTmp;
    APPBARDATA abd;
    
    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = GetTrayWindow();
    if (phMon)
        Tray_GetHMonitor(abd.hWnd, phMon);

    abd.uEdge = (UINT)-1;
    //lTmp = g_pdtray->AppBarGetTaskBarPos(&abd);
    lTmp = SHAppBarMessage(ABM_GETTASKBARPOS, &abd);
    ASSERT(lTmp);
    TraceMsg(DM_TRAY, "gts: ret=ABE_%d", abd.uEdge);
    return abd.uEdge;
}

//***
// ENTRY/EXIT
//  fNoMerge    is for the IPS::Load case
// NOTES
//  warning: be careful of reentrancy!  fNoMove is how we guard against it.
void CDeskBarApp::_SetModeSide(UINT eMode, UINT uSide, HMONITOR hMonNew, BOOL fNoMerge) 
{
    BOOL fNoMove;

    // make sure we don't merge etc. on NOOP moves.
    // we do such moves to force refresh (e.g. for autohide and IPS::Load);
    // also happens w/ drags which end up back where they started
    fNoMove = (eMode == _eMode && uSide == _uSide && hMonNew == _hMon);

    if (!fNoMove)
        _LeaveSide();
    
    // warning: this may call (e.g.) AppBarRegister, which causes a
    // resize, which calls back to us.  careful of reentrancy!!!
    // if we do reenter we end up w/ nt5:155043, where entry #1 has
    // fNoMove==0, then we get a recalc, entry #2 has fNoMove==1,
    // and we set our side array to us, then return back to entry
    // #1 which merges into itself!
    SUPERCLASS::_SetModeSide(eMode, uSide, hMonNew, fNoMerge);

    if (!fNoMove) {
        if (ISABE_DOCK(_uSide) && !ISWBM_FLOAT(_eMode)) {
            LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMonNew, TRUE);
            HMONITOR hMonTray = NULL;
            if (pdbpm) {
                if (fNoMerge) {
                    if (!pdbpm->Deskbars[_uSide]) {
                        // 1st guy on an edge owns it
                        // if we don't do this, when we load persisted state on logon
                        // we end up w/ *no* edge owner (since fNoMerge), so we don't
                        // merge on subsequent moves.
                        goto Lsetowner;
                    }
                }
                else if (pdbpm->Deskbars[_uSide]) {
                    // if someone already there, try merging into them
#ifdef DEBUG
                    // alt+drag suppresses merge
                    // DEBUG only since don't track >1 per side, but useful
                    // for testing appbars and toolbars anyway
                    if (!(GetKeyState(VK_MENU) < 0))
#endif
                    {
                        extern IBandSite* _GetBandSite(IDeskBar * pdb);
                        IBandSite *pbs;
                        
                        pbs = _GetBandSite(pdbpm->Deskbars[_uSide]);
                        // nt5:215952: should 'never' have pbs==0 but somehow
                        // it does happen (during deskbar automation tests).
                        // call andyp or tjgreen if you hit this assert so
                        // we can figure out why.
                        if (TPTR(pbs)) {
                            _MergeSide(pbs);            // dst=pbs, src=this
                            pbs->Release();
                        }
                    }
                }
                else if ((GetTraySide(&hMonTray) == _uSide) && (hMonTray == _hMon) && !(GetKeyState(VK_SHIFT) < 0)) {
                    // ditto for tray (but need to marshal/unmarshal)
#ifdef DEBUG
                    // alt+drag suppresses merge
                    // DEBUG only since don't track >1 per side, but useful
                    // for testing appbars and toolbars anyway
                    if (!(GetKeyState(VK_MENU) < 0))
#endif
                    {
                        _MergeSide((IBandSite *)1);     // dst=pbs, src=this
                    }
                }
                else {
                    // o.w. nobody there yet, set ourselves as owner
                    ASSERT(pdbpm->hMon);
                    ASSERT(pdbpm->hMon == hMonNew);
Lsetowner:
                    TraceMsg(DM_TRAY, "cdba._sms: 1st side owner this=0x%x", this);
                    pdbpm->Deskbars[_uSide] = this;
                }
            }
        }
    }
}

void CDeskBarApp::_UpdateCaptionTitle()
{
    if (ISWBM_FLOAT(_eMode)) {
        int iCount = (int)_pbs->EnumBands((UINT)-1, NULL);
        if (iCount == 1) {
            DWORD dwBandID;
            if (SUCCEEDED(_pbs->EnumBands(0, &dwBandID))) {
                WCHAR wszTitle[80];
                if (SUCCEEDED(_pbs->QueryBand(dwBandID, NULL, NULL, wszTitle, ARRAYSIZE(wszTitle)))) {
                    USES_CONVERSION;
                    SetWindowText(_hwnd, W2T(wszTitle));
                }
            }
        }
        else {
            TCHAR szTitle[80];
            szTitle[0] = 0;
            MLLoadString(IDS_WEBBARSTITLE,szTitle,ARRAYSIZE(szTitle));
            SetWindowText(_hwnd, szTitle);
        }
    }
}


void CDeskBarApp::_NotifyModeChange(DWORD dwMode)
{
    SUPERCLASS::_NotifyModeChange(dwMode);
    _UpdateCaptionTitle();
}

//***   GetTrayIface -- get iface from tray (w/ marshal/unmarshal)
//
HRESULT GetTrayIface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_FAIL;
    HWND hwndTray;
    IStream *pstm;

    TraceMsg(DM_TRAY, "gtif: marshal!");

    *ppvObj = NULL;

    hwndTray = GetTrayWindow();
    if (hwndTray) {
        pstm = (IStream *) SendMessage(hwndTray, TM_MARSHALBS, (WPARAM)(GUID *)&riid, 0);

        if (EVAL(pstm)) {
            // paired w/ matching Marshal in explorer (TM_MARSHALBS)
            hr = CoGetInterfaceAndReleaseStream(pstm, riid, ppvObj);
            ASSERT(SUCCEEDED(hr));
        }
    }

    return hr;
}

//***   _MergeSide -- merge two deskbars into one
// ENTRY/EXIT
//  this    [INOUT] destination deskbar (ptr:1 if tray)
//  pdbSrc  [INOUT] source deskbar; deleted if all bands moved successfully
//  ret     S_OK if all bands moved; S_FALSE if some moved; E_* o.w.
HRESULT CDeskBarApp::_MergeSide(IBandSite *pbsDst)
{
    extern HRESULT _MergeBS(IDropTarget *pdtDst, IBandSite *pbsSrc);
    HRESULT hr;
    IDropTarget *pdtDst;

    AddRef();   // make sure we don't disappear partway thru operation

    if (pbsDst == (IBandSite *)1) {
        // get (marshal'ed) iface from tray
        hr = GetTrayIface(IID_IDropTarget, (void **)&pdtDst);
        ASSERT(SUCCEEDED(hr));
    }
    else {
        // don't merge into ourself!
        ASSERT(pbsDst != _pbs);
        ASSERT(!SHIsSameObject(pbsDst, SAFECAST(_pbs, IBandSite*)));

        hr = pbsDst->QueryInterface(IID_IDropTarget, (void **)&pdtDst);
        ASSERT(SUCCEEDED(hr));
    }
    ASSERT(SUCCEEDED(hr) || pdtDst == NULL);

    if (pdtDst) {
        hr = _MergeBS(pdtDst, _pbs);
        pdtDst->Release();
    }

    Release();

    return hr;
}

void CDeskBarApp::_CreateBandSiteMenu()
{
    CoCreateInstance(CLSID_BandSiteMenu, NULL,CLSCTX_INPROC_SERVER, 
                     IID_PPV_ARG(IContextMenu3, &_pcm));
    if (_pcm)
    {
        IShellService* pss;
        
        _pcm->QueryInterface(IID_IShellService, (LPVOID*)&pss);
        if (pss)
        {
            pss->SetOwner((IBandSite*)_pbs);
            pss->Release();
        }
    }
}

HRESULT CDeskBarApp::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IContextMenu) ||
        IsEqualIID(riid, IID_IContextMenu2) ||
        IsEqualIID(riid, IID_IContextMenu3))
    {
        if (!_pcm)
        {
            _CreateBandSiteMenu();
        }
        
        // only return out our pointer if we got the one we're going
        // to delegate to
        if (_pcm)
        {
            *ppvObj = SAFECAST(this, IContextMenu3*);
            AddRef();
            return S_OK;
        }
    }
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}

HRESULT CDeskBarApp::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService,SID_SBandSite)) {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}


HRESULT CDeskBarApp::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    int idCmd = -1;

    if (!HIWORD(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);

    if (idCmd >= _idCmdDeskBarFirst)
    {
        _AppBarOnCommand(idCmd - _idCmdDeskBarFirst);
        return S_OK;
    }
    
    return _pcm->InvokeCommand(pici);
    
}

HRESULT CDeskBarApp::GetCommandString(  UINT_PTR    idCmd,
                                        UINT        uType,
                                        UINT       *pwReserved,
                                        LPSTR       pszName,
                                        UINT        cchMax)
{
    return _pcm->GetCommandString(idCmd, uType, pwReserved, pszName, cchMax);
}

HRESULT CDeskBarApp::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _pcm->HandleMenuMsg(uMsg, wParam, lParam);
}

HRESULT CDeskBarApp::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    return _pcm->HandleMenuMsg2(uMsg, wParam, lParam, plres);
}

HRESULT CDeskBarApp::QueryContextMenu(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    HRESULT hr = _pcm->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    if (SUCCEEDED(hr))
    {
        int i = hr;
        HMENU hmenuSrc;

        _idCmdDeskBarFirst = i;
        hmenuSrc = _GetContextMenu();

        // off-by-1 and by idCmdFirst+i, i think...
        i += Shell_MergeMenus(hmenu, hmenuSrc, (UINT)-1, idCmdFirst + i, idCmdLast, MM_ADDSEPARATOR) - (idCmdFirst + i);
        DestroyMenu(hmenuSrc);

        return ResultFromShort(i);   // potentially off-by-1, but who cares...
    }
    return hr;
}


//***
// NOTES
//  FEATURE: nuke this, fold it into CDeskBarApp_CreateInstance
HRESULT DeskBarApp_Create(IUnknown** ppunk)
{
    HRESULT hres;

    *ppunk = NULL;
    
    CDeskBarApp *pdb = new CDeskBarApp();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    CBandSite *pcbs = new CBandSite(NULL);
    if (pcbs)
    {
        IDeskBarClient *pdbc = SAFECAST(pcbs, IDeskBarClient*);
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            pdb->_pbs = pcbs;
            pcbs->AddRef();
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    if (FAILED(hres))
        pdb->Release();
        
    return hres;
}


STDAPI CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres;
    IUnknown *punk;

    // aggregation checking is handled in class factory

    hres = DeskBarApp_Create(&punk);
    if (SUCCEEDED(hres)) {
        *ppunk = SAFECAST(punk, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//*** CDeskBarApp::IInputObject*::* {
//

HRESULT CDeskBarApp::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (lpMsg->message == WM_SYSKEYDOWN) {
        if (lpMsg->wParam == VK_F4) {
            // ie4:28819: need to trap VK_F4 here, o.w. CBaseBrowser::TA
            // does a last-chance (winsdk)::TA (to IDM_CLOSE) and doing a
            // shutdown!
            PostMessage(_hwnd, WM_CLOSE, 0, 0);
            return S_OK;
        }
    }

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

// }

//*** CDeskBarApp::IPersistStream*::* {
//

HRESULT CDeskBarApp::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DeskBarApp;
    return S_OK;
}

HRESULT CDeskBarApp::IsDirty(void)
{
    return S_FALSE; // Never be dirty
}


//
// Persisted CDeskBarApp
//
#define STC_VERSION     1

struct SThisClass
{
    DWORD   cbSize;
    DWORD   cbVersion;
};

HRESULT CDeskBarApp::Load(IStream *pstm)
{
    SThisClass stc;
    ULONG cbRead;
    HRESULT hres;

    TraceMsg(DM_PERSIST, "cdba.l enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_LOAD;

    hres = pstm->Read(&stc, SIZEOF(stc), &cbRead);
#ifdef DEBUG
    // just in case we toast ourselves (offscreen or something)...
    static BOOL fNoPersist = FALSE;
    if (fNoPersist)
        hres = E_FAIL;
#endif
    if (hres==S_OK && cbRead==SIZEOF(stc)) {
        if (stc.cbSize==SIZEOF(SThisClass) && stc.cbVersion==STC_VERSION) {
            _eInitLoaded = IPS_LOAD;    // FEATURE: what if OLFS of bands fails?

            hres = SUPERCLASS::Load(pstm);

            TraceMsg(DM_INIT, "cdba::Load succeeded");
        } else {
            TraceMsg(DM_ERROR, "cdba::Load failed stc.cbSize==SIZEOF(SThisClass) && stc.cbVersion==SWB_VERSION");
            hres = E_FAIL;
        }
    } else {
        TraceMsg(DM_ERROR, "cdba::Load failed (hres==S_OK && cbRead==SIZEOF(_adEdge)");
        hres = E_FAIL;
    }
    TraceMsg(DM_PERSIST, "cdba.l leave tell()=%x", DbStreamTell(pstm));
    
    // after loading this, if we find that we're supposed to be browser docked,
    // make our bandsite always have a gripper
    if (_eMode == WBM_BFLOATING)
    {
        BANDSITEINFO bsinfo;

        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_ALWAYSGRIPPER;

        _pbs->SetBandSiteInfo(&bsinfo);
    }
    return hres;
}

HRESULT CDeskBarApp::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SThisClass stc;

    TraceMsg(DM_PERSIST, "cdba.s enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));
    stc.cbSize = SIZEOF(SThisClass);
    stc.cbVersion = STC_VERSION;

    hres = pstm->Write(&stc, SIZEOF(stc), NULL);
    if (SUCCEEDED(hres)) {
        SUPERCLASS::Save(pstm, fClearDirty);
    }
    
    TraceMsg(DM_PERSIST, "cdba.s leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CDeskBarApp::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ULARGE_INTEGER cbMax = { SIZEOF(SThisClass), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

HRESULT CDeskBarApp::InitNew(void)
{
    HRESULT hres;

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_INITNEW;
    TraceMsg(DM_INIT, "CDeskBarApp::InitNew called");

    hres = SUPERCLASS::InitNew();
    if (FAILED(hres))
        return hres;

    // can't call _InitPos4 until set site in SetSite

    return hres;
}


HRESULT CDeskBarApp::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) {
        /*NOTHING*/
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup)) {
        switch (nCmdID) {
        case DBCID_EMPTY:
            if (_pbs) {
                // if we have no bands left, close
                PostMessage(_hwnd, WM_CLOSE, 0, 0);
            }
            return S_OK;
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_DeskBand)) {
        switch (nCmdID) {
        case DBID_BANDINFOCHANGED:
            _UpdateCaptionTitle();
            return S_OK;
        }
    }
    else if (IsEqualIID(*pguidCmdGroup, CGID_BandSite)) {
        switch (nCmdID) {
        case BSID_BANDADDED:
        case BSID_BANDREMOVED:
            _UpdateCaptionTitle();
            return S_OK;
        }
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT CDeskBarApp::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    HRESULT hres;

    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_LOAD;
    TraceMsg(DM_INIT, "CDeskBarApp::Load(bag) called");

    hres = SUPERCLASS::Load(pPropBag, pErrorLog);
    
    // after loading this, if we find that we're supposed to be browser docked,
    // make our bandsite always have a gripper
    if (_eMode == WBM_BFLOATING)
    {
        BANDSITEINFO bsinfo;

        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_ALWAYSGRIPPER;

        _pbs->SetBandSiteInfo(&bsinfo);
    }
    return hres;
}

IBandSite * _GetBandSite(IDeskBar * pdb)
{
    IBandSite* pbs = NULL;
    
    if (pdb) {
        IUnknown* punkClient;
        
        pdb->GetClient(&punkClient);
        if (punkClient) {
            punkClient->QueryInterface(IID_IBandSite, (LPVOID*)&pbs);
            punkClient->Release();
        }
    }
    
    return pbs;
}

        
IBandSite* DeskBarApp_GetBandSiteOnEdge(UINT uEdge)
{
    // APPCOMPAT: (dli) if no HMONITOR is passed in, use the primary monitor
    // should make sure that there is always a valid HMONITOR passed in
    HMONITOR hMon = GetPrimaryMonitor();
    // --------------------------------------------------------------

    LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMon, FALSE);
    if (pdbpm) {
        ASSERT(pdbpm->hMon);
        ASSERT(pdbpm->hMon == hMon);
        return _GetBandSite(pdbpm->Deskbars[uEdge]);
    }
    return NULL;
}



IBandSite* DeskBarApp_GetBandSiteAtPoint(LPPOINT ppt)
{
    HWND hwnd = WindowFromPoint(*ppt);
    HMONITOR hMon = MonitorFromPoint(*ppt, MONITOR_DEFAULTTONULL);
    if (hwnd && hMon) {
        LPDESKBARSPERMONITOR pdbpm = GetDBPMWithMonitor(hMon, FALSE);
        if (pdbpm) {
            ASSERT(pdbpm->hMon);
            ASSERT(pdbpm->hMon == hMon);
            int i;
            for (i = 0; i < 4; i++) {
                if (pdbpm->Deskbars[i]) {
                    HWND hwndDeskbar;
                    pdbpm->Deskbars[i]->GetWindow(&hwndDeskbar);
            
                    if (hwndDeskbar == hwnd) {
                        return _GetBandSite(pdbpm->Deskbars[i]); 
                    }
                }
            }
        }
    }
    return NULL;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\commonsb.h ===
#ifndef COMMONSB_INC_
#define COMMONSB_INC_

#include "caggunk.h"
#include "fldset.h"

#define ITB_ITBAR       0               // index to the Internet Toolbar


typedef struct _ZONESICONNAMECACHE  // Cache for zones icons and display names
{
    HICON hiconZones;
    WCHAR szZonesName[MAX_ZONE_DESCRIPTION];
    WCHAR szIconPath[MAX_ZONE_PATH];  // we'll initially load the path, then cache the icon on demand
} ZONEICONNAMECACHE, *PZONEICONNAMECACHE;


class CCommonBrowser : 
    public CAggregatedUnknown
   ,public IShellBrowser
   ,public IBrowserService3
   ,public IServiceProvider
   ,public IOleCommandTarget
   ,public IDockingWindowSite
   ,public IDockingWindowFrame
   ,public IInputObjectSite
   ,public IDropTarget
   ,public IShellBrowserService
{
public:

    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {return CAggregatedUnknown::QueryInterface(riid, ppvObj);};
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CAggregatedUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { return CAggregatedUnknown::Release();};


    // *** IBrowserService specific methods ***
    virtual STDMETHODIMP GetParentSite(  IOleInPlaceSite** ppipsite) ;
    virtual STDMETHODIMP SetTitle( IShellView* psv, LPCWSTR pszName) ;
    virtual STDMETHODIMP GetTitle( IShellView* psv, LPWSTR pszName, DWORD cchName) ;
    virtual STDMETHODIMP GetOleObject(  IOleObject** ppobjv) ;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    // I am sure this has shipped at least once, looks like it is here to stay - justmann 2000-01-27
    virtual STDMETHODIMP GetTravelLog( ITravelLog** pptl) ;

    virtual STDMETHODIMP ShowControlWindow( UINT id, BOOL fShow) ;
    virtual STDMETHODIMP IsControlWindowShown( UINT id, BOOL *pfShown) ;
    virtual STDMETHODIMP IEGetDisplayName( LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) ;
    virtual STDMETHODIMP IEParseDisplayName( UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) ;
    virtual STDMETHODIMP DisplayParseError( HRESULT hres, LPCWSTR pwszPath) ;
    virtual STDMETHODIMP NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF) ;

    virtual STDMETHODIMP SetNavigateState( BNSTATE bnstate) ;
    virtual STDMETHODIMP GetNavigateState ( BNSTATE *pbnstate) ;

    virtual STDMETHODIMP NotifyRedirect (  IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) ;
    virtual STDMETHODIMP UpdateWindowList () ;

    virtual STDMETHODIMP UpdateBackForwardState () ;

    virtual STDMETHODIMP SetFlags( DWORD dwFlags, DWORD dwFlagMask) ;
    virtual STDMETHODIMP GetFlags( DWORD *pdwFlags) ;

    // Tells if it can navigate now or not.
    virtual STDMETHODIMP CanNavigateNow () ;

    virtual STDMETHODIMP GetPidl ( LPITEMIDLIST *ppidl) ;
    virtual STDMETHODIMP SetReferrer ( LPITEMIDLIST pidl) ;
    virtual STDMETHODIMP_(DWORD) GetBrowserIndex() ;
    virtual STDMETHODIMP GetBrowserByIndex( DWORD dwID, IUnknown **ppunk) ;
    virtual STDMETHODIMP GetHistoryObject( IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) ;
    virtual STDMETHODIMP SetHistoryObject( IOleObject *pole, BOOL fIsLocalAnchor) ;

    virtual STDMETHODIMP CacheOLEServer( IOleObject *pole) ;

    virtual STDMETHODIMP GetSetCodePage( VARIANT* pvarIn, VARIANT* pvarOut) ;
    virtual STDMETHODIMP OnHttpEquiv( IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) ;
    virtual STDMETHODIMP GetPalette(  HPALETTE * hpal ) ;
    virtual STDMETHODIMP RegisterWindow( BOOL fUnregister, int swc) ;
    virtual STDMETHODIMP_(LRESULT) WndProcBS( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) ;
    virtual STDMETHODIMP OnSize(WPARAM wParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP OnFrameWindowActivateBS(BOOL fActive);
    virtual STDMETHODIMP ReleaseShellView( ) ;
    virtual STDMETHODIMP ActivatePendingView( ) ;
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP GetBaseBrowserData( LPCBASEBROWSERDATA* ppbd );
    virtual STDMETHODIMP_(LPBASEBROWSERDATA) PutBaseBrowserData();
    virtual STDMETHODIMP SetTopBrowser();
    virtual STDMETHODIMP UpdateSecureLockIcon(int eSecureLock);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP InitializeDownloadManager();
    virtual STDMETHODIMP InitializeTransitionSite();
    virtual STDMETHODIMP GetFolderSetData(struct tagFolderSetData* pfsd) { *pfsd = _fsd; return S_OK; };
    virtual STDMETHODIMP CreateBrowserPropSheetExt(REFIID, LPVOID *);
    virtual STDMETHODIMP SetActivateState(UINT uActivate);
    virtual STDMETHODIMP AllowViewResize(BOOL f);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    
    // Temporarily in interface, needs to be brought local
    virtual STDMETHODIMP_(UINT) _get_itbLastFocus() {return _itbLastFocus; };
    virtual STDMETHODIMP _put_itbLastFocus(UINT itbLastFocus) {_itbLastFocus = itbLastFocus; return S_OK;};
    virtual STDMETHODIMP _UIActivateView(UINT uState) ;

    // BEGIN REVIEW:  review names and need of each.  
    // 
    // this first set could be basebrowser only members.  no one overrides
    virtual STDMETHODIMP _CancelPendingNavigationAsync() ;

    virtual STDMETHODIMP _MaySaveChanges() ; 
    virtual STDMETHODIMP _PauseOrResumeView( BOOL fPaused) ;
    virtual STDMETHODIMP _DisableModeless() ;
    
    // rethink these... are all of these necessary?
    virtual STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _SwitchActivationNow( );
    virtual STDMETHODIMP _CancelPendingView() ;

    
    virtual STDMETHODIMP v_MayTranslateAccelerator( MSG* pmsg);
    virtual STDMETHODIMP _CycleFocus( LPMSG lpMsg) ;
    virtual STDMETHODIMP v_MayGetNextToolbarFocus(LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd);
    virtual STDMETHODIMP _SetFocus(LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg);
    virtual STDMETHODIMP_(BOOL) _HasToolbarFocus(void) ;
    virtual STDMETHODIMP _FixToolbarFocus(void) ;

    // this belongs with the toolbar set.
    virtual STDMETHODIMP _ExecChildren(IUnknown *punkBar, BOOL fBroadcast,
        const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP _SendChildren(HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP _GetViewBorderRect(RECT* prc);

    virtual STDMETHODIMP _UpdateViewRectSize();
    virtual STDMETHODIMP _ResizeNextBorder(UINT itb);
    virtual STDMETHODIMP _ResizeView();

    virtual STDMETHODIMP _GetBorderDWHelper(IUnknown* punkSrc, LPRECT prcBorder, BOOL bUseHmonitor);

    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT prcBorder, HMONITOR hmon);

    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);

    //END REVIEW:

    // for CShellBrowser split
    virtual STDMETHODIMP SetAsDefFolderSettings();
    virtual STDMETHODIMP GetViewRect(RECT* prc);
    virtual STDMETHODIMP GetViewWindow(HWND * phwndView);
    virtual STDMETHODIMP InitializeTravelLog(ITravelLog* ptl, DWORD dw);

    // Desktop needs to override these:
    virtual STDMETHODIMP_(IStream*) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    
    // Desktop needs access to these:
    virtual STDMETHODIMP_(LRESULT) ForwardViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP SetAcceleratorMenu(HACCEL hacc);

    // Shell browser overrides this.
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl) {return S_OK;};

    // *** IDropTarget (delegate to basesb) ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IOleWindow
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv);
    virtual STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDockingWindowFrame (also IOleWindow(?))
    virtual STDMETHODIMP AddToolbar(IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved);
    virtual STDMETHODIMP RemoveToolbar(IUnknown* punkSrc, DWORD dwFlags);
    virtual STDMETHODIMP FindToolbar(LPCWSTR pwszItem, REFIID riid, LPVOID* ppvObj);

    // IDockingWindowSite (also IOleWindow(?))
    virtual STDMETHODIMP GetBorderDW(IUnknown* punkSrc, LPRECT prcBorder);
    virtual STDMETHODIMP RequestBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw);
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pbw);

    // IInputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);

    //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv) {return E_FAIL;}

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);

protected:
    CCommonBrowser(IUnknown* punkAgg);
    virtual ~CCommonBrowser();
    
    friend HRESULT CCommonBrowser_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    //
    // Notes: 
    //  The values in the _arcBorderTools array indicates the size of
    // the border space taken by each toolbar on each side of the
    // containing rectangle.
    //
    virtual STDMETHODIMP_(LPTOOLBARITEM) _GetToolbarItem(int itb);
    virtual STDMETHODIMP_(int) _GetToolbarCount() { return FDSA_GetItemCount(&_fdsaTBar); }
    virtual STDMETHODIMP_(int) _AllocToolbarItem();
    void        _ReleaseToolbarItem(int itb, BOOL fClose);
    
    // Helper function for toolbar negotiation
    virtual STDMETHODIMP_(UINT) _FindTBar(IUnknown* punkSrc);
    virtual STDMETHODIMP _OnFocusChange(UINT itb);
    virtual STDMETHODIMP _CloseAndReleaseToolbars(BOOL fClose = TRUE);

    virtual STDMETHODIMP v_ShowHideChildWindows(BOOL fChildOnly);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow) ;
    virtual STDMETHODIMP _SaveToolbars(IStream* pstm);
    virtual STDMETHODIMP _LoadToolbars(IStream* pstm);

    BOOL _TBWindowHasFocus(UINT itb);
    BOOL _ShouldTranslateAccelerator(MSG* pmsg);

    DWORD _CacheZonesIconsAndNames(BOOL fRefresh);
    BOOL _GetCachedZoneIconAndName(DWORD lZone, HICON *pIcon, LPTSTR pszName, DWORD cch);

    IInternetZoneManager * _pizm;

    virtual STDMETHODIMP _ResizeNextBorderHelper(UINT itb, BOOL bUseHmonitor);

    
    virtual BOOL _CanHandleAcceleratorNow(void) {return TRUE;}
    
    FDSA            _fdsaTBar;
    TOOLBARITEM     _aTBar[ITB_CSTATIC];
    UINT            _itbLastFocus;   // last one called OnFocusChange (can be -1)

    HRESULT _FindActiveTarget(REFIID riid, LPVOID* ppvOut);

    IUnknown* _punkInner;

    // implementations in basesb
    IBrowserService2* _pbsInner;
    IBrowserService3* _pbsInner3;
    IShellBrowser* _psbInner;
    IDropTarget* _pdtInner;             // TODO: non-cached?
    IServiceProvider* _pspInner;
    IOleCommandTarget* _pctInner;
    IInputObjectSite* _piosInner;

    // desktop overrides some of these methods
    IBrowserService2* _pbsOuter;
    IBrowserService2* _pbsOuter3;
    
    LPCBASEBROWSERDATA _pbbd;

    HACCEL _hacc;
    
    // for view set information
    struct tagFolderSetData _fsd;
    
    virtual HRESULT SetInner(IUnknown* punk);
};


HRESULT     _ConvertPathToPidl(IBrowserService2* pbs, HWND hwnd, LPCTSTR pszPath, LPITEMIDLIST * ppidl);

#endif // COMMONSB_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dbapp.h ===
#ifndef _DBAPP_H
#define _DBAPP_H

class CDeskBarApp : public CDeskBar
                    ,public IContextMenu3
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) {return CDeskBar::AddRef();};
    STDMETHODIMP_(ULONG) Release(void) { return CDeskBar::Release();};
    
    STDMETHOD(QueryService)(REFGUID guidService,
                                 REFIID riid, void **ppvObj);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void);

    // *** IPersistPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);

    // *** IContextMenu3 methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);
    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plres);


    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
protected:
    virtual void _SetModeSide(UINT eMode, UINT uSide, HMONITOR hMon, BOOL fNoMerge);
    virtual void _UpdateCaptionTitle();
    virtual void _NotifyModeChange(DWORD dwMode);
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _LeaveSide();

    virtual ~CDeskBarApp();
    void _CreateBandSiteMenu();


    BOOL _OnCloseBar(BOOL fConfirm); // Override dockbar's _OnCloseBar to add UI confirmation


    HRESULT _MergeSide(IBandSite *pdbDst);

    IContextMenu3* _pcm;
    
    // this class explicitely knows about CBandSite.  this is the distinction between deskbar and dbapp.
    CBandSite* _pbs;
    UINT    _eInitLoaded:2;
    int _idCmdDeskBarFirst;
    

    friend HRESULT DeskBarApp_Create(IUnknown** ppunk);
};

extern HRESULT DeskBarApp_Create(IUnknown** ppunk, IUnknown** ppbs);

#endif // _DBAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\debdump.cpp ===
#include "priv.h"
#include "resource.h"   // IDM_AB_* fir this!
#include "shbrows2.h"
#include "browbar.h"
#include "menuband.h"
#include "mnbase.h"
#include "menusite.h"
#include "menubar.h"
#include "browmenu.h"
#include "mnstatic.h"
#include "mnfolder.h"


#ifdef DEBUG // {

#define DM_FIXME    0       // trace/break when hit unknown guy

struct DBClassInfo {
    int     cbSize;
    TCHAR * pszName;
};

//
// EXTERNALOBJECTS is a macro which simply expands to X(C,0) X(D,1)
// X(E, 2)...
// where C, D, E, ... are classes whose sizes are defined externally.
//

#define EXTERNALOBJECTS 
//    X(CSDWindows, 0)  \
//    X(CDesktopBrowser, 1)  \

#define TABENT(c)   { SIZEOF(c), TEXT(#c) }
#define X(c, n)  { 0, TEXT(#c) },
struct DBClassInfo DBClassInfoTab[] =
{
    // REARCHITECT: tons of table entries missing
    // maybe drive off same file as debug extensions dumpers?
    TABENT(CSHELLBROWSER),  // 0
    TABENT(CBrowserBar),    // 1
    TABENT(CMenuBand),
    TABENT(CMenuDeskBar),
    TABENT(CMenuSite),
    TABENT(CFavoritesCallback),
    TABENT(CMenuSFToolbar),
    TABENT(CMenuStaticToolbar),
    TABENT(CMenuData),

    #define NUM_INTERNAL_OBJECTS 11

    EXTERNALOBJECTS // 3...
    { 0 },
};
#undef  TABENT
#undef  X

#define X(c, n) extern "C" extern const int SIZEOF_##c;
EXTERNALOBJECTS
#undef X

//***   DBGetClassSymbolic -- map size to class name (guess)
// NOTES
//  we just take the 1st hit, so if there are multiple classes w/ the
//  same size you get the wrong answer.  if that turns out to be a pblm
//  we can add special-case heuristics for the relevant classes.
//
//  FEATURE: TODO: should use a generic DWORD value/data pair lookup
//  helper func.
//

TCHAR *DBGetClassSymbolic(int cbSize)
{
    struct DBClassInfo *p;

#define X(c, n) \
    DBClassInfoTab[NUM_INTERNAL_OBJECTS+n].cbSize = SIZEOF_##c;
    EXTERNALOBJECTS
#undef X

    for (p = DBClassInfoTab; p->cbSize != 0; p++) {
        if (p->cbSize == cbSize)
            return p->pszName;
    }
    if (DM_FIXME) {
        TraceMsg(DM_FIXME, "DBgcs: cbSize=%d  no entry", cbSize);
        ASSERT(0);
    }
    return NULL;
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"
//#include <windows.h>
//#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "browseui"
#define SZ_MODULE           "BROWSEUI"
#define DECLARE_DEBUG
#include <debug.h>

// Include the standard helper functions to dump common ADTs
#include "..\inc\dump.c"


#ifdef DEBUG

void DumpMsg(LPCTSTR pszLabel, MSG * pmsg)
{
    ASSERT(IS_VALID_STRING_PTR(pszLabel, -1));
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        break;

    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYUP:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_KEYDOWN);
                STRING_CASE(WM_SYSKEYDOWN);
                STRING_CASE(WM_KEYUP);
                STRING_CASE(WM_SYSKEYUP);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            vk = %#04lx  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        BLOCK
        {
            LPTSTR pcsz = TEXT("(unknown)");
            switch (pmsg->message)
            {
                STRING_CASE(WM_CHAR);
                STRING_CASE(WM_SYSCHAR);
            }

            TraceMsg(TF_ALWAYS, "%s: msg = %s     hwnd = %#08lx",
                     pszLabel, pcsz, pmsg->hwnd);
            TraceMsg(TF_ALWAYS, "            char = '%c'  count = %u  flags = %#04lx",
                     pmsg->wParam, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
        }
        break;

    case WM_MOUSEMOVE:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MOUSEMOVE hwnd = %#08lx  x=%d  y=%d",
                 pszLabel, pmsg->hwnd, LOWORD(pmsg->lParam), HIWORD(pmsg->lParam));
#endif
        break;

    case WM_TIMER:
#if 0
        TraceMsg(TF_ALWAYS, "%s: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
#endif
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "%s: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pszLabel, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        if (WM_USER > pmsg->message)
        {
            TraceMsg(TF_ALWAYS, "%s: msg = %#04lx    hwnd=%#04lx wP=%#08lx lP=%#08lx",
                     pszLabel, pmsg->message, pmsg->hwnd, pmsg->wParam, pmsg->lParam);
        }
        break;
    }
}    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\desktop.h ===
/* desktop.cpp */

#include <desktopp.h>
#include "hnfblock.h"

#define PROGMAN             TEXT("Program Manager")
#define DESKTOPCLASS        TEXT(STR_DESKTOPCLASS)
#define DESKTOPPROXYCLASS   TEXT("Proxy Desktop")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\deskbar.cpp ===
// coming soon: new deskbar (old deskbar moved to browbar base class)

#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "deskbar.h"

#define SUPERCLASS  CDockingBar

//***   CDeskBar_CreateInstance --
//
STDAPI CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CDeskBar *pwbar = new CDeskBar();
    if (pwbar) {
        *ppunk = SAFECAST(pwbar, IDockingWindow*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//***
// NOTES
//  REARCHITECT: nuke this, fold it into CDeskBar_CreateInstance
HRESULT DeskBar_Create(IUnknown** ppunk, IUnknown** ppbs)
{
    HRESULT hres;

    *ppunk = NULL;
    if (ppbs)
        *ppbs = NULL;
    
    CDeskBar *pdb = new CDeskBar();
    if (!pdb)
        return E_OUTOFMEMORY;
    
    IDeskBarClient *pdbc;
    hres = CoCreateInstance(CLSID_RebarBandSite, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IDeskBarClient, (LPVOID*)&pdbc);
    if (SUCCEEDED(hres))
    {
        hres = pdb->SetClient(pdbc);
        if (SUCCEEDED(hres))
        {
            if (ppbs) {
                *ppbs = pdbc;
                pdbc->AddRef();
            }
        
            *ppunk = SAFECAST(pdb, IDeskBar*);
        }
    
        pdbc->Release();
    }

    if (FAILED(hres))
    {
        pdb->Release();
    }

    return hres;
}


CDeskBar::CDeskBar() : SUPERCLASS()
{
    // We assume this object was ZERO-INITed on the heap.
    ASSERT(!_fRestrictionsInited);
}


//*** CDeskBar::IUnknown::* {

HRESULT CDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDeskBar, IRestrict),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

// }


//*** CDeskBar::IPersistStream*::* {

HRESULT CDeskBar::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DeskBar;
    return S_OK;
}

// }



//*** CDeskBar::IRestrict::* {

HRESULT CDeskBar::IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult)
{
    HRESULT hr = S_OK;

    if (!EVAL(pguidID) || !EVAL(pdwRestrictionResult))
        return E_INVALIDARG;

    *pdwRestrictionResult = RR_NOCHANGE;
    if (IsEqualGUID(RID_RDeskBars, *pguidID))
    {
        if (!_fRestrictionsInited)
        {
            _fRestrictionsInited = TRUE;
            if (SHRestricted(REST_NOCLOSE_DRAGDROPBAND))
                _fRestrictDDClose = TRUE;
            else
                _fRestrictDDClose = FALSE;

            if (SHRestricted(REST_NOMOVINGBAND))
                _fRestrictMove = TRUE;
            else
                _fRestrictMove = FALSE;
        }

        switch(dwRestrictAction)
        {
        case RA_DRAG:
        case RA_DROP:
        case RA_ADD:
        case RA_CLOSE:
            if (_fRestrictDDClose)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        case RA_MOVE:
            if (_fRestrictMove)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        }
    }

    if (RR_NOCHANGE == *pdwRestrictionResult)    // If we don't handle it, let our parents have a wack at it.
        hr = IUnknown_HandleIRestrict(_ptbSite, pguidID, dwRestrictAction, pvarArgs, pdwRestrictionResult);

    return hr;
}

// }



//*** CDeskBar::IServiceProvider::* {

HRESULT CDeskBar::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    if (IsEqualGUID(guidService, SID_SRestrictionHandler))
    {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\deskbar.h ===
// coming soon: new deskbar (old deskbar moved to browbar base class)
#ifndef DESKBAR_H_
#define DESKBAR_H_

#include "dockbar.h"

#ifndef NOCDESKBAR

class CDeskBar : public CDockingBar
               , public IRestrict
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void)   { return CDockingBar::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)  { return CDockingBar::Release(); }
    virtual STDMETHODIMP         QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IPersistStreamInit ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IRestrict ***
    virtual STDMETHODIMP IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult);
    
    CDeskBar();

protected:
    BITBOOL _fRestrictionsInited :1;        // Have we read in the restrictions?
    BITBOOL _fRestrictDDClose :1;           // Restrict: Add, Close, Drag & Drop
    BITBOOL _fRestrictMove :1;              // Restrict: Move
};

#endif

class CDeskBarPropertyBag : public CDockingBarPropertyBag
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dhuihand.h ===
#ifndef _DHUIHAND_H
#define _DHUIHAND_H

class CDocHostUIHandler : 
   public IDocHostUIHandler
{
   public:

       // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    
    // IDocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
        DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI( 
        DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

protected:
    HRESULT GetAltExternal(IDispatch **ppDisp);

};

#endif  _DHUIHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\droptgt.cpp ===
#include "priv.h"

#include "..\inc\droptgt.h"
#include "..\inc\droptgt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dockbar.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "mshtmhst.h"
#include "desktopp.h"   // DTRF_RAISE etc.

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"

#include "deskbar.h"
#include "theater.h"

#include "mluisupp.h"

#define SUPERCLASS CBaseBar

#define DM_PERSIST      0               // trace IPS::Load, ::Save, etc.
#define DM_POPUI        0               // expando-UI (proto)
#define DM_MENU         0               // trace menu code
#define DM_DRAG         0               // drag move/size (terse)
#define DM_DRAG2        0               // ... (verbose)
#define DM_API          0               // trace API calls
#define DM_HIDE         DM_TRACE               // autohide
#define DM_HIDE2        DM_TRACE               // autohide (verbose)
#define DM_APPBAR       0               // SHAppBarMessage calls
#define DM_OLECT        0               // IOleCommandTarget calls
#define DM_FOCUS        0               // focus change
#define DM_RES          DM_WARNING      // resolution

#define ABS(i)  (((i) < 0) ? -(i) : (i))

#define RECTGETWH(uSide, prc)   (ABE_HORIZ(uSide) ? RECTHEIGHT(*prc) : RECTWIDTH(*prc))

//***   CDB_INITED -- has CDockingBar::_Initialize been called
//
#define CDB_INITED()   (_eInitLoaded && _fInitSited && _fInitShowed)

enum ips_e {
    IPS_FALSE,    // reserved, must be 0 (FALSE)
    IPS_LOAD,
    IPS_LOADBAG,
    IPS_INITNEW,
    IPS_LAST
};

CASSERT(IPS_FALSE == 0);
CASSERT(((IPS_LAST - 1) & 0x03) == (IPS_LAST - 1)); // 2-bit _eInitLoaded


//***   CXFLOAT -- distance from edge to 'float' zone 
// NOTES
//  pls forgive the lousy hungarian...
#define CXFLOAT()   GetSystemMetrics(SM_CXICON)
#define CYFLOAT()   GetSystemMetrics(SM_CYICON)
#define CXYHIDE(uSide)  2       // FEATUE: GetSystemMetrics(xxx), we need an appropriate system metric

#ifdef DEBUG
#if 0   // turn on to debug autohide boundary cases
int g_cxyHide = 8;
#undef  CXYHIDE
#define CXYHIDE(uSide)  g_cxyHide
#endif
#endif

#define CXSMSIZE()  GetSystemMetrics(SM_CXSMSIZE)
#define CYSMSIZE()  GetSystemMetrics(SM_CYSMSIZE)


#ifdef DEBUG
extern unsigned long DbStreamTell(IStream *pstm);
extern BOOL DbCheckWindow(HWND hwnd, RECT *prcExp, HWND hwndClient);
TCHAR *DbMaskToMneStr(UINT uMask, TCHAR *szMnemonics);
#else
#define DbStreamTell(pstm) 0
#define DbCheckWindow(hwnd, prcExp, hwndClient) 0
#define DbMaskToMneStr(uMask, szMnemonics) szMnemonics
#endif

//***   autohide -- design note
//
// here's an overview of how we do autohide.  see the code for details.
//
// only a few routines really know about it.  their behavior is driven
// by '_fHiding'.  when FALSE, they behave normally.  when TRUE, they
// do alternate 'fake' behavior.
//
// a 'real' or 'normal' rect is the full-size rect we display when not hidden.
// a 'fake' or 'tiny' rect is the very thin rect we display when hidden.
// (plus there's a '0-width' rect we register w/ the system when we're hidden).
//
// more specifically,
//
// when fHiding is TRUE, a few routines have alternate 'fake' behavior:
//      _ProtoRect      returns a 'tiny' rect rather than the 'real' rect
//      _NegotiateRect  is a NOOP (so we don't change the 'tiny' rect) 
//      _SetVRect       is a NOOP (so we don't save   the 'tiny' rect)
//      AppBarSetPos    is a NOOP (so we don't set    the 'tiny' rect)
// plus, a few routines handle transitions (and setup):
//      _DoHide         hide/unhide helper
//      _MoveSizeHelper detects and handles transitions
//      _HideReg        register autohide appbar w/ 0-width rect
// and finally, a few messages trigger the transitions:
//      unhide          WM_NCHITTEST on the 'tiny' rect starts the unhide.
//              actually it starts a timer (IDT_AUTOUNHIDE) so there's a
//              bit of hysteresis.
//      hide            WM_ACTIVATE(deact) starts a timer (IDT_AUTOHIDE)
//              which we use to poll for mouse leave events.  again, there
//              is some hysteresis, plus some additional heuristics for hiding.
//              WM_ACTIVATE(act) stops the timer.
//
// #if 0
// we also have 'manual hide'.  manual hide differs from autohide as follows:
//     autohide never negotiates space(*)   , manual hide always does
//     autohide is focus- and cursor- driven, manual hide is UI-driven
//     (*) actually it negotiates space of '0'.
// e.g. 'manual hide' is used for the BrowserBar (e.g. search results).
// however for now at least 'manual hide' is simply a ShowDW(FALSE).
// #endif

void CDockingBar::_AdjustToChildSize()
{
    if (_szChild.cx)
    {
        RECT rc, rcChild;
    
        GetWindowRect(_hwnd, &rc);
        GetClientRect(_hwndChild, &rcChild);

        // we need to change rc by the delta of prc-rcChild
        rc.right += _szChild.cx - RECTWIDTH(rcChild);
        rc.bottom += _szChild.cy - RECTHEIGHT(rcChild);

        _SetVRect(&rc);
    
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);

        _szChild.cx = 0;
    }
}

void CDockingBar::_OnPostedPosRectChange()
{
    if (_ptbSite) {
        if (!_fDragging) {
            _AdjustToChildSize();
        }
    }
}

HMENU CDockingBar::_GetContextMenu()
{
    HMENU hmenu = LoadMenuPopup(MENU_WEBBAR);
    if (hmenu) {

        // _eMode
        if (!ISWBM_DESKTOP())
        {
            EnableMenuItem(hmenu, IDM_AB_TOPMOST, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hmenu, IDM_AB_AUTOHIDE, MF_BYCOMMAND | MF_GRAYED);
        }
        CheckMenuItem(hmenu, IDM_AB_TOPMOST, WBM_IS_TOPMOST() ? (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED));

        // hide
        // we use _fWantHide (not _fCanHide) to reflect what user asked
        // for, not what he got.  o.w. you can't tell what the state is
        // unless you actually get it.
        CheckMenuItem(hmenu, IDM_AB_AUTOHIDE,
            MF_BYCOMMAND | (_fWantHide ? MF_CHECKED : MF_UNCHECKED));

        CASSERT(PARENT_XTOPMOST == HWND_DESKTOP);   // for WM_ACTIVATE
        CASSERT(PARENT_BTMMOST() == HWND_DESKTOP);  // for WM_ACTIVATE
        if (_eMode & WBM_FLOATING)
        {
            // (for now) only desktop btm/topmost does autohide
            EnableMenuItem(hmenu, IDM_AB_AUTOHIDE, MF_BYCOMMAND | MF_GRAYED);
        }

#ifdef DEBUG
        // FEATURE temporary until we make browser tell us about activation
        CheckMenuItem(hmenu, IDM_AB_ACTIVATE,
            MF_BYCOMMAND | (_fActive ? MF_CHECKED : MF_UNCHECKED));
#endif

    }
    return hmenu;
}

HRESULT CDockingBar::_TrackPopupMenu(const POINT* ppt)
{
    HRESULT hres = S_OK;

    HMENU hmenu = _GetContextMenu();
    if (hmenu)
    {
        TrackPopupMenu(hmenu, /*TPM_LEFTALIGN|*/TPM_RIGHTBUTTON,
            ppt->x, ppt->y, 0, _hwnd, NULL);
        DestroyMenu(hmenu);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}

void CDockingBar::_HandleWindowPosChanging(LPWINDOWPOS pwp)
{
}

/***
 */
LRESULT CDockingBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    POINT pt;
    DWORD pos;
    RECT rc;

    switch (uMsg) {
    case WM_CLOSE:
        _AppBarOnCommand(IDM_AB_CLOSE);   // _RemoveToolbar(0)
        break;

    case WM_DESTROY:
        if (_fAppRegistered)
            _AppBarRegister(FALSE);
        break;

    case APPBAR_CALLBACK:
        _AppBarCallback(hwnd, uMsg, wParam, lParam);
        return 0;

    case WM_CONTEXTMENU:
        if (_CheckForwardWinEvent(uMsg, wParam, lParam, &lres))
            break;
            
        if ((LPARAM)-1 == lParam)
        {
            GetClientRect(_hwnd, &rc);
            MapWindowRect(_hwnd, HWND_DESKTOP, &rc);
            pt.x = rc.left + (rc.right - rc.left) / 2;
            pt.y = rc.top + (rc.bottom - rc.top) / 2;
        }
        else
        {
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
        }
        _TrackPopupMenu(&pt);
        break;

    case WM_ENTERSIZEMOVE:
        ASSERT(_fDragging == 0);
        _fDragging = 0;         // reset if busted
        _xyPending = XY_NIL;
#if XXX_CANCEL
        GetWindowRect(hwnd, &_rcCapture);      // to detect cancel
#endif
        break;

    case WM_SYSCHAR:
        if (wParam == TEXT(' '))
        {
            HMENU hmenu;

            hmenu = GetSystemMenu(hwnd, FALSE);
            if (hmenu) {
                EnableMenuItem(hmenu, SC_RESTORE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MAXIMIZE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MINIMIZE, MFS_GRAYED | MF_BYCOMMAND);
            }
        }
        goto DoDefault;

    case WM_SIZING:     // goto DoDefault? I doubt it.
    case WM_MOVING:
        {
            LPRECT prc = (RECT*)lParam;

            pos = GetMessagePos();
            if (_fDragging == 0)
            {
                // 1st time
                _DragEnter(uMsg, GET_X_LPARAM(pos), GET_Y_LPARAM(pos), prc);
                ASSERT(_fDragging != 0);
            }
            else
            {
                // 2nd..Nth time
                _DragTrack(uMsg, GET_X_LPARAM(pos), GET_Y_LPARAM(pos), prc, 0);
            }
        }
        return 1;

    case WM_MOVE:       // xLeft , yTop
    case WM_SIZE:       // xWidth, yHeight
        if (_fDragging)
        {
            RECT rcTmp;

            CopyRect(&rcTmp, &_rcPending);
            _DragTrack(uMsg, GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending),
                &rcTmp, 1);
        }

        _OnSize();    // PERF: only needed for WM_SIZE? At worst this might cause a sligth flicker.
        break;
        
    case WM_EXITSIZEMOVE:
        _DragLeave(-1, -1, TRUE);
        ASSERT(_fDragging == 0);

        break;

    case WM_CHILDACTIVATE:
        if (_eMode == WBM_BFLOATING)
            SendMessage(_hwnd, WM_MDIACTIVATE, (WPARAM)_hwnd, 0);
        goto DoDefault;
        
    case WM_WINDOWPOSCHANGING:
        _HandleWindowPosChanging((LPWINDOWPOS)lParam);
        break;

    case WM_WINDOWPOSCHANGED:
Lfwdappbar:
        if (_fAppRegistered)
            _AppBarOnWM(uMsg, wParam, lParam);
        goto DoDefault;        // fwd on so we'll get WM_SIZE etc.

    case WM_TIMER:
        switch (wParam) {

        case IDT_AUTOHIDE:
            {
                ASSERT(_fWantHide && _fCanHide);

                GetCursorPos(&pt);
                GetWindowRect(hwnd, &rc);
                // add a bit of fudge so we don't hide when trying to grab the edge
                InflateRect(&rc, GetSystemMetrics(SM_CXEDGE) * 4,
                    GetSystemMetrics(SM_CYEDGE)*4);

                HWND hwndAct = GetActiveWindow();

                if (!PtInRect(&rc, pt) && hwndAct != hwnd &&
                  (hwndAct == NULL || ::GetWindowOwner(hwndAct) != hwnd))
                  {
                    // to hide, we need to be outside the inflated window,
                    // and we can't be active (for keyboard users).
                    // (heuristics stolen from tray.c)
                    // FEATURE: tray.c also checks TM_SYSMENUCOUNT == 0

                    _DoHide(AHO_KILLDO|AHO_MOVEDO);
                }
            }
            break;

        case IDT_AUTOUNHIDE:    // FEATURE: share code w/ IDT_AUTOHIDE
            ASSERT(_fWantHide && _fCanHide);

            if (_fHiding)
            {
                ASSERT(_fHiding == HIDE_AUTO);
                GetCursorPos(&pt);
                GetWindowRect(hwnd, &rc);
                if (PtInRect(&rc, pt))
                    _DoHide(AHO_KILLUN|AHO_MOVEUN|AHO_SETDO);
                else
        Lkillun:
                    _DoHide(AHO_KILLUN);
            }
            else
            {
                // if we mouse-over and then TAB very quickly, we can end
                // up getting a WM_ACT followed by a WM_TIMER (despite the
                // KillTimer inside OnAct).  if so we need to be careful
                // not to do an AHO_SETDO.  just to be safe we do an
                // AHO_KILLUN as well.
                TraceMsg(DM_HIDE, "cwb.WM_T: !_fHiding (race!) => AHO_KILLUN");
                goto Lkillun;
            }
            break;

        default:
            goto DoDefault;
        }

        break;

    case WM_NCLBUTTONDOWN:
    case WM_LBUTTONDOWN:
        goto DoDefault;


    case WM_ACTIVATE:
        _OnActivate(wParam, lParam);
        goto Lfwdappbar;

    case WM_GETMINMAXINFO:  // prevent it from getting too small
        // n.b. below stuff works for scheme 'win standard large'
        // but not for v. large edges.  not sure why, but we'll
        // have to fix it or the original bug will still manifest
        // on accessibility-enabled machines.

        // nt5:149535: resize/drag of v. small deskbar.
        // APPCOMPAT workaround USER hittest bug for v. small windows.
        // DefWndProc(WM_NCHITTEST) gives wrong result (HTLEFT) when
        // window gets too small.  so stop it from getting v. small.
        //
        // the below calc actually gives us slightly *more* than the
        // min size, but what the heck.  e.g. it gives 8+15+1=24,
        // whereas empirical tests give 20.  not sure why there's a
        // diff, but we'll use the bigger # to be safe.
        {
            RECT rcTmp = {100,100,100,100}; // arbitrary 0-sized rect
            LONG ws, wsx;
            HWND hwndTmp;

            _GetStyleForMode(_eMode, &ws, &wsx, &hwndTmp);
            AdjustWindowRectEx(&rcTmp, ws, FALSE, wsx);

            ((MINMAXINFO *)lParam)->ptMinTrackSize.x = RECTWIDTH(rcTmp)  + CXSMSIZE() + 1;
            ((MINMAXINFO *)lParam)->ptMinTrackSize.y = RECTHEIGHT(rcTmp) + CYSMSIZE() + 1;
            if (ISWBM_FLOAT(_eMode))
            {
                // nt5:169734 'close' button on v. small floating deskbar.
                // APPCOMPAT workaround USER 'close' button bug for v. small windows.
                // the button on a v. small TOOLWINDOW doesn't work.
                // empirically the below adjustment seems to work.
                ((MINMAXINFO *)lParam)->ptMinTrackSize.x += (CXSMSIZE() + 1) * 3 / 2;
                ((MINMAXINFO *)lParam)->ptMinTrackSize.y += (CYSMSIZE() + 1) * 3 / 2;
            }
            TraceMsg(DM_TRACE, "cwb.GMMI: x=%d", ((MINMAXINFO *)lParam)->ptMinTrackSize.x);
        }
        break;

    case WM_NCHITTEST:
        return _OnNCHitTest(wParam, lParam);

    case WM_WININICHANGE:
        // Active Desktop *broadcasts* a WM_WININICHANGE SPI_SETDESKWALLPAPER
        // message when starting up. If this message gets processed during
        // startup at just the right time, then the bands will notify their
        // preferred state, and we lose the persisted state.  Since the desktop
        // wallpaper changing is really of no interest to us, we filter it out here.
        //
        // REVIEW CDTURNER: Would we get a perf win by punting a larger class
        // of these wininichange messages? It seems like most won't affect
        // the contents of a deskbar...
        //
        if (SPI_SETDESKWALLPAPER == wParam)
            break;

        goto DoDefault;
        
    default:
DoDefault:
        return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}

LRESULT CDockingBar::_OnNCHitTest(WPARAM wParam, LPARAM lParam)
{
    if (_fHiding)
        _DoHide(AHO_SETUN);

    // get 'pure' hittest...
    LRESULT lres = _CalcHitTest(wParam, lParam);

    // ... and perturb it based on where we're docked
    BOOL fSizing = FALSE;
    if (ISWBM_FLOAT(_eMode)) {
        // standard sizing/moving behavior
        return lres;
    }
    else {
        // opposing edge sizes; any other edge moves
        ASSERT(ISABE_DOCK(_uSide));
        switch (_uSide) {
        case ABE_LEFT:
            //  
            // Mirror the edges (since we are dealing with screen coord)
            // if the docked-window parent is mirrored. [samera]
            //
            if (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)))
                fSizing = (lres==HTLEFT);
            else
                fSizing = (lres==HTRIGHT);
            break;
        case ABE_RIGHT:
            //  
            // Mirror the edges (since we are dealing with screen coord)
            // if the docked-window parent is mirrored.
            //
            if (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)))
                fSizing = (lres==HTRIGHT);
            else
                fSizing = (lres==HTLEFT);
            break;
        case ABE_TOP:
            fSizing = (lres==HTBOTTOM);
            break;
        case ABE_BOTTOM:
            fSizing = (lres==HTTOP);
            break;

        default: 
            ASSERT(0); 
            break;
        }
    }

    if (!fSizing) {
        lres = HTCAPTION;
    }
    return lres;
}

//***   _OnActivate --
//
void CDockingBar::_OnActivate(WPARAM wParam, LPARAM lParam)
{
    TraceMsg(DM_HIDE, "cwb.WM_ACTIVATE wParam=%x", wParam);
    if (_fCanHide) {
        ASSERT(_fHiding != HIDE_MANUAL);
        if (LOWORD(wParam) != WA_INACTIVE) {
            // activate
            TraceMsg(DM_HIDE, "cdb._oa:  WM_ACT(act) _fHiding=%d", _fHiding);
            // turn off timers for perf
            // nash:40992: unhide if hidden (e.g. TABed to hidden)
            _DoHide(AHO_KILLDO|AHO_MOVEUN);
        }
        else {
            // deactivate
            _DoHide(AHO_SETDO);         // restore
        }
    }

    return;
}

/***
 */
CDockingBar::CDockingBar() : _eMode(WBM_NIL), _uSide(ABE_RIGHT)
{
    ASSERT(_fIdtUnHide == FALSE);
    ASSERT(_fIdtDoHide == FALSE);
    _ptIdtUnHide.x = _ptIdtUnHide.y = -1;

    // set up worst-case defaults.  we'll end up using them for:
    //     - some of them for Load(bag)
    //     - all  of them for InitNew()
    // note that we might call _InitPos4 again in SetSite.
    _InitPos4(TRUE);

    return;
}

//***   _Initialize -- 2nd-phase ctor
// NOTES
//  we need any IPS::Load settings and also a site before we can init
//  ourself, so most initialization waits until here.
void CDockingBar::_Initialize()
{
    ASSERT(!_fInitShowed);
    ASSERT(_fInitSited && _eInitLoaded);
    ASSERT(!CDB_INITED());

    _fInitShowed = TRUE;

    // warning: delicate phase-ordering here...
    UINT eModeNew = _eMode;
    _eMode = WBM_NIL;
    UINT uSideNew = _uSide;
    _uSide = ABE_NIL;
    HMONITOR hMonNew = _hMon;
    _hMon = NULL;
    // 48463: beta reports fault on boot when we have deskbar+taskbar on
    // same edge (non-merged).  i'm guessing (no proof) that shdocvw isn't
    // init'ed enough early on during boot to handle doing a MergeBS, or
    // alternately that there's a race btwn the tray and desktop threads.
    //
    // plus in any case we shouldn't do the merge just because the guy did
    // a logoff/logon!
    _SetModeSide(eModeNew, uSideNew, hMonNew, /*fNoMerge*/_eInitLoaded == IPS_LOAD);

    _NotifyModeChange(0);

    // if we have a bar on the right and we drag a band from it to
    // the top, we end up getting a sequence:
    //      create deskbar; AddBand; SetSite; _Initialize
    // the AddBand of the (1st) band tries to do an autosize but
    // there's no site yet, so nothing happens.
    //
    // so we need to force it here.
    _AdjustToChildSize();

    if (_fWantHide) {
        _fWantHide = FALSE;
        _AppBarOnCommand(IDM_AB_AUTOHIDE);
    }

    ASSERT(CDB_INITED());

    return;
}

/***
 */
CDockingBar::~CDockingBar()
{
    ASSERT(!_fAppRegistered);   // make sure _ChangeTopMost(WBM_NIL) was called

    // make sure SetSite(NULL); was called
    ASSERT(!_ptbSite);
    return;
}


void CDockingBar::_GetChildPos(LPRECT prc)
{
    GetClientRect(_hwnd, prc);
}

//***   _OnSize -- compute size for OC, leaving room for toolbar (caption?)
//
void CDockingBar::_OnSize(void)
{
    RECT rc;

    if (!_hwndChild || !_eInitLoaded)
        return;

    ASSERT(IsWindow(_hwndChild));

    // don't resize on a hide (it's temporary and we don't want things
    // to jerk around or worse still do a destructive reformat)
    // APPCOMPAT: should suppress resizing here in theater mode autohide
    // too (see theater.cpp)
    if (_fHiding)
        return;

    _GetChildPos(&rc);
    // (used to do ISWBM_EDGELESS 'fake edge' adjustments here, someone
    // nuked them, but should be o.k. now that visuals are frozen *provided*
    // we don't go back to edgeless)

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER);
    //ASSERT(DbCheckWindow(_hwndChild, &rc, xxx));
}

//***   _CalcHitTest --
// NOTES
//      really only has to return an int (win16?)
LRESULT CDockingBar::_CalcHitTest(WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;

    if (!(ISWBM_BOTTOM(_eMode) && ISWBM_EDGELESS(_eMode))) {
        // For non-btmmost, we can ask USER to perform the default
        // hit testing.
        lRet = DefWindowProcWrap(_hwnd, WM_NCHITTEST, wParam, lParam);
    } else {
        // For btmmost, we need to do it.
        // (possibly dead code if bottom is never edgeless)
        // (if so, compiler should optimize it out)

        //TraceMsg(DM_WARNING, "cdb.ro: edgeless!");

        RECT rc;
        GetWindowRect(_hwnd, &rc);
        UINT x = GET_X_LPARAM(lParam);
        UINT y = GET_Y_LPARAM(lParam);
        // actually SM_C?SIZEFRAME is too big, but we get away w/ it
        // since we've been initiated by a WM_NCHITTEST so we know
        // we're on *some* edge
        UINT cx = GetSystemMetrics(SM_CXSIZEFRAME);
        UINT cy = GetSystemMetrics(SM_CYSIZEFRAME);
        if (_eMode == WBM_BBOTTOMMOST)
            cx *= 2;

        lRet = HTCAPTION;
        if (x > rc.right-cx) {
            lRet = HTRIGHT;
        } else if (x < rc.left+cx) {
            lRet = HTLEFT;
        } else if (y < rc.top+cy) {
            lRet = HTTOP;
        } else if (y > rc.bottom-cy) {
            lRet = HTBOTTOM;
        }
    }

    return lRet;
}

//***
//
void CDockingBar::_DragEnter(UINT uMsg, int x, int y, RECT* rcFeed)
{
    ASSERT(_fDragging == 0);

    if ((!(_eMode & WBM_FLOATING)) && uMsg == WM_MOVING)
    {
        // APPCOMPAT workaround USER non-full-drag drag rect bug
        // by forcing rcFeed back to exact current location (rather than
        // leaving at initial offset that USER gave us).
        //
        // w/o this code a drag from right to top in non-full-drag mode
        // will leave drag-rect droppings at the top of the original
        //
        // APPCOMPAT but, this seems to make things *worse* if !ISWBM_DESKTOP(),
        // so we don't do it in that case...  (sigh).
        _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, rcFeed, FALSE, FALSE);
    }

    _eModePending = _eMode;
    _uSidePending = _uSide;
    _xyPending = MAKELPARAM(x, y);
    _hMonPending = _hMon;
    ASSERT(rcFeed != 0);
    if (rcFeed != 0)
        CopyRect(&_rcPending, rcFeed);

#if XXX_CANCEL
    RECT rcTmp;

    GetWindowRect(_hwnd, &rcTmp);
    TraceMsg(DM_DRAG2,
        "cwb.de: rcTmp=(%d,%d,%d,%d) (%dx%d) _rcCapture=(%d,%d,%d,%d) (%dx%d)",
        rcTmp.left, rcTmp.top, rcTmp.right, rcTmp.bottom,
        RECTWIDTH(rcTmp), RECTHEIGHT(rcTmp),
        _rcCapture.left, _rcCapture.top, _rcCapture.right, _rcCapture.bottom,
        RECTWIDTH(_rcCapture), RECTHEIGHT(_rcCapture));
#endif

    switch (uMsg) {
    case WM_MOVING: _fDragging = DRAG_MOVE; break;
    case WM_SIZING: _fDragging = DRAG_SIZE; break;

    default: ASSERT(0); break;
    }

    if (_fDragging == DRAG_MOVE) {
        // turn off size negotiation to prevent horz/vert pblms.
        //
        // e.g. when we drag a floating guy to horz/vert, there's
        // a period of time during which we have a horz/vert size,
        // but still think we're floating, which screws up size
        // negotiation royally.
        _ExecDrag(DRAG_MOVE);
    }

    return;
}

//***
//
void CDockingBar::_DragTrack(UINT uMsg, int x, int y, RECT* rcFeed, int eState)
{
#if DM_API
    TraceMsg(DM_DRAG2,
        "cwb.dt: API s=%d xy=(%d,%d) rc=(%d,%d,%d,%d) (%dx%d)",
        eState, x, y,
        _PM(rcFeed,left), _PM(rcFeed,right), _PM(rcFeed,bottom), _PM(rcFeed,right),
        _PX(rcFeed,RECTWIDTH(*rcFeed)), _PX(rcFeed,RECTHEIGHT(*rcFeed)));
#endif

    ASSERT(_fDragging != 0);

    switch (eState) {
    case 0:     // WM_MOVING
        {
            BOOL fImmediate = ((!_fDesktop) && uMsg == WM_SIZING) ? TRUE:FALSE;

            // remember for eventual commit
            _xyPending = MAKELPARAM(x, y);
            ASSERT(rcFeed != NULL);
            CopyRect(&_rcPending, rcFeed);

            // snap and give feedback
            _TrackSliding(x, y, rcFeed, fImmediate, fImmediate);

            break;
        }
    case 1:     // WM_MOVE
        TraceMsg(DM_DRAG2,
            "cwb.dt: %s _xyPend=(%d,%d) xy=(%d,%d)",
            (_xyPending != MAKELPARAM(x, y)) ? "noop/cancel" : "commit",
            GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending), x, y);

        break;

    default: ASSERT(0); break;
    }

    return;
}

//***
//
void CDockingBar::_DragLeave(int x, int y, BOOL fCommit)
{
#if DM_API
    TraceMsg(DM_DRAG,
        "cwb.dl: API xy=(%d,%d) fCommit=%d",
        x, y, fCommit);
#endif

    if (_fDragging == 0) {
        // when we're inside a browser and you move the browser window
        // we get WM_ENTERSIZEMOVE/ WM_EXITSIZEMOVE but never any
        // WM_MOVING/WM_MOVE/WM_SIZING/WM_SIZE
        return;
    }

    switch (_fDragging) {
    case DRAG_MOVE:
    case DRAG_SIZE:
        break;
    default: ASSERT(0); break;
    }

#if XXX_CANCEL
    RECT rcTmp;

    GetWindowRect(_hwnd, &rcTmp);
    TraceMsg(DM_DRAG2,
        "cwb.dl: rcTmp=(%d,%d,%d,%d) (%dx%d) _rcCapture=(%d,%d,%d,%d) (%dx%d)",
        rcTmp.left, rcTmp.top, rcTmp.right, rcTmp.bottom,
        RECTWIDTH(rcTmp), RECTHEIGHT(rcTmp),
        _rcCapture.left, _rcCapture.top, _rcCapture.right, _rcCapture.bottom,
        RECTWIDTH(_rcCapture), RECTHEIGHT(_rcCapture));
    TraceMsg(DM_DRAG2, "cwb.dl: %s",
        EqualRect(&rcTmp, &_rcCapture) ? "noop/cancel" : "commit");
#endif

    BOOL fCancel = FALSE;       // FEATURE: todo: cancel NYI

    if (!fCancel) {
        if (_fDragging == DRAG_MOVE) {
            // nt5:187720 do this *before* the final move.
            // o.w. addr band ends up w/ 80-high default rather than
            // snapped to correct/negotiated size.
            //
            // why are we able to turn this on here when in general it
            // had to be off during the drag?  well, the preview of the
            // drag went thru MoveSizeHelper which did a NotifyModeChange
            // which told our client what its orientation really is.  so
            // by now things should be in sync.

            // size negotiation had been turned off (to prevent horz/vert
            // pblms).  turn it on before the final move so that we'll
            // recalc correctly.
            _ExecDrag(0);
        }

        // (we're done w/ _rcPending so o.k. to pass it in and trash it)
        // fMove==TRUE even though USER has already done the move for us,
        // since it's only done the move not the resize (?).  if we use
        // fMove==FALSE we end up in the new location but w/ the old size,
        // despite the fact that rcFeed has been updated along the way.
        // this is because USER sets SWP_NOSIZE when it does the move.
        _TrackSliding(GET_X_LPARAM(_xyPending), GET_Y_LPARAM(_xyPending),
            &_rcPending, TRUE, TRUE);

        // if we got a preferred child sizewhild dragging, set ourselves to that now.
        // sizing up   (cx > min), _szChild.cx == 0 and call a noop.
        // sizing down (cx < min), _szChild.cx != 0 and call does something.
        //ASSERT(_szChild.cx == 0);   // 0 => _AdjustToChildSize is nop
        _AdjustToChildSize();
    }
    else {
        _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, NULL, TRUE, FALSE);   // FEATURE: fMove?
    }

    _fDragging = 0;
    
    return;
}

#ifdef DEBUG
int g_dbNoExecDrag = 0;     // to play w/ ExecDrag w/o recompiling
#endif

void DBC_ExecDrag(IUnknown *pDBC, int eDragging)
{
    VARIANTARG vaIn = {0};      // VariantInit

    ASSERT(eDragging == DRAG_MOVE || eDragging == 0);

#ifdef DEBUG
    if (g_dbNoExecDrag)
        return;
#endif

    vaIn.vt = VT_I4;
    vaIn.lVal = eDragging;      // n.b. currently only 0/1 is supported 
    IUnknown_Exec(pDBC, &CGID_DeskBarClient, DBCID_ONDRAG, OLECMDEXECOPT_DONTPROMPTUSER, &vaIn, NULL);
    // VariantClear

    return;
}

void CDockingBar::_ExecDrag(int eDragging)
{
    DBC_ExecDrag(_pDBC, eDragging);
    return;
}

//***   _Recalc -- force recalc using current settings
//
void CDockingBar::_Recalc(void)
{
    _MoveSizeHelper(_eMode, _uSide, _hMon, NULL, NULL, TRUE, TRUE);
    return;
}

//***   _MoveSizeHelper -- shared code for menu and dragging forms of move/size
//
void CDockingBar::_MoveSizeHelper(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
    POINT* ptTrans, RECT* rcFeed, BOOL fCommit, BOOL fMove)
{
    UINT eModeOld, eSideOld;

    RECT rcNew;

    // only desktop guys can go to TOPMOST
    ASSERT(eModeNew != WBM_TOPMOST || ISWBM_DESKTOP());

    eModeOld = _eMode;
    eSideOld = _uSide;

    ASSERT(CHKWBM_CHANGE(eModeNew, _eMode));
    _eModePending = eModeNew;   // for drag feedback, before commit
    _uSidePending = eSideNew;
    _hMonPending = hMonNew;

    if (fCommit)
    {
        // we need to be careful when we call _ChangeHide or we'll recurse
        BOOL fChangeHide = (_fWantHide &&
            (eSideNew != _uSide || eModeNew != _eMode || hMonNew != _hMon));

        if (fChangeHide)
            _DoHide(AHO_KILLDO|AHO_UNREG);

        _SetModeSide(eModeNew, eSideNew, hMonNew, FALSE);

        if (fChangeHide)
        {
            // don't do AHO_SETDO now, wait for WM_ACTIVATE(deactivate)
            _DoHide(AHO_REG);
        }
    }

    // negotiate (and possibly commit to negotiation)
    _ProtoRect(&rcNew, eModeNew, eSideNew, hMonNew, ptTrans);
    _NegotiateRect(eModeNew, eSideNew, hMonNew, &rcNew, fCommit);

    // commit
    if (fCommit)
        _SetVRect(&rcNew);

    // feedback
    if (rcFeed != 0)
    {
        CopyRect(rcFeed, &rcNew);
    }
    
    if (fMove)
    {
        // If we're in theater mode, out parent manages our width and
        // horizontal position, unless we're being forced to a new
        // size by szChild.
        if (_fTheater && !_fDragging)
        {
            RECT rcCur;
            GetWindowRect(_hwnd, &rcCur);
            rcNew.left = rcCur.left;
            rcNew.right = rcCur.right;
        }

        // aka ScreenToClient
        MapWindowPoints(HWND_DESKTOP, GetParent(_hwnd), (POINT*) &rcNew, 2);
        
        if (_fCanHide && eModeNew == eModeOld && eSideNew == eSideOld)
        {
            // if we're [un]hiding to the same state, we can do SlideWindow
            ASSERT(ISWBM_HIDEABLE(eModeNew));
            DAD_ShowDragImage(FALSE);   // unlock the drag sink if we are dragging.
            SlideWindow(_hwnd, &rcNew, _hMon, !_fHiding);
            DAD_ShowDragImage(TRUE);    // restore the lock state.
        }
        else
        {
            MoveWindow(_hwnd, rcNew.left, rcNew.top,
                       RECTWIDTH(rcNew), RECTHEIGHT(rcNew), TRUE);
        }
    }

    // WARNING: rcNew is no longer in consistent coords! (ScreenToClient)

    // notify the child of changes
    _NotifyModeChange(0);
}

void CDockingBar::_NotifyModeChange(DWORD dwMode)
{
    UINT eMode, uSide;

    eMode = ((_fDragging == DRAG_MOVE) ? _eModePending : _eMode);
    uSide = ((_fDragging == DRAG_MOVE) ? _uSidePending : _uSide);
    //hMon = ((_fDragging == DRAG_MOVE) ? _hMonPending : _hMon);

    if (ISWBM_FLOAT(eMode))
        dwMode |= DBIF_VIEWMODE_FLOATING;
    else if (!ABE_HORIZ(uSide))
        dwMode |= DBIF_VIEWMODE_VERTICAL;

    SUPERCLASS::_NotifyModeChange(dwMode);
    
}

void CDockingBar::_TrackSliding(int x, int y, RECT* rcFeed,
    BOOL fCommit, BOOL fMove)
{
    TraceMsg(DM_DRAG2,
        "cwb.ts: _TrackSliding(x=%d, y=%d, rcFeed=(%d,%d,%d,%d)(%dx%d), fCommit=%d, fMove=%d)",
        x, y,
        _PM(rcFeed,left), _PM(rcFeed,top), _PM(rcFeed,right), _PM(rcFeed,bottom),
        _PX(rcFeed,RECTWIDTH(*rcFeed)), _PX(rcFeed,RECTHEIGHT(*rcFeed)),
        fCommit, fMove);

    POINT pt = { x, y };
    UINT eModeNew, uSideNew;
    HMONITOR hMonNew;
    if (_fDragging == DRAG_MOVE) {
        // moving...

        if (fCommit) {
            // use last feedback position.
            // o.w. (if we recompute) we end up in the wrong place since
            // WM_MOVE gives us the (left,top), which often is in another
            // docking zone.
            ASSERT(x == GET_X_LPARAM(_xyPending) && y == GET_Y_LPARAM(_xyPending));
            //eModeNew = _eModePending;
            //uSideNew = _uSidePending;
        }

        //
        // figure out snap position,
        // and do a few special-case hacks to fix it up if necessary
        //
        uSideNew = _CalcDragPlace(pt, &hMonNew);
        if (uSideNew == ABE_XFLOATING) {
            // dock->float or float->float
            eModeNew = _eMode | WBM_FLOATING;
            uSideNew = _uSide;          // FEATURE: _uSidePending? This seems to work correctly as is.
        }
        else {
            // float->dock or dock->dock
            eModeNew = _eMode & ~WBM_FLOATING;
        }

        TraceMsg(DM_DRAG2,
            "cwb.ts: (m,s) _x=(%d,%d) _xPend=(%d,%d) xNew=(%d,%d)",
            _eMode, _uSide, _eModePending, _uSidePending, eModeNew, uSideNew);

        // 970725: we now allow bottom->float (for the desktop, not browser)
        if (ISWBM_FLOAT(eModeNew) && ISWBM_BOTTOM(_eMode) && !ISWBM_DESKTOP()) {
            // special case: don't allow switch from BTMMOST to FLOATING
            ASSERT(CHKWBM_CHANGE(eModeNew, _eMode));
            eModeNew = _eModePending;   // the dead zone...
            uSideNew = _uSidePending;   // QUESTION: init case?
            hMonNew = _hMonPending;
            TraceMsg(DM_DRAG2,
                "cwb.ts: (m,s) btm->flt override     xNew=(%d,%d)",
                eModeNew, uSideNew);
            ASSERT(!ISWBM_FLOAT(eModeNew));
        }

        //
        // smooth things out so we don't jump around
        //
        _SmoothDragPlace(eModeNew, uSideNew, hMonNew, &pt, rcFeed);

        //
        // now do the move
        //
        // | with _eMode & WBMF_BROWSER because dragging around doesn't change the
        // browser owned bit
        _MoveSizeHelper(eModeNew | (_eMode & WBMF_BROWSER), uSideNew, hMonNew, 
            ISWBM_FLOAT(eModeNew) ? &pt : NULL, rcFeed, fCommit, fMove);
    }
    else {
        ASSERT(_fDragging == DRAG_SIZE);

        // truncate to max size if necessary
        _SmoothDragPlace(_eMode, _uSide, _hMon, NULL, rcFeed);

        if (!fCommit) {
            // USER does everything for us
            return;
        }
        ASSERT(MAKELPARAM(x, y) != XY_NIL);

        // APPCOMPAT: we're gonna commit so just blast it in here...
        RECT rcNew;

        GetWindowRect(_hwnd, &rcNew);   // PERF: already set?
        _SetVRect(&rcNew);
        _MoveSizeHelper(_eMode, _uSide, _hMon,
            NULL, NULL,                 // FEATURE: &rcNew?
            fCommit, fMove);
    }

    return;
}

/***    _CalcDragPlace -- compute where drag will end up
 * NOTES
 *      FEATURE: prelim version
 */
UINT CDockingBar::_CalcDragPlace(POINT& pt, HMONITOR * phMon)
{
    TraceMsg(DM_DRAG2,
        "cwb.cdp: _CalcDragPlace(pt=(%d,%d))",
        pt.x, pt.y);

    SIZE screen, error;
    UINT uHorzEdge, uVertEdge, uPlace;
    RECT rcDisplay = {0};  // _GetBorderRect doesn't always set rect.

    // Get the correct hMonitor.
    ASSERT(phMon);
    *phMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    // FEATURE: todo: make hwndSite and rcDisplay args, then this can be
    // a generic helper func
    _GetBorderRect(*phMon, &rcDisplay);

    // if we're outside our 'parent' (browser or desktop), we float.
    // this really only applies to the browser case, since we'll never
    // be outside the desktop (what about multi-monitor?).
    if (!PtInRect(&rcDisplay, pt) || !_ptbSite) {
        TraceMsg(DM_DRAG2,
            "cwb.cdp: pt=(%d,%d) uSideNew=%u",
            pt.x, pt.y, ABE_XFLOATING);
        return ABE_XFLOATING;
    }

    // if we're not w/in min threshhold from edge, we float
    {
        RECT rcFloat;   // FEATURE can just use rcDisplay
        int cx = CXFLOAT();
        int cy = CYFLOAT();

        CopyRect(&rcFloat, &rcDisplay);
        InflateRect(&rcFloat, -cx, -cy);

        if (PtInRect(&rcFloat, pt)) {
            TraceMsg(DM_DRAG2,
                "cwb.cdp: pt=(%d,%d) uSideNew=%u",
                pt.x, pt.y, ABE_XFLOATING);
            return ABE_XFLOATING;
        }
    }

    //
    // re-origin at zero to make calculations simpler
    //
    screen.cx =  RECTWIDTH(rcDisplay);
    screen.cy = RECTHEIGHT(rcDisplay);
    pt.x -= rcDisplay.left;
    pt.y -= rcDisplay.top;

    //
    // are we closer to the left or right side of this display?
    //
    if (pt.x < (screen.cx / 2)) {
        uVertEdge = ABE_LEFT;
        error.cx = pt.x;
    }
    else {
        uVertEdge = ABE_RIGHT;
        error.cx = screen.cx - pt.x;
    }

    //
    // are we closer to the top or bottom side of this display?
    //
    if (pt.y < (screen.cy / 2)) {
        uHorzEdge = ABE_TOP;
        error.cy = pt.y;
    }
    else {
        uHorzEdge = ABE_BOTTOM;
        error.cy = screen.cy - pt.y;
    }

    //
    // closer to a horizontal or vertical edge?
    //
    uPlace = ((error.cy * screen.cx) > (error.cx * screen.cy))?
        uVertEdge : uHorzEdge;

    TraceMsg(DM_DRAG2,
        "cwb.cdp: pt=(%d,%d) uSideNew=%u",
        pt.x, pt.y, uPlace);

    return uPlace;
}

//***   _SmoothDragPlace -- do some magic to smooth out dragging
// ENTRY/EXIT
//      eModeNew        where we're snapping to
//      eSideNew        ...
//      [_eModePending] where we're snapping from
//      [_eSidePending] ...
//      pt              INOUT cursor position
//      rcFeed          USER's original drag feedback rect
// NOTES
//      this is the place to put excel-like heuristics.  e.g. when coming
//      back off the right side we could put the cursor at the top right of
//      the floating rect (rather than the top left) to allow us to float
//      as close as possible to the other side w/o docking.  hmm, but how
//      would we tell USER where to put the cursor...
//
void CDockingBar::_SmoothDragPlace(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
    INOUT POINT* pt, RECT* rcFeed)
{
    if (_fDragging == DRAG_MOVE) {
        if (ISWBM_FLOAT(eModeNew) && ISWBM_FLOAT(_eModePending) && rcFeed != 0 && pt) {
            // use the feedback rect from USER to keep things smooth.
            // o.w. if we use the cursor position we'll jump at the
            // beginning (to move the left-top corner to the starting
            // cursor position).
            pt->x = rcFeed->left;
            pt->y = rcFeed->top;
        }
    }
    else {
        ASSERT(_fDragging == DRAG_SIZE);
        ASSERT(eModeNew == _eMode && eSideNew == _uSide && hMonNew == _hMon);
        if (!ISWBM_FLOAT(_eMode)) {
            // truncate to max size (1/2 of screen) if necessary

            int iWH;
            RECT rcScreen;

            // we'd like to use 1/2 of browser, not 1/2 of screen.  however
            // this causes pblms if you maximize, grow to 1/2, and restore.
            // then the 1st time you resize the bar it 'jumps' down to 1/2
            // of the *current* size from 1/2 of the old size.  kind of a
            // hack, sigh...
            //
            // also note that there's still a bug here: if you size down
            // the browser gradually, we don't go thru this logic, so you
            // end up w/ a bar width > browser width so you the right edge
            // is clipped and there's no way to size it down.  probably
            // when the browser resize is done we should re-smooth the bar.
            //_GetBorderRect(_hMon, &rcScreen);
            GetMonitorRect(_hMon, &rcScreen);   // aka GetSystemMetrics(SM_CXSCREEN)
            iWH = RECTGETWH(_uSide, &rcScreen);
            iWH /= 2;
            if (RECTGETWH(_uSide, rcFeed) > iWH) {
                TraceMsg(DM_TRACE, "cwb.sdp: truncate iWH'=%d", iWH);
                RectXform(rcFeed, RX_OPPOSE, rcFeed, NULL, iWH, _uSide, NULL);
            }
        }
    }

    return;
}

/***
 */
LRESULT CDockingBar::_OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    if (_CheckForwardWinEvent(uMsg, wParam, lParam, &lres))
        return lres;
    
    if ((Command_GetID(wParam) <= IDM_AB_LAST) &&
        (Command_GetID(wParam) >= IDM_AB_FIRST)) {
        _AppBarOnCommand(Command_GetID(wParam));
    }

    return lres;
}

/***    CDockingBar::_AppBarRegister -- register/unregister AppBar
 * DESCRIPTION
 *      updates _fAppRegistered
 *      does nothings if it's already regisrered or unregistered
 */
void CDockingBar::_AppBarRegister(BOOL fRegister)
{
    APPBARDATA abd;

    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwnd;

    if (fRegister && !_fAppRegistered) {
        abd.uCallbackMessage = APPBAR_CALLBACK;
        TraceMsg(DM_APPBAR, "cwb.abr: call ABM_NEW");
        UINT_PTR bT = SHAppBarMessage(ABM_NEW, &abd);
        ASSERT(bT);
        if (bT) {
            _fAppRegistered = TRUE;

            // fake a callback to set initial state
            // #if XXX_TASKMAN
            TraceMsg(DM_APPBAR, "cwb.abr: fake ABN_STATECHANGE");
            _AppBarCallback(_hwnd, APPBAR_CALLBACK, ABN_STATECHANGE, 0);
            // #endif
        }
    }
    else if (!fRegister && _fAppRegistered) {
        TraceMsg(DM_APPBAR, "cwb.abr: call ABM_REMOVE");
        // n.b. sensitive phase ordering, must set flag before send message
        // since the message causes a bunch of callbacks
        _fAppRegistered = FALSE;
        SHAppBarMessage(ABM_REMOVE, &abd);
    }
}

//***   _SetVRect -- set our 'virtual rect' to reflect window state
//
void CDockingBar::_SetVRect(RECT* rcNew)
{
    UINT eModeNew, uSideNew;

    //ASSERT(_fDragging == 0);  // o.w. we should look at _xxxPending

    eModeNew = _eMode;
    uSideNew = _uSide;


    if (_fHiding && ISWBM_HIDEABLE(eModeNew)) {
        TraceMsg(DM_HIDE, "cwb.svr: _fHiding => suppress rcNew=(%d,%d,%d,%d)",
            rcNew->left, rcNew->top, rcNew->right, rcNew->bottom);
        return;
    }


    if (ISWBM_FLOAT(eModeNew)) {
        CopyRect(&_rcFloat, rcNew);
    }
    else {
        _adEdge[uSideNew] = ABE_HORIZ(uSideNew) ? RECTHEIGHT(*rcNew) : RECTWIDTH(*rcNew);
    }
    return;
}

//***   _ChangeTopMost -- switch back and forth btwn TopMost and BottomMost
// ENTRY/EXIT
//      eModeNew        new mode we're switching to
//
void CDockingBar::_ChangeTopMost(UINT eModeNew)
{
    BOOL fShouldRegister = (eModeNew & WBM_TOPMOST) && !(eModeNew & WBM_FLOATING);
    
    // here's what's legal...
//              to...................
// from         btm     top     float
// ----         ---     ---     -----
// btm(desk)    -       top+    y(1)    (1) force to top
// top          top-    -       'undock'
// float        y(2)    'dock'  -       (2) force to right
// btm(app)     -       x(3)    y(4)    (3) foster child (4) 'owned' window


#if 0
    // (1,4) going from BTMMOST to FLOATING is illegal (and NYI) unless desktop
    ASSERT(eModeNew != WBM_FLOATING || _eMode != WBM_BOTTOMMOST || ISWBM_DESKTOP());
#endif

    // (3) only desktop guys can go to TOPMOST
    ASSERT(eModeNew != WBM_TOPMOST || ISWBM_DESKTOP());

    // _uSide should always be laying around (even if floating)
    ASSERT(_eMode == WBM_NIL || ISABE_DOCK(_uSide));

    // note the ordering here, make sure window bits are right
    // before doing resume new or else new will have unexpected state
    _ChangeWindowStateAndParent(eModeNew);
    _eMode = eModeNew;
    _ChangeZorder();

    // resume new
    switch (_eMode) {
    case WBM_NIL:
        // dummy state for termination
        return;

    case WBM_BOTTOMMOST:
        _ResetZorder();
#if ! XXX_BROWSEROWNED
        // fall through
    case WBM_BBOTTOMMOST:
#endif
        break;
    }
    
    _AppBarRegister(fShouldRegister);
}

//***   _ChangeZorder -- set z-order appropriately
// NOTES
//  currently doesn't account for 'raised' mode (i.e. caller must call
//  _ChangeZorder before _ResetZorder)
void CDockingBar::_ChangeZorder()
{
    BOOL fWantTopmost = BOOLIFY(WBM_IS_TOPMOST());
    BOOL fIsTopmost = BOOLIFY(GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST);
    if (fWantTopmost != fIsTopmost)
        SetWindowPos(_hwnd, fWantTopmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    return;
}

//***    _ResetZorder -- toggle DockingBars between 'normal' and 'raised' mode
// DESCRIPTION
//  queries desktop state and does appropriate '_OnRaise'
//
void CDockingBar::_ResetZorder()
{
    HRESULT hr;
    VARIANTARG vaIn = {0};      // VariantInit
    VARIANTARG vaOut = {0};     // VariantInit

    vaIn.vt = VT_I4;
    vaIn.lVal = DTRF_QUERY;
    hr = IUnknown_Exec(_ptbSite, &CGID_ShellDocView, SHDVID_RAISE, OLECMDEXECOPT_DONTPROMPTUSER,
        &vaIn, &vaOut);
    if (SUCCEEDED(hr) && vaOut.vt == VT_I4)
        _OnRaise(vaOut.lVal);
    // VariantClear
    return;
}

//***   _OnRaise -- handle desktop 'raise' command
// DESCRIPTION
//  changes DockingBar z-order depending on desktop raise state:
//      desktop     DockingBar
//      raised      force on top (so visible)
//      restored    return to normal
// NOTES
//  FEATURE: should we handle WBM_FLOATING too?
//  FEATURE: should add ZORD_xxx to deskbar.h and handle non-WBM_BOTTOMMOST
void CDockingBar::_OnRaise(UINT flags)
{
    HWND hwndZorder;

    if (_eMode != WBM_BOTTOMMOST)
        return;

    switch (flags) {
    case DTRF_RAISE:
        hwndZorder = HWND_TOPMOST;
        break;

    case DTRF_LOWER:
        hwndZorder = HWND_NOTOPMOST;
        break;
    
    default:
        ASSERT(0);
        return;
    }

    SetWindowPos(_hwnd, hwndZorder, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

    return;
}

#if XXX_BTMFLOAT && 0 // see 'NOTES'
//***   _MayReWindow -- change/restore window state for dragging
// DESCRIPTION
//      USER won't let us drag outside of the browser unless we reparent
//      ourselves.
// NOTES
//      need to call this *before* we enter USER's move/size loop.
//      i.e. on LBUTTONDOWN and on EXITSIZEMOVE.  this gets a bit
//      tricky due to CANCEL etc., since the LBUTTONUP may come thru
//      either before or after we're done.
//
void CDockingBar::_MayReWindow(BOOL fToFloat)
{

    if (ISWBM_DESKTOP() || _eMode != WBM_BOTTOMMOST)
        return;

    // do style bits 1st or re-parenting breaks
    SHSetWindowBits(_hwnd, GWL_STYLE, WS_CHILD | WS_POPUP, fToFloat ? WS_POPUP | WS_CHILD);

    if (!fToFloat) {
        // float->btm

        // nuke owner
        SHSetParentHwnd(_hwnd, NULL);

        // parent
        SetParent(_hwnd, _hwndSite);
    }


    if (fToFloat) {
        // btm->float, set owner

        // parent
        SetParent(_hwnd, PARENT_FLOATING);

        // set owner
        ASSERT(_hwndSite != NULL);
        SHSetParentHwnd(_hwnd, _hwndSite);
    }
}
#endif


void CDockingBar::_GetStyleForMode(UINT eMode, LONG* plStyle, LONG* plExStyle, HWND* phwndParent)
{
    switch (eMode) {
    case WBM_NIL:
        *plStyle = WS_NIL;
        *plExStyle= WS_EX_NIL;
        *phwndParent = PARENT_NIL;
        break;

    case WBM_BBOTTOMMOST:
        *plStyle = WS_BBTMMOST;
        *plExStyle= WS_EX_BBTMMOST;
        *phwndParent = PARENT_BBTMMOST();
        break;

    case WBM_BOTTOMMOST:
        *plStyle = WS_BTMMOST;
        *plExStyle= WS_EX_BTMMOST;
        *phwndParent = PARENT_BTMMOST();
        break;

    case WBM_BFLOATING:
        // FEATURE: todo: FLOATING NYI
        *plStyle = WS_BFLOATING;
        *plExStyle = WS_EX_BFLOATING;
        *phwndParent = _hwndSite;
        break;

    case (WBM_FLOATING | WBM_TOPMOST):
    case WBM_FLOATING:
        // FEATURE: todo: FLOATING NYI
        *plStyle = WS_FLOATING;
        *plExStyle = WS_EX_FLOATING;
        *phwndParent = PARENT_FLOATING;
        break;

    case WBM_TOPMOST:
        *plStyle = WS_XTOPMOST;
        *plExStyle= WS_EX_XTOPMOST;
        *phwndParent = PARENT_XTOPMOST;
        break;
    }
#ifdef DEBUG // {
    if (_eMode == eMode) {
        // style, exstyle
        ASSERT(BITS_SET(GetWindowLong(_hwnd, GWL_STYLE), *plStyle));
        ASSERT(BITS_SET(GetWindowLong(_hwnd, GWL_EXSTYLE), *plExStyle & ~WS_EX_TOPMOST));

        // id
        ASSERT(GetWindowLong(_hwnd, GWL_ID) == 0);

        // parent 
        ASSERT(GetParent(_hwnd) == *phwndParent ||
               (ISWBM_OWNED(_eMode) && GetParent(_hwnd)==_hwndSite));
    }
#endif // }
}

//***   _ChangeWindowStateAndParent --
// NOTES
//      todo: make table-driven (ws1, ws2, etc.)
//
void CDockingBar::_ChangeWindowStateAndParent(UINT eModeNew)
{
    LONG ws1, wsx1, ws2, wsx2;
    HWND hwnd;

    if (eModeNew == _eMode) {
        // same mode, nothing to do
        return;
    }

    //
    // nuke old bits
    //
    _GetStyleForMode(_eMode, &ws1, &wsx1, &hwnd);


    //
    // set new bits
    //
    _GetStyleForMode(eModeNew, &ws2, &wsx2, &hwnd);

    // if it's going to be owned by the browser, 
    // override hwnd to our site's hwnd
    if (eModeNew & WBMF_BROWSER)
        hwnd = _hwndSite;

    // style, exstyle
    // (SWB can't do WS_EX_TOPMOST, we do it in caller w/ SWP)
    SHSetWindowBits(_hwnd, GWL_STYLE, ws1|ws2 , ws2);
    SHSetWindowBits(_hwnd, GWL_EXSTYLE, (wsx1|wsx2) & ~WS_EX_TOPMOST, wsx2);

    // id
    // (unchanged)
    HWND hwndParent = GetParent(_hwnd); 
    if (hwndParent != hwnd) {
        if (hwndParent != HWND_DESKTOP) {
            // float->btm, nuke owner
            SHSetParentHwnd(_hwnd, NULL);
        }

        // parent
        SetParent(_hwnd, hwnd);

        if (hwnd == _hwndSite) {
            // btm->float, set owner
            ASSERT(_hwndSite != NULL);
            SHSetParentHwnd(_hwnd, _hwndSite);
        }
    }
    //
    // force redraw
    //
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0,
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

    return;
}

//***   _SetNewMonitor --
// When the Desktop is our Docking Site, set the new monitor I am on
// and return the old monitor 
HMONITOR CDockingBar::_SetNewMonitor(HMONITOR hMonNew)
{
    HMONITOR hMonOld = NULL;
    if (ISWBM_DESKTOP() && _ptbSite)
    {
        IMultiMonitorDockingSite * pdds;
        HRESULT hresT = _ptbSite->QueryInterface(IID_IMultiMonitorDockingSite, (LPVOID *)&pdds);
        if (SUCCEEDED(hresT))
        {
            HMONITOR hMon;
            ASSERT(pdds);
            if (SUCCEEDED(pdds->GetMonitor(SAFECAST(this, IDockingWindow*), &hMon)))
            {
                if (hMon != hMonNew)
                {
                    pdds->RequestMonitor(SAFECAST(this, IDockingWindow*), &hMonNew);
                    pdds->SetMonitor(SAFECAST(this, IDockingWindow*), hMonNew, &hMonOld);
                    // These two should be the same, otherwise something wierd is happening -- dli
                    ASSERT(hMonOld == hMon);
                }
            }
            pdds->Release();
        }
    }
    
    return hMonOld;
}

//***   _GetBorderRect --
// NOTES
//      result in screen coordinates
//
void CDockingBar::_GetBorderRect(HMONITOR hMon, RECT* prc)
{
    if (!ISWBM_BOTTOM(_eMode)) {
        // FEATURE: todo: should use:
        // floating: _hwndSite (not strictly correct, but good enough)
        // topmost: UnionRect of:
        //     GetWindowRect(_hwndSite);        // non-appbar rect
        //     GetWindowRect(self)              // plus my personal appbar
        ASSERT(IsWindow(_hwndSite));
        if (ISWBM_DESKTOP())
            GetMonitorRect(hMon, prc);
        else
            GetWindowRect(_hwndSite, prc);  
#ifdef DEBUG
#if 0
        RECT rcTmp;

        // these asserts often fail.  e.g. when dragging topmost right->top.
        // weird: _hwndSite ends up being PROGMAN's hwnd.
        // weird: also, the GetWindowRect fails.
        ASSERT(_hwndSite == PARENT_XTOPMOST);
        // _hwndSite is PROGMAN
        GetWindowRect(PARENT_XTOPMOST, &rcTmp);
        ASSERT(EqualRect(prc, &rcTmp));
#endif
#endif
    }
    else if (_ptbSite) {
        HMONITOR hMonOld = _SetNewMonitor(hMon);
        _ptbSite->GetBorderDW(SAFECAST(this, IDockingWindow*), prc);
        if (hMonOld)
            _SetNewMonitor(hMonOld);
        ASSERT(_hwndSite != NULL);
        //ASSERT(GetParent(_hwnd) == _hwndSite);  // FEATURE ISWBM_OWNED?
        // convert if necessary
        // aka ClientToScreen
        MapWindowPoints(_hwndSite, HWND_DESKTOP, (POINT*) prc, 2);
    }

    return;
}

//***   _HideRegister -- (un)register auto-hide w/ edge
// ENTRY/EXIT
//      fToHide         TRUE if turning AutoHide on, FALSE if turning off
//      _fCanHide       [OUT] TRUE if successfully set autohide on; o.w. FALSE 
//      other           pops up dialog if operation fails
//
void CDockingBar::_HideRegister(BOOL fToHide)
{
    BOOL fSuccess;
    APPBARDATA abd;

    if (! ISWBM_HIDEABLE(_eMode))
        return;

    // (try to) register or unregister it
    // n.b. we're allowed to do this even if we're not an AppBar
    // that's good, because we want at most one autohide deskbar 
    // on an edge regardless of mode
    abd.cbSize = SIZEOF(abd);
    abd.hWnd = _hwnd;
    abd.uEdge = _uSide;
    abd.lParam = fToHide;

    // FEATURE should we do a ABM_GETAUTOHIDEBAR at some point?
    // (tray.c does, and so does the AB sample code...)
    //ASSERT(_fAppRegistered);
    fSuccess = (BOOL) SHAppBarMessage(ABM_SETAUTOHIDEBAR, &abd);

    // set our state
    _fCanHide = BOOLIFY(fSuccess);
    // FEATURE: how handle failure?

    // init some stuff
    if (fToHide)
    {
        if (_fCanHide)
        {
            RECT rc;

            ASSERT(_fCanHide);  // so we won't SetVRect

            ASSERT(!_fHiding);  // (paranoia)

            // force a '0-width' rectangle so we don't take up any space
            RectXform(&rc, RX_EDGE|RX_OPPOSE|RX_ADJACENT, &rc, NULL,
                0, _uSide, _hMon);

            switch (_eMode) {
            case WBM_TOPMOST:
                // negotiate/commit it
                APPBARDATA abd;
                abd.cbSize = sizeof(APPBARDATA);
                abd.hWnd = _hwnd;
                ASSERT(_fCanHide);
                // we used to do:
                //  _fCanHide = FALSE;  // hack: so we surrender AppBar's space
                //  AppBarQuerySetPos(&rc, _uSide, &rc, &abd, TRUE);
                //  _fCanHide = TRUE;   // hack: restore
                // but the instant we do the ABSetPos the shell does a recalc
                // by doing a ShowDW of all toolbars, which does a _Recalc,
                // which does a MSH, which ends up doing ProtoRect w/ our
                // 'temporary' _fCanHide=0, which ends up taking space (oops!).
                //
                // so instead we call the low-level ABQueryPos/ABSetPos guys
                // directly.
                AppBarQueryPos(&rc, _uSide, _hMon, &rc, &abd, TRUE);
                AppBarSetPos0(_uSide, &rc, &abd);
                break;
            }

            // do *not* start the hide here
            // it's up to the caller, since a) might want delay or
            // immediate and b) recursion pblms w/ _MoveSizeHelper
        }
        else
        {
            // FEATURE: do PostMessage a la tray.c?
            MLShellMessageBox(_hwnd,
                MAKEINTRESOURCE(IDS_ALREADYAUTOHIDEBAR),
                MAKEINTRESOURCE(IDS_WEBBARTITLE),
                MB_OK | MB_ICONINFORMATION);
            ASSERT(!_fCanHide);
        }
    }
    else
    {
        // do *not* start the unhide here
        // it's up to the caller, since a) might want delay or
        // immediate and b) recursion pblms w/ _MoveSizeHelper

        _fCanHide = FALSE;
    }

    return;
}

//***   IsNearPoint -- am i currently near specified point?
// ENTRY/EXIT
//  pptBase     (INOUT) IN previous cursor pos, OUT updated to current if !fNear
//  fNear       (ret) TRUE if near, o.w. FALSE
// NOTES
//  heuristic stolen from explorer/tray.c!TraySetUnhideTimer
//
BOOL IsNearPoint(/*INOUT*/ POINT *pptBase)
{
    POINT ptCur;
    int dx, dy, dOff, dNear;

    GetCursorPos(&ptCur);
    dx = pptBase->x - ptCur.x;
    dy = pptBase->y - ptCur.y;
    dOff = dx * dx + dy * dy;
    dNear = GetSystemMetrics(SM_CXDOUBLECLK) * GetSystemMetrics(SM_CYDOUBLECLK);
    if (dOff <= dNear)
        return TRUE;
    TraceMsg(DM_HIDE2, "cwb.inp: ret=0 dOff=%d dNear=%d", dOff, dNear);
    *pptBase = ptCur;
    return FALSE;
}

//***   _DoHide --
// DESCRIPTION
//      AHO_KILLDO              kill timer for 'do'   operation
//      AHO_SETDO               set  timer for 'do'   operation
//      AHO_KILLUN              kill timer for 'undo' operation
//      AHO_SETUN               set  timer for 'undo' operation
//      AHO_REG                 register
//      AHO_UNREG               unregister
//      AHO_MOVEDO              do the actual hide
//      AHO_MOVEUN              do the actual unhide
// NOTES
//  the _fIdtXxHide stuff stops us from doing a 2nd SetTimer before the
// 1st one comes in, which makes us never get the 'earlier' ticks.
//  this fixes nt5:142686: drag-over doesn't unhide.  it was caused by us
// getting a bunch of WM_NCHITTESTs in rapid succession (OLE asking us on
// a fast timer?).
//  REARCHITECT: i think there's a tiny race window on _fIdtXxHide (between the
// call to Set/Kill and the shadowing in _fIdtXxHide).  not sure we can
// even hit it, but if we do, i think the worst that happens is somebody
// doesn't hide or unhide for a while.
//
void CDockingBar::_DoHide(UINT uOpMask)
{
    TraceMsg(DM_HIDE, "cwb.dh enter(uOpMask=0x%x(%s))",
        uOpMask, DbMaskToMneStr(uOpMask, AHO_MNE));

    if (!ISWBM_HIDEABLE(_eMode)) {
        TraceMsg(DM_HIDE, "cwb.dh !ISWBM_HIDEABLE(_eMode) => suppress");
        return;
    }

    // nuke old timer
    if (uOpMask & AHO_KILLDO) {
        TraceMsg(DM_HIDE, "cwb.dh: KillTimer(idt_autohide)");
        KillTimer(_hwnd, IDT_AUTOHIDE);
        _fIdtDoHide = FALSE;
    }
    if (uOpMask & AHO_KILLUN) {
        TraceMsg(DM_HIDE, "cwb.dh: KillTimer(idt_autoUNhide)");
        KillTimer(_hwnd, IDT_AUTOUNHIDE);
        _fIdtUnHide = FALSE;
        _ptIdtUnHide.x = _ptIdtUnHide.y = -1;
    }

    if (uOpMask & (AHO_REG|AHO_UNREG)) {
        _HideRegister(uOpMask & AHO_REG);
    }

    if (uOpMask & (AHO_MOVEDO|AHO_MOVEUN)) {
        // tricky, tricky...
        // all the smarts are in _MoveSizeHelper, driven by _fHiding (and _fCanHide)
        // use correct one of (tiny,real)
        _fHiding = (uOpMask & AHO_MOVEDO) ? HIDE_AUTO : FALSE;

        TraceMsg(DM_HIDE, "cwb.dh: move _fHiding=%d", _fHiding);
        ASSERT(_fCanHide);                      // suppress SetVRect
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    }

    // start new timer
    if (_fCanHide) {
        if (uOpMask & AHO_SETDO) {
            TraceMsg(DM_HIDE, "cwb.dh: SetTimer(idt_autohide) fAlready=%d", _fIdtDoHide);
            if (!_fIdtDoHide) {
                _fIdtDoHide = TRUE;
                SetTimer(_hwnd, IDT_AUTOHIDE, DLY_AUTOHIDE, NULL);
            }
        }
        if (uOpMask & AHO_SETUN) {
            TraceMsg(DM_HIDE, "cwb.dh: SetTimer(idt_autoUNhide) fAlready=%d", _fIdtUnHide);
            // IsNearPoint hysteresis prevents us from unhiding when we happen
            // to be passed over on the way to something unrelated
            if (!IsNearPoint(&_ptIdtUnHide) || !_fIdtUnHide) {
                _fIdtUnHide = TRUE;
                SetTimer(_hwnd, IDT_AUTOUNHIDE, DLY_AUTOUNHIDE, NULL);
            }
        }
    }
    else {
#ifdef DEBUG
        if ((uOpMask & (AHO_SETDO|AHO_SETUN))) {
            TraceMsg(DM_HIDE, "cwb.dh: !_fCanHide => suppress AHO_SET*");
        }
#endif
    }

    return;
}

//***   SlideWindow -- sexy slide effect
// NOTES
//      stolen from tray.c
void SlideWindow(HWND hwnd, RECT *prc, HMONITOR hMonClip, BOOL fShow)
{
    RECT rcMonitor, rcClip;
    BOOL fRegionSet = FALSE; 

    SetRectEmpty(&rcMonitor);
    if (GetNumberOfMonitors() > 1)
    {
        GetMonitorRect(hMonClip, &rcMonitor);
        // aka ScreenToClient
        MapWindowPoints(HWND_DESKTOP, GetParent(hwnd), (LPPOINT)&rcMonitor, 2);     }

    // Future: We could loop on the following code for the slide effect 
    IntersectRect(&rcClip, &rcMonitor, prc);
    if (!IsRectEmpty(&rcClip))
    {
        HRGN hrgnClip;

        // Change the clip region to be relative to the upper left corner of prc
        // NOTE: this is not converting rcClip to prc client coordinate
        OffsetRect(&rcClip, -prc->left, -prc->top);
        
        hrgnClip = CreateRectRgnIndirect(&rcClip);
        // LINTASSERT(hrgnClip || !hgnClip);    // 0 semi-ok for SetWindowRgn
        // nt5:149630: always repaint, o.w. auto-unhide BitBlt's junk
        // from hide position
        fRegionSet = SetWindowRgn(hwnd, hrgnClip, /*fRepaint*/TRUE);
    }
    MoveWindow(hwnd, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), TRUE);

    // Turn off the region stuff if we don't hide any more
    if (fRegionSet && fShow)
        SetWindowRgn(hwnd, NULL, TRUE);

    return;
}

/***    AppBarQueryPos -- negotiate position
 * ENTRY/EXIT
 *      return  width (height) from docked edge to opposing edge
 */
int CDockingBar::AppBarQueryPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq,
    PAPPBARDATA pabd, BOOL fCommit)
{
    int iWH;

    ASSERT(ISWBM_DESKTOP());

    // snap to edge (in case another AppBar disappeared w/o us knowing),
    // readjust opposing side to reflect that snap,
    // and max out adjacent sides to fill up full strip.
    iWH = RectGetWH(prcReq, uEdge);
    
    RectXform(&(pabd->rc), RX_EDGE|RX_OPPOSE|RX_ADJACENT|(_fHiding ? RX_HIDE : 0), prcReq, NULL, iWH, uEdge, hMon);

    ASSERT(EqualRect(&(pabd->rc), prcReq));     // caller guarantees?

    // negotiate
    // if we're dragging we might not be registered yet (floating->docked)
    // in that case we'll just use the requested size (w/o negotiating).
    // ditto for if we're in the middle of a top/non-top mode switch.
    if (_fAppRegistered) {
        pabd->uEdge = uEdge;
        TraceMsg(DM_APPBAR, "cwb.abqp: call ABM_QUERYPOS");
        SHAppBarMessage(ABM_QUERYPOS, pabd);
    }

    // readjust opposing side to reflect the negotiation (which only
    // adjusts the moved edge-most side, not the opposing edge).
    // FEATURE: (dli) need to find the right hmonitor to pass  in
    RectXform(prcOut, RX_OPPOSE, &(pabd->rc), NULL, iWH, uEdge, hMon);

    return RectGetWH(prcOut, uEdge);
}

//***   AppBarSetPos --
// NOTES
//      does *not* do _SetVRect and MoveWindow, that's up to caller
//
void CDockingBar::AppBarSetPos(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd)
{
    ASSERT(_eMode == WBM_TOPMOST);

    if (!_fCanHide && _fAppRegistered)
        AppBarSetPos0(uEdge, prcReq, pabd);

    return;
}

void CDockingBar::AppBarSetPos0(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd)
{
    CopyRect(&(pabd->rc), prcReq);
    pabd->uEdge = uEdge;

    TraceMsg(DM_APPBAR, "cwb.absp: call ABM_SETPOS");
    ASSERT(_fAppRegistered);
    SHAppBarMessage(ABM_SETPOS, pabd);

    // APPCOMPAT workaround explorer bug: during dragging we get:
    //  querypos*; wm_winposchanged; querypos; setpos
    // the lack of a wm_winposchanged at the end screws up the
    // autohide bring-to-top code.
    ASSERT(pabd->cbSize == sizeof(APPBARDATA));
    ASSERT(pabd->hWnd == _hwnd);
    TraceMsg(DM_APPBAR, "cwb.absp: call ABM_WINPOSCHGED");
    SHAppBarMessage(ABM_WINDOWPOSCHANGED, pabd);

    // n.b. _SetVRect and MoveWindow done by caller

    return;
}

//***   AppBarQuerySetPos --
//
void CDockingBar::AppBarQuerySetPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq,
    PAPPBARDATA pabd, BOOL fCommit)
{
    RECT rcTmp;

    if (prcOut == NULL)
        prcOut = &rcTmp;

    AppBarQueryPos(prcOut, uEdge, hMon, prcReq, pabd, fCommit);
    if (fCommit) {
        AppBarSetPos(uEdge, prcOut, pabd);
        ASSERT(EqualRect(prcOut, &(pabd->rc))); // callers assume prcOut correct
    }

    return;
}

void CDockingBar::_AppBarOnSize()
{
    RECT rc;
    APPBARDATA abd;

    ASSERT(_eMode == WBM_TOPMOST);
    ASSERT(ISABE_DOCK(_uSide));

    if (!_fAppRegistered)
        return;

    // don't commit until done
    if (_fDragging)
        return;

    abd.cbSize = sizeof(APPBARDATA);
    abd.hWnd = _hwnd;

    GetWindowRect(_hwnd, &rc);
    AppBarQuerySetPos(NULL, _uSide, _hMon, &rc, &abd, TRUE);

    return;
}

void CDockingBar::_RemoveToolbar(DWORD dwFlags)
{
    if (_ptbSite) {
        // WM_DESTROY will do _ChangeTopMost(WBM_NIL) for us

        IDockingWindowFrame* ptbframe;
        HRESULT hresT=_ptbSite->QueryInterface(IID_IDockingWindowFrame, (LPVOID*)&ptbframe);
        if (SUCCEEDED(hresT)) {
            AddRef();   // guard against self destruction
            ptbframe->RemoveToolbar(SAFECAST(this, IDockingWindow*), dwFlags);
            ptbframe->Release();
            Release();
        }
    } else {
        CloseDW(0);
    }
}

void CDockingBar::_AppBarOnCommand(UINT idCmd)
{
    UINT eModeNew;

    switch (idCmd) {
    case IDM_AB_TOPMOST:
        eModeNew = _eMode ^ WBM_TOPMOST;
        _MoveSizeHelper(eModeNew, _uSide, _hMon, NULL, NULL, TRUE, TRUE);
        break;

    case IDM_AB_AUTOHIDE:
        if (_fWantHide)
        {
            // on->off
            _DoHide(AHO_KILLDO|AHO_UNREG);      // _ChangeHide
            _fWantHide = FALSE;
        }
        else
        {
            // off->on
            _fWantHide = TRUE;
            // don't do AHO_SETDO now, wait for WM_ACTIVATE(deactivate)
            _DoHide(AHO_REG);     // _ChangeHide
        }

        // force it to happen *now*
        // REARCHITECT potential race condition w/ the AHO_SETDO above,
        // but worst case that should cause a 2nd redraw (?).
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);

        if (SHIsChildOrSelf(GetActiveWindow(), _hwnd) != S_OK)
        {
            // nt5:148444: if we're already deactive, we need to kick off
            // the hide now.  this is needed e.g. for login when we load
            // persisted auto-hide deskbars.  they come up inactive so we
            // never get the initial deact to hide them.
            _OnActivate(MAKEWPARAM(WA_INACTIVE, FALSE), (LPARAM)(HWND)0);
        }

        break;
#ifdef DEBUG
    case IDM_AB_ACTIVATE:
        // REARCHITECT temporary until we make browser tell us about activation

        // note that since we're faking this w/ a menu our (normal) assumption
        // in WM_ENTERMENU is bogus so make sure you keep the mouse over
        // the BrowserBar during activation or it will hide away out from under
        // you and the Activate won't work...
        _OnActivate(MAKEWPARAM(_fActive ? WA_INACTIVE : WA_ACTIVE, FALSE),
            (LPARAM) (HWND) 0);
        _fActive = !_fActive;
        break;
#endif

    case IDM_AB_CLOSE:
        _OnCloseBar(TRUE);
        break;

    default:
        MessageBeep(0);
        break;
    }
}

BOOL CDockingBar::_OnCloseBar(BOOL fConfirm)
{
    _RemoveToolbar(0);
    return TRUE;
}

void CDockingBar::_AppBarOnWM(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_WINDOWPOSCHANGED:
    case WM_ACTIVATE:
        {
            APPBARDATA abd;

            abd.cbSize = sizeof(APPBARDATA);
            abd.hWnd = _hwnd;
            abd.lParam = (long) NULL;
            if (uMsg == WM_WINDOWPOSCHANGED) {
                TraceMsg(DM_APPBAR, "cwb.WM_WPC: call ABM_WINPOSCHGED");
                SHAppBarMessage(ABM_WINDOWPOSCHANGED, &abd);
            }
            else {
                //if (LOWORD(wParam) != WA_INACTIVE)
                // just do it always, doesn't hurt...
                TraceMsg(DM_APPBAR, "cwb.WM_ACT: call ABM_ACTIVATE");
                SHAppBarMessage(ABM_ACTIVATE, &abd);
            }
        }
        break;

    default:
        ASSERT(0);
        break;
    }

    return;
}

// try to preserve our thinkness
void CDockingBar::_AppBarOnPosChanged(PAPPBARDATA pabd)
{
    RECT rcWindow;

    ASSERT(_eMode == WBM_TOPMOST);

    GetWindowRect(pabd->hWnd, &rcWindow);
    RectXform(&rcWindow, RX_EDGE|RX_OPPOSE, &rcWindow, NULL, RectGetWH(&rcWindow, _uSide), _uSide, _hMon);

    _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    return;
}

/***    _InitPos4 -- initialize edge positions
 * ENTRY/EXIT
 *  fCtor       TRUE if called from constructor; o.w. FALSE
 */
void CDockingBar::_InitPos4(BOOL fCtor)
{
    RECT rcSite;

    TraceMsg(DM_PERSIST, "cdb.ip4(fCtor=%d) enter", fCtor);

    if (fCtor)
    {
        // set some worst-case defaults for the Load(bag) case
        _adEdge[ABE_TOP]    = 80;
        _adEdge[ABE_BOTTOM] = 80;
        _adEdge[ABE_LEFT]   = 80;
        _adEdge[ABE_RIGHT]  = 80;

        SetRect(&_rcFloat, 10, 10, 310, 310);       // FEATURE: todo: NYI
        _hMon = GetPrimaryMonitor();
    }
    else
    {
        // set up semi-reasonable defaults for the InitNew case
        ASSERT(_eInitLoaded == IPS_INITNEW);    // not req'd, but expected
        ASSERT(IsWindow(_hwndSite));
        GetWindowRect(_hwndSite, &rcSite);

        _adEdge[ABE_TOP]    = AB_THEIGHT(rcSite);
        _adEdge[ABE_BOTTOM] = AB_BHEIGHT(rcSite);
        _adEdge[ABE_LEFT]   = AB_LWIDTH(rcSite);
        _adEdge[ABE_RIGHT]  = AB_RWIDTH(rcSite);
        
        // FEATURE: (dli) should we ask _hwndSite for it's hmonitor?
        // This current implementation already seems acceptable -justmann
        _hMon = MonitorFromRect(&rcSite, MONITOR_DEFAULTTONULL);
        if (!_hMon)
        {
            POINT ptCenter;
            ptCenter.x = (rcSite.left + rcSite.right) / 2;
            ptCenter.y = (rcSite.top + rcSite.bottom) / 2;
            _hMon = MonitorFromPoint(ptCenter, MONITOR_DEFAULTTONEAREST);
        }

    }

    return;
}

/***    RectXform -- transform RECT
 * ENTRY/EXIT
 *      prcOut
 *      uRxMask
 *      prcIn           initial rect
 *      prcBound        bounding rect specifying min/max dimensions
 *      iWH
 *      uSide
 * DESCRIPTION
 *      RX_EDGE         set edgemost side  to extreme (0 or max)
 *      RX_OPPOSE       set opposing side  to edge + width
 *      RX_ADJACENT     set adjacent sides to extremes (0 and max)
 *      RX_GETWH        get distance to opposing side
 *
 *      Two common calls are:
 *      ...
 * NOTES
 *      Note that rcOut, rcIn, and rcSize can all be the same.
 */
int CDockingBar::RectXform(RECT* prcOut, UINT uRxMask,
    const RECT* prcIn, RECT* prcBound, int iWH, UINT uSide, HMONITOR hMon)
{
    RECT rcDef;
    int  iRet = 0;
    BOOL bMirroredWnd=FALSE;

    if (prcOut != prcIn && prcOut != NULL) {
        ASSERT(prcIn != NULL);  // used to do SetRect(prcOut,0,0,0,0)
        CopyRect(prcOut, prcIn);
    }

#ifdef DEBUG
    if (! (uRxMask & (RX_OPPOSE|RX_GETWH))) {
        ASSERT(iWH == -1);
        iWH = -1;       // try to force something to go wrong...
    }
#endif

    if (uRxMask & (RX_EDGE|RX_ADJACENT)) {
        if (prcBound == NULL) {
            prcBound = &rcDef;
            ASSERT(hMon);
            GetMonitorRect(hMon, prcBound);     // aka GetSystemMetrics(SM_CXSCREEN)
        }

        #define iXMin (prcBound->left)
        #define iYMin (prcBound->top)
        #define iXMax (prcBound->right);
        #define iYMax (prcBound->bottom);
    }

    if (uRxMask & (RX_EDGE|RX_OPPOSE|RX_HIDE|RX_GETWH)) {

        //
        // If docking is happening on a horizontal size, then...
        // 
        if ((ABE_LEFT == uSide) || (ABE_RIGHT == uSide)) {
            bMirroredWnd = (IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd)));
        }

        switch (uSide) {
        case ABE_TOP:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->top = iYMin;
                if (uRxMask & RX_OPPOSE)
                    prcOut->bottom = prcOut->top + iWH;
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left, prcOut->top - iWH + CXYHIDE(uSide));
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTHEIGHT(*prcIn);

            break;
        case ABE_BOTTOM:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->bottom = iYMax;
                if (uRxMask & RX_OPPOSE)
                    prcOut->top = prcOut->bottom - iWH;
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left, prcOut->bottom - CXYHIDE(uSide));
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTHEIGHT(*prcIn);

            break;
        case ABE_LEFT:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->left = iXMin;
                if (uRxMask & RX_OPPOSE) {
                    //
                    // If the parent of this docked window is mirrored, then it is placed and
                    // aligned to the right. [samera]
                    //
                    if (bMirroredWnd)
                        prcOut->left = prcOut->right - iWH;
                    else
                        prcOut->right = prcOut->left + iWH;
                }
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->left - iWH + CXYHIDE(uSide), prcOut->top);
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTWIDTH(*prcIn);

            break;
        case ABE_RIGHT:
            if (prcOut)
            {
                if (uRxMask & RX_EDGE)
                    prcOut->right = iXMax;
                if (uRxMask & RX_OPPOSE) {
                    //
                    // If the parent of this docked window is mirrored, then it is placed and
                    // aligned to the left
                    //
                    if (bMirroredWnd)
                        prcOut->right = prcOut->left + iWH;
                    else
                        prcOut->left = prcOut->right - iWH;
                }
                if (uRxMask & RX_HIDE)
                    MoveRect(prcOut, prcOut->right - CXYHIDE(uSide), prcOut->top);
            }
            if (uRxMask & RX_GETWH)
                iRet = RECTWIDTH(*prcIn);

            break;
        }
    }

    if ((uRxMask & RX_ADJACENT) && prcOut)
    {
        if (uSide == ABE_LEFT || uSide == ABE_RIGHT) {
            prcOut->top    = iYMin;
            prcOut->bottom = iYMax;
        }
        else {
            prcOut->left   = iXMin;
            prcOut->right  = iXMax;
        }
    }

    return iRet;
}

//***   _ProtoRect -- create best-guess proto rect for specified location
//
void CDockingBar::_ProtoRect(RECT* prcOut, UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, POINT* ptXY)
{
    if (ISWBM_FLOAT(eModeNew))
    {
        // start at last position/size, and move to new left-top if requested
        CopyRect(prcOut, &_rcFloat);
        if (ptXY != NULL)
            MoveRect(prcOut, ptXY->x, ptXY->y);

        // if we're (e.g.) floating on the far right and the display shrinks,
        // we need to reposition ourselves
        // PERF: wish we could do this at resolution-change time but
        // WM_DISPLAYCHANGE comes in too early (before our [pseudo] parent
        // has changed).
        if (eModeNew == WBM_FLOATING)
        {
            // make sure we're still visible
            // FEATURE todo: multi-mon
            RECT rcTmp;

            _GetBorderRect(hMonNew, &rcTmp);

            if (prcOut->left > rcTmp.right || prcOut->top > rcTmp.bottom)
            {
                // WARNING note we don't explicitly account for other toolbars
                // this may be a bug (though other apps seem to behave the
                // same way)
                MoveRect(prcOut,
                    prcOut->left <= rcTmp.right ? prcOut->left :
                        rcTmp.right - CXFLOAT(),
                    prcOut->top  <= rcTmp.bottom ? prcOut->top  :
                        rcTmp.bottom - CYFLOAT()
                );
            }

        }
    }
    else
    {
        ASSERT(ISABE_DOCK(uSideNew));
        if (_fCanHide && ISWBM_HIDEABLE(eModeNew))
        {
            // force a 'tiny' rectangle
            // (WARNING prcBound==NULL bogus for XXX_HIDEALL && XXX_BROWSEROWNED)
            RectXform(prcOut, RX_EDGE|RX_OPPOSE|RX_ADJACENT|(_fHiding ? RX_HIDE : 0),
                prcOut, NULL, _adEdge[uSideNew], uSideNew, hMonNew);
        }
        else
        {
            // get current rect, adjust opposing side per request
            _GetBorderRect(hMonNew, prcOut);    
            RectXform(prcOut, RX_OPPOSE, prcOut, NULL, _adEdge[uSideNew], uSideNew, hMonNew);

        }
    }

    return;
}

//***   _NegotiateRect --
// NOTES
//      will only return an approximate result in the non-commit case.
//
void CDockingBar::_NegotiateRect(UINT eModeNew, UINT uSideNew, HMONITOR hMonNew,
    RECT* rcReq, BOOL fCommit)
{
    switch (eModeNew) {
    case WBM_TOPMOST:
        APPBARDATA abd;
        abd.cbSize = sizeof(APPBARDATA);
        abd.hWnd = _hwnd;

        AppBarQuerySetPos(rcReq, uSideNew, hMonNew, rcReq, &abd, fCommit);
        if (_fCanHide)
        {
            // we did a query to adjust the adjacent sides (e.g. so we don't
            // cover up the 'start' menu when we unhide).  however that may
            // have also moved us in from the edge, which we don't want.
            // so snap back to edge.
            int iWH;

            iWH = RectGetWH(rcReq, uSideNew);
            RectXform(rcReq, RX_EDGE|RX_OPPOSE|(_fHiding ? RX_HIDE : 0), rcReq, NULL, iWH, uSideNew, hMonNew);
        }
        goto Ldefault;

    default:
    Ldefault:
        // everyone else just gives us what we want

        // but, we need to free up border
        _NegotiateBorderRect(NULL, NULL, fCommit);     // free up space

        break;

    case WBM_BOTTOMMOST:
    case WBM_BBOTTOMMOST:
        _NegotiateBorderRect(rcReq, rcReq, fCommit);
        break;
    }


    return;
}

void CDockingBar::_AppBarCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    APPBARDATA abd;

    ASSERT(_eMode == WBM_TOPMOST);

    abd.cbSize = sizeof(abd);
    abd.hWnd = hwnd;

    switch (wParam) {
    case ABN_FULLSCREENAPP:
        // when 1st  app goes   full-screen, move ourselves to BOTTOM;
        // when last app leaves full-screen, move ourselves back
        // todo: FullScreen(flg)
        {
            BOOL fIsTopmost = BOOLIFY(GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST);
            if (!lParam != fIsTopmost)
            {
                SetWindowPos(hwnd,
                    lParam ? HWND_BOTTOM : HWND_TOPMOST,
                    0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            }
        }
        break;

    case ABN_POSCHANGED:
        TraceMsg(DM_APPBAR, "cwb.abcb: ABN_POSCHANGED");

        // note that we do this even if _fHiding.  while we want
        // to stay snapped to the edge as a 'tiny' rect, a change
        // in someone else *should* effect our adjacent edges.
        //
        // FEATURE: unfortunately this currently causes 'jiggle' of a hidden
        // guy when another appbar moves (due to a SlideWindow of a 0-width
        // hidden guy and a rounded-up 8-pixel wide guy).  when we switch
        // to explorer's new offscreen hide that should go away.
        _AppBarOnPosChanged(&abd);
        break;
    }

    return;
}

HRESULT CDockingBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDockingBar, IDockingWindow),        // IID_IDockingWindow
        QITABENT(CDockingBar, IObjectWithSite),       // IID_IObjectWithSite
        QITABENT(CDockingBar, IPersistStreamInit),    // IID_IPersistStreamInit
        QITABENTMULTI(CDockingBar, IPersistStream, IPersistStreamInit), // IID_IPersistStream
        QITABENTMULTI(CDockingBar, IPersist, IPersistStreamInit), // IID_IPersist
        QITABENT(CDockingBar, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

HRESULT CDockingBar::QueryService(REFGUID guidService,
                                REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    //  Block IID_ITargetFrame, so we don't look like a frame of the
    //  window we are attached to
    if (IsEqualGUID(guidService, IID_ITargetFrame)
        ||IsEqualGUID(guidService, IID_ITargetFrame2)) {
        return hres;
    }

    hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
    if (FAILED(hres))
    {
        const GUID* pguidService = &guidService;
    
        if (IsEqualGUID(guidService, SID_SProxyBrowser)) {
            pguidService = &SID_STopLevelBrowser;
        }
    
        if (_ptbSite) {
            hres = IUnknown_QueryService(_ptbSite, *pguidService, riid, ppvObj);
        }
    }

    return hres;
}

void CDockingBar::_GrowShrinkBar(DWORD dwDirection)
{
    RECT    rcNew, rcOld;
    int     iMin;

    iMin = GetSystemMetrics(SM_CXVSCROLL) * 4;

    GetWindowRect(_hwnd, &rcNew);   
    rcOld = rcNew;
    
    switch(_uSide)
    {
        case ABE_TOP:
            if (VK_DOWN == dwDirection)
                rcNew.bottom += GetSystemMetrics(SM_CYFRAME);

            if (VK_UP == dwDirection)
                rcNew.bottom -= GetSystemMetrics(SM_CYFRAME);

            if ((rcNew.bottom - rcNew.top) < iMin)
                rcNew.bottom = rcNew.top + iMin;
            break;

        case ABE_BOTTOM:
            if (VK_UP == dwDirection)
                rcNew.top -= GetSystemMetrics(SM_CYFRAME);

            if (VK_DOWN == dwDirection)
                rcNew.top += GetSystemMetrics(SM_CYFRAME);

            if ((rcNew.bottom - rcNew.top) < iMin)
                rcNew.top = rcNew.bottom - iMin;
            break;

        case ABE_LEFT:
            if (VK_RIGHT == dwDirection)
                rcNew.right += GetSystemMetrics(SM_CXFRAME);

            if (VK_LEFT == dwDirection)
                rcNew.right -= GetSystemMetrics(SM_CXFRAME);

            if ((rcNew.right - rcNew.left) < iMin)
                rcNew.right = rcNew.left + iMin;
            break;
            
        case ABE_RIGHT:
            if (VK_LEFT == dwDirection)
                rcNew.left -= GetSystemMetrics(SM_CXFRAME);

            if (VK_RIGHT == dwDirection)
                rcNew.left += GetSystemMetrics(SM_CXFRAME);

            if ((rcNew.right - rcNew.left) < iMin)
                rcNew.left = rcNew.right - iMin;
            break;

    }

    if (!EqualRect(&rcOld, &rcNew))
    {
        int iWH;
        RECT rcScreen;

        // don't let the new size get > MonitorRect/2
        GetMonitorRect(_hMon, &rcScreen);   // aka GetSystemMetrics(SM_CXSCREEN)
        iWH = RECTGETWH(_uSide, &rcScreen);
        iWH /= 2;
        if (RECTGETWH(_uSide, &rcNew) > iWH) 
        {
            RectXform(&rcNew, RX_OPPOSE, &rcNew, NULL, iWH, _uSide, NULL);
        }

        _SetVRect(&rcNew);
        _Recalc();
    }
}


//*** CDockingBar::IOleCommandTarget::* {

HRESULT CDockingBar::Exec(const GUID *pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt,
    VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) {
        switch (nCmdID) {
        case SHDVID_RAISE:
            ASSERT(pvarargIn && pvarargIn->vt == VT_I4);
            if (pvarargIn->vt == VT_I4 && pvarargIn->lVal != DTRF_QUERY) {
                _OnRaise(pvarargIn->lVal);
                return S_OK;
            }
            break;  // e.g. DTRF_QUERY
        default:
            // note that this means we may get OLECMDERR_E_UNKNOWNGROUP
            // rather than OLECMDERR_E_NOTSUPPORTED for unhandled guys...
            break;
        }
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup)) 
    {
        if (DBCID_RESIZE == nCmdID)
        {
            _GrowShrinkBar(nCmdexecopt);
            return S_OK;
        }
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt,
        pvarargIn, pvarargOut);
}
// }

//*** CDockingBar::IDockingWindow::* {
//

HRESULT CDockingBar::SetSite(IUnknown* punkSite)
{
    ATOMICRELEASE(_ptbSite);

    if (punkSite)
    {
        HRESULT hresT;
        hresT = punkSite->QueryInterface(IID_IDockingWindowSite, (LPVOID*)&_ptbSite);

        IUnknown_GetWindow(punkSite, &_hwndSite);

        //
        // Check if we are under the desktop browser or not and set
        // the initial state correctly. (Always on top for Desktop)
        //
        IUnknown* punkT;
        hresT = punkSite->QueryInterface(SID_SShellDesktop, (LPVOID*)&punkT);
        if (SUCCEEDED(hresT))
        {
            _fDesktop = TRUE;
            punkT->Release();
        }

        if (!_fInitSited)
        {
            if (!_eInitLoaded)
            {
                // if we haven't initialized, do it now.
                InitNew();
                _eMode = WBM_BOTTOMMOST;
            }
                
            ASSERT(_eInitLoaded);
            if (_eInitLoaded == IPS_INITNEW)
            {
                _InitPos4(FALSE);
                _eMode = _fDesktop ? WBM_TOPMOST : WBM_BBOTTOMMOST;
            }
        }
        ASSERT(_eMode != WBM_NIL);
        // WARNING actually we could also be owned floating...
        ASSERT(ISWBM_DESKTOP() == _fDesktop);
        ASSERT(_fDesktop || _eMode == WBM_BBOTTOMMOST);
        ASSERT(ISWBM_DESKTOP() == _fDesktop);
        ASSERT(ISWBM_DESKTOP() || _eMode == WBM_BBOTTOMMOST);
    }

    _fInitSited = TRUE;     // done w/ 1st-time init

    return S_OK;
}

HRESULT CDockingBar::ShowDW(BOOL fShow)
{
    fShow = BOOLIFY(fShow);     // so comparisons and assigns to bitfields work

    // we used to early out if BOOLIFY(_fShow) == fShow.
    // however we now count on ShowDW(TRUE) to force a refresh
    // (e.g. when screen resolution changes CBB::v_ShowHideChildWindows
    // calls us)
    if (BOOLIFY(_fShow) == fShow)
        return S_OK;

    _fShow = fShow;

    if (!_fInitShowed)
    {
        ASSERT(_fInitSited && _eInitLoaded);
        _Initialize();
        ASSERT(_fInitShowed);
    }

    if (_fShow)
    {
        // FEATURE: switch to using _ChangeTopMost, it already does this... 
        // Tell itself to resize.

        // use _MoveSizeHelper (not just _NegotiateBorderRect) since we might
        // actually be moving to a new position...
        _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
        // _NegotiateBorderRect(NULL, NULL, FALSE)

        if (_pDBC)
            _pDBC->UIActivateDBC(DBC_SHOW);

        // nt5:148444: SW_SHOWNA (vs. SW_SHOW) so we don't unhide on create
        // this fix will cause a new bug -- newly created bars don't have
        // focus (e.g. drag a band to floating, the new floating bar won't
        // have focus) -- but that should be the lesser of evils.
        //ShowWindow(_hwnd, ISWBM_FLOAT(_eMode) ? SW_SHOWNORMAL : SW_SHOWNA);
        ShowWindow(_hwnd, SW_SHOWNA);
        _OnSize();
    }
    else
    {
        ShowWindow(_hwnd, SW_HIDE);
        if (EVAL(_pDBC))
            _pDBC->UIActivateDBC(DBC_SHOWOBSCURE);
        UIActivateIO(FALSE, NULL);
        
        // Tell itself to resize.

        // don't call MoveSizeHelper here since it will do (e.g.)
        // negotiation, which will cause flicker and do destructive stuff.
        //_Recalc();  //_MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
        _NegotiateBorderRect(NULL, NULL, TRUE);     // hide=>0 border space
    }

    return S_OK;
}

HRESULT CDockingBar::ResizeBorderDW(LPCRECT prcBorder,
    IUnknown* punkToolbarSite, BOOL fReserved)
{
    _Recalc();  // _MoveSizeHelper(_eMode, _uSide, NULL, NULL, TRUE, TRUE);
    return S_OK;    // FEATURE _NegotiateBorderRect()?
}

HRESULT CDockingBar::_NegotiateBorderRect(RECT* prcOut, RECT* prcReq, BOOL fCommit)
{
    UINT eMode, uSide;
    HMONITOR hMon;
    int iWH;

    // FEATURE: should be params like MSH etc.
    eMode = ((_fDragging == DRAG_MOVE) ? _eModePending : _eMode);
    uSide = ((_fDragging == DRAG_MOVE) ? _uSidePending : _uSide);
    hMon = ((_fDragging == DRAG_MOVE) ? _hMonPending : _hMon);

    if (prcOut != prcReq && prcOut != NULL && prcReq != NULL)
        CopyRect(prcOut, prcReq);

    if (_ptbSite) {
        RECT rcRequest = { 0, 0, 0, 0 };

        if (_fShow && ISWBM_BOTTOM(eMode)) {

            if (prcReq)
            {
                iWH = RectGetWH(prcReq, uSide);
                ASSERT(iWH == _adEdge[uSide]);
                if ((!_fCanHide) && uSide != ABE_NIL)
                    ((int*)&rcRequest)[uSide] = iWH;
            }
                
            if (_fTheater) {
                // MOVE TO CBROWSERBAR

                
                // we override the left that we request from the browser, but
                // we need to notify theater what the user has requested for the expaneded width
                VARIANTARG v = { 0 };
                v.vt = VT_I4;
                v.lVal = rcRequest.left;
                IUnknown_Exec(_ptbSite, &CGID_Theater, THID_SETBROWSERBARWIDTH, 0, &v, NULL);
                _iTheaterWidth = v.lVal;
                
                // if we're in theater mode, we can only be on the left and we only grab left border
                ASSERT(uSide == ABE_LEFT);

                // if we're in autohide mode, we request no space
                if (!_fNoAutoHide)
                    rcRequest.left = 0;

                // END MOVE TO CBROWSERBAR                
            }
        }

        // FEATURE: leave alone (at 0 from HideRegister?) if _fHiding==HIDE_AUTO
        HMONITOR hMonOld = _SetNewMonitor(hMon);  

        _ptbSite->RequestBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);
        if (fCommit) {
            RECT rcMirRequest;
            LPRECT lprcRequest = &rcRequest; 

            if (IS_WINDOW_RTL_MIRRORED(_hwnd) && 
                !IS_WINDOW_RTL_MIRRORED(GetParent(_hwnd))) {
                // Swap left and right.
                rcMirRequest.left   = rcRequest.right;
                rcMirRequest.right  = rcRequest.left;
                rcMirRequest.top    = rcRequest.top;
                rcMirRequest.bottom = rcRequest.bottom;

                lprcRequest = &rcMirRequest;
            }
            _ptbSite->SetBorderSpaceDW(SAFECAST(this, IDockingWindow*), lprcRequest);
        }

        if (_fShow && ISWBM_BOTTOM(eMode) && !_fTheater) {
            // were'd we end up (as a real rect not just a size)?
            // start w/ our full border area, then apply negotiated width.
            // however that may have also moved us in from the edge, which
            // we don't want if we're autohide, so snap back to edge if so.
            _ptbSite->GetBorderDW(SAFECAST(this, IDockingWindow*), prcOut);

            // aka ClientToScreen
            if (prcOut)
                MapWindowPoints(_hwndSite, HWND_DESKTOP, (POINT*) prcOut, 2);

            if ((!_fCanHide) && uSide != ABE_NIL)
                iWH = ((int*)&rcRequest)[uSide];
            
            RectXform(prcOut, (_fCanHide ? RX_EDGE : 0)|RX_OPPOSE|(_fHiding ? RX_HIDE : 0), prcOut, NULL, iWH, uSide, hMon);
        }
        
        if (hMonOld)
            _SetNewMonitor(hMonOld);

    }

    return S_OK;
}

// }

//*** CDockingBar::IPersistStream*::* {
//

HRESULT CDockingBar::IsDirty(void)
{
    return S_FALSE; // Never be dirty
}

//
// Persisted CDockingBar
//
struct SWebBar
{
    DWORD   cbSize;
    DWORD   cbVersion;
    UINT    uSide : 3;
    UINT    fWantHide :1;
    INT     adEdge[4];  // FEATURE: wordsize dependent
    RECT    rcFloat;    
    POINT   ptSiteCenter; // Center of the docking site -- in case of multiple docking sites

    UINT    eMode;
    UINT    fAlwaysOnTop;

    RECT    rcChild;
};

#define SWB_VERSION 8

HRESULT CDockingBar::Load(IStream *pstm)
{
    SWebBar swb = {0};
    ULONG cbRead;

    TraceMsg(DM_PERSIST, "cwb.l enter(this=%x pstm=%x) tell()=%x", this, pstm, DbStreamTell(pstm));

    ASSERT(!_eInitLoaded);
    HRESULT hres = pstm->Read(&swb, SIZEOF(swb), &cbRead);
#ifdef DEBUG
    // just in case we toast ourselves (offscreen or something)...
    static BOOL fNoPersist = FALSE;
    if (fNoPersist)
        hres = E_FAIL;
#endif
    
    if (hres==S_OK && cbRead==SIZEOF(swb)) {
        // REARCHITECT: this is not forward compatible!
        if (swb.cbSize==SIZEOF(SWebBar) && swb.cbVersion==SWB_VERSION) {

            _eMode = swb.eMode;
            _uSide = swb.uSide;
            _hMon  = MonitorFromPoint(swb.ptSiteCenter, MONITOR_DEFAULTTONEAREST);
            // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize
            _fWantHide = swb.fWantHide;
            memcpy(_adEdge, swb.adEdge, SIZEOF(_adEdge));
            _rcFloat = swb.rcFloat;
            _NotifyModeChange(0);

            // child (e.g. bandsite)
            ASSERT(_pDBC != NULL);
            if (_pDBC != NULL) {
                // require IPersistStreamInit?
                IPersistStream *ppstm;
                hres = _pDBC->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
                if (SUCCEEDED(hres)) {

                    // set the child size first because initialization layout might depend on it
                    SetWindowPos(_hwndChild, 0,
                                 swb.rcChild.left, swb.rcChild.top, RECTWIDTH(swb.rcChild), RECTHEIGHT(swb.rcChild),
                                 SWP_NOACTIVATE|SWP_NOZORDER);
                    
                    ppstm->Load(pstm);
                    ppstm->Release();
                }
            }

            _eInitLoaded = IPS_LOAD;    // what if OLFS of bands fails?
            TraceMsg(DM_PERSIST, "CDockingBar::Load succeeded");
        } else {
            TraceMsg(DM_ERROR, "CWB::Load failed swb.cbSize==SIZEOF(SWebBar) && swb.cbVersion==SWB_VERSION");
            hres = E_FAIL;
        }
    } else {
        TraceMsg(DM_ERROR, "CWB::Load failed (hres==S_OK && cbRead==SIZEOF(_adEdge)");
        hres = E_FAIL;
    }
    TraceMsg(DM_PERSIST, "cwb.l leave tell()=%x", DbStreamTell(pstm));
    return hres;
}

HRESULT CDockingBar::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    SWebBar swb = {0};
    RECT rcMonitor;

    swb.cbSize = SIZEOF(SWebBar);
    swb.cbVersion = SWB_VERSION;
    swb.uSide = _uSide;
    swb.eMode = _eMode;
    swb.fWantHide = _fWantHide;
    memcpy(swb.adEdge, _adEdge, SIZEOF(_adEdge));
    swb.rcFloat = _rcFloat;
    GetWindowRect(_hwndChild, &swb.rcChild);
    MapWindowRect(HWND_DESKTOP, _hwnd, &swb.rcChild);

    ASSERT(_hMon);
    GetMonitorRect(_hMon, &rcMonitor);
    swb.ptSiteCenter.x = (rcMonitor.left + rcMonitor.right) / 2;
    swb.ptSiteCenter.y = (rcMonitor.top + rcMonitor.bottom) / 2;
    
    hres = pstm->Write(&swb, SIZEOF(swb), NULL);
    if (SUCCEEDED(hres))
    {
        IPersistStream* ppstm;
        hres = _pDBC->QueryInterface(IID_IPersistStream, (LPVOID*)&ppstm);
        if (SUCCEEDED(hres))
        {
            hres = ppstm->Save(pstm, TRUE);
            ppstm->Release();
        }
    }
    
    return hres;
}

HRESULT CDockingBar::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ULARGE_INTEGER cbMax = { SIZEOF(SWebBar), 0 };
    *pcbSize = cbMax;
    return S_OK;
}

HRESULT CDockingBar::InitNew(void)
{
    ASSERT(!_eInitLoaded);
    _eInitLoaded = IPS_INITNEW;
    TraceMsg(DM_PERSIST, "CDockingBar::InitNew called");

    // can't call _InitPos4 until set site in SetSite
    // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize

    // derived class (e.g. CBrowserBarApp) does the _Populate...

    // on first creation, before bands are added, but the bandsite IS created, we need to notify the bandsite of the new position
    _NotifyModeChange(0);
    return S_OK;
}

HRESULT CDockingBar::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(!_eInitLoaded);

    _eInitLoaded = IPS_LOADBAG;

    // TODO: We'll read following properties.
    //
    //  URL = "..."
    //  Mode = 0 - TopMost, 1 - Bottom, 2 - Undocked
    //  Side = 0 - Right, 1 - Top, 2 - Left, 3 - Bottom
    //  Left/Right/Top/Bottom = Initial docked size
    //


    UINT uSide;
    UINT eMode = _eMode;

    if (WBM_NIL == eMode)
        eMode = WBM_BOTTOMMOST;
    
    eMode = PropBag_ReadInt4(pPropBag, L"Mode", eMode);
    uSide = PropBag_ReadInt4(pPropBag, L"Side", _uSide);
    _adEdge[ABE_LEFT] = PropBag_ReadInt4(pPropBag, L"Left", _adEdge[ABE_LEFT]);
    _adEdge[ABE_RIGHT] = PropBag_ReadInt4(pPropBag, L"Right", _adEdge[ABE_RIGHT]);
    _adEdge[ABE_TOP] = PropBag_ReadInt4(pPropBag, L"Top", _adEdge[ABE_TOP]);
    _adEdge[ABE_BOTTOM] = PropBag_ReadInt4(pPropBag, L"Bottom", _adEdge[ABE_BOTTOM]);

    int x = PropBag_ReadInt4(pPropBag, L"X", _rcFloat.left);
    int y = PropBag_ReadInt4(pPropBag, L"Y", _rcFloat.top);
    OffsetRect(&_rcFloat, x - _rcFloat.left, y - _rcFloat.top);

    int cx = PropBag_ReadInt4(pPropBag, L"CX", RECTWIDTH(_rcFloat));
    int cy = PropBag_ReadInt4(pPropBag, L"CY", RECTHEIGHT(_rcFloat));
    _rcFloat.right = _rcFloat.left + cx;
    _rcFloat.bottom = _rcFloat.top + cy;

    // set up vars for eventual CDockingBar::_Initialize call
    ASSERT(!CDB_INITED());
    _eMode = eMode;
    _uSide = uSide;
    
    POINT pt = {x, y};
    // (dli) compute the new hMonitor 
    _hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

    // don't call _SetModeSide, _MoveSizeHelper, etc. until *after* _Initialize

    // derived class (e.g. CBrowserBarApp) does the _Populate...

    // on first creation, before bands are added, but the bandsite IS created, we need to notify the bandsite of the new position
    _NotifyModeChange(0);
    return S_OK;
}

HRESULT CDockingBar::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    // We don't need to support this for now.
    return E_NOTIMPL;
}

// }

//*** CDockingBar::IDocHostUIHandler::* {
//

HRESULT CDockingBar::ShowContextMenu(DWORD dwID,
    POINT* ppt,
    IUnknown* pcmdtReserved,
    IDispatch* pdispReserved)
{
    if (dwID==0) {
        TraceMsg(DM_MENU, "cdb.scm: intercept");
        return _TrackPopupMenu(ppt);
    }
    return S_FALSE;
}


// }


void CDockingBar::_SetModeSide(UINT eMode, UINT uSide, HMONITOR hMonNew, BOOL fNoMerge) 
{
    _ChangeTopMost(eMode);
    _uSide = uSide;
    _hMon = hMonNew;
    _SetNewMonitor(hMonNew);
}


// *** IInputObjectSite methods ***

HRESULT CDockingBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return IUnknown_OnFocusChangeIS(_ptbSite, SAFECAST(this, IInputObject*), fSetFocus);
}


////////////////////////////////////////////////////////////////
//
//  A deskbar property bag
//////
HRESULT CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CDockingBarPropertyBag* p = new CDockingBarPropertyBag();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IPropertyBag*);
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

ULONG CDockingBarPropertyBag::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CDockingBarPropertyBag::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDockingBarPropertyBag::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDockingBarPropertyBag, IPropertyBag),     // IID_IPropertyBag
        QITABENT(CDockingBarPropertyBag, IDockingBarPropertyBagInit),     // IID_IDockingBarPropertyBagInit
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


const WCHAR * const c_szPropNames[] = {
    L"Side",
    L"Mode",
    L"Left",
    L"Top",
    L"Right",
    L"Bottom",
    L"Deleteable",
    L"X",
    L"Y",
    L"CX",
    L"CY"
};


HRESULT CDockingBarPropertyBag::Read( 
                    /* [in] */ LPCOLESTR pszPropName,
                    /* [out][in] */ VARIANT *pVar,
                    /* [in] */ IErrorLog *pErrorLog)
{
    int epropdata;

    for (epropdata = 0; epropdata < (int)PROPDATA_COUNT; epropdata++) {
        if (!StrCmpW(pszPropName, c_szPropNames[epropdata])) {
            break;
        }
    }

    if (epropdata < PROPDATA_COUNT && 
        _props[epropdata]._fSet) {
        pVar->lVal = _props[epropdata]._dwData;
        pVar->vt = VT_I4;
        return S_OK;
    }
    
    return E_FAIL;
}




#ifdef DEBUG
//***   DbCheckWindow --
// NOTES
//  FEATURE: Its a bad idea, why break working code, but here is the suggestion:
//  nuke the 'hwndClient' param and just use GetParent (but what
//  about 'owned' windows, does GetParent give the correct answer?)
BOOL DbCheckWindow(HWND hwnd, RECT *prcExp, HWND hwndClient)
{
    RECT rcAct;

    GetWindowRect(hwnd, &rcAct);
    hwndClient = GetParent(hwnd);   // nuke this param
    if (hwndClient != NULL) {
        // aka ClientToScreen
        MapWindowPoints(HWND_DESKTOP, hwndClient, (POINT*) &rcAct, 2);
    }
    if (!EqualRect(&rcAct, prcExp)) {
        TraceMsg(DM_TRACE,
            "cwb.dbcw: !EqualRect rcAct=(%d,%d,%d,%d) (%dx%d) rcExp=(%d,%d,%d,%d) (%dx%d) hwndClient=0x%x",
            rcAct.left, rcAct.top, rcAct.right, rcAct.bottom,
            RECTWIDTH(rcAct), RECTHEIGHT(rcAct),
            prcExp->left, prcExp->top, prcExp->right, prcExp->bottom,
            RECTWIDTH(*prcExp), RECTHEIGHT(*prcExp),
            hwndClient);
        return FALSE;
    }
    return TRUE;
}

//***   DbStreamTell -- get position in stream (low part only)
//
unsigned long DbStreamTell(IStream *pstm)
{
    if (pstm == 0)
        return (unsigned long) -1;

    ULARGE_INTEGER liEnd;

    pstm->Seek(c_li0, STREAM_SEEK_CUR, &liEnd);
    if (liEnd.HighPart != 0)
        TraceMsg(DM_TRACE, "DbStreamTell: hi!=0");
    return liEnd.LowPart;
}

//***   DbMaskToMneStr -- pretty-print a bit mask in mnemonic form
// ENTRY/EXIT
//  uMask       bit mask
//  szMne       mnemonics, sz[0] for bit 0 .. sz[N] for highest bit
//  return      ptr to *static* buffer
// NOTES
//  n.b.: non-reentrant!!!
TCHAR *DbMaskToMneStr(UINT uMask, TCHAR *szMnemonics)
{
    static TCHAR buf[33];       // FEATURE: non-reentrant!!!
    TCHAR *p;

    p = &buf[ARRAYSIZE(buf) - 1];       // point at EOS
    ASSERT(*p == '\0');
    for (;;) {
        if (*szMnemonics == 0) {
            ASSERT(uMask == 0);
            break;
        }

        --p;
        *p = (uMask & 1) ? *szMnemonics : TEXT('-');

        ++szMnemonics;
        uMask >>= 1;
    }

    return p;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dllreg.cpp ===
// dllreg.c -- autmatic registration and unregistration
//
#include "priv.h"
#include <advpub.h>
#include <comcat.h>
#include <winineti.h>
#include "resource.h"
#include "regkeys.h"
#include "DllRegHelper.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

void AddNotepadToOpenWithList();

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


// ISSUE/010429/davidjen      need to register typelib LIBID_BrowseUI
// before checkin in verify if this typelib already gets registered by setup!!!!!!!
#ifndef ATL_ENABLED
#define ATL_ENABLED
#endif

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
#ifdef ATL_ENABLED
BOOL UnregisterTypeLibrary
(
    const CLSID* piidLibrary
)
{
    TCHAR szScratch[GUID_STR_LEN];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ|KEY_WRITE, &hk))
    {
        SHDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }

    return TRUE;
}
#endif

#ifdef ATL_ENABLED
HRESULT SHRegisterTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD dwPathLen;
    WCHAR wzModuleName[MAX_PATH];

    // Load and register our type library.
    //
    dwPathLen = GetModuleFileName(HINST_THISDLL, wzModuleName, ARRAYSIZE(wzModuleName));

#ifdef UNIX
    dwPathLen = ConvertModuleNameToUnix( wzModuleName );
#endif

    hr = LoadTypeLib(wzModuleName, &pTypeLib);

    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_BrowseUI);
        hr = RegisterTypeLib(pTypeLib, wzModuleName, NULL);

        if (FAILED(hr))
        {
            TraceMsg(DM_WARNING, "sccls: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(DM_WARNING, "sccls: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}
#endif


void SetBrowseNewProcess(void)
// We want to enable browse new process by default on high capacity
// machines.  We do this in the per user section so that people can
// disable it if they want.
{
    static const TCHAR c_szBrowseNewProcessReg[] = REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess");
    static const TCHAR c_szBrowseNewProcess[] = TEXT("BrowseNewProcess");
    
    // no way if less than ~30 meg (allow some room for debuggers, checked build etc)
    MEMORYSTATUS ms;
    SYSTEM_INFO  si;

    ms.dwLength=sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&ms);
    GetSystemInfo(&si);

    if (!g_fRunningOnNT && ((si.dwProcessorType == PROCESSOR_INTEL_486) ||
                            (si.dwProcessorType == PROCESSOR_INTEL_386)))
    {
        // Bail if Win9x and 386 or 486 cpu
        return;
    }
        

    if (ms.dwTotalPhys < 30*1024*1024)
        return;
    
    SHRegSetUSValue(c_szBrowseNewProcessReg, c_szBrowseNewProcess, REG_SZ, TEXT("yes"), SIZEOF(TEXT("yes")), SHREGSET_FORCE_HKLM);
}


/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/

#define SIZE_FLAG   sizeof(" -nohome")

BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf,
    IN  BOOL  bInsertQuotes)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_REGKEY_IEXPLOREA, 0, KEY_QUERY_VALUE, &hkey))
    {
        TraceMsg(TF_ERROR, "GetIEPath(): RegOpenKey( %s ) Failed", c_szIexploreKey) ;
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        if (bInsertQuotes)
            lstrcatA(pszBuf, "\"");

        cbBrowser = CbFromCchA(cchBuf - SIZE_FLAG - 4);
        if (NO_ERROR != RegQueryValueExA(hkey, "", NULL, &dwType, 
                                         (LPBYTE)&pszBuf[bInsertQuotes?1:0], &cbBrowser))
        {
            TraceMsg(TF_ERROR, "GetIEPath(): RegQueryValueEx() for Iexplore path failed");
        }
        else
        {
            bRet = TRUE;
        }

        if (bInsertQuotes)
            lstrcatA(pszBuf, "\"");

        RegCloseKey(hkey);
    }

    return bRet;
}


//
// The actual functions called
//


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.
*/
HRESULT 
CallRegInstall(
    LPSTR pszSection,
    BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            // Get the location of iexplore from the registry
            if ( !GetIEPath(szIEPath, SIZECHARS(szIEPath), TRUE) )
            {
#ifndef UNIX
                // Failed, just say "iexplore"
                lstrcpyA(szIEPath, "iexplore.exe");
                AssertMsg(0, TEXT("IE.INF either hasn't run or hasn't set the AppPath key.  NOT AN IE BUG.  Look for changes to IE.INX."));
#else
                lstrcpyA(szIEPath, "iexplorer");
#endif
            }

            if (g_fRunningOnNT)
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hinst, pszSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        else
            TraceMsg(DM_ERROR, "DLLREG CallRegInstall() calling GetProcAddress(hinstAdvPack, \"RegInstall\") failed");

        FreeLibrary(hinstAdvPack);
    }
    else
        TraceMsg(DM_ERROR, "DLLREG CallRegInstall() Failed to load ADVPACK.DLL");

    return hr;
}

const CATID * const c_InfoBandClasses[] =
{
    &CLSID_SearchBand,
    &CLSID_MediaBand,
    NULL
};

void RegisterCategories(BOOL fRegister)
{
    enum DRH_REG_MODE eRegister = fRegister ? CCR_REG : CCR_UNREG;

    DRH_RegisterOneCategory(&CATID_InfoBand, IDS_CATINFOBAND, c_InfoBandClasses, eRegister);
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;  //used to return the first failure
    TraceMsg(DM_TRACE, "DLLREG DllRegisterServer() Beginning");

#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllRegisterServer");
        DEBUG_BREAK;
    }
#endif

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstAdvPack = LoadLibraryA("ADVPACK.DLL");
    hr = THR(CallRegInstall("InstallControls", FALSE));
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

#ifdef ATL_ENABLED
    // registers object, typelib and all interfaces in typelib
    hr = SHRegisterTypeLib();
    if (SUCCEEDED(hrExternal))
        hrExternal = hr;
#endif

    return hrExternal;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    TraceMsg(DM_TRACE, "DLLREG DllUnregisterServer() Beginning");

    // UnInstall the registry values
    hr = THR(CallRegInstall("UnInstallControls", TRUE));

    return hr;
}

void ImportQuickLinks();
/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    HRESULT hrExternal = S_OK;

    HRESULT hrInit = SHCoInitialize();
    if (bInstall)
    {
        // "U" means it's the per user install call
        if (pszCmdLine && (lstrcmpiW(pszCmdLine, L"U") == 0))
        {
            ImportQuickLinks();
            if (GetUIVersion() >= 5)
            {
                // don't upgrade these on XP -> XPSP#
                BOOL fUpgradeUserSettings = TRUE;
                WCHAR szVersion[50]; // plenty big for aaaa,bbbb,cccc,dddd
                DWORD cbVersion = sizeof(szVersion);
                if (ERROR_SUCCESS==SHGetValueW(HKEY_CURRENT_USER,
                        L"Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11cf-8B85-00AA005B4383}",L"Version", // guid is ie4uninit's Active Setup (it calls browseu's selfreg)
                        NULL, szVersion, &cbVersion))
                {
                    __int64 nverUpgradeFrom;
                    __int64 nverWinXP;
                    if (SUCCEEDED(GetVersionFromString64(szVersion, &nverUpgradeFrom)) &&
                        SUCCEEDED(GetVersionFromString64(L"6,0,2600,0000", &nverWinXP)))
                    {
                        fUpgradeUserSettings = nverUpgradeFrom < nverWinXP;
                    }
                }
                if (fUpgradeUserSettings)
                {
                    hr = THR(CallRegInstall("InstallPerUser_BrowseUIShell", FALSE));
                }
            }
        }
        else
        {
            SetBrowseNewProcess();
            // Backup current associations because InstallPlatformRegItems() may overwrite.
            if (GetUIVersion() < 5)
                hr = THR(CallRegInstall("InstallBrowseUINonShell", FALSE));
            else
                hr = THR(CallRegInstall("InstallBrowseUIShell", FALSE));
            if (SUCCEEDED(hrExternal))
                hrExternal = hr;

            if (!IsOS(OS_WHISTLERORGREATER))
            {
                hr = THR(CallRegInstall("InstallBrowseUIPreWhistler", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }
        
            if (IsOS(OS_NT))
            {
                hr = THR(CallRegInstall("InstallBrowseUINTOnly", FALSE));
                if (SUCCEEDED(hrExternal))
                    hrExternal = hr;
            }

            RegisterCategories(TRUE);

#ifdef ATL_ENABLED
            SHRegisterTypeLib();
#endif
        }

        // Add Notepad to the OpenWithList for .htm files
        AddNotepadToOpenWithList();
    }
    else
    {
        hr = THR(CallRegInstall("UnInstallBrowseUI", TRUE));
        if (SUCCEEDED(hrExternal))
            hrExternal = hr;

#ifdef ATL_ENABLED
        UnregisterTypeLibrary(&LIBID_BrowseUI);
#endif
        RegisterCategories(FALSE);
    }

    SHCoUninitialize(hrInit);
    return hrExternal;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dockbar.h ===
#ifndef DOCKBAR_H_
#define DOCKBAR_H_

#include "basebar.h"
//      local macros
//
// configurable constants

#define XXX_NEW         0       // 1=turn on work-in-progress
#define XXX_BROWSEROWNED    0   // 1:browser deskbar is owned (proto)
#define XXX_CHEEDESK    0       // 1:chee's desktop (vs. _fDesktop)
#define XXX_BTMFLOAT    0       // 0=allow dragging from non-desk-btm->float
#define XXX_HIDE        1       // 1=turn on autohide (work-in-progress)
#define XXX_HIDEALL     1       // 1=enable autohide in browsers (non-topmost)


#define XXX_CANCEL      0       // 1=use experimental CANCEL code
#define XXX_NEWSLIDE    0       // 1=use new SlideWindow code

#ifndef UNREFERENCED_PARM
#define UNREFERENCED_PARM(p)    (p)      // ARGUSED
#endif

//***   _PM, _PX -- lazy shorthands
// DESCRIPTION
//      _PM     check for p==NULL before doing p->m
//      _PX     check for p==NULL before doing EXPR(p)
//
#define _PM(p, m)       ((p) ? (p)->m : (-1))
#define _PX(p, x)       ((p) ? (x) : (-1))

#define BITS_SET(v, m)  (((v) & (m)) == (m))

//***   IN, OUT, INOUT --
//
#define IN
#define OUT
#define INOUT

#ifndef NOCDESKBAR
#include "dhuihand.h"

//========================================================================
// class CDeskBar (CDeskBar* pwbar)
// NOTES
//  we don't use CObjectWithSite because we want _ptbSite not _punkSite.
//========================================================================
class CDockingBar : public CBaseBar
                ,public IDockingWindow
                ,public IObjectWithSite     // n.b. *not* CObjectWithSite
                ,public IPersistStreamInit
                ,public IPersistPropertyBag
                ,public CDocHostUIHandler
{
public:
    // *** IUnknown -- disambiguate ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CBaseBar::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CBaseBar::Release(); }

    // *** IOleWindow -- disambiguate ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd)
        { return CBaseBar::GetWindow(lphwnd); }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode)
        { return CBaseBar::ContextSensitiveHelp(fEnterMode); }

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved) { return CBaseBar::CloseDW(dwReserved); }
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
        IUnknown* punkToolbarSite, BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    // NOTE: I sure hope E_NOTIMPL is ok?
    virtual STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { ASSERT(0); *ppvSite = NULL; return E_NOTIMPL; };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IPersistStreamInit ***
    //virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);
    virtual STDMETHODIMP InitNew(void);

    // *** IPersistPropertyBag ***
    virtual STDMETHODIMP Load(IPropertyBag *pPropBag,
                                           IErrorLog *pErrorLog);
    virtual STDMETHODIMP Save(IPropertyBag *pPropBag,
                        BOOL fClearDirty, BOOL fSaveAllProperties);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);
    
    // *** IDocHostUIHandler methods ***
    virtual STDMETHODIMP ShowContextMenu(DWORD dwID,
        POINT* ppt, IUnknown* cmdtReserved, IDispatch* pdispReserved);

protected:
    // Constructor & Destructor
    CDockingBar();
    virtual ~CDockingBar();
    
    void _Initialize();         // 2nd-phase ctor
    virtual void _SetModeSide(UINT eMode, UINT uSide, HMONITOR hMon, BOOL fNoMerge);
    virtual void _OnPostedPosRectChange();
    virtual void _GetChildPos(LPRECT prc);
    virtual void _GetStyleForMode(UINT eMode, LONG* plStyle, LONG* plExStyle, HWND* phwndParent);
    
    friend HRESULT CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend HRESULT BrowserBar_Create(IUnknown** ppunk, IUnknown** ppbs);

    // Private members
    HMENU _GetContextMenu();

    virtual LRESULT _OnCommand(UINT msg, WPARAM wparam, LPARAM lparam);
    void _ChangeTopMost(UINT eModeNew);
    void _ChangeWindowStateAndParent(UINT eModeNew);
    void _ChangeZorder();
    void _ResetZorder();
    virtual void _OnRaise(UINT flags);
#if XXX_BTMFLOAT && 0
    void _MayReWindow(BOOL fToFloat);
#endif
    
    virtual void _NotifyModeChange(DWORD dwMode);
    void _GetBorderRect(HMONITOR hMon, RECT* prc);
    HRESULT _NegotiateBorderRect(RECT* prcOut, RECT* prcReq, BOOL fCommit);
    virtual void _OnSize(void);
    void _InitPos4(BOOL fCtor);
    void _ProtoRect(RECT* prcOut, UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, POINT* ptXY);
    void _NegotiateRect(UINT eModeNew, UINT uSideNew, HMONITOR hMonNew, RECT* rcReq, BOOL fCommit);
    void _MoveSizeHelper(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew,
        POINT* ptTrans, RECT* rcFeed, BOOL fCommit, BOOL fMove);
    void _SetVRect(RECT* rcNew);
    void _Recalc(void);

    LRESULT _CalcHitTest(WPARAM wParam, LPARAM lParam);

    void _DragEnter(UINT uMsg, int xCursor, int yCursor, RECT* rcFeed);
    void _DragTrack(UINT uMsg, int xCursor, int yCursor, RECT* rcFeed, int eState);
    void _DragLeave(int x, int y, BOOL fCommit);
    void _ExecDrag(int eDragging);

    void _TrackSliding(int x, int y, RECT* rcFeed,
        BOOL fCommit, BOOL fMove);
    UINT _CalcDragPlace(POINT& pt, HMONITOR * hMon);
    void _SmoothDragPlace(UINT eModeNew, UINT eSideNew, HMONITOR hMonNew, INOUT POINT* pt, RECT* rcFeed);
    void _RemoveToolbar(DWORD dwFlags);

    HRESULT _TrackPopupMenu(const POINT* ppt);
    HMONITOR _SetNewMonitor(HMONITOR hMonNew);

    void _HideRegister(BOOL fToHide);
    void _DoHide(UINT uOpMask);
    virtual void _HandleWindowPosChanging(LPWINDOWPOS pwp);
    virtual void _GrowShrinkBar(DWORD dwDirection);

#if 0
    void _DoManHide(UINT uOpMask);
#endif
        // for _DoHide and _DoManHide
        enum aho {
            AHO_KILLDO  = 0x01,
            AHO_SETDO   = 0x02,
            AHO_KILLUN  = 0x04,
            AHO_SETUN   = 0x08,
            AHO_REG     = 0x10,
            AHO_UNREG   = 0x20,
            AHO_MOVEDO  = 0x40,
            AHO_MOVEUN  = 0x80
        };

        #define AHO_MNE         TEXT("ksKSrRmM")

    void _AppBarRegister(BOOL fRegister);
    void _AppBarOnSize();
    void _AppBarOnCommand(UINT idCmd);
    void _AppBarOnWM(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _AppBarOnPosChanged(PAPPBARDATA pabd);
    void _AppBarCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    int AppBarQueryPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq, PAPPBARDATA pabd, BOOL fCommit);
    void AppBarSetPos(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd);
    void AppBarSetPos0(UINT uEdge, const RECT* prcReq, PAPPBARDATA pabd);
    void AppBarQuerySetPos(RECT* prcOut, UINT uEdge, HMONITOR hMon, const RECT* prcReq, PAPPBARDATA pabd, BOOL fCommit);
    LRESULT _OnNCHitTest(WPARAM wParam, LPARAM lParam);

    void _AdjustToChildSize();

    // Window procedure
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnActivate(WPARAM wParam, LPARAM lParam);

    virtual BOOL _OnCloseBar(BOOL fConfirm);


#define RX_EDGE         0x01
#define RX_OPPOSE       0x02
#define RX_ADJACENT     0x04
#define RX_GETWH        0x08
#define RX_HIDE         0x10

    //
    // We need to do a get window in side this function so that we
    // can mirror the edges. I changed them to non-static. [samera]
    //
    int RectXform(RECT* prcOut, UINT uRxMask,
        const RECT* prcIn, RECT* prcBound, int iWH, UINT uSide, HMONITOR hMon);
    
    int RectGetWH(const RECT* prcReq, UINT uSide) {
        return RectXform(NULL, RX_GETWH, prcReq, NULL, -1, uSide, NULL);
    }

    void RectSetWH(RECT* prcReq, int iWH, UINT uSide) {
        RectXform(prcReq, RX_OPPOSE, prcReq, NULL, iWH, uSide, NULL);
        return;
    }

    // Member variables
    IDockingWindowSite*  _ptbSite;           // owner
    INT             _adEdge[4];             // edges' widths (or heights)
    RECT            _rcFloat;               // floating position
    HMONITOR        _hMon;                  // the monitor I am on
    POINT           _ptIdtUnHide;           // unhide hysteresis cursor pos

    // Variable initialized IPersistPropertyBag::Load
    // ...

    // Bit fields
    UINT            _uSide:3;               // edge we're on (ABE_*)
    // 3 states to initialization (4 w/ ctor)
    BITBOOL         _fInitSited:1;          // SetSite done
    UINT            _eInitLoaded:2;         // Load (or InitNew) done
    BITBOOL         _fInitShowed:1;         // Show done
#if ! XXX_CHEEDESK
    BITBOOL         _fDesktop:1;            // 1:hosted by desktop (vs. browser)
#endif
    UINT            _fDragging:2;           // we're dragging
    BITBOOL         _fWantHide:1;           // 1:autohide requested (in UI)
    BITBOOL         _fDeleteable:1;         // when we close we should signal our parent to delete our info
    BITBOOL         _fAppRegistered:1;      // Registered as an appbar

    // Member variables (drag&drop, sizing, ...)
    UINT            _uSidePending:3;        // ...
    BITBOOL         _fCanHide:1;            // 1:autohide granted (registered)
    BOOL            _fHiding:2;             // hide mode (HIDE_*)
    BITBOOL         _fIdtDoHide:1;          // 1:IDT_AUTOHIDE running
    BITBOOL         _fIdtUnHide:1;          // 1:IDT_AUTOUNHIDE running

    UINT            _eMode;               // mode we're in (WBM_*)
    UINT            _eModePending;        // pending drag state
    
    LPARAM          _xyPending;             // pending drag state
    RECT            _rcPending;             // ...
    HMONITOR        _hMonPending;           // pending monitor 
#ifdef DEBUG
    // temporary until we make browser tell us about activation
    BOOL            _fActive:1;             // 1:window is active
#endif

    
    // MOVE TO CBROWSERBAR    
    BITBOOL _fTheater :1;
    BITBOOL _fNoAutoHide :1;
    int _iTheaterWidth;
    // END MOVE TO CBROWSERBAR
};

#define WBM_IS_TOPMOST() (_eMode & WBM_TOPMOST)

#endif //NOCDESKBAR

//***   CASSERT -- compile-time assert
// DESCRIPTION
//      Like Assert, but checked at compile-time, and generates no code
//      Note that the expr must of course be constant...
#ifndef UNIX
#define CASSERT(e)      extern int dummy_array[(e)]
#else
#define CASSERT(e)      
#endif

//***   ABE_* -- helpers, etc. for ABE_*'s
//

//***   ABE_X* -- extended ABE_*'s
// DESCRIPTION
//      ABE_NIL: distinguished value (unused?).
//
//      ABE_XFLOATING: normally we carry around a (mode,side) pair.  this
//      works fine but is a pain in the (rare) case that we want to return
//      a pair.  so we have a 'special' side which means we're really
//      floating.  (alternatives considered included combining the two via
//      bit magic, or passing by reference.  none stood out as a great
//      sol'n, and we only use it one place.  a hack?  perhaps...)
#define ABE_NIL         ((UINT) 0x07)   // nil (-1 as a 3-bit field) (ugh!)
#define ABE_XFLOATING   ((UINT) 4)      // floating (undocked)
CASSERT((ABE_LEFT|ABE_RIGHT|ABE_TOP|ABE_BOTTOM) == 3);  // 0..3

#define ISABE_DOCK(abe) ((UINT)(abe) <= 3)

#define ABE_TO_IDM(abe) (IDM_AB_LEFT + (abe))
#define IDM_TO_ABE(abe) ((abe) - IDM_AB_LEFT)
CASSERT(IDM_AB_BOTTOM - IDM_AB_LEFT == 3);      // make sure LEFT is 0th

//***   ABE_HORIZ -- is ABE_* horizontal?
// #define ABE_HORIZ(e) ((e) == ABE_TOP || (e) == ABE_BOTTOM)
#define ABE_HORIZ(e)    ((e) & 1)
CASSERT(ABE_HORIZ(ABE_TOP) && ABE_HORIZ(ABE_BOTTOM));
CASSERT(! ABE_HORIZ(ABE_LEFT) && ! ABE_HORIZ(ABE_RIGHT));


#define APPBAR_CALLBACK (WM_USER + 73)  // REARCHITECT: bad bad bad, I don't know why this is bad but it's previous tagname was unacceptable, perhaps someone should look at this someday - justmann


//***   WS_*, etc. -- window bits, etc. for various modes
// NOTES
//      REVIW Don't use SM_CAPTION because it doesn't work properly yet.
//      WS_XTOPMOST w/ an 'X' to avoid collision w/ WS_TOPMOST...

#define WS_NIL          (WS_POPUP|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_NIL       (WS_EX_TOOLWINDOW /*|WS_EX_WINDOWEDGE*/)
#define PARENT_NIL      (HWND_DESKTOP)

#define WS_XTOPMOST     (WS_POPUP|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_XTOPMOST  (WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE)
#define PARENT_XTOPMOST (HWND_DESKTOP)

#define WS_BTMMOST      (WS_POPUP|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS)
#define WS_EX_BTMMOST   (WS_EX_TOOLWINDOW|WS_EX_WINDOWEDGE)
#define PARENT_BTMMOST() HWND_DESKTOP

#if 0
// 970208 keep this around for 1 week in case the autosize bug isn't fixed
#define WS_BTMMOST      WS_BBTMMOST
#define WS_EX_BTMMOST   WS_EX_BBTMMOST
#define PARENT_BTMMOST() PARENT_BBTMMOST()
#endif

#define WS_BFLOATING     ((/*WS_POPUP*/WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME |WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX))
#define WS_EX_BFLOATING  (/*WS_EX_PALETTEWINDOW | */ WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE)


#define WS_FLOATING     ((/*WS_POPUP*/WS_TILEDWINDOW|WS_THICKFRAME|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_MINIMIZEBOX|WS_MAXIMIZEBOX))
#define WS_EX_FLOATING  (WS_EX_PALETTEWINDOW | WS_EX_WINDOWEDGE)
#define PARENT_FLOATING (HWND_DESKTOP)

#if XXX_BROWSEROWNED
#define WS_BBTMMOST     WS_FLOATING
#define WS_EX_BBTMMOST  (WS_EX_FLOATING|WS_EX_TOOLWINDOW)
#define PARENT_BBTMMOST PARENT_FLOATING
#else
// non-topmost
#define WS_BBTMMOST     (WS_CHILD/*|WS_BORDER|WS_THICKFRAME*/|WS_CLIPSIBLINGS | WS_CLIPCHILDREN)
#define WS_EX_BBTMMOST  (WS_EX_CLIENTEDGE /*|WS_EX_WINDOWEDGE*/)
#define PARENT_BBTMMOST() (_hwndSite)
#endif

#define ISWSX_EDGELESS(ws, wsx) \
    (!(((ws)&WS_THICKFRAME) || ((wsx)&WS_EX_WINDOWEDGE)))

#define ISWBM_EDGELESS(eMode) \
    ((eMode==WBM_BBOTTOMMOST && ISWSX_EDGELESS(WS_BBTMMOST, WS_EX_BBTMMOST)) \
    || (eMode==WBM_BOTTOMMOST && ISWSX_EDGELESS(WS_BTMMOST, WS_EX_BTMMOST)))

#define XY_NIL          ((LPARAM) (-1))

// drag state
#define DRAG_NIL        0       // nil
#define DRAG_MOVE       1       // moving
#define DRAG_SIZE       2       // sizing

extern void DBC_ExecDrag(IUnknown *pDbc, int eDragging);

#define WBMF_BROWSER    (0x0001000)        // hosted by browser (vs. by desktop)
#define WBM_BBOTTOMMOST (WBMF_BROWSER|WBM_BOTTOMMOST)
//#define WBM_BTOPMOST    (WBMF_BROWSER|WBM_TOPMOST)
#define WBM_BFLOATING   (WBMF_BROWSER|WBM_FLOATING)
#define WBM_BNIL        *** error! ***


//***   ISWBM_* -- check mode
#define ISWBM_FLOAT(eMode) \
                           (eMode & WBM_FLOATING)

#define ISWBM_BOTTOM(eMode) \
    ((eMode) == WBM_BOTTOMMOST || (eMode) == WBM_BBOTTOMMOST)

#if XXX_CHEEDESK
#define ISWBM_DESKTOP()     (!(_eMode & WBMF_BROWSER))
#else
#define ISWBM_DESKTOP()     (_fDesktop)
#endif

#if XXX_BROWSEROWNED
#define ISWBM_OWNED(eMode) ((!ISWBM_DESKTOP()) && \
    ((eMode) == WBM_BFLOATING || (eMode) == WBM_BBOTTOMMOST))
#else
#define ISWBM_OWNED(eMode) ((eMode) == WBM_BFLOATING)
#endif

#if XXX_HIDE
#if XXX_HIDEALL
#define ISWBM_HIDEABLE(eMode)   (((eMode) & ~WBMF_BROWSER) != WBM_FLOATING)
#else
#define ISWBM_HIDEABLE(eMode)   ((eMode) == WBM_TOPMOST)
#endif
#endif

#define CHKWBM_CHANGE(eModeNew, eModeCur) \
    (((eModeNew) & WBMF_BROWSER) == ((eModeCur) & WBMF_BROWSER) \
        || (eModeNew) == WBM_NIL || (eModeCur) == WBM_NIL) 


//***   timer stuff
#define IDT_POPUI       10
#define IDT_AUTOHIDE    11
#define IDT_AUTOUNHIDE  12

#define DLY_AUTOHIDE    500
#define DLY_AUTOUNHIDE  50

//***   hide state (_fHiding)
#define HIDE_FALSE      0       // must be FALSE
#define HIDE_AUTO       1       // currently hidden (due to autohide)
#define HIDE_MANUAL     2       // currently hidden (due to manual hide)

CASSERT(! HIDE_FALSE);


#if 0
//***   MKMS, MSTO* -- make/crack combined mode+side
//
#define MSTOMODE(ms)    (((UINT) (ms)) >> 8)
#define MSTOSIDE(ms)    (((UINT) (ms)) & 0x7)
#define MKMS(m, s)      ((((UINT) (m)) << 8) | (UINT) (s))
#endif

#if WEBBAR_APP
HMENU LoadMenuPopup(UINT id);
extern HINSTANCE        g_hinst;
#define HINST_THISDLL   g_hinst
#endif

// REARCHITECT we can replace these once the portability layer is up and running.
#define Command_GetNotifyCode(wp,lp)    HIWORD(wp)
#define Command_GetHwndCtl(lp)          ((HWND)lp)
#define Command_GetID(wp)               LOWORD(wp)


CASSERT((ABE_LEFT|ABE_RIGHT|ABE_TOP|ABE_BOTTOM) == 3);  // must fit in _uSide:2

//***   MoveRect -- move left-top corner of rect to (x,y)
//
#define MoveRect(prc, x, y) \
    OffsetRect((prc), (x) - (prc)->left, (y) - (prc)->top)

#define AB_THEIGHT(rc)  (RECTHEIGHT(rc) * 10 / 100)     // 10%
#define AB_BHEIGHT(rc)  (RECTHEIGHT(rc) * 10 / 100)     // 10%
#define AB_LWIDTH(rc)   (40)                            // fixed width 40
#define AB_RWIDTH(rc)   ( RECTWIDTH(rc) * 35 / 100)     // 30%

void SlideWindow(HWND hwnd, RECT *prc, HMONITOR hMonClip, BOOL fShow);


class PropDataSet {
public:
    BOOL _fSet;
    DWORD _dwData;
};

class CDockingBarPropertyBag :
      public IPropertyBag
    , public IDockingBarPropertyBagInit
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPropertyBag ***
    virtual HRESULT STDMETHODCALLTYPE Read( 
                                           /* [in] */ LPCOLESTR pszPropName,
                                           /* [out][in] */ VARIANT *pVar,
                                           /* [in] */ IErrorLog *pErrorLog);

    virtual HRESULT STDMETHODCALLTYPE Write( 
                                            /* [in] */ LPCOLESTR pszPropName,
                                            /* [in] */ VARIANT *pVar) {return E_NOTIMPL;};

    // *** IDockingBarPropertyBagInit
    virtual STDMETHODIMP SetDataDWORD(ENUMPROPDATA e, DWORD dwData) { _props[e]._fSet = TRUE; _props[e]._dwData = dwData; return S_OK; }
    
protected:
    CDockingBarPropertyBag() { _cRef = 1; };
    friend HRESULT CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    UINT _cRef;
    
    PropDataSet _props[PROPDATA_COUNT];
    
}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dhuihand.cpp ===
#include "priv.h"

#include "dhuihand.h"


#define DM_DOCHOSTUIHANDLER 0

//==========================================================================
// IDocHostUIHandler implementation
//==========================================================================

HRESULT CDocHostUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowContextMenu called");

    //
    // LATER: WebBand in a DesktBar/BrowserBar needs to hook this event
    // to popup a customized context menu.
    //
    return S_FALSE; // Host did not display any UI. 
}

HRESULT CDocHostUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetHostInfo called");

// Trident does not initialize it. It's defined as [in] parameter. 
#if 0
    if (pInfo->cbSize < SIZEOF(DOCHOSTUIINFO)) {
        return E_INVALIDARG;
    }
#endif
    pInfo->cbSize = SIZEOF(DOCHOSTUIINFO);
    pInfo->dwFlags = DOCHOSTUIFLAG_BROWSER;
// Disable double buffering if low memory machine.
//    if (SHIsLowMemoryMachine(ILMM_IE4))
//        pInfo->dwFlags = pInfo->dwFlags | DOCHOSTUIFLAG_DISABLE_OFFSCREEN;
    
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;     // default
    return S_OK;
}

HRESULT CDocHostUIHandler::ShowUI( 
    DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
    IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
    IOleInPlaceUIWindow *pDoc)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::ShowUI called");

    // Host did not display its own UI. Trident will proceed to display its own. 
    return S_FALSE;
}

HRESULT CDocHostUIHandler::HideUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::HideUI called");
    // This one is paired with ShowUI
    return S_FALSE;
}

HRESULT CDocHostUIHandler::UpdateUI(void)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::UpdateUI called");
    // LATER: Isn't this equivalent to OLECMDID_UPDATECOMMANDS?
    return S_FALSE;
}

HRESULT CDocHostUIHandler::EnableModeless(BOOL fEnable)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::EnableModeless called");
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::ResizeBorder( 
LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_OK;
}

HRESULT CDocHostUIHandler::TranslateAccelerator( 
LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    // Called from the Trident when the equivalent member of its
    // IOleInPlaceActiveObject is called by the frame. We don't care
    // those cases.
    return S_FALSE; // The message was not translated
}

HRESULT CDocHostUIHandler::GetOptionKeyPath(BSTR *pbstrKey, DWORD dw)
{
    // Trident will default to its own user options.
    *pbstrKey = NULL;
    return S_FALSE;
}

HRESULT CDocHostUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetDropTarget called");

    return E_NOTIMPL;
}

HRESULT CDocHostUIHandler::GetAltExternal(IDispatch **ppDisp)
{
    HRESULT hr = E_FAIL;
    
    IDocHostUIHandler *pDocHostUIHandler;
    IOleObject        *pOleObject;
    IOleClientSite    *pOleClientSite;

    *ppDisp = NULL;

    //  * QI ourselves for a service provider
    //  * QS for the top level browser's service provider
    //  * Ask for an IOleObject
    //  * Ask the IOleObject for an IOleClientSite
    //  * QI the IOleClientSite for an IDocHostUIHandler
    //  * Call GetExternal on the IDocHostUIHandler to get the IDispatch

    if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(this, IID_PPV_ARG(IOleObject, &pOleObject))))
    {
        if (SUCCEEDED(pOleObject->GetClientSite(&pOleClientSite)))
        {
            if (SUCCEEDED(pOleClientSite->QueryInterface(IID_IDocHostUIHandler,
                                                         (void **)&pDocHostUIHandler)))
            {
                hr = pDocHostUIHandler->GetExternal(ppDisp);
                pDocHostUIHandler->Release();
            }
            pOleClientSite->Release();
        }
        pOleObject->Release();
    }

    return hr;
}


HRESULT CDocHostUIHandler::GetExternal(IDispatch **ppDisp)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::GetExternal called");

    HRESULT hr;

    if (ppDisp)
    {
        IDispatch *psuihDisp;
        IDispatch *pAltExternalDisp;

        *ppDisp = NULL;

        GetAltExternal(&pAltExternalDisp);

        hr = CShellUIHelper_CreateInstance2((IUnknown **)&psuihDisp, IID_IDispatch,
                                           (IUnknown *)this, pAltExternalDisp);
        if (SUCCEEDED(hr))
        {
            *ppDisp = psuihDisp;

            if (pAltExternalDisp)
            {
                //  Don't hold a ref - the ShellUIHelper will do it
                pAltExternalDisp->Release();
            }
        }
        else if (pAltExternalDisp)
        {
            //  Couldn't create a ShellUIHelper but we got our host's
            //  external.
            *ppDisp = pAltExternalDisp;
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    ASSERT((SUCCEEDED(hr) && (*ppDisp)) || (FAILED(hr)));
    return hr;
}


HRESULT CDocHostUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::TranslateUrl called");

    return S_FALSE;
}


HRESULT CDocHostUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    TraceMsg(DM_DOCHOSTUIHANDLER, "CDOH::FilterDataObject called");

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\enumband.h ===
#ifndef _ENUMBAND_H_
#define _ENUMBAND_H_

// e.g. STDMETHODIMP Foo(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam)
typedef HRESULT (CALLBACK* PFNENUMCATIDCLASSES)(REFCATID rcatid, REFCLSID rclsid, LPARAM lParam);

#define EEBWC_DESKBANDS              0x00000001
#define EEBWC_INFOBANDS              0x00000002
#define EEBWC_VERTICAL_BANDS_RUNTIME 0x00000008

STDMETHODIMP SHEnumClassesImplementingCATID(REFCATID rcatid, PFNENUMCATIDCLASSES pfnEnum, LPARAM lParam);

#endif  // _ENUMBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\enumband.cpp ===
#include "priv.h"
#include "comcatex.h"
#include "enumband.h"

// Private forward decalarations
typedef HRESULT (CALLBACK* PFNENUMCLSIDPROC)(REFGUID rguid, LPARAM lParam);

typedef struct tagADDCATIDENUM
{
    PFNENUMCATIDCLASSES pfnEnum;
    const CATID*        pcatid;
    LPARAM              lParam;
} ADDCATIDENUM, *PADDCATIDENUM;


STDMETHODIMP _SHEnumGUIDsWithCallback(IEnumCLSID* peclsid, PFNENUMCLSIDPROC pfnEnum, LPARAM lParam);
STDMETHODIMP _SHEnumRegGUIDs(HKEY hk, PCTSTR pszKey, IEnumGUID** ppenum);

STDMETHODIMP _AddCATIDEnum(REFCLSID rclsid, LPARAM lParam);


STDMETHODIMP SHEnumClassesImplementingCATID(REFCATID rcatid, PFNENUMCATIDCLASSES pfnEnum, LPARAM lParam)
{
    ADDCATIDENUM params;
    IEnumCLSID*  peclsid;
    HRESULT      hr;

    params.pcatid  = &rcatid;
    params.pfnEnum = pfnEnum;
    params.lParam  = lParam;

    hr = SHEnumClassesOfCategories(1, (CATID*)&rcatid, 0, NULL, &peclsid);

    if (FAILED(hr))
    {
        return hr;
    }

    return _SHEnumGUIDsWithCallback(peclsid, _AddCATIDEnum, (LPARAM)&params);
}


//----- Private APIs -----
class CEnumRegGUIDs : public IEnumGUID
{
public:
    // *** IUnknown ***
    STDMETHOD (QueryInterface)(REFIID riid, PVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ***  IEnumGUID ***
    STDMETHOD (Next)(ULONG celt, LPGUID rgelt, PULONG pceltFetched);
    STDMETHOD (Skip)(ULONG celt);
    STDMETHOD (Reset)();
    STDMETHOD (Clone)(IEnumGUID** ppenum);

protected:
    // constructor & destructor
    CEnumRegGUIDs(HKEY hk, PCTSTR pszKey);
    virtual ~CEnumRegGUIDs();

    // data members
    HKEY   _hkHive;
    TCHAR  _szKey[MAX_PATH];

    HKEY   _hkGuids;
    ULONG  _nCurrent;
    ULONG  _cRef;

    friend STDMETHODIMP _SHEnumRegGUIDs(HKEY hk, PCTSTR pszKey, IEnumGUID** ppenum);
};


//----- Constructor & Destructor -----
inline CEnumRegGUIDs::CEnumRegGUIDs(HKEY hk, PCTSTR pszKey)
{
    _hkHive   = hk;
    _szKey[0] = TEXT('\0');
    StrCpy(_szKey, pszKey);

    _hkGuids  = NULL;
    _nCurrent = 0;
    _cRef     = 1;

    DllAddRef();
}

CEnumRegGUIDs::~CEnumRegGUIDs()
{
    if (NULL != _hkGuids)
    {
        RegCloseKey(_hkGuids);
        _hkGuids = NULL;
    }

    DllRelease();
}


//----- IUnknown -----
HRESULT CEnumRegGUIDs::QueryInterface(REFIID riid, PVOID* ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CEnumRegGUIDs, IEnumGUID),     // IID_IEnumGUID
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CEnumRegGUIDs::AddRef()
{
    return ++_cRef;
}

ULONG CEnumRegGUIDs::Release()
{
    ASSERT(0 < _cRef);
    if (0 != --_cRef)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


//----- IEnumGUID -----
STDMETHODIMP CEnumRegGUIDs::Next(ULONG celt, LPGUID rgelt, PULONG pceltFetched)
{
    TCHAR szGuid[GUIDSTR_MAX];
    DWORD cchGuid;
    ULONG i, j;
    LONG  lr;

    if (NULL != pceltFetched)
    {
        *pceltFetched = 0;
    }

    if (NULL == _hkGuids)
    {
        lr = RegOpenKeyEx(_hkHive, _szKey, 0, KEY_ENUMERATE_SUB_KEYS, &_hkGuids);
        if (ERROR_SUCCESS != lr)
        {
            return E_FAIL;
        }
    }
    ASSERT(NULL != _hkGuids);

    for (i = j = 0; i < celt; i++)
    {
        cchGuid = ARRAYSIZE(szGuid);
        lr      = SHEnumKeyEx(_hkGuids, _nCurrent++, szGuid, &cchGuid);
        if (ERROR_SUCCESS != lr)
        {
            continue;
        }

        GUIDFromString(szGuid, &rgelt[j]);
        j++;
    }

    if (NULL != pceltFetched)
    {
        *pceltFetched = j;
    }

    return S_OK;
}

STDMETHODIMP CEnumRegGUIDs::Skip(ULONG celt)
{
    _nCurrent += celt;
    return S_OK;
}

STDMETHODIMP CEnumRegGUIDs::Reset()
{
    _nCurrent = 0;
    return S_OK;
}

STDMETHODIMP CEnumRegGUIDs::Clone(IEnumGUID** ppenum)
{
    return E_NOTIMPL;
}


STDMETHODIMP _SHEnumGUIDsWithCallback(IEnumCLSID* peclsid, PFNENUMCLSIDPROC pfnEnum, LPARAM lParam)
{
    CLSID   clsid;
    HRESULT hr;
    ULONG   i;

    if (NULL == peclsid || NULL == pfnEnum)
    {
        return E_INVALIDARG;
    }

    hr = S_OK;

    peclsid->Reset();
    while (S_OK == peclsid->Next(1, &clsid, &i))
    {
        hr = pfnEnum(clsid, lParam);
        if (S_OK != hr)
        {
            break;
        }
    }

    return hr;
}

STDMETHODIMP _SHEnumRegGUIDs(HKEY hk, PCTSTR pszKey, IEnumGUID** ppenum)
{
    if (NULL == ppenum)
    {
        return E_INVALIDARG;
    }

    *ppenum = new CEnumRegGUIDs(hk, pszKey);
    return (NULL != *ppenum) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP _AddCATIDEnum(REFCLSID rclsid, LPARAM lParam)
{
    PADDCATIDENUM p = (PADDCATIDENUM)lParam;
    ASSERT(NULL != p);
    ASSERT(NULL != p->pfnEnum);
    return (*p->pfnEnum)(*p->pcatid, rclsid, p->lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\explore2.h ===
#ifndef _explore2_H
#define _explore2_H

#include "shbrows2.h"

class CExplorerBrowser : public CSHELLBROWSER
{
public:
    // IOleInPlaceUIWindow (also IOleWindow)
    
    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared,
                LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);


    // IBrowserService
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);

protected:
    CExplorerBrowser();
    virtual ~CExplorerBrowser();

    friend HRESULT CExplorerBrowser_CreateInstance(HWND hwnd, void **ppsb);
    
    // topmost CExplorerBrowser in a frameset (IE3/AOL/CIS/VB)


    // CSHELLBROWSER virtuals
    virtual void _UpdateFolderSettings(LPCITEMIDLIST pidl);
    virtual DWORD       v_ShowControl(UINT iControl, int iCmd);
    virtual void        v_GetAppTitleTemplate(LPTSTR pszBuffer, LPTSTR pszAppTitle);
    virtual LRESULT     v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    virtual void        v_GetDefaultSettings(IETHREADPARAM *piei);
    virtual STDMETHODIMP_(IStream *) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName);
    virtual DWORD       v_RestartFlags();
    virtual void        v_ParentFolder();
    virtual IStream *   _GetITBarStream(BOOL fWebBrowser, DWORD grfMode);
    virtual void        v_InitMembers();
    friend LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CALLBACK BrowserThreadProc(IETHREADPARAM* piei);
    friend LRESULT CALLBACK DrivesWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    
    BOOL _ExplorerTreeHasFocus();
    void _EnableMenuItemsByAttribs(HMENU hmenu);
        
    friend int CALLBACK _export HTIList_FolderIDCompare(HTREEITEM hItem1, HTREEITEM hItem2, LPARAM lParam);
        
    HTREEITEM           _htiCut;
    HWND                _hwndNextViewer;
    
    UINT                _nSelChangeTimer;
    BITBOOL             _fPostCloseLater        :1;
    BITBOOL             _fInteractive           :1;
    BITBOOL             _fNoInteractive         :1; // huh?  why do we have both?
    BITBOOL             _fShowTitles            :1;    
};

#endif // _explore2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\gfldset.cpp ===
// gfldset.cpp
//
//  A class that manages global folder settings.

#include "priv.h"
#include "sccls.h"

class CGlobalFolderSettings : public IGlobalFolderSettings
{
    public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)(THIS);
    STDMETHOD_(ULONG,Release)(THIS);

    // *** IGlobalFolderSettings meTHODs ***
    STDMETHOD(Get)(THIS_ DEFFOLDERSETTINGS *pdfs, int cbDfs);
    STDMETHOD(Set)(THIS_ const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags);

    protected:
        friend HRESULT CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

        CGlobalFolderSettings();
        ~CGlobalFolderSettings();

        LONG            m_cRef;
};

STDAPI CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // class factory will take care of denying aggregation and giving a null
    // back on failure
    ASSERT(pUnkOuter == NULL);

    CGlobalFolderSettings* pid = new CGlobalFolderSettings();

    if (pid)
    {
        *ppunk = SAFECAST(pid, IGlobalFolderSettings*);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CGlobalFolderSettings::CGlobalFolderSettings() : m_cRef(1)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CGlobalFolderSettings::~CGlobalFolderSettings()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::QueryInterface ( REFIID riid, LPVOID * ppvObj )
{
    if ( riid == IID_IUnknown || riid == IID_IGlobalFolderSettings)
    {
        *ppvObj = SAFECAST( this, IGlobalFolderSettings *);
        AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CGlobalFolderSettings:: AddRef ()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CGlobalFolderSettings:: Release ()
{
    if ( InterlockedDecrement( &m_cRef ) == 0 )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::Get(DEFFOLDERSETTINGS *pdfs, int cbDfs)
{
    if (cbDfs < sizeof(DEFFOLDERSETTINGS_W2K))
    {
        return E_INVALIDARG;
    }
    else if (cbDfs > sizeof(DEFFOLDERSETTINGS))
    {
        ZeroMemory(pdfs, cbDfs);
    }

    CopyMemory(pdfs, &g_dfs, min(cbDfs, sizeof(g_dfs)));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGlobalFolderSettings::Set(const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags)
{
    if (flags & ~GFSS_VALID) {
        ASSERT(!"Invalid flags passed to CGlobalFolderSettings::Set");
        return E_INVALIDARG;
    }

    //
    //  Special hack:  If you pass (NULL, 0) then it means "reset to
    //  default".
    //
    if (pdfs == NULL)
    {
        if (cbDfs == 0)
        {
            static DEFFOLDERSETTINGS dfs = INIT_DEFFOLDERSETTINGS;
            dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;
            pdfs = &dfs;
            cbDfs = sizeof(dfs);
        }
        else
        {
            return E_INVALIDARG;
        }
    }
    else if (cbDfs < sizeof(DEFFOLDERSETTINGS_W2K))
    {
        ASSERT(!"Invalid cbDfs passed to CGlobalFolderSettings::Set");
        return E_INVALIDARG;
    }

    // Preserve the dwDefRevCount, otherwise we'll never be able
    // to tell if the structure has been revised!
    DWORD dwDefRevCount = g_dfs.dwDefRevCount;
    CopyMemory(&g_dfs, pdfs, min(cbDfs, sizeof(g_dfs)));
    g_dfs.dwDefRevCount = dwDefRevCount;
    SaveDefaultFolderSettings(flags);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_

#include <iethread.h>

DECLARE_HANDLE(HNFBLOCK);

STDAPI_(HNFBLOCK) ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
STDAPI_(IETHREADPARAM *) ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);


#endif // HNFBLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\explore2.cpp ===
#include "priv.h"

#ifndef UNIX

#include "sccls.h"
#include "explore2.h"
#include <iethread.h>
#include "resource.h"
#include "itbar.h"

#include "mluisupp.h"

#define DM_FOCUS    DM_TRACE

#define SUPERCLASS CSHELLBROWSER

TCHAR const c_szSettings[] = TEXT("Settings");
TCHAR const c_szCabinetExpView[]    = TEXT("ExpView");

CExplorerBrowser::CExplorerBrowser()
{
    // warning: can't call SUPERCLASS until _Initialize has been called
    // (since that's what does the aggregation)
}

CExplorerBrowser::~CExplorerBrowser()
{
    if (GetUIVersion() < 5) {
        if (_hmenuTemplate)
            DestroyMenu(_hmenuTemplate);

        if (_hmenuFull)
            DestroyMenu(_hmenuFull);
    }
}

HRESULT CExplorerBrowser::_Initialize(HWND hwnd, IUnknown *pauto)
{
    HRESULT hr;
    SHELLSTATE ss = {0};

    hr = SUPERCLASS::_Initialize(hwnd, pauto);
    if (SUCCEEDED(hr)) {
        _fSubclassed = TRUE;
    }

    return hr;
}

void CExplorerBrowser::v_InitMembers()
{
    if (GetUIVersion() < 5) {
        _hmenuTemplate = _MenuTemplate(MENU_TEMPLATE, TRUE);
        _hmenuFull = _MenuTemplate(MENU_FULL, TRUE);
        _hmenuCur = _hmenuTemplate;
    } else {
        // explorer/non-explorer shell menus same on nt5
        SUPERCLASS::v_InitMembers();
    }
}

HRESULT CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb)
{
    HRESULT hr;
    CExplorerBrowser *psb = new CExplorerBrowser();

    if (psb) {
        hr = psb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr)) {
            ASSERT(0);    // shouldn't happen
            ATOMICRELEASE(psb);
        }
    } else {
        // low mem
        hr = E_OUTOFMEMORY;
    }

    *ppsb = (LPVOID)psb;
    return hr;
}

IStream* CExplorerBrowser::_GetITBarStream(BOOL fWebBrowser, DWORD grfMode)
{
    return GetITBarStream(ITBS_EXPLORER, grfMode);
}

HRESULT CExplorerBrowser::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres = SUPERCLASS::OnCreate(pcs);
    v_ShowControl(FCW_TREE, SBSC_SHOW);
    return hres;
}

DWORD CExplorerBrowser::v_ShowControl(UINT iControl, int iCmd)
{
    int iShowing = -1;
    
    switch (iControl) {
    case FCW_TREE:
    {
        // get the current state
        iShowing = (IsControlWindowShown(FCW_TREE, NULL) == S_OK) ? SBSC_SHOW : SBSC_HIDE;
        
        if (iCmd != SBSC_QUERY) {
            // turn it on/off as requested
            VARIANTARG v = {0};
            v.vt = VT_I4;
            v.lVal = SBSC_SHOW ? 1 : 0;
            Exec(&CGID_Explorer, SBCMDID_EXPLORERBAR, 0, &v, NULL);
        }
        break;
    }
 
    default:
        return SUPERCLASS::v_ShowControl(iControl, iCmd);
    }
    
    return iShowing;
}


// FEATURE: should go to cshellbrowser
void CExplorerBrowser::_EnableMenuItemsByAttribs(HMENU hmenu)
{    
    if (_pbbd->_pidlCur) {
        DWORD dwAttrib = SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET;
        
        IEGetAttributesOf(_pbbd->_pidlCur, &dwAttrib);

        _EnableMenuItem(hmenu, FCIDM_DELETE, (dwAttrib & SFGAO_CANDELETE));
        _EnableMenuItem(hmenu, FCIDM_RENAME, (dwAttrib & SFGAO_CANRENAME));
        _EnableMenuItem(hmenu, FCIDM_PROPERTIES, (dwAttrib & SFGAO_HASPROPSHEET));
        
    }
}

BOOL CExplorerBrowser::_ExplorerTreeHasFocus()
{
    BOOL bRet = FALSE;
    IInputObject* pio;
    if (SUCCEEDED(_QIExplorerBand(IID_IInputObject, (void**)&pio)))
    {
        bRet = (pio->HasFocusIO() == S_OK);
        pio->Release();
    }
    return bRet;
}


LRESULT CExplorerBrowser::v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu)
{
    if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FILE)) 
    {
        if (_ExplorerTreeHasFocus())
            _EnableMenuItemsByAttribs(hmenuPopup);
    }
    
    return SUPERCLASS::v_OnInitMenuPopup(hmenuPopup, nIndex, fSystemMenu);
}

HRESULT CExplorerBrowser::InsertMenusSB(HMENU hmenuShared,
                            LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    SUPERCLASS::InsertMenusSB(hmenuShared, lpMenuWidths);

    if (GetUIVersion() < 5) {
        if (lpMenuWidths->width[4] == 1)
            lpMenuWidths->width[4] = 2;  // we have tools AND help for explorer mode
    }

    return S_OK;
}

void CExplorerBrowser::v_GetDefaultSettings(IETHREADPARAM *piei)
{
    if (GetUIVersion() < 5)
    {
        // set the flags
        piei->fs.fFlags = 0;

        piei->fs.ViewMode = FVM_LIST;

        ASSERT(DFS_VID_Default == VID_WebView);
#if 0 // If DFS_VID_Default differs from VID_WebView, then turn these lines back on
        piei->m_vidRestore = VID_List;
        piei->m_dwViewPriority = VIEW_PRIORITY_NONE; // let anyone override the VID_List default
#endif

        piei->wv.bStatusBar = g_dfs.bDefStatusBar;
        piei->wp.length = 0;
        piei->wHotkey = 0;
    }
    else
        SUPERCLASS::v_GetDefaultSettings(piei);
}

void CExplorerBrowser::v_ParentFolder()
{
    if (_ShouldAllowNavigateParent()) {
        BrowseObject(NULL, SBSP_PARENT | SBSP_SAMEBROWSER);
    }
}

HRESULT CExplorerBrowser::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    // turn non-explore to newbrowser
    if ((GetUIVersion() < 5) && (wFlags & SBSP_OPENMODE))
    {
        wFlags &= ~(SBSP_DEFBROWSER | SBSP_SAMEBROWSER);
        wFlags |= SBSP_NEWBROWSER;
    }
    
    return SUPERCLASS::BrowseObject(pidl, wFlags);
}

DWORD CExplorerBrowser::v_RestartFlags()
{
    return COF_CREATENEWWINDOW | COF_EXPLORE;
}

void CExplorerBrowser::v_GetAppTitleTemplate(LPTSTR pszBuffer, LPTSTR szFullName)
{
    if (GetUIVersion() < 5) {
        // "exploring - la de da"
        TCHAR szBuffer[80];
        MLLoadString(IDS_EXPLORING, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pszBuffer, ARRAYSIZE(szBuffer) /*Lack of something better*/, TEXT("%s - %%s"), szBuffer);
    } else {
        SUPERCLASS::v_GetAppTitleTemplate(pszBuffer, szFullName);
    }
}

void CExplorerBrowser::_UpdateFolderSettings(LPCITEMIDLIST pidl)
{
    if (GetUIVersion() < 5)
    {
        // Explorer always inherits the view a la win95
        _pbbd->_psv->GetCurrentInfo(&_fsd._fs);
    }
    else
        SUPERCLASS::_UpdateFolderSettings(pidl);
}

LPSTREAM CExplorerBrowser::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode,
        LPCWSTR pwszName)
{
    // if it's asking for general browser info, give it the one browser info.
    // otherwise give do what our superclass does

    if ((GetUIVersion() < 5) && (StrCmpW(pwszName, L"CabView") == 0))
    {
        HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
        if (hk)
        {
            IStream *pstm = OpenRegStream(hk, c_szCabinetExpView, c_szSettings, grfMode);
            RegCloseKey(hk);
            return pstm;
        }
    }

    return SUPERCLASS::v_GetViewStream(pidl, grfMode, pwszName);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\globals.h ===
////////////////////////////////////////////////////////////////
//
// this file is for global macros and global variables
// macros in the first section, variables (and macros associated with those variabls in the second
// (look for BEGIN GLOBALS
//
////////////////////////////////////////////////////////////////





// Map KERNEL32 unicode string functions to SHLWAPI
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW


#define c_szNULL        TEXT("")
#define c_szHelpFile     TEXT("iexplore.hlp")
#define MAX_TOOLTIP_STRING 80

// status bar pane numbers actually used to create the controls - in left-to-right order
#define STATUS_PANES            6
#define STATUS_PANE_NAVIGATION  0
#define STATUS_PANE_PROGRESS    1
#define STATUS_PANE_OFFLINE     2
#define STATUS_PANE_PRINTER     2         // printer and offline share a spot
#define STATUS_PANE_PRIVACY     3
#define STATUS_PANE_SSL         4
#define STATUS_PANE_ZONE        5

#define ZONES_PANE_WIDTH        220

// logical defines for grfKeyState bits
#define FORCE_COPY (MK_CONTROL | MK_LBUTTON)    // means copy
#define FORCE_LINK (MK_LBUTTON | MK_CONTROL | MK_SHIFT)     // means link

// the only place ITB_MAX is really used is to make sure we don't have
// one of the distinguished values (e.g. ITB_VIEW, for both correctness
// and perf).  technically that means we can have ITB_MAX = (INT_MAX - 1),
// but 32000 ought to be plenty big enough and it's probably a bit safer
// in terms of collisions w/ ITB_VIEW.
#define ITB_MAX         32000           // max #
#define ITB_CSTATIC     2               // statically allocated guys
#define ITB_CGROW       2               // dynamic guys chunk size
// CASSERT(ITB_CSTATIC % ITB_CGROW == 0);

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)

// this is for the file menus recently visited list.  
//  it represents the count of entries both back and forward 
//  that should be on the menu.
#define CRECENTMENU_MAXEACH     5

// shorthand
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
//
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#   ifdef __cplusplus
#       define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#   else
#       define ATOMICRELEASE(p) IUnknown_AtomicRelease((LPVOID*)&p)
#   endif
#endif
#endif //ATOMICRELEASE

#ifdef SAFERELEASE
#undef SAFERELEASE
#endif
#define SAFERELEASE(p) ATOMICRELEASE(p)


#ifdef  UNICODE

   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;

#endif /* UNICODE */

#define LoadMenuPopup(id) SHLoadMenuPopup(MLGetHinst(), id)   
#define PropagateMessage SHPropagateMessage
#define MenuIndexFromID  SHMenuIndexFromID
#define Menu_RemoveAllSubMenus SHRemoveAllSubMenus
#define _EnableMenuItem SHEnableMenuItem
#define _CheckMenuItem SHCheckMenuItem

#define REGSTR_PATH_EXPLORERA    "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
#define REGSTR_KEY_STREAMMRUA    REGSTR_PATH_EXPLORERA "\\StreamMRU"

#ifdef UNICODE
#define REGSTR_KEY_STREAMMRU        TEXT(REGSTR_PATH_EXPLORERA) TEXT("\\StreamMRU")
#else // UNICODE
#define REGSTR_KEY_STREAMMRU        REGSTR_KEY_STREAMMRUA
#endif // UNICODE
   
///////////////////////////////////////////////////////////////////////////////
///// BEGIN GLOBALS 
   
#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
   
extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

extern BOOL g_fRunningOnNT;
extern BOOL g_bRunOnNT5;
extern BOOL g_bRunOnMemphis;
extern BOOL g_fRunOnFE;
extern BOOL g_fRunOnWhistler;
extern BOOL g_fIE;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;


extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

#define SID_SDropBlocker CLSID_SearchBand

#define FillExecInfo(_info, _hwnd, _verb, _file, _params, _dir, _show) \
        (_info).hwnd            = _hwnd;        \
        (_info).lpVerb          = _verb;        \
        (_info).lpFile          = _file;        \
        (_info).lpParameters    = _params;      \
        (_info).lpDirectory     = _dir;         \
        (_info).nShow           = _show;        \
        (_info).fMask           = 0;            \
        (_info).cbSize          = sizeof(SHELLEXECUTEINFO);

extern LCID g_lcidLocale;

//
// Globals (per-process)
//
extern LONG g_cThreads;
extern LONG g_cModelessDlg;
extern UINT g_tidParking;           // parking thread
extern HWND g_hDlgActive;
extern UINT g_msgMSWheel;
extern BOOL g_fShowCompColor;
extern COLORREF g_crAltColor;
extern HPALETTE g_hpalHalftone;


extern const GUID CGID_PrivCITCommands;


#ifdef __cplusplus
};                                   /* End of extern "C" {. */
#endif   /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\iaccess.cpp ===
#include "priv.h"
// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "resource.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hres = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hres = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_IAccessible, (void**)&paccChild1);
                if(SUCCEEDED(hres))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hres = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hres == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hres = pdispChild1->QueryInterface(IID_IAccessible, (void**)&paccChild2);

                        // Does this have a child?
                        if (hres == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hres = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hres == S_OK)
                            {
                                hres = pdispChild2->QueryInterface(IID_IAccessible, (void**)&_pInnerAcc);
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hres = _pmb->QueryInterface(IID_IShellMenuAcc, (void**)&_psma);
        if (SUCCEEDED(hres))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
        }

        if (_fState == MB_STATE_ITEM)
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP CAccessible::GetTypeInfoCount(UINT FAR* pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch * FAR* ppdispParent)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_IUnknown, (void**)&punk)))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_IAccessible, (void**)&pacc)))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hres = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClearLazy(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hres = S_FALSE;
                }

                punk->Release();
            }

            return hres;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_IDispatch, (void**)ppdispParent);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long FAR* pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hres = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hres = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hres = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hres))
            {
                hres = _psma->GetSubMenu(&varChild, IID_IDispatch, (void**)ppdispChild);
            }
        }
        else
            hres = E_NOINTERFACE;
        break;
    }
    
    return hres;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hres = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // This interface sucks.
    if (hres == S_OK)
    {
        IAccessible* pacc;
        hres = pdisp->QueryInterface(IID_IAccessible, (void**)&pacc);
        if (SUCCEEDED(hres))
        {
            VARIANT varChild;
            hres = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hres))
                hres = pacc->get_accName(varChild, pbstr);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{   
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                MLLoadString(IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            int iIndex;
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, _iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                MLLoadString(idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
            {
                SHStripMneumonic(sz);
                *pszName = SysAllocString(sz);
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // This does not make sense for these.
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR FAR* pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescription)))
        {
            TCHAR sz[100];
            MLLoadString(IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical;
            BOOL fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = ( fVertical )? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen;
            BOOL fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwAccState = STATE_SYSTEM_FOCUSABLE;

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            DWORD dwState = ToolBar_GetState(_pmtbItem->_hwndMB, _iIndex);

            if (dwState & TBSTATE_PRESSED)
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;

            if (idHotTracked == _iIndex)
                dwAccState |= STATE_SYSTEM_HOTTRACKED;

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {

            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR sz[MAX_PATH];
                    TCHAR szAccel[100] = TEXT("");
                    int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                    if (S_FALSE == _psma->IsEmpty())
                    {
                        if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                        {
                            BOOL fVertical, fOpen;
                            _psma->GetState(&fVertical, &fOpen);
                            if (!fVertical)
                            {
                                MLLoadString(IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel));
                            }
                            szAccel[lstrlen(szAccel)] = GetAccelerator(sz, TRUE);
                            szAccel[lstrlen(szAccel)] = TEXT('\0');
                            hres = S_OK;
                        }
                    }

                    *pszKeyboardShortcut = SysAllocStringT(szAccel);
                    if (!*pszKeyboardShortcut)
                        hres = E_OUTOFMEMORY;
                    pmtb->Release();
                }
            }

        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT FAR * pvarFocusChild)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                hres = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                    iIndex, pvarFocusChild);
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT FAR * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            MLLoadString(IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)? IDS_ACC_OPEN: IDS_ACC_EXEC;
                MLLoadString(iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hres = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hres = _psma->GetParentSite(IID_IUnknown, (void**)&punk);
                    if (SUCCEEDED(hres))
                    {
                        IOleWindow* poct;
                        hres = IUnknown_QueryService(punk, SID_SMenuPopup, 
                            IID_IOleWindow, (void**)&poct);
                        if (SUCCEEDED(hres))
                        {
                            HWND hwnd;
                            hres = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hres))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hres = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hres))
                    {

labelGetRect:           int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                            hres = E_INVALIDARG;
                        MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hres))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iIndex = 0;         // 1 based index
    int iTBIndex;
    HRESULT hres = S_FALSE;
    TBBUTTONINFO tbInfo;
    int idCmd;
    VARIANT varTemp;
    CMenuToolbarBase* pmtb;
    BOOL fVertical;
    BOOL fOpen;


    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    _GetChildFromVariant(&varStart, NULL, &iIndex);

    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through
    case NAVDIR_DOWN:

        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex++;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }

        iIndex = 0;
        hres = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }
        iIndex = -1;
        hres = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
            if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                IMenuPopup* pmp;
                hres = _psma->GetSubMenu(&varStart, IID_IMenuPopup, (void**)&pmp);
                if (SUCCEEDED(hres))
                {
                    IAccessible* pacc;
                    hres = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_IAccessible, (void**)&pacc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                        pacc->Release();
                    }
                    pmp->Release();
                }
            }

                return hres;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex--;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    if (iTBIndex == 0)    
                    {   
                        hres = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_IOleCommandTarget, (void**)&punk)))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_IOleCommandTarget, (void**)&poct)))
                            {
                                VARIANT varVert;
                                varVert.vt = VT_BOOL;

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_IAccessible, (void**)&pacc)))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hres = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClearLazy(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres) && S_FALSE != hres)
        hres = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hres;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        hres = pacc->InitAcc();
        if (SUCCEEDED(hres))
        {
            hres = pacc->QueryInterface(IID_IDispatch, (void**) ppdisp);
        }
        pacc->Release();
    }
    return hres;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT FAR* rgvar, 
                        unsigned long FAR* pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

#define MB_STATE_TRACK 1
#define MB_STATE_MENU  2
#define MB_STATE_ITEM  4

#define TOOLBAR_MASK 0x80000000

// BUGBUG (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();
    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 
};

extern "C"
{
    LRESULT LresultFromObject(REFIID riid, WPARAM wParam, IUnknown*);
    void WINAPI NotifyWinEvent(DWORD event, HWND hwnd,
        LONG idObject, LONG idChild);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\iedde.h ===
#ifndef _IEDDE_H
#define _IEDDE_H


#endif  //_IEDDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\identity.cpp ===
// identity.cpp
//
//  A dummy class whose sole purpose is to say, "Yes, I am BrowseUI"

#include "priv.h"
#include "sccls.h"

class CBrowseuiIdentity : public IUnknown
{
    public:
        STDMETHOD ( QueryInterface ) ( REFIID riid, LPVOID * ppvObj );
        STDMETHOD_( ULONG, AddRef ) ();
        STDMETHOD_( ULONG, Release ) ();

    protected:
        friend HRESULT CBrowseuiIdentity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

        CBrowseuiIdentity();
        ~CBrowseuiIdentity();

        LONG            m_cRef;
};

STDAPI CBrowseuiIdentity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // class factory should've done these
    ASSERT(pUnkOuter == NULL);
    ASSERT(*ppunk == NULL);

    CBrowseuiIdentity* pid = new CBrowseuiIdentity();

    if (pid)
    {
        *ppunk = SAFECAST(pid, IUnknown*);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CBrowseuiIdentity::CBrowseuiIdentity() : m_cRef(1)
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CBrowseuiIdentity::~CBrowseuiIdentity()
{
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CBrowseuiIdentity::QueryInterface ( REFIID riid, LPVOID * ppvObj )
{
    if ( riid == IID_IUnknown )
    {
        *ppvObj = SAFECAST( this, IUnknown *);
        AddRef();
    }
    else
    {
        return E_NOINTERFACE;
    }

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBrowseuiIdentity:: AddRef ()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CBrowseuiIdentity:: Release ()
{
    if ( InterlockedDecrement( &m_cRef ) == 0 )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\iethread.cpp ===
#include "priv.h"
#include <iethread.h>
#include "hnfblock.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

BOOL _GetToken(LPCWSTR *ppszCmdLine, LPWSTR szToken, UINT cchMax)
{
    LPCWSTR pszCmdLine = *ppszCmdLine;

    WCHAR chTerm = L' ';
    if (*pszCmdLine == L'"') {
        chTerm = L'"';
        pszCmdLine++;
    }

    UINT ichToken = 0;
    WCHAR ch;
    while((ch=*pszCmdLine) && (ch != chTerm)) {
        if (ichToken < cchMax-1) {
            szToken[ichToken++] = ch;
        }
        pszCmdLine++;
    }

    szToken[ichToken] = L'\0';

    if (chTerm == L'"' && ch == L'"') {
        pszCmdLine++;
    }

    // skip trailing spaces
    while(*pszCmdLine == L' ')
        pszCmdLine++;

    *ppszCmdLine = pszCmdLine;

    TraceMsgW(TF_SHDAUTO, "_GetToken returning %s (+%s)", szToken, pszCmdLine);

    return szToken[0];
}

BOOL _CheckForOptionOnCmdLine(LPCWSTR *ppszCmdLine, LPCWSTR pszOption)
{
    LPCWSTR pszCmdLine = *ppszCmdLine;
    int cch = lstrlenW(pszOption);

    if (0 == StrCmpNIW(pszCmdLine, pszOption, cch))
    {
        pszCmdLine+= cch;
        while(*pszCmdLine == L' ')
            pszCmdLine++;

        *ppszCmdLine = pszCmdLine;
        return TRUE;
    }
    return FALSE;
}

BOOL IsCalleeIEAK()
{
    // APPCOMPAT: this is hack so as to allow IEAK CD install to continue without
    // any security restrictions. If the IEAK CD install window name changes
    // the name change should also reflect here.
    return (FindWindow(TEXT("IECD"), NULL) != NULL);
}

BOOL SHParseIECommandLine(LPCWSTR *ppwszCmdLine, IETHREADPARAM * piei)
{
    ASSERT(ppwszCmdLine);
    ASSERT(*ppwszCmdLine);
    LPCWSTR pszCmdLine = *ppwszCmdLine;

#ifdef UNIX
    if( CheckForInvalidOptions( *ppwszCmdLine ) == FALSE )
    {
        piei->fShouldStart = FALSE;
        return FALSE;
    }

    // Options valid.
    piei->fShouldStart = TRUE;
#endif

    TraceMsg(TF_SHDAUTO, "SHParseIECommandLine called with %s", pszCmdLine);

    BOOL fDontLookForPidl = FALSE; // A flag option is set, so don't go looking for an open window 
                                   // with the same pidl
                                   // FEATURE: (dli) what if there is a window opened with the same flags?
    while (*pszCmdLine == L'-')
    {
        fDontLookForPidl = TRUE;
        
        //Note: (dli)These flags are supposed to be set to FALSE at initialization
        // check if -nohome was passed in!
        //
        if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-slf") && !IsOS(OS_WIN2000ORGREATER) && IsCalleeIEAK())
            piei->fNoLocalFileWarning = TRUE;
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-nohome"))
            piei->fDontUseHomePage = TRUE;
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-k"))
        {
            piei->fFullScreen = TRUE;
            piei->fNoDragDrop = TRUE;
        }
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-embedding"))
        {
            piei->fAutomation = TRUE;
            // if we're started as an embedding, we don't want to go to our start page
            piei->fDontUseHomePage = TRUE;
        } 
#ifndef UNIX
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-channelband"))
        {
            piei->fDesktopChannel = TRUE;
        } 
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-e")) 
        {
            piei->uFlags |= COF_EXPLORE;

        } 
#else
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-help"))
        {
            piei->fShouldStart = FALSE;
            PrintIEHelp();
            break;
        } 
        else if  (_CheckForOptionOnCmdLine(&pszCmdLine, L"-v") || 
                  _CheckForOptionOnCmdLine(&pszCmdLine, L"-version")) 
        {
            piei->fShouldStart = FALSE;
            PrintIEVersion();
            break;
        } 
#endif
        else if (_CheckForOptionOnCmdLine(&pszCmdLine, L"-root")) 
        {
            ASSERT(piei->pidlRoot==NULL);
            WCHAR szRoot[MAX_PATH];
            if (_GetToken(&pszCmdLine, szRoot, ARRAYSIZE(szRoot))) 
            {
                CLSID clsid, *pclsid = NULL;
                
                TraceMsgW(TF_SHDAUTO, "SHParseIECommandLine got token for /root %s", szRoot);

                if (GUIDFromString(szRoot, &clsid))
                {
                    pclsid = &clsid;
                    _GetToken(&pszCmdLine, szRoot, ARRAYSIZE(szRoot));
                }

                if (szRoot[0]) 
                {
                    LPITEMIDLIST pidlRoot = ILCreateFromPathW(szRoot);
                    if (pidlRoot) 
                    {
                        piei->pidl = ILRootedCreateIDList(pclsid, pidlRoot);
                        ILFree(pidlRoot);
                    } 
                }
            }
        }
        else
        {
#ifdef UNIX
            piei->fShouldStart = FALSE;
#endif
            // unknown option..
            fDontLookForPidl = FALSE;
            break;
        }
    }

    *ppwszCmdLine = pszCmdLine;
    
    return fDontLookForPidl;
}

IETHREADPARAM* SHCreateIETHREADPARAM(LPCWSTR pszCmdLineIn, int nCmdShowIn, ITravelLog *ptlIn, IEFreeThreadedHandShake* piehsIn)
{
    IETHREADPARAM *piei = (IETHREADPARAM *)LocalAlloc(LPTR, sizeof(IETHREADPARAM));
    if (piei)
    {
        piei->pszCmdLine = pszCmdLineIn;    // careful, aliased pointer
        piei->nCmdShow = nCmdShowIn;
        piei->ptl = ptlIn;
        piei->piehs = piehsIn;

        if (piehsIn)
            piehsIn->AddRef();

        if (ptlIn)
            ptlIn->AddRef();
#ifdef UNIX
        piei->fShouldStart = TRUE;
#endif
#ifdef NO_MARSHALLING
        piei->fOnIEThread = TRUE;
#endif 
    }

    return piei;
}

IETHREADPARAM* SHCloneIETHREADPARAM(IETHREADPARAM* pieiIn)
{
    IETHREADPARAM *piei = (IETHREADPARAM *)LocalAlloc(LPTR, sizeof(IETHREADPARAM));
    if (piei)
    {
        *piei = *pieiIn;

        // convert aliased pointers into refs

        if (piei->pidl)
            piei->pidl = ILClone(piei->pidl);
    
        if (piei->pidlSelect)
            piei->pidlSelect = ILClone(piei->pidlSelect);
    
        if (piei->pidlRoot)
            piei->pidlRoot = ILClone(piei->pidlRoot);
    
        if (piei->psbCaller)
            piei->psbCaller->AddRef();
    
        if (piei->ptl)
            piei->ptl->Clone(&piei->ptl);
    }
    return piei;

}

void SHDestroyIETHREADPARAM(IETHREADPARAM* piei)
{
    if (piei)
    {
        if (piei->pidl)
            ILFree(piei->pidl);
    
        if (piei->pidlSelect)
            ILFree(piei->pidlSelect);
    
        if (((piei->uFlags & COF_HASHMONITOR) == 0) && piei->pidlRoot)
            ILFree(piei->pidlRoot);
    
        if (piei->piehs)
            piei->piehs->Release();   // note, this is not a COM object, don't ATOMICRELEASE();

        ATOMICRELEASE(piei->psbCaller);
        ATOMICRELEASE(piei->pSplash);
        ATOMICRELEASE(piei->ptl);
        ATOMICRELEASE(piei->punkRefProcess);

        LocalFree(piei);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\iface.h ===
#ifndef _IFACE_H
#define _IFACE_H

// Interfaces and IIDs defined here are private to shdocvw.dll
//


//
// IDocNavigate
//
// DocHost needs to notify the browser of certain events
//
//131A6950-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IDocNavigate
DECLARE_INTERFACE_(IDocNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocNavigate methods ***
    STDMETHOD(OnReadyStateChange)(THIS_ IShellView* psvSource, DWORD dwReadyState) PURE;
    STDMETHOD(get_ReadyState)(THIS_ DWORD * pdwReadyState) PURE;

} ;

//
// IBandNavigate
//
//  band needs to navigate its UI to a specific pidl.
//
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;


//
// IEFrameAuto
//
// CIEFrameAuto private interface to hold randum stuff
//
//131A6953-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IEFrameAuto
DECLARE_INTERFACE_(IEFrameAuto, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IEFrameAuto methods ***
    STDMETHOD(SetOwnerHwnd)(THIS_ HWND hwndOwner) PURE;
    STDMETHOD(put_DefaultReadyState)(THIS_ DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState) PURE;
    STDMETHOD(OnDocumentComplete)(THIS) PURE;
    STDMETHOD(OnWindowsListMarshalled)(THIS) PURE;
} ;

//
// IPrivateOleObject
//
// a cut down version of IOleObject used for the WebBrowserOC to communicate with
// objects hosted via CDocObjectView
#undef INTERFACE
#define INTERFACE IPrivateOleObject
DECLARE_INTERFACE_(IPrivateOleObject, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPrivateOleObject
    STDMETHOD( SetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
    STDMETHOD( GetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
};


STDAPI AddUrlToUrlHistoryStg(LPCWSTR pwszUrl, LPCWSTR pwszTitle, LPUNKNOWN punk, 
                             BOOL fWriteToHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory,
                             UINT* pcodepage);

#ifdef __cplusplus

//
// LATER: Move all ITravelLog/ITravelEntry definitions here
//
// TLOG_BACKEXTERNAL -- succeeds only if the previous entry is external
//
#define TLOG_BACKEXTERNAL   -0x7fffffff

#endif // __cplusplus

#endif // _IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\itbar.h ===
#ifndef _ITBAR_H
#define _ITBAR_H

// initial layout information
typedef struct tagBANDSAVE
{
    UINT wID;
    UINT fStyle;
    UINT cx;
} BANDSAVE, *PBANDSAVE;

// CItnernet Toolbar - Private commands 
#define CITIDM_ONINTERNET    1  // nCmdexecopt ? Web : Shell
#define CITE_INTERNET       0
#define CITE_SHELL          1
#define CITE_QUERY          2

#define CITIDM_THEATER       2  // nCmdexecopt..
#define CITIDM_TEXTLABELS    3  // Toggle Text Labels
// the modes for theater mode
#define THF_ON  0            
#define THF_OFF 1
#define THF_UNHIDE 2 
#define THF_HIDE  3
                   
// Indicies for Coolbar bands
// These indexes are 1 based since band array is memset to 0 and ShowDW would 
// think that an unused item would belong to IDX0.

// IMPORTANT: don't change the value of anything between CBIDX_FIRST and CBIDX_LAST.
// CInternetToolbar::_LoadUpgradeSettings assumes these values haven't changed from
// version to version.
#define CBIDX_MENU              1
#define CBIDX_TOOLS             2
#define CBIDX_LINKS             3
#define CBIDX_ADDRESS           4
#define CBIDX_BRAND             5
#define CBIDX_FIRST             CBIDX_MENU
#define CBIDX_LAST              CBIDX_BRAND

#define MAXEXTERNALBANDS        16
#define CBIDX_EXTERNALFIRST     (CBIDX_LAST + 1)
#define CBIDX_EXTERNALLAST      (CBIDX_EXTERNALFIRST + MAXEXTERNALBANDS - 1)

#define CBANDSMAX               (CBIDX_LAST + MAXEXTERNALBANDS)

#define CITIDM_VIEWEXTERNALBAND_FIRST 30
#define CITIDM_VIEWEXTERNALBAND_LAST (CITIDM_VIEWEXTERNALBAND_FIRST + MAXEXTERNALBANDS - 1)

#define BandIDtoIndex(hwnd, idx) SendMessage(hwnd, RB_IDTOINDEX, idx, 0)


// Indices for Toolbar imagelists
#define IMLIST_DEFAULT          0
#define IMLIST_HOT              1

#define ITBS_SHELL    0
#define ITBS_WEB      1
#define ITBS_EXPLORER 2
IStream *GetITBarStream(BOOL fWebBrowser, DWORD grfMode);

// number of bitmaps in the IDB_IETOOLBAR strips
#define MAX_TB_BUTTONS          16

#define SHELLGLYPHS_OFFSET      MAX_TB_BUTTONS

#endif /* _ITBAR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\imgctx.cpp ===
#include "priv.h"
#include <iimgctx.h>


class CImgCtxThumb :  public IExtractImage2,
                      public IRunnableTask,
                      public IPersistFile
{
public:
    CImgCtxThumb();
    ~CImgCtxThumb();

    STDMETHOD(QueryInterface) (REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IExtractImage
    STDMETHOD (GetLocation) (LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags);

    STDMETHOD (Extract)(HBITMAP * phBmpThumbnail);

    STDMETHOD (GetDateStamp) (FILETIME * pftTimeStamp);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID *pClassID);
    STDMETHOD (IsDirty)();
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR *ppszFileName);

    STDMETHOD (Run)();
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)();

    STDMETHOD (InternalResume)();

protected:
    friend void CALLBACK OnImgCtxChange(void * pvImgCtx, void * pv);
    void CImgCtxThumb::CalcAspectScaledRect(const SIZE * prgSize,
                                             RECT * pRect);
    void CImgCtxThumb::CalculateAspectRatio(const SIZE * prgSize,
                                             RECT * pRect);

    long m_cRef;
    BITBOOL m_fAsync : 1;
    BITBOOL m_fOrigSize : 1;
    WCHAR m_szPath[MAX_PATH * 4 + 7];
    HANDLE m_hEvent;
    SIZE m_rgSize;
    DWORD m_dwRecClrDepth;
    IImgCtx * m_pImg;
    LONG m_lState;
    HBITMAP * m_phBmp;
};

STDAPI CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CImgCtxThumb * pExtract = new CImgCtxThumb();
    if (pExtract != NULL)
    {
        *ppunk = SAFECAST(pExtract, IPersistFile *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CImgCtxThumb::CImgCtxThumb()
{
    m_fAsync = FALSE;
    StrCpyW(m_szPath, L"file://");
    m_cRef = 1;

    DllAddRef();
}


CImgCtxThumb::~CImgCtxThumb()
{
    ATOMICRELEASE(m_pImg);
    if (m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
    DllRelease();
}

STDMETHODIMP CImgCtxThumb::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CImgCtxThumb, IExtractImage, IExtractImage2),
        QITABENT(CImgCtxThumb, IExtractImage2),
        QITABENT(CImgCtxThumb, IRunnableTask),
        QITABENT(CImgCtxThumb, IPersistFile),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CImgCtxThumb::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CImgCtxThumb::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CImgCtxThumb::GetLocation (LPWSTR pszPathBuffer,
                                         DWORD cch,
                                         DWORD * pdwPriority,
                                         const SIZE * prgSize,
                                         DWORD dwRecClrDepth,
                                         DWORD *pdwFlags)
{
    if (!pdwFlags || !pszPathBuffer || !prgSize)
    {
        return E_INVALIDARG;
    }

    m_rgSize = *prgSize;
    m_dwRecClrDepth = dwRecClrDepth;

    HRESULT hr = S_OK;
    if (*pdwFlags & IEIFLAG_ASYNC)
    {
        if (!pdwPriority)
        {
            return E_INVALIDARG;
        }

        hr = E_PENDING;
        m_fAsync = TRUE;
    }

    m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);

    *pdwFlags = IEIFLAG_CACHE;

    PathCreateFromUrlW(m_szPath, pszPathBuffer, &cch, URL_UNESCAPE);

    return hr;
}

void CALLBACK OnImgCtxChange(void * pvImgCtx, void * pv)
{
    CImgCtxThumb * pThis = (CImgCtxThumb *) pv;
    ASSERT(pThis);
    ASSERT(pThis->m_hEvent);

    // we only asked to know about complete anyway....
    SetEvent(pThis->m_hEvent);
}

// This function makes no assumption about whether the thumbnail is square, so
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
void CImgCtxThumb::CalcAspectScaledRect(const SIZE * prgSize, RECT * pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = (iWidth * 1000) / prgSize->cx;
    int iYRatio = (iHeight * 1000) / prgSize->cy;

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;

        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = ((iHeight * 1000) / iXRatio);
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }

        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = ((iWidth * 1000) / iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;

        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}

void CImgCtxThumb::CalculateAspectRatio(const SIZE * prgSize, RECT * pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

STDMETHODIMP CImgCtxThumb::Extract(HBITMAP * phBmpThumbnail)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hEvent)
    {
        return E_OUTOFMEMORY;
    }

    m_phBmp = phBmpThumbnail;

    return InternalResume();
}

STDMETHODIMP CImgCtxThumb::GetDateStamp(FILETIME * pftTimeStamp)
{
    ASSERT(pftTimeStamp);

    WIN32_FIND_DATAW rgData;
    WCHAR szBuffer[MAX_PATH];

    DWORD dwSize = ARRAYSIZE(szBuffer);
    PathCreateFromUrlW(m_szPath, szBuffer, &dwSize, URL_UNESCAPE);

    HANDLE hFind = FindFirstFileW(szBuffer, &rgData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        *pftTimeStamp = rgData.ftLastWriteTime;
        FindClose(hFind);
        return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CImgCtxThumb::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (!pszFileName)
    {
        return E_INVALIDARG;
    }

    if (lstrlenW(pszFileName) > ARRAYSIZE(m_szPath) - 6)
    {
        return E_FAIL;
    }

    DWORD dwSize = ARRAYSIZE(m_szPath);
    UrlCreateFromPathW(pszFileName, m_szPath, &dwSize, URL_ESCAPE_UNSAFE);

    return S_OK;
}

STDMETHODIMP CImgCtxThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Run()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImgCtxThumb::Kill(BOOL fUnused)
{
    LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_PENDING);
    if (lRes != IRTIR_TASK_RUNNING)
    {
        m_lState = lRes;
    }

    if (m_hEvent)
        SetEvent(m_hEvent);

    return S_OK;
}

STDMETHODIMP CImgCtxThumb::Resume()
{
    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return S_FALSE;
    }

    return InternalResume();
}

STDMETHODIMP CImgCtxThumb::Suspend()
{
    LONG lRes = InterlockedExchange(& m_lState, IRTIR_TASK_SUSPENDED);
    if (lRes != IRTIR_TASK_RUNNING)
    {
        m_lState = lRes;
    }

    if (m_hEvent)
        SetEvent(m_hEvent);

    return S_OK;
}

STDMETHODIMP_(ULONG) CImgCtxThumb::IsRunning()
{
    return m_lState;
}

STDMETHODIMP CImgCtxThumb::InternalResume()
{
    if (m_phBmp == NULL)
    {
        return E_UNEXPECTED;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = S_OK;
    if (!m_pImg)
    {
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImgCtx, &m_pImg));
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pImg);

            hr = m_pImg->Load(m_szPath, DWN_RAWIMAGE | m_dwRecClrDepth);
            if (SUCCEEDED(hr))
            {
                hr = m_pImg->SetCallback(OnImgCtxChange, this);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_pImg->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);
            }
            if (FAILED(hr))
            {
                ATOMICRELEASE(m_pImg);
                m_lState = IRTIR_TASK_FINISHED;
                return hr;
            }
        }
        else
        {
            m_lState = IRTIR_TASK_FINISHED;
            return hr;
        }
    }

    ULONG fState;
    SIZE  rgSize;

    m_pImg->GetStateInfo(&fState, &rgSize, TRUE);

    if (!(fState & IMGLOAD_COMPLETE))
    {
        do
        {
            DWORD dwRet = MsgWaitForMultipleObjects(1, &m_hEvent, FALSE, INFINITE, QS_ALLINPUT);

            if (dwRet != WAIT_OBJECT_0)
            {
                // check the event anyway, msgs get checked first, so
                // it could take a while for this to get fired otherwise..
                dwRet = WaitForSingleObject(m_hEvent, 0);
            }
            if (dwRet == WAIT_OBJECT_0)
            {
                break;
            }

            MSG msg;
            // empty the message queue...
            while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if ((msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST) ||
                    (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST  && msg.message != WM_MOUSEMOVE))
                {
                    continue;
                }

                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        } while (TRUE);

        // check why we broke out...
        if (m_lState == IRTIR_TASK_PENDING)
        {
            m_lState = IRTIR_TASK_FINISHED;
            m_pImg->Disconnect();
            ATOMICRELEASE(m_pImg);
            return E_FAIL;
        }
        if (m_lState == IRTIR_TASK_SUSPENDED)
            return E_PENDING;
        m_pImg->GetStateInfo(&fState, &rgSize, TRUE);
    }

    hr = (fState & IMGLOAD_ERROR) ? E_FAIL : S_OK;

    if (SUCCEEDED(hr))
    {
        HDC hdc = GetDC(NULL);
        // LINTASSERT(hdc || !hdc);     // 0 semi-ok
        void *lpBits;

        HDC hdcBmp = CreateCompatibleDC(hdc);
        if (hdcBmp && hdc)
        {
            struct {
                BITMAPINFOHEADER bi;
                DWORD            ct[256];
            } dib;

            dib.bi.biSize            = sizeof(BITMAPINFOHEADER);
            // On NT5 we go directly to the thumbnail with StretchBlt
            // on other OS's we make a full size copy and pass the bits
            // to ScaleSharpen2().
            if (IsOS(OS_WIN2000ORGREATER))
            {
                dib.bi.biWidth       = m_rgSize.cx;
                dib.bi.biHeight      = m_rgSize.cy;
            }
            else
            {
                dib.bi.biWidth       = rgSize.cx;
                dib.bi.biHeight      = rgSize.cy;
            }
            dib.bi.biPlanes          = 1;
            dib.bi.biBitCount        = (WORD) m_dwRecClrDepth;
            dib.bi.biCompression     = BI_RGB;
            dib.bi.biSizeImage       = 0;
            dib.bi.biXPelsPerMeter   = 0;
            dib.bi.biYPelsPerMeter   = 0;
            dib.bi.biClrUsed         = (m_dwRecClrDepth <= 8) ? (1 << m_dwRecClrDepth) : 0;
            dib.bi.biClrImportant    = 0;

            HPALETTE hpal = NULL;
            HPALETTE hpalOld = NULL;

            if (m_dwRecClrDepth <= 8)
            {
                if (m_dwRecClrDepth == 8)
                {
                    // need to get the right palette....
                    hr = m_pImg->GetPalette(& hpal);
                }
                else
                {
                    hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
                }

                if (SUCCEEDED(hr) && hpal)
                {
                    hpalOld = SelectPalette(hdcBmp, hpal, TRUE);
                    // LINTASSERT(hpalOld || !hpalOld); // 0 semi-ok for SelectPalette
                    RealizePalette(hdcBmp);

                    int n = GetPaletteEntries(hpal, 0, 256, (LPPALETTEENTRY)&dib.ct[0]);

                    ASSERT(n >= (int) dib.bi.biClrUsed);
                    for (int i = 0; i < (int)dib.bi.biClrUsed; i ++)
                        dib.ct[i] = RGB(GetBValue(dib.ct[i]),GetGValue(dib.ct[i]),GetRValue(dib.ct[i]));
                }
            }

            HBITMAP hBmp = CreateDIBSection(hdcBmp, (LPBITMAPINFO)&dib, DIB_RGB_COLORS, &lpBits, NULL, 0);
            if (hBmp != NULL)
            {
                HGDIOBJ hOld = SelectObject(hdcBmp, hBmp);

                // On NT5 Go directly to the Thumbnail with StretchBlt()
                if (IsOS(OS_WIN2000ORGREATER))
                {
                    // Compute output size of thumbnail
                    RECT rectThumbnail;
                    rectThumbnail.left   = 0;
                    rectThumbnail.top    = 0;
                    
                    rectThumbnail.right  = m_rgSize.cx;
                    rectThumbnail.bottom = m_rgSize.cy;
                    
                    FillRect(hdcBmp, &rectThumbnail, (HBRUSH) (COLOR_WINDOW+1));
                    rectThumbnail.right  = rgSize.cx;
                    rectThumbnail.bottom = rgSize.cy;

                    CalculateAspectRatio (&m_rgSize, &rectThumbnail);

                    // Call DanielC for the StretchBlt
                    SetStretchBltMode (hdcBmp, HALFTONE);

                    // Create the thumbnail
                    m_pImg->StretchBlt(hdcBmp,
                                        rectThumbnail.left,
                                        rectThumbnail.top,
                                        rectThumbnail.right - rectThumbnail.left,
                                        rectThumbnail.bottom - rectThumbnail.top,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        SRCCOPY);

                    SelectObject(hdcBmp, hOld);

                    *m_phBmp = hBmp;
                }
                else
                {
                    //
                    // On systems other than NT5 make a full size copy of
                    // the bits and pass the copy to ScaleSharpen2().
                    //
                    RECT rectThumbnail;
                    rectThumbnail.left   = 0;
                    rectThumbnail.top    = 0;
                    
                    rectThumbnail.right  = rgSize.cx;
                    rectThumbnail.bottom = rgSize.cy;
                    
                    FillRect(hdcBmp, &rectThumbnail, (HBRUSH) (COLOR_WINDOW+1));

                    m_pImg->StretchBlt(hdcBmp,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        0, 0,
                                        rgSize.cx,
                                        rgSize.cy,
                                        SRCCOPY);

                    SelectObject(hdcBmp, hOld);

                    if (m_rgSize.cx == rgSize.cx && m_rgSize.cy == rgSize.cy)
                    {
                        *m_phBmp = hBmp;
                    }
                    else
                    {
                        SIZEL rgCur;
                        rgCur.cx = rgSize.cx;
                        rgCur.cy = rgSize.cy;

                        IScaleAndSharpenImage2 * pScale;
                        hr = CoCreateInstance(CLSID_ThumbnailScaler, NULL, CLSCTX_INPROC_SERVER,
                                               IID_PPV_ARG(IScaleAndSharpenImage2, &pScale));
                        if (SUCCEEDED(hr))
                        {
                            hr = pScale->ScaleSharpen2((BITMAPINFO *) &dib,
                                                        lpBits,
                                                        m_phBmp,
                                                        &m_rgSize,
                                                        m_dwRecClrDepth,
                                                        hpal,
                                                        20, m_fOrigSize);
                            pScale->Release();
                        }
                        DeleteObject(hBmp);
                    }
                }
            }
            if (SUCCEEDED(hr) && hpal && m_dwRecClrDepth <= 8)
            {
                (void) SelectPalette(hdcBmp, hpalOld, TRUE);
                RealizePalette(hdcBmp);
            }
            if (m_dwRecClrDepth < 8)
            {
                // we used a stock 16 colour palette
                DeletePalette(hpal);
            }
        }
        if (hdc)
        {
            ReleaseDC(NULL, hdc);
        }
        if (hdcBmp)
        {
            DeleteDC(hdcBmp);
        }
    }
    m_pImg->Disconnect();
    ATOMICRELEASE(m_pImg);
    
    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\itbdrop.h ===
//
//  ITBDROP_H
//  Header file for the internet toolbar's drop target.
//
//  History:
//      8/22/96 -   t-mkim: created

#ifndef _ITBDROP_H
#define _ITBDROP_H

#define TBIDM_BACK              0x120
#define TBIDM_FORWARD           0x121
#define TBIDM_HOME              0x122
#define TBIDM_SEARCH            0x123  // copy of this in shdocvw\basesb.cpp
#define TBIDM_STOPDOWNLOAD      0x124
#define TBIDM_REFRESH           0x125
#define TBIDM_FAVORITES         0x126
#define TBIDM_THEATER           0x128
#define TBIDM_HISTORY           0x12E
#define TBIDM_PREVIOUSFOLDER    0x130
#define TBIDM_CONNECT           0x131
#define TBIDM_DISCONNECT        0x132
#define TBIDM_ALLFOLDERS        0x133
#define TBIDM_MEDIABAR          0x134

#define REGSTR_SET_HOMEPAGE_RESTRICTION               TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGVAL_HOMEPAGE_RESTRICTION                   TEXT("HomePage")

// Class for implementing a single drop target for all the various and sundry things
// that can be dropped onto on the internet toolbar.
class CITBarDropTarget : public IDropTarget
{
private:
    ULONG _cRef;
    HWND _hwndParent;
    IDropTarget *_pdrop;    // hand on to the the favorites target
    int _iDropType;         // Which format data is in.
    int _iTarget;           // what item are we running for

public:
    CITBarDropTarget(HWND hwnd, int iTarget);

    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef (void);
    STDMETHODIMP_(ULONG) Release (void);

    STDMETHODIMP DragEnter(IDataObject *dtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
};

#endif //_ITBDROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\imgcache.cpp ===
#include "priv.h"

HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig)
{
    HDC     hdc, hdcMem1, hdcMem2;
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;
    int     IncOne = 0;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    hdc = GetDC(NULL);

    if (hdc)
    {
        hdcMem1 = CreateCompatibleDC(hdc);

        if (!hdcMem1)
        {
            ReleaseDC(NULL, hdc);
            return NULL;
        }
    
        hdcMem2 = CreateCompatibleDC(hdc);
        if (!hdcMem2)
        {
            DeleteDC(hdcMem1);
            ReleaseDC(NULL, hdc);
            return NULL;
        }

        hbm = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);

        if (!hbm)
        {
            ReleaseDC(NULL, hdc);
            DeleteDC(hdcMem1);
            DeleteDC(hdcMem2);
            return NULL;
        }

        //
        // Flip the bitmap
        //
        hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
        hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

        SET_DC_RTL_MIRRORED(hdcMem2);
        if (g_bRunOnMemphis)
        {
            // off-by-one on win98 or higher copying from non-mirrored to mirrored DC
            IncOne++;
        }   

        BitBlt(hdcMem2, IncOne, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);

        SelectObject(hdcMem1, hOld_bm1 );
        SelectObject(hdcMem1, hOld_bm2 );
    
        DeleteDC(hdcMem1);
        DeleteDC(hdcMem2);

        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

HICON CreateMirroredIcon(HICON hiconOrg)
{
    HDC      hdcScreen, hdcBitmap, hdcMask = NULL;
    HBITMAP  hbm, hbmMask, hbmOld,hbmOldMask;
    BITMAP   bm;
    ICONINFO ii;
    HICON    hicon = NULL;
#ifdef WINNT
#define      IPIXELOFFSET 0 
#else // !WINNT
#define      IPIXELOFFSET 2
#endif WINNT

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap)
    {
        hdcMask = CreateCompatibleDC(NULL);

        if( hdcMask )
        {

            SET_DC_RTL_MIRRORED(hdcBitmap);
            SET_DC_RTL_MIRRORED(hdcMask);
        }
        else
        {
            DeleteDC( hdcBitmap );
            hdcBitmap = NULL;
        }
    }
         
    hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        if (hdcBitmap && hdcMask) 
        {
            if (hiconOrg)
            {
                if (GetIconInfo(hiconOrg, &ii) &&
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm))
                {
                    //
                    // I don't want these.
                    //
                    DeleteObject( ii.hbmMask );
                    DeleteObject( ii.hbmColor );
                    ii.hbmMask = ii.hbmColor = NULL;

                    hbm = CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
                    hbmMask = CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                    hbmOld = (HBITMAP)SelectObject(hdcBitmap, hbm);
                    hbmOldMask = (HBITMAP)SelectObject(hdcMask, hbmMask);
      
                    DrawIconEx(hdcBitmap, IPIXELOFFSET, 0, hiconOrg, bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_IMAGE);

                    DrawIconEx(hdcMask, IPIXELOFFSET, 0, hiconOrg, bm.bmWidth, bm.bmHeight, 0,
                               NULL, DI_MASK);

                    SelectObject(hdcBitmap, hbmOld);
                    SelectObject(hdcMask, hbmOldMask);

                    //
                    // create the new mirrored icon, and delete bmps
                    //
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbm;
                    hicon = CreateIconIndirect(&ii);

                    DeleteObject(hbm);
                    DeleteObject(hbmMask);
                }
               
            }
        }

        ReleaseDC(NULL, hdcScreen);
    }

    if (hdcBitmap)
        DeleteDC(hdcBitmap);

    if (hdcMask)
        DeleteDC(hdcMask);

    return hicon;
}

HBITMAP AddImage_PrepareBitmap(LPCIMAGECACHEINFO pInfo, HBITMAP hbmp)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        return CreateMirroredBitmap(hbmp);
    }
    else 
    {
        return hbmp;
    }    
 }

HICON AddImage_PrepareIcon(LPCIMAGECACHEINFO pInfo, HICON hicon)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        return CreateMirroredIcon(hicon);
    }
    else 
    {
        return hicon;
    }    
}

void AddImage_CleanupBitmap(LPCIMAGECACHEINFO pInfo, HBITMAP hbmp)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        if (hbmp)
        {
            DeleteObject(hbmp);
        }    
    }
}

void AddImage_CleanupIcon(LPCIMAGECACHEINFO pInfo, HICON hicon)
{
    if (pInfo->dwMask & ICIFLAG_MIRROR)
    {
        if (hicon)
        {
            DestroyIcon(hicon);
        }    
    }
}

///////////////////////////////////////////////////////////////////////////////////
typedef struct 
{
    UINT        uImageIndex;  // The actual Image Index

    // USAGE COUNT
    UINT        iUsage;     // usage count....
    DWORD       dwUsage;    // usage information

    // SEARCH KEYS
    DWORD       dwFlags;    // key: flags
    int         iIndex;     // data: icon index
    FILETIME    ftDateStamp;
    WCHAR   szName[1];        // the filename of the item....
} ICONCACHE_DATA, *PICONCACHE_DATA;

#define ICD_NOUSAGE 0x0001
#define ICD_DELETED 0x0002
#define ICD_SYSTEM  0x0004

class CImageListCache : public IImageCache3
{
public:
    CImageListCache( void );
    ~CImageListCache( void );

    STDMETHOD ( QueryInterface )( REFIID riid, void ** ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    STDMETHOD ( AddImage )( LPCIMAGECACHEINFO pInfo, UINT * puImageIndex );
    STDMETHOD ( FindImage )( LPCIMAGECACHEINFO pInfo, UINT * puImageIndex );
    STDMETHOD ( FreeImage )( UINT iImageIndex );
    STDMETHOD ( Flush )( BOOL fRelease );
    STDMETHOD ( ChangeImageInfo )( UINT iImageIndex, LPCIMAGECACHEINFO pInfo );
    STDMETHOD ( GetCacheSize )( UINT * puSize );
    STDMETHOD ( GetUsage )( UINT iImageIndex, UINT * puUsage );
    STDMETHOD ( GetImageList )( LPIMAGECACHEINITINFO pInfo );

    STDMETHOD ( DeleteImage )( UINT iImageIndex );
    STDMETHOD ( GetImageInfo )( UINT iImageIndex, LPIMAGECACHEINFO pInfo );

    STDMETHOD ( GetImageIndexFromCacheIndex )( UINT iCacheIndex, UINT * puImageIndex );

protected:  //internal methods.
    UINT CountFreeSlots( void );
    int FindEmptySlot( void );
    ICONCACHE_DATA * CreateDataNode( LPCIMAGECACHEINFO pInfo ) const;
    
    ICONCACHE_DATA * GetNodeFromImageIndex( UINT iImageIndex );
    UINT GetNodeIndexFromImageIndex( UINT iImageIndex );

    HDPA             m_hListData;
    HIMAGELIST       m_himlLarge;
    HIMAGELIST       m_himlSmall;
    CRITICAL_SECTION m_csLock;
    DWORD            m_dwFlags;
    long             m_cRef;
};

STDAPI CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CImageListCache * pCache = new CImageListCache();
    if (pCache != NULL)
    {
        *ppunk = SAFECAST(pCache, IImageCache *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

STDMETHODIMP CImageListCache::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CImageListCache, IImageCache),
        QITABENT(CImageListCache, IImageCache2),
        QITABENT(CImageListCache, IImageCache3),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageListCache::AddRef()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

STDMETHODIMP_(ULONG) CImageListCache::Release()
{
    if (InterlockedDecrement( &m_cRef ))
        return m_cRef;

    delete this;
    return 0;
}

int CALLBACK DestroyEnum( void *p, void *pData )
{
    ASSERT( p );

    if ( p )
    {
        LocalFree((ICONCACHE_DATA *) p);
    }

    return TRUE;
}

int CALLBACK UsageEnum( void *p, void *pData )
{
    ASSERT( p);
    ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) p;

    pNode->iUsage = PtrToUlong(pData);
    pNode->dwUsage = 0;
    
    return TRUE;
}

CImageListCache::CImageListCache( )
{
    // imagelist info.
    InitializeCriticalSection( &m_csLock );
    m_cRef = 1;

    DllAddRef();
}

CImageListCache::~CImageListCache( )
{
    // don't bother entering the critical section, if we shouldn't be accessed
    // by multiple threads if we have reached the destructor...
    
    if ( m_himlLarge ) 
    {
        ImageList_Destroy( m_himlLarge );
    }
    if ( m_himlSmall ) 
    {
        ImageList_Destroy( m_himlSmall );
    }

    if ( m_hListData )
    {
        DPA_DestroyCallback( m_hListData, DestroyEnum, NULL );
        m_hListData = NULL;
    }
    
    DeleteCriticalSection( &m_csLock );

    DllRelease();
}

ICONCACHE_DATA * CImageListCache::CreateDataNode(LPCIMAGECACHEINFO pInfo ) const
{
    UINT cbSize = sizeof( ICONCACHE_DATA );
    if ( pInfo->dwMask & ICIFLAG_NAME )
    {
        ASSERT( pInfo->pszName );
        cbSize += lstrlenW( pInfo->pszName ) * sizeof( WCHAR );
    }

    // zero init mem alloc
    ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) LocalAlloc( LPTR, cbSize );
    if ( !pNode )
    {
        return NULL;
    }
    
    // fill in the data...
    if ( pInfo->dwMask & ICIFLAG_NAME )
    {
        StrCpyW( pNode->szName, pInfo->pszName );
    }
    pNode->iIndex = pInfo->iIndex;
    pNode->dwFlags = pInfo->dwFlags;
    pNode->iUsage = 1;
    pNode->ftDateStamp = pInfo->ftDateStamp;

    if ( pInfo->dwMask & ICIFLAG_NOUSAGE )
    {
        pNode->dwUsage |= ICD_NOUSAGE;
    }
    if ( pInfo->dwMask & ICIFLAG_SYSTEM )
    {
        pNode->dwUsage |= ICD_SYSTEM;
    }

    return pNode;
}

STDMETHODIMP CImageListCache::AddImage(LPCIMAGECACHEINFO pInfo, UINT * puImageIndex)
{
    if ( !pInfo || !puImageIndex || !(pInfo->dwMask & (ICIFLAG_LARGE | ICIFLAG_SMALL)) ||
                                    !(pInfo->dwMask & (ICIFLAG_BITMAP | ICIFLAG_ICON )))
    {
        return E_INVALIDARG;
    }

    ICONCACHE_DATA * pNode = CreateDataNode( pInfo );
    if ( !pNode )
    {
        return E_OUTOFMEMORY;
    }

    EnterCriticalSection( &m_csLock );
    int iImageIndex = -1;
    int iCacheIndex = FindEmptySlot();
    if (iCacheIndex != -1)
    {
        // swap for the old one...
        ICONCACHE_DATA * pOld = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if (m_dwFlags & ICIIFLAG_SORTBYUSED)
        {
            DPA_DeletePtr( m_hListData, iCacheIndex);
            DPA_AppendPtr( m_hListData, pNode);
            iImageIndex = pNode->uImageIndex = pOld->uImageIndex;
        }
        else
        {
            DPA_SetPtr( m_hListData, iCacheIndex, pNode);
            iImageIndex = pNode->uImageIndex = iCacheIndex;
        }
        // TraceMsg(TF_CUSTOM2, "CImageListCache::AddImage -- Replacing Image (CI:%d II:%d) ", iCacheIndex, iImageIndex);
        
        LocalFree((LPVOID) pOld );

        ASSERT(!(m_dwFlags & ICIIFLAG_LARGE) == !(pInfo->dwMask & ICIFLAG_LARGE)
               && !(m_dwFlags & ICIIFLAG_SMALL) == !(pInfo->dwMask & ICIFLAG_SMALL));
        
        if ( pInfo->dwMask & ICIFLAG_LARGE )
        {
            ASSERT( m_dwFlags & ICIIFLAG_LARGE );
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapLarge );

                HBITMAP hBitmapLarge = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapLarge);
                HBITMAP hMaskLarge = AddImage_PrepareBitmap(pInfo, pInfo->hMaskLarge);
                ImageList_Replace( m_himlLarge, iImageIndex, hBitmapLarge, hMaskLarge );
                AddImage_CleanupBitmap(pInfo, hBitmapLarge);
                AddImage_CleanupBitmap(pInfo, hMaskLarge);
            }
            else
            {
                ASSERT( pInfo->hIconLarge && pInfo->dwMask & ICIFLAG_ICON );

                HICON hIconLarge = AddImage_PrepareIcon(pInfo, pInfo->hIconLarge);
                ImageList_ReplaceIcon( m_himlLarge, iImageIndex, hIconLarge );
                AddImage_CleanupIcon(pInfo, hIconLarge);
            }
        }
        if ( pInfo->dwMask & ICIFLAG_SMALL )
        {
            ASSERT( m_dwFlags & ICIIFLAG_SMALL );
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapSmall );

                HBITMAP hBitmapSmall = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapSmall);
                HBITMAP hMaskSmall = AddImage_PrepareBitmap(pInfo, pInfo->hMaskSmall);
                ImageList_Replace( m_himlSmall, iImageIndex, hBitmapSmall, hMaskSmall );
                AddImage_CleanupBitmap(pInfo, hBitmapSmall);
                AddImage_CleanupBitmap(pInfo, hMaskSmall);
            }
            else
            {
                ASSERT( pInfo->hIconSmall && pInfo->dwMask & ICIFLAG_ICON );

                HICON hIconSmall = AddImage_PrepareIcon(pInfo, pInfo->hIconSmall);
                ImageList_ReplaceIcon( m_himlSmall, iImageIndex, hIconSmall );
                AddImage_CleanupIcon(pInfo, hIconSmall);
            }
        }
    }
    else
    {
        iCacheIndex = DPA_AppendPtr( m_hListData, pNode );
        if ( iCacheIndex >= 0 )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                if ( pInfo->dwMask & ICIFLAG_LARGE )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_LARGE );
                    ASSERT( pInfo->hBitmapLarge );

                    HBITMAP hBitmapLarge = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapLarge);
                    HBITMAP hMaskLarge = AddImage_PrepareBitmap(pInfo, pInfo->hMaskLarge);
                    iImageIndex  = ImageList_Add( m_himlLarge, hBitmapLarge, hMaskLarge);
                    AddImage_CleanupBitmap(pInfo, hBitmapLarge);
                    AddImage_CleanupBitmap(pInfo, hMaskLarge);
                }
                if ( pInfo->dwMask & ICIFLAG_SMALL )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_SMALL );
                    ASSERT( pInfo->hBitmapSmall );

                    HBITMAP hBitmapSmall = AddImage_PrepareBitmap(pInfo, pInfo->hBitmapSmall);
                    HBITMAP hMaskSmall = AddImage_PrepareBitmap(pInfo, pInfo->hMaskSmall);
                    iImageIndex  = ImageList_Add( m_himlSmall, hBitmapSmall, hMaskSmall);
                    AddImage_CleanupBitmap(pInfo, hBitmapSmall);
                    AddImage_CleanupBitmap(pInfo, hMaskSmall);
                }
            }
            else
            {
                ASSERT( pInfo->dwMask & ICIFLAG_ICON );
                if ( pInfo->dwMask & ICIFLAG_LARGE )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_LARGE );
                    ASSERT( pInfo->hIconLarge );

                    HICON hIconLarge = AddImage_PrepareIcon(pInfo, pInfo->hIconLarge);
                    iImageIndex = ImageList_AddIcon( m_himlLarge, hIconLarge );
                    AddImage_CleanupIcon(pInfo, hIconLarge);
                }
                if ( pInfo->dwMask & ICIFLAG_SMALL )
                {
                    ASSERT( m_dwFlags & ICIIFLAG_SMALL );
                    ASSERT( pInfo->hIconSmall );

                    HICON hIconSmall = AddImage_PrepareIcon(pInfo, pInfo->hIconSmall);
                    iImageIndex = ImageList_AddIcon( m_himlSmall, hIconSmall );
                    AddImage_CleanupIcon(pInfo, hIconSmall);
                }
            }
            ASSERT(iCacheIndex == iImageIndex);
            pNode->uImageIndex = iImageIndex;
            //TraceMsg(TF_CUSTOM2, "CImageListCache::AddImage -- Adding Image (CI:%d II:%d) ", iCacheIndex, iImageIndex);
        }
        else
        {
            // failed to add to the list...
            LocalFree( pNode );
        }
    }

    LeaveCriticalSection( &m_csLock );
    *puImageIndex = (UINT) iImageIndex;
    
    return (iImageIndex >= 0) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CImageListCache::FindImage(LPCIMAGECACHEINFO pInfo, UINT *puImageIndex)
{
    HRESULT hr = S_FALSE;
    ASSERT( m_hListData );

    DWORD dwMatch = pInfo->dwMask & (ICIFLAG_FLAGS | ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_DATESTAMP);
    DWORD dwMask;
    int iCacheIndex = 0;
    ICONCACHE_DATA * pNode = NULL;
    EnterCriticalSection( &m_csLock );
    do
    {
        dwMask = 0;
        pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if ((pNode->dwUsage & ICD_DELETED) || (pNode->iUsage == 0))
        {
            iCacheIndex ++;
            continue;
        }
        
        if (( dwMatch & ICIFLAG_NAME ) && StrCmpW( pInfo->pszName, pNode->szName ) == 0 )
        {
            // found it
            dwMask |= ICIFLAG_NAME;
        }
        if (( dwMatch& ICIFLAG_INDEX ) && pInfo->iIndex == pNode->iIndex )
        {
            dwMask |= ICIFLAG_INDEX;
        }
        if (( dwMatch & ICIFLAG_FLAGS ) && pInfo->dwFlags == pNode->dwFlags )
        {
            dwMask |= ICIFLAG_FLAGS;
        }

        if (( dwMatch & ICIFLAG_DATESTAMP ) &&
            ( pInfo->ftDateStamp.dwLowDateTime == pNode->ftDateStamp.dwLowDateTime &&
              pInfo->ftDateStamp.dwHighDateTime == pNode->ftDateStamp.dwHighDateTime ))
        {
            dwMask |= ICIFLAG_DATESTAMP;
        }

        iCacheIndex ++;
    }
    while ( dwMask != dwMatch);

    // found it, save the index... (as long as it was freed not deleted...
    if ( pNode && (dwMask == dwMatch) )
    {
        //TraceMsg(TF_CUSTOM2, "CImageListCache::FindImage *FOUND* (path=%s)", pNode->szName);
        hr = S_OK;
        *puImageIndex = (UINT) pNode->uImageIndex;
        
        // bump usage
        iCacheIndex --; // We had an extra increment at the end.
        if ( !(pNode->dwUsage & ICD_SYSTEM) )
        {
            if (m_dwFlags & ICIIFLAG_SORTBYUSED)
            {
                DPA_DeletePtr(m_hListData, iCacheIndex);
                iCacheIndex = DPA_AppendPtr(m_hListData, pNode);
                if (iCacheIndex == -1) // We failed to move the node...
                {
                    LocalFree(pNode);
                    *puImageIndex = (UINT) -1;
                    hr = E_OUTOFMEMORY;
                }            
            }
            else if ( !(pNode->dwUsage) && !(pInfo->dwMask & ICIFLAG_NOUSAGE ))
            {
                ASSERT(!(pNode->dwUsage & ICD_DELETED));
                pNode->iUsage++;
            }
        }
    }
    
    LeaveCriticalSection( &m_csLock );

    return hr;
}

STDMETHODIMP CImageListCache::Flush(BOOL fRelease)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    if ( fRelease )
    {
        // simply empty the data list. The ImageList never shrinks...
        DPA_EnumCallback( m_hListData, DestroyEnum, NULL );
        DPA_DeleteAllPtrs( m_hListData );

        if ( m_himlLarge )
        {
            ImageList_RemoveAll( m_himlLarge );
        }

        if ( m_himlSmall )
        {
            ImageList_RemoveAll( m_himlSmall );
        }
    }
    else
    {
        DPA_EnumCallback( m_hListData, UsageEnum, 0 );
    }
    LeaveCriticalSection( &m_csLock );

    return S_OK;
}

STDMETHODIMP CImageListCache::FreeImage(UINT uImageIndex)
{
    ASSERT ( m_hListData );
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&m_csLock);
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if (!pNode->dwUsage && pNode->iUsage)
        {
            hr = S_OK;
            if (m_dwFlags & ICIIFLAG_SORTBYUSED)
            {
                //TraceMsg(TF_CUSTOM2, "CImageListCache::FreeImage -- (CI::%d II::%d)", GetNodeIndexFromImageIndex(uImageIndex), uImageIndex);
                pNode->iUsage = 0;
            }
            else
            {
                pNode->iUsage--;
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    LeaveCriticalSection(&m_csLock);
    return hr;
}

STDMETHODIMP CImageListCache::DeleteImage(UINT uImageIndex)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT ( m_hListData );

    EnterCriticalSection( &m_csLock );
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if ( !pNode->dwUsage )
        {
            pNode->dwUsage = ICD_DELETED;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    LeaveCriticalSection( &m_csLock );
    return hr;
}

STDMETHODIMP CImageListCache::ChangeImageInfo(UINT uImageIndex, LPCIMAGECACHEINFO pInfo)
{
    ASSERT( m_hListData );
    
    EnterCriticalSection( &m_csLock );
    UINT uCacheIndex = GetNodeIndexFromImageIndex(uImageIndex);
    if (-1 == uCacheIndex)
    {
        LeaveCriticalSection( &m_csLock );
        return E_INVALIDARG;
    }
    
    ICONCACHE_DATA * pNode = CreateDataNode( pInfo );
    if (!pNode)
    {
        LeaveCriticalSection( &m_csLock );
        return E_OUTOFMEMORY;
    }

    ICONCACHE_DATA * pOld = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, uCacheIndex );
    ASSERT( pOld );
    
    DPA_SetPtr( m_hListData, uCacheIndex, pNode );
    pNode->iUsage = pOld->iUsage;
    pNode->dwUsage = pOld->dwUsage;
    pNode->uImageIndex = pOld->uImageIndex;
    LocalFree( pOld );

    if ( pInfo->dwMask & ( ICIFLAG_BITMAP | ICIFLAG_ICON ))
    {
        // update the picture....
        if ( pInfo->dwMask & ICIFLAG_LARGE )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapLarge );
                ImageList_Replace( m_himlLarge, uImageIndex, pInfo->hBitmapLarge, pInfo->hMaskLarge );
            }
            else
            {
                ASSERT( pInfo->hIconLarge && pInfo->dwMask & ICIFLAG_ICON );
                ImageList_ReplaceIcon( m_himlLarge, uImageIndex, pInfo->hIconLarge );
            }
        }
        if ( pInfo->dwMask & ICIFLAG_SMALL )
        {
            if ( pInfo->dwMask & ICIFLAG_BITMAP )
            {
                ASSERT( pInfo->hBitmapSmall );
                ImageList_Replace( m_himlSmall, uImageIndex, pInfo->hBitmapSmall, pInfo->hMaskSmall );
            }
            else
            {
                ASSERT( pInfo->hIconSmall && pInfo->dwMask & ICIFLAG_ICON );
                ImageList_ReplaceIcon( m_himlLarge, uImageIndex, pInfo->hIconSmall );
            }
        }
    }
    LeaveCriticalSection(&m_csLock);
    return S_OK;
}

UINT CImageListCache::CountFreeSlots( )
{
    ASSERT( m_hListData );
    int iSlot = 0;
    UINT uFree = 0;
    
    do
    {
        ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iSlot ++ );
        if ( !pNode )
        {
            break;
        }

        if (pNode->iUsage == 0 || (pNode->dwUsage & ICD_DELETED))
        {
            uFree++;
        }
    }
    while ( TRUE );

    return uFree;
}

STDMETHODIMP CImageListCache::GetCacheSize(UINT * puSize)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    *puSize = DPA_GetPtrCount( m_hListData ) - CountFreeSlots();
    LeaveCriticalSection( &m_csLock );
    return S_OK;
}

STDMETHODIMP CImageListCache::GetImageList(LPIMAGECACHEINITINFO pInfo )
{
    ASSERT( pInfo->cbSize == sizeof( IMAGECACHEINITINFO ));

    if ( !(pInfo->dwMask & (ICIIFLAG_LARGE | ICIIFLAG_SMALL)))
    {
        // must specify one or both of large or small
        return E_INVALIDARG;
    }

    if ( m_hListData )
    {
        // we have already been created, just pass back the info if they match.....
        if ((( pInfo->dwMask & ICIIFLAG_SMALL ) && !m_himlSmall ) ||
            (( pInfo->dwMask & ICIIFLAG_LARGE ) && !m_himlLarge ) ||
            ( m_dwFlags != pInfo->dwMask ))
        {
            return E_INVALIDARG;
        }

        if ( pInfo->dwMask & ICIIFLAG_SMALL )
        {
            pInfo->himlSmall = m_himlSmall;
        }
        if ( pInfo->dwMask & ICIIFLAG_LARGE )
        {
            pInfo->himlLarge = m_himlLarge;
        }

        return S_FALSE;
    }
    
    m_hListData = DPA_Create( 30 );
    if ( !m_hListData )
    {
        return E_OUTOFMEMORY;
    }
    
    if ( pInfo->dwMask & ICIIFLAG_LARGE )
    {
        m_himlLarge = ImageList_Create( pInfo->rgSizeLarge.cx, pInfo->rgSizeLarge.cy, pInfo->dwFlags,
            pInfo->iStart, pInfo->iGrow );
        if ( !m_himlLarge )
        {
            return E_OUTOFMEMORY;
        }
        pInfo->himlLarge = m_himlLarge;
    }
    if ( pInfo->dwMask & ICIIFLAG_SMALL )
    {
        m_himlSmall = ImageList_Create( pInfo->rgSizeSmall.cx, pInfo->rgSizeSmall.cy, pInfo->dwFlags,
            pInfo->iStart, pInfo->iGrow );
        if ( !m_himlSmall )
        {
            return E_OUTOFMEMORY;
        }
        pInfo->himlSmall = m_himlSmall;
    }

    m_dwFlags = pInfo->dwMask;
    
    return S_OK;
}

int CImageListCache::FindEmptySlot()
{
    // search for an element with a zero usage count...
    ASSERT( m_hListData );
    
    int iCacheIndex = 0;
    do
    {
        ICONCACHE_DATA * pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if (pNode->iUsage == 0 || (pNode->dwUsage & ICD_DELETED))
        {
            return iCacheIndex;
        }
        iCacheIndex ++;
    } while (TRUE);
    
    return  -1;
}

STDMETHODIMP CImageListCache::GetUsage(UINT uImageIndex, UINT * puUsage)
{
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );

    HRESULT hr = E_INVALIDARG;
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        if (pNode->dwUsage & ICD_DELETED)
        {
            *puUsage = ICD_USAGE_DELETED;
        }
        else if (pNode->dwUsage & ICD_SYSTEM)
        {
            *puUsage = ICD_USAGE_SYSTEM;
        }
        else if (pNode->dwUsage & ICD_NOUSAGE)
        {
            *puUsage = ICD_USAGE_NOUSAGE;
        }
        else
        {
            *puUsage = pNode->iUsage;
        }
        hr = S_OK;
    }

    LeaveCriticalSection( &m_csLock );
    return hr;
}

STDMETHODIMP CImageListCache::GetImageInfo(UINT uImageIndex, LPIMAGECACHEINFO pInfo)
{
    HRESULT hr;
    ASSERT( m_hListData );

    EnterCriticalSection( &m_csLock );
    
    ICONCACHE_DATA * pNode = GetNodeFromImageIndex(uImageIndex);
    if (pNode)
    {
        hr  = E_NOTIMPL;
        if ( pInfo->dwMask & ICIFLAG_DATESTAMP )
        {
            if ( pNode->dwFlags & ICIFLAG_DATESTAMP )
            {
                pInfo->ftDateStamp = pNode->ftDateStamp;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if ( pInfo->dwMask & ICIFLAG_NOUSAGE )
        {
            hr = S_OK;
        }
        pInfo->dwMask = pNode->dwFlags & pInfo->dwMask;
    }
    else
        hr = E_INVALIDARG;
    
    LeaveCriticalSection(&m_csLock);
    return hr;
}

STDMETHODIMP CImageListCache::GetImageIndexFromCacheIndex( UINT iCacheIndex, UINT * puImageIndex )
{
    ASSERT( m_hListData );
    
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection( &m_csLock );
    ICONCACHE_DATA *pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
    
    *puImageIndex = (UINT) -1;
    if (pNode)
    {
        *puImageIndex = (UINT) pNode->uImageIndex;
        hr = S_OK;
    }

    LeaveCriticalSection(&m_csLock);
    return hr;
}

ICONCACHE_DATA * CImageListCache::GetNodeFromImageIndex( UINT iImageIndex )
{
    UINT iCacheIndex = GetNodeIndexFromImageIndex(iImageIndex);
    return (iCacheIndex == -1) ? NULL : (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
}

UINT CImageListCache::GetNodeIndexFromImageIndex( UINT iImageIndex )
{
    UINT iCacheIndex = 0;
    ICONCACHE_DATA * pNode = NULL;

    // We must assume that we have the critical section here or else the data would be
    // meaningless upon return from this function.
    
    do
    {
        pNode = (ICONCACHE_DATA *) DPA_GetPtr( m_hListData, iCacheIndex );
        if ( !pNode )
        {
            break;
        }

        if (pNode->dwUsage & ICD_DELETED)
        {
            iCacheIndex ++;
            continue;
        }

        iCacheIndex ++;
    }
    while ( pNode->uImageIndex != iImageIndex );

    return (pNode ? iCacheIndex - 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\itbar.cpp ===
#include "priv.h"
#include "sccls.h"
#include <varutil.h>

#include "itbdrop.h"
#include <urlhist.h>
#include "autocomp.h"
#include "itbar.h"
#include "address.h"
#include <winbase.h>
#include "basebar.h"
#include "shbrowse.h"
#include "brand.h"
#include "resource.h"
#include "theater.h"
#include "browmenu.h"
#include "util.h"
#include "droptgt.h"
#include "legacy.h"
#include "apithk.h"
#include "shbrows2.h"
#include "stdenum.h"
#include "iehelpid.h"
#include <tb_ids.h>
#include "mediautil.h"

#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "schedule.h"
#include "uemapp.h"

#include "mluisupp.h"

#ifdef UNIX
extern "C"  const GUID  CLSID_MsgBand;
#endif

// The edit button hackery needs to be moved to shdocvw.  This define identifies this code.
#define EDIT_HACK

// Offset of the comctl32 default bitmaps
#define OFFSET_HIST             (MAX_TB_BUTTONS - 1 + 0)   // 15
#define OFFSET_STD              (MAX_TB_BUTTONS - 1 + 6)   // 21
#define OFFSET_VIEW             (MAX_TB_BUTTONS - 1 + 21)  // 36

// This is the offset in the toolbar for the Shell glyphs and the Shell toolbar labels
#define SHELLTOOLBAR_OFFSET     (MAX_TB_BUTTONS - 1 + 1)  // 16
#define FONTGLYPH_OFFSET        (MAX_TB_BUTTONS - 1 + 38) // 53
#define BRIEFCASEGLYPH_OFFSET   (MAX_TB_BUTTONS - 1 + 34) // 49
#define RNAUIGLYPH_OFFSET       (MAX_TB_BUTTONS - 1 + 36) // 51
#define WEBCHECKGLYPH_OFFSET    (MAX_TB_BUTTONS - 1 + 42) // 57
#ifdef EDIT_HACK
#define EDITGLYPH_OFFSET        (9)
#endif

#define IDT_UPDATETOOLBAR       0x1
#define TIMEOUT_UPDATETOOLBAR   400

const GUID CLSID_Separator = { 0x67077B90L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };

extern HRESULT VariantClearLazy(VARIANTARG *pvarg);

// How many CT_TABLE structures to allocated at a time.
#define TBBMPLIST_CHUNK     5

#define MAX_EXTERNAL_BAND_NAME_LEN 64

#define MAX_TB_COMPRESSED_WIDTH 42
// 16 is added to the the MAX_TB defines. This is added through the strings
// in the RC file. This is done so that the localization folks can increase
// or decrease the width of the toolbar buttons
#define MAX_TB_WIDTH_LORES      38
#define MAX_TB_WIDTH_HIRES      60

// Dimensions of Coolbar Glyphs ..
#define TB_SMBMP_CX               16
#define TB_SMBMP_CY               16
#define TB_BMP_CX                 20
#define TB_BMP_CY                 20
#define TB_BMP_CX_ALPHABITMAP     24
#define TB_BMP_CY_ALPHABITMAP     24

int g_iToolBarLargeIconWidth = TB_BMP_CX;
int g_iToolBarLargeIconHeight = TB_BMP_CY;


#define CX_SEPARATOR    6     // we override toolbar control's default separator width of 8

#define DM_TBSITE   0
#define DM_TBCMD    0
#define DM_TBREF    TF_SHDREF
#define DM_LAYOUT   0
#define DM_ITBAR    0

#define TF_TBCUST   0x01000000

#if CBIDX_LAST != 5
#error Expected CBIDX_LAST to have value of 5
#endif

#if (FCIDM_EXTERNALBANDS_LAST - FCIDM_EXTERNALBANDS_FIRST + 1) < MAXEXTERNALBANDS
#error Insufficient range for FCIDM_EXTERNALBANDS_FIRST to FCIDM_EXTERNALBANDS_LAST
#endif


__inline UINT EXTERNALBAND_VBF_BIT(UINT uiBandExt)
{
    ASSERT(uiBandExt < MAXEXTERNALBANDS);

    // Formula: take 1, shift left by uiBandExt + 16
    //      => a bit in range (0x80000000, 0x00010000)
    UINT uBit = 1 << (uiBandExt + 16);
    ASSERT(uBit & VBF_EXTERNALBANDS);

    return uBit;
}

__inline BOOL IS_EXTERNALBAND(int idBand)
{
    return (InRange(idBand, CBIDX_EXTERNALFIRST, CBIDX_EXTERNALLAST));
}

__inline int MAP_TO_EXTERNAL(int idBand)
{
    ASSERT(IS_EXTERNALBAND(idBand));

    // CBIDX_LAST is one-based, mapping is zero-based
    return (idBand - (1 + CBIDX_LAST));
}


// maximum number of menu items in the context menus for back and forward.
#define MAX_NAV_MENUITEMS               9

#define DEFAULT_SEARCH_GUID    SRCID_SFileSearch //SRCID_SWebSearch

#define SZ_PROP_CUSTDLG     TEXT("Itbar custom dialog hwnd")

#define REG_KEY_BANDSTATE  TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar")

// MHTML Editing
#define SZ_IE_DEFAULT_MHTML_EDITOR  "Default MHTML Editor"
#define REGSTR_PATH_DEFAULT_MHTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_MHTML_EDITOR)
#define REGSTR_KEY_DEFAULT_MHTML_EDITOR  TEXT(SZ_IE_DEFAULT_MHTML_EDITOR)

DWORD DoNetConnect(HWND hwnd);
DWORD DoNetDisconnect(HWND hwnd);


void _LoadToolbarGlyphs(HWND hwnd, IMLCACHE *pimlCache, int cx, int idBmp,
                        int iBitmapBaseIndex, BOOL bUseClassicGlyphs, HINSTANCE hInst);

BOOL _UseSmallIcons();


typedef struct tagTBBMP_LIST
{
    HINSTANCE hInst;
    UINT_PTR  uiResID;
    UINT  uiOffset;
    BITBOOL  fNormal:1;
    BITBOOL  fHot:1;
    BITBOOL  fDisabled:1;
    UINT  uiCount;
} TBBMP_LIST;

typedef struct tagCMDMAP
{
    GUID    guidButtonGroup;
    UINT    nCmdID;
    LPARAM lParam;  // app's data
} CMDMAP;

typedef struct tagCMDMAPCUSTOMIZE
{
    TBBUTTON btn;
    CMDMAP cm;
} CMDMAPCUSTOMIZE;

typedef struct {

    // the IOleCommandTarget info:
    GUID guid;
    UINT nCmdID;
    UINT fButtonState;
} BUTTONSAVEINFO;

#define TBSI_VERSION            7
typedef struct {
    int cVersion;
} TOOLBARSAVEINFO;

typedef struct {
    HDSA hdsa;
    BITBOOL fAdjust:1;
    BITBOOL fDirty:1;
} CUSTOMIZEINFO, *LPCUSTOMIZEINFO;

//Current latest version.
#define CBS_VERSION             17

// NOTE: Be very careful changing COOLBARSAVE because _LoadUpgradeSettings makes
// assumptions about the layout of the structure.  To avoid breaking that
// upgrade code, be sure you:
//
//  - don't change the order of existing members
//  - always add new members to the end of the structure.
//  - update _LoadUpgradeSettings if appropriate
//
typedef struct tagCOOLBARSAVE
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BITBOOL     fVertical : 1;      // The bar is oriented vertically
    BITBOOL     fNoText :1;         // "NoText"
    BITBOOL     fList : 1;          // toolbar is TBSTYLE_LIST (text on right) + TBSTYLE_EX_MIXEDBUTTONS
    BITBOOL     fAutoHide : 1;      // Auto hide toolbar in theater mode
    BITBOOL     fStatusBar : 1;     // Status bar in theater mode
    BITBOOL     fSaveInShellIntegrationMode : 1;     // Did we save in shell integration mode?
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[CBANDSMAX];
    CLSID       aclsidExternalBands[ MAXEXTERNALBANDS ];  // Check classid
    CLSID       clsidVerticalBar;       //clsid of bar persisted within vertical band
    CLSID       clsidHorizontalBar;
} COOLBARSAVE, *LPCOOLBARSAVE;

//Flags for dwFlags passed to UpdateToolbarDisplay()
#define UTD_TEXTLABEL  0x00000001
#define UTD_VISIBLE    0x00000002

static const TCHAR c_szRegKeyCoolbar[] = TSZIEPATH TEXT("\\Toolbar");
static const TCHAR c_szValueTheater[]  = TEXT("Theater");

typedef struct tagFOLDERSEARCHITEM
{
    UINT    idCmd;
    GUID    guidSearch;
    int     iIcon;
    WCHAR   wszUrl[MAX_URL_STRING];
    WCHAR   wszName[80];           // friendly name
}FOLDERSEARCHITEM, *LPFOLDERSEARCHITEM;

BOOL NavigateSearchBar(IWebBrowser2 *pwb2, LPCWSTR pwszUrl);
BOOL _GetSearchHKEY(LPGUID lpguidSearch, HKEY *phkey);

#define REG_SZ_STATIC       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FindExtensions\\Static")
#define REG_SZ_SEARCH_GUID  TEXT("SearchGUID")
#define REG_SZ_SEARCH_URL   TEXT("SearchGUID\\Url")

#define VIEW_OFFSET (SHELLGLYPHS_OFFSET + HIST_MAX + STD_MAX)
#define VIEW_ALLFOLDERS  (VIEW_NETCONNECT + 14)

static const TBBUTTON    c_tbExplorer[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0, TBIDM_BACK  ,      0,               BTNS_DROPDOWN | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    { 1, TBIDM_FORWARD,     0,               BTNS_DROPDOWN, {0,0}, 0, 1 },

    { 2, TBIDM_STOPDOWNLOAD, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 2 },
    { 3, TBIDM_REFRESH,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 3 },
    { 4, TBIDM_HOME,         TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 4 },

    { VIEW_PARENTFOLDER + VIEW_OFFSET,    TBIDM_PREVIOUSFOLDER,   TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_PARENTFOLDER + VIEW_OFFSET },
    { VIEW_NETCONNECT + VIEW_OFFSET,      TBIDM_CONNECT,          TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_NETCONNECT + VIEW_OFFSET },
    { VIEW_NETDISCONNECT + VIEW_OFFSET,   TBIDM_DISCONNECT,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, VIEW_NETDISCONNECT + VIEW_OFFSET },

    { CX_SEPARATOR, 0,          TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { 5, TBIDM_SEARCH,          TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, 5 },
    { VIEW_ALLFOLDERS + VIEW_OFFSET,    TBIDM_ALLFOLDERS,         TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, VIEW_ALLFOLDERS + VIEW_OFFSET },
    { 6, TBIDM_FAVORITES,       TBSTATE_ENABLED,  BTNS_SHOWTEXT, {0,0}, 0, 6 },
    // IF YOU CHANGE THE ORDERING OF THIS, please change AddMediaBarButton to reflect this ordering.
    { 11, TBIDM_MEDIABAR,       TBSTATE_ENABLED, BTNS_SHOWTEXT, {0,0}, 0, 11 },
    { 12, TBIDM_HISTORY,        TBSTATE_ENABLED, 0/*BTNS_SHOWTEXT*/, {0,0}, 0, 12},
    { CX_SEPARATOR,    0,       TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
#ifndef DISABLE_FULLSCREEN
    // IE UNIX : No theater mode for beta1
    { 14, TBIDM_THEATER,         TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 14 },
#endif
};

// these IDs are the array indices into c_tbExplorer above
// keep in sync, be aware there are ASSERTs to enforce them to be in sync
#define TBXID_BACK              0
#define TBXID_FORWARD           1
#define TBXID_STOPDOWNLOAD      2
#define TBXID_REFRESH           3
#define TBXID_HOME              4
#define TBXID_PREVIOUSFOLDER    5
#define TBXID_CONNECT           6
#define TBXID_DISCONNECT        7
#define TBXID_SEPARATOR1        8
#define TBXID_SEARCH            9
#define TBXID_ALLFOLDERS       10
#define TBXID_FAVORITES        11
#define TBXID_MEDIABAR         12
#define TBXID_HISTORY          13
#define TBXID_SEPARATOR2       14
#define TBXID_THEATER          15


static const BROWSER_RESTRICTIONS c_rest[] = {
    REST_BTN_BACK,
    REST_BTN_FORWARD,
    REST_BTN_STOPDOWNLOAD,
    REST_BTN_REFRESH,
    REST_BTN_HOME,
    REST_BROWSER_NONE,      // no policy for up
    REST_BROWSER_NONE,      // no policy for map drive
    REST_BROWSER_NONE,      // no policy for disconnect drive
    REST_BROWSER_NONE,      // separator
    REST_BTN_SEARCH,
    REST_BTN_ALLFOLDERS,
    REST_BTN_FAVORITES,
    REST_BTN_MEDIABAR,
    REST_BTN_HISTORY,
    REST_BROWSER_NONE,      // separator
#ifndef DISABLE_FULLSCREEN
    REST_BTN_THEATER,
#endif
};


// init flags to avoid multiple inits of toolbar and buttons
#define TBBIF_REG_PATH      TEXT("Software\\Microsoft\\Internet Explorer")
#define TBBIF_REG_KEY       TEXT("AddButtons")
// defined flags as bitfield
#define TBBIF_NONE          0
#define TBBIF_XBAR          0x1     // reserved/used to distinguish pre IE6/RC1 where PersonalBar/xBar was configured
#define TBBIF_MEDIA         0x2

#define SUPERCLASS CBaseBar

class CInternetToolbar :
   public CBaseBar,
   public IDockingWindow,
   public IObjectWithSite,  // *not* CObjectWithSite (want _ptbSite)
   public IExplorerToolbar,
   public DWebBrowserEvents,
   public IPersistStreamInit,
   public IShellChangeNotify,
   public ISearchItems
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return SUPERCLASS::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return SUPERCLASS::Release(); };

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return SUPERCLASS::GetWindow(lphwnd);};
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) {return SUPERCLASS::ContextSensitiveHelp(fEnterMode);};

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    // is E_NOTIMPL ok?
    virtual STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { ASSERT(0); return E_NOTIMPL; };

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void** ppvObj);

    // *** IExplorerToolbar method ***
    virtual STDMETHODIMP SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags);
    virtual STDMETHODIMP AddStdBrowserButtons(void);

    virtual STDMETHODIMP AddButtons(const GUID* pguidButtonGroup, UINT nButtons, const TBBUTTON * lpButtons);
    virtual STDMETHODIMP AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset);
    virtual STDMETHODIMP GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);
    virtual STDMETHODIMP GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT * pfState);
    virtual STDMETHODIMP SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState);
    virtual STDMETHODIMP AddBitmap(const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb,
                                   LRESULT * pOffset, COLORREF rgbMask);
    virtual STDMETHODIMP GetBitmapSize(UINT * uiID);
    virtual STDMETHODIMP SendToolbarMsg(const GUID * pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes);

    virtual STDMETHODIMP SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled);
    virtual STDMETHODIMP ModifyButton( const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // IPersistStreamInit
    STDMETHOD(GetClassID)(GUID *pguid);
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(InitNew)(void);
    STDMETHOD(IsDirty)(void);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER  *pcbSize);

    /* IDispatch methods */
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo);

    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames,
                                       LCID lcid, DISPID * rgdispid);

    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                                DISPPARAMS * pdispparams, VARIANT * pvarResult,
                                EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // IShellChangeNotify
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // CBaseBar overrides
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** ISearchItems methods ***
    virtual STDMETHODIMP GetDefaultSearchUrl(LPWSTR pwzUrl, UINT cch);

    CInternetToolbar();
protected:
    virtual ~CInternetToolbar();
    static LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL _SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    LRESULT _OnNotify(LPNMHDR pnmh);
    void _OnTooltipNeeded(LPTOOLTIPTEXT pnmTT);
    void _QueryStatusTip(IOleCommandTarget *pct, LPTOOLTIPTEXT pnmTT, UINT uiCmd, const GUID* pguid);

    BOOL _UpEnabled();
    void _UpdateCommonButton(int iCmd, UINT nCmdID);
    void _UpdateToolbar(BOOL fForce);
    void _UpdateToolbarNow();
    void _UpdateGroup(const GUID *pguidCmdGroup, int cnt, OLECMD rgcmds[], const GUID* pguidButton, const int buttonsInternal[]);
    void _CSHSetStatusBar(BOOL fOn);
    void _StartDownload();
    void _StopDownload(BOOL fClosing);
    void _SendDocCommand(UINT idCmd);
    BOOL _CompressBands(BOOL fCompress, UINT uRowsNew, BOOL fForceUpdate);
    void _TrackSliding(int x, int y);
    HRESULT _DoNavigateA(LPSTR pszURL,int iNewSelection);
    HRESULT _DoNavigateW(LPWSTR pwzURL,int iNewSelection);
    HRESULT _DoNavigate(BSTR bstrURL,int iNewSelection);
    void _Unadvise(void);
    LRESULT _OnBeginDrag(NMREBAR* pnm);

    void _InsertURL(LPTSTR pszURL);

    void _ShowContextMenu(HWND hwnd, LPARAM lParam, LPRECT prcExclude);
    BOOL _ShowBackForwardMenu(BOOL fForward, POINT pt, LPRECT prcExclude);
    // search helper methods
    BOOL _GetFolderSearchData();
    void _SetSearchStuff();
    BOOL _GetSearchUrl(LPWSTR pwszUrl, DWORD cch);
    HRESULT _GetFolderSearches(IFolderSearches **ppfs);


    void _ReloadButtons();
    void _UpdateToolsStyle(BOOL fList);
    void _InitBitmapDSA();
    void _ReloadBitmapDSA();
    void _InitForScreenSize();
    void _InitToolbar();
    BOOL _FoldersButtonAvailable();
    void _AdminMarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons);
    void _MarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons);
    void _AddCommonButtons();
    HRESULT _CreateBands();
    BOOL    _ShowBands(UINT fVisible);
    HRESULT _ShowTools(PBANDSAVE pbs);
    HRESULT _ShowAddressBand(PBANDSAVE pbs);
    HRESULT _ShowExternalBand(PBANDSAVE pbs, int idBand );
    HRESULT _ShowLinks(PBANDSAVE pbs);
    HRESULT _ShowBrand(PBANDSAVE pbs);
    HRESULT _ShowMenu(PBANDSAVE pbs);
    void _ShowBandCommon(PBANDSAVE pbs, LPBANDITEMDATA pbid, BOOL fShow);
    void _EnsureAllBandsShown();
    HRESULT _GetMinRowHeight();

    HBITMAP _LoadBackBitmap();
    void    _SetBackground();
    void    _CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST* ppidl);
    LPITEMIDLIST _GetCurrentPidl(void);
    int     _ConvertHwndToID(HWND hwnd);

    HRESULT _GetPersistedBand(const CLSID clsid, REFIID riid, void ** ppiface);

    // Multiple command target
    LRESULT _AddBitmapFromForeignModule(UINT uiGetMSG, UINT uiSetMSG, UINT uiCount, HINSTANCE hinst,
                                        UINT_PTR nID, COLORREF rgbMask);

    HRESULT _LoadDefaultSettings(void);
    HRESULT _LoadUpgradeSettings(ULONG cbRead);
    HRESULT _LoadDefaultWidths(void);
    void _TryLoadIE3Settings();
    HRESULT _UpdateToolbarDisplay(DWORD dwFlags, UINT uVisibleBands, BOOL fNoText, BOOL fPersist);
    void _UpdateBrandSize();
    void _ShowVisible(DWORD dwVisible, BOOL fPersist);
    void _BuildSaveStruct(COOLBARSAVE* pcs);
    void _RestoreSaveStruct(COOLBARSAVE* pcs);
    void _GetVisibleBrowserBar(UINT idBar, CLSID *pclsidOut);
    VOID _UpdateLocking();

    LPBANDITEMDATA _AddNewBand(IDeskBand* pdb, DWORD dwID);

    void _TheaterModeLayout(BOOL fEnter);

    HBITMAP          _bmpBack; // this is the state we think the itbar is in
    static BMPCACHE  s_bmpBackShell; // this is the state of the shell bmp cache
    static BMPCACHE  s_bmpBackInternet; // this is the state of the internet bmp cache
    static IMLCACHE  s_imlTBGlyphs;

    HWND            _hwndMenu;
    HWND            _hwndAddressBand;

    IDockingWindowSite* _ptbsite;
    IOleCommandTarget*  _ptbsitect;
    IBrowserService*    _pbs;
    IBrowserService2*   _pbs2;
    IServiceProvider*   _psp;
    IBandProxy *        _pbp;

    BITBOOL            _fCreatedBandProxy:1;
    BITBOOL            _fBackEnabled:1;
    BITBOOL            _fForwardEnabled:1;
    BITBOOL            _fEditEnabled:1;
    BITBOOL            _fShow:1;
    BITBOOL            _fAnimating:1;
    BITBOOL            _fCompressed:1;
    BITBOOL            _fUserNavigated :1;
    BITBOOL            _fAutoCompInitialized :1;
    BITBOOL            _fDirty:1;
    BITBOOL            _fUsingDefaultBands:1;
    BITBOOL            _fTransitionToHTML:1;
    BITBOOL            _fInitialPidlIsWeb:1;
    BITBOOL            _fTheater: 1; // are we in theater mode?  claim no border space
    BITBOOL            _fAutoHide :1;
    BITBOOL            _fRebarDragging :1;
    BITBOOL            _fShellView:1;   // are we in shell view or web view?
    BITBOOL            _fNoShowMenu:1;    // can show menu band?
    BITBOOL            _fUpdateToolbarTimer:1;
    BITBOOL            _fNeedUpdateToolbar:1;
    BITBOOL            _fNavigateComplete:1;
    BITBOOL            _fLoading:1;     // are we still loading the bar?
    BITBOOL            _fDestroyed:1;   // Did we destroy our member varibles and are shutting down? If so, don't use the varibles. (Stress bug w/messages coming in)
    BITBOOL            _fLockedToolbar:1;

    UINT            _nVisibleBands;     // bitmask of which bands are visible: VBF_*

    IWebBrowser2*   _pdie;
    DWORD           _dwcpCookie;        // DIID_DWebBrowserEvents2
    int             _xCapture;
    int             _yCapture;
    // for multiple command target support
    HDSA            _hdsaTBBMPs;
    UINT            _uiMaxTBWidth;
    UINT            _uiTBTextRows;
    UINT            _uiTBDefaultTextRows;
    // search stuff
    HDPA            _hdpaFSI; // folder search items
    GUID            _guidCurrentSearch;
    GUID            _guidDefaultSearch;

    COOLBARSAVE     _cs;             //Coolbar layout info from registry!
    BOOL            _fDontSave;      // force ourselves not to persist out the state.

    struct EXTERNALBANDINFO {
        CLSID       clsid;          // CLSID of the band
        LPWSTR      pwszName;       // Band name
        LPWSTR      pwszHelp;       // Band help text
    };
    EXTERNALBANDINFO _rgebi[ MAXEXTERNALBANDS ];

    void _LoadExternalBandInfo();

    TBBUTTON _tbExplorer[ARRAYSIZE(c_tbExplorer)];
    int      _iButtons;


#ifdef EDIT_HACK
    // Variables for customizing the edit button glyph
    HIMAGELIST      _himlEdit;          // Monochrome Image list for the edit button
    HIMAGELIST      _himlEditHot;       // Hot image list for edit button
    int             _iEditIcon;         // index of current edit icon
    int             _cxEditGlyph;       // cx of glyph size
    int             _cyEditGlyph;       // cx of glyph size

    // Functions for managing a custom edit glyph
    void _InitEditButtonStyle();
    void _SetEditGlyph(int iIcon);
    void _RefreshEditGlyph();
    void _UpdateEditButton();
    static HIMAGELIST _CreateGrayScaleImagelist(HBITMAP hbmpImage, HBITMAP hbmpMask);
    static BSTR _GetEditProgID(IHTMLDocument2* pHTMLDocument);

    //
    // We can have multiple edit verbs associated with a document.  The following class
    // maintains a list of verbs.
    //
    #define FCIDM_EDITFIRST  2000
    #define FCIDM_EDITLAST   2100
    #define SZ_EDITVERB_PROP  TEXT("CEditVerb_This")
    #define IL_EDITBUTTON 2     // Index of image list used for the edit button
    #define IL_SEARCHBUTTON 3   //                   ||             search button

    // MSAA Menu Info declarations.
    // These will eventually be incorporated into oleacc.h - but for the
    // moment, we declare them privately...
    #define MSAA_MENU_SIG  0xAA0DF00DL

    class CEditVerb
    {
    public:
        CEditVerb();
        ~CEditVerb();

        // Functions for managing the verbs
        BOOL Add(LPTSTR pszProgID);
        UINT GetSize() { return _nElements; }
        void RemoveAll();

        // Functions to access the default edit verb
        int   GetIcon() { return (_nElements && _pVerb[_nDefault].fShowIcon) ? _GetVerb(_nDefault).iIcon : -1; }
        BOOL  GetToolTip(LPTSTR pszToolTip, UINT cchMax, BOOL fStripAmpersands = TRUE);
        BOOL  GetMenuText(LPTSTR pszText, UINT cchMax) { return GetToolTip(pszText, cchMax, FALSE); }
        void  Edit(LPCTSTR pszUrl) { _Edit(pszUrl, _nDefault); }

        // Pop-up menu
        BOOL ShowEditMenu(POINT pt, HWND hwnd, LPTSTR pszUrl);

        // Get default editor from the registry
        void InitDefaultEditor(HKEY hkey = NULL);

    protected:
        struct MSAAMenuInfo
        {
            DWORD m_MSAASig;  // Must be MSAA_MENU_SIG
            DWORD m_CharLen;  // Length in characters of text, excluding terminating NUL
            LPWSTR m_pWStr;   // Menu text, in UNICODE, with terminating UNICODE-NUL.
        };

        struct EDITVERB
        {
            MSAAMenuInfo m_MSAA;     // MSAA info - must be first element.
            HKEY    hkeyProgID;      // Key the we shellexec
            BITBOOL fUseOpenVerb:1;  // use open verb instead of edit
            BITBOOL fInit:1;         // true if the data below has beed initialized
            BITBOOL fShowIcon:1;     // true if icon should show up on button
            int     iIcon;           // cached icon index
            UINT    idCmd;           // menu id
            LPTSTR  pszDesc;         // executable name or document name
            LPTSTR  pszMenuText;     // Menu text
            LPTSTR  pszExe;          // Path of the exe used to edit
        };

        EDITVERB* _Add(HKEY hkeyProgID, BOOL fPermitOpenVerb, BOOL fCheckForOfficeApp, BOOL fShowIcon);
        EDITVERB& _GetVerb(UINT nIndex);
        void      _FetchInfo(UINT nIndex);
        void      _Edit(LPCTSTR pszUrl, UINT nIndex);
        LPCTSTR   _GetDescription(EDITVERB& rVerb);
        void      _SetMSAAMenuInfo(EDITVERB& rVerb);
        void      _ClearMSAAMenuInfo(EDITVERB& rVerb);
        void      _FormatMenuText(UINT nIndex);
        BOOL      _IsUnique(EDITVERB& rNewVerb);
        BOOL      _IsHtmlStub(LPCWSTR pszPath);
        LPCTSTR   _GetExePath(EDITVERB& rVerb);
        LPCTSTR   _GetDefaultEditor();
        void      _InitDefaultMHTMLEditor();

        static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        // Member data
        UINT        _nElements;         // number of edit verbs
        UINT        _nDefault;          // Default edit verb
        EDITVERB*   _pVerb;             // array of edit verbs
        WNDPROC     _lpfnOldWndProc;    // former wndProc
        LPWSTR      _pszDefaultEditor;  // Friendly name of default HTML editor
        BOOL        _fInitEditor;       // if we checked for a default editor
    };
    CEditVerb  _aEditVerb;

#endif

    // internal bandsite class
    class CBrowserToolsBand;
    class CITBandSite : public CBandSite
    {
        CITBandSite();

        virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
        virtual STDMETHODIMP AddBand(IUnknown *punk);
        virtual STDMETHODIMP HasFocusIO();

    protected:
        virtual void v_SetTabstop(LPREBARBANDINFO prbbi);
        BOOL _SetMinDimensions();
        friend class CInternetToolbar;
        friend class CBrowserToolsBand;

        virtual HRESULT _OnContextMenu(WPARAM wParm, LPARAM lParam);
        virtual HRESULT _Initialize(HWND hwndParent);

    };
    CITBandSite _bs;


#define TOOLSBANDCLASS CInternetToolbar::CBrowserToolsBand
    class CBrowserToolsBand : public CToolbarBand
    {
        CMDMAP* _GetCmdMapByIndex(int nIndex) { return _GetCmdMap(nIndex, TRUE);};
        CMDMAP* _GetCmdMapByID(int id)  { return _GetCmdMap(id, FALSE);};
        LRESULT _ToolsCustNotify (LPNMHDR pnmh);  // Handle TBCustomization Notify
        BOOL _SaveRestoreToolbar(BOOL fSave);
        void _FreeCustomizeInfo();
        void _FreeCmdMap(CMDMAP*);
        BOOL _RemoveAllButtons();
        int _CommandFromIndex(UINT uIndex);
        HRESULT _ConvertCmd(const GUID* pguidButtonGroup, UINT id, GUID* pguidOut, UINT * pid);
        void _OnDeletingButton(TBNOTIFY* ptbn);
        LONG_PTR _AddString(LPWSTR pwstr);
        void _PreProcessButtonString(TBBUTTON *ptbn, DWORD dwFlags);
        void _PreProcessExternalTBButton(TBBUTTON *ptbn);
        UINT _ProcessExternalButtons(PTBBUTTON ptbb, UINT cButtons);
        void _GetButtons(IOleCommandTarget* pct, const GUID* pguid, HDSA hdsa);
        void _RecalcButtonWidths();
        void _AddMediaBarButton();

        void            _UpdateTextSettings(INT_PTR ids);
        static BOOL_PTR CALLBACK _BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static void     _PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources);
        static void     _SetComboSelection(HWND hwnd, int iCurOption);
        void            _SetDialogSelections(HWND hDlg, BOOL fSmallIcons);
        static void     _PopulateDialog(HWND hDlg);
        void            _OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm);

        BOOL _BuildButtonDSA();
        CMDMAPCUSTOMIZE* _GetCmdMapCustomize(GUID* guid, UINT nCmdID);

        virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

        virtual STDMETHODIMP GetClassID(CLSID *pClassID) {return E_NOTIMPL;};
        virtual STDMETHODIMP Load(IStream *pStm) {return E_NOTIMPL;};
        virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) {return E_NOTIMPL;};

        // *** IUnknown ***
        virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
        virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
        virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);

        // *** IDeskBand methods ***
        virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi);

        // *** IWinEventHandler methods ***
        virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);

        // *** IDockingWindow methods ***
        virtual STDMETHODIMP CloseDW(DWORD dwReserved) { return S_OK;};

        // *** IInputObject methods ***
        virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    protected:
        IOleCommandTarget* _CommandTargetFromCmdMap(CMDMAP* pcm);
        LRESULT _OnToolbarDropDown(TBNOTIFY *ptbn);
        virtual LRESULT _OnNotify(LPNMHDR pnmh);
        LRESULT _OnContextMenu(LPARAM lParam, WPARAM wParam);
        CMDMAP* _GetCmdMap(int i, BOOL fByIndex);
        void _OnEndCustomize();
        LRESULT _TryShowBackForwardMenu(DWORD dwItemSpec, LPPOINT ppt, LPRECT prcExclude);
        CBrowserToolsBand();
        void _FreeBtnsAdded();

        friend class CInternetToolbar;
        friend class CITBandSite;

        GUID            _guidCurrentButtonGroup;
        IOleCommandTarget* _pctCurrentButtonGroup;
        LPTBBUTTON      _pbtnsAdded;
        int             _cBtnsAdded;
        DWORD            _nNextCommandID;
        CUSTOMIZEINFO *_pcinfo;
        BITBOOL    _fCustomize :1;
        BITBOOL    _fNeedFreeCmdMapsAdded :1;
    };

    CBrowserToolsBand _btb;

    friend class CBrowserToolsBand;
    friend class CITBandSite;
    friend void CInternetToolbar_CleanUp();
    friend void CInternetToolbar_Preload();
    friend void ITBar_LoadToolbarGlyphs(HWND hwnd);
};

//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

HRESULT _GetStreamName(DWORD dwITBS, LPTSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;

    ASSERT(pszName);

    switch (dwITBS)
    {
    case ITBS_WEB:
        StrCpyN(pszName, TEXT("WebBrowser"), cchSize);
        break;

    case ITBS_SHELL:
        StrCpyN(pszName, TEXT("ShellBrowser"), cchSize);
        break;

    case ITBS_EXPLORER:
        StrCpyN(pszName, TEXT("Explorer"), cchSize);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if (FAILED(hr))
        pszName[0] = '\0';

    return hr;
}


//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

IStream *GetRegStream(BOOL fInternet, LPCTSTR pszValue, DWORD grfMode)
{
    IStream *pstm = NULL;
    HKEY    hkToolbar;

    if (RegCreateKey(HKEY_CURRENT_USER, c_szRegKeyCoolbar, &hkToolbar) == ERROR_SUCCESS)
    {
        TCHAR   szStreamName[MAX_PATH];

        if (SUCCEEDED(_GetStreamName(fInternet, szStreamName, ARRAYSIZE(szStreamName))))
            pstm = OpenRegStream(hkToolbar, szStreamName, pszValue, grfMode);

        RegCloseKey(hkToolbar);
    }

    return(pstm);
}


//
// Gets the stream corresponding to the type of the given pidl
//     If the stream already doesn't exist, then it returns NULL.

IStream *GetITBarStream(BOOL fInternet, DWORD grfMode)
{
    return GetRegStream(fInternet, TEXT("ITBarLayout"), grfMode);
}


IMLCACHE CInternetToolbar::s_imlTBGlyphs = {NULL};
BMPCACHE CInternetToolbar::s_bmpBackShell = {NULL};
BMPCACHE CInternetToolbar::s_bmpBackInternet = {NULL};
BOOL g_fSmallIcons = FALSE;

void IMLCACHE_CleanUp(IMLCACHE * pimlCache, DWORD dwFlags)
{
    for (int i = 0; i < CIMLISTS; i++)
    {
        if (pimlCache->arhimlPendingDelete[i])
            ImageList_Destroy(pimlCache->arhimlPendingDelete[i]);

        if ((dwFlags & IML_DESTROY) && pimlCache->arhiml[i])
            ImageList_Destroy(pimlCache->arhiml[i]);
    }
}

// DO NOT change the numbering of the following bitmap specs. 
// If you want to add new sizes, add them _after_ ITB_1616_HOT_HICOLOR

#define    ITB_2020_NORMAL             0
#define    ITB_2020_HOT                1
#define    ITB_1616_NORMAL             2
#define    ITB_1616_HOT                3
#define    ITB_2020_NORMAL_HICOLOR     4
#define    ITB_2020_HOT_HICOLOR        5
#define    ITB_1616_NORMAL_HICOLOR     6
#define    ITB_1616_HOT_HICOLOR        7

void ITBar_LoadToolbarGlyphs(HWND hwnd)
{
    int cx, idBmpType;
    int iBitmapBaseIndex;
    BOOL bUseClassicGlyphs = SHUseClassicToolbarGlyphs();
    HINSTANCE hInst;

    g_fSmallIcons = _UseSmallIcons();

    if (bUseClassicGlyphs)
    {
        g_iToolBarLargeIconWidth = TB_BMP_CX;
        g_iToolBarLargeIconHeight = TB_BMP_CY;

        iBitmapBaseIndex = IDB_SHSTD;
        hInst = HINST_THISDLL;
    }
    else
    {
        g_iToolBarLargeIconWidth = TB_BMP_CX_ALPHABITMAP;
        g_iToolBarLargeIconHeight = TB_BMP_CY_ALPHABITMAP;

        iBitmapBaseIndex = IDB_TB_SH_BASE;
        hInst = GetModuleHandle(TEXT("shell32.dll"));
    }

    if (g_fSmallIcons)
    {
        cx = TB_SMBMP_CX;
        idBmpType = ITB_1616_NORMAL;
    }
    else
    {
        cx = g_iToolBarLargeIconWidth;
        idBmpType = ITB_2020_NORMAL;
    }

    if (SHGetCurColorRes() > 8)
        idBmpType += DELTA_HICOLOR;

    _LoadToolbarGlyphs(hwnd, &CInternetToolbar::s_imlTBGlyphs, cx, idBmpType,
                       iBitmapBaseIndex, bUseClassicGlyphs, hInst);
}


void CInternetToolbar_Preload()
{
   ENTERCRITICAL;
   ITBar_LoadToolbarGlyphs(NULL);
   Brand_InitBrandContexts();
   LEAVECRITICAL;
}


void CInternetToolbar_CleanUp()
{
    TraceMsg(DM_ITBAR, "CInternetToolbar_CleanUp: Destroying shared GDI objects");
    if (CInternetToolbar::s_bmpBackInternet.hbmp)
        DeleteObject(CInternetToolbar::s_bmpBackInternet.hbmp);
    if (CInternetToolbar::s_bmpBackShell.hbmp)
        DeleteObject(CInternetToolbar::s_bmpBackShell.hbmp);

    IMLCACHE_CleanUp(&CInternetToolbar::s_imlTBGlyphs, IML_DESTROY);
}

STDAPI CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CInternetToolbar *pitbar = new CInternetToolbar();
    if (pitbar)
    {
        *ppunk = SAFECAST(pitbar, IDockingWindow *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

LRESULT CInternetToolbar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if ( uMsg == WM_SYSCOLORCHANGE )
    {
        // refresh the back drop incase the colours have changed
        _SetBackground();
    }

    return SUPERCLASS::v_WndProc( hwnd, uMsg, wParam, lParam );
}

void CInternetToolbar::_LoadExternalBandInfo()
{
#ifdef DEBUG
    int i;
    // Should have been zero-initialized
    for (i = 0; i < ARRAYSIZE(_rgebi); i++)
    {

        ASSERT(IsEqualGUID(_rgebi[i].clsid, GUID_NULL));
        ASSERT(_rgebi[i].pwszName == NULL);
        ASSERT(_rgebi[i].pwszHelp == NULL);
    }
#endif

    if ((!SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), TEXT("Enable Browser Extensions"), FALSE, TRUE))
        || (GetSystemMetrics(SM_CLEANBOOT)!=0))
    {
        return;
    }

    HKEY hkey;
    DWORD dwClsidIndex = 0;
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_KEY_BANDSTATE, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR tszReg[MAX_PATH];
        StrCpy(tszReg, TEXT("CLSID\\"));
        const int cchClsidPrefix = 6;      // 6 = strlen("CLSID\\")
        LPTSTR ptszClsid = tszReg + cchClsidPrefix;
        DWORD cchClsid;
        for (DWORD dwIndex = 0;
             cchClsid = ARRAYSIZE(tszReg) - cchClsidPrefix,
             dwClsidIndex < ARRAYSIZE(_rgebi) &&
             RegEnumValue( hkey, dwIndex, ptszClsid, &cchClsid, NULL, NULL, NULL, NULL ) == ERROR_SUCCESS;
             dwIndex++)
        {
            CLSID clsid;

            // We want to ignore the radio toolband {8E718888-423F-11D2-876E-00A0C9082467}
            // without affecting its existing registration. Makes uninstall easier.
            if (GUIDFromString( ptszClsid, &clsid )
                && StrCmpI(ptszClsid, TEXT("{8E718888-423F-11D2-876E-00A0C9082467}")))
            {
                HKEY hkeyClsid;
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, tszReg, 0, KEY_READ, &hkeyClsid) == ERROR_SUCCESS)
                {
                    // Don't save the CLSID until we're sure it worked
                    _rgebi[dwClsidIndex].clsid = clsid;

                    WCHAR wszBuf[MAX_PATH];

                    // Get the name; use SHLoadRegUIString so the app can localize
                    SHLoadRegUIStringW( hkeyClsid, L"", wszBuf, ARRAYSIZE(wszBuf) );
                    Str_SetPtrW( &_rgebi[dwClsidIndex].pwszName, wszBuf);

                    // Get the help; use SHLoadRegUIString so the app can localize
                    SHLoadRegUIStringW( hkeyClsid, L"HelpText", wszBuf, ARRAYSIZE(wszBuf) );
                    Str_SetPtrW( &_rgebi[dwClsidIndex].pwszHelp, wszBuf);

                    RegCloseKey(hkeyClsid);

                    dwClsidIndex++;
                }
            }
        }
        RegCloseKey( hkey );
    }
}

CInternetToolbar::CInternetToolbar() : CBaseBar(), _yCapture(-1), _iButtons(-1)
#ifdef EDIT_HACK
, _iEditIcon(-1), _cxEditGlyph(-1), _cyEditGlyph(-1)
#endif
{
    DllAddRef();

    if (GetSystemMetrics(SM_CXSCREEN) < 650)
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    else
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;

    ASSERT(_fLoading == FALSE);
    ASSERT(_hwnd == NULL);
    ASSERT(_btb._guidCurrentButtonGroup == CLSID_NULL);
    _btb._nNextCommandID = 1000;

    DWORD dwResult = FALSE, dwType, dwcbData = sizeof(dwResult), dwDefault = TRUE;
    SHRegGetUSValue(c_szRegKeyCoolbar, TEXT("Locked"), &dwType, &dwResult, &dwcbData, FALSE, &dwDefault, sizeof(dwDefault));
    SHSetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("Locked"), REG_DWORD, &dwResult, sizeof(dwResult));
    _fLockedToolbar = dwResult;

    _LoadExternalBandInfo();
}

void CInternetToolbar::_Unadvise(void)
{
    if(_dwcpCookie)
    {
        ConnectToConnectionPoint(NULL, DIID_DWebBrowserEvents2, FALSE, _pdie, &_dwcpCookie, NULL);
    }
}

int CALLBACK DeleteDPAPtrCB(void *pItem, void *pData)
{
    if ( pItem )
    {
        ASSERT( ::LocalSize(pItem) == sizeof(FOLDERSEARCHITEM) );
        LocalFree(pItem);
        pItem = NULL;
    }

    return TRUE;
}

CInternetToolbar::~CInternetToolbar()
{
    ATOMICRELEASE(_pdie);

    if(_pbp && _fCreatedBandProxy)
    {
        _pbp->SetSite(NULL);
    }
    
    if (IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);
    }

    ATOMICRELEASE(_pbp);

    ASSERT(!_ptbsite && !_ptbsitect && !_psp && !_pbs && !_pbs2);
    SetSite(NULL);

    if ( _hdpaFSI )
    {
        DPA_DestroyCallback(_hdpaFSI, DeleteDPAPtrCB, NULL);
        _hdpaFSI = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(_rgebi); i++)
    {
        Str_SetPtrW( &_rgebi[i].pwszName, NULL);
        Str_SetPtrW( &_rgebi[i].pwszHelp, NULL);
    }

    TraceMsg(TF_SHDLIFE, "dtor CInternetToolbar %x", this);
    DllRelease();
}

#define IID_DWebBrowserEvents DIID_DWebBrowserEvents


HRESULT CInternetToolbar::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENTMULTI(CInternetToolbar, IDispatch, DWebBrowserEvents),  // IID_IDispatch
        QITABENT(CInternetToolbar, IExplorerToolbar),       // IID_IDispatch
        QITABENT(CInternetToolbar, IObjectWithSite),        // IID_IObjectWithSite
        QITABENT(CInternetToolbar, IPersistStreamInit),     // IID_IPersistStreamInit
        QITABENT(CInternetToolbar, IDockingWindow),         // IID_IDockingWindow
        QITABENT(CInternetToolbar, DWebBrowserEvents),      // IID_DWebBrowserEvents
        QITABENT(CInternetToolbar, IShellChangeNotify),     // rare IID_IShellChangeNotify
        QITABENT(CInternetToolbar, ISearchItems),           // rare IID_ISearchItems
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}

/* IDispatch methods */
HRESULT CInternetToolbar::GetTypeInfoCount(UINT *pctinfo)
{
    return(E_NOTIMPL);
}

HRESULT CInternetToolbar::GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo)
{
    return(E_NOTIMPL);
}

HRESULT CInternetToolbar::GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames,
                                        LCID lcid, DISPID * rgdispid)
{
    return(E_NOTIMPL);
}

#if 0
//  NOTE - StevePro changed it so this code isnt called
//  this is a goodness, because it calls SHVerbExists() which
//  is a TCHAR API, that is actually compiled as an ANSI API
//  and since we are UNICODE it just always fails.
//  leaving this in so that we know about the issue of
//  frontpad.exe possibly needing to be disabled.
BOOL _ShowEditForExtension(LPCTSTR pszExtension)
{
    TCHAR szBuf[MAX_PATH];
    if (SHVerbExists(pszExtension, TEXT("edit"), szBuf))
    {
        // don't show it if it's just our own
        if (StrStrI(szBuf, TEXT("frontpad.exe")))
        {
            return FALSE;
        }
        return TRUE;
    }

    return FALSE;
}
#endif

#ifdef EDIT_HACK
//+-------------------------------------------------------------------------
// This function scans the html document for META tags that indicate the
// program that was used to create the HTML page.  Examples are:
//
//  <meta name="ProgID" content="word.document" >
//  <meta name="ProgID" content="excel.sheet" >
//
// If a match is found, the content of the first match is returned.  This
// progid is used to edit the document.
//--------------------------------------------------------------------------
BSTR CInternetToolbar::_GetEditProgID(IHTMLDocument2* pHTMLDocument)
{
    BSTR bstrProgID = NULL;

    //
    // First get all document elements.  Note that this is very fast in
    // ie5 because the collection directly accesses the internal tree.
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(pHTMLDocument->get_all(&pAllCollection)))
    {
        IHTMLMetaElement* pMetaElement;
        IHTMLBodyElement* pBodyElement;
        IHTMLFrameSetElement* pFrameSetElement;
        IDispatch* pDispItem;

        //
        // Now we scan the document for meta tags.  Since these must reside in
        // in the head, and since Trident always creates a body tag, we can
        // stop looking when we hit the body.
        //
        // Note, the alternative of using pAllCollection->tags to return the
        // collection of meta tags is likely more expensive because it will
        // walk the whole tree (unless Trident optimizes this).
        //
        long lItemCnt;
        VARIANT vEmpty;
        V_VT(&vEmpty) = VT_EMPTY;

        VARIANT vIndex;
        V_VT(&vIndex) = VT_I4;

        EVAL(SUCCEEDED(pAllCollection->get_length(&lItemCnt)));

        for (long lItem = 0; lItem < lItemCnt; lItem++)
        {
            V_I4(&vIndex) = lItem;

            if (S_OK == pAllCollection->item(vIndex, vEmpty, &pDispItem))
            {
                //
                // First see if it's a meta tag
                //
                if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLMetaElement, &pMetaElement))))
                {
                    BSTR bstrName = NULL;

                    //
                    // We have a META element, check its NAME and CONTENT
                    //
                    if ( SUCCEEDED(pMetaElement->get_name(&bstrName)) && (bstrName != NULL) &&
                         (StrCmpIW(bstrName, OLESTR("ProgId")) == 0) &&
                         SUCCEEDED(pMetaElement->get_content(&bstrProgID)) && (bstrProgID != NULL)
                       )
                    {
                        // We got the ProgID, so terminate the search;
                        lItem = lItemCnt;
                    }

                    if (bstrName != NULL)
                        SysFreeString(bstrName);

                    pMetaElement->Release();
                }
                //
                // Next check for the body tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLBodyElement, &pBodyElement))))
                {
                    // Found the body tag, so terminate the search
                    lItem = lItemCnt;
                    pBodyElement->Release();
                }
                //
                // Finally, check for a frameset tag
                //
                else if (SUCCEEDED(pDispItem->QueryInterface(IID_PPV_ARG(IHTMLFrameSetElement, &pFrameSetElement))))
                {
                    // Found a frameset tag, so terminate the search
                    lItem = lItemCnt;
                    pFrameSetElement->Release();
                }
                pDispItem->Release();
            }
        }
        // Make sure that these don't have to be cleared (should not have been modified)
        ASSERT(vEmpty.vt == VT_EMPTY);
        ASSERT(vIndex.vt == VT_I4);

        pAllCollection->Release();
    }

    return bstrProgID;
}

//+-------------------------------------------------------------------------
// Returns grey-scale image from the icon passed in.
//--------------------------------------------------------------------------
HIMAGELIST CInternetToolbar::_CreateGrayScaleImagelist(HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    // Determine the button dimensions
    int cx = g_fSmallIcons ? TB_SMBMP_CX : g_iToolBarLargeIconWidth;
    int cy = g_fSmallIcons ? TB_SMBMP_CY : g_iToolBarLargeIconHeight;

    // Start with a 24 bit color image list
    HIMAGELIST himlEdit = ImageList_Create(cx, cy, ILC_COLOR24 | ILC_MASK, 1, 1);
    if (NULL == himlEdit)
    {
        return NULL;
    }

    ImageList_Add(himlEdit, hbmpImage, hbmpMask);

    // Get the dib section from the image list
    IMAGEINFO ii;
    if (ImageList_GetImageInfo(himlEdit, 0, &ii))
    {
        DIBSECTION ds = {0};
        if (GetObject(ii.hbmImage, sizeof(ds), &ds))
        {
            //
            // Map each pixel to a monochrome equivalent.
            //
            BYTE* pBits = (BYTE*)ds.dsBm.bmBits;
            BYTE* pScan = pBits;
            int xWid = ds.dsBm.bmWidth;
            int yHei = ds.dsBm.bmHeight;
            long cbScan = ((xWid * 24 + 31) & ~31) / 8;

            for (int y=0; y < yHei; ++y)
            {
                for (int x=0; x < xWid; ++x)
                {
                    //
                    // Map to equivalent gray color by setting r,g,b to the same value.
                    // Using the average of r,g,b can be too dark, and using the max
                    // of r,g,b can be too bright.  So, as a simple algorithm we use
                    // the average of the two schemes.  This is cheaper than using true
                    // intensity matching.
                    //
                    BYTE nMax = max(max(pScan[0], pScan[1]), pScan[2]);
                    BYTE nAve = ((UINT)pScan[0] + pScan[1] + pScan[2])/3;
                    pScan[0] = pScan[1] = pScan[2] = ((UINT)nMax + nAve)/2;

                    // Increment to next pixel
                    pScan += 3;
                }

                // Increment to the next scan line
                pBits += cbScan;
                pScan = pBits;
            }
        }
    }
    return himlEdit;
}

//+-------------------------------------------------------------------------
// Returns image and mask bitmaps for the desired image list item
//--------------------------------------------------------------------------
BOOL MyImageList_GetBitmaps
(
    HIMAGELIST himl,        // image list to use
    int iImage,             // image to copy
    int x,                  // x-offset to draw in bitmap
    int y,                  // x-offset to draw in bitmap
    int cx,                 // width of bitmap
    int cy,                 // height of bitmap
    HBITMAP* phbmpImage,    // returned color bitmap
    HBITMAP* phbmpMask      // returned mask bitmap
)
{
    ASSERT(phbmpImage);
    ASSERT(phbmpMask);

    BOOL fRet = FALSE;
    HDC hdc = GetDC(NULL);

    if (hdc)
    {
        HDC hdcDst = CreateCompatibleDC(hdc);
        if (hdcDst)
        {
            HBITMAP hbmpImage = CreateCompatibleBitmap(hdc, cx, cy);
            if (hbmpImage)
            {
                HBITMAP hbmpMask = CreateBitmap(cx, cy, 1, 1, NULL);
                if (hbmpMask)
                {
                    // Draw  mask bitmap
                    HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcDst, hbmpMask);
                    PatBlt(hdcDst, 0, 0, cx, cy, WHITENESS);
                    ImageList_Draw(himl, iImage, hdcDst, x, y, ILD_MASK);

                    // Draw image bitmap
                    SelectObject(hdcDst, hbmpImage);
                    ImageList_Draw(himl, iImage, hdcDst, x, y, ILD_NORMAL);

                    SelectObject(hdcDst, hbmpOld);

                    *phbmpImage = hbmpImage;
                    *phbmpMask  = hbmpMask;
                    fRet = TRUE;
                }
                else
                {
                    DeleteObject(hbmpImage);
                }
            }
            DeleteDC(hdcDst);
        }
        ReleaseDC(NULL, hdc);
    }

    return fRet;
}
extern HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig);

//+-------------------------------------------------------------------------
// Creates a special image list for the edit button and configures the edit
// button to use it.  If the hIcon is -1, the edit button is reset to use
// it's default glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_SetEditGlyph
(
    int iIcon   // new edit button glyph, index into shell image cache
)
{
    // If no toolbar, we just need to see if we need to free the old image lists.
    if (_btb._hwnd == NULL)
    {
        if (iIcon == -1)
        {
            if (_himlEdit)
            {
                ImageList_Destroy(_himlEdit);
                _himlEdit = NULL;
            }
            if (_himlEditHot)
            {
                ImageList_Destroy(_himlEditHot);
                _himlEditHot = NULL;
            }
        }
        else
        {
            // Can't set the glyph if no toolbar!
            ASSERT(FALSE);
        }
        return;
    }

    // Determine the button dimensions
    int cx = g_fSmallIcons ? TB_SMBMP_CX : g_iToolBarLargeIconWidth;
    int cy = g_fSmallIcons ? TB_SMBMP_CY : g_iToolBarLargeIconHeight;


    UINT uiCmd = -1;
    // Dochost merges under one of two clsids, so have to check both
    if (FAILED(_btb._ConvertCmd(&CLSID_InternetButtons, DVIDM_EDITPAGE, NULL, &uiCmd)) &&
        FAILED(_btb._ConvertCmd(&CLSID_MSOButtons, DVIDM_EDITPAGE, NULL, &uiCmd)))
    {
        // The edit button is not on toolbar, so free the edit glyphs
        iIcon = -1;
    }

    // If the current icon is already set, we are done
    if ((_iEditIcon == iIcon) && (_cxEditGlyph == cx) && (_cyEditGlyph == cy))
    {
        if (_himlEdit)
        {
            // Set up the new image lists
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)_himlEdit);
            if (_himlEditHot)
            {
                SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)_himlEditHot);
            }

            // Redirect the edit button to the new image list
            TBBUTTONINFO tbi = {0};
            tbi.cbSize = sizeof(tbi);
            tbi.dwMask = TBIF_IMAGE;
            tbi.iImage = MAKELONG(0, IL_EDITBUTTON);

            SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
        }
        return;
    }

    _iEditIcon = iIcon;
    _cxEditGlyph = cx;
    _cyEditGlyph = cy;

    if (-1 == iIcon)
    {
        if (_himlEdit)
        {
            if (uiCmd != -1)
            {
                // Reset to the original edit glyph
                TBBUTTONINFO tbi = {0};
                tbi.cbSize = sizeof(tbi);
                tbi.dwMask = TBIF_IMAGE;
                tbi.iImage = EDITGLYPH_OFFSET;
                SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
            }

            // Destroy the custom edit glyphs.  Note that we have to reset the primary image list
            // or the image sizes are messed up.
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)NULL);
            ImageList_Destroy(_himlEdit);
            _himlEdit = NULL;
        }

        if (_himlEditHot)
        {
            SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)NULL);
            ImageList_Destroy(_himlEditHot);
            _himlEditHot = NULL;
        }
    }
    else
    {
        // Get the image bitmaps
        HBITMAP hbmpImage = NULL;
        HBITMAP hbmpMask = NULL;
        BOOL bMirrored = IS_WINDOW_RTL_MIRRORED(_btb._hwnd);
        HIMAGELIST himlSmall;
        int cxSmall;
        int cySmall;

        if (Shell_GetImageLists(NULL, &himlSmall) &&
            ImageList_GetIconSize(himlSmall, &cxSmall, &cySmall) &&
            MyImageList_GetBitmaps(himlSmall, iIcon, (cx - cxSmall)/2, (cy - cySmall)/2,
                                   cx, cy, &hbmpImage, &hbmpMask))
        {

            if (bMirrored) 
            {
                HBITMAP hbmpTemp;

                hbmpTemp = CreateMirroredBitmap(hbmpImage);
                if (hbmpTemp)
                {
                    DeleteObject(hbmpImage);
                    hbmpImage = hbmpTemp;
                }
                hbmpTemp = CreateMirroredBitmap(hbmpMask);
                if (hbmpTemp)
                {
                    DeleteObject(hbmpMask);
                    hbmpMask = hbmpTemp;
                }
            }
            // Create a monochrome glyph for the edit button
            HIMAGELIST himlEdit = _CreateGrayScaleImagelist(hbmpImage, hbmpMask);
            SendMessage(_btb._hwnd, TB_SETIMAGELIST, IL_EDITBUTTON, (LPARAM)himlEdit);
            if (_himlEdit)
            {
                ImageList_Destroy(_himlEdit);
            }
            _himlEdit = himlEdit;

            // Create a hot glyph for the edit button
            HIMAGELIST himlEditHot = ImageList_Create(cx, cy, ILC_COLORDDB | ILC_MASK, 1, 1);
            int nIndex = ImageList_Add(himlEditHot, hbmpImage, hbmpMask);

            SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, IL_EDITBUTTON, (LPARAM)himlEditHot);
            if (_himlEditHot)
            {
                ImageList_Destroy(_himlEditHot);
            }
            _himlEditHot = himlEditHot;

            // Redirect the edit button to the new image list
            if (_himlEdit)
            {
                TBBUTTONINFO tbi = {0};
                tbi.cbSize = sizeof(tbi);
                tbi.dwMask = TBIF_IMAGE;
                tbi.iImage = MAKELONG(nIndex, IL_EDITBUTTON);

                SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
            }

            DeleteObject(hbmpImage);
            DeleteObject(hbmpMask);
               
        }
        else
        {
            // Couldn't create images so use the default edit glyph
            _SetEditGlyph(-1);
        }
    }
}

//+-------------------------------------------------------------------------
// Initializes the edit button to display a drop-down menu if there are
// multiple verbs.  Also optionally displays a custion glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_InitEditButtonStyle()
{
    // If we have or want a custon edit glyph, load it
    _SetEditGlyph(_aEditVerb.GetIcon());

    UINT uiCmd;

    // Dochost merges under one of two clsids, so have to check both
    if (SUCCEEDED(_btb._ConvertCmd(&CLSID_InternetButtons, DVIDM_EDITPAGE, NULL, &uiCmd)) ||
        SUCCEEDED(_btb._ConvertCmd(&CLSID_MSOButtons, DVIDM_EDITPAGE, NULL, &uiCmd)))
    {
        ASSERT(uiCmd != -1);

        // If multiple verbs, make the button a split button
        TBBUTTONINFO tbi = {0};
        tbi.cbSize = sizeof(tbi);
        tbi.dwMask = TBIF_STYLE | TBIF_STATE;
        tbi.fsState = 0;

        if (_aEditVerb.GetSize() > 1)
        {
            tbi.fsStyle |= BTNS_DROPDOWN;
        }

        if (_aEditVerb.GetSize() > 0)
        {
            tbi.fsState = TBSTATE_ENABLED;
        }
        SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCmd, (LPARAM)&tbi);
    }
}

//+-------------------------------------------------------------------------
// If the edit button is displaying a custon glyph, this function reloads
// the glyph.
//--------------------------------------------------------------------------
void CInternetToolbar::_RefreshEditGlyph()
{
    // If we have a custon edit glyph, reload it
    if (_himlEdit)
    {
        // Refresh the edit glyph
        _iEditIcon = -1;
        _InitEditButtonStyle();
    }
}

//+-------------------------------------------------------------------------
// Updates the edit button based on the document type currently loaded
//--------------------------------------------------------------------------
void CInternetToolbar::_UpdateEditButton()
{
    _aEditVerb.RemoveAll();
    _fEditEnabled = FALSE;
    BOOL fNoEditSpecified = FALSE;

    //
    // First add editors associated with the url
    //
    BSTR bstrUrl = NULL;
    _pdie->get_LocationURL(&bstrUrl);
    if (bstrUrl)
    {
        LPTSTR pszExt;
        //
        // Find the cache file associated with the url.  The file extension for this entry
        // is based off of the mime type. (Note that get_mimeType on the document
        // returns a frindly name that is hard to translate back to an actual mimetype.
        // So we use the file extension instead.)
        //
        WCHAR szCacheFileName[MAX_PATH];
        *szCacheFileName = 0;
        if (FAILED(URLToCacheFile(bstrUrl, szCacheFileName, ARRAYSIZE(szCacheFileName))))
        {
            // If we can't get a file associated with the url, probably want to disable the edit button
            // because most apps need a file to edit.
            SysFreeString(bstrUrl);
            return;
        }

        pszExt = PathFindExtension(szCacheFileName);

        // bug 79055 - The cache has a bug where some html entries are not
        // given a file extension.  Too risky to fix for 5.x, so we'll just
        // assume .htm for http if no extension is present.
        if (L'\0' == *pszExt && GetUrlScheme(bstrUrl) == URL_SCHEME_HTTP)
        {
            StrCpyN(szCacheFileName, L".htm", ARRAYSIZE(szCacheFileName));
            pszExt = szCacheFileName;
        }

        if (*pszExt)
        {
            _aEditVerb.Add(pszExt);

            // If ".html", use the ".htm" editors too
            if (StrCmpI(pszExt, L".html") == 0 )
            {
                //  This is an html document, so add the .htm editors
                if (!_aEditVerb.Add(TEXT(".htm")) && StrCmpI(pszExt, L".html") != 0)
                {
                    _aEditVerb.Add(TEXT(".html"));
                }
            }
        }

        SysFreeString(bstrUrl);
    }

    //
    // See if the feature to search the doc for the progid is enabled
    //
    static int fCheckDocForProgID = -1;
    if (fCheckDocForProgID == -1)
    {
        fCheckDocForProgID = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                 TEXT("CheckDocumentForProgID"), FALSE, TRUE) ? 1 : 0;
    }

    // Check for a meta tag that specifies a progid for editing this document
    if (fCheckDocForProgID)
    {
        //
        // Next see if this is an html document with a progid
        //
        IWebBrowser2*       pWB2 = NULL;
        IDispatch *         pDispatch = NULL;
        IHTMLDocument2 *    pHTMLDocument = NULL;

        // Get the html document currently loaded
        if (_psp &&
            SUCCEEDED(_psp->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pWB2))) &&
            SUCCEEDED(pWB2->get_Document(&pDispatch)) &&
            SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument))))
        {
            //
            // Check the current document for a META tag specifying the program to use to
            // edit this file.
            //
            BSTR bstrProgID = _GetEditProgID(pHTMLDocument);
            if (bstrProgID)
            {
                if (lstrcmpi(bstrProgID, TEXT("NoEdit")) == 0)
                {
                    fNoEditSpecified = TRUE;
                }
                else
                {
                    USES_CONVERSION;
                    _aEditVerb.Add(W2T(bstrProgID));
                    SysFreeString(bstrProgID);
                }
            }
        }

        SAFERELEASE(pWB2);
        SAFERELEASE(pDispatch);
        SAFERELEASE(pHTMLDocument);
    }


    if (!fNoEditSpecified)
    {
        _fEditEnabled = (_aEditVerb.GetSize() > 0);
    }

    // Update edit glyph, drop-down style, & enabled state
    _InitEditButtonStyle();
}
#endif //EDIT_HACK

HRESULT CInternetToolbar::Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                                 DISPPARAMS * pdispparams, VARIANT * pvarResult,
                                 EXCEPINFO * pexcepinfo,UINT * puArgErr)
{
    if(!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {

    case DISPID_NAVIGATECOMPLETE2:
    {
        //
        // Notify the brand and theater mode objects about whether we're in shell or
        // web mode. Wait til now to do it (rather than doing it in SetCommandTarget)
        // because they might want to ask the browser about the new pidl, which isn't
        // yet filled in at SetCommandTarget time.
        //
        DWORD nCmdexecopt = _fShellView ? CITE_SHELL : CITE_INTERNET;

        LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
        if (pbid)
        {
            IUnknown_Exec(pbid->pdb, &CGID_PrivCITCommands, CITIDM_ONINTERNET, nCmdexecopt, NULL, NULL);
        }

        if (_fTheater)
        {
            IUnknown_Exec(_ptbsite, &CGID_Theater, THID_ONINTERNET, nCmdexecopt, NULL, NULL);
        }

        // If notification is not from a frame, set the _fNavigateComplete flag
        for (DWORD i = 0; i < pdispparams->cArgs; i++)
        {
            if (pdispparams->rgvarg[i].vt == VT_DISPATCH)
            {
                // See who's sending us this event
                IBrowserService* pbs = NULL;
                HRESULT hr = IUnknown_QueryService(pdispparams->rgvarg[i].pdispVal, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs));
                if (pbs)
                {
                    // We don't really need this interface, just its address
                    pbs->Release();
                }
                if (SUCCEEDED(hr) && pbs == _pbs)
                {
                    // Notification did not come from a frame, 
                    _fNavigateComplete = TRUE;
                }
            }
        }
    }
    break;

    case DISPID_BEFORENAVIGATE:
    {
        BOOL fWeb = FALSE;

        ASSERT((pdispparams->rgvarg[5].vt == VT_BSTR) &&
               (pdispparams->rgvarg[5].bstrVal != NULL));

        PARSEDURL pu = { 0 };
        USES_CONVERSION;

        pu.cbSize = sizeof(pu);
        ParseURL(W2T(pdispparams->rgvarg[5].bstrVal), &pu);

        if ((URL_SCHEME_UNKNOWN != pu.nScheme) && (URL_SCHEME_FILE != pu.nScheme))
            fWeb = TRUE;

        UINT uiState = 0;
        GetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, &uiState);

        if ((uiState & TBSTATE_HIDDEN) && fWeb)
        {

            _fTransitionToHTML = TRUE;
            uiState &= ~TBSTATE_HIDDEN;
            SetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, uiState);
        }

        // Default to the edit button hidden
        _fEditEnabled = FALSE;
    }
    break;

    case DISPID_DOWNLOADBEGIN:// This is when we just started to navigate?  No bits?
        _StartDownload();
        break;

    case DISPID_DOWNLOADCOMPLETE:    // we be done
        _fTransitionToHTML = FALSE;
        _StopDownload(FALSE);
        break;

    case DISPID_DOCUMENTCOMPLETE:   // This is where we have all the bits
    {
        //
        // Sometimes we get a premature document complete (for framesets).  We can catch this
        // by checking to see if we have received a DISPID_NAVIGATECOMPLETE2 event
        // for the top window.  We have to update the edit button here instead of in 
        // navigate complete because otherwise the document is not in the interactive
        // state and our metatag search sees the previous document. 
        //
        // REARCHITECT: Is it possible that this event came from a frame and the document is not
        // interactive yet? Trident posts an interactive event right before calling us so
        // we're probably ok.  We don't want to wait for the document complete for the top window
        // in framesets because it can take too long.  Really need to sink DISPID_READYSTATECHANGE
        // and wait for the document to go interactive.
        //
        if (_fNavigateComplete)
        {
            _fNavigateComplete = FALSE;
            _UpdateEditButton();
        }
        break;
    }

    case DISPID_COMMANDSTATECHANGE:
        BOOL fEnable;

        if(!pdispparams || (pdispparams->cArgs != 2) ||
           (pdispparams->rgvarg[0].vt != VT_BOOL) ||
           (pdispparams->rgvarg[1].vt != VT_I4))
            return E_INVALIDARG;

        fEnable = (BOOL) pdispparams->rgvarg[0].boolVal;
        UINT uiCmd;

        switch (pdispparams->rgvarg[1].lVal)
        {
        case CSC_UPDATECOMMANDS:
            // corresponds to OLECMDID_UPDATECOMMANDS from Exec()
            _UpdateToolbar(FALSE);
            break;

        case CSC_NAVIGATEBACK:
            _fBackEnabled = fEnable;
            _btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_BACK, NULL, &uiCmd);
            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd,    MAKELONG(fEnable, 0));
            break;

        case CSC_NAVIGATEFORWARD:
            _fForwardEnabled = fEnable;
            _btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_FORWARD, NULL, &uiCmd);
            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd, MAKELONG(fEnable, 0));
            break;

        default:
            return(E_INVALIDARG);
        }

        // FEATURE need to handle the case of navigation failure and
        // do some cleanup

    }

    return S_OK;
}

// *** IInputObjectSite methods ***

HRESULT CInternetToolbar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return IUnknown_OnFocusChangeIS(_ptbsite, SAFECAST(this, IInputObject*), fSetFocus);
}


//***   CInternetToolbar::IInputObject::* {

HRESULT CInternetToolbar::TranslateAcceleratorIO(LPMSG lpMsg)
{
    LPBANDITEMDATA pbid;

    if (_fShow)
    {
        if (lpMsg->message == WM_KEYDOWN)
        {
            switch (lpMsg->wParam)
            {
            case VK_F4:
        Laddrband:
                if (_nVisibleBands & VBF_ADDRESS)
                {
                    pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
                    if (EVAL(pbid))
                    {
                        HRESULT hrT;

                        hrT = IUnknown_TranslateAcceleratorIO(pbid->pdb, lpMsg);
                        ASSERT(hrT == S_OK);
                    }
                }
                return S_OK;    // (even if we just eat it)
            }
        }
        else if(lpMsg->message == WM_SYSCHAR)
        {
            static CHAR szAccel[2] = "\0";
            CHAR   szChar [2] = "\0";

            if ('\0' == szAccel[0])
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR, szAccel, ARRAYSIZE(szAccel));

            szChar[0] = (CHAR)lpMsg->wParam;
            
            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                goto Laddrband;
            }
        }
        return _bs.TranslateAcceleratorIO(lpMsg);
    }
    return S_FALSE;
}


// }

HRESULT CInternetToolbar::SetSite(IUnknown* punkSite)
{
    ATOMICRELEASE(_ptbsite);
    ATOMICRELEASE(_ptbsitect);
    ATOMICRELEASE(_pbs);
    ATOMICRELEASE(_pbs2);
    ATOMICRELEASE(_psp);

    _Unadvise();

    ATOMICRELEASE(_pdie);

    ASSERT(_ptbsite==NULL);
    ASSERT(_ptbsitect==NULL);
    ASSERT(_pbs==NULL);
    ASSERT(_pbs2==NULL);
    ASSERT(_pdie==NULL);

    if (_pbp && _fCreatedBandProxy)
        _pbp->SetSite(punkSite);

    if (punkSite)
    {
        punkSite->QueryInterface(IID_PPV_ARG(IDockingWindowSite, &_ptbsite));
        punkSite->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_ptbsitect));
        punkSite->QueryInterface(IID_PPV_ARG(IBrowserService2, &_pbs2));
        punkSite->QueryInterface(IID_PPV_ARG(IServiceProvider, &_psp));

        if (_psp)
        {
            _psp->QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &_pdie));
            _psp->QueryService(SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &_pbs));
            ASSERT(_pdie);
        }
        else
        {
            ASSERT(0);
        }

    }
    else
    {
        SetClient(NULL);
    }


    return S_OK;
}


//***
//
void CInternetToolbar::_UpdateGroup(const GUID *pguidCmdGroup, int cnt,
    OLECMD rgcmds[], const GUID* pguidButton, const int buttonsInternal[])
{

    if (!IsEqualGUID(*pguidButton, CLSID_CommonButtons) &&
        !IsEqualGUID(*pguidButton, _btb._guidCurrentButtonGroup))
        return; // we don't have any buttons at this time, so no use checking

    if (_ptbsitect)
    {
        _ptbsitect->QueryStatus(pguidCmdGroup, cnt, rgcmds, NULL);

        // make sure stop is enabled while we are animating
        if (_fAnimating && pguidCmdGroup == NULL && rgcmds[0].cmdID == OLECMDID_STOP)
        {
            rgcmds[0].cmdf = OLECMDF_ENABLED;
        }
    }

    for (int i = 0; i < cnt; i++)
    {
        // do nothing if command is not available or not in our table
        if (rgcmds[i].cmdf & OLECMDF_SUPPORTED)
        {
            UINT idBut;
            if (SUCCEEDED(_btb._ConvertCmd(pguidButton, buttonsInternal[i], NULL, (UINT*)&idBut)))
            {
                SendMessage(_btb._hwnd, TB_ENABLEBUTTON, idBut,
                    (rgcmds[i].cmdf & OLECMDF_ENABLED) ? TRUE : FALSE);

                SendMessage(_btb._hwnd, TB_CHECKBUTTON, idBut,
                    (rgcmds[i].cmdf & OLECMDF_LATCHED) ? TRUE : FALSE);
            }
        }
    }
    return;
}

void CInternetToolbar::_UpdateToolbar(BOOL fForce)
{
    if (fForce || SHIsChildOrSelf(GetForegroundWindow(), _hwnd) == S_OK)
    {
        if (!_fUpdateToolbarTimer)
        {
            SetTimer(_hwnd, IDT_UPDATETOOLBAR, TIMEOUT_UPDATETOOLBAR, NULL);
            _fUpdateToolbarTimer = TRUE;
            _UpdateToolbarNow();
        }
        else
        {
            _fNeedUpdateToolbar = TRUE;
        }
    }
}

BOOL CInternetToolbar::_UpEnabled()
{
    OLECMD rgcmd = { FCIDM_PREVIOUSFOLDER, 0 };
    _ptbsitect->QueryStatus(&CGID_ShellBrowser, 1, &rgcmd, NULL);

    return (rgcmd.cmdf & OLECMDF_ENABLED);
}

void CInternetToolbar::_UpdateCommonButton(int iCmd, UINT nCmdID)
{
    switch (nCmdID)
    {
    case TBIDM_THEATER:
        SendMessage(_btb._hwnd, TB_CHECKBUTTON, iCmd, _fTheater);
        break;

    case TBIDM_PREVIOUSFOLDER:
    case TBIDM_BACK:
    case TBIDM_FORWARD:
        {
            BOOL fEnabled;

            switch (nCmdID)
            {
            case TBIDM_PREVIOUSFOLDER:  fEnabled = _UpEnabled();       break;
            case TBIDM_BACK:            fEnabled = _fBackEnabled;      break;
            case TBIDM_FORWARD:         fEnabled = _fForwardEnabled;   break;
            }

            SendMessage(_btb._hwnd, TB_ENABLEBUTTON, iCmd, MAKELONG(fEnabled, 0));
        }
        break;
    }
}

void CInternetToolbar::_UpdateToolbarNow()
{
    _fNeedUpdateToolbar = FALSE;

    {
        // MUST not be static (due to ConvertCmd overwrite)
        OLECMD rgcmds[] = {
            { OLECMDID_STOP, 0 }, // NOTE: must be first
            { OLECMDID_REFRESH, 0 },
        };

        static const int buttonsInternal[] = { // MUST be in same order as above array
            TBIDM_STOPDOWNLOAD,
            TBIDM_REFRESH,
        };
        _UpdateGroup(NULL, ARRAYSIZE(buttonsInternal), rgcmds, &CLSID_CommonButtons, buttonsInternal);
    }

    {
        OLECMD rgcmds[] = {
            { SBCMDID_SEARCHBAR, 0 },
            { SBCMDID_FAVORITESBAR, 0 },
            { SBCMDID_HISTORYBAR, 0 },
            { SBCMDID_EXPLORERBAR, 0 },
            { SBCMDID_MEDIABAR, 0 },
        };
        static const int buttonsInternal[] = { // MUST be in same order as above array
            TBIDM_SEARCH,
            TBIDM_FAVORITES,
            TBIDM_HISTORY,
            TBIDM_ALLFOLDERS,
            TBIDM_MEDIABAR,
        };

        _UpdateGroup(&CGID_Explorer, ARRAYSIZE(buttonsInternal), rgcmds, &CLSID_CommonButtons, buttonsInternal);
    }

    int nButtons = (int) SendMessage(_btb._hwnd, TB_BUTTONCOUNT, 0, 0L);

    for (int nIndex = 0; nIndex < nButtons; nIndex++)
    {
        CMDMAP* pcm = _btb._GetCmdMapByIndex(nIndex);
        if (pcm)
        {
            int iCmd = _btb._CommandFromIndex(nIndex);
            if (IsEqualGUID(pcm->guidButtonGroup, CLSID_CommonButtons))
            {
                _UpdateCommonButton(iCmd, pcm->nCmdID);
            }
            else
            {
                // NOTE (andrewgu): ie5.5 b#106047 - the two conditions below used to be ASSERTs,
                // the second one was faulting under stress. if either one of these checks fails,
                // the button is stale.
                if (IsEqualGUID(pcm->guidButtonGroup, _btb._guidCurrentButtonGroup) &&
                    NULL != _btb._pctCurrentButtonGroup)
                {
                    OLECMD ocButton;
                    ocButton.cmdID = pcm->nCmdID;
                    ocButton.cmdf = 0;

                    if (SUCCEEDED(_btb._pctCurrentButtonGroup->QueryStatus(&pcm->guidButtonGroup, 1, &ocButton, NULL)))
                    {
                        SendMessage(_btb._hwnd, TB_ENABLEBUTTON, iCmd,
                                    (ocButton.cmdf & OLECMDF_ENABLED) ? TRUE : FALSE);

                        SendMessage(_btb._hwnd, TB_CHECKBUTTON, iCmd,
                                    (ocButton.cmdf & OLECMDF_LATCHED) ? TRUE : FALSE);
                    }
                }
            }
        }
    }

    if (_btb._hwnd)
    {
        _btb._BandInfoChanged();
    }
}

void CInternetToolbar::_StartDownload()
{
    UINT uiCmd;
    if (SUCCEEDED(_btb._ConvertCmd(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, NULL, &uiCmd)))
    {
        SendMessage(_btb._hwnd, TB_ENABLEBUTTON, uiCmd, MAKELONG(TRUE, 0));

        _fAnimating = TRUE;
    }
}

//
// Parameters:
//  fClosing -- TRUE only if we are calling this from CloseDW member.
//              In that case, we can skip all UI-update code.
//
void CInternetToolbar::_StopDownload(BOOL fClosing)
{
    _fAnimating = FALSE;
}

HRESULT CInternetToolbar::CloseDW(DWORD dwReserved)
{
    _fDestroyed = TRUE; // Stop using the member variables, they are invalid.
    _StopDownload(TRUE);

    ASSERT(!_btb._pcinfo);
    ATOMICRELEASE(_btb._pctCurrentButtonGroup);

    _btb._FreeBtnsAdded();

    if (_btb._hwnd)
    {
        _btb._RemoveAllButtons();

        SendMessage(_btb._hwnd, TB_SETIMAGELIST, 0, NULL);
        SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, 0, NULL);

        DSA_Destroy(_hdsaTBBMPs);
        _hdsaTBBMPs = NULL;  // So we don't try to re-destroy in _InitBitmapDSA()
    }
#ifdef EDIT_HACK
    _SetEditGlyph(-1);
#endif

    _bs._Close();

    SUPERCLASS::CloseDW(dwReserved);

    _btb._hwnd = NULL;

    // We advise during ShowDW, so unadvise here. Also, we hit a stress
    // case where it seems that an event came in after closedw but before
    // one of the other _Unadvise calls. This event percolated down to
    // a reference to _hdsaCT which we freed above, causing a GPF.
    //
    _Unadvise();

    return S_OK;
}

void CInternetToolbar::CITBandSite::v_SetTabstop(LPREBARBANDINFO prbbi)
{
    // Don't set tabstops for all bands in the browser case.  A band
    // can still make itself a tabstop by setting WS_TABSTOP.
    return;
}

BOOL CInternetToolbar::CITBandSite::_SetMinDimensions()
{
    INT_PTR fRedraw = SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

    int icBands = (int) SendMessage( _hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_ID | RBBIM_CHILDSIZE;
        if (SendMessage(_hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            LPBANDITEMDATA pbid = (LPBANDITEMDATA)_GetBandItemDataStructByID(rbbi.wID);
            if (EVAL(pbid) && IS_VALID_HANDLE(pbid->hwnd, WND))
            {
                rbbi.cxMinChild = pbid->ptMinSize.x;
                rbbi.cyMinChild = pbid->ptMinSize.y;
            }
            else
            {
                rbbi.cxMinChild = 0;
                rbbi.cyMinChild = 0;
            }

            SendMessage(_hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
        }
    }

    SendMessage(_hwnd, WM_SETREDRAW, fRedraw, 0);

    return TRUE;
}


BOOL HimlCacheDirty(IMLCACHE* pimlCache, BOOL fSmallIcons)
{

    if (fSmallIcons != pimlCache->fSmallIcons)
        return TRUE;

    COLORREF cr3D = GetSysColor(COLOR_3DFACE);

    if (cr3D != pimlCache->cr3D)
        return TRUE;

    if (SHUseClassicToolbarGlyphs() != pimlCache->fUseClassicGlyphs)
        return TRUE;

    for (int i = 0; i < CIMLISTS; i++)
        if (!pimlCache->arhiml[i])
            return TRUE;

    return FALSE;
}


#define SZ_REGKEY_SMALLICONS       REGSTR_PATH_EXPLORER TEXT("\\SmallIcons")
#define SZ_REGVALUE_SMALLICONS     TEXT("SmallIcons")

BOOL _DefaultToSmallIcons()
{
    // We default to small icons if:
    //
    // This is NT 5, or the policy says to use small icons, or this is any
    // of the Whistler servers (server, adv server, dtc)

    return ((GetUIVersion() == 5) || SHRestricted2(REST_SMALLICONS, NULL, 0) ||
            (IsOS(OS_WHISTLERORGREATER) && IsOS(OS_ANYSERVER)));
}

BOOL _UseSmallIcons()
{
    BOOL fDefaultToSmall = _DefaultToSmallIcons();

    return SHRegGetBoolUSValue(SZ_REGKEY_SMALLICONS, SZ_REGVALUE_SMALLICONS,
                                        FALSE, fDefaultToSmall);
}


BOOL _UseMapNetDrvBtns()
{
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define SZ_REGVALUE_MAPNETDRV      TEXT("MapNetDrvBtn")

    DWORD dwData = 0;
    if (GetUIVersion() >= 4)
    {
        DWORD cbData = sizeof(dwData);
        DWORD dwDefault = 0;
        DWORD cbDefault = sizeof(dwDefault);

        SHRegGetUSValue(SZ_REGKEY_ADVFOLDER, SZ_REGVALUE_MAPNETDRV, NULL,
                            &dwData, &cbData, FALSE, &dwDefault, cbDefault);
    }
    return dwData;
}

HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask, UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst);

void _LoadToolbarGlyphs(HWND hwnd, IMLCACHE *pimlCache, int cx, int idBmpType,
                        int iBitmapBaseIndex, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    // set uMsg and uFlags for first iteration of loop (default state)
    UINT uMsg = TB_SETIMAGELIST;
    UINT uFlags = LR_CREATEDIBSECTION;
    int i;
    HBITMAP hBMP;
    BOOL fSmallIcons = g_fSmallIcons;

    if (HimlCacheDirty(pimlCache, fSmallIcons))
    {
        COLORREF cr3D   = GetSysColor(COLOR_3DFACE);
        COLORREF crMask = RGB( 255, 0, 255 );

#ifdef UNIX
        if (SHGetCurColorRes() < 2 )
        {
            crMask = CLR_NONE;
        }
#endif

        ENTERCRITICAL;

        if (!HimlCacheDirty(pimlCache, fSmallIcons) )
            goto DontReload;

        for (i = 0; i < CIMLISTS; i++)
        {
            if ((!pimlCache->arhiml[i]) || (cr3D != pimlCache->cr3D) ||
                (fSmallIcons != pimlCache->fSmallIcons) || (bUseClassicGlyphs != pimlCache->fUseClassicGlyphs))
            {
                TraceMsg(DM_ITBAR, "_LoadToolbarGlyphs: Loading New Images");

                if (pimlCache->arhimlPendingDelete[i])
                    ImageList_Destroy(pimlCache->arhimlPendingDelete[i]);

                pimlCache->arhimlPendingDelete[i] = pimlCache->arhiml[i];

                pimlCache->arhiml[i] = _LoadThemedToolbarGlyphs(idBmpType, i, cx, crMask, uFlags, bUseClassicGlyphs, hInst);

                if (pimlCache->arhiml[i])
                {
                    // add shell glyphs
                    int idShellBmp = iBitmapBaseIndex + idBmpType;
                    hBMP = (HBITMAP) LoadImage (hInst, MAKEINTRESOURCE(idShellBmp + i), IMAGE_BITMAP,
                                      0, 0, uFlags);

                    ImageList_AddMasked(pimlCache->arhiml[i], (HBITMAP)hBMP, crMask);

                    DeleteObject(hBMP);
                }
            }
        }
        pimlCache->cr3D = cr3D;
        pimlCache->fSmallIcons = fSmallIcons;
        pimlCache->fUseClassicGlyphs = bUseClassicGlyphs;
DontReload:
        LEAVECRITICAL;
    }

    if (hwnd)
    {
        ASSERT(IS_VALID_HANDLE(hwnd, WND));

        for (i = 0; i < CIMLISTS; i++)
        {
            SendMessage(hwnd, uMsg, 0, (LPARAM) pimlCache->arhiml[i]);

            // set uMsg and uFlags for last iteration of loop (hot state)
            uMsg = TB_SETHOTIMAGELIST;
            uFlags = 0;
        }
    }
}

#ifdef THEME_BUTTONS
BOOL _GetThemeSetting(HKEY hkey, PDWORD pdwSetting)
{
    ASSERT(pdwSetting);
    BOOL fRet = FALSE;
    DWORD dwType, dwcbData = sizeof(*pdwSetting);
    *pdwSetting = 0;
    if (ERROR_SUCCESS==SHGetValue(hkey, 
                                  c_szRegKeyCoolbar, TEXT("UseTheme"), &dwType, pdwSetting, &dwcbData))
    {
        // We going to assume that the data type and size is correct. This way, we can break
        // into an error state.
        fRet = TRUE;
        // Acceptable values:
        // 0: use IE6 icons
        // 1: use IE5.5 icons
        // 2: use themed icons
        // other values are reserved.
        if (*pdwSetting > 2)
        {
            *pdwSetting = 0;
        }
    }
    return fRet;
}


HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask,
                                    UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    HIMAGELIST himl = NULL;
    // Restriction goes here.

    HKEY hkey = HKEY_CURRENT_USER;
    DWORD dwSetting = 0;
    if (!_GetThemeSetting(hkey, &dwSetting))
    {
        hkey = HKEY_LOCAL_MACHINE;
        _GetThemeSetting(hkey, &dwSetting);
    }

    DWORD dwType, dwcbData;
    if (dwSetting==2)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szItem[] = TEXT("ITBx");
        szItem[3] = TEXT('0') + idBmpType + iTemperature;

        dwcbData = sizeof(szPath);
        if ((ERROR_SUCCESS==SHGetValue(hkey, 
                                       c_szRegKeyCoolbar, szItem, &dwType, szPath, &dwcbData))
            && (dwType==REG_SZ))
        {
            int nBmpIndex = PathParseIconLocation(szPath);

            WCHAR szExpPath[MAX_PATH];
            SHExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath));

            // If no resource id, assume it's a bmp file
            if (nBmpIndex==0)
            {
                himl = CreateImageList(NULL,
                                       szExpPath, cx, 0, crMask,
                                       IMAGE_BITMAP, uFlags | LR_LOADFROMFILE,
                                       !bUseClassicGlyphs);
            }

            // Otherwise, see if it's a resouce
            if (!himl)
            {
                HINSTANCE hInst = LoadLibraryEx(szExpPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
                if (hInst)
                {
                    himl = CreateImageList(hInst,
                                           MAKEINTRESOURCE(nBmpIndex), cx, 0, crMask,
                                           IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
                    FreeLibrary(hInst);
                }
            }

            if (himl)
            {
                // You just can't trust anyone these days. If the graphics aren't the expected 
                // size, or there aren't the expected number, we're going to use the defaults

                // ISSUE: 16 is a magic number. Do we have a constant anywhere? I can't find it.
                int ecx, ecy;
                if (!(ImageList_GetIconSize(himl, &ecx, &ecy)
                    && (ecx==ecy)
                    && (ecy==cx)
                    && (ImageList_GetImageCount(himl)==16)))
                {
                    ImageList_Destroy(himl);
                    himl = NULL;
                }
            }
        }
    }

    if (!himl)
    {
        // dwSetting must be 1 to get IE6 icons. If dwSetting isn't set to 1, then default
        // either to the new Whistler icons or the default IE icons (as appropriate)
        int iResource;

        if (dwSetting == 1)
        {
            iResource = IDB_IE6_TOOLBAR;
        }
        else
        {
            if (bUseClassicGlyphs)
            {
                iResource = IDB_IETOOLBAR;
            }
            else
            {
                iResource = IDB_TB_IE_BASE;
            }
        }

        iResource += (idBmpType + iTemperature);

        himl = CreateImageList(hInst,
                               MAKEINTRESOURCE(iResource), cx, 0, crMask,
                               IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
    }
    return himl;
}

#else
HIMAGELIST _LoadThemedToolbarGlyphs(int idBmpType, int iTemperature, int cx, COLORREF crMask,
                                    UINT uFlags, BOOL bUseClassicGlyphs, HINSTANCE hInst)
{
    HIMAGELIST himl = NULL;
    int iResource;
    if (bUseClassicGlyphs)
    {
        iResource = IDB_IETOOLBAR;
    }
    else
    {
        iResource = IDB_TB_IE_BASE;
    }
    iResource += (idBmpType + iTemperature);

    himl = CreateImageList(hInst,
                           MAKEINTRESOURCE(iResource), cx, 0, crMask,
                           IMAGE_BITMAP, uFlags, !bUseClassicGlyphs);
    return himl;
}

#endif

void CInternetToolbar::_InitBitmapDSA()
{
    DSA_Destroy(_hdsaTBBMPs);
    _hdsaTBBMPs = DSA_Create(sizeof(TBBMP_LIST), TBBMPLIST_CHUNK);

    if (_hdsaTBBMPs)
    {
        TBBMP_LIST tbl = { HINST_COMMCTRL, 0, 0, TRUE, TRUE, FALSE };

        tbl.uiResID = IDB_STD_SMALL_COLOR;
        tbl.uiOffset = OFFSET_STD;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_STD_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);

        tbl.uiResID = IDB_VIEW_SMALL_COLOR;
        tbl.uiOffset = OFFSET_VIEW;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_VIEW_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);

        tbl.uiResID = IDB_HIST_SMALL_COLOR;
        tbl.uiOffset = OFFSET_HIST;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
        tbl.uiResID = IDB_HIST_LARGE_COLOR;
        DSA_AppendItem(_hdsaTBBMPs, &tbl);
    }
}


void CInternetToolbar::_ReloadBitmapDSA()
{
    if (_hdsaTBBMPs)
    {
        INT i = 6; 
        TBBMP_LIST * pTBBs = NULL;
        int nCount = DSA_GetItemCount(_hdsaTBBMPs);
        // We want to skip the first 6 entries in the DSA, which are added by InitBitmapDSA
        for (int nIndex = 6; nIndex < nCount; nIndex++)
        {
            pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
            if (pTBBs)
            {
                HIMAGELIST himl = NULL;
                if (pTBBs->fNormal)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETIMAGELIST, TB_SETIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
                if (pTBBs->fHot)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETHOTIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETHOTIMAGELIST, TB_SETHOTIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
                if (pTBBs->fDisabled)
                {
                    himl = (HIMAGELIST)SendMessage(_btb._hwnd, TB_GETDISABLEDIMAGELIST, 0, 0L);
                    if (himl
                        && (pTBBs->uiOffset==ImageList_GetImageCount(himl)))
                    {
                        LRESULT lOffset = _AddBitmapFromForeignModule(TB_GETDISABLEDIMAGELIST, TB_SETDISABLEDIMAGELIST, pTBBs->uiCount, pTBBs->hInst, pTBBs->uiResID, RGB(192,192,192));
                        ASSERT(pTBBs->uiOffset==lOffset);
                    }
                }
            }
        }
    }
}


void CInternetToolbar::_InitForScreenSize()
{
    TCHAR szScratch[16];
    if (GetSystemMetrics(SM_CXSCREEN) < 650) 
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_LORES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    } 
    else 
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_HIRES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;
    }
    _uiMaxTBWidth += StrToInt(szScratch) * WIDTH_FACTOR;
}


// removes all buttons marked hidden.  returns the number
// of buttons left
int RemoveHiddenButtons(TBBUTTON* ptbn, int iCount)
{
    int i;
    int iTotal = 0;
    TBBUTTON* ptbn1 = ptbn;
    for (i = 0; i < iCount; i++, ptbn1++) 
    {
        if (!(ptbn1->fsState & TBSTATE_HIDDEN)) 
        {
            if (ptbn1 != ptbn) 
            {
                *ptbn = *ptbn1;
            }
            ptbn++;
            iTotal++;
        }
    }
    return iTotal;
}

#ifdef DEBUG
void _AssertRestrictionOrderIsCorrect()
{
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbExplorer) == ARRAYSIZE(c_rest));

    for (UINT i = 0; i < ARRAYSIZE(c_tbExplorer); i++)
    {
        // If any of these rip, it means that c_rest and c_tbExplorer have
        // gotten out of sync.  Need to fix up c_rest to match c_tbExplorer.
        switch (c_tbExplorer[i].idCommand)
        {
            case TBIDM_BACK:            ASSERT(c_rest[i] == REST_BTN_BACK);         break;
            case TBIDM_FORWARD:         ASSERT(c_rest[i] == REST_BTN_FORWARD);      break;
            case TBIDM_STOPDOWNLOAD:    ASSERT(c_rest[i] == REST_BTN_STOPDOWNLOAD); break;
            case TBIDM_REFRESH:         ASSERT(c_rest[i] == REST_BTN_REFRESH);      break;
            case TBIDM_HOME:            ASSERT(c_rest[i] == REST_BTN_HOME);         break;
            case TBIDM_SEARCH:          ASSERT(c_rest[i] == REST_BTN_SEARCH);       break;
            case TBIDM_HISTORY:         ASSERT(c_rest[i] == REST_BTN_HISTORY);      break;
            case TBIDM_FAVORITES:       ASSERT(c_rest[i] == REST_BTN_FAVORITES);    break;
            case TBIDM_ALLFOLDERS:      ASSERT(c_rest[i] == REST_BTN_ALLFOLDERS);   break;
            case TBIDM_THEATER:         ASSERT(c_rest[i] == REST_BTN_THEATER);      break;
            case TBIDM_MEDIABAR:        ASSERT(c_rest[i] == REST_BTN_MEDIABAR);     break;
            default:                    ASSERT(c_rest[i] == REST_BROWSER_NONE);     break;
        }
    }
}
#endif

__inline BOOL CInternetToolbar::_FoldersButtonAvailable()
{
    return (GetUIVersion() >= 4);
}

void CInternetToolbar::_AdminMarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons)
{
    // We only have policies for web buttons.
    ASSERT(!_fShellView);

    // Caller should have checked this.
    ASSERT(SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0));


    // SHRestricted2 returns 0 if it can't find the policy.  Assert that
    // this lines up with RESTOPT_BTN_STATE_DEFAULT.
    COMPILETIME_ASSERT(RESTOPT_BTN_STATE_DEFAULT == 0);

    for (UINT i = 0; i < cButtons; i++) 
    {
        if (c_rest[i] != 0)
        {
            DWORD dwRest = SHRestricted2(c_rest[i], NULL, 0);
            ptbb[i].fsState = SHBtnStateFromRestriction(dwRest, ptbb[i].fsState);
        }
    }

    // Folders button is not available on non-integrated platforms, so
    // set state to hidden even if policy specifies that it should be shown.
    ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
    if (!_FoldersButtonAvailable())
        ptbb[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;
}

void CInternetToolbar::_MarkDefaultButtons(PTBBUTTON ptbb, UINT cButtons)
{
    if (SHRestricted(REST_NONLEGACYSHELLMODE))
    {
        ASSERT(ptbb[TBXID_BACK].idCommand == TBIDM_BACK);
        ptbb[TBXID_BACK].fsState |= TBSTATE_HIDDEN;
        ASSERT(ptbb[TBXID_FORWARD].idCommand == TBIDM_FORWARD);
        ptbb[TBXID_FORWARD].fsState |= TBSTATE_HIDDEN;
    }

    if (_fShellView) 
    {
        ASSERT(c_tbExplorer[TBXID_STOPDOWNLOAD].idCommand == TBIDM_STOPDOWNLOAD);
        ptbb[TBXID_STOPDOWNLOAD].fsState |= TBSTATE_HIDDEN;
        ASSERT(c_tbExplorer[TBXID_REFRESH].idCommand == TBIDM_REFRESH);
        ptbb[TBXID_REFRESH].fsState |= TBSTATE_HIDDEN;
        ASSERT(c_tbExplorer[TBXID_HOME].idCommand == TBIDM_HOME);
        ptbb[TBXID_HOME].fsState |= TBSTATE_HIDDEN;

        ASSERT(c_tbExplorer[TBXID_SEARCH].idCommand == TBIDM_SEARCH);
        ASSERT(c_tbExplorer[TBXID_HISTORY].idCommand == TBIDM_HISTORY);
        ASSERT(c_tbExplorer[TBXID_SEPARATOR2].idCommand == 0);    // (a separator)

        if (GetUIVersion() < 5) 
        {
            ptbb[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
            ptbb[TBXID_HISTORY].fsState |= TBSTATE_HIDDEN;
            ptbb[TBXID_SEPARATOR2].fsState |= TBSTATE_HIDDEN;
        }
        else
        {
            if (GetUIVersion() > 5)
            {
                ptbb[TBXID_HISTORY].fsState |= TBSTATE_HIDDEN;
            }

            if (SHRestricted(REST_NOSHELLSEARCHBUTTON))
            {
                ptbb[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
            }
            ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
            ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
            if (SHRestricted(REST_NONETCONNECTDISCONNECT))
            {
                ptbb[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
                ptbb[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
            }
        }

        ASSERT(c_tbExplorer[TBXID_FAVORITES].idCommand == TBIDM_FAVORITES);
        ptbb[TBXID_FAVORITES].fsState |= TBSTATE_HIDDEN;
    }

    ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
    if (!_fShellView)
        ptbb[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
    ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
    if (!_fShellView || !_UseMapNetDrvBtns()) 
    {
        ptbb[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
        ptbb[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
    }

    // If this TBIDM_ALLFOLDERS assertion rips, remember to fix up _AdminMarkDefaultButtons too.
    ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
    if (!_fShellView || GetUIVersion() < 5)
        ptbb[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_THEATER].idCommand == TBIDM_THEATER);
    ptbb[TBXID_THEATER].fsState |= TBSTATE_HIDDEN;

    ASSERT(c_tbExplorer[TBXID_MEDIABAR].idCommand == TBIDM_MEDIABAR);
    if (_fShellView || SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) || !CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        ptbb[TBXID_MEDIABAR].fsState |= TBSTATE_HIDDEN;
    }

    ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
    if (!_fShellView) 
    {
        ptbb[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;
    }
}

void CInternetToolbar::_AddCommonButtons()
{
    TBBUTTON  tbExplorer[ARRAYSIZE(c_tbExplorer)];

    memcpy(tbExplorer, c_tbExplorer, sizeof(TBBUTTON) * ARRAYSIZE(c_tbExplorer));

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        if (!SHUseClassicToolbarGlyphs())
        {
            tbExplorer[0].iBitmap = 1;
            tbExplorer[1].iBitmap = 0;
        }
    }

    _MarkDefaultButtons(tbExplorer, ARRAYSIZE(c_tbExplorer));

#ifdef DEBUG
    _AssertRestrictionOrderIsCorrect();
#endif

    if (!_fShellView && SHRestricted2(REST_SPECIFYDEFAULTBUTTONS, NULL, 0))
        _AdminMarkDefaultButtons(tbExplorer, ARRAYSIZE(c_tbExplorer));

    int iButtons = RemoveHiddenButtons(tbExplorer, ARRAYSIZE(tbExplorer));

    for (int i = 0; i < iButtons; i++) 
    {
        if (!(tbExplorer[i].fsStyle & BTNS_SEP)) 
        {
            CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
            if (pcm) 
            {
                pcm->guidButtonGroup = CLSID_CommonButtons;
                pcm->nCmdID = tbExplorer[i].idCommand;

                tbExplorer[i].idCommand = _btb._nNextCommandID++;
                tbExplorer[i].dwData = (LPARAM)pcm;
            }
        }
    }

    SendMessage(_btb._hwnd, TB_ADDBUTTONS, iButtons, (LPARAM) tbExplorer);

    _btb._RecalcButtonWidths();
}

#define IS_LIST_STYLE(hwnd) (BOOLIFY(GetWindowLong(hwnd, GWL_STYLE) & TBSTYLE_LIST))

void CInternetToolbar::_UpdateToolsStyle(BOOL fList)
{
    if (BOOLIFY(fList) != IS_LIST_STYLE(_btb._hwnd))
    {
        _fDirty = TRUE;

        // toggle TBSTYLE_LIST
        SHSetWindowBits(_btb._hwnd, GWL_STYLE, TBSTYLE_LIST, fList ? TBSTYLE_LIST : 0);
        // toggle TBSTYLE_EX_MIXEDBUTTONS
        SendMessage(_btb._hwnd, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_MIXEDBUTTONS, fList ? TBSTYLE_EX_MIXEDBUTTONS : 0);
    }
}

void CInternetToolbar::_InitToolbar()
{
    TCHAR szShellTBText[1024];  // This should be enough
    ZeroMemory(szShellTBText, sizeof(szShellTBText));
    int nRows = _fCompressed ? 0 : _uiTBTextRows;
    DWORD dwStyle = TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_HIDECLIPPEDBUTTONS;

    if (IsOS(OS_WHISTLERORGREATER))
        dwStyle |= TBSTYLE_EX_DOUBLEBUFFER;

    // this tells the toolbar what version we are
    SendMessage(_btb._hwnd, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);
    SendMessage(_btb._hwnd, TB_SETEXTENDEDSTYLE, dwStyle, dwStyle);
    SendMessage(_btb._hwnd, TB_SETMAXTEXTROWS,      nRows, 0L);
    SendMessage(_btb._hwnd, TB_SETDROPDOWNGAP,  GetSystemMetrics(SM_CXEDGE) / 2, 0);
    SendMessage(_btb._hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);

    _UpdateToolsStyle(_cs.fList);
    _fDirty = FALSE; // _UpdateToolsStyle unfortunately sets this early on; but we can assume we're not dirty now.

    ITBar_LoadToolbarGlyphs(_btb._hwnd);
    _InitBitmapDSA();

    _InitForScreenSize();

    SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), IDS_IE_TB_LABELS);

    _AddCommonButtons();

    INT_PTR nRet = SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), IDS_SHELL_TB_LABELS);

#ifdef DEBUG
    if (nRet != SHELLTOOLBAR_OFFSET)
        TraceMsg(TF_ERROR, "CInternetToolbar::_InitToolbar -- nRet != SHELLTOOLBAR_OFFSET");
#endif
}

HRESULT CInternetToolbar::_ShowTools(PBANDSAVE pbs)
{
    HRESULT         hr  = S_OK;
    LPBANDITEMDATA  pbid = _bs._GetBandItemDataStructByID(CBIDX_TOOLS);

    if (!pbid)
    {
        ASSERT(!_btb._hwnd);

        _btb._hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_CHILD | TBSTYLE_FLAT |
                                TBSTYLE_TOOLTIPS |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 0, 0, _bs._hwnd, (HMENU) FCIDM_TOOLBAR, HINST_THISDLL, NULL);

        if (_btb._hwnd)
        {
            _InitToolbar();
            pbid = _AddNewBand((IDeskBand*)&_btb, CBIDX_TOOLS);
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
    {
        pbs = NULL;
    }

    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_TOOLS);
    return hr;
}

void CInternetToolbar::_ShowBandCommon(PBANDSAVE pbs, LPBANDITEMDATA pbid, BOOL fShow)
{
    REBARBANDINFO   rbbi;

    pbid->fShow = BOOLIFY(fShow);
    if (pbid->pdb)
    {
        pbid->pdb->ShowDW(pbid->fShow);
    }

    INT_PTR i = BandIDtoIndex(_bs._hwnd, pbid->dwBandID);

    if (pbs)
    {
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_SIZE | RBBIM_STYLE;

        // we just want to change the RBBS_BREAK bit
        // assert that our caller doesn't expect to set any other bits
        // ASSERT(!(pbs->fStyle & ~RBBS_BREAK)); <--- I hit this assert all the time

        // get old style
        SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi);

        rbbi.fStyle = (rbbi.fStyle & ~RBBS_BREAK) | (pbs->fStyle & RBBS_BREAK);
        rbbi.cx = pbs->cx;

        SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM)&rbbi);
    }


    if ( pbid->dwModeFlags & DBIMF_BREAK )
    {
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            // in theater mode we don't allow bands to have breaks
            if ((rbbi.fStyle & RBBS_BREAK ) && _fTheater)
            {
                rbbi.fStyle &= ~RBBS_BREAK;
                SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            }
        }
    }

    SendMessage(_bs._hwnd, RB_SHOWBAND, i, pbid->fShow);
}


HRESULT CInternetToolbar::_GetPersistedBand(const CLSID clsid, REFIID riid, void ** ppiface)
{
    HRESULT hr  = E_FAIL;
    TCHAR szStreamName[MAX_PATH];

    if (SUCCEEDED(_GetStreamName(_fInitialPidlIsWeb, szStreamName, ARRAYSIZE(szStreamName))))
    {
        static BOOL fBrowserOnly = (WhichPlatform() != PLATFORM_INTEGRATED);
        TCHAR szKey[MAX_PATH];
        TCHAR szGUID[MAX_PATH];

        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\%s"), szStreamName);
        SHStringFromGUID(clsid, szGUID, ARRAYSIZE(szGUID));

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, szKey, szGUID, NULL, NULL, NULL))
        {
            // Was the stream saved by an Integrated shell and we are in browser only mode?
            if ((_cs.fSaveInShellIntegrationMode) && fBrowserOnly)
            {
                // Yes, so we need to ignore the stream.
            }
            else
            {
                IStream * pstm = GetRegStream(_fInitialPidlIsWeb, szGUID, STGM_READ);
                if (pstm)
                {
                    hr = _bs.LoadFromStreamBS(pstm, riid, ppiface);
                    pstm->Release();
                }
            }
        }
    }

    if (FAILED(hr))
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, riid, ppiface);
        if (SUCCEEDED(hr))
        {
            IPersistStreamInit * ppsi;
            ((IUnknown *) *ppiface)->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &ppsi));
            if (ppsi)
            {
                ppsi->InitNew();
                ppsi->Release();
            }
        }
    }

    return hr;
}


HRESULT CInternetToolbar::_ShowExternalBand( PBANDSAVE pbs, int idBand )
{
    HRESULT hr;
    if (IS_EXTERNALBAND(idBand))
    {
        int idBandExt = MAP_TO_EXTERNAL(idBand);

        if (!IsEqualCLSID(_rgebi[idBandExt].clsid, GUID_NULL))
        {
            LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID( idBand );
            BOOL fIsVisible = _nVisibleBands & EXTERNALBAND_VBF_BIT(idBandExt);
            if (!pbid && fIsVisible)
            {
                IDeskBand *pitbBand;
                hr = _GetPersistedBand(_rgebi[idBandExt].clsid, IID_PPV_ARG(IDeskBand, &pitbBand));
                if (SUCCEEDED(hr))
                {
                    pbid = _AddNewBand( pitbBand, idBand );
                    pitbBand->Release();
                }
                if (!pbid)
                    return E_OUTOFMEMORY;
            }
            else
            {
                pbs = NULL;
                if (!pbid)
                    return S_OK;
            }
            _ShowBandCommon(pbs, pbid, fIsVisible );
        }
    }
    return S_OK;
}


HRESULT CInternetToolbar::_ShowAddressBand(PBANDSAVE pbs)
{
    HRESULT         hr  = S_OK;
    LPBANDITEMDATA  pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
    if (!pbid)
    {
       if (_nVisibleBands & VBF_ADDRESS)
       {
            IDeskBand *pitbAddressBand;

            hr = _GetPersistedBand(CLSID_AddressBand, IID_PPV_ARG(IDeskBand, &pitbAddressBand));
            if (SUCCEEDED(hr))
            {
                pbid = _AddNewBand(pitbAddressBand, CBIDX_ADDRESS);
                if (pbid)
                {
                    _hwndAddressBand = pbid->hwnd;

                    if (!pbs)
                    {
                        for (int i = 0; i < CBANDSMAX; i++)
                        {
                            if (_cs.bs[i].wID == CBIDX_ADDRESS)
                            {
                                pbs = _cs.bs + i;
                                break;
                            }
                        }
                    }
                }

                pitbAddressBand->Release();
            }
        }
        else
        {
            return S_OK;
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;


    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_ADDRESS);
    return S_OK;
}

LPBANDITEMDATA CInternetToolbar::_AddNewBand(IDeskBand* pdb, DWORD dwID)
{
    if (SUCCEEDED(_bs._AddBandByID(pdb, dwID)))
    {
        return _bs._GetBandItemDataStructByID(dwID);
    }
    return NULL;
}


HRESULT CInternetToolbar::_ShowLinks(PBANDSAVE pbs)
{
    HRESULT hr = S_OK;

    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_LINKS);
    if (!pbid)
    {
        IDeskBand* pdbLinks = NULL;

        // Check if custom link band GUID is present in the registry,
        // and if so, do a full CoCreateInstance using this GUID.
        // Otherwise, just do the normal internal call to the link's band factory.

        if (_nVisibleBands & VBF_LINKS)
        {
            if (!_fInitialPidlIsWeb ||
                FAILED(CreateFromRegKey(c_szRegKeyCoolbar, TEXT("QuickLinksCLSID"), IID_PPV_ARG(IDeskBand, &pdbLinks))))
            {
                hr = _GetPersistedBand(CLSID_QuickLinks, IID_PPV_ARG(IDeskBand, &pdbLinks));
                IUnknown_Exec(pdbLinks, &CLSID_QuickLinks, QLCMD_SINGLELINE, 1, NULL, NULL);
            }
        }
        else
        {
            return S_OK;
        }

        if (pdbLinks)
        {
            // mark it so ISFBand knows it's qlinks (for UAssist)
            VARIANTARG v;
#ifdef DEBUG
            {
                // n.b. we overwrite old persisted guys (which should be -1)
                IUnknown_Exec(pdbLinks, &CGID_ISFBand, ISFBID_PRIVATEID, 0, NULL, &v);
                ASSERT(v.lVal == -1 || v.lVal == CSIDL_FAVORITES);
            }
#endif
            v.vt = VT_I4;
            v.lVal = CSIDL_FAVORITES;   // close enough for our purposes...
            IUnknown_Exec(pdbLinks, &CGID_ISFBand, ISFBID_PRIVATEID, 0, &v, NULL);
            pbid = _AddNewBand(pdbLinks, CBIDX_LINKS);

            if (pbid && !pbs)
            {
                for (int i = 0; i < CBANDSMAX; i++)
                {
                    if (_cs.bs[i].wID == CBIDX_LINKS)
                    {
                        pbs = _cs.bs + i;
                        break;
                    }
                }
            }

            pdbLinks->Release();
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;

    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_LINKS);


    return hr;
}

HRESULT CInternetToolbar::_ShowMenu(PBANDSAVE pbs)
{
    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_MENU);
    if (!pbid)
    {
        CFavoritesCallback* pfcb = new CFavoritesCallback();
        if (pfcb)
        {
            IShellMenu* psm;
            if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &psm))))
            {
                VARIANTARG var;

                if (SUCCEEDED(IUnknown_Exec(_pbs2, &CGID_Explorer, SBCMDID_GETCURRENTMENU, 0, NULL, &var)) &&
                        var.vt == VT_INT_PTR && var.byref)
                {
                    IDeskBand* pdbMenu;
                    if (SUCCEEDED(psm->Initialize(pfcb, -1, ANCESTORDEFAULT, SMINIT_HORIZONTAL | SMINIT_TOPLEVEL)) &&
                        SUCCEEDED(psm->SetMenu((HMENU)var.byref, GetParent(_hwnd), SMSET_DONTOWN)) &&
                        SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdbMenu))))
                    {
                        pbid = _AddNewBand(pdbMenu, CBIDX_MENU);
                        if (pbid)
                        {
                            // Tell the menuband we're not a real bar/bandsite/band
                            IUnknown_Exec(pbid->pdb, &CGID_MenuBand, MBANDCID_NOTAREALSITE, TRUE, NULL, NULL);

                            _bs.SetBandState(CBIDX_MENU, BSSF_NOTITLE, BSSF_NOTITLE);
                            _hwndMenu = pbid->hwnd;
                        }

                        pdbMenu->Release();
                    }
                }
                psm->Release();
            }
            pfcb->Release();
        }

        if (!pbid)
            return E_OUTOFMEMORY;
    }
    else
        pbs = NULL;


    _ShowBandCommon(pbs, pbid, _nVisibleBands & VBF_MENU);
    return S_OK;
}

HBITMAP CInternetToolbar::_LoadBackBitmap()
{
    if (SHIsLowMemoryMachine(ILMM_IE4))
        return NULL;

    if (_fInitialPidlIsWeb)
    {
        static LPTSTR s_pszBitmapInternet = NULL;
        return LoadToolbarBackBmp(&s_pszBitmapInternet, &s_bmpBackInternet, _fInitialPidlIsWeb);
    }
    else
    {
        static LPTSTR s_pszBitmapShell = NULL;
        return LoadToolbarBackBmp(&s_pszBitmapShell, &s_bmpBackShell, _fInitialPidlIsWeb);
    }
}

void CInternetToolbar::_SetBackground()
{
    REBARBANDINFO   rbbi;
    HBITMAP         hbmp;

    // Theater mode doesn't allow bitmap customization, so don't bother loading one from the cache
    if (_fTheater)
        hbmp = NULL;
    else
        hbmp = _LoadBackBitmap();

    // don't bother updating the bkcolor if we know we'll just set it to CLR_NONE below (otherwise rebar invalidates)
    if (!hbmp)
        SendMessage(_bs._hwnd, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));

    // If we think we have a bitmap, or the cache thinks we have a bitmap, we have some work to do
    if (_bmpBack || hbmp)
    {
        BOOL fRemove = (NULL!=_bmpBack && NULL==hbmp);

        if (hbmp)
            SendMessage(_bs._hwnd, RB_SETBKCOLOR, 0, (LPARAM)CLR_NONE);
        _bmpBack = hbmp;

        rbbi.cbSize = sizeof(REBARBANDINFO);

        INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

        INT icBands = (INT) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
        for (int i = 0; i < icBands; i++)
        {
            rbbi.fMask = RBBIM_ID | RBBIM_CHILD | RBBIM_BACKGROUND;
            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
            {
                if (rbbi.wID != CBIDX_BRAND && rbbi.hbmBack != hbmp)
                {
                    rbbi.fMask = RBBIM_BACKGROUND;
                    rbbi.hbmBack = hbmp;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                    InvalidateRect(rbbi.hwndChild, NULL, TRUE);
                }
            }
        }
        SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);

        // When removing the background bitmap, we need to invalidate *outside*
        // of the WM_SETREDRAW so we actually erase the background properly
        //
        if (fRemove)
            InvalidateRect(_bs._hwnd, NULL, TRUE);

    }
}


HRESULT CInternetToolbar::_ShowBrand(PBANDSAVE pbs)
{
    REBARBANDINFO       rbbi;
    LPBANDITEMDATA      pbid;
    INT_PTR             i;
    HRESULT             hr = S_OK;
    BOOL                fCreated = FALSE;

    pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
    if (!pbid)
    {
        IDeskBand *pdbBrandBand;
        hr = CBrandBand_CreateInstance(NULL, (IUnknown **)&pdbBrandBand, NULL);
        if (SUCCEEDED(hr))
        {
            pbid = _AddNewBand(pdbBrandBand, CBIDX_BRAND);
            fCreated = TRUE;
            pdbBrandBand->Release();
        }
        else
            return hr;
    }

    if (!pbid)
        return E_OUTOFMEMORY;

    pbid->pdb->ShowDW(TRUE);

    i = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);
    if (fCreated)
    {
        // add these to ::IDeskBand::GetBandInfo()
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_STYLE;
        rbbi.fStyle = RBBS_FIXEDSIZE | RBBS_VARIABLEHEIGHT;

        if (pbs)
        {
            rbbi.fMask |= RBBIM_SIZE;
            rbbi.fStyle |= pbs->fStyle;
            rbbi.cx = pbs->cx;
        }
        SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM)&rbbi);
        // this can cause the band to move because a fixed size band
        // is forced in a particular location.
        // so we need to re-fetch the index
        i = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);
    }
    SendMessage(_bs._hwnd, RB_SHOWBAND, i, _nVisibleBands & VBF_BRAND);
    return S_OK;
}

void CInternetToolbar::_EnsureAllBandsShown()
{
    if (_hwnd)
    {
        INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

        _ShowMenu(NULL);
        _ShowTools(NULL);
        _ShowAddressBand(NULL);
        _ShowLinks(NULL);
        _ShowBrand(NULL);
        for (int i = CBIDX_EXTERNALFIRST; i <= CBIDX_EXTERNALLAST; i++)
        {
            _ShowExternalBand( NULL, i );
        }

        _SetBackground();
        _bs._SetMinDimensions();
        _UpdateLocking();
        
        SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
    }
}

BOOL CInternetToolbar::_ShowBands(UINT fVisible)
{
    fVisible &= VBF_VALID;

    if (fVisible == _nVisibleBands)
        return(TRUE);

    _nVisibleBands = fVisible;
    _EnsureAllBandsShown();
    ShowDW(_fShow);

    return(TRUE);
}

HRESULT CInternetToolbar::_CreateBands()
{
    HRESULT hr = S_OK;

    if (!_hwnd && _ptbsite)
    {
        HWND hwndParent;

        hr = _ptbsite->GetWindow(&hwndParent);
        if (SUCCEEDED(hr))
        {
            TCHAR szScratch[16];
            int i;

            // Check if coolbar layout had already been loaded from the registry
            if(_cs.cbVer != CBS_VERSION)
            {
                TraceMsg(DM_ITBAR, "CInternetToolbar::_CreateBands failed. Bad Version");
                ASSERT(0);

                return(S_FALSE);
            }

            _nVisibleBands = _cs.uiVisible;

            _InitComCtl32();    // don't check result, if this fails our CreateWindows will fail

            MLLoadString(IDS_WEB_TB_TEXTROWS, szScratch, ARRAYSIZE(szScratch));
            _uiTBTextRows = _uiTBDefaultTextRows = StrToInt(szScratch);

            _fCompressed = (_cs.fNoText != FALSE);

            _hwnd = SHCreateWorkerWindow(SizableWndProc, hwndParent, 0, WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                       (HMENU)FCIDM_REBAR, this);

            if (!IS_VALID_HANDLE(_hwnd, WND))
            {
                _fDontSave = TRUE;
                TraceMsg(TF_ERROR, "CInternetToolbar::_CreateBands() - _hwnd failed");
                return E_OUTOFMEMORY;
            }

            // delay until now
            // this sets up the parent child chain so that these children can
            // queryservice through us
            hr = SetClient(SAFECAST(&_bs, IInputObjectSite*));
            if (SUCCEEDED(hr))
            {
                INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);

                for (i = 0; i < CBANDSMAX; i++)
                {
                    hr = S_OK;
                    switch (_cs.bs[i].wID)
                    {
                    case CBIDX_TOOLS:
                        if(!SHRestricted2W(REST_NoToolBar, NULL, 0))
                        {
                            hr = _ShowTools(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_TOOLS;
                        }
                        break;

                    case CBIDX_ADDRESS:
                        if(!SHRestricted2W(REST_NoAddressBar, NULL, 0))
                        {
                            hr = _ShowAddressBand(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_ADDRESS;
                        }
                        break;

                    case CBIDX_LINKS:
                        if(!SHRestricted2W(REST_NoLinksBar, NULL, 0))
                        {
                            hr = _ShowLinks(_cs.bs + i);
                        }
                        else
                        {
                            _nVisibleBands &= ~VBF_LINKS;
                        }
                        break;

                    case CBIDX_BRAND:
                        hr = _ShowBrand(_cs.bs + i);
                        break;

                    case CBIDX_MENU:
                        hr = _ShowMenu(_cs.bs + i);
                        break;

                    // If there is no id associated, there's nothing more to restore.
                    case 0:
                    {
                        // Out of bands; stop loop.
                        i = CBANDSMAX;
                        break;
                    }

                    default:
                        if (IS_EXTERNALBAND(_cs.bs[i].wID))
                        {
                            for (DWORD j = 0; j < MAXEXTERNALBANDS; j++)
                            {
                                if (_cs.aclsidExternalBands[MAP_TO_EXTERNAL(_cs.bs[i].wID)] == _rgebi[j].clsid)
                                {
                                    CLSID clsidTemp = _rgebi[j].clsid;
                                    _rgebi[j].clsid = _rgebi[MAP_TO_EXTERNAL(_cs.bs[i].wID)].clsid;
                                    _rgebi[MAP_TO_EXTERNAL(_cs.bs[i].wID)].clsid = clsidTemp;
                                    hr = _ShowExternalBand(_cs.bs + i, _cs.bs[i].wID);
                                    break;
                                }
                            }
                        }
                        break;
                    }

                    if (hr != S_OK)
                    {
                        TraceMsg(TF_ERROR, "CInternetToolbar::_CreateBands -- band ID %x creation failed", _cs.bs[i].wID);

                        // if band creation failed, we still go ahead and open the browser and do our normal stuff --
                        // including persisting the band state.
                        // unfortunately for the user who opens too many windows, they hit GDI limits and we can't
                        // create the bands and we fail, and then persist out that state.  so all future windows
                        // are broken without the file menu etc. and the user cant get out.
                        _fDontSave = TRUE;
                    }
                }

                _SetBackground();
                _bs._SetMinDimensions();
                _UpdateLocking();

                SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
            }
        }
    }
    return hr;
}

HRESULT CInternetToolbar::ShowDW(BOOL fShow)
{
    if ((g_dwProfileCAP & 0x00000008) && s_imlTBGlyphs.arhiml[0])
    {
        StartCAP();
    }

    HRESULT hres = _CreateBands();
    if (FAILED(hres))
        return hres;

    if (!_nVisibleBands && fShow)
        return(FALSE);

    _fShow = fShow;

    _bs.UIActivateDBC(fShow ? DBC_SHOW : DBC_HIDE);

    ResizeBorderDW(NULL, NULL, FALSE);
    ShowWindow(_hwnd, fShow ? SW_SHOW : SW_HIDE);


    BOOL fConnect = (fShow && _dwcpCookie == 0);
    if (fConnect || (!fShow && _dwcpCookie != 0))
    {
        ConnectToConnectionPoint(SAFECAST(this, IDockingWindow*), DIID_DWebBrowserEvents2, fConnect, _pdie, &_dwcpCookie, NULL);
    }

    return hres;
}

int ITBar_TrackPopupMenuEx(HMENU hmenu, UINT uFlags, int x, int y, HWND hwnd, LPRECT prcExclude)
{
    TPMPARAMS tpm;
    if (prcExclude)
    {
        tpm.cbSize = sizeof(TPMPARAMS);
        CopyRect(&tpm.rcExclude, prcExclude);
    }
    return TrackPopupMenuEx(hmenu, uFlags, x, y, hwnd, prcExclude ? &tpm : NULL);
}

/*******************************************************************

NAME:       CInternetToolbar::_ShowBackForwardMenu

SYNOPSIS:
NOTES:
********************************************************************/
BOOL CInternetToolbar::_ShowBackForwardMenu(BOOL fForward, POINT pt, LPRECT prcExclude)
{
    BOOL fRet = FALSE;
    HMENU hmenuBF = CreatePopupMenu();
    if (hmenuBF)
    {
        ASSERT(_pbs2);
        ITravelLog *ptl;

        _pbs2->GetTravelLog(&ptl);
        if (NULL != ptl)
        {
            HRESULT hr;

            hr = ptl->InsertMenuEntries(_pbs2, hmenuBF, 0, 1, MAX_NAV_MENUITEMS, fForward ? TLMENUF_FORE : TLMENUF_BACK);
            if (S_OK == hr)
            {
                OLECMD cmd;

                cmd.cmdID = SBCMDID_HISTORYBAR;
                cmd.cmdf  = 0;

                ASSERT(NULL != _ptbsitect);
                _ptbsitect->QueryStatus(&CGID_Explorer, 1, &cmd, NULL);

                if (((cmd.cmdf & OLECMDF_ENABLED) && !(cmd.cmdf & OLECMDF_LATCHED)) &&
                    (1 /* MAX_NAV_MENUITEMS */ < ptl->CountEntries(_pbs2)))
                {
                    static TCHAR s_szMenuText[MAX_PATH];
                    static int   s_iMenuIcon = -1;

                    if (TEXT('\0') == s_szMenuText[0])
                    {
                        MLLoadString(IDS_MI_BACK_HISTORY, s_szMenuText, ARRAYSIZE(s_szMenuText));
                        ASSERT(TEXT('\0') != s_szMenuText[0]);
                    }

                    if (-1 == s_iMenuIcon)
                    {
                        IShellFolder  *psfParent;
                        LPITEMIDLIST  pidlHistory;
                        LPCITEMIDLIST pidlItem;

                        psfParent   = NULL;
                        pidlHistory = NULL;
                        pidlItem    = NULL;

                        SHGetSpecialFolderLocation(NULL, CSIDL_HISTORY, &pidlHistory);
                        if (NULL != pidlHistory)
                        {
                            SHBindToIDListParent(pidlHistory, IID_PPV_ARG(IShellFolder, &psfParent), &pidlItem);
                            if (NULL != psfParent)
                            {
                                ASSERT(NULL != pidlItem);

                                hr = SHMapPIDLToSystemImageListIndex(psfParent, pidlItem, &s_iMenuIcon);
                                if (FAILED(hr))
                                    s_iMenuIcon = -1;

                                psfParent->Release();
                            }

                            ILFree(pidlHistory);
                        }
                    }

                    ULONG_PTR rgpData[2];

                    rgpData[0] = (ULONG_PTR)s_szMenuText;
                    rgpData[1] = s_iMenuIcon;

                    AppendMenu(hmenuBF, MF_SEPARATOR, -1, NULL);
                    AppendMenu(hmenuBF, MF_OWNERDRAW, FCIDM_VBBHISTORYBAND, (PCTSTR)rgpData);
                }

                // If any menu items were added, show the menu and navigate to it
#ifndef MAINWIN
                int nIndex;

                if (nIndex = ITBar_TrackPopupMenuEx (hmenuBF, TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD, pt.x, pt.y, _hwnd, prcExclude))
#else
                    // Because mainwin doesn't support win95 look and feel we are
                    // having a problem to keep the popup from dismissing when we
                    // pass NULL as noDismissal area.
                    RECT rect;
                    GetWindowRect( _hwnd, &rect );
                    if (nIndex = (int)TrackPopupMenu (hmenuBF,
                        TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                        pt.x, pt.y, 0, _hwnd,
                        &rect))
#endif
                {
                    if (FCIDM_VBBHISTORYBAND != nIndex)
                    {
                        ptl->Travel(_pbs2, (fForward ? nIndex : -nIndex));
                    }
                    else
                    {
                        VARIANTARG varOn;

                        varOn.vt   = VT_I4;
                        varOn.lVal = 1;

                        _ptbsitect->Exec(&CGID_Explorer, SBCMDID_HISTORYBAR, OLECMDEXECOPT_DONTPROMPTUSER, &varOn, NULL);
                    }
                }
            }

            ptl->Release();
        }

        DestroyMenu (hmenuBF);
    }

    return fRet;
}

// get per folder search items and default search
BOOL CInternetToolbar::_GetFolderSearchData()
{
    int iInserted=0;

    if (_pbs2)
    {
        LPCBASEBROWSERDATA pbbd;

        if (SUCCEEDED(_pbs2->GetBaseBrowserData(&pbbd)) && (pbbd->_psfPending || pbbd->_psf))
        {
            IShellFolder2 * psf2;
            IShellFolder*   psf = pbbd->_psfPending ? pbbd->_psfPending : pbbd->_psf;

            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                LPENUMEXTRASEARCH penum;
                GUID              guid;

                if (SUCCEEDED(psf2->GetDefaultSearchGUID(&guid)))
                    _guidDefaultSearch = guid;

                // get per folder search items
                if (_hdpaFSI && SUCCEEDED(psf2->EnumSearches(&penum)))
                {
                    EXTRASEARCH  xs;

                    while(penum->Next(1, &xs, NULL) == S_OK)
                    {
                        LPFOLDERSEARCHITEM pfsi = (LPFOLDERSEARCHITEM)LocalAlloc(LPTR, sizeof(FOLDERSEARCHITEM));
                        if (pfsi)
                        {
                            pfsi->idCmd = -1;
                            pfsi->guidSearch = xs.guidSearch;
                            StrCpyNW(pfsi->wszUrl, xs.wszUrl, ARRAYSIZE(pfsi->wszUrl));
                            StrCpyNW(pfsi->wszName, xs.wszFriendlyName, ARRAYSIZE(pfsi->wszName));

                            if (DPA_InsertPtr(_hdpaFSI, iInserted, pfsi) != -1)
                                iInserted++;
                            else
                                LocalFree(pfsi);
                        }
                    }
                    penum->Release();
                }
                psf2->Release();
            }
        }
    }

    return (iInserted > 0);
}

BOOL NavigateSearchBar(IWebBrowser2 *pwb2, LPCWSTR pwszUrl)
{
    BOOL bRet  = FALSE;

    SA_BSTRGUID bstr;
    InitFakeBSTR(&bstr, CLSID_SearchBand);

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = bstr.wsz;

    // show a search bar
    VARIANT varEmpty = {0};
    if (SUCCEEDED(pwb2->ShowBrowserBar(&var, &varEmpty, &varEmpty)))
    {
        VARIANT varTargetFrame = {0};
        VARIANT varFlags = {0};

        StrCpyNW(bstr.wsz, pwszUrl, ARRAYSIZE(bstr.wsz));
        bstr.cb = lstrlenW(bstr.wsz) * sizeof(WCHAR);

        varFlags.vt = VT_I4;
        varFlags.lVal = navBrowserBar;

        var.vt = VT_BSTR;
        var.bstrVal = bstr.wsz;

        // navigate the search bar to the correct url
        if (SUCCEEDED(pwb2->Navigate2(&var, &varFlags, &varTargetFrame, &varEmpty, &varEmpty)))
            bRet = TRUE;
    }

    return bRet;
}

void RestrictItbarViewMenu(HMENU hmenu, IUnknown *punkBar )
{
    BOOL fIsRestricted = SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0);
    if (fIsRestricted)
    {
        _EnableMenuItem(hmenu, FCIDM_VIEWLINKS, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWMENU, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWADDRESS, FALSE);
        _EnableMenuItem(hmenu, FCIDM_VIEWTOOLS, FALSE);
    }

    for (int i = 0; i < MAXEXTERNALBANDS; i++)
    {
        OLECMD cmd = { CITIDM_VIEWEXTERNALBAND_FIRST + i, 0 };
        OLECMDTEXTV<MAX_EXTERNAL_BAND_NAME_LEN> cmdtv;
        OLECMDTEXT *pcmdText = &cmdtv;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->cwActual = 0;
        pcmdText->cwBuf = MAX_EXTERNAL_BAND_NAME_LEN;

        IUnknown_QueryStatus( punkBar, &CGID_PrivCITCommands, 1, &cmd, pcmdText );
        if (cmd.cmdf & OLECMDF_SUPPORTED)
        {
            DWORD dwMenuCommand = FCIDM_EXTERNALBANDS_FIRST + i;
            InsertMenu( hmenu, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND, dwMenuCommand, pcmdText->rgwz );
            if (cmd.cmdf & OLECMDF_ENABLED)
            {
                _CheckMenuItem( hmenu, dwMenuCommand, TRUE );
            }
            if (fIsRestricted)
            {
                _EnableMenuItem( hmenu, dwMenuCommand, FALSE );
            }
        }
    }
}

void CInternetToolbar::_ShowContextMenu(HWND hwnd, LPARAM lParam, LPRECT prcExclude)
{
    // Bail if this context menu doesn't correspond to a band (fixes NT5 #181899)
    POINT pt;
    int iIndex = _bs._ContextMenuHittest(lParam, &pt);
    int idBandActive = _bs._IndexToBandID(iIndex);
    if (!InRange(idBandActive, CBIDX_FIRST, CBANDSMAX))
        return;

    // Bail if we can't find the resource
    HMENU hmenuITB = LoadMenuPopup(MENU_ITOOLBAR);
    if (!hmenuITB)
        return;

    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, idBandActive == -1 ? UIBL_CTXTITBBKGND : UIBL_CTXTITBITEM);

    // Set the initial state of the menu
    _CheckMenuItem (hmenuITB, FCIDM_VIEWTOOLS, _nVisibleBands & VBF_TOOLS);
    _CheckMenuItem (hmenuITB, FCIDM_VIEWADDRESS, _nVisibleBands & VBF_ADDRESS);
    _CheckMenuItem (hmenuITB, FCIDM_VIEWLINKS, _nVisibleBands & VBF_LINKS);
    
    int cItemsBelowSep = 4;

    // only in theater mode can we autohide
    if (!_fTheater)
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWAUTOHIDE, MF_BYCOMMAND);
        cItemsBelowSep--;
        if (_nVisibleBands & VBF_MENU || _fNoShowMenu)
            DeleteMenu(hmenuITB, FCIDM_VIEWMENU, MF_BYCOMMAND);
    }
    else
    {
        if (_fNoShowMenu)
            DeleteMenu(hmenuITB, FCIDM_VIEWMENU, MF_BYCOMMAND);
        DeleteMenu(hmenuITB, FCIDM_VIEWTOOLS, MF_BYCOMMAND);
        _CheckMenuItem (hmenuITB, FCIDM_VIEWAUTOHIDE, _fAutoHide);
        _CheckMenuItem (hmenuITB, FCIDM_VIEWMENU, _nVisibleBands & VBF_MENU);

    }

    if (_fTheater || SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
    {
        // No lock in theater mode or Windows Explorer
        DeleteMenu(hmenuITB, FCIDM_VIEWLOCKTOOLBAR, MF_BYCOMMAND);
    }
    else
    {
        _CheckMenuItem(hmenuITB, FCIDM_VIEWLOCKTOOLBAR, _fLockedToolbar);
    }

    // if it was done via the keyboard, but focus wasn't on the tools band,
    // then don't have customize menu option
    // or if click didn't happen on the band
    if (!(_btb._fCustomize && idBandActive == CBIDX_TOOLS))
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWTOOLBARCUSTOMIZE, MF_BYCOMMAND);
        cItemsBelowSep--;
    }

    BOOL fGoButtonAvailable =
        WasOpenedAsBrowser(static_cast<IExplorerToolbar *>(this)) || (GetUIVersion() >= 5);

    // Only show the go button item when you click on the address bar
    if (idBandActive != CBIDX_ADDRESS || !fGoButtonAvailable)
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWGOBUTTON, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    else
    {
        BOOL fShowGoButton = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                                TEXT("ShowGoButton"), FALSE, /*default*/TRUE);
        _CheckMenuItem(hmenuITB, FCIDM_VIEWGOBUTTON, fShowGoButton);
    }

    if (_fTheater || _btb._fCustomize || SHRestricted2(REST_LOCKICONSIZE, NULL, 0))
    {
        DeleteMenu(hmenuITB, FCIDM_VIEWTEXTLABELS, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    else
    {
        // If customize is unavailable, then there's no way for the user to
        // turn list style on/off.  In this case we want toggling text labels
        // to work the way it did in IE4 -- that is, switch between "text on
        // all buttons" and "text on no buttons".  So, if we're in "selective
        // text on right" mode, we say that labels are turned off.  If the user
        // picks this menu option, we'll go into "text on all buttons" mode.

        BOOL fChecked = !_fCompressed && !IS_LIST_STYLE(_btb._hwnd);
        _CheckMenuItem(hmenuITB, FCIDM_VIEWTEXTLABELS, fChecked);
    }

    if (!cItemsBelowSep)
        DeleteMenu(hmenuITB, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND);

    RestrictItbarViewMenu(hmenuITB, SAFECAST( this, IOleCommandTarget* ) );
    ITBar_TrackPopupMenuEx(hmenuITB, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, pt.x, pt.y, _hwnd, prcExclude);

    // HACK: since the ITBar isn't a real bar/bandsite, we have to
    // do this so any menuband that might be up can take back the
    // mouse capture.
    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_MENU);
    if (pbid)
        IUnknown_Exec(pbid->pdb, &CGID_MenuBand, MBANDCID_RECAPTURE, 0, NULL, NULL);

    DestroyMenu (hmenuITB);
}


void CInternetToolbar::_QueryStatusTip(IOleCommandTarget *pct, LPTOOLTIPTEXT pnmTT, UINT uiCmd, const GUID* pguid)
{
    OLECMD rgcmd = { uiCmd, 0 };
    OLECMDTEXTV<MAX_TOOLTIP_STRING> cmdtv;
    OLECMDTEXT *pcmdText = &cmdtv;

    pcmdText->cwBuf = MAX_TOOLTIP_STRING;
    pcmdText->cmdtextf = OLECMDTEXTF_NAME;
    pcmdText->rgwz[0] = 0;
    pct->QueryStatus(pguid, 1, &rgcmd, pcmdText);
    if (rgcmd.cmdf & OLECMDF_ENABLED)
    {
        SHUnicodeToTChar(pcmdText->rgwz, pnmTT->szText, MAX_TOOLTIP_STRING);
    }

}

BOOL _IsDocHostGUID(const GUID* pguid)
{
    // Dochost merges under one of two clsids, so have to check both
    BOOL fRet = IsEqualGUID(*pguid, CLSID_InternetButtons) ||
                IsEqualGUID(*pguid, CLSID_MSOButtons);
    return fRet;
}

void _PruneAmpersands(LPTSTR psz)
{
    //
    // Collapse double ampersands in the string to single
    // ampersands, and rip out single ampersands.  e.g.,
    //
    //  "AT&T" -> "ATT"
    //  "AT&&T" -> "AT&T"
    //
    // We need to do this to hack around the ToolTips control's
    // annoying prefix behavior.  When TTS_NOPREFIX is set
    // (which is true of itbar's), TT leaves prefix characters
    // alone completely.  However when it is not set, besides just
    // letting DrawText do it's prefix thing on the string, TT also
    // pre-processes the string using an analogous version of the
    // below function, collapsing double ampersands to single
    // ampersands and ripping out single ampersands.  This is so
    // that that if you use menu text (e.g. "&File") as a tooltip,
    // you won't get an underline.  Unfortunately, the side effect
    // is that you're in trouble if you really wanted an ampersand in
    // the title (e.g. "AT&&T"), since the preprocessing turns "AT&&T"
    // into "AT&T", which DrawText then renders with an underline.
    //
    // Thus we have to leave TTS_NOPREFIX set and mimic the DrawText
    // preprocessing ourselves.
    //

    if (psz)
    {
        LPTSTR pszOut = psz;
        BOOL fLastAmpSkipped = FALSE;

        while (*psz)
        {
            if (*psz == TEXT('&'))
            {
                if (fLastAmpSkipped)
                {
                    fLastAmpSkipped = FALSE;
                    *pszOut++ = *psz;
                }
                else
                {
                    fLastAmpSkipped = TRUE;
                }
            }
            else
            {
                *pszOut++ = *psz;
            }

            psz++;
        }

        *pszOut = TEXT('\0');
    }
}

void CInternetToolbar::_OnTooltipNeeded(LPTOOLTIPTEXT pnmTT)
{
    UINT uiCmd;
    GUID guid;

    ASSERT(pnmTT->hdr.hwndFrom == (HWND)SendMessage(_btb._hwnd, TB_GETTOOLTIPS, 0, 0));

    // Make sure tooltips don't filter out ampersands
    LONG lStyle = GetWindowLong(pnmTT->hdr.hwndFrom, GWL_STYLE);
    if (!IsFlagSet(lStyle, TTS_NOPREFIX))
    {
        SetWindowLong(pnmTT->hdr.hwndFrom, GWL_STYLE, lStyle | TTS_NOPREFIX);
    }


    if (SUCCEEDED(_btb._ConvertCmd(NULL, (UINT)pnmTT->hdr.idFrom, &guid, &uiCmd)))
    {
        if (IsEqualGUID(guid, CLSID_CommonButtons))
        {
            switch (uiCmd)
            {
            case TBIDM_FORWARD:
            case TBIDM_BACK:
                if (_ptbsite)
                {
                    IBrowserService *pbsvc;

                    if (SUCCEEDED(_ptbsite->QueryInterface(IID_PPV_ARG(IBrowserService, &pbsvc))))
                    {
                        // FEATURE raymondc - make ITravelLog UNICODE someday
                        ITravelLog *ptl;
                        pbsvc->GetTravelLog( &ptl );
                        if (ptl)
                        {
                            WCHAR szTemp[ARRAYSIZE(pnmTT->szText)];
                            if (uiCmd == TBIDM_BACK)
                                ptl->GetToolTipText(pbsvc, TLOG_BACK, 0, szTemp, ARRAYSIZE(szTemp));
                            else if (uiCmd == TBIDM_FORWARD)
                                ptl->GetToolTipText(pbsvc, TLOG_FORE, 0, szTemp, ARRAYSIZE(szTemp));

                            SHUnicodeToTChar(szTemp, pnmTT->szText, ARRAYSIZE(pnmTT->szText));

                            ptl->Release();
                        }
                        pbsvc->Release();
                    }
                }
            }
        }
#ifdef EDIT_HACK
        // Dochost merges under one of two clsids, so have to check both
        else if (_IsDocHostGUID(&guid))
        {
            if (uiCmd == DVIDM_EDITPAGE)
            {
                _aEditVerb.GetToolTip(pnmTT->szText, ARRAYSIZE(pnmTT->szText));
            }
            else
            {
                // If the button text is hidden or truncated, we use that text for the tooltip.
                TBBUTTONINFO tbbi = {0};
                tbbi.cbSize = sizeof(TBBUTTONINFO);
                tbbi.dwMask = TBIF_STYLE | TBIF_STATE;
                SendMessage(_btb._hwnd, TB_GETBUTTONINFO, pnmTT->hdr.idFrom, (LPARAM)&tbbi);

                if (_fCompressed || 
                    IS_LIST_STYLE(_btb._hwnd) && !(tbbi.fsStyle & BTNS_SHOWTEXT) ||
                    (tbbi.fsState & TBSTATE_ELLIPSES))
                {
                    //
                    // Get the button text and fix up the ampersands so that the
                    // tooltip will look right
                    //
                    if (SendMessage(_btb._hwnd, TB_GETBUTTONTEXT, pnmTT->hdr.idFrom, (LPARAM)&pnmTT->szText))
                    {
                        _PruneAmpersands(pnmTT->szText);
                    }
                }
            }
        }
#endif
    }
}

LRESULT CInternetToolbar::_OnBeginDrag(NMREBAR *pnm)
{
    if (SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0) || _fLockedToolbar)
    {
        return 1;
    }

    if (_fTheater)
    {
        // if we're in theater mode, we do our own drag handling where we force
        // all  the mouse moves into the middle of the band, thereby disallowing
        // the user to make a multi line rebar
        SetCapture(_hwnd);
        SendMessage(_bs._hwnd, RB_BEGINDRAG, pnm->uBand, (LPARAM)-2);
        _fRebarDragging = TRUE;
        return 1;
    }
    return SHRestricted2(REST_NoToolbarOptions, NULL, 0);
}

LRESULT CInternetToolbar::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;
    if (!_pdie)
        return 0;

    if (pnmh->code == TTN_NEEDTEXT  && pnmh->hwndFrom == (HWND)SendMessage(_btb._hwnd, TB_GETTOOLTIPS, 0, 0))
    {
        _OnTooltipNeeded((LPTOOLTIPTEXT)pnmh);
        return 0;
    }

    if(_SendToToolband(pnmh->hwndFrom, WM_NOTIFY,0, (LPARAM)pnmh, &lres))
        return lres;

    switch (pnmh->idFrom)
    {
    case FCIDM_REBAR:
        switch (pnmh->code)
        {
        case RBN_BEGINDRAG:
            return _OnBeginDrag((NMREBAR*)pnmh);

        case RBN_HEIGHTCHANGE:
            ResizeBorderDW(NULL, NULL, FALSE);
            break;

        case RBN_CHILDSIZE:
        {
            // make the brand always take the full height
            NMREBARCHILDSIZE *pnm = (NMREBARCHILDSIZE*)pnmh;
            if (pnm->wID == CBIDX_BRAND)
            {
                pnm->rcChild.top = pnm->rcBand.top;
                pnm->rcChild.bottom = pnm->rcBand.bottom;
            }
            break;
        }

        case RBN_LAYOUTCHANGED:
            //Because the layout has changed, remember to save later!
            _fDirty = TRUE;
            _UpdateBrandSize();

            if (_ptbsitect)
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
            break;

        case RBN_GETOBJECT:
        {
            NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnmh;
            if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
            {
                HWND hwnd;

                switch (pnmon->iItem)
                {
                case CBIDX_MENU:
                case CBIDX_LINKS:
                {
                     LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(pnmon->iItem);
                     if (pbid && pbid->pdb)
                     {
                        pnmon->hResult = pbid->pdb->QueryInterface(IID_IDropTarget, (void**)&pnmon->pObject);
                     }
                     break;
                }

                case CBIDX_TOOLS:
                    hwnd = _btb._hwnd;
                    pnmon->hResult = (HRESULT)SendMessage(hwnd, TB_GETOBJECT,
                                        (WPARAM)&IID_IDropTarget, (LPARAM)&pnmon->pObject);
                    break;

                case CBIDX_ADDRESS:
                    if (_ptbsite)
                    {
                        pnmon->hResult = _ptbsite->QueryInterface(IID_IDropTarget, (void**)&pnmon->pObject);
                    }
                    break;
                }
            }
            ASSERT((SUCCEEDED(pnmon->hResult) && pnmon->pObject) ? (IS_VALID_CODE_PTR(pnmon->pObject, IUnknown)) : (pnmon->pObject == NULL));
            return TRUE;
        }

        case RBN_CHEVRONPUSHED:
        {
            LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmh;
            if (pnmch->wID == CBIDX_TOOLS)
            {
                int idMenu = MENU_TBMENU;
                // this must be the tools band (not enumerated in bandsite)
                MapWindowPoints(pnmh->hwndFrom, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);
                if (!_btb._fCustomize)
                    idMenu = 0;

                ToolbarMenu_Popup(_hwnd, &pnmch->rc, NULL, _btb._hwnd, idMenu, (DWORD)pnmch->lParamNM);
                return TRUE;
            }
            _bs._OnNotify(pnmh);
            break;
        }

        default:
            return _bs._OnNotify(pnmh);

        } // switch (pnmh->code)
        break;

    } // switch (pnmh->idFrom)
    return 0;
}


/*******************************************************************

NAME:       CInternetToolbar::_DoNavigateA

SYNOPSIS:   Called when the user types in or selects a URL
to navigate to through the address bar

NOTES:      This function calls the helper function _DoNavigate.
This is just here to convert the ANSI string to
a BSTR.

********************************************************************/
HRESULT CInternetToolbar::_DoNavigateA(LPSTR pszURL, int iNewSelection)
{
    ASSERT(pszURL);    // must have valid URL to navigate to

    LBSTR::CString          strText;

    LPTSTR          pstrText = strText.GetBuffer( MAX_URL_STRING );

    if ( strText.GetAllocLength() < MAX_URL_STRING )
    {
        TraceMsg( TF_WARNING, "CInternetToolbar::_DoNavigateA() - strText Allocation Failed!" );

        return E_OUTOFMEMORY;
    }
    else
    {
        SHAnsiToUnicode( pszURL, pstrText, MAX_URL_STRING );

        strText.ReleaseBuffer();

        return _DoNavigate( strText, iNewSelection );
    }
}

/*******************************************************************

NAME:       CInternetToolbar::_DoNavigateW

SYNOPSIS:   Called when the user types in or selects a URL
to navigate to through the address bar

NOTES:      This function calls the helper function _DoNavigate.
This is just here to convert the Unicode string to
a BSTR.

********************************************************************/
HRESULT CInternetToolbar::_DoNavigateW(LPWSTR pwzURL, int iNewSelection)
{
    ASSERT(pwzURL);    // must have valid URL to navigate to

    LBSTR::CString          strPath( pwzURL );

    return _DoNavigate( strPath, iNewSelection );
}

/*******************************************************************

NAME:       CInternetToolbar::_DoNavigate

SYNOPSIS:   Called when the user types in or selects a URL
to navigate to through the address bar

ENTRY:      bstrURL - string of URL to navigate to, in BSTR form
iNewSelection - index of current selection in address
bar combo box

********************************************************************/
HRESULT CInternetToolbar::_DoNavigate(BSTR bstrURL,int iNewSelection)
{
    HRESULT hr;

    ASSERT(bstrURL); // must have valid URL to browse to
    ASSERT(_pdie);  // must have valid pointer to automation interface

    VARIANTARG v;
    VariantInit (&v);

    v.vt = VT_I4;
    v.lVal = navAllowAutosearch;

    // call automation interface to make browser navigate to this URL
    hr = _pdie->Navigate(bstrURL, &v, PVAREMPTY, PVAREMPTY, PVAREMPTY);

    VariantClearLazy(&v);

    return hr;
}

LPITEMIDLIST CInternetToolbar::_GetCurrentPidl(void)
{
    LPITEMIDLIST pidl = NULL;

    ASSERT(_pbs2);
    if (_pbs2)
    {
        _pbs2->GetPidl(&pidl);
    }

    return pidl;
}

void CInternetToolbar::_CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST* ppidl)
{
    // stuff that needs to be done tree or no tree
    switch (lEvent)
    {
        // README:
        // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
        // shbrowse.cpp in order to get the notifications
    case SHCNE_DRIVEREMOVED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_MEDIAINSERTED:
    case SHCNE_DRIVEADD:
    case SHCNE_UPDATEIMAGE:
    case SHCNE_UPDATEITEM:
        // Forward this command to CAddressBand::FileSysChange()
        // by using IToolbandHelper::OnWinEvent().
        {
            LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
            if (pbid)
            {
                // REVIEW: why don't we use IShellChangeNotify here?
                //
                IUnknown_FileSysChange(pbid->pdb, (DWORD)lEvent, (LPCITEMIDLIST*)ppidl);
            }
        }
        break;
    }
}

HRESULT CInternetToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST ppidl[2] = {(LPITEMIDLIST)pidl1, (LPITEMIDLIST)pidl2};
    _CommonHandleFileSysChange(lEvent, ppidl);

    return S_OK;
}

void CInternetToolbar::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    if (!_pdie)
        return;

    HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    // If this is a command from the toolbar, and it is not one of the StdBrowseButtons
    // call Exec() on the appropriate CmdTarget
    if (hwndControl == _btb._hwnd)
    {
        UINT uiInternalCmdID = idCmd;

        // Convert to the real thing and get the guid
        CMDMAP* pcm = _btb._GetCmdMapByID(idCmd);

        IOleCommandTarget* pct = _btb._CommandTargetFromCmdMap(pcm);
        if (pct)
        {
            VARIANTARG var;
            var.vt = VT_I4;
            var.lVal = uiInternalCmdID;
            if (SHIsSameObject(_btb._pctCurrentButtonGroup, pct))
            {
                // give the browser a chance to pick this off in case
                // focus doesn't belong to the view currently
                if (SUCCEEDED(_ptbsitect->Exec(&IID_IExplorerToolbar, pcm->nCmdID, 0, NULL, &var)))
                    return;
            }

            UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT,
                UIG_COMMON, (LPARAM)pcm->nCmdID);
            pct->Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, 0, NULL, &var);
        }
        return;
    }

    if (_SendToToolband(hwndControl, WM_COMMAND, wParam, lParam, NULL))
        return;


    // this switch block actually executes
    switch(idCmd)
    {
    case FCIDM_VIEWTOOLBARCUSTOMIZE:
        ASSERT(!SHRestricted2(REST_NOTOOLBARCUSTOMIZE, NULL, 0));
        SendMessage (_btb._hwnd, TB_CUSTOMIZE, 0, 0L);
        break;

    case FCIDM_DRIVELIST:
        _SendToToolband(_hwndAddressBand, WM_COMMAND, wParam, lParam, NULL);
        break;

    case FCIDM_VIEWADDRESS:
    case FCIDM_VIEWTOOLS:
    case FCIDM_VIEWMENU:
    case FCIDM_VIEWLINKS:
        if (!SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0)
            && !SHRestricted2(REST_NoToolbarOptions, NULL, 0))
        {
            DWORD dw = _nVisibleBands;
            switch (idCmd)
            {
            case FCIDM_VIEWTOOLS:
                dw ^= VBF_TOOLS;
                break;
            case FCIDM_VIEWMENU:
                dw ^= VBF_MENU;
                break;
            case FCIDM_VIEWADDRESS:
                dw ^= VBF_ADDRESS;
                break;
            case FCIDM_VIEWLINKS:
                dw ^= VBF_LINKS;
                break;
            }
            if ( !( dw & ~VBF_BRAND))
            {
                _pdie->put_ToolBar( FALSE );
            }

            _ShowVisible(dw, TRUE);
        }
        return;

    case FCIDM_VIEWAUTOHIDE:
    {
        ASSERT(_fTheater);
        _fAutoHide = !_fAutoHide;

        VARIANTARG v = {0};
        v.vt = VT_I4;
        v.lVal = _fAutoHide;
        IUnknown_Exec(_ptbsite, &CGID_Theater, THID_SETTOOLBARAUTOHIDE, 0, &v, NULL);

        ResizeBorderDW(NULL, NULL, FALSE);

        break;
    }

    case FCIDM_VIEWLOCKTOOLBAR:
    {
        _fLockedToolbar = !_fLockedToolbar;
        DWORD dwResult = _fLockedToolbar;
        SHSetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("Locked"), REG_DWORD, &dwResult, sizeof(dwResult));
        _UpdateLocking();
        break;
    }

    case FCIDM_VIEWTEXTLABELS:
        if(!SHRestricted2(REST_NoToolbarOptions, NULL, 0))
        {
            if (!_btb._fCustomize && IS_LIST_STYLE(_btb._hwnd))
            {
                // If customize is unavailable, then there's no way for the user to
                // turn list style on/off.  In this case we want toggling text labels
                // to work the way it did in IE4 -- that is, switch between "text on
                // all buttons" and "text on no buttons".  So, if we're in "selective
                // text on right" mode, we say that labels are turned off.  If the user
                // picks this menu option, we'll go into "text on all buttons" mode.

                _UpdateToolsStyle(FALSE);

                // Make ourselves believe that text labels are turned off (so
                // that _UpdateToolbarDisplay will turn them on)

                _fCompressed = TRUE;
            }
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, !_fCompressed, TRUE);
        }
        return;

    case FCIDM_VIEWGOBUTTON:
        _SendToToolband(_hwndAddressBand, WM_COMMAND, wParam, lParam, NULL);
        break;

    default:
        if (InRange( idCmd, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST ))
        {
            if (!SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
            {
                DWORD dw = _nVisibleBands;
                dw ^= EXTERNALBAND_VBF_BIT(idCmd - FCIDM_EXTERNALBANDS_FIRST);
                if ( !( dw & ~VBF_BRAND))
                {
                    _pdie->put_ToolBar( FALSE );
                }
                _ShowVisible(dw, TRUE);
            }
            return;
        }
        break;
    }
}

// get the doc property, then get the command target from that and do it
void CInternetToolbar::_SendDocCommand(UINT idCmd)
{
    if (_ptbsitect)
    {
        VARIANTARG varIn;
        VARIANTARG varOut;
        VARIANTARG *pvarIn = &varIn;
        VARIANTARG *pvarOut = &varOut;

        VariantInit(&varIn);
        VariantInit(&varOut);


        switch (idCmd)
        {
        case OLECMDID_HIDETOOLBARS:
        case OLECMDID_PRINT:
            // word & excel barf if there are arguments passed to print
            pvarIn = NULL;
            pvarOut = NULL;
            break;

        case OLECMDID_ZOOM:
            // get the zoom range
            int iMax, iMin;
            if (FAILED(_ptbsitect->Exec(NULL, OLECMDID_GETZOOMRANGE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varOut)))
                goto Bail;

            if (varOut.vt == VT_I4)
            {
                iMin = (int)(short)LOWORD(varOut.lVal);
                iMax = (int)(short)HIWORD(varOut.lVal);
            }
            else
                goto Bail;

            varOut.vt = VT_EMPTY; // return to VariantInit state

            // get the current zoom depth
            if (FAILED(_ptbsitect->Exec(NULL, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varIn)))
                goto Bail;

            if (varIn.vt == VT_I4)
            {
                varIn.lVal++;
                if ((int)varIn.lVal > iMax)
                {
                    varIn.lVal = iMin;
                }
            }
            else
            {
                goto Bail;
            }

            break;

        }

#ifdef FEATURE_IE40
        _ptbsitect->Exec(NULL, idCmd, OLECMDEXECOPT_DONTPROMPTUSER, pvarIn, pvarOut);
#else
        _ptbsitect->Exec(NULL, idCmd, OLECMDEXECOPT_PROMPTUSER, pvarIn, pvarOut);
#endif

Bail:
    // if this fails, we should maybe do the invoke with a
    // proper verb?
    VariantClearLazy(&varIn);
    VariantClearLazy(&varOut);

    }
}

BOOL CInternetToolbar::_CompressBands(BOOL fCompress, UINT uRowsNew, BOOL fForceUpdate)
{
    UINT_PTR uRowsOld = SendMessage(_btb._hwnd, TB_GETTEXTROWS, 0, 0L);
    if (fCompress)
        uRowsNew = 0;

    if (!fForceUpdate && (uRowsOld == uRowsNew))
    {
        // same as what we've already got, blow it off
        return FALSE;
    }

    _fCompressed = fCompress;

    // Change the size of the Brand window and add ot remove the text
    SendMessage(_btb._hwnd, TB_SETMAXTEXTROWS, uRowsNew, 0L);

    UINT uWidthNew = _fCompressed ? MAX_TB_COMPRESSED_WIDTH : _uiMaxTBWidth;
    SendMessage(_btb._hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, uWidthNew));

    _btb._BandInfoChanged();

    _UpdateBrandSize();
    _bs._SetMinDimensions();

    return TRUE;
}

#define ABS(x)  (((x) < 0) ? -(x) : (x))

void CInternetToolbar::_TrackSliding(int x, int y)
{
    INT_PTR cBands    = SendMessage(_bs._hwnd, RB_GETBANDCOUNT, 0, 0L);
    INT_PTR cRows     = SendMessage(_bs._hwnd, RB_GETROWCOUNT, 0, 0L);
    INT_PTR cyHalfRow = SendMessage(_bs._hwnd, RB_GETROWHEIGHT, cBands-1, 0L) / 2;
    RECT rc;
    int cyBefore;
    int c;
    BOOL_PTR fChanged = FALSE;

    // do this instead of GetClientRect so that we include borders
    GetWindowRect(_bs._hwnd, &rc);
    MapWindowPoints(HWND_DESKTOP, _bs._hwnd, (LPPOINT)&rc, 2);
    cyBefore = rc.bottom - rc.top;

    c = y - _yCapture;
    rc.bottom = y;

    // was there enough change?
    if (ABS(c) <= cyHalfRow)
        return;

    if ((cRows == 1) || _fCompressed)
    {
        if (c < -cyHalfRow)
            fChanged = _CompressBands(TRUE, 0, FALSE);
        else
            fChanged = _CompressBands(FALSE, _uiTBTextRows, FALSE);

    }

    if (!fChanged)
    {
        // if the compressing bands didn't change anything, try to fit it to size
        fChanged = SendMessage(_bs._hwnd, RB_SIZETORECT, 0, (LPARAM)&rc);
    }


    // TODO: There is a drawing glitch when you resize from 3 bars (No Text) to 3 bars
    // with text. The _yCapture gets set to a value greater than y. So on the
    // next MOUSEMOVE it figures that the user moved up and switches from 3 bars with text
    // to 2 bars with text.
    if (fChanged)
    {
        _UpdateBrandSize();
        GetWindowRect(_bs._hwnd, &rc);
        _yCapture += (rc.bottom - rc.top) - cyBefore;
        _fDirty = TRUE; //Since the band layout changed, set the dirty bit ON.
        if (_ptbsitect)
            _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
    }
}


void CInternetToolbar::_ShowVisible(DWORD dwVisibleBands, BOOL fPersist)
{
    // PERF (scotth): is this even necessary now that we have a
    //  menu band always showing?
    BOOL fShowInitial = (! (_nVisibleBands & ~VBF_BRAND));

    _UpdateToolbarDisplay(UTD_VISIBLE, dwVisibleBands, _fCompressed, fPersist);

    if (fShowInitial)
        _pdie->put_ToolBar(TRUE);
}


HRESULT CInternetToolbar::_UpdateToolbarDisplay(DWORD dwFlags, UINT uVisibleBands, BOOL fNoText, BOOL fPersist)
{
    _fDirty = TRUE;  //Since we are making changes, set the dirty bit!

    //Update the back bitmap
    _SetBackground();

    //Show the bands.
    if(dwFlags & UTD_VISIBLE)
        _ShowBands(uVisibleBands);

    //Show/Hide the text.
    if(dwFlags & UTD_TEXTLABEL)
        _CompressBands(fNoText, _uiTBTextRows, TRUE);

    _fDirty = TRUE;  //Since we are making changes, set the dirty bit!
    if (!_fTheater && fPersist && _ptbsitect)
        _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);

    return S_OK;
}

void CInternetToolbar::_UpdateBrandSize()
{
    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_BRAND);
    if (pbid && ((_nVisibleBands & (VBF_TOOLS | VBF_BRAND)) == (VBF_TOOLS | VBF_BRAND)))
    {
        BOOL fMinAlways = _fCompressed;

        if (!fMinAlways)
        {
            INT_PTR iTools = BandIDtoIndex(_bs._hwnd, CBIDX_TOOLS);
            INT_PTR iBrand = BandIDtoIndex(_bs._hwnd, CBIDX_BRAND);

            if (iBrand < iTools && !_fTheater)
                fMinAlways = TRUE;
        }

        VARIANTARG v = {0};
        v.vt = VT_I4;
        v.lVal = fMinAlways;
        IUnknown_Exec(pbid->pdb, &CGID_PrivCITCommands, CITIDM_BRANDSIZE, 0, &v, NULL);
    }
}

LRESULT CALLBACK CInternetToolbar::SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = (CInternetToolbar*)GetWindowPtr0(hwnd); // GetWindowLong(hwnd, 0)

    switch(uMsg)
    {
    case WM_SETCURSOR:
    {
        if (pitbar->_fLockedToolbar)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return TRUE;
        }

        if ((HWND)wParam == hwnd && LOWORD(lParam) == HTCLIENT && 
              !SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0)) 
        {
            SetCursor(LoadCursor(NULL, IDC_SIZENS));
            return TRUE;
        }
        goto DoDefault;
    }

    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
        if (FALSE == pitbar->_fDestroyed)
        {
            DWORD dwSection = SHIsExplorerIniChange(wParam, lParam);

            BOOL fRebuild = (uMsg == WM_SYSCOLORCHANGE) ||
                            (dwSection == EICH_KWINEXPLSMICO) ||
                            (wParam == SPI_SETNONCLIENTMETRICS);

            if (fRebuild)
            {
                pitbar->_InitForScreenSize();
                ITBar_LoadToolbarGlyphs(pitbar->_btb._hwnd);
                pitbar->_ReloadBitmapDSA();
                pitbar->_SetSearchStuff();
                pitbar->_ReloadButtons();
#ifdef EDIT_HACK
                if (uMsg == WM_SYSCOLORCHANGE)
                {
                    pitbar->_RefreshEditGlyph();
                }
#endif
            }
            
#ifdef EDIT_HACK
            if (dwSection == EICH_KINET)
            {
                pitbar->_aEditVerb.InitDefaultEditor();
                pitbar->_UpdateEditButton();
            }
#endif

            SendMessage(pitbar->_bs._hwnd, uMsg, wParam, lParam);
            pitbar->_SendToToolband(HWND_BROADCAST, uMsg, wParam, lParam, NULL);

            if (fRebuild)
            {
                pitbar->_SetBackground();
                InvalidateRect(pitbar->_bs._hwnd, NULL, TRUE);
                pitbar->_bs._SetMinDimensions();
            }
        }
        break;

    case WM_LBUTTONDOWN:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);
        // Don't allow toolbar resizing in theater mode
        if (!pitbar->_fTheater && 
            !SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0) && 
            (!pitbar->_fLockedToolbar))
        {
            pitbar->_xCapture = GET_X_LPARAM(lParam);
            pitbar->_yCapture = GET_Y_LPARAM(lParam);
            SetCapture(hwnd);
        }
        break;

    case WM_MOUSEMOVE:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);

        if (pitbar->_yCapture != -1)
        {
            if (hwnd != GetCapture())
                pitbar->_yCapture = -1;
            else
                pitbar->_TrackSliding(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }
        else if (pitbar->_fRebarDragging)
        {
            RECT rc;
            POINT pt;
            GetClientRect(pitbar->_bs._hwnd, &rc);
            GetCursorPos(&pt);
            MapWindowPoints(HWND_DESKTOP, pitbar->_bs._hwnd, &pt, 1);
            rc.bottom /= 2;
            if (pt.y > rc.bottom)
                pt.y = rc.bottom;
            SendMessage(pitbar->_bs._hwnd, RB_DRAGMOVE, 0, MAKELPARAM(pt.x, pt.y));
        }
        break;

    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
        //            RelayToToolTips(prb->hwndToolTips, hwnd, wMsg, wParam, lParam);

        pitbar->_yCapture = -1;
        if (pitbar->_fRebarDragging)
        {
            pitbar->_fRebarDragging = FALSE;
            SendMessage(pitbar->_bs._hwnd, RB_ENDDRAG, 0, 0);
        }
        if (GetCapture() == hwnd)
            ReleaseCapture();
        break;

    case WM_CONTEXTMENU:
        pitbar->_bs.OnWinEvent(pitbar->_hwnd, uMsg, wParam, lParam, NULL);
        break;

    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        // We must swallow these messages to avoid infinit SendMessage
        break;

    case WM_NOTIFY:
        // We must swallow these messages to avoid infinit SendMessage
        return pitbar->_OnNotify((LPNMHDR)lParam);

    case WM_NOTIFYFORMAT:
        if (NF_QUERY == lParam)
            return (DLL_IS_UNICODE ? NFR_UNICODE : NFR_ANSI);
        break;

    case WM_COMMAND:
        pitbar->_OnCommand(wParam, lParam);
        break;

    case WM_ERASEBKGND:
        {
            HDC hdc = (HDC)wParam;
            RECT rc;
            GetClientRect(hwnd, &rc);
            SHFillRectClr(hdc, &rc, (pitbar->_fTheater) ? RGB(0,0,0) : GetSysColor(COLOR_3DFACE));
            break;
         }

    case WM_PALETTECHANGED:
        //
        // PERF: we could optimize this by realizing and checking the
        // return value
        //
        // for now we will just invalidate ourselves and all children...
        //
        RedrawWindow(hwnd, NULL, NULL,
                     RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);
        break;

    case WM_MEASUREITEM:
    {
        PMEASUREITEMSTRUCT pmis;

        ASSERT(NULL != lParam);
        pmis = (PMEASUREITEMSTRUCT)lParam;

        switch (pmis->itemID)
        {
        case FCIDM_VBBHISTORYBAND:
            ASSERT(0 == wParam);
            {
                PULONG_PTR pData = (PULONG_PTR)pmis->itemData;
                ASSERT(NULL != pData);
                MeasureMenuItem(pmis, (PCTSTR)pData[0]);
            }
            break;

        default:
            goto DoDefault;
        }
        break;
    }

    case WM_DRAWITEM:
    {
        PDRAWITEMSTRUCT pdis;

        ASSERT(NULL != lParam);
        pdis = (PDRAWITEMSTRUCT)lParam;

        switch (pdis->itemID)
        {
        case FCIDM_VBBHISTORYBAND:
            ASSERT(0 == wParam);
            {
                PULONG_PTR pData = (PULONG_PTR)pdis->itemData;
                ASSERT(NULL != pData);
                DrawMenuItem(pdis, (PCTSTR)pData[0], (UINT) pData[1]);
            }
            break;

        default:
            goto DoDefault;
        }
        break;
    }

    case WM_MENUCHAR:
        if (MF_POPUP == HIWORD(wParam))
        {
            MENUITEMINFO mii = { 0 };

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_DATA | MIIM_TYPE;
            GetMenuItemInfo((HMENU)lParam, FCIDM_VBBHISTORYBAND, FALSE, &mii);

            if (TEXT('h') == LOWORD(wParam) || TEXT('H') == LOWORD(wParam))
            {
                return MAKELRESULT(FCIDM_VBBHISTORYBAND, MNC_EXECUTE);
            }
        }
        break;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_UPDATETOOLBAR:
            pitbar->_fUpdateToolbarTimer = FALSE;
            KillTimer(hwnd, wParam);
            if (pitbar->_fNeedUpdateToolbar)
                pitbar->_UpdateToolbarNow();
            break;
        }
        break;

    case WM_DESTROY:
        pitbar->_Unadvise(); // remove ref-loop with _pdie
        TraceMsg(DM_TBREF, "CInternetToolbar::SizableWndProc() - Called RemoveProp. Called Release new _cRef=%d", pitbar->_cRef);
        goto DoDefault;

DoDefault:
    default:
        return(DefWindowProcWrap(hwnd, uMsg, wParam, lParam));
    }

    return 0L;
}


HRESULT CInternetToolbar::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW called (_fShow==%d)", _fShow);
    HRESULT hres = S_OK;

    ASSERT(_ptbsite);
    if (_ptbsite)
    {
        RECT rcRequest = { 0, 0, 0, 0 };

        if (_fShow)
        {
            RECT rcRebar, rcBorder;
            int  cx,cy;

            GetWindowRect(_bs._hwnd, &rcRebar);
            cx = rcRebar.right - rcRebar.left;
            cy = rcRebar.bottom - rcRebar.top;

            int iExtra = 3;
            if (_fTheater)
            {
                // 1 for the 1 pixel border on the bottom
                iExtra = 1;
            }
            else if (_fLockedToolbar)
            {
                iExtra = 0;
            }

            TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW cy = %d", cy);

            if (!prcBorder)
            {
                _ptbsite->GetBorderDW(SAFECAST(this, IDockingWindow*), &rcBorder);
                prcBorder = &rcBorder;
            }

            cx = prcBorder->right - prcBorder->left;


            SetWindowPos(_bs._hwnd, NULL, 0, 0,
                         cx, cy,  SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

            GetWindowRect(_bs._hwnd, &rcRebar);


            rcRequest.top = rcRebar.bottom - rcRebar.top + iExtra;
            SetWindowPos(_hwnd, NULL, prcBorder->left, prcBorder->top,
                         rcRebar.right - rcRebar.left, rcRequest.top, SWP_NOZORDER | SWP_NOACTIVATE);
        }

        if (_fTheater && _fAutoHide)
        {
            // if we're in theater mode, then we should request no space
            rcRequest.left = rcRequest.top = 0;
        }

        TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW calling RequstBS with %d,%d,%d,%d",
                 rcRequest.left, rcRequest.top, rcRequest.right, rcRequest.bottom);
        _ptbsite->RequestBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);

        TraceMsg(DM_LAYOUT, "CITB::ResizeBorderDW calling SetBS with %d,%d,%d,%d",
                 rcRequest.left, rcRequest.top, rcRequest.right, rcRequest.bottom);
        _ptbsite->SetBorderSpaceDW(SAFECAST(this, IDockingWindow*), &rcRequest);
    }

    return hres;
}

HRESULT CInternetToolbar::QueryStatus(const GUID *pguidCmdGroup,
                                      ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
    if (pbid && pbid->pdb)
    {
        IOleCommandTarget *poct;
        if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poct))))
        {
            hr = poct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
            poct->Release();
        }
    }

    if (pguidCmdGroup && IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        hr = S_OK;
        for (ULONG i = 0 ; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;
            switch (rgCmds[i].cmdID)
            {
            case CITIDM_VIEWTOOLS:
                if (_nVisibleBands & VBF_TOOLS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWMENU:
                if (_nVisibleBands & VBF_MENU)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWTOOLBARCUSTOMIZE:
                if (_btb._fCustomize)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWAUTOHIDE:
                if (_fAutoHide)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWLOCKTOOLBAR:
                if (_fLockedToolbar)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWADDRESS:
                if (_nVisibleBands & VBF_ADDRESS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_VIEWLINKS:
                if (_nVisibleBands & VBF_LINKS)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_TEXTLABELS:
                if (!_fCompressed)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            case CITIDM_EDITPAGE:
                if (_fEditEnabled)
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
#ifdef EDIT_HACK
                // The tooltip text is also used for the menu
                if (pcmdtext)
                {
                    TCHAR szBuf[MAX_PATH];
                    if ((pcmdtext->cmdtextf == OLECMDTEXTF_NAME) &&
                         _aEditVerb.GetMenuText(szBuf, ARRAYSIZE(szBuf)))
                    {
                        SHTCharToUnicode(szBuf, pcmdtext->rgwz, pcmdtext->cwBuf);
                        pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz) + 1;
                    }
                    else
                    {
                        pcmdtext->cwActual = 0;
                    }
                }
#endif
                break;
            default:
                if (InRange( rgCmds[i].cmdID, CITIDM_VIEWEXTERNALBAND_FIRST, CITIDM_VIEWEXTERNALBAND_LAST))
                {
                    int iBand = rgCmds[i].cmdID - CITIDM_VIEWEXTERNALBAND_FIRST;
                    if (!IsEqualCLSID( _rgebi[iBand].clsid, GUID_NULL ))
                    {
                        rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                        if (_nVisibleBands & EXTERNALBAND_VBF_BIT( iBand ))
                        {
                            rgCmds[i].cmdf |= OLECMDF_ENABLED;
                        }
                        if (pcmdtext)
                        {
                            pcmdtext->rgwz[0] = TEXT('\0');
                            switch (pcmdtext->cmdtextf)
                            {
                            case OLECMDTEXTF_NAME:
                                if (_rgebi[iBand].pwszName)
                                    Str_GetPtrW(_rgebi[iBand].pwszName, pcmdtext->rgwz, pcmdtext->cwBuf );
                                break;

                            case OLECMDTEXTF_STATUS:
                                if (_rgebi[iBand].pwszHelp)
                                    Str_GetPtrW(_rgebi[iBand].pwszHelp, pcmdtext->rgwz, pcmdtext->cwBuf );
                                break;

                            default:
                                break;
                            }
                            pcmdtext->cwActual = lstrlen( pcmdtext->rgwz );
                        }
                    }
                }
                break;
            }
        }
    }
    return hr;
}

void CInternetToolbar::_RestoreSaveStruct(COOLBARSAVE* pcs)
{
    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    int i;

    _fAutoHide = pcs->fAutoHide;
    _ShowVisible(pcs->uiVisible, FALSE);

    BOOL fAllowRetry = TRUE;
    BOOL fNeedRetry = FALSE;
    INT_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);
Retry:
    for (i = 0; i < CBANDSMAX; i++)
    {
        INT_PTR iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, pcs->bs[i].wID, 0);
        if (iIndex != -1)
        {
            SendMessage(_bs._hwnd, RB_MOVEBAND, iIndex, i);
            rbbi.fMask = RBBIM_STYLE;
            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
            {
                rbbi.fMask = RBBIM_SIZE | RBBIM_STYLE;
                rbbi.cx = pcs->bs[i].cx;
                rbbi.fStyle = pcs->bs[i].fStyle;
                SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            }

            // the SetBandInfo could have potentially caused items to shift around
            // verify that this didn't happen.
            iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, pcs->bs[i].wID, 0);
            if (iIndex != i)
            {
                fNeedRetry = TRUE;
            }
        }
    }

    if (fAllowRetry && fNeedRetry)
    {
        fAllowRetry = FALSE;
        goto Retry;
    }

    _CSHSetStatusBar(pcs->fStatusBar);
    _UpdateToolsStyle(pcs->fList);

    RECT rc;
    GetWindowRect(_bs._hwnd, &rc);
    SetWindowPos(_bs._hwnd, NULL, 0,0, RECTWIDTH(rc), pcs->cyRebar, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);
}

void CInternetToolbar::_CSHSetStatusBar(BOOL fOn)
{
    VARIANTARG v = { 0 };
    v.vt = VT_I4;
    v.lVal = fOn;
    IUnknown_Exec(_ptbsite, &CGID_ShellBrowser, FCIDM_SETSTATUSBAR,
        0, &v, NULL);
}

void CInternetToolbar::_TheaterModeLayout(BOOL fEnter)
{
    static const struct {
        int id;
        int cx;
    } c_layout[] =
    {
        { CBIDX_TOOLS, 400 },
        { CBIDX_MENU, 200 },
        { CBIDX_ADDRESS, 300 },
        { CBIDX_LINKS, 40 }
    };

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);

    BOOL_PTR fRedraw = SendMessage(_bs._hwnd, WM_SETREDRAW, FALSE, 0);
    SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_AUTOSIZE, 0);
    if (fEnter)
    {
        _BuildSaveStruct(&_cs);

        // turn off text labels
        COOLBARSAVE cs;
        DWORD dwType, cbSize = sizeof(COOLBARSAVE);
        if (SHRegGetUSValue(c_szRegKeyCoolbar, c_szValueTheater, &dwType, (void*)&cs, &cbSize, FALSE, NULL, 0) == ERROR_SUCCESS &&
           cs.cbVer == CBS_VERSION)
        {
            _RestoreSaveStruct(&cs);
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, TRUE, TRUE);
        }
        else
        {
            _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, TRUE, TRUE);
            _ShowVisible(VBF_TOOLS | VBF_BRAND, FALSE); // only show tools band by default
            RECT rc = { 0, 0, GetSystemMetrics(SM_CXSCREEN), 20 }; // something arbitrarily small vertically
            SendMessage(_bs._hwnd, RB_SIZETORECT, 0, (LPARAM)&rc);

            int cBands = (int) SendMessage(_bs._hwnd, RB_GETBANDCOUNT, 0, 0L);
            int i;
            // strip off all blanks
            rbbi.fMask = RBBIM_STYLE;
            for (i = 0; i < cBands; i++)
            {
                if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
                {
                    rbbi.fStyle &= ~RBBS_BREAK;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                }
            }

            // then move into the proper order and size
            for (i = 0; i < ARRAYSIZE(c_layout); i++)
            {
                INT_PTR iIndex = SendMessage(_bs._hwnd, RB_IDTOINDEX, c_layout[i].id, 0);
                if (iIndex != -1)
                {
                    SendMessage(_bs._hwnd, RB_MOVEBAND, iIndex, i);

                    rbbi.fMask = RBBIM_SIZE;
                    rbbi.cx = c_layout[i].cx;
                    SendMessage(_bs._hwnd, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                }
            }
            _CSHSetStatusBar(FALSE);  // default value in theater mode
        }
        SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_BANDBORDERS | WS_BORDER, RBS_BANDBORDERS);
    }
    else
    {
        COOLBARSAVE cs;
        _BuildSaveStruct(&cs);
        SHRegSetUSValue(c_szRegKeyCoolbar, c_szValueTheater, REG_BINARY,
                        (void*)&cs, sizeof(COOLBARSAVE), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
        _RestoreSaveStruct(&_cs);
        _UpdateToolbarDisplay(UTD_TEXTLABEL, 0, _cs.fNoText, FALSE);
        SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_BANDBORDERS | WS_BORDER, RBS_BANDBORDERS | WS_BORDER);
    }

    _SetBackground();
    SHSetWindowBits(_bs._hwnd, GWL_STYLE, RBS_AUTOSIZE, RBS_AUTOSIZE);
    SendMessage(_bs._hwnd, WM_SETREDRAW, fRedraw, 0);

    SetWindowPos(_bs._hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
}

HRESULT CInternetToolbar::_GetMinRowHeight()
{
    UINT iHeight = 0;
    int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        REBARBANDINFO rbbi;
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_CHILDSIZE | RBBIM_STYLE;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM)&rbbi))
        {
            // go until the end of the row
            if (rbbi.fStyle & RBBS_BREAK)
                break;

            if (!(rbbi.fStyle & RBBS_HIDDEN))
            {
                if (rbbi.cyMinChild > iHeight)
                    iHeight = rbbi.cyMinChild;
            }
        }
    }

    return ResultFromShort(iHeight);
}

BOOL IsBarRefreshable(IDeskBar* pdb)
{
    ASSERT(pdb);
    BOOL fIsRefreshable = TRUE;
    VARIANT varClsid = {0};

    if (SUCCEEDED(IUnknown_Exec(pdb, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 1, NULL, &varClsid)) && (varClsid.vt == VT_BSTR))
    {
        CLSID clsidBar;

        //if the bar is hidden, it returns GUID_NULL, so don't refresh it
        if ( GUIDFromString(varClsid.bstrVal, &clsidBar) &&
             (IsEqualGUID(clsidBar, GUID_NULL)) )
        {
            fIsRefreshable = FALSE;
        }
        else
        {
            //APPHACK for office discussions band (and possibly others)
            //CLSID\GUID\Instance
            WCHAR wszKey[6+40+1+9];
            DWORD dwValue, dwType=REG_DWORD, dwcbData = 4;
            wnsprintf(wszKey, ARRAYSIZE(wszKey), L"CLSID\\%s\\Instance", varClsid.bstrVal);

            if ( (SHGetValue(HKEY_CLASSES_ROOT, wszKey, L"DontRefresh", &dwType, &dwValue, &dwcbData) == ERROR_SUCCESS) &&
                 (dwValue != 0) )
            {
                fIsRefreshable = FALSE;
            }
        }
        VariantClear(&varClsid);
    }
    return fIsRefreshable;
}

HRESULT CInternetToolbar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;  // assume failure

    if (!pguidCmdGroup)
    {
        goto Lother;
    }
    else if (IsEqualGUID(CLSID_CommonButtons, *pguidCmdGroup))
    {
        if (pvarargOut)
        {
            ASSERT(pvarargOut && pvarargOut->vt == VT_I4);
            UINT uiInternalCmdID = pvarargOut->lVal;

            if (nCmdID == TBIDM_SEARCH && uiInternalCmdID == -1)
                _btb._ConvertCmd(pguidCmdGroup, nCmdID, NULL, &uiInternalCmdID);

            switch (nCmdID)
            {
            case TBIDM_BACK:
            case TBIDM_FORWARD:
            case TBIDM_STOPDOWNLOAD:
            case TBIDM_REFRESH:
            case TBIDM_HOME:
            case TBIDM_SEARCH:
            case TBIDM_FAVORITES:
            case TBIDM_HISTORY:
            case TBIDM_ALLFOLDERS:
            case TBIDM_MEDIABAR:
                if (!SendMessage(_btb._hwnd, TB_ISBUTTONENABLED, uiInternalCmdID, 0))
                    return S_OK;
                break;
            }
            if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
            {
                // the user hit the drop down
                if (_ptbsitect && pvarargIn && pvarargIn->vt == VT_INT_PTR)
                {
                    // v.vt = VT_I4;
                    POINT pt;
                    RECT* prc = (RECT*)pvarargIn->byref;
                    pt.x = prc->left;
                    pt.y = prc->bottom;

                    switch (nCmdID)
                    {
                    case TBIDM_BACK:
                        _ShowBackForwardMenu(FALSE, pt, prc);
                        break;

                    case TBIDM_FORWARD:
                        _ShowBackForwardMenu(TRUE, pt, prc);
                        break;
                    }
                    // VariantClearLazy(&v);
                }
                return S_OK;
            }

            switch(nCmdID)
            {
            case TBIDM_PREVIOUSFOLDER:
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PREVIOUSFOLDER, 0, NULL, NULL);
                break;

            case TBIDM_CONNECT:
                DoNetConnect(_hwnd);
                break;

            case TBIDM_DISCONNECT:
                DoNetDisconnect(_hwnd);
                break;

            case TBIDM_BACK:
                _pdie->GoBack();
                break;

            case TBIDM_FORWARD:
                _pdie->GoForward();
                break;

            case TBIDM_HOME:
                _pdie->GoHome();
                break;

            case TBIDM_SEARCH:
                if (_ptbsitect)
                {
                    VARIANTARG vaOut = {0};
                    VARIANTARG* pvaOut = NULL;
                    LPITEMIDLIST pidl = NULL;

                    // i'm leaving this not #ifdefed out because it is used by explorer bar
                    // persistance (reljai)
                    //_SetSearchStuff initializes _guidDefaultSearch, which may or may not have
                    // been called yet
                    if (IsEqualGUID(_guidDefaultSearch, GUID_NULL))
                        _SetSearchStuff();

                    // see if what the state of search pane is, so we can toggle it...
                    OLECMD rgcmds[] = {{ SBCMDID_SEARCHBAR, 0 },};
                    
                    if (_ptbsitect)
                        _ptbsitect->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmds), rgcmds, NULL);
                    // not pressed, then show the pane
                    if (!(rgcmds[0].cmdf & OLECMDF_LATCHED))
                    {
                        WCHAR       wszUrl[MAX_URL_STRING];

                        if (_GetSearchUrl(wszUrl, ARRAYSIZE(wszUrl)))
                        {
                            CLSID clsid;

                            if (GUIDFromString(wszUrl, &clsid))
                            {
                                IContextMenu* pcm;

                                if (SUCCEEDED(SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm))))
                                {
                                    CMINVOKECOMMANDINFO ici = {0};
                                    CHAR                szGuid[GUIDSTR_MAX];
                                    BOOL                bSetSite = TRUE;

                                    ici.cbSize = sizeof(ici);
                                    ici.hwnd = _hwnd;
                                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(0);
                                    ici.nShow  = SW_NORMAL;
                                    SHStringFromGUIDA(_guidDefaultSearch, szGuid, ARRAYSIZE(szGuid));
                                    ici.lpParameters = szGuid;

                                    // in case of rooted browser we need to open the search in the new window
                                    // 'coz otherwise the pane opens in the same window and user starts search
                                    // and browseobject (or someone) detects the rooted case and launches new
                                    // browser for our search results view (which is blank because it cannot do
                                    // search by itself and also there is not search pane) (reljai)
                                    if (_pbs2)
                                    {
                                        LPITEMIDLIST pidl;

                                        if (SUCCEEDED(_pbs2->GetPidl(&pidl)))
                                        {
                                            bSetSite = !ILIsRooted(pidl);
                                            ILFree(pidl);
                                        }
                                    }
                                    // if there is no site, InvokeCommand bellow will launch new browser w/ the 
                                    // search pane open
                                    if (bSetSite)
                                        IUnknown_SetSite(pcm, _psp);
                                    hr = pcm->InvokeCommand(&ici);
                                    if (bSetSite)
                                        IUnknown_SetSite(pcm, NULL);
                                    pcm->Release();
                                }
                                break;
                            }
                            //_guidCurrentSearch = _guidDefaultSearch;//done on set state
                            IECreateFromPathW(wszUrl, &pidl);
                            // convert pidl into VARIANT
                            // way to pass the pidl, so...
                            InitVariantFromIDList(&vaOut, pidl);
                            pvaOut = &vaOut;
                        }
                    }

                    hr = _ptbsitect->Exec(&CGID_Explorer, SBCMDID_SEARCHBAR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, pvaOut); // vaIn:NULL means toggle
                    ASSERT(SUCCEEDED(hr));
                    if (pvaOut)
                        VariantClear(pvaOut);
                    ILFree(pidl);
                }
                else
                {
                    TraceMsg(DM_ERROR, "CITBar::Exec: no IOleCommandTarget!");
                }
                break;

            case TBIDM_FAVORITES:
            case TBIDM_HISTORY:
            case TBIDM_ALLFOLDERS:
            case TBIDM_MEDIABAR:
                if (_ptbsitect) 
                {
                    static const int tbtab[] = {
                        TBIDM_FAVORITES    , TBIDM_HISTORY    ,   TBIDM_ALLFOLDERS   , TBIDM_MEDIABAR  ,
                    };
                    static const int cttab[] = {
                        SBCMDID_FAVORITESBAR, SBCMDID_HISTORYBAR, SBCMDID_EXPLORERBAR, SBCMDID_MEDIABAR,
                    };
                    HRESULT hres;
                    int idCT;

                    idCT = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), nCmdID);
                    hres = _ptbsitect->Exec(&CGID_Explorer, idCT, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);  // vaIn:NULL means toggle
                    ASSERT(SUCCEEDED(hres));
                }
                else
                {
                    TraceMsg(DM_ERROR, "CITBar::Exec: no IOleCommandTarget!");
                }
                break;

            case TBIDM_THEATER:
                {
                    VARIANT_BOOL b;
                    if (SUCCEEDED(_pdie->get_TheaterMode(&b)))
                        _pdie->put_TheaterMode( b == VARIANT_TRUE ? VARIANT_FALSE : VARIANT_TRUE);
                    break;
                }

            case TBIDM_STOPDOWNLOAD:
                if (_fTransitionToHTML)
                {
                    UINT uiState;
                    _fTransitionToHTML = FALSE;
                    if (SUCCEEDED(GetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, &uiState)))
                    {
                        uiState |= TBSTATE_HIDDEN;
                        SetState(&CLSID_CommonButtons, TBIDM_STOPDOWNLOAD, uiState);
                    }
                    SendMessage(_hwndAddressBand, CB_SETEDITSEL, NULL, (LPARAM)MAKELONG(-1,0));
                }
                _pdie->Stop();
                break;

            case TBIDM_REFRESH:
            {
                VARIANT v = {0};
                v.vt = VT_I4;
                v.lVal = (GetAsyncKeyState(VK_CONTROL) < 0) ?
                         OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_PROMPTIFOFFLINE :
                         OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
                _pdie->Refresh2(&v);

                if (_hwndAddressBand)
                {
                    LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
                    if (pbid && pbid->pdb)
                    {
                        IAddressBand *pab = NULL;
                        if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IAddressBand, &pab))))
                        {
                            VARIANTARG varType = {0};
                            varType.vt = VT_I4;
                            varType.lVal = OLECMD_REFRESH_TOPMOST;
                            pab->Refresh(&varType);
                            pab->Release();
                        }
                    }
                }

                // pass this to vert and horz bars
                IDockingWindowFrame *psb;
                if (_psp && SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IDockingWindowFrame, &psb))))
                {
                    IDeskBar* pdb;

                    if (SUCCEEDED(psb->FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb &&
                        IsBarRefreshable(pdb))
                    {
                        IUnknown_Exec(pdb, NULL, OLECMDID_REFRESH, OLECMDIDF_REFRESH_NORMAL|OLECMDIDF_REFRESH_PROMPTIFOFFLINE, NULL, NULL);
                        pdb->Release();
                    }
                    if (SUCCEEDED(psb->FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb &&
                        IsBarRefreshable(pdb))
                    {
                        IUnknown_Exec(pdb, NULL, OLECMDID_REFRESH, OLECMDIDF_REFRESH_NORMAL|OLECMDIDF_REFRESH_PROMPTIFOFFLINE, NULL, NULL);
                        pdb->Release();
                    }
                    psb->Release();
                }

            }
                break;
            }
        }
    } 
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup)) 
    {
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            {
                if (_iButtons == -1) 
                {
                    // haven't initialized yet
                    _iButtons = ARRAYSIZE(c_tbExplorer);
                    memcpy(_tbExplorer, c_tbExplorer, sizeof(TBBUTTON) * ARRAYSIZE(c_tbExplorer));

                    if (IS_BIDI_LOCALIZED_SYSTEM())
                    {
                        if (!SHUseClassicToolbarGlyphs())
                        {
                            _tbExplorer[0].iBitmap = 1;
                            _tbExplorer[1].iBitmap = 0;
                        }
                    }

                    if (GetUIVersion() < 5) 
                    {
                        // we don't want up button and network drive buttons available
                        // on < nt5 shell (by trident pm design)

                        // no customization in shell view on < nt5
                        ASSERT(!_fShellView);

                        ASSERT(c_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
                        _tbExplorer[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
                        _tbExplorer[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
                        _tbExplorer[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;

                        ASSERT(c_tbExplorer[TBXID_ALLFOLDERS].idCommand == TBIDM_ALLFOLDERS);
                        if (!_FoldersButtonAvailable())
                            _tbExplorer[TBXID_ALLFOLDERS].fsState |= TBSTATE_HIDDEN;
                    }
                    else
                    {
                        ASSERT(c_tbExplorer[TBXID_SEARCH].idCommand == TBIDM_SEARCH);
                        if (_fShellView && SHRestricted(REST_NOSHELLSEARCHBUTTON))
                            _tbExplorer[TBXID_SEARCH].fsState |= TBSTATE_HIDDEN;
                            
                        ASSERT(c_tbExplorer[TBXID_CONNECT].idCommand == TBIDM_CONNECT);
                        ASSERT(c_tbExplorer[TBXID_DISCONNECT].idCommand == TBIDM_DISCONNECT);
                        if (SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            _tbExplorer[TBXID_CONNECT].fsState |= TBSTATE_HIDDEN;
                            _tbExplorer[TBXID_DISCONNECT].fsState |= TBSTATE_HIDDEN;
                        }
                    }
                    ASSERT(_tbExplorer[TBXID_MEDIABAR].idCommand == TBIDM_MEDIABAR);
                    if (_fShellView || SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) || !CMediaBarUtil::IsWMP7OrGreaterCapable())
                    {
                        _tbExplorer[TBXID_MEDIABAR].fsState |= TBSTATE_HIDDEN;
                    }

                    ASSERT(_tbExplorer[TBXID_PREVIOUSFOLDER].idCommand == TBIDM_PREVIOUSFOLDER);
                    if (!_fShellView) 
                    {
                        _tbExplorer[TBXID_PREVIOUSFOLDER].fsState |= TBSTATE_HIDDEN;
                    }
                    
                    _iButtons = RemoveHiddenButtons(_tbExplorer, ARRAYSIZE(_tbExplorer));
                }

                pvarargOut->vt = VT_BYREF;
                pvarargOut->byref = (void*)_tbExplorer;
                *pvarargIn->plVal = _iButtons;
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        DWORD dw;
        hr = S_OK;
        switch (nCmdID)
        {
        case CITIDM_GETFOLDERSEARCHES:
            {
                hr = E_INVALIDARG;

                if (pvarargOut)
                {
                    IFolderSearches *pfs;
                    hr = _GetFolderSearches(&pfs);

                    if (SUCCEEDED(hr))
                    {
                        VariantClear(pvarargOut);
                        pvarargOut->vt = VT_UNKNOWN;
                        pvarargOut->punkVal = pfs;
                    }
                }
            }
            break;

        case CITIDM_SET_DIRTYBIT:
            _fDirty = BOOLIFY(nCmdexecopt);
            break;

        case CITIDM_GETMINROWHEIGHT:
            hr = _GetMinRowHeight();
            break;

        case CITIDM_VIEWTOOLBARCUSTOMIZE:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTOOLBARCUSTOMIZE, _hwnd, 0));
            break;

        case CITIDM_TEXTLABELS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTEXTLABELS, _hwnd, 0));
            break;

        case CITIDM_EDITPAGE:
            // FEATURE: temp code -- edit code moving to dochost.cpp
            _btb.Exec(&CLSID_InternetButtons, DVIDM_EDITPAGE, 0, NULL, NULL);
            break;

        case CITIDM_ONINTERNET:
            switch (nCmdexecopt)
            {
            case CITE_INTERNET:
                _fInitialPidlIsWeb = TRUE;
                _fShellView = !_fInitialPidlIsWeb;
                break;
            case CITE_SHELL:
                _fInitialPidlIsWeb = FALSE;
                _fShellView = !_fInitialPidlIsWeb;
                break;
            case CITE_QUERY:
                return ResultFromScode(_fShellView ? CITE_SHELL : CITE_INTERNET);
                break;
            }
            return ResultFromScode(_fInitialPidlIsWeb ? CITE_INTERNET : CITE_SHELL);

        case CITIDM_VIEWTOOLS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWTOOLS, _hwnd, 0));
            break;

        case CITIDM_VIEWAUTOHIDE:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWAUTOHIDE, _hwnd, 0));
            break;

        case CITIDM_VIEWLOCKTOOLBAR:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWLOCKTOOLBAR, _hwnd, 0));
            break;

        case CITIDM_VIEWADDRESS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWADDRESS, _hwnd, 0));
            break;

        case CITIDM_VIEWLINKS:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWLINKS, _hwnd, 0));
            break;

        case CITIDM_VIEWMENU:
            _OnCommand(GET_WM_COMMAND_MPS(FCIDM_VIEWMENU, _hwnd, 0));
            break;

        case CITIDM_SHOWTOOLS:
            dw = VBF_TOOLS;
            goto ShowABand;

        case CITIDM_SHOWADDRESS:
            dw = VBF_ADDRESS;
            goto ShowABand;

        case CITIDM_SHOWLINKS:
            dw = VBF_LINKS;
            goto ShowABand;

#ifdef UNIX
        case CITIDM_SHOWBRAND:
            dw = VBF_BRAND;
            goto ShowABand;
#endif

        case CITIDM_SHOWMENU:
            dw = VBF_MENU;
ShowABand:
            if (nCmdexecopt)
                dw |= _nVisibleBands;           // Set
            else
                dw = (_nVisibleBands & ~dw);    // Clear

            _ShowVisible(dw, TRUE);
            _fUsingDefaultBands = FALSE;
            break;

        case CITIDM_DISABLESHOWMENU:
            _fNoShowMenu = BOOLIFY(nCmdexecopt);
            break;

        case CITIDM_STATUSCHANGED:
            _fDirty = TRUE;
            if (_ptbsitect)
                _ptbsitect->Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);
            break;

        case CITIDM_THEATER:

            if (_fShow)
            {

                // IF YOU SEE HTIS ASSERT, TRY TO REMEMBER WHAT YOU DID AND CALL CHEE
                ASSERT(_fTheater || _nVisibleBands & VBF_MENU);

                switch (nCmdexecopt)
                {

                case THF_ON:
                    _fTheater = TRUE;
                    ResizeBorderDW(NULL, NULL, FALSE);
                    _TheaterModeLayout(TRUE);
                    // theater has its own brand, so needs to know whether we're in shell or web view so it can show the right brand
                    IUnknown_Exec(_ptbsite, &CGID_Theater, THID_ONINTERNET, _fShellView ? CITE_SHELL : CITE_INTERNET, NULL, NULL);

                    // pass back _fAutoHide
                    pvarargOut->vt = VT_I4;
                    pvarargOut->lVal = _fAutoHide;

                    goto notify_bands;


                case THF_OFF:
                    _fTheater = FALSE;
                    ResizeBorderDW(NULL, NULL, FALSE);
                    _TheaterModeLayout(FALSE);

                    // position everything properly (needed after reparenting)
                    SendMessage(_hwnd, RB_PRIV_RESIZE, 0, 0);
                    goto notify_bands;

notify_bands:
                    {
                        int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
                        for (int i = 0; i < icBands; i++)
                        {
                            REBARBANDINFO rbbi;
                            rbbi.cbSize = sizeof(REBARBANDINFO);
                            rbbi.fMask = RBBIM_ID;

                            if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
                            {
                                LPBANDITEMDATA pbid = (LPBANDITEMDATA)_bs._GetBandItemDataStructByID(rbbi.wID);
                                if (pbid)
                                    IUnknown_Exec(pbid->pdb, pguidCmdGroup, CITIDM_THEATER, nCmdexecopt, NULL, NULL);
                            }
                        }
                    }
                    break;

                case THF_UNHIDE:
                    // position everything properly (needed after reparenting)
                    SendMessage(_hwnd, RB_PRIV_RESIZE, 0, 0);
                    break;
                }

                // IF YOU SEE HTIS ASSERT, TRY TO REMEMBER WHAT YOU DID AND CALL CHEE
                ASSERT(_fTheater || _nVisibleBands & VBF_MENU);
            }

            break;
        case CITIDM_VIEWEXTERNALBAND_BYCLASSID:
            if ((pvarargIn->vt == VT_BSTR) && pvarargIn->bstrVal)
            {
                CLSID clsid;
                if (GUIDFromString( pvarargIn->bstrVal, &clsid ))
                {
                    hr = E_FAIL;
                    for (DWORD i = 0; i < MAXEXTERNALBANDS; i++)
                    {
                        if (clsid == _rgebi[i].clsid)
                        {
                            DWORD dw = _nVisibleBands;
                            DWORD dwBit = EXTERNALBAND_VBF_BIT( i );
                            dw = (nCmdexecopt) ? dw | dwBit : dw & ~dwBit;
                            if ( !( dw & ~VBF_BRAND))
                            {
                                _pdie->put_ToolBar( FALSE );
                            }
                            _ShowVisible(dw, TRUE);
                            _fUsingDefaultBands = FALSE;
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }
            break;
        default:
            if (InRange( nCmdID, CITIDM_VIEWEXTERNALBAND_FIRST, CITIDM_VIEWEXTERNALBAND_LAST ))
            {
                _OnCommand(GET_WM_COMMAND_MPS( nCmdID - CITIDM_VIEWEXTERNALBAND_FIRST + FCIDM_EXTERNALBANDS_FIRST, _hwnd, 0));
                break;
            }
            ASSERT(0);
            break;
        }
    }
    else
    {
Lother:
        LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
        if (pbid)
        {
            hr = IUnknown_Exec(pbid->pdb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }

    return hr;
}

BOOL _GetSearchHKEY(REFGUID guidSearch, HKEY *phkey)
{
    HKEY hkey;
    BOOL bRet = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_SZ_STATIC, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szExt[MAX_PATH];//extension key name
        DWORD cchExt = ARRAYSIZE(szExt);
        int  iExt;
        BOOL bNoUrl = FALSE; // true iff guidSearch is found and there is no Url subkey

        for (iExt=0;
             !bRet && RegEnumKeyEx(hkey, iExt, szExt, &cchExt, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
             cchExt = ARRAYSIZE(szExt), iExt++)
        {
            HKEY hkeyExt; // static extension key

            if (RegOpenKeyEx(hkey, szExt, 0, KEY_READ, &hkeyExt) == ERROR_SUCCESS)
            {
                int i;
                TCHAR szSubKey[32];
                HKEY  hkeySub;

                for (i = 0; !bRet && (wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i),
                            RegOpenKey(hkeyExt, szSubKey, &hkeySub) == ERROR_SUCCESS);
                     i++)
                {
                    TCHAR szSearchGuid[GUIDSTR_MAX];
                    DWORD cb;
                    DWORD dwType;

                    cb = sizeof(szSearchGuid);
                    if (SHGetValue(hkeySub, REG_SZ_SEARCH_GUID, NULL, &dwType, (BYTE*)szSearchGuid, &cb) == ERROR_SUCCESS)
                    {
                        GUID guid;

                        if (GUIDFromString(szSearchGuid, &guid) &&
                            IsEqualGUID(guid, guidSearch))
                        {
                            HKEY hkeyTmp;

                            if (RegOpenKey(hkeySub, REG_SZ_SEARCH_URL, &hkeyTmp) == ERROR_SUCCESS)
                                RegCloseKey(hkeyTmp);
                            else
                                bNoUrl = TRUE;

                            bRet = TRUE;
                        }
                    }
                    if (!bRet || bNoUrl)
                        RegCloseKey(hkeySub);
                    else
                        *phkey = hkeySub;

                }
                if (!bNoUrl)
                    RegCloseKey(hkeyExt);
                else
                {
                    ASSERT(bRet);
                    *phkey = hkeyExt;
                }
            }
        }
        RegCloseKey(hkey);
    }
    return bRet;
}

HRESULT CInternetToolbar::GetDefaultSearchUrl(LPWSTR pwszUrl, UINT cch)
{
    HRESULT hr = E_FAIL;

    if (GetDefaultInternetSearchUrlW(pwszUrl, cch, TRUE))
        hr = S_OK;
    return hr;
}

void WINAPI CopyEnumElement(void *pDest, const void *pSource, DWORD dwSize)
{
    if (!pDest)
        return;

    memcpy(pDest, pSource, dwSize);
}

class CFolderSearches : public IFolderSearches
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    // *** IFolderSearches ***
    STDMETHODIMP EnumSearches(IEnumUrlSearch **ppenum);
    STDMETHODIMP DefaultSearch(GUID *pguid);

    CFolderSearches(GUID *pguid, int iCount, URLSEARCH *pUrlSearch);
    ~CFolderSearches();
private:
    LONG _cRef;
    int  _iCount;
    GUID _guidDefault;
    URLSEARCH *_pUrlSearch;
};

CFolderSearches::CFolderSearches(GUID *pguid, int iCount, URLSEARCH *pUrlSearch)
{
    _cRef = 1;
    _iCount = iCount;
    _guidDefault = *pguid;
    _pUrlSearch = pUrlSearch;
}

CFolderSearches::~CFolderSearches()
{
    if (_pUrlSearch)
        LocalFree(_pUrlSearch);
}

HRESULT CFolderSearches::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CFolderSearches, IFolderSearches),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CFolderSearches::AddRef()
{
    return ++_cRef;
}

ULONG CFolderSearches::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFolderSearches::EnumSearches(IEnumUrlSearch **ppenum)
{
    HRESULT hres = E_OUTOFMEMORY;

    *ppenum = (IEnumUrlSearch *)new CStandardEnum(IID_IEnumUrlSearch, FALSE,
                _iCount, sizeof(URLSEARCH), _pUrlSearch, CopyEnumElement);
    if (*ppenum)
    {
        _pUrlSearch = NULL;
        _iCount = 0;
        hres = S_OK;
    }
    return hres;
}

HRESULT CFolderSearches::DefaultSearch(GUID *pguid)
{
    *pguid = _guidDefault;
    return S_OK;
}

HRESULT CInternetToolbar::_GetFolderSearches(IFolderSearches **ppfs)
{
    HRESULT hres = E_FAIL;

    *ppfs = NULL;
    if (_hdpaFSI)
    {
        LPURLSEARCH pUrlSearch = NULL;
        int iCount = 0;
        int cFSIs = DPA_GetPtrCount(_hdpaFSI);

        hres = E_OUTOFMEMORY;
        if (cFSIs > 0
            && ((pUrlSearch = (LPURLSEARCH)LocalAlloc(LPTR, sizeof(URLSEARCH)*cFSIs)) != NULL))
        {
            LPFOLDERSEARCHITEM pfsi;
            int i;

            // insert per folder items
            for (i = 0; i < cFSIs && (pfsi = (LPFOLDERSEARCHITEM)DPA_GetPtr(_hdpaFSI, i)) != NULL; i++)
            {
                CLSID  clsid;

                // check if Url is actually a GUID. if yes we cannot enumerate it because
                // we need Title/Url pair.
                if (!GUIDFromStringW(pfsi->wszUrl, &clsid))
                {
                    lstrcpynW(pUrlSearch[iCount].wszName, pfsi->wszName, ARRAYSIZE(pUrlSearch[iCount].wszName));
                    lstrcpynW(pUrlSearch[iCount].wszUrl,  pfsi->wszUrl,  ARRAYSIZE(pUrlSearch[iCount].wszUrl));
                    iCount++;
                }
            }
        }
        *ppfs = new CFolderSearches(&_guidDefaultSearch, iCount, pUrlSearch);
        if (*ppfs)
            hres = S_OK;
        else
            LocalFree(pUrlSearch);
    }
    return hres;
}

BOOL CInternetToolbar::_GetSearchUrl(LPWSTR pwszUrl, DWORD cch)
{
    BOOL        bRet = FALSE;
    HKEY        hkey;

    if (pwszUrl)
    {
        pwszUrl[0] = L'\0';

        // if we are looking for web search url bypass the registry lookup and the
        // per folder items and go straight to GetDefaultSearchUrl which call
        // GetSearchAssistantUrlW
        if (!IsEqualGUID(_guidDefaultSearch, SRCID_SWebSearch))
        {
            // _GetSearchHKEY looks in the registry where shell search items are registered
            // if we have old shell32 then we don't display shell search items so we should
            // not look in the registry
            if (GetUIVersion() >= 5 && _GetSearchHKEY(_guidDefaultSearch, &hkey))
            {
                DWORD cb = cch*sizeof(TCHAR);
                TCHAR szGuid[GUIDSTR_MAX];
                DWORD cbGuid = sizeof(szGuid);

                // is there a url key
                if (SHGetValueW(hkey, REG_SZ_SEARCH_URL, NULL, NULL, pwszUrl, &cb) == ERROR_SUCCESS)
                    bRet = TRUE;
                // no? try the default value, maybe it's the clsid
                else if (SHGetValueW(hkey, NULL, NULL, NULL, szGuid, &cbGuid) == ERROR_SUCCESS)
                {
                    GUID guid;
                    // is it a valid guid string
                    if (GUIDFromString(szGuid, &guid))
                    {
                        StrCpyNW(pwszUrl, szGuid, cch);
                        bRet = TRUE;
                    }
                }

                RegCloseKey(hkey);
            }
            // maybe it's one of the per-folder items...
            else if (_hdpaFSI) //FSI = folder search items
            {
                int i;
                LPFOLDERSEARCHITEM pfsi;

                for (i=0; (pfsi = (LPFOLDERSEARCHITEM)DPA_GetPtr(_hdpaFSI, i)) != NULL; i++)
                {
                    if (IsEqualGUID(_guidDefaultSearch, pfsi->guidSearch))
                    {
                        StrCpyNW(pwszUrl, pfsi->wszUrl, cch);
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }

        if (!bRet)
            bRet = SUCCEEDED(GetDefaultSearchUrl(pwszUrl, cch));
    }

    return bRet;
}

void CInternetToolbar::_SetSearchStuff()
{
    UINT uiState;
    BOOL bChecked = FALSE;

    if (SUCCEEDED(GetState(&CLSID_CommonButtons, TBIDM_SEARCH, &uiState)))
        bChecked = uiState & TBSTATE_CHECKED;

    if (!_hdpaFSI)
    {
        _hdpaFSI = DPA_Create(2);
    }
    else
    {
        DPA_EnumCallback(_hdpaFSI, DeleteDPAPtrCB, NULL); // delete all ptrs
        DPA_DeleteAllPtrs(_hdpaFSI); // now tell hdpa to forget about them
    }

    // this is bogus -- _fShellView is always FALSE when using automation
    if (_fShellView)
        _guidDefaultSearch = SRCID_SFileSearch;
    else
        _guidDefaultSearch = SRCID_SWebSearch;

    // get per folder search items and the default search (if any)
    // and insert them to _himlSrc
    _GetFolderSearchData();

    if (!bChecked)
    {
        _guidCurrentSearch = _guidDefaultSearch;
    }
}

//
// CInternetToolbar::SetCommandTarget()
//
// This function sets the current command target and button group.  A client calls this
// before merging in buttons with the AddButtons method.
//
// There are a couple of tricky things about this function.
//
// NTRAID#NTBUG9-196149-2000/12/11-AIDANL  Hide Address Bar by default in explorer for Per/Pro
//      We no longer allow dwFlags to set links, address, tools, brand, relying on 
//      CInternetToolbar::_LoadDefaultSettings() for those settings.
//
// One is that the client can pass some flags (dwFlags param) specifying the bands it wants
// showing by default (menu, links, address, tools, brand, external).  But we don't let them change
// the state of the menu band.  And, if another client has already set the default bands, we
// don't let them change the state of any of the bands.
//
// The other is that we do some stuff to figure out if the caller is just another instantiation of the same
// client.  If we think this is a new client (new guidButtonGroup), we flush the toolbar and return S_OK.
// But if we think this is the same client reincarnated (same guidButtonGroup and non-NULL command target),
// we return S_FALSE without flushing the toolbar.  This is done for performance.  A new dochost is instantiated
// on each navigation, but its toolbar buttons never change, so don't bother remerging its toolbar buttons.
//
HRESULT CInternetToolbar::SetCommandTarget(IUnknown* punkCmdTarget, const GUID* pguidButtonGroup, DWORD dwFlags)
{
    if (!pguidButtonGroup || !punkCmdTarget || IsEqualGUID(CLSID_CommonButtons, *pguidButtonGroup))
        return E_INVALIDARG;

    // RAID 196149 - disallow changes to links, address, tools, brand, instead use _cs.uiVisible for these settings
    dwFlags = dwFlags & ~(VBF_LINKS| VBF_ADDRESS | VBF_TOOLS | VBF_BRAND);
    dwFlags |= (_cs.uiVisible & (VBF_LINKS| VBF_ADDRESS | VBF_TOOLS | VBF_BRAND));

    // this should not change the menu bit or external bands.
    dwFlags |= (_nVisibleBands & (VBF_MENU | VBF_EXTERNALBANDS));

    _btb._fCustomize = !((dwFlags & VBF_NOCUSTOMIZE) || SHRestricted2(REST_NOTOOLBARCUSTOMIZE, NULL, 0));

    // if the new button group is the internet button group, then we're
    // in internet mode; else we're in shell mode
    _fShellView = !(_IsDocHostGUID(pguidButtonGroup));

    _SetSearchStuff();

    HRESULT hr = S_FALSE;

    BOOL fNewButtonGroup = !IsEqualGUID(*pguidButtonGroup, _btb._guidCurrentButtonGroup);
    BOOL fNewCommandTarget = !SHIsSameObject(_btb._pctCurrentButtonGroup, punkCmdTarget);

    // when changing button groups we need to invalidate our cache of buttons for customization
    // why? well, with browse in separate process not turned on, navigating from shell to web
    // reuses the toolbar and some buttons may be disabled for shell but not for browser and vice versa.
    if (fNewButtonGroup)
        _iButtons = -1;
        
    if (fNewButtonGroup || fNewCommandTarget) 
    {
        if (_btb._pctCurrentButtonGroup)
            _btb._pctCurrentButtonGroup->Exec(&IID_IExplorerToolbar, ETCMDID_NEWCOMMANDTARGET, 0, NULL, NULL);

        _btb._guidCurrentButtonGroup = *pguidButtonGroup;
        ATOMICRELEASE(_btb._pctCurrentButtonGroup);
        punkCmdTarget->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_btb._pctCurrentButtonGroup));

        // A new view can tell us how many rows of text it NEEDs.
        // if it doesn't specify, we give it the default. (stored in _uiDefaultTBTextRows)
        if (dwFlags & VBF_ONELINETEXT )
            _uiTBTextRows = 1;
        else if (dwFlags & VBF_TWOLINESTEXT)
            _uiTBTextRows = 2;
        else
            _uiTBTextRows = _uiTBDefaultTextRows;

        _CompressBands(_fCompressed, _uiTBTextRows, FALSE);

        if (fNewButtonGroup) 
        {
            // new button group; flush toolbar
            _btb._RemoveAllButtons();
            hr = S_OK;
        }

        if (_fUsingDefaultBands && !_fTheater)
            _fUsingDefaultBands = FALSE;
        else
            dwFlags = _nVisibleBands;

        if (dwFlags)
            _ShowBands(dwFlags);
    }

    return hr;
}

HRESULT CInternetToolbar::AddStdBrowserButtons()
{
    //
    // code to add browser buttons has moved to CDocObjectHost::_AddButtons
    //
    ASSERT(0);
    return E_NOTIMPL;
}

void CInternetToolbar::_ReloadButtons()
{
    if (!IsEqualGUID(_btb._guidCurrentButtonGroup, CLSID_CommonButtons) &&
            _btb._pctCurrentButtonGroup)
    {
        HRESULT hres = _btb._pctCurrentButtonGroup->Exec(&IID_IExplorerToolbar, ETCMDID_RELOADBUTTONS, 0, NULL, NULL);
        if (FAILED(hres))
            AddButtons(&_btb._guidCurrentButtonGroup, _btb._cBtnsAdded, _btb._pbtnsAdded);

#ifdef EDIT_HACK
        _InitEditButtonStyle();
#endif

        _UpdateToolbar(TRUE);
    }
}

// The cmdTarget should have already added the Imagelists and the strings.
HRESULT CInternetToolbar::AddButtons(const GUID* pguidButtonGroup, UINT nNewButtons, const TBBUTTON * lpButtons)
{
    if (!pguidButtonGroup || !IsEqualGUID(*pguidButtonGroup, _btb._guidCurrentButtonGroup))
        return E_INVALIDARG;

    if (!IsWindow(_btb._hwnd))
        return E_FAIL;

    LPTBBUTTON lpTBCopy = (LPTBBUTTON)LocalAlloc(LPTR, nNewButtons * sizeof(TBBUTTON));
    if (!lpTBCopy)
        return E_OUTOFMEMORY;

    _CreateBands();
    _btb._RemoveAllButtons();

    memcpy(lpTBCopy, lpButtons, sizeof(TBBUTTON) * nNewButtons);

    nNewButtons = _btb._ProcessExternalButtons(lpTBCopy, nNewButtons);

    // Free the old button array
    _btb._FreeBtnsAdded();

    _btb._pbtnsAdded = lpTBCopy;
    _btb._cBtnsAdded = nNewButtons;

    if (_btb._fCustomize && _btb._SaveRestoreToolbar(FALSE))
    {
        // Customization mechanism filled the toolbar for us

        // 
        // The customization mechanism allocated its own set of
        // cmdmaps for the buttons, which means that we need to
        // free those hanging off _pbtnsAdded when _pbtnsAdded is
        // freed.
        //
        _btb._fNeedFreeCmdMapsAdded = TRUE;
        
        _btb._RecalcButtonWidths();

#ifdef EDIT_HACK
        //
        // If we had a custom edit glyph, reload it so that we
        // don't momentarily flash the default glyph during
        // navigation.  We'll update it again when we get a
        // DISPID_DOCUMENTCOMPLETE event.
        //
        _RefreshEditGlyph();
#endif //EDIT_HACK

        if (!_fShellView)
        {
            _btb._AddMediaBarButton();
        }
    }
    else
    {
        // No customization found for this button group

        //
        // We're adding the button array to toolbar directly,
        // and the cmdmaps get freed on TBN_DELETINGBUTTON, so
        // we shouldn't also try to free them when _pbtnsAdded
        // is freed.
        //
        _btb._fNeedFreeCmdMapsAdded = FALSE;

        _AddCommonButtons();
        SendMessage(_btb._hwnd, TB_ADDBUTTONS, nNewButtons, (LPARAM)lpTBCopy);
    }

    _bs._SetMinDimensions();
    return S_OK;
}

HRESULT CInternetToolbar::AddString(const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LONG_PTR *pOffset)
{
    TraceMsg(DM_ITBAR, "CITBar::AddString called");

    *pOffset = -1;

    if (!IsWindow(_btb._hwnd))
    {
        TraceMsg(DM_ERROR, "CITBar::AddString failed");
        return E_FAIL;
    }

    *pOffset= SendMessage(_btb._hwnd, TB_ADDSTRING, (WPARAM)hInst, (LPARAM)uiResID);

    if (*pOffset != -1)
        return S_OK;

    TraceMsg(DM_ERROR, "CITBar::AddString failed");
    return E_FAIL;
}

HRESULT CInternetToolbar::GetButton(const GUID* pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    UINT_PTR uiIndex = 0;
    TraceMsg(DM_ITBAR, "CITBar::GetButton called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        uiIndex = SendMessage(_btb._hwnd, TB_COMMANDTOINDEX, uiCommand, 0L);
        if (SendMessage(_btb._hwnd, TB_GETBUTTON, uiIndex, (LPARAM)lpButton))
        {
            GUID guid;
            _btb._ConvertCmd(NULL, lpButton->idCommand, &guid, (UINT*)&lpButton->idCommand);
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CInternetToolbar::GetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT * pfState)
{
    TraceMsg(DM_ITBAR, "CITBar::GetState called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        *pfState = (UINT)SendMessage(_btb._hwnd, TB_GETSTATE, uiCommand, 0L);
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CInternetToolbar::SetState(const GUID* pguidButtonGroup, UINT uiCommand, UINT fState)
{
    BOOL bIsSearchBtn;

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    TraceMsg(DM_ITBAR, "CITBar::SetState called");

    bIsSearchBtn = uiCommand == TBIDM_SEARCH;
    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        UINT_PTR uiState;

        uiState = SendMessage(_btb._hwnd, TB_GETSTATE, uiCommand, NULL);
        uiState ^= fState;
        if (uiState)
        {
            // search button is being unchecked, change the icon to the default search's
            if (bIsSearchBtn && !(fState & TBSTATE_CHECKED) && !IsEqualGUID(_guidCurrentSearch, _guidDefaultSearch))
            {
                _guidCurrentSearch = _guidDefaultSearch;
            }
            if (SendMessage(_btb._hwnd, TB_SETSTATE, uiCommand, (LPARAM)fState))
            {
                if (uiState & TBSTATE_HIDDEN)
                    _bs._SetMinDimensions();
            }
        }
        return S_OK;
    }
    return E_FAIL;
}

//
//  A bitmap can be added in two ways:
//  1.  Send a bitmap in the hBMPNew field. The uiBMPType parameter needs to be a BITMAP_BMP*
//      The uiCount and the ptb parameters are ignored
//      The offset is placed in puiOffset
//
//  2.  A TBADDBITMAP struct can be sent. The uiCount should have the count
//      uiBMPType parameter needs to be a BITMAP_TBA* value
//      The offset is placed in puiOffset
HRESULT CInternetToolbar::AddBitmap(const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb, LRESULT * pOffset, COLORREF rgbMask)
{
    UINT uiGetMSG, uiSetMSG;
    TBBMP_LIST tbl = {NULL};

    TraceMsg(DM_ITBAR, "CITBar::AddBitmap called");
    *pOffset = -1;

    _CreateBands();
    if ((!pguidButtonGroup) || (!IsWindow(_btb._hwnd)) || !_hdsaTBBMPs)
    {
        TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - NULL pguidButtonGroup or invalid _hwnd");
        return E_FAIL;
    }

    // See if we already have the bitmap loaded.
    TBBMP_LIST * pTBBs = NULL;
    int nCount = DSA_GetItemCount(_hdsaTBBMPs);
    for (int nIndex = 0; nIndex < nCount; nIndex++)
    {
        pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
        if ((pTBBs) && (pTBBs->hInst == ptb->hInst) && (pTBBs->uiResID == ptb->nID))
            break;
        pTBBs = NULL;
    }

    // If it was in the commctrl, then we should already have an entry in the DSA
    if ((ptb->hInst == HINST_COMMCTRL) && (!pTBBs))
    {
        TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - bogus ResID for HINST_COMMCTL");
        return E_FAIL;
    }

    // If the icons being added are from fontsext.dll or from dialup networking
    // or the briefcase, then we have it. So just send return the offset
    if (ptb->hInst != HINST_COMMCTRL)
    {
        TCHAR szDLLFileName[MAX_PATH], *pszFN;
        memset(szDLLFileName, 0, ARRAYSIZE(szDLLFileName));
        if (GetModuleFileName(ptb->hInst, szDLLFileName, ARRAYSIZE(szDLLFileName)))
        {
            pszFN = PathFindFileName(szDLLFileName);
            if(!lstrcmpi(pszFN, TEXT("fontext.dll")))
                *pOffset = FONTGLYPH_OFFSET;
            else if (!lstrcmpi(pszFN, TEXT("shell32.dll")))
            {
                // 140 and 141 are the glyphs that Shell32.dll uses:
                // IDB_BRF_TB_SMALL        140
                // IDB_BRF_TB_LARGE        141
                if ((ptb->nID == 140) || (ptb->nID == 141))
                    *pOffset = BRIEFCASEGLYPH_OFFSET;
            }
            else if (!lstrcmpi(pszFN, TEXT("rnaui.dll")))
                *pOffset = RNAUIGLYPH_OFFSET;
            else if (!lstrcmpi(pszFN, TEXT("webcheck.dll")))
                *pOffset = WEBCHECKGLYPH_OFFSET;
            if (*pOffset != -1)
                return S_OK;
        }
    }

    // So the bitmaps is not from commctrl. And we have never seen this before.
    // Add an entry into the DSA and then add the bitmap to the himage list.
    if (!pTBBs)
    {
        tbl.hInst = ptb->hInst;
        tbl.uiResID = ptb->nID;
        nIndex = DSA_AppendItem(_hdsaTBBMPs, &tbl);
        if (nIndex  < 0)
        {
            TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - nIndex < 0!");
            return E_FAIL;
        }
        pTBBs = (TBBMP_LIST*)DSA_GetItemPtr(_hdsaTBBMPs, nIndex);
        if (!pTBBs)
        {
            TraceMsg(DM_ERROR, "CITBar::AddBitmap failed - pTBBS is NULL!");
            return E_FAIL;
        }
    }


    switch(uiBMPType)
    {
    case BITMAP_NORMAL:
        if ((pTBBs) && (pTBBs->fNormal))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fNormal = TRUE;

        uiGetMSG = TB_GETIMAGELIST; uiSetMSG = TB_SETIMAGELIST;
        break;

    case BITMAP_HOT:
        if ((pTBBs) && (pTBBs->fHot))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fHot = TRUE;

        uiGetMSG = TB_GETHOTIMAGELIST; uiSetMSG = TB_SETHOTIMAGELIST;
        break;

    case BITMAP_DISABLED:
        if ((pTBBs) && (pTBBs->fDisabled))
        {
            *pOffset = pTBBs->uiOffset;
            return S_OK;
        }
        else if (pTBBs)
            pTBBs->fDisabled = TRUE;

        uiGetMSG = TB_GETDISABLEDIMAGELIST; uiSetMSG = TB_SETDISABLEDIMAGELIST;
        break;

    default:
        ASSERT(FALSE);
        return E_FAIL;
    }
    pTBBs->uiCount = uiCount;
    
    *pOffset = _AddBitmapFromForeignModule(uiGetMSG, uiSetMSG, uiCount, ptb->hInst, ptb->nID, rgbMask);
    if (pTBBs)
        pTBBs->uiOffset = (UINT)*pOffset;

    return S_OK;
}

// the CmdTarget needs to call this to see what size of bmps we are using.
HRESULT CInternetToolbar::GetBitmapSize(UINT * uiSize)
{
    TraceMsg(DM_ITBAR, "CITBar::GetBitmapSize called");

    *uiSize = g_fSmallIcons ? MAKELONG(TB_SMBMP_CX, TB_SMBMP_CY) : MAKELONG(g_iToolBarLargeIconWidth,g_iToolBarLargeIconHeight);
    return S_OK;
}

HRESULT CInternetToolbar::SetImageList( const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled)
{
    if (IsEqualGUID(*pguidCmdGroup, _btb._guidCurrentButtonGroup))
    {
        SendMessage(_btb._hwnd, TB_SETIMAGELIST, 1, (LPARAM)himlNormal);
        SendMessage(_btb._hwnd, TB_SETHOTIMAGELIST, 1, (LPARAM)himlHot);
        SendMessage(_btb._hwnd, TB_SETDISABLEDIMAGELIST, 1, (LPARAM)himlDisabled);
    }
    return S_OK;
}

HRESULT CInternetToolbar::ModifyButton( const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton)
{
    UINT uiIndex = 0;
    TraceMsg(DM_ITBAR, "CITBar::ModifyButton called");

    if (!pguidButtonGroup || !IsWindow(_btb._hwnd))
        return E_FAIL;

    if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, uiCommand, NULL, &uiCommand)))
    {
        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_STATE | TBIF_IMAGE;
        tbbi.fsState = lpButton->fsState;
        tbbi.iImage = lpButton->iBitmap;

        if (SendMessage(_btb._hwnd, TB_SETBUTTONINFO, uiCommand, (LPARAM)&tbbi))
        {
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CInternetToolbar::SendToolbarMsg(const GUID* pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes)
{
    LRESULT lRes;
    if (!IsWindow(_btb._hwnd))
    {
        TraceMsg(DM_ERROR, "CITBar::SendToolbarMsg Message failed");
        return E_FAIL;
    }

    if (
        // this api is only here for back compat, and these messages didn't
        // exist when the old clients were written

        uMsg == TB_GETBUTTONINFOA ||
        uMsg == TB_GETBUTTONINFOW ||
        uMsg == TB_SETBUTTONINFOA ||
        uMsg == TB_SETBUTTONINFOW ||

        // unsupported right now
        uMsg == TB_ADDBUTTONSA || uMsg == TB_ADDBUTTONSW
       )
    {

        ASSERT(0);
        return E_FAIL;
    }



    if ((uMsg == TB_ENABLEBUTTON) || (uMsg == TB_HIDEBUTTON) || (uMsg == TB_CHECKBUTTON) ||
        (uMsg == TB_PRESSBUTTON) || (uMsg == TB_MARKBUTTON))
    {
        unsigned int uiTemp;
        if (SUCCEEDED(_btb._ConvertCmd(pguidButtonGroup, (UINT)wParam, NULL, &uiTemp)))
            wParam = uiTemp;
    }

    if (uMsg == TB_INSERTBUTTON && lParam)
    {
        TBBUTTON btn = (*(TBBUTTON*)lParam);
        _btb._PreProcessExternalTBButton(&btn);
        lRes = SendMessage(_btb._hwnd, uMsg, wParam, (LPARAM)&btn);
    }
    else
    {
        lRes = SendMessage(_btb._hwnd, uMsg, wParam, lParam);

        if (uMsg == TB_GETBUTTON)
        {
            TBBUTTON* pbtn = (TBBUTTON*)lParam;
            if (pbtn && pbtn->dwData)
            {
                CMDMAP* pcm = (CMDMAP*)pbtn->dwData;
                pbtn->idCommand = pcm->nCmdID;
                pbtn->dwData = pcm->lParam;
            }
        }
    }

    if (plRes)
        *plRes = lRes;
    return S_OK;
}

TOOLSBANDCLASS::CBrowserToolsBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
}

#define DEFAULT_LIST_VALUE()    (GetUIVersion() >= 5)

void TOOLSBANDCLASS::_FreeBtnsAdded()
{
    if (_pbtnsAdded)
    {
        if (_fNeedFreeCmdMapsAdded)
        {
            for (int i = 0; i < _cBtnsAdded; i++)
            {
                CMDMAP* pcm = (CMDMAP*)_pbtnsAdded[i].dwData;
                _FreeCmdMap(pcm);
            }
        }

        LocalFree(_pbtnsAdded);

        _pbtnsAdded = NULL;
        _cBtnsAdded = 0;
    }
}

LRESULT TOOLSBANDCLASS::_ToolsCustNotify (LPNMHDR pnmh)
{
    LPTBNOTIFY ptbn = (LPTBNOTIFY) pnmh;

    switch (pnmh->code)
    {

    case TBN_SAVE:
    {
        NMTBSAVE *pnmtbs = (NMTBSAVE*)pnmh;
        if (pnmtbs->iItem == -1)
        {
            // before the save
            int nButtons = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);
            int uSize = pnmtbs->cbData +
                        sizeof(BUTTONSAVEINFO) * nButtons +  // stuff for each button
                        sizeof(TOOLBARSAVEINFO); // stuff for the toolbar
            pnmtbs->pData = (LPDWORD)LocalAlloc(LPTR, uSize);
            pnmtbs->pCurrent = pnmtbs->pData;
            pnmtbs->cbData = uSize;

            if (pnmtbs->pData)
            {
                TOOLBARSAVEINFO *ptbsi = (TOOLBARSAVEINFO*)pnmtbs->pData;
                ptbsi->cVersion = TBSI_VERSION;
                pnmtbs->pCurrent = (LPDWORD)(ptbsi+1);
            }
        }
        else
        {
            CMDMAP *pcm = (CMDMAP*)pnmtbs->tbButton.dwData;
            BUTTONSAVEINFO* pbsi = (BUTTONSAVEINFO*)pnmtbs->pCurrent;
            pnmtbs->pCurrent = (LPDWORD)(pbsi+1);
            if (pcm)
            {
                pbsi->guid = pcm->guidButtonGroup;
                pbsi->nCmdID = pcm->nCmdID;
                pbsi->fButtonState = pnmtbs->tbButton.fsState;
#ifdef DEBUG
                TCHAR szGuid[80];
                SHStringFromGUID(pcm->guidButtonGroup, szGuid, ARRAYSIZE(szGuid));
                TraceMsg(TF_TBCUST, "Saving: %s - %d (%x)", szGuid, pbsi->nCmdID, pbsi->nCmdID);
#endif
            }
            else
            {
                ASSERT(pnmtbs->tbButton.fsStyle & BTNS_SEP);
                if (pnmtbs->tbButton.idCommand)
                {
                    TraceMsg(TF_TBCUST, "Saving: a separator w/ id %d (%x)", pnmtbs->tbButton.idCommand, pnmtbs->tbButton.idCommand);
                    pbsi->guid = CLSID_Separator;
                    pbsi->nCmdID = pnmtbs->tbButton.idCommand;
                }
                else
                {
                    TraceMsg(TF_TBCUST, "Saving: a separator");
                }
            }
        }
        break;
    }

    case TBN_RESTORE:
        {
            NMTBRESTORE* pnmtbr = (NMTBRESTORE*)pnmh;
            if (pnmtbr->iItem == -1)
            {
                // before the restore.
                // take the data, verify the version,
                // fill in the button count, bytes per record
                // initialize the pCurrent to the end of the tb header
                //
                TOOLBARSAVEINFO* ptbsi = (TOOLBARSAVEINFO*)pnmtbr->pCurrent;
                if (ptbsi->cVersion != TBSI_VERSION)
                {
                    TraceMsg( TF_WARNING, "TOOLSBANDCLASS::_ToolsCustNotify() - Wrong Toolbar Save Info Version (0x%x vs. 0x%x)!", ptbsi->cVersion, TBSI_VERSION );
                    return 1; // abort
                }


                // we're actually going to do a restore.  initialize our database:
                _BuildButtonDSA();

                pnmtbr->pCurrent = (LPDWORD)(ptbsi+1);
                pnmtbr->cbBytesPerRecord += sizeof(BUTTONSAVEINFO);
                pnmtbr->cButtons = (pnmtbr->cbData - sizeof(TOOLBARSAVEINFO)) / pnmtbr->cbBytesPerRecord;
                // make sure we did the math right and there are no remainders
                ASSERT(((pnmtbr->cbData - sizeof(TOOLBARSAVEINFO)) % pnmtbr->cbBytesPerRecord) == 0);

                //this is going to clobber all of the buttons in the current toolbar.
                // since toolbar control just writes over the dwords, we need to go free them now.
                int nButtons = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);

                for (int nTemp = 0; nTemp < nButtons; nTemp++)
                {
                    CMDMAP *pcm = _GetCmdMapByIndex(nTemp);
                    _FreeCmdMap(pcm);
                    TBBUTTONINFO tbbi;
                    tbbi.cbSize = sizeof(tbbi);
                    tbbi.lParam = (LPARAM)NULL;
                    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
                    SendMessage(_hwnd, TB_SETBUTTONINFO, nTemp, (LPARAM)&tbbi);
                }
            }
            else
            {
                BUTTONSAVEINFO* pbsi = (BUTTONSAVEINFO*)pnmtbr->pCurrent;
                pnmtbr->pCurrent = (LPDWORD)(pbsi+1);
                pnmtbr->tbButton.dwData = 0;
                pnmtbr->tbButton.iString = -1;

                if (IsEqualGUID(CLSID_Separator, pbsi->guid))
                {
                    // restore a separator with a command id
                    pnmtbr->tbButton.fsStyle = BTNS_SEP;
                    TraceMsg(TF_TBCUST, "Restoring: a separator w/ id %d (%x)", pnmtbr->tbButton.idCommand, pnmtbr->tbButton.idCommand);
                }
                else if (!(pnmtbr->tbButton.fsStyle & BTNS_SEP))
                {
                    // Make sure that the button exists for this site
                    CMDMAPCUSTOMIZE* pcmc = _GetCmdMapCustomize(&pbsi->guid, pbsi->nCmdID);
                    if ((pcmc == NULL) || (SHRestricted(REST_NONLEGACYSHELLMODE) && ((pbsi->nCmdID == TBIDM_BACK) || (pbsi->nCmdID == TBIDM_FORWARD))))
                    {
                        // Ignore this button
                        return 1;
                    }

                    CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
                    if (pcm)
                    {
                        pcm->guidButtonGroup = pbsi->guid;
                        pcm->nCmdID = pbsi->nCmdID;

#ifdef DEBUG
                        TCHAR szGuid[80];
                        SHStringFromGUID(pcm->guidButtonGroup, szGuid, ARRAYSIZE(szGuid));
                        TraceMsg(TF_TBCUST, "Restoring: %s - %d (%x)", szGuid, pbsi->nCmdID, pbsi->nCmdID);
#endif

                        // fill in the rest of the info
                        pnmtbr->tbButton = pcmc->btn;
                        pnmtbr->tbButton.fsState = pbsi->fButtonState;
                        pnmtbr->tbButton.dwData = (DWORD_PTR) pcm;

                    }
                }
                else
                {
                    TraceMsg(TF_TBCUST, "Restoring: a separator");
                }
            }
        }
        break;

    case TBN_ENDADJUST:
        _OnEndCustomize();
        break;

    case TBN_TOOLBARCHANGE:
        _pcinfo->fDirty = TRUE;
        break;

    case TBN_INITCUSTOMIZE:
        _OnBeginCustomize((NMTBCUSTOMIZEDLG*)pnmh);
        return TBNRF_HIDEHELP;

    case TBN_RESET:
        _pcinfo->fDirty = FALSE;
        if (_pctCurrentButtonGroup)
        {
            NMTBCUSTOMIZEDLG *pnm = (NMTBCUSTOMIZEDLG*)pnmh;
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            TCHAR szGuid[GUIDSTR_MAX];
            SHStringFromGUID(_guidCurrentButtonGroup, szGuid, ARRAYSIZE(szGuid));
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_TOOLBAR, szGuid);

            // Default text labels setting should be as follows:
            //
            //  If fullscreen mode, any platform -- "No text labels"
            //  Else if NT5 -- "Selective text on right"
            //  Else  -- "Show text labels"
            //
            int idsDefault;

            if (pitbar->_fTheater)
                idsDefault = IDS_NOTEXTLABELS;
            else if (DEFAULT_LIST_VALUE())
                idsDefault = IDS_PARTIALTEXT;
            else
                idsDefault = IDS_TEXTLABELS;

            _UpdateTextSettings(idsDefault);

            HWND hwnd = (HWND) GetProp(pnm->hDlg, SZ_PROP_CUSTDLG);
            if (hwnd)
            {
                // update our dialog's control selection states
                _SetDialogSelections(hwnd, _DefaultToSmallIcons());
            }

            _RemoveAllButtons();
            _OnEndCustomize();
            if (_pbtnsAdded)
            {
                pitbar->AddButtons(&_guidCurrentButtonGroup, _cBtnsAdded, _pbtnsAdded);

#ifdef EDIT_HACK
                // Restore the edit button
                pitbar->_InitEditButtonStyle();
#endif

                pitbar->_UpdateToolbar(TRUE);
            }
            else
            {
                return TBNRF_ENDCUSTOMIZE;
            }
        }
        break;

    case TBN_QUERYINSERT:
        return TRUE;

    case TBN_QUERYDELETE:
        return (SendMessage(_hwnd, TB_ISBUTTONHIDDEN,
                            (WPARAM) ptbn->tbButton.idCommand,
                            (LPARAM) 0)) ? FALSE : TRUE;

    case TBN_GETBUTTONINFO:
        if (ptbn->iItem < DSA_GetItemCount(_pcinfo->hdsa))
        {
            CMDMAPCUSTOMIZE *pcmc;
            pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, ptbn->iItem);
            ptbn->tbButton = pcmc->btn;
            ptbn->tbButton.fsState &= ~TBSTATE_HIDDEN;
            return TRUE;
        }
        return FALSE;

    case TBN_BEGINADJUST:
        if (!_pcinfo || !_pcinfo->fAdjust)
            return 1;
        break;

    }
    return FALSE;
}

BOOL TOOLSBANDCLASS::_SaveRestoreToolbar(BOOL fSave)
{
    TBSAVEPARAMS tbsp;
    TCHAR szGuid[GUIDSTR_MAX];
    SHStringFromGUID(_guidCurrentButtonGroup, szGuid, ARRAYSIZE(szGuid));

    tbsp.hkr = HKEY_CURRENT_USER;
    tbsp.pszSubKey = REGSTR_PATH_TOOLBAR;
    tbsp.pszValueName = szGuid;
    BOOL fRet = BOOLFROMPTR(SendMessage(_hwnd, TB_SAVERESTORE, (WPARAM) fSave, (LPARAM) &tbsp));

    _FreeCustomizeInfo();
    return fRet;
}

void TOOLSBANDCLASS::_AddMediaBarButton()
{
    // Wrap this with a reg key to make sure it happens only once
    // then check to make sure it's not already in the thing

    if (_hwnd && !SHRestricted2W(REST_No_LaunchMediaBar, NULL, 0) && !SHRestricted2(REST_BTN_MEDIABAR, NULL, 0) && CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        DWORD dwType, dwSize;
        DWORD dwValue = TBBIF_NONE;
        dwSize = sizeof(dwValue);
        if (   (ERROR_SUCCESS==SHGetValue(HKEY_CURRENT_USER, TBBIF_REG_PATH, TBBIF_REG_KEY, &dwType, &dwValue, &dwSize))
            && (dwType==REG_DWORD)
            && ((dwValue & TBBIF_MEDIA) != 0))
        {
            return;
        }
        dwValue |= TBBIF_MEDIA;
        SHSetValue(HKEY_CURRENT_USER, TBBIF_REG_PATH, TBBIF_REG_KEY, REG_DWORD, &dwValue, sizeof(dwValue));

        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX | TBIF_LPARAM;

        int iFavs = -1, iHist = -1, iLastTool = -1;
        int iMedia = -1;
        
        // lookup MediaBar in current toolbar
        // this could be a previous PersonalBar since the MediaBar reuses the cmdID
        BOOL fFound = FALSE;
        int cntButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
        for (int j = 0; j < cntButtons; j++)
        {
            if (SendMessage(_hwnd, TB_GETBUTTONINFO, j, (LPARAM)&tbbi)!=-1)
            {
                CMDMAP* pcm = (CMDMAP*)tbbi.lParam;
                if (pcm)
                {
                    // already present ?
                    if (pcm->nCmdID == TBIDM_MEDIABAR)
                    {
                        fFound = TRUE;  // no need to add, only care about updating position in toolbar
                        iMedia = j;
                    }
                    // will try placing after Favorites....
                    else if (pcm->nCmdID == TBIDM_FAVORITES)
                    {
                        iFavs = j;
                        iLastTool = j;
                    }
                    // ... and/or before History
                    else if (pcm->nCmdID == TBIDM_HISTORY)
                    {
                        iHist = j;
                        iLastTool = j;
                    }
                    // ... but at least after last found button in second group
                    else if (   (pcm->nCmdID == TBIDM_SEARCH)
                             || (pcm->nCmdID == TBIDM_ALLFOLDERS))
                    {
                        iLastTool = j;
                    }
                }                
            }
        }

        // force-expose MediaBar button at least once
        if (!fFound)
        {
            TBBUTTON tbXBar;
            memcpy((VOID*)&tbXBar, (VOID*)&c_tbExplorer[TBXID_MEDIABAR], sizeof(TBBUTTON));

            CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
            if (pcm) 
            {
                pcm->guidButtonGroup = CLSID_CommonButtons;
                pcm->nCmdID = c_tbExplorer[TBXID_MEDIABAR].idCommand;

                tbXBar.idCommand = _nNextCommandID++;
                tbXBar.dwData = (LPARAM)pcm;
                SendMessage(_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tbXBar);
            }
        }

        if (iMedia < 0)
        {
            cntButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
            for (j = cntButtons - 1; j >= 0; j--)
            {
                if (SendMessage(_hwnd, TB_GETBUTTONINFO, j, (LPARAM)&tbbi)!=-1)
                {
                    CMDMAP* pcm = (CMDMAP*)tbbi.lParam;
                    if (pcm)
                    {
                        // already present ?
                        if (pcm->nCmdID == TBIDM_MEDIABAR)
                        {
                            iMedia = j;
                            break;
                        }
                    }
                }
            }
        }

        // update position of MediaBar button
        // do we know a preferred position where the MediaBar button should move to?
        if ((iMedia >= 0) && ((iFavs >= 0) || (iHist >= 0) || (iLastTool >= 0)))
        {
            int iNewPos = -1;
            if (iFavs >= 0)
            {
                iNewPos = iFavs;
            }
            else if (iHist >= 0)
            {
                iNewPos = max(iHist - 1, 0);
            }
            else if (iLastTool >= 0)
            {
                iNewPos = iLastTool;
            }

            if (iNewPos >= 0)
            {
                if (iNewPos < iMedia)
                    SendMessage(_hwnd, TB_MOVEBUTTON, iMedia, iNewPos + 1);
                else
                    SendMessage(_hwnd, TB_MOVEBUTTON, iMedia, iNewPos);

                _SaveRestoreToolbar(TRUE);
                _RecalcButtonWidths();
            }
        }

    }
}

int TOOLSBANDCLASS::_CommandFromIndex(UINT uIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_COMMAND | TBIF_BYINDEX;
    SendMessage(_hwnd, TB_GETBUTTONINFO, uIndex, (LPARAM)&tbbi);
    return tbbi.idCommand;
}

//  _btb._ConvertCmd()
//  This is used to covert a external Command ID to an internal ID or vice versa
//  If we are converting to an external ID then
//      call with pguidButtonGroup == NULL                  (to external:  pguidButtonGroup == NULL)
//      otherwise call with the external button group GUID  (to internal:  pguidOut == NULL)
HRESULT TOOLSBANDCLASS::_ConvertCmd(const GUID* pguidButtonGroup, UINT id, GUID* pguidOut, UINT * pid)
{
    HRESULT hres = E_FAIL;
    BOOL fToInternal = (bool) (pguidButtonGroup);

    ASSERT((pguidButtonGroup == NULL) ^ (pguidOut == NULL));

    // First look for the command
    if (fToInternal)
    {
        if (_hwnd)
        {
            int nCount = (int) SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
            for (int i = 0; i < nCount; i++)
            {
                CMDMAP *pcm = _GetCmdMapByIndex(i);

                if (pcm)
                {
                    // loop through the command mapping structures until we
                    // find this guid and id
                    if (IsEqualGUID(pcm->guidButtonGroup, *pguidButtonGroup) &&
                        id == pcm->nCmdID)
                    {
                        *pid = _CommandFromIndex(i);
                        hres = S_OK;
                        break;
                    }
                }
            }
        }
    }
    else
    {

        // going from toolbar id to commandtarget info
        CMDMAP *pcm = _GetCmdMapByID(id);
        if (pcm)
        {
            *pguidOut = pcm->guidButtonGroup;
            *pid = pcm->nCmdID;
            hres = S_OK;
        }
    }
    return hres;
}



LRESULT CInternetToolbar::_AddBitmapFromForeignModule(UINT uiGetMSG, UINT uiSetMSG, UINT uiCount, HINSTANCE hinst, UINT_PTR nID, COLORREF rgbMask)
{
    HBITMAP hBMPRaw = NULL, hBMPFixedUp = NULL;
    HBITMAP * phBmp = &hBMPFixedUp;
    BITMAP bmp;
    HIMAGELIST himlTemp;
    LRESULT lRes = 1L;
    BOOL fOk = TRUE;
    HDC dc = NULL, dcMemSrc = NULL, dcMemDest = NULL;
    HBITMAP hbmpOldDest = NULL, hbmpOldSrc = NULL;
    int cxOrg = 0;
    int xDest = 0, yDest = 0;
    RECT rect = {0,0,0,0};
    HBRUSH hbr = NULL;

    // What if hinst == NULL?  That means that nID is really an HBITMAP
    ASSERT( hinst != NULL );

    if (!(hBMPRaw = LoadBitmap(hinst, MAKEINTRESOURCE(nID))))
        return 0L;

    fOk = (BOOL)(GetObject(hBMPRaw, sizeof(BITMAP), &bmp) != 0);

    // Check is the size is OK
    if (fOk && (bmp.bmWidth != (LONG)(g_iToolBarLargeIconWidth * uiCount)) || (bmp.bmHeight != (LONG)g_iToolBarLargeIconHeight) )
    {
        int cxBmp;
        int cyBmp;

        if (g_fSmallIcons)
        {
            cxBmp = TB_SMBMP_CX;
            cyBmp = TB_SMBMP_CY;
        }
        else
        {
            cxBmp = g_iToolBarLargeIconWidth;
            cyBmp = g_iToolBarLargeIconHeight;
        }

        // If the height is 15, the we assume that this is one of the old bitmaps therefore
        // the width is 16. We cannot rely on the (bmp.bmWidth / uiCount) because some apps
        // like SecureFile give us a bitmap 192 wide and say that there are 10 glyphs in it.
        if (bmp.bmHeight == 15)
            cxOrg = 16;
        else
            cxOrg = bmp.bmWidth / (uiCount ? uiCount : 1);

        if (rgbMask)
            fOk = (BOOL)((hbr = CreateSolidBrush(rgbMask))!= NULL);

        if (fOk)
            fOk = (BOOL)((dc = GetDC(_btb._hwnd)) != NULL);

        if (fOk)
            fOk = (BOOL)((hBMPFixedUp = CreateCompatibleBitmap(dc, (cxBmp * uiCount), cyBmp)) != NULL);

        if (fOk)
            fOk = (BOOL)((dcMemSrc = CreateCompatibleDC(dc)) != NULL);

        if (fOk)
            fOk = (BOOL)((dcMemDest = CreateCompatibleDC(dc)) != NULL);

        if (!fOk)
            goto Error;

        hbmpOldSrc = (HBITMAP)SelectObject(dcMemSrc, hBMPRaw);
        hbmpOldDest = (HBITMAP)SelectObject(dcMemDest, hBMPFixedUp);

        rect.right = (cxBmp * uiCount);
        rect.bottom = cyBmp;
        if (rgbMask)
            FillRect(dcMemDest, &rect, hbr);

        for (UINT n = 0; n < uiCount; n++)
        {

            int cxCopy;
            int cyCopy;

            xDest = (n * cxBmp);
            if (cxOrg < cxBmp)
            {
                // if the bitmap is too small, we need to center it.
                // the amount we copy is the full bitmap
                cxCopy = cxOrg;
                xDest += ((cxBmp - cxOrg) / 2);
            }
            else
            {
                // if the bitmap is big enough, we align it to top left and
                // we strecth(shrink) it down to fit
                cxCopy = cxBmp;
            }

            if (bmp.bmHeight < cyBmp)
            {
                cyCopy = bmp.bmHeight;
                yDest = ((cyBmp - bmp.bmHeight) / 2);
            }
            else
            {
                cyCopy = cyBmp;
                yDest = 0;
            }
            StretchBlt(dcMemDest, xDest, yDest, cxOrg, bmp.bmHeight,
                   dcMemSrc, (cxOrg * n), 0, cxCopy, cyCopy, SRCCOPY);

        }

        SelectObject(dcMemDest, hbmpOldDest);
        SelectObject(dcMemSrc, hbmpOldSrc);
    }
    else
        phBmp = &hBMPRaw;

    if (!(himlTemp = (HIMAGELIST)SendMessage(_btb._hwnd, uiGetMSG, 0, 0L)))
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - uiGetMSG SendMessage Failure");
        fOk = FALSE;
        goto Error;
    }

    if (rgbMask)
        lRes = ImageList_AddMasked(himlTemp, (HBITMAP)*phBmp, rgbMask);
    else
        lRes = ImageList_Add(himlTemp, (HBITMAP)*phBmp, NULL);

    if (lRes == -1)
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - lRes == -1");
        fOk = FALSE;
        goto Error;
    }


    if (!SendMessage(_btb._hwnd, uiSetMSG, 0, (LPARAM)himlTemp))
    {
        TraceMsg(DM_ERROR, "CITBar::_AddBitmapFromForeignModule Failed - uiSetMSG SendMessage Failed");
        fOk = FALSE;
        goto Error;
    }

Error:
    if (hBMPFixedUp)
        DeleteObject(hBMPFixedUp);

    if (hBMPRaw)
        DeleteObject(hBMPRaw);

    if (dc)
        ReleaseDC(_btb._hwnd, dc);

    if (dcMemSrc)
        DeleteDC(dcMemSrc);

    if (dcMemDest)
        DeleteDC(dcMemDest);

    if (hbr)
        DeleteObject(hbr);

    if (!fOk)
        lRes = 0L;

    return lRes;
}

#define VERY_HIGH_NUMBER    4000
HRESULT CInternetToolbar::_LoadDefaultSettings()
{
    memset(&_cs, 0, sizeof(COOLBARSAVE));
    _cs.cbVer       = CBS_VERSION;

    _cs.bs[0].wID    = CBIDX_MENU;
    _cs.bs[0].cx     = VERY_HIGH_NUMBER;

    _cs.bs[1].wID    = CBIDX_BRAND;

    _cs.bs[2].wID    = CBIDX_TOOLS;
    _cs.bs[2].cx     = VERY_HIGH_NUMBER;
    _cs.bs[2].fStyle = RBBS_BREAK;

    _cs.bs[3].wID    = CBIDX_ADDRESS;
    _cs.bs[3].cx     = VERY_HIGH_NUMBER;
    _cs.bs[3].fStyle = RBBS_BREAK;

    _cs.bs[4].wID    = CBIDX_LINKS;

    if (!_fInitialPidlIsWeb)
    {
        // we're in shell view, or we're rooted.  for perf, don't bother creating the links band.
        if (IsOS(OS_WHISTLERORGREATER) && (IsOS(OS_PERSONAL)))
        {
            _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_BRAND);
        }
        else
        {
            _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_ADDRESS | VBF_BRAND);
        }
    }
    else
    {
        // web page
        _cs.uiVisible = (VBF_MENU | VBF_TOOLS | VBF_ADDRESS | VBF_LINKS | VBF_BRAND);
    }

    _cs.clsidVerticalBar = GUID_NULL;
    _cs.clsidHorizontalBar = GUID_NULL;
    _cs.fNoText = FALSE;
    _cs.fList = DEFAULT_LIST_VALUE();

    _fUsingDefaultBands = TRUE;

    return(NOERROR);
}

typedef struct tagCOOLBARSAVEv12    // IE4
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BOOL        fVertical : 1;      // The bar is oriented vertically
    BOOL        fNoText :1;         // "NoText"
    BOOL        fAutoHide : 1;      // Auto hide toolbar in theater mode
    BOOL        fStatusBar : 1;     // Status bar in theater mode
    BOOL        fSaveInShellIntegrationMode : 1;     // Did we save in shell
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[5];
} COOLBARSAVEv12;

typedef struct tagCOOLBARSAVEv15    // IE5 Beta2
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
#ifdef UNIX
    BITBOOL     fUnUsed : 28;       // unused
#endif
    BITBOOL     fVertical : 1;      // The bar is oriented vertically
    BITBOOL     fNoText :1;         // "NoText"
    BITBOOL     fList : 1;          // toolbar is TBSTYLE_LIST (text on right) + TBSTYLE_EX_MIXEDBUTTONS
    BITBOOL     fAutoHide : 1;      // Auto hide toolbar in theater mode
    BITBOOL     fStatusBar : 1;     // Status bar in theater mode
    BITBOOL     fSaveInShellIntegrationMode : 1;     // Did we save in shell integration mode?
    UINT        uiVisible;          // "Visible bands"
    UINT        cyRebar;
    BANDSAVE    bs[5];
    CLSID       clsidVerticalBar;       //clsid of bar persisted within vertical band
    CLSID       clsidHorizontalBar;
} COOLBARSAVEv15;

#define CB_V12  (sizeof(COOLBARSAVEv12))
#define CB_V13  (sizeof(COOLBARSAVEv15))
#define CB_V14  CB_V13          // 14: added fList:1 (in middle!)
#define CB_V15  CB_V14          // 15: new rbbi.fStyle semantics
#define CB_V17  (sizeof(COOLBARSAVE))

HRESULT CInternetToolbar::_LoadUpgradeSettings(ULONG cbRead)
{
    // If we shipped with the CBS_VERSION you're incrementing, you need
    // to add upgrade code here for that version, then update this assertion.
    COMPILETIME_ASSERT(CBS_VERSION == 17);

    // Double-check our size calculations.
#ifndef UNIX
    COMPILETIME_ASSERT(CB_V12 == (6 * sizeof(UINT) + CBIDX_LAST * sizeof(BANDSAVE)));
#endif
    COMPILETIME_ASSERT(CB_V12 == (CB_V15 - sizeof(CLSID) * 2));
    COMPILETIME_ASSERT(CB_V13 == (CB_V12 + 2 * sizeof(CLSID)));
    COMPILETIME_ASSERT(CB_V14 == (CB_V13 + 0));
    COMPILETIME_ASSERT(CB_V15 == (CB_V14 + 0));
    COMPILETIME_ASSERT(CB_V17 == (CB_V15 + (MAXEXTERNALBANDS * sizeof(BANDSAVE)) + (MAXEXTERNALBANDS * sizeof(CLSID))));

    // If the stream was shorter than the version data field, there's nothing we can do.
    if (cbRead < sizeof(_cs.cbVer))
    {
        return E_FAIL;
    }

    // Check to see if the version is one we know about and that the stream
    // size is the same as that version's structure size.
    if (!((_cs.cbVer == 12 && cbRead == CB_V12) ||      // IE4
          (_cs.cbVer == 13 && cbRead == CB_V13) ||      // ?
          (_cs.cbVer == 14 && cbRead == CB_V14) ||      // ?
          (_cs.cbVer == 15 && cbRead == CB_V15)))       // IE5 Beta2
    {
        return E_FAIL;
    }

    TraceMsg(DM_WARNING, "citb._lus: try upgrade %d->%d", _cs.cbVer, CBS_VERSION);

    // Make a scratch copy of _cs so we don't worry about overwriting
    // parts of _cs we need to read later.
    COOLBARSAVE cs = _cs;

    if (_cs.cbVer == 12)
    {
        // clsidVerticalBar/clsidHorizontalBar weren't a part
        // of the structure until v13
        cs.clsidVerticalBar = GUID_NULL;
        cs.clsidHorizontalBar = GUID_NULL;
    }
    else
    {
        ASSERT(_cs.cbVer < 16);

        // Band array (bs) grew in v16 to include external bands, so
        // clsidVerticalBar/clsidHorizontalBar were at a different offset.
        COOLBARSAVEv15 *pv15 = (COOLBARSAVEv15 *) &_cs;
        cs.clsidVerticalBar = pv15->clsidVerticalBar;
        cs.clsidHorizontalBar = pv15->clsidHorizontalBar;
        cs.bs[CBIDX_LAST].wID = 0xFFFFFFFF;
    }

    if (InRange(_cs.cbVer, 12, 13))
    {
        // fList was inserted into the middle of the bitbool list in v14.
        // Copy the displaced bitbools and initialize fList.
        COOLBARSAVEv12 *pv12 = (COOLBARSAVEv12 *) &_cs;
        cs.fAutoHide = pv12->fAutoHide;
        cs.fStatusBar = pv12->fStatusBar;
        cs.fSaveInShellIntegrationMode = pv12->fSaveInShellIntegrationMode;
        cs.fList = DEFAULT_LIST_VALUE();
    }

    // Force FALSE as no longer support vertical itbar mode.
    cs.fVertical = FALSE;

    // Strip off any invalid visible band bits
    cs.uiVisible &= VBF_VALID;

    // Set current version and copy scratch cs back to _cs
    cs.cbVer = CBS_VERSION;
    _cs = cs;

    return S_OK;
}

HRESULT CInternetToolbar::_LoadDefaultWidths()
{
    // If there was no max width set for the QL bar or the Toolbar, then
    // before we use the default, check it the localization people wanted to
    // increase the width. The RC file string range from '0' to '9'
    TCHAR szScratch[16];
    UINT uiExtraWidth = 0;

    if (GetSystemMetrics(SM_CXSCREEN) < 650)
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_LORES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_LORES;
    }
    else
    {
        MLLoadString(IDS_TB_WIDTH_EXTRA_HIRES, szScratch, ARRAYSIZE(szScratch));
        _uiMaxTBWidth = MAX_TB_WIDTH_HIRES;
    }
    _uiMaxTBWidth += StrToInt(szScratch) * WIDTH_FACTOR;


    return(NOERROR);
}

BOOL IsClsidInHKCR(REFGUID pclsid)
{
    HKEY hkeyResult;

    if (SHRegGetCLSIDKeyW(pclsid, NULL, FALSE, FALSE, &hkeyResult) == ERROR_SUCCESS)
    {
        RegCloseKey(hkeyResult);
        return TRUE;
    }
    return FALSE;
}

typedef struct tagCOOLBARSAVEv2     // IE3
{
    UINT        cbVer;
    UINT        uiMaxTBWidth;
    UINT        uiMaxQLWidth;
    BOOL        fVertical;             // The bar is oriented vertically
    BANDSAVE    bs[4];
} COOLBARSAVEv2;

#define VBF_VALIDv2               (VBF_TOOLS | VBF_ADDRESS | VBF_LINKS)

void CInternetToolbar::_TryLoadIE3Settings()
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        COOLBARSAVEv2 cbv2;
        DWORD dwcbData = sizeof(cbv2);
        if (SHQueryValueEx(hKey, TEXT("Layout"), NULL, NULL, (LPBYTE)&cbv2, &dwcbData) == ERROR_SUCCESS)
        {
            _cs.uiMaxTBWidth = cbv2.uiMaxTBWidth;
            _cs.uiMaxQLWidth = cbv2.uiMaxQLWidth;
            // FEATURE: todo -- read in bs field too; need to do some conversions as
            // CBIDX_ numbers were zero-based and there was no menuband in IE3.
        }

        BOOL fNoText;
        dwcbData = sizeof(fNoText);
        if (SHQueryValueEx(hKey, TEXT("NoText"), NULL, NULL, (LPBYTE)&fNoText, &dwcbData) == ERROR_SUCCESS)
        {
            // Set the no-text flag.
            _cs.fNoText = BOOLIFY(fNoText);
        }

        UINT uiVisible;
        dwcbData = sizeof(uiVisible);
        if (SHQueryValueEx(hKey, TEXT("VisibleBands"), NULL, NULL, (LPBYTE)&uiVisible, &dwcbData) == ERROR_SUCCESS)
        {
            // Set the visible bands, changing only the ones that IE3 knew about.
            _cs.uiVisible = (_cs.uiVisible &~ VBF_VALIDv2) | (uiVisible & VBF_VALIDv2);
        }

        RegCloseKey(hKey);
    }
}

VOID CInternetToolbar::_UpdateLocking()
{
    // if we have no gripper then turn them off
    BANDSITEINFO bsinfo;
    bsinfo.dwMask = BSIM_STYLE;
    bsinfo.dwStyle = BSIS_LEFTALIGN | (_fLockedToolbar ? BSIS_NOGRIPPER : 0);
    _bs.SetBandSiteInfo(&bsinfo);
    _bs._UpdateAllBands(FALSE, TRUE);
    ResizeBorderDW(NULL, NULL, FALSE);
}

HRESULT CInternetToolbar::Load(IStream *pstm)
{
    ULONG  ulRead;

    //Read from the given stream and initialize the Toolbar data!

    _fLoading = TRUE;
    HRESULT hr = pstm->Read(&_cs, sizeof(COOLBARSAVE), &ulRead);
    if (SUCCEEDED(hr))
    {
        if (ulRead != sizeof(COOLBARSAVE) || _cs.cbVer != CBS_VERSION)
        {
            hr = _LoadUpgradeSettings(ulRead);
        }
    }

    if (FAILED(hr))
    {
        _LoadDefaultSettings();
    }

    ASSERT(_cs.uiVisible & VBF_MENU);
    // make sure that the settings include a menu
    _cs.uiVisible |= VBF_MENU;

    _LoadDefaultWidths();
    hr = _CreateBands();

    _UpdateLocking();
    
    //if in web view, show the last visible browser bars too
    if (!_fShellView)
    {
        VARIANT varOut = {0};
        varOut.vt = VT_I4;

        if (!IsEqualGUID(_cs.clsidVerticalBar, GUID_NULL) && IsClsidInHKCR(_cs.clsidVerticalBar))
        {
            BOOL fSearch = IsEqualGUID(_cs.clsidVerticalBar, CLSID_SearchBand) 
                           || IsEqualGUID(_cs.clsidVerticalBar, CLSID_FileSearchBand);

            WCHAR wsz[GUIDSTR_MAX];
            SHStringFromGUID((const CLSID)_cs.clsidVerticalBar, wsz, ARRAYSIZE(wsz));

#ifdef UNIX
            // IEUNIX: Donot persist/load MsgBand
            if (!IsEqualGUID(_cs.clsidVerticalBar, CLSID_MsgBand))
#endif
            {
                if (!fSearch)
                {
                    VARIANT varClsid;
                    varClsid.vt = VT_BSTR;
                    varClsid.bstrVal = wsz;

                    IUnknown_Exec(_pbs2, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &varClsid, &varOut);
                }
                else
                {
                    // if it's the search band, must be shown in this way to get correct search
                    VARIANTARG var;
                    var.vt = VT_I4;
                    var.lVal = -1;

                    Exec(&CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var);
                }
            }
        }

        if (!IsEqualGUID(_cs.clsidHorizontalBar, GUID_NULL) && IsClsidInHKCR(_cs.clsidHorizontalBar))
        {
            WCHAR wsz[GUIDSTR_MAX];
            SHStringFromGUID((const CLSID)_cs.clsidHorizontalBar, wsz, ARRAYSIZE(wsz));

            VARIANT varClsid;
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = wsz;

            IUnknown_Exec(_pbs2, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR, 1, &varClsid, &varOut);
        }
    }
    _fLoading = FALSE;

    return hr;
}

//see APPHACK note below
const GUID CLSID_AlexaVert = { 0xBA0B386CL, 0x7143, 0x11d1, 0xba, 0x8c, 0x00, 0x60, 0x08, 0x27, 0x87, 0x8d };
const GUID CLSID_AlexaHorz = { 0xBA0B386EL, 0x7143, 0x11d1, 0xba, 0x8c, 0x00, 0x60, 0x08, 0x27, 0x87, 0x8d };

void CInternetToolbar::_GetVisibleBrowserBar(UINT idBar, CLSID *pclsidOut)
{
    *pclsidOut = GUID_NULL;

    ASSERT(idBar == IDBAR_VERTICAL || idBar == IDBAR_HORIZONTAL);

    IDockingWindowFrame *psb;
    if (_psp && SUCCEEDED(_psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IDockingWindowFrame, &psb))))
    {
        IDeskBar* pdb;

        if ( (IDBAR_VERTICAL   == idBar && (SUCCEEDED(psb->FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb)) ||
             (IDBAR_HORIZONTAL == idBar && (SUCCEEDED(psb->FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb))) && pdb)) )
        {
            VARIANT varClsid = {0};

            if (SUCCEEDED(IUnknown_Exec(pdb, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 1, NULL, &varClsid)))
            {
                if (varClsid.vt == VT_BSTR)
                {
                    GUIDFromString(varClsid.bstrVal, pclsidOut);
                    VariantClear(&varClsid);
                }

//APPHACK
// Alexa 3.0 has some code so that their explorer bar persists that works in ie4. however, when ie5
// persists them, they don't handle the case where the main page has not finished loading yet, which
// causes them to fault on launch of the browser. see IE5 55895.
                if ( (IDBAR_VERTICAL   == idBar && (IsEqualGUID(*pclsidOut, CLSID_AlexaVert))) ||
                     (IDBAR_HORIZONTAL == idBar && (IsEqualGUID(*pclsidOut, CLSID_AlexaHorz))) )
                {
                    *pclsidOut = GUID_NULL;
                }
//END APPHACK
            }

            pdb->Release();
        }
        psb->Release();
    }
}

void CInternetToolbar::_BuildSaveStruct(COOLBARSAVE* pcs)
{
    REBARBANDINFO   rbbi;
    RECT rc;
    static BOOL fBrowserOnly = (WhichPlatform() != PLATFORM_INTEGRATED);

    //Save into the given stream!
    memset(pcs, 0, sizeof(COOLBARSAVE));
    pcs->cbVer = CBS_VERSION;

    // Browser Only can't load Shell Integrated streams because of the Favorites
    // shell extension created pidls unreadable by browser only which doesn't have the Favorites ShellExt
    pcs->fSaveInShellIntegrationMode = !fBrowserOnly;

    GetWindowRect(_bs._hwnd, &rc);
    pcs->cyRebar = RECTHEIGHT(rc);
    //Save the new fields.
    pcs->fAutoHide = _fAutoHide;
    pcs->fNoText = _fCompressed;
    pcs->fList = IS_LIST_STYLE(_btb._hwnd);
    pcs->uiVisible = _nVisibleBands;

    //only persist the visible bars for web view
    if (!_fShellView)
    {
        _GetVisibleBrowserBar(IDBAR_VERTICAL, &pcs->clsidVerticalBar);
        _GetVisibleBrowserBar(IDBAR_HORIZONTAL, &pcs->clsidHorizontalBar);
    }
    //else pcs->clsid*Bar nulled out by memset above

    LRESULT lStyle = GetWindowLong(_bs._hwnd, GWL_STYLE);
    pcs->fVertical = BOOLIFY(lStyle & CCS_VERT);

    pcs->uiMaxTBWidth = _uiMaxTBWidth;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_STYLE | RBBIM_SIZE | RBBIM_ID;
    int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        pcs->bs[i].wID = 0xFFFFFFFF;
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            if (rbbi.wID < CBANDSMAX)
            {
                // desk band objects have the choice of not saving there visibility
                // state
                BANDITEMDATA *pbid = _bs._GetBandItem( i );
                UINT uiMask = rbbi.wID <= CBIDX_LAST ? ( 1 << (rbbi.wID - 1) ) : EXTERNALBAND_VBF_BIT(rbbi.wID - CBIDX_LAST-1);
                if (pbid && pbid->pdb && (pcs->uiVisible & uiMask))
                {
                    OLECMD cmd;
                    cmd.cmdID = CITIDM_DISABLEVISIBILITYSAVE;
                    cmd.cmdf = 0;
                    IUnknown_QueryStatus( pbid->pdb, &CGID_PrivCITCommands, 1, &cmd, NULL );
                    if ( cmd.cmdf &  OLECMDF_ENABLED )
                    {
                        pcs->uiVisible &= ~uiMask;
                        rbbi.fStyle |= RBBS_HIDDEN;
                    }
                }
                pcs->bs[i].fStyle = rbbi.fStyle;
                pcs->bs[i].cx = rbbi.cx;
                pcs->bs[i].wID = rbbi.wID;
                if (IS_EXTERNALBAND(rbbi.wID))
                {
                    pcs->aclsidExternalBands[MAP_TO_EXTERNAL(rbbi.wID)] = _rgebi[MAP_TO_EXTERNAL(rbbi.wID)].clsid;
                }
            }
        }
    }
    // Query CShellBrowser for status bar state
    VARIANTARG v = { 0 };
    v.vt = VT_I4;
    IUnknown_Exec(_ptbsite, &CGID_ShellBrowser, FCIDM_GETSTATUSBAR,
        0, NULL, &v);
    pcs->fStatusBar = v.lVal;
}

typedef struct tagCLSID_BANDTYPE
{
    const CLSID * pclsid;
    DWORD dwBandID;
} CLSID_BANDTYPE;

CLSID_BANDTYPE c_CLSIDsToSave[] =
{
    {&CLSID_AddressBand, CBIDX_ADDRESS},
    {&CLSID_QuickLinks, CBIDX_LINKS},
};

HRESULT CInternetToolbar::Save(IStream *pstm, BOOL fClearDirty)
{
    COOLBARSAVE cs;
    HRESULT hr = S_FALSE;

    // avoid the hit of saving when we are still loading.  State will not have
    // changed, at least not enough to justify saving, until after we are loaded.
    if (_fLoading)
        return S_OK;

    // Check the dirty bit to see if we need to save.
    if (!_fDirty)
        return S_OK;

    // if we failed during creation, our current state isnt good enough to persist.
    if (_fDontSave)
        return S_OK;

    ASSERT(!_fTheater);
    _BuildSaveStruct(&cs);

    if(SUCCEEDED(hr = pstm->Write(&cs, sizeof(COOLBARSAVE), NULL)) && fClearDirty)
        _fDirty = FALSE;

    REBARBANDINFO rbbi;
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID;

    int icBands = (int) SendMessage( _bs._hwnd, RB_GETBANDCOUNT, 0, 0 );
    for (int i = 0; i < icBands; i++)
    {
        if (SendMessage(_bs._hwnd, RB_GETBANDINFO, i, (LPARAM) &rbbi))
        {
            if ((rbbi.wID == CBIDX_ADDRESS) || (rbbi.wID == CBIDX_LINKS) || IS_EXTERNALBAND(rbbi.wID))
            {
                BANDITEMDATA *pbid = _bs._GetBandItem( i );
                if (pbid && pbid->pdb)
                {
                    CLSID clsid;
                    IPersistStream *pStream;
                    if (SUCCEEDED(pbid->pdb->QueryInterface(IID_PPV_ARG(IPersistStream, &pStream))))
                    {
                        pStream->GetClassID( &clsid );
                        IStream * pstm;
                        TCHAR szGUID[MAX_PATH];
                        SHStringFromGUID( clsid, szGUID, ARRAYSIZE(szGUID) );
                        pstm = GetRegStream( _fInitialPidlIsWeb, szGUID, STGM_WRITE | STGM_CREATE );
                        if (pstm)
                        {
                            HRESULT hrInternal = _bs.SaveToStreamBS(pbid->pdb, pstm);

                            // Only return Success values
                            if (SUCCEEDED(hrInternal))
                                hr = S_OK;
                            pstm->Release();
                        }
                        pStream->Release();
                    }
                }
            }
        }
    }
    return(hr);
}

HRESULT CInternetToolbar::InitNew(void)
{
    // This shouldn't get called if Load has already been called, so assert
    // that _cs is uninitialized.
    ASSERT(_cs.cbVer == 0);

    _LoadDefaultSettings();

    // Look for any IE3 settings and override defaults with those.  (IE3
    // wrote structures directly to registry, rather than via IPersistStream).
    _TryLoadIE3Settings();

    _LoadDefaultWidths();

    return S_OK;
}

BOOL CInternetToolbar::_SendToToolband(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    return _bs._SendToToolband(hwnd, uMsg, wParam, lParam, plres);
}


HRESULT CInternetToolbar::IsDirty(void)
{
    if (_fDirty && !_fLoading)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT CInternetToolbar::QueryService(REFGUID guidService,
                                       REFIID riid, void **ppvObj)
{
    HRESULT hres = E_NOTIMPL;

    if (IsEqualIID(guidService, SID_IBandProxy))
    {
        hres = QueryService_SID_IBandProxy(SAFECAST(_ptbsitect, IUnknown *), riid, &_pbp, ppvObj);
        if(!_pbp)
        {
            // We need to create it ourselves since our parent couldn't help
            ASSERT(FALSE == _fCreatedBandProxy);

            hres = CreateIBandProxyAndSetSite(SAFECAST(_ptbsitect, IUnknown *), riid, &_pbp, ppvObj);
            if(_pbp)
            {
                ASSERT(S_OK == hres);
                _fCreatedBandProxy = TRUE;
            }
        }
        return hres;
    }
    else if (IsEqualGUID(guidService, IID_IBandSite))
    {
        return _bs.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, IID_IAddressBand))
    {
        LPBANDITEMDATA pbid = _bs._GetBandItemDataStructByID(CBIDX_ADDRESS);
        if (pbid && pbid->pdb)
        {
            return pbid->pdb->QueryInterface(riid, ppvObj);
        }
        else
        {
            *ppvObj = NULL;
            return E_FAIL;
        }
    }

    if (_psp)
        return _psp->QueryService(guidService, riid, ppvObj);


    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

//
// FEATURE: Do we really need to implement the following two functions?
// Currently nobody uses them.
//
HRESULT CInternetToolbar::GetClassID(GUID *pguid)
{
    *pguid = CLSID_InternetToolbar;
    return(S_OK);
}

HRESULT CInternetToolbar::GetSizeMax(ULARGE_INTEGER *ulMaxSize)
{
    ulMaxSize->LowPart = sizeof(COOLBARSAVE);
    ulMaxSize->HighPart = 0;
    return(S_OK);
}


CInternetToolbar::CITBandSite::CITBandSite() : CBandSite(NULL)
{
    // HACKHACK: set the initial band ID to something bigger
    //           than the number of toolbars that is in this
    //           object.  Currently those toolbars are not
    //           individual bands, but we want CBandSite to
    //           at least be aware of them.
    //
    _dwBandIDNext = CBANDSMAX;
}

HRESULT CInternetToolbar::CITBandSite::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
    pitbar->_ShowContextMenu((HWND)wParam, lParam, NULL);
    return S_OK;
}

HRESULT CInternetToolbar::CITBandSite::_Initialize(HWND hwndParent)
{
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP | RBS_DBLCLKTOGGLE |
                           WS_VISIBLE | WS_BORDER | WS_CHILD | WS_CLIPCHILDREN |
//                           WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                           0, 0, 100, 36, hwndParent, (HMENU) FCIDM_REBAR, HINST_THISDLL, NULL);

    if (_hwnd)
    {
        Comctl32_SetWindowTheme(_hwnd, TEXT("ExplorerToolbar"));
        SendMessage(_hwnd, RB_SETTEXTCOLOR, 0, CLR_DEFAULT);
        SendMessage(_hwnd, RB_SETBKCOLOR, 0, CLR_DEFAULT);
        SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
    }

    return CBandSite::_Initialize(hwndParent);
}


HRESULT CInternetToolbar::CITBandSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (!pguidCmdGroup)
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        return pitbar->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        return IUnknown_Exec(pitbar->_ptbsite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return CBandSite::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT CInternetToolbar::CITBandSite::AddBand(IUnknown *punk)
{
    HRESULT hres = CBandSite::AddBand(punk);
    if (SUCCEEDED(hres))
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        pitbar->_SetBackground();
    }
    return hres;
}

HRESULT CInternetToolbar::CITBandSite::HasFocusIO()
{
    HRESULT hres = CBandSite::HasFocusIO();
    if (hres == S_FALSE)
    {
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _bs, this);
        if (pitbar->_btb._hwnd == GetFocus())
            hres = S_OK;

    }
    return hres;
}

// This will remove all the buttons except the first 2
BOOL TOOLSBANDCLASS::_RemoveAllButtons()
{
    INT_PTR nCount = SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);

    if (!nCount)
        return FALSE;

    while (nCount-- > 0)
    {
        SendMessage(_hwnd, TB_DELETEBUTTON, nCount, 0L);
    }

    return S_OK;
}


HRESULT TOOLSBANDCLASS::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
     CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    if (!pguidCmdGroup)
    {
        /*NOTHING*/
#ifdef DEBUG
    }
    else if (IsEqualGUID(*pguidCmdGroup, IID_IExplorerToolbar))
    {
        switch(nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            // if this rips call tjgreen
            ASSERT(0);
            return E_FAIL;
        }
#endif
    }
    else if (_IsDocHostGUID(pguidCmdGroup))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_INET, nCmdID);

        if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
        {
            // the user hit the drop down
            if (pitbar->_ptbsitect && pvarargIn && pvarargIn->vt == VT_INT_PTR)
            {
                // v.vt = VT_I4;
                POINT pt;
                RECT* prc = (RECT*)pvarargIn->byref;
                pt.x = prc->left;
                pt.y = prc->bottom;

                switch (nCmdID)
                {
#ifdef EDIT_HACK
                case DVIDM_EDITPAGE:
                    {
                        // Show the edit pop-up
                        BSTR bstrURL;
                        pitbar->_pdie->get_LocationURL(&bstrURL);
                        if (bstrURL)
                        {
                            USES_CONVERSION;
                            pitbar->_aEditVerb.ShowEditMenu(pt,  pitbar->_hwnd, W2T(bstrURL));
                            SysFreeString(bstrURL);
                        }
                        break;
                    }
#endif

                default:
                    // if this rips find tjgreen
                    ASSERT(0);
                    break;
                }
            }
            return S_OK;
        }

        switch(nCmdID)
        {
        case DVIDM_EDITPAGE:
        {
            BSTR bstrURL;
            ULONG fMask = 0;
            TCHAR szCacheFileName[MAX_PATH + MAX_URL_STRING + 2];
            memset(szCacheFileName, 0, sizeof(szCacheFileName));

            pitbar->_pdie->get_LocationURL(&bstrURL);
            if (NULL == bstrURL)
                break;

            USES_CONVERSION;
            LPCTSTR szURL = W2T(bstrURL);

#ifdef EDIT_HACK
            // Use the default edit verb
            pitbar->_aEditVerb.Edit(szURL);
#else
            SHELLEXECUTEINFO sei = {0};
            LPTSTR pszTemp = PathFindExtension(szURL);

            // If we did not find an extension, we assume it is an .htm or .html
            if (*pszTemp != TEXT('.'))
            {
                if (SHVerbExists(TEXT(".htm"), TEXT("edit"), NULL))
                    sei.lpClass = TEXT(".htm");
                else
                    sei.lpClass = TEXT(".html");
            }
            else
            {
                sei.lpClass = pszTemp;
            }

            if (PathIsURL(szURL))
            {
                // (reinerf)
                // Some apps (FrontPad, Office99, etc) want the URL passed to
                // them instead of the cache filename. We therefore create a string
                // that has the URL name after the null:
                //
                //  "CacheFileName/0UrlName"
                //
                // and pass it as the lpFile parameter to shellexecute.
                // We also pass SEE_MASK_FILEANDURL, so shellexecute can
                // recognize this case.
                int iLength;

                URLDownloadToCacheFile(NULL, szURL, szCacheFileName, 0, URLOSTRM_USECACHEDCOPY, NULL);
                iLength = lstrlen(szCacheFileName);

                // copy in the URL name
                StrCpy(&szCacheFileName[iLength + 1], szURL);

                // add the mask so shellexecute knows to check for the URL, if necessary.
                fMask |= SEE_MASK_FILEANDURL;
            }
            else
            {
                StrCpy(szCacheFileName, szURL);
            }

            sei.cbSize = sizeof(SHELLEXECUTEINFO);
            sei.fMask = fMask;
            sei.hwnd = NULL;
            sei.lpVerb = TEXT("edit");
            sei.lpFile = szCacheFileName;
            sei.lpParameters = NULL;
            sei.lpDirectory = NULL;
            sei.nShow = SW_SHOWNORMAL;
            sei.hInstApp = NULL;

            ShellExecuteEx(&sei);

            SysFreeString(bstrURL);
#endif //!EDIT_HACK
        }
        break;

        default:
            // if this rips call tjgreen
            ASSERT(0);
            break;
        }
    }

    return S_OK;
}

// *** IInputObject methods ***
HRESULT TOOLSBANDCLASS::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return CToolBand::TranslateAcceleratorIO(lpMsg);
}

// *** IUnknown methods ***
HRESULT TOOLSBANDCLASS::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(TOOLSBANDCLASS, IWinEventHandler),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

// *** IDeskBand methods ***
HRESULT TOOLSBANDCLASS::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi)
{

    _dwBandID = dwBandID;

    // set dwModeFlags
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_USECHEVRON;

    // set ptMinSize
    {
        if (SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0))
        {
            // make our min size just big enough to show the first button
            RECT rc;
            SendMessage(_hwnd, TB_GETITEMRECT, 0, (LPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
        else
        {
            // we don't have any buttons; so use standard button size
            LONG lButtonSize = (long) SendMessage(_hwnd, TB_GETBUTTONSIZE, 0, 0);
            pdbi->ptMinSize.x = LOWORD(lButtonSize);
            pdbi->ptMinSize.y = HIWORD(lButtonSize);
        }

        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
        if (pitbar->_fTheater && (pdbi->ptMinSize.y < (THEATER_CYTOOLBAR - 1)))
            pdbi->ptMinSize.y = (THEATER_CYTOOLBAR - 1);
    }

    // set ptActual
    {
        SIZE size;
        size.cy = pdbi->ptMinSize.y;
        SendMessage(_hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
        pdbi->ptActual.x = size.cx;
        pdbi->ptActual.y = size.cy;
    }

    // no title
    pdbi->dwMask &= ~DBIM_TITLE;

    return S_OK;
}

IOleCommandTarget* TOOLSBANDCLASS::_CommandTargetFromCmdMap(CMDMAP* pcm)
{
    IOleCommandTarget* pct = NULL;

    if (pcm)
    {
        if (IsEqualGUID(pcm->guidButtonGroup, CLSID_CommonButtons))
        {
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            pct = SAFECAST(pitbar, IOleCommandTarget*);
        }
        else
        {
            // If either of these rip, the button is stale
            ASSERT(IsEqualGUID(pcm->guidButtonGroup, _guidCurrentButtonGroup));
            ASSERT(_pctCurrentButtonGroup);

            pct = _pctCurrentButtonGroup;
        }
    }

    return pct;
}

BOOL ShiftRectToEdgeOfMonitor(RECT *prc)
{
    BOOL bRet = FALSE;
    POINT pt = {prc->left, prc->top};

    HMONITOR hmon = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    if (hmon)
    {
        MONITORINFO mi = {sizeof(MONITORINFO)};
        if (GetMonitorInfo(hmon, &mi))
        {
            // get the different between the monitor's left edge and the rect's left edge
            int iShift = mi.rcMonitor.left - prc->left;
            if (iShift > 0)
            {
                prc->left += iShift;
                prc->right += iShift;

                bRet = TRUE;
            }
        }
    }
    return bRet;
}

LRESULT TOOLSBANDCLASS::_OnToolbarDropDown(TBNOTIFY *ptbn)
{
    if (ptbn->hdr.hwndFrom == _hwnd)
    {
        CMDMAP* pcm = _GetCmdMapByID(ptbn->iItem);
        IOleCommandTarget* pct = _CommandTargetFromCmdMap(pcm);

        if (pct)
        {
            VARIANTARG var;
            var.vt = VT_I4;
            var.lVal = ptbn->iItem;

            // REARCHITECT: use VARIANT[TO/FROM]BUFFER here to fix win64 problem

            VARIANT v = {VT_INT_PTR};
            v.byref = &ptbn->rcButton;

            MapWindowRect(_hwnd, HWND_DESKTOP, &ptbn->rcButton);

            //
            // If this window is mirrored, then let's take the
            // other coordinate [samera]
            //
            if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            {
                int iTmp = ptbn->rcButton.right;
                ptbn->rcButton.right = ptbn->rcButton.left;
                ptbn->rcButton.left  = iTmp;
            }

            // TrackMenuPopup is lame when confronted with negative co-ordinates... lets clip to the edge of the screen.
            ShiftRectToEdgeOfMonitor(&ptbn->rcButton);

#ifdef EDIT_HACK
            // FEATURE: temp code -- edit code moving to dochost.cpp
            if (_IsDocHostGUID(&pcm->guidButtonGroup) && pcm->nCmdID == DVIDM_EDITPAGE)
                Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, OLECMDEXECOPT_PROMPTUSER, &v, &var);
            else
#endif
                pct->Exec(&pcm->guidButtonGroup, (DWORD)pcm->nCmdID, OLECMDEXECOPT_PROMPTUSER, &v, &var);
        }
    }

    return TBDDRET_DEFAULT;
}

LRESULT TOOLSBANDCLASS::_TryShowBackForwardMenu(DWORD dwItemSpec, LPPOINT ppt, LPRECT prcExclude)
{
    LRESULT lres = 0;

    GUID guid;
    UINT id;
    if (SUCCEEDED(_ConvertCmd(NULL, dwItemSpec, &guid, &id)))
    {
        // If the user right clicked on the the back or forward button, show the context menu
        // On all other buttons show the regular shortcut menu
        if (IsEqualGUID(guid, CLSID_CommonButtons))
        {
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            if (id == TBIDM_BACK)
            {
                pitbar->_ShowBackForwardMenu(FALSE, *ppt, prcExclude);
                lres = 1;
            }
            else if (id == TBIDM_FORWARD)
            {
                pitbar->_ShowBackForwardMenu(TRUE, *ppt, prcExclude);
                lres = 1;
            }
        }
    }
    return lres;
}

LRESULT TOOLSBANDCLASS::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;

    ASSERT(pnmh->idFrom == FCIDM_TOOLBAR);

    switch (pnmh->code)
    {

    case NM_RCLICK:
        {
            NMCLICK * pnm = (LPNMCLICK)pnmh;

            if (!pnm)
                break;

            // Convert to Screen coordinates
            MapWindowPoints(pnmh->hwndFrom, HWND_DESKTOP, &pnm->pt, 1);

            if (pnmh->hwndFrom == _hwnd)
                lres = _TryShowBackForwardMenu((DWORD)pnm->dwItemSpec, &pnm->pt, NULL);
        }
        break;

    case TBN_DROPDOWN:
        lres = _OnToolbarDropDown((TBNOTIFY *)pnmh);
        break;

    case TBN_DELETINGBUTTON:
        _OnDeletingButton((TBNOTIFY*)pnmh);
        break;

    case TBN_SAVE:
    case TBN_RESET:
    case TBN_INITCUSTOMIZE:
    case TBN_RESTORE:
    case TBN_BEGINADJUST:
    case TBN_GETBUTTONINFO:
    case TBN_ENDADJUST:
    case TBN_QUERYDELETE:
    case TBN_QUERYINSERT:
    case TBN_TOOLBARCHANGE:
        if (pnmh->hwndFrom == _hwnd)
            lres = _ToolsCustNotify (pnmh);
        break;

    case TBN_GETOBJECT:
        {
            NMOBJECTNOTIFY *pnmon = (NMOBJECTNOTIFY *)pnmh;
            if (IsEqualIID(*pnmon->piid, IID_IDropTarget))
            {
                if (pnmh->hwndFrom == _hwnd)
                {
                    UINT uiCmd;
                    GUID guid;
                    _ConvertCmd(NULL, pnmon->iItem, &guid, &uiCmd);

                    if (IsEqualGUID(guid, CLSID_CommonButtons) &&
                            (uiCmd == TBIDM_HOME || uiCmd == TBIDM_FAVORITES))
                    {
                        CITBarDropTarget *pdtgt = new CITBarDropTarget(_hwnd, uiCmd);
                        if (pdtgt)
                        {
                            pnmon->pObject = SAFECAST(pdtgt, IDropTarget*);
                            pnmon->hResult = NOERROR;
                        }
                    }
                    else     // pass back CDropDummy to handle basics.
                    {
                        CDropDummy *pdtgt = new CDropDummy(_hwnd);
                        if (pdtgt)
                        {
                            pnmon->pObject = SAFECAST(pdtgt, IDropTarget*);
                            pnmon->hResult = NOERROR;
                        }
                    }

                }
                lres = TRUE;
            }
        }
        break;

    default:
        lres = CToolbarBand::_OnNotify(pnmh);
        break;
    }

    return lres;
}

LRESULT TOOLSBANDCLASS::_OnContextMenu(LPARAM lParam, WPARAM wParam)
{
    LRESULT lres = 0;

    if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
    {
        // keyboard context menu.  figure out where to pop up menu and
        // which context menu to use, and tell itbar to pop it up.
        RECT rc;
        BOOL fBackForward = FALSE;

        // figure out coordinates to use
        INT_PTR iBtn = SendMessage(_hwnd, TB_GETHOTITEM, 0, 0);
        if (iBtn != -1)
        {
            // use lower left corner of current hot button
            SendMessage(_hwnd, TB_GETITEMRECT, iBtn, (LPARAM)&rc);
        }
        else
        {
            // no hot button; use top left corner of tools window
            SetRect(&rc, 0, 0, 0, 0);
        }
        MapWindowPoints(_hwnd, HWND_DESKTOP, (LPPOINT)&rc, 2);

        if (iBtn != -1)
        {
            // get hot button's command
            TBBUTTONINFO tbbi;
            tbbi.cbSize = sizeof(TBBUTTONINFO);
            tbbi.dwMask = TBIF_BYINDEX | TBIF_COMMAND;
            SendMessage(_hwnd, TB_GETBUTTONINFO, iBtn, (LPARAM)&tbbi);

            POINT pt = {rc.left, rc.bottom};

            // try popping up the back/forward context menu
            if (_TryShowBackForwardMenu(tbbi.idCommand, &pt, &rc))
                fBackForward = TRUE;
        }

        if (!fBackForward)
        {
            // pop up the standard context menu
            CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
            pitbar->_ShowContextMenu((HWND)wParam, MAKELONG(rc.left, rc.bottom), (iBtn == -1 ? NULL : &rc));
        }

        lres = 1;
    }
    return lres;
}

void TOOLSBANDCLASS::_RecalcButtonWidths()
{
    // We need the toolbars buttons to use ONLY exactly as much space as is needed.
    // By setting the size a a really small number like 10, and then setting it to
    // the real number we can accomplish this.
    // If we don't use do this, then when we add new buttons after doing this
    // RemoveAllButtons(), the new buttons will be at least as wide as the widest
    // button that existed on the last set of buttons (the ones we are just removing)
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM)MAKELONG(0, 10));
    SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM)(pitbar->_fCompressed ? MAKELONG(0, MAX_TB_COMPRESSED_WIDTH) : MAKELONG(0, pitbar->_uiMaxTBWidth)));
}

// *** IWinEventHandler methods ***
HRESULT TOOLSBANDCLASS::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_OK;

    switch (dwMsg)
    {
    case WM_CONTEXTMENU:
        *plres = _OnContextMenu(lParam, wParam);
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_WININICHANGE:
        *plres = SendMessage(_hwnd, dwMsg, wParam, lParam);
        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            _RecalcButtonWidths();
            _BandInfoChanged();
        }
        break;

    default:
        hres = CToolbarBand::OnWinEvent(hwnd, dwMsg, wParam, lParam, plres);
        break;
    }

    return hres;
}

CMDMAP* TOOLSBANDCLASS::_GetCmdMap(int i, BOOL fByIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_LPARAM;
    tbbi.lParam = 0;
    if (fByIndex)
        tbbi.dwMask |= TBIF_BYINDEX;
    SendMessage(_hwnd, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);
    return (CMDMAP*)(void*)tbbi.lParam;
}


void TOOLSBANDCLASS::_FreeCmdMap(CMDMAP* pcm)
{
    if (pcm)
        LocalFree(pcm);
}

void TOOLSBANDCLASS::_OnDeletingButton(TBNOTIFY* ptbn)
{
    CMDMAP *pcm = (CMDMAP*)(void*)ptbn->tbButton.dwData;
    _FreeCmdMap(pcm);
}

LONG_PTR TOOLSBANDCLASS::_AddString(LPWSTR pwstr)
{
    LONG_PTR lOffset;
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    pitbar->AddString(&_guidCurrentButtonGroup, 0, (UINT_PTR)pwstr, &lOffset);

    return lOffset;
}

#define PPBS_LOOKINTOOLBAR  0x00000001
#define PPBS_EXTERNALBUTTON 0x00000002

void TOOLSBANDCLASS::_PreProcessButtonString(TBBUTTON *ptbn, DWORD dwFlags)
{
    // Caller should have checked this.
    ASSERT(!(ptbn->fsStyle & BTNS_SEP));

    // If we don't have a command target, we shouldn't have any external buttons.
    ASSERT(_pctCurrentButtonGroup || !(dwFlags & PPBS_EXTERNALBUTTON));

    if (ptbn->iString < 0 && ptbn->iBitmap <= MAX_SHELLGLYPHINDEX)
    {
        // total hack
        // we're hard coding the strings in to match
        // the bitmap.  so if anyone uses the shell bitmaps,
        // they're going to get our text labels
        // also hacking in that the bitmap array and string array are
        // matched
        // who designed reviewed this???

        ptbn->iString = ptbn->iBitmap;
    }
    else if (!ptbn->iString && (dwFlags & PPBS_EXTERNALBUTTON))
    {
        // Some Extensions are giving us bogus string ids (Font ext sends 0)
        ptbn->iString = -1;
    }
    else if (ptbn->iString != -1 && !IS_INTRESOURCE(ptbn->iString))
    {
        // It's a string pointer.  The customization mechanism requires that all buttons
        // use strings from the tb string pool.  So add the string to the pool and set
        // iString to the pool index.
        ptbn->iString = _AddString((LPWSTR)ptbn->iString);
    }

    if (ptbn->iString == -1 && IsFlagSet(dwFlags, PPBS_LOOKINTOOLBAR | PPBS_EXTERNALBUTTON))
    {
        // If we're building the customization dsa rather than adding new buttons to the
        // toolbar, we may already have this button in the toolbar.  If so, use that string.

        UINT idCommand;
        if (SUCCEEDED(_ConvertCmd(&_guidCurrentButtonGroup, ptbn->idCommand, NULL, &idCommand)))
        {
            TBBUTTON tbb;
            if (SendMessage(_hwnd, TB_GETBUTTON, idCommand, (LPARAM)&tbb))
                ptbn->iString = tbb.iString;
        }
    }

    if (ptbn->iString == -1 && (dwFlags & PPBS_EXTERNALBUTTON))
    {
        // Still don't have a string for this puppy.  Last resort is to ask via QueryStatus.
        OLECMDTEXTV<MAX_TOOLTIP_STRING> cmdtv;
        OLECMDTEXT *pcmdText = &cmdtv;

        pcmdText->cwBuf = MAX_TOOLTIP_STRING;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->cwActual = 0;

        OLECMD rgcmd = {ptbn->idCommand, 0};

        HRESULT hr = _pctCurrentButtonGroup->QueryStatus(&_guidCurrentButtonGroup, 1, &rgcmd, pcmdText);
        if (SUCCEEDED(hr) && (pcmdText->cwActual))
            ptbn->iString = _AddString(pcmdText->rgwz);
    }

    // If it's an internal button, we'd better have found a string for it.
    ASSERT(ptbn->iString != -1 || (dwFlags & PPBS_EXTERNALBUTTON));
}

void TOOLSBANDCLASS::_PreProcessExternalTBButton(TBBUTTON *ptbn)
{
    if (!(ptbn->fsStyle & BTNS_SEP))
    {
        CMDMAP* pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
        if (pcm)
        {
            pcm->guidButtonGroup = _guidCurrentButtonGroup;
            pcm->nCmdID = ptbn->idCommand;

            _PreProcessButtonString(ptbn, PPBS_EXTERNALBUTTON);

            _nNextCommandID++;
            pcm->lParam = ptbn->dwData;
        }

        ptbn->dwData = (LPARAM)pcm;
    }
    else
    {
        ptbn->dwData = 0;

        // override default toolbar width for separators; iBitmap member of
        // TBBUTTON struct is a union of bitmap index & separator width
        ptbn->iBitmap = CX_SEPARATOR;
    }
}

UINT TOOLSBANDCLASS::_ProcessExternalButtons(PTBBUTTON ptbb, UINT cButtons)
{
    cButtons = RemoveHiddenButtons(ptbb, cButtons);

    for (UINT i = 0; i < cButtons; i++)
        _PreProcessExternalTBButton(&ptbb[i]);

    return cButtons;
}

void TOOLSBANDCLASS::_GetButtons(IOleCommandTarget* pct, const GUID* pguid, HDSA hdsa)
{
    LONG lCount;
    VARIANTARG v1;
    VariantInit(&v1);
    v1.vt = VT_BYREF | VT_I4;
    v1.plVal = &lCount;

    VARIANTARG v2;
    VariantInit(&v2);
    if (SUCCEEDED(pct->Exec(&IID_IExplorerToolbar, ETCMDID_GETBUTTONS, 0, &v1, &v2)) && v2.vt == VT_BYREF)
    {
        CMDMAPCUSTOMIZE cmc;
        TBBUTTON* pbtn = (TBBUTTON*)v2.byref;

        cmc.cm.guidButtonGroup = *pguid;

        DWORD dwFlags = PPBS_LOOKINTOOLBAR;

        if (!IsEqualGUID(*pguid, CLSID_CommonButtons))
            dwFlags |= PPBS_EXTERNALBUTTON;

        for (long l = 0; l < lCount; l++)
        {
            cmc.btn = pbtn[l];
            if (!(cmc.btn.fsStyle & BTNS_SEP))
            {
                cmc.cm.nCmdID = pbtn[l].idCommand;

                _PreProcessButtonString(&cmc.btn, dwFlags);

                if (FAILED(_ConvertCmd(pguid, cmc.cm.nCmdID, NULL, (UINT*)&cmc.btn.idCommand)))
                {
                    // not already in the toolbar, generate a new id
                    cmc.btn.idCommand = _nNextCommandID++;
                }

                DSA_AppendItem(hdsa, &cmc);
            }
            else
            {
                cmc.btn.dwData = 0;
            }
        }
    }
}

void TOOLSBANDCLASS::_OnEndCustomize()
{

    if (_pcinfo)
    {
        // loop through and make sure that any items added have the appropriate cmdmap
        int i;
        INT_PTR nCount = SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0L);
        _pcinfo->fAdjust = FALSE;
        for(i = 0; i < nCount; i++)
        {
            CMDMAP* pcm = _GetCmdMapByIndex(i);
            if (!pcm)
            {
                // no command map for this item
                // find the corresponding CMDMAP in our hdsa, clone it and give it to this button.

                // the command id's are the same, so get the toolbar command id, find the corresponding
                // one in the hdsa and clone away.
                TBBUTTONINFO tbbi;
                tbbi.cbSize = sizeof(tbbi);
                tbbi.dwMask = TBIF_COMMAND | TBIF_BYINDEX;
                SendMessage(_hwnd, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);

                int j;
                for (j = 0; j < DSA_GetItemCount(_pcinfo->hdsa); j++)
                {
                    CMDMAPCUSTOMIZE* pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, j);
                    ASSERT(pcmc);
                    if (pcmc->btn.idCommand == tbbi.idCommand)
                    {
                        // found it!

                        // clone the cmdmap
                        CMDMAP *pcm = (CMDMAP*)LocalAlloc(LPTR, sizeof(CMDMAP));
                        if (pcm)
                        {
                            *pcm = pcmc->cm;
                            tbbi.lParam = (LPARAM)pcm;
                            tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
                            SendMessage(_hwnd, TB_SETBUTTONINFO, i, (LPARAM)&tbbi);
                        }
                    }
                }
            }
        }

        if (_pcinfo->fDirty)
            _SaveRestoreToolbar(TRUE);
        
        _FreeCustomizeInfo();

        _RecalcButtonWidths();
        CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

#ifdef EDIT_HACK
        pitbar->_InitEditButtonStyle();
#endif
        if (g_fSmallIcons != _UseSmallIcons())
        {
            SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)SZ_REGKEY_SMALLICONS, 3000);

            // Resize the Theater Controls based upon the icon changes.
            IUnknown_Exec( _punkSite, &CGID_Theater, THID_RECALCSIZING, 0, NULL, NULL );
        }

        pitbar->_UpdateToolbar(TRUE);
    }
}

void TOOLSBANDCLASS::_FreeCustomizeInfo()
{
    if (_pcinfo)
    {
        DSA_Destroy(_pcinfo->hdsa);
        _pcinfo->hdsa = NULL;
        LocalFree(_pcinfo);
        _pcinfo = NULL;
    }
}

CMDMAPCUSTOMIZE* TOOLSBANDCLASS::_GetCmdMapCustomize(GUID* pguid, UINT nCmdID)
{
    int j;
    for (j = 0; j < DSA_GetItemCount(_pcinfo->hdsa); j++)
    {
        CMDMAPCUSTOMIZE* pcmc = (CMDMAPCUSTOMIZE*)DSA_GetItemPtr(_pcinfo->hdsa, j);

        if (pcmc->cm.nCmdID == nCmdID &&
            IsEqualGUID(*pguid, pcmc->cm.guidButtonGroup))
        {
            return pcmc;
        }
    }

    return NULL;
}

BOOL TOOLSBANDCLASS::_BuildButtonDSA()
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    ASSERT(!_pcinfo);
    _pcinfo = (CUSTOMIZEINFO*)LocalAlloc(LPTR, sizeof(CUSTOMIZEINFO));

    if (_pcinfo)
    {
        // build a CMDMAP array of all the buttons available
        _pcinfo->hdsa = DSA_Create(sizeof(CMDMAPCUSTOMIZE), 4);

        if (_pcinfo->hdsa)
        {
            // add the common set (back,forward, stop, refresh, home and search
            _GetButtons(pitbar, &CLSID_CommonButtons, _pcinfo->hdsa);
            _GetButtons(_pctCurrentButtonGroup, &_guidCurrentButtonGroup, _pcinfo->hdsa);
            return TRUE;
        }
        else
        {
            _FreeCustomizeInfo();
            return FALSE;
        }
    }
    return FALSE;
}

void TOOLSBANDCLASS::_UpdateTextSettings(INT_PTR ids)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    BOOL fText, fList;

    switch (ids)
    {
    case IDS_TEXTLABELS:
        fList = FALSE;
        fText = TRUE;
        break;

    case IDS_PARTIALTEXT:
        fList = TRUE;
        fText = TRUE;
        break;

    case IDS_NOTEXTLABELS:
        fList = FALSE;  // (but we really don't care)
        fText = FALSE;
        break;

    default:
        ASSERT(0);
        fList = FALSE;
        fText = FALSE;
        break;
    }

    pitbar->_UpdateToolsStyle(fList);

    // (_fCompressed == TRUE means no text labels)
    pitbar->_UpdateToolbarDisplay(UTD_TEXTLABEL, 0, !fText, TRUE);
}

const static DWORD c_aBtnAttrHelpIDs[] = {
    IDC_SHOWTEXT,       IDH_BROWSEUI_TB_TEXTOPTNS,
    IDC_SMALLICONS,     IDH_BROWSEUI_TB_ICONOPTNS,
    0, 0
};

BOOL_PTR CALLBACK TOOLSBANDCLASS::_BtnAttrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CInternetToolbar* pitbar = (CInternetToolbar*)GetWindowPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);  /* LPADJUSTDLGDATA pointer */
        return TRUE;

    case WM_COMMAND:
        if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_SHOWTEXT)
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELENDOK ||
                GET_WM_COMMAND_CMD(wParam, lParam) == CBN_CLOSEUP)
            {
                // what'd they pick?
                HWND hwndText = GET_WM_COMMAND_HWND(wParam, lParam);
                INT_PTR iSel = SendMessage(hwndText, CB_GETCURSEL, 0, 0);
                INT_PTR idsSel = SendMessage(hwndText, CB_GETITEMDATA, iSel, 0);

                pitbar->_btb._UpdateTextSettings(idsSel);

                return TRUE;
            }
        }
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR) c_aBtnAttrHelpIDs);
        return TRUE;

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aBtnAttrHelpIDs);
        return TRUE;

    case WM_DESTROY:
        {
#define SZ_YES  TEXT("yes")
#define SZ_NO   TEXT("no")

            HWND hwndIcons = GetDlgItem(hDlg, IDC_SMALLICONS);
            if (TPTR(hwndIcons))
            {
                INT_PTR iSel = SendMessage(hwndIcons, CB_GETCURSEL, 0, 0);
                BOOL fSmallIcons = (SendMessage(hwndIcons, CB_GETITEMDATA, iSel, 0) == IDS_SMALLICONS);

                LPCTSTR szData;
                DWORD cbData;

                if (fSmallIcons)
                {
                    szData = SZ_YES;
                    cbData = sizeof(SZ_YES);
                }
                else
                {
                    szData = SZ_NO;
                    cbData = sizeof(SZ_NO);
                }
                SHRegSetUSValue(SZ_REGKEY_SMALLICONS, SZ_REGVALUE_SMALLICONS, REG_SZ, (void*)szData, cbData, SHREGSET_FORCE_HKCU);
            }
        }
        return TRUE;
    }

    return FALSE;
}

void TOOLSBANDCLASS::_PopulateComboBox(HWND hwnd, const int iResource[], UINT cResources)
{
    TCHAR sz[256];

    // loop through iResource[], load each string resource and insert into combobox
    for (UINT i = 0; i < cResources; i++)
    {
        if (MLLoadString(iResource[i], sz, ARRAYSIZE(sz)))
        {
            INT_PTR iIndex = SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwnd, CB_SETITEMDATA, iIndex, iResource[i]);
        }
    }
}

void TOOLSBANDCLASS::_SetComboSelection(HWND hwnd, int iCurOption)
{
    INT_PTR cItems = SendMessage(hwnd, CB_GETCOUNT, 0, 0);

    while (cItems--)
    {
        INT_PTR iItemData = SendMessage(hwnd, CB_GETITEMDATA, cItems, 0);

        if (iItemData == iCurOption)
        {
            SendMessage(hwnd, CB_SETCURSEL, cItems, 0);
            break;
        }
        else
        {
            // iCurOption should be in list somewhere;
            // assert that we're not done looking
            ASSERT(cItems);
        }
    }
}

void TOOLSBANDCLASS::_SetDialogSelections(HWND hDlg, BOOL fSmallIcons)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);

    int iCurOption;
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);

    if (pitbar->_fCompressed)
        iCurOption = IDS_NOTEXTLABELS;
    else if (IS_LIST_STYLE(_hwnd))
        iCurOption = IDS_PARTIALTEXT;
    else
        iCurOption = IDS_TEXTLABELS;

    _SetComboSelection(hwnd, iCurOption);
    if (pitbar->_fTheater)
        SHSetWindowBits(hwnd, GWL_STYLE, WS_DISABLED, WS_DISABLED);

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    iCurOption = (fSmallIcons ? IDS_SMALLICONS : IDS_LARGEICONS);
    _SetComboSelection(hwnd, iCurOption);
}

static const int c_iTextOptions[] = {
    IDS_TEXTLABELS,
    IDS_PARTIALTEXT,
    IDS_NOTEXTLABELS,
};

static const int c_iIconOptions[] = {
    IDS_SMALLICONS,
    IDS_LARGEICONS,
};

void TOOLSBANDCLASS::_PopulateDialog(HWND hDlg)
{
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, IDC_SHOWTEXT);
    _PopulateComboBox(hwnd, c_iTextOptions, ARRAYSIZE(c_iTextOptions));

    hwnd = GetDlgItem(hDlg, IDC_SMALLICONS);
    _PopulateComboBox(hwnd, c_iIconOptions, ARRAYSIZE(c_iIconOptions));
}

void TOOLSBANDCLASS::_OnBeginCustomize(LPNMTBCUSTOMIZEDLG pnm)
{
    CInternetToolbar* pitbar = IToClass(CInternetToolbar, _btb, this);
    HWND hwnd = (HWND) GetProp(pnm->hDlg, SZ_PROP_CUSTDLG);

    if (!hwnd)
    {
        //
        // hasn't been initialized.
        //
        // we need to check this because this init will be called
        // when the user hits reset as well

        hwnd = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_TEXTICONOPTIONS), pnm->hDlg, _BtnAttrDlgProc, (LPARAM)pitbar);
        if (hwnd)
        {
            // store hwnd of our dialog as property on tb cust dialog
            SetProp(pnm->hDlg, SZ_PROP_CUSTDLG, hwnd);

            // populate dialog controls
            _PopulateDialog(hwnd);

            // initialize dialog control selection states
            _SetDialogSelections(hwnd, g_fSmallIcons);

            RECT rc, rcWnd, rcClient;
            GetWindowRect(pnm->hDlg, &rcWnd);
            GetClientRect(pnm->hDlg, &rcClient);
            GetWindowRect(hwnd, &rc);

            // enlarge tb dialog to make room for our dialog
            SetWindowPos(pnm->hDlg, NULL, rcWnd.left, rcWnd.top + 64, RECTWIDTH(rcWnd), RECTHEIGHT(rcWnd) + RECTHEIGHT(rc), SWP_NOZORDER);

            // position our dialog at the bottom of the tb dialog
            SetWindowPos(hwnd, HWND_TOP, rcClient.left, rcClient.bottom, 0, 0, SWP_NOSIZE | SWP_SHOWWINDOW);
        }
    }

    if (_BuildButtonDSA())
    {
        _pcinfo->fAdjust = TRUE;
    }
}

class CBitmapPreload : public IRunnableTask
{
public:
    STDMETHOD ( QueryInterface ) ( REFIID riid, void ** ppvObj );
    STDMETHOD_( ULONG, AddRef ) ();
    STDMETHOD_( ULONG, Release ) ();

    STDMETHOD (Run)( void );
    STDMETHOD (Kill)( BOOL fWait );
    STDMETHOD (Suspend)( );
    STDMETHOD (Resume)( );
    STDMETHOD_( ULONG, IsRunning )( void );

protected:
    friend HRESULT CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

    CBitmapPreload();
    ~CBitmapPreload();

    LONG            m_cRef;
    LONG            m_lState;
};

STDAPI CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking and *ppunk zeroing are handled in class factory
    ASSERT(pUnkOuter == NULL);

    CBitmapPreload* pbp = new CBitmapPreload();

    if (pbp)
    {
        *ppunk = SAFECAST(pbp, IRunnableTask*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL; // redundant but doesn't hurt
        return E_OUTOFMEMORY;
    }
}


CBitmapPreload::CBitmapPreload() : m_cRef(1)
{
    m_lState = IRTIR_TASK_NOT_RUNNING;
}


CBitmapPreload::~CBitmapPreload()
{
}


STDMETHODIMP CBitmapPreload::QueryInterface (REFIID riid, void ** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CBitmapPreload, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDMETHODIMP_( ULONG ) CBitmapPreload:: AddRef ()
{
    return InterlockedIncrement( &m_cRef );
}

STDMETHODIMP_( ULONG ) CBitmapPreload:: Release ()
{
    if (InterlockedDecrement( &m_cRef ) == 0 )
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CBitmapPreload::Run ( void )
{
    if ( m_lState != IRTIR_TASK_NOT_RUNNING )
    {
        return E_FAIL;
    }

    InterlockedExchange( &m_lState, IRTIR_TASK_RUNNING );

    CInternetToolbar_Preload( );

    InterlockedExchange( &m_lState, IRTIR_TASK_FINISHED );

    return NOERROR;
}


STDMETHODIMP CBitmapPreload::Kill ( BOOL fWait )
{
    return E_NOTIMPL;
}


STDMETHODIMP CBitmapPreload::Suspend ( )
{
    return E_NOTIMPL;
}


STDMETHODIMP CBitmapPreload::Resume ( )
{
    return E_NOTIMPL;
}


STDMETHODIMP_( ULONG ) CBitmapPreload:: IsRunning ( void )
{
    return m_lState;
}



#ifdef EDIT_HACK

//+-------------------------------------------------------------------------
//  Constructor
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::CEditVerb()
{
    ASSERT(_nElements == 0);
    ASSERT(_nDefault == 0);
    ASSERT(_pVerb == NULL);
    ASSERT(_lpfnOldWndProc == NULL);
    ASSERT(_pszDefaultEditor == NULL);
    ASSERT(_fInitEditor == FALSE);
}

//+-------------------------------------------------------------------------
//  Destructor
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::~CEditVerb()
{
    if (_pVerb) RemoveAll();
    SetStr(&_pszDefaultEditor, NULL);
}

//+-------------------------------------------------------------------------
// Removes all cached edit verbs and associated memory
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::RemoveAll()
{
    if (_nElements > 0)
    {
        for (UINT i=0; i < _nElements; ++i)
        {
            EDITVERB& rVerb = _pVerb[i];

            SetStr(&rVerb.pszDesc, NULL);
            SetStr(&rVerb.pszMenuText, NULL);
            SetStr(&rVerb.pszExe, NULL);
            if (rVerb.hkeyProgID)
            {
                RegCloseKey(rVerb.hkeyProgID);
            }
            _ClearMSAAMenuInfo(rVerb);
        }

        LocalFree(_pVerb);

        _pVerb = NULL;
        _nElements = 0;
        _nDefault = 0;
    }
}

void _AddToOpenWithList(HKEY hkeyProgid, LPCWSTR pszVerb, LPCWSTR pszFileExt)
{
    ASSERT(hkeyProgid);
    ASSERT(pszVerb);
    ASSERT(pszFileExt);

    // First get the name of the exe
    WCHAR szPath[MAX_PATH];

    if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkeyProgid,
        pszVerb, szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath)))))
    {
        // Now see if it is in the openwith list for the given file extension
        LPCWSTR pszExe = PathFindFileName(szPath);

        WCHAR szKey[MAX_PATH];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithList\\%s", pszFileExt, pszExe);
        HKEY hkey;

        DWORD dwDisp;
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, szKey, 0, L"", REG_OPTION_NON_VOLATILE,
                                      KEY_READ | KEY_WRITE, NULL, &hkey, &dwDisp))
        {
            // If we create a new key, we then need to check that verb is registered
            // for this app
            if (dwDisp == REG_CREATED_NEW_KEY)
            {
                AssocMakeApplicationByKey(ASSOCMAKEF_VERIFY, hkeyProgid, pszVerb);
            }
            RegCloseKey(hkey);
        }
    }
}

//+-------------------------------------------------------------------------
// Check registry for a default mhtml editor.  If a new editor is detected,
// it is added to the mhtml openwith list.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_InitDefaultMHTMLEditor()
{
    //
    // Check for a default MHTML editor.
    //
    HKEY hkeyEdit = NULL;
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_MHTML_EDITOR, 0, KEY_READ | KEY_WRITE, &hkeyEdit))
    {
        // Migrate hklm setting to hkcu
        HKEY hkeySrc;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_MHTML_EDITOR, 0, KEY_READ, &hkeySrc))
        {
            HKEY hkeyDest;
            if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_MHTML_EDITOR, &hkeyDest))
            {
                SHCopyKey(hkeySrc, NULL, hkeyDest, 0);
                hkeyEdit = hkeyDest;
            }
            RegCloseKey(hkeySrc);
        }
    }

    if (hkeyEdit)
    {
        // If the mhtml editor has changed, copy it into the mhtml openwithlist
        DWORD dwType;
        WCHAR szCurrent[MAX_PATH];
        DWORD cb = sizeof(szCurrent);
        if (ERROR_SUCCESS == SHGetValue(hkeyEdit, L"shell\\edit\\command", NULL, &dwType, szCurrent, &cb) &&
            dwType == REG_SZ)
        {
            WCHAR szLast[MAX_PATH];
            DWORD cb = sizeof(szLast);
            if (ERROR_SUCCESS != SHGetValue(hkeyEdit, NULL, L"Last", &dwType, szLast, &cb) ||
                (dwType == REG_SZ && StrCmp(szLast, szCurrent) != 0))
            {
                // Copy the MHTML editor into our MHTML openwithlist
                _AddToOpenWithList(hkeyEdit, L"edit", L".mhtml");

                // Remember that we migrated this key. Copying to the openwithlist can be slow
                // because we need to hit the disk to verify the exe name. So it's worth the effort
                // to avoid doing this unecessarily.
                SHSetValue(hkeyEdit, NULL, L"Last", REG_SZ, szCurrent, CbFromCch(lstrlen(szCurrent) +1));
            }
        }

        RegCloseKey(hkeyEdit);
    }
}

//+-------------------------------------------------------------------------
// Check registry for the friendly name of the default html editor.  This
// editor is configured by inetcpl or by office 2000.  If necessary, the
// associated verb is moved to the OpenWithList for .htm files.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::InitDefaultEditor(HKEY hkey)
{
    //
    // First see if the default editor is in HKCU
    //
    HKEY hkeyEdit = hkey;
    if (hkey ||
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR,
                                      0, KEY_READ | KEY_WRITE, &hkeyEdit))
    {
        //
        // See if we have a default editor selected
        //
        WCHAR szBuf[MAX_PATH];
        DWORD cbBuf = sizeof(szBuf);
        if (ERROR_SUCCESS == SHGetValue(hkeyEdit, NULL, L"Description", NULL, szBuf, &cbBuf))
        {
            // We got it!  Save the friendly name.
            PathRemoveBlanks(szBuf);
            SetStr(&_pszDefaultEditor, szBuf);
        }
        else
        {
            // No default editor description, so check to see if an edit verb was added.
            // (Office/inetcpl deletes the description key to signal to us that something changed).
            IQueryAssociations *pqa;

            if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa))))
            {
                if (SUCCEEDED(pqa->Init(0, NULL, hkeyEdit, NULL)) &&
                ( SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, L"edit", szBuf, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szBuf))))
                || SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, NULL, szBuf, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szBuf))))))
                {
                    PathRemoveBlanks(szBuf);

                    // Save the name of the default editor
                    SetStr(&_pszDefaultEditor, szBuf);
                    SHSetValue(hkeyEdit, NULL, L"Description", REG_SZ, szBuf, CbFromCch(lstrlen(szBuf) +1));

                    // Add it to our openwithlist for .htm files
                    _AddToOpenWithList(hkeyEdit, L"edit", L".htm");
                }

                pqa->Release();
            }
        }

        // Close the key if it wasn't passed in
        if (hkeyEdit && NULL == hkey)
        {
            RegCloseKey(hkeyEdit);
        }
    }

    // During setup, Office places the orginial edit verb in HKLM. We need to copy this to HKCU.
    else if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyEdit))
    {
        // Migrate this key into HKCU
        HKEY hkeyDest;
        if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, &hkeyDest))
        {
            SHCopyKey(hkeyEdit, NULL, hkeyDest, 0);

            // Try again
            InitDefaultEditor(hkeyDest);
            RegCloseKey(hkeyDest);
        }
        RegCloseKey(hkeyEdit);
    }

    //
    // Check for a default MHTML editor.
    //
    if (hkey == NULL)   // Don't do on recursion
    {
        _InitDefaultMHTMLEditor();
    }
}

BOOL _GetAppKey(LPCWSTR pszApp, HKEY *phkApp)
{
    ASSERT(pszApp && *pszApp);
    WCHAR szKey[MAX_PATH];
    StrCpy(szKey, L"Applications\\");
    StrCatBuff(szKey, pszApp, SIZECHARS(szKey));

    return (NOERROR == RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        szKey,
        0L,
        MAXIMUM_ALLOWED,
        phkApp));
}

//+-------------------------------------------------------------------------
// Make sure that notepad is registered in the OpenWithList for .htm files.
// This is called when this dll is registered (at setup time)
//--------------------------------------------------------------------------
void AddNotepadToOpenWithList()
{
    // Add notepad to the openwith list for .htm files
    HKEY hkeyOpenWith;
    DWORD dwDisp;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, L".htm\\OpenWithList\\notepad.exe", 0, L"",
                                        REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hkeyOpenWith, &dwDisp))
    {
        // Add the edit verb for notepad
//        if (g_fRunningOnNT) // didn't work on nt4
//        {
//            const WCHAR szPath[] = L"%SystemRoot%\\notepad.exe %1";
//            SHSetValue(HKEY_CLASSES_ROOT, L"Applications\\notepad.exe\\shell\\edit\\command", NULL, REG_EXPAND_SZ, szPath, sizeof(szPath));
//        }
//        else
        {
            WCHAR szPath[MAX_PATH];
            GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
            PathAddBackslash(szPath);
            StrCatBuff(szPath, L"notepad.exe %1", ARRAYSIZE(szPath));
            SHSetValue(HKEY_CLASSES_ROOT, L"Applications\\notepad.exe\\shell\\edit\\command", NULL, REG_SZ, szPath, (lstrlen(szPath)+1) * sizeof(WCHAR));
        }

        // Add a localizable name for the edit verb
        TCHAR szEditVerb[MAX_PATH];
        int cch = MLLoadShellLangString(IDS_EDITVERB, szEditVerb, ARRAYSIZE(szEditVerb));
        if (cch > 0)
        {
            SHSetValue(HKEY_CLASSES_ROOT, L"Applications\\notepad.exe\\shell\\edit", NULL, REG_SZ, szEditVerb, (cch + 1) * sizeof(WCHAR));
        }

        RegCloseKey(hkeyOpenWith);
    }
}

//+-------------------------------------------------------------------------
// Returns the friendly name of the default HTML editor
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetDefaultEditor()
{
    // Do a lazy init of the default editor
    if (!_fInitEditor)
    {
        InitDefaultEditor();
        _fInitEditor = TRUE;
    }
    return _pszDefaultEditor;
}

//+-------------------------------------------------------------------------
// Gets the path of the exe associated with the verb and stores the
// result in rVerb.  The caller is responsible for freeing the string
// returned.
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetExePath(EDITVERB& rVerb)
{
    // If we already have the path, simply return it
    if (NULL == rVerb.pszExe)
    {
        ASSERT(rVerb.hkeyProgID);
        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, rVerb.hkeyProgID,
            rVerb.fUseOpenVerb ? NULL : L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
            rVerb.pszExe = StrDup(sz);
    }

    return rVerb.pszExe;
}

//+-------------------------------------------------------------------------
// Returns TRUE if path of the exe associated with the verb is not found in
// any of the existing verbs.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::_IsUnique(EDITVERB& rNewVerb)
{
    // Get the friendly name of the new element
    LPCTSTR pszNewDesc = _GetDescription(rNewVerb);
    if (NULL == pszNewDesc)
    {
        // Executable must not exist
        return FALSE;
    }

    // Scan existing elements for the same executable
    for (UINT i=0; i < _nElements; ++i)
    {
        LPCTSTR pszDesc = _GetDescription(_pVerb[i]);
        if (pszDesc && (StrCmpI(pszNewDesc, pszDesc) == 0))
        {
            // Match found, so free the friendly name for the new verb
            SetStr(&rNewVerb.pszDesc, NULL);

            // If the new item shows its icon on the button, make the duplicate
            // do the same.
            if (rNewVerb.fShowIcon)
            {
                _pVerb[i].fShowIcon = TRUE;
                _nDefault = i;
            }
            return FALSE;
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// Some programs such as msothmed.exe act as stubs that redirect the edit
// command to the appropriate executable. This function returns true if
// the path contains the name of a known stub.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::_IsHtmlStub
(
    LPCWSTR pszPath
)
{
    BOOL fRet = FALSE;

    // Get the MULTISZ list of known redirectors
    TCHAR szRedir[MAX_PATH];
    ZeroInit(szRedir, ARRAYSIZE(szRedir)); // Protect against non-multisz strings in the reg
    DWORD dwType;
    DWORD cb = sizeof(szRedir) - 4;
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, L"Stubs", &dwType, szRedir, &cb))
    {
        // Nothing in registry, so default to ignore the Office redirector
        StrCpyN(szRedir, L"msohtmed.exe\0", ARRAYSIZE(szRedir));
    }

    // See if the path contains the name of a redirectors
    // Note that PathFindFileName doesn't work well for pathes with parameters so we just
    // check for the exe name in the path)
    for (LPTSTR p = szRedir; *p != NULL; p += lstrlen(p) + 1)
    {
        if (StrStrI(pszPath, p))
        {
            fRet = TRUE;
            break;
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
//  Adds a new edit verb.  Returns a pointer to the new verb if it
//  successfully added.
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::EDITVERB* CInternetToolbar::CEditVerb::_Add
(
    HKEY hkeyProgID,        // location of of verb
    BOOL fPermitOpenVerb,   // permit open as well as edit verb
    BOOL fCheckForOfficeApp,// redirect to office app
    BOOL fShowIcon          // if button face icon should be customized
)
{
    EDITVERB* pNewVerb = NULL;

    if (hkeyProgID)
    {
        BOOL fUseOpenVerb = FALSE;

        //
        // See if an appropriate verb exists.
        //
        TCHAR szCommand[MAX_PATH];
        HRESULT hr = AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProgID, L"edit", szCommand, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szCommand)));
        if (FAILED(hr) && fPermitOpenVerb)
        {
            hr = AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProgID, NULL, szCommand, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szCommand)));
            if (SUCCEEDED(hr))
            {
                fUseOpenVerb = TRUE;
            }
        }

        // If no verb or if this is the office redirector, ignore this progid
        // Otherwise we can get two entries that do the same thing.
        if (FAILED(hr) || _IsHtmlStub(szCommand))
        {
            RegCloseKey(hkeyProgID);
            return NULL;
        }

        if (fCheckForOfficeApp)
        {
            ASSERT(*szCommand);

            //
            // HACK: Office2000 needs us to call a special proxy to get around thier DDE bugs and
            // to check the HTML document for the name of the original document.  These problems
            // should be fixed in the apps themselves.
            //
            // So if this is an office app, we will redirect to the appropriate progid. Note that
            // we don't need to do this if a progid was from the html meta tag because this progid
            // already supports the proxy.
            //
            struct OfficeHackery {LPCWSTR pszApp; LPCWSTR pszProgID;};

            // Must not have been a progid passed in.
            static const OfficeHackery exeToProgID[] =
            {
                {L"winword",   L"Word.Document"},
                {L"excel",     L"Excel.Sheet"},
                {L"powerpnt",  L"PowerPoint.Slide"},
                {L"msaccess",  L"Access.Application"},
                {L"frontpg",   L"FrontPage.Editor.Document"},
            };

            for (int i=0; i < ARRAYSIZE(exeToProgID); ++i)
            {
                if (StrStrI(szCommand, exeToProgID[i].pszApp))
                {
                    // Match found!
                    HKEY hkeyOffice = NULL;
                    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, exeToProgID[i].pszProgID, NULL, &hkeyOffice)))
                    {
                        // Redirect to the office progid
                        RegCloseKey(hkeyProgID);
                        hkeyProgID = hkeyOffice;

                        // The office apps always use the open verb
                        fUseOpenVerb = TRUE;

                        // The icon is shown on the button face for office apps
                        fShowIcon = TRUE;
                    }
                    break;
                }
            }
        }

        EDITVERB newVerb = {0};
        newVerb.hkeyProgID = hkeyProgID;
        newVerb.fUseOpenVerb = fUseOpenVerb;
        newVerb.fShowIcon = fShowIcon;

        // Ignore it if we have another verb to the same exe.
        if (!_IsUnique(newVerb))
        {
            RegCloseKey(hkeyProgID);
        }
        else
        {
            EDITVERB* pVerbsNew;
            if (_pVerb == NULL)
            {
                pVerbsNew = (EDITVERB*)LocalAlloc(LPTR, sizeof(EDITVERB));
            }
            else
            {
                pVerbsNew = (EDITVERB*)LocalReAlloc(_pVerb, (_nElements+1) * sizeof(EDITVERB), LMEM_MOVEABLE | LMEM_ZEROINIT);
            }

            if (pVerbsNew == NULL)
            {
                RegCloseKey(hkeyProgID);
            }
            else
            {
                _pVerb = pVerbsNew;
                pNewVerb = &_pVerb[_nElements];
                *pNewVerb = newVerb;

                //
                // If the description of the executable matches that of the default editor, make
                // it our default edit verb.  If we are not checking for the office app, we
                // can assume that this verb was from a progid in an html file and we will also
                // make it our default.
                //
                LPCWSTR pszDefDesc = _GetDefaultEditor();
                LPCWSTR pszNewDesc = _GetDescription(*pNewVerb);

                if (!fCheckForOfficeApp ||
                    (pszDefDesc && pszNewDesc && StrCmp(pszDefDesc, pNewVerb->pszDesc) == 0))
                {
                    _nDefault = _nElements;
                }

                ++_nElements;
            }
        }
    }

    return pNewVerb;
}

//+-------------------------------------------------------------------------
//  Adds a new edit verb.  Returns TRUE if a verb was successfully added.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::Add
(
    LPTSTR pszProgID    // program id or file extension associated with verb
)
{
    ASSERT(pszProgID);

    BOOL fRet = FALSE;
    BOOL fFileExt = (pszProgID[0] == TEXT('.'));

    //
    // Open the associated reg key and try to add it to our list of verbs
    //
    BOOL fUseOpenVerb = FALSE;
    HKEY hkeyProgID = NULL;
    BOOL fPermitOpenVerb = !fFileExt;
    BOOL fShowIcon = !fFileExt;    // If a progid was passed in, we will show the icon on the button face

    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszProgID, NULL, &hkeyProgID)))
    {
        EDITVERB* pNewVerb = _Add(hkeyProgID, fPermitOpenVerb, fFileExt, fShowIcon);
        if (pNewVerb)
        {
            fRet = TRUE;
        }
    }

    //
    // If a file extension was passed in, we also add the alternative editors from the
    // OpenWithList
    //
    if (fFileExt)
    {
        WCHAR szOpenWith[MAX_PATH];
        StrCpyN(szOpenWith, pszProgID, ARRAYSIZE(szOpenWith));
        StrCatBuff(szOpenWith, L"\\OpenWithList", ARRAYSIZE(szOpenWith));

        HKEY hkeyOpenWithList;

        // See if there is an OpenWithList
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szOpenWith, 0, KEY_READ, &hkeyOpenWithList))
        {
            DWORD dwIndex = 0;
            DWORD dwSize = ARRAYSIZE(szOpenWith);
            HKEY hkeyOpenWith = NULL;
            while (ERROR_SUCCESS == RegEnumKeyEx(hkeyOpenWithList, dwIndex, szOpenWith, &dwSize, NULL, NULL, NULL, NULL))
            {
                if (_GetAppKey(szOpenWith, &hkeyOpenWith))
                {
                    // We only permit the edit verbs from here
                    EDITVERB* pNewVerb = _Add(hkeyOpenWith, FALSE, TRUE, FALSE);
                    if (pNewVerb)
                    {
                        fRet = TRUE;
                    }

                    ++dwIndex;

                    // Note that we don't close hkeyOpenWith here.  It is either closed if it was not added, or
                    // it will be closed later.
                }
                else
                {
                    // Invalid entry, so try to fix it (may be old format):
                    //
                    // In IE5.0 we use to store the friendly names of apps in the openwithlist.  For shell compatibility, we need
                    // to convert these entries to store the exe name instead:
                    //
                    //  ----> permanent entries are stored un HKCR
                    //  HKCR
                    //     \.Ext
                    //         \OpenWithList
                    //             \app.exe
                    //
                    //  ----> and applications or the system can write app association here
                    //     \Applications
                    //         \APP.EXE
                    //             \shell...
                    //         \foo.exe
                    //             \shell...
                    //
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyOpenWithList, szOpenWith, 0, KEY_READ, &hkeyOpenWith))
                    {
                        _AddToOpenWithList(hkeyOpenWith, L"edit", L".htm");

                        // Remove the invalid entry
                        if (ERROR_SUCCESS != SHDeleteKey(hkeyOpenWith, L""))
                        {
                            // NOTE (andrewgu): ie5.5 b#108551 - on locked-down nt5 this will fail
                            // and if dwIndex is not incremented, will result in an infinite loop.
                            dwIndex++;
                        }

                        RegCloseKey(hkeyOpenWith);
                    }
                }
                dwSize = ARRAYSIZE(szOpenWith);
            }

            RegCloseKey(hkeyOpenWithList);
        }

        //
        // If a ".htm" or ".html" was passed in, add our default html editor
        //
        if ((StrCmpI(pszProgID, L".htm") == 0 || StrCmpI(pszProgID, L".html") == 0) &&
            _GetDefaultEditor())
        {
            HKEY hkeyDefault;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault))
            {
                if (_Add(hkeyDefault, TRUE, TRUE, FALSE))
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}

//+-------------------------------------------------------------------------
// Returns the tooltip for the default edit verb
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::GetToolTip
(
    LPTSTR pszToolTip,
    UINT cchMax,
    BOOL fStripAmpersands
)
{
    if (_nElements == 0)
    {
        return FALSE;
    }

    // Use the menu text for the tooltip.
    _FormatMenuText(_nDefault);

    // Copy text stripping out any ampersands
    LPWSTR pszDest = pszToolTip;
    LPWSTR pszSrc = _GetVerb(_nDefault).pszMenuText;
    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            // strip out '&'
            if (fStripAmpersands)
            {
                while (*pszSrc == L'&')
                {
                    ++pszSrc;
                }
            }

            if ( !(*pszDest++ = *pszSrc++) )
            {
                --pszDest;
                break;
            }
        }

        if (0 == cchMax)
            *pszDest = L'\0';

        ASSERT(*pszDest == 0);

        //
        // In some locals, the accelerator is identified in brackets at the
        // end of the string, so if we strip ampersands, we strip these too.
        //
        if (fStripAmpersands && --pszDest >= pszToolTip && *pszDest == L')')
        {
            while (--pszDest >= pszToolTip)
            {
                if (*pszDest == L'(')
                {
                    *pszDest = L'\0';
                    break;
                }
            }
        }
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// "Lazy-fetches" the verb info, and returns the desired info.
//--------------------------------------------------------------------------
CInternetToolbar::CEditVerb::EDITVERB& CInternetToolbar::CEditVerb::_GetVerb(UINT nIndex)
{
    ASSERT(nIndex < _nElements);

    // We fetch the info when first asked for it.
    if (!_pVerb[nIndex].fInit)
    {
        _FetchInfo(nIndex);
        _pVerb[nIndex].fInit = TRUE;
    }
    return _pVerb[nIndex];
}

//+-------------------------------------------------------------------------
// Gets the name of the app associated with the verb.
//--------------------------------------------------------------------------
LPCTSTR CInternetToolbar::CEditVerb::_GetDescription(EDITVERB& rVerb)
{
    // If we already have a description, we are done
    if (NULL == rVerb.pszDesc)
    {
        ASSERT(rVerb.hkeyProgID);

        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, rVerb.hkeyProgID,
            rVerb.fUseOpenVerb ? NULL : L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            rVerb.pszDesc = StrDup(sz);
            if (rVerb.pszDesc)
            {
                // Remove preceeding and trailing blanks
                PathRemoveBlanks(rVerb.pszDesc);
            }
        }
    }

    return rVerb.pszDesc;
}

//+-------------------------------------------------------------------------
// Reads the info associated with the progid at the given index.  This
// function allows us to do a lazy fetch of the info when requested.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_FetchInfo(UINT nIndex)
{
    ASSERT(nIndex < _nElements);
    ASSERT(_pVerb[nIndex].hkeyProgID != NULL);

    EDITVERB& rVerb = _pVerb[nIndex];

    //
    // Get the path to the edit verb's exe
    //
    if (_GetExePath(rVerb))
    {
        ASSERT(rVerb.pszExe);

        // Note that we fetched the friendly name earlier
        ASSERT(rVerb.pszDesc);

        // Now get the icon
        rVerb.iIcon = Shell_GetCachedImageIndex(rVerb.pszExe, 0, 0);
    }
    else
    {
        rVerb.iIcon = -1;
    }
}

//+-------------------------------------------------------------------------
// SetMSAAMenuInfo()
//
// Fills in MSAAMenuInfo part of EDITVERB from the other fields of the rVerb
//--------------------------------------------------------------------------

void CInternetToolbar::CEditVerb::_SetMSAAMenuInfo( EDITVERB& rVerb )
{

#ifdef UNICODE

    // If we're UNICODE, we can just refer to the m_pName of the MenuEntry itself...
    rVerb.m_MSAA.m_CharLen = lstrlen( rVerb.pszMenuText );
    rVerb.m_MSAA.m_pWStr = rVerb.pszMenuText;

#else // UNICODE

    // If we're ANSI, need to create a UNICODE string for the MSAA text...

    // Call MultiByteToWideChar first with 0 to get the size needed. (Assumes
    // m_pName is ASCII NUL terminated - cChars will include the terminating NUL)
    int cChars = MultiByteToWideChar( CP_ACP, 0, rVerb.pszMenuText, -1, NULL, 0 );

    // Don't want to include NUL in character length, so subtract one...
    rVerb.m_MSAA.m_CharLen = cChars - 1;

    // Now call MultiByteToWideChar to do the conversion.
    // MultiByteToWideChar adds the terminating WIDE-NUL for us, so we don't have to
    // add it explicitly...
    rVerb.m_MSAA.m_pWStr = new WCHAR [ cChars ];
    if (rVerb.m_MSAA.m_pWStr)
    {
        // Note - we don't delete[] the above allocated memory in this sample
        // code because we know that in this case it will be reclaimed by the system on
        // exit and won't give a leak.
        MultiByteToWideChar( CP_ACP, 0, rVerb.pszMenuText, -1, rVerb.m_MSAA.m_pWStr, cChars );
    }

#endif // UNICODE

    // Finally, add MSAAINFO signature...
    rVerb.m_MSAA.m_MSAASig = MSAA_MENU_SIG;
}


//+-------------------------------------------------------------------------
// ClearMSAAMenuInfo()
//
// Clean up MSAAMenuInfo - specifically, release the allocated
// UNICODE string, if appropriate...
//--------------------------------------------------------------------------

void CInternetToolbar::CEditVerb::_ClearMSAAMenuInfo( EDITVERB& rVerb )
{
    // Paranoia - clear signature...
    rVerb.m_MSAA.m_MSAASig = 0;

#ifdef UNICODE

    // We're unicode - nothing to do, since we didn't allocate anything.

#else // UNICODE

    // We're ANSI - release allocated UNICODE string...
    delete [] rVerb.m_MSAA.m_pWStr;

#endif // UNICODE
}


//+-------------------------------------------------------------------------
// Shows the edit pop-up menu.
//--------------------------------------------------------------------------
BOOL CInternetToolbar::CEditVerb::ShowEditMenu(POINT pt, HWND hwnd, LPTSTR pszURL)
{
    BOOL  bRet  = FALSE;
    HMENU hmEdit = CreatePopupMenu();

    if (hmEdit)
    {
        UINT idCmd = FCIDM_EDITFIRST;
        UINT nMax = FCIDM_EDITLAST - FCIDM_EDITFIRST;

        // Add each verb to the menu
        for (UINT i=0; i<_nElements && i < nMax; ++i)
        {
            EDITVERB& rVerb = _GetVerb(i);
            _FormatMenuText(i);
            rVerb.idCmd = idCmd;
            AppendMenu(hmEdit, MF_OWNERDRAW, idCmd, (LPCTSTR) &rVerb );

            // Fix up MSAAMenuInfo part...
            _SetMSAAMenuInfo( rVerb );

            ++idCmd;
        }

        // Temporarily subclass the hwnd to intercept the owner-draw messages
        if (SetProp(hwnd, SZ_EDITVERB_PROP, this))
        {
            ASSERT(!_lpfnOldWndProc);
            _lpfnOldWndProc = (WNDPROC) SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) _WndProc);

            idCmd = ITBar_TrackPopupMenuEx(hmEdit, TPM_RETURNCMD, pt.x, pt.y, hwnd, NULL);

            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_lpfnOldWndProc);
            _lpfnOldWndProc = NULL;
            RemoveProp(hwnd, SZ_EDITVERB_PROP);

            if (InRange(idCmd, FCIDM_EDITFIRST, FCIDM_EDITLAST))
            {
                // Execute the selected edit verb
                _Edit(pszURL, idCmd - FCIDM_EDITFIRST);
            }
        }

        DestroyMenu(hmEdit);
    }

    return bRet;
}

//+-------------------------------------------------------------------------
// Creates a menu string from the progid's description
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_FormatMenuText(UINT nIndex)
{
    ASSERT(nIndex < _nElements);

    EDITVERB& rVerb = _GetVerb(nIndex);
    if (rVerb.pszMenuText == NULL)
    {
        if (_GetDescription(rVerb))
        {
            TCHAR szFormat[100];
            TCHAR szMenuText[200];

            MLLoadString(IDS_EDITWITH, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szMenuText, ARRAYSIZE(szMenuText), szFormat, rVerb.pszDesc);
            SetStr(&((EDITVERB&)rVerb).pszMenuText, szMenuText);
        }
        else
        {
            // Things are really messed up
            ASSERT(FALSE);
            SetStr(&((EDITVERB&)rVerb).pszMenuText, TEXT(""));
        }
    }
}


//+-------------------------------------------------------------------------
// Executes the edit verb indicated by nIndex.
//--------------------------------------------------------------------------
void CInternetToolbar::CEditVerb::_Edit
(
    LPCTSTR pszURL,     // url assocated with the verb
    UINT nIndex         // verb to execute
)
{
    ASSERT(pszURL);

    if (nIndex >= _nElements)
    {
        return;
    }

    EDITVERB& rVerb = _pVerb[nIndex];
    int fMask = SEE_MASK_CLASSKEY;

    SHELLEXECUTEINFO sei = {0};

    TCHAR szCacheFileName[MAX_PATH + MAX_URL_STRING + 2];
    memset(szCacheFileName, 0, sizeof(szCacheFileName));

    if (PathIsURL(pszURL))
    {
        // We pass the url if the app has register that it wants this
        if ((WhichPlatform() == PLATFORM_BROWSERONLY) && DoesAppWantUrl(rVerb.pszExe))
        {
            //
            // Old versions of shell32 (PLATFORM_BROWSERONLY) ignore the SEE_MASK_FILEANDURL
            // flag, so on these platforms we check ourselves to see if the app
            // wants the url instead of the cache file name.
            //
            StrCpyN(szCacheFileName, pszURL, ARRAYSIZE(szCacheFileName));
            sei.lpFile = szCacheFileName;
        }
        else
        {
            // (reinerf)
            // Some apps (FrontPad, Office99, etc) want the URL passed to
            // them instead of the cache filename. We therefore create a string
            // that has the URL name after the null:
            //
            //  "CacheFileName/0UrlName"
            //
            // and pass it as the lpFile parameter to shellexecute.
            // We also pass SEE_MASK_FILEANDURL, so shellexecute can
            // recognize this case.
            //
            int iLength;

            if (FAILED(URLToCacheFile(pszURL, szCacheFileName, ARRAYSIZE(szCacheFileName))))
            {
                // Frontpage express crashes if we pass a null file name, so if the app doesn't
                // prefer the url instead, we bail.
                if (!DoesAppWantUrl(rVerb.pszExe))
                {
                    return;
                }
            }
            iLength = lstrlen(szCacheFileName);

            // copy in the URL name
            StrCpyN(&szCacheFileName[iLength + 1], pszURL, ARRAYSIZE(szCacheFileName) - (iLength + 1));

            // add the mask so shellexecute knows to check for the URL, if necessary.
            fMask |= SEE_MASK_FILEANDURL;
            sei.lpFile = szCacheFileName;
        }
    }
    else
    {
        // Not a URL, so pass the filename
        StrCpyN(szCacheFileName, pszURL, ARRAYSIZE(szCacheFileName));
        sei.lpFile = szCacheFileName;
    }

    // Hack for IE5 bug 50033 - Can remove when fpxpress fixes mru buffer overrun
    _GetExePath(rVerb);
    if(StrStr(rVerb.pszExe, TEXT("fpxpress.exe")) != NULL)
        szCacheFileName[256] = TEXT('\0');

    sei.cbSize = sizeof(SHELLEXECUTEINFO);
    sei.fMask = fMask;
    sei.hwnd = NULL;
    sei.lpVerb = rVerb.fUseOpenVerb ? NULL : TEXT("edit");
//    sei.lpFile = szCacheFileName;
//    sei.lpParameters = NULL;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    sei.hkeyClass= rVerb.hkeyProgID;

    //
    // The office guys want us to call a special proxy to get around some DDE problems
    // and to sniff the html file for the original document name. Hackers! So let's
    // see if it is registered.
    //
    HKEY hkeyProxy = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(rVerb.hkeyProgID, TEXT("HTML Handler"), 0, KEY_READ, &hkeyProxy))
    {
        DWORD cch;
        if (SUCCEEDED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProxy, L"edit", NULL, &cch)))
        {
            sei.lpVerb = L"edit";
            sei.hkeyClass = hkeyProxy;
        }
        else if (SUCCEEDED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, hkeyProxy, NULL, NULL, &cch)))
        {
            sei.lpVerb = NULL;
            sei.hkeyClass = hkeyProxy;
        }
    }

    ShellExecuteEx(&sei);

    if (hkeyProxy)
    {
        RegCloseKey(hkeyProxy);
    }
}

//+-------------------------------------------------------------------------
// This window procedure intercepts owner-draw menu messages when the edit
// pop-up menu is displayed.
//--------------------------------------------------------------------------
LRESULT CALLBACK CInternetToolbar::CEditVerb::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEditVerb* pThis = (CEditVerb*)GetProp(hwnd, SZ_EDITVERB_PROP);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    switch(uMsg)
    {
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        {
            UINT idCmd;

            switch (uMsg)
            {
                case WM_DRAWITEM:
                    idCmd = ((EDITVERB*)((DRAWITEMSTRUCT*)lParam)->itemData)->idCmd;
                    break;
                case WM_MEASUREITEM:
                    idCmd = ((EDITVERB*)((MEASUREITEMSTRUCT*)lParam)->itemData)->idCmd;
                    break;
            }

            if (InRange(idCmd, FCIDM_EDITFIRST, FCIDM_EDITLAST))
            {
                // do our own measuring
                UINT index  = idCmd - FCIDM_EDITFIRST;
                const EDITVERB& rVerb = pThis->_GetVerb(index);

                // We don't want the same accelerator on all items,
                // so remove underlines
                WCHAR wzBuf[MAX_PATH];
                UINT cchMax = ARRAYSIZE(wzBuf);
                LPWSTR pszTo = wzBuf;
                LPWSTR pszFrom = rVerb.pszMenuText;
                if (pszFrom)
                {
                    while (0 < --cchMax)
                    {
                        if (*pszFrom == L'&')
                        {
                            pszFrom++;
                            continue;
                        }

                        if ( !(*pszTo++ = *pszFrom++) )
                        {
                            --pszTo;
                            break;
                        }
                    }

                    if (0 == cchMax)
                        *pszTo = L'\0';

                    //
                    // In some locals, the accelerator is identified in brackets at the
                    // end of the string, so if we strip ampersands, we strip these too.
                    //
                    if (--pszTo >= wzBuf && *pszTo == L')')
                    {
                        while (--pszTo >= wzBuf)
                        {
                            if (*pszTo == L'(')
                            {
                                *pszTo = L'\0';
                                break;
                            }
                        }
                    }
                }
                else
                {
                    wzBuf[0] = 0;
                }

                switch (uMsg)
                {
                    case WM_MEASUREITEM:
                        MeasureMenuItem((MEASUREITEMSTRUCT *)lParam, wzBuf);
                        break;
                    case WM_DRAWITEM:
                        int iIcon = (rVerb.iIcon != -1) ? rVerb.iIcon : 0;
                        DrawMenuItem((LPDRAWITEMSTRUCT)lParam, wzBuf, iIcon);
                        break;
                }
            }
        }
        default:
           return CallWindowProc(pThis->_lpfnOldWndProc, hwnd, uMsg, wParam, lParam);
    }
    return 0L;
}

#endif // EDIT_HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "priv.h"

#include "..\inc\uassist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\itbdrop.cpp ===
//
//  ITBDROP.CPP
//  routines for implementing OLE drop target capability
//  within the internet toolbar control
//
//  History:
//      07/13/96 t-mkim     Created
//      10/13/96 chrisg     massive cleanup
//

#include "priv.h"
#include "itbdrop.h"
#include "sccls.h"

#include "resource.h"

#include "mluisupp.h"

#ifdef UNIX

#ifdef SIZEOF
#undef SIZEOF
#endif
#define SIZEOF(x)   sizeof(x)       // has been checked for UNICODE correctness

#endif

#define MAX_NAME_QUICKLINK 40

// Data type of the incoming data object.
#define CITBDTYPE_NONE      0
#define CITBDTYPE_HDROP     1
#define CITBDTYPE_URL       2
#define CITBDTYPE_TEXT      3



//  get an IDropTarget for shell special folders
//
HRESULT _GetSpecialDropTarget(UINT csidl, IDropTarget **ppdtgt)
{
    IShellFolder *psfDesktop;

    *ppdtgt = NULL;

    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidl;
        hres = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        if (SUCCEEDED(hres))
        {
            IShellFolder *psf;
            hres = psfDesktop->BindToObject(pidl, NULL, IID_IShellFolder, (void **)&psf);
            if (SUCCEEDED(hres))
            {
                hres = psf->CreateViewObject(NULL, IID_IDropTarget, (void **)ppdtgt);
                psf->Release();
            }

            ILFree(pidl);
        }
        psfDesktop->Release();
    }
    return hres;
}

//  Takes a variety of inputs and returns a string for drop targets.
//  szUrl:    the URL
//  szName:   the name (for quicklinks and the confo dialog boxes)
//  returns:  NOERROR if succeeded
//
HRESULT _GetURLData(IDataObject *pdtobj, int iDropType, TCHAR *pszUrl, DWORD cchUrl,  TCHAR *pszName)
{
    HRESULT hRes = NOERROR;
    STGMEDIUM stgmedium;
    UINT cfFormat;

    *pszName = 0;
    *pszUrl = 0;

    switch (iDropType)
    {
    case CITBDTYPE_HDROP:
        cfFormat = CF_HDROP;
        break;

    case CITBDTYPE_URL:
        InitClipboardFormats();
        cfFormat = g_cfURL;
        break;

    case CITBDTYPE_TEXT:
        cfFormat = CF_TEXT;
        break;

    default:
        return E_UNEXPECTED;
    }

    // Get the parse string
    LPCSTR pszURL = (LPCSTR)DataObj_GetDataOfType(pdtobj, cfFormat, &stgmedium);
    if (pszURL)
    {
        if (iDropType == CITBDTYPE_HDROP)
        {
            ASSERT(stgmedium.tymed == TYMED_HGLOBAL);

            TCHAR szPath[MAX_PATH];
            DragQueryFile((HDROP)stgmedium.hGlobal, 0, szPath, ARRAYSIZE(szPath));

            // defaults...
            lstrcpyn(pszUrl, szPath, MAX_URL_STRING);
            lstrcpyn(pszName, szPath, MAX_NAME_QUICKLINK);

            SHFILEINFO sfi;
            DWORD_PTR bGotInfo = SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES);
            if (bGotInfo)
                lstrcpyn(pszName, sfi.szDisplayName, MAX_NAME_QUICKLINK);

            if (bGotInfo && (sfi.dwAttributes & SFGAO_LINK))
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(GetLinkTargetIDList(szPath, pszUrl, cchUrl, &pidl)))
                {
                    // we only care about the name... thanks anyway.
                    ILFree(pidl);
                }
            }
        }
        else
        {
#ifdef UNICODE
            WCHAR wszURL[MAX_URL_STRING];
            SHAnsiToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
            LPTSTR pszURLData = wszURL;
#else
            LPTSTR pszURLData = pszURL;
#endif
            if (iDropType == CITBDTYPE_URL)
            {
                // defaults
                lstrcpyn(pszUrl,  pszURLData, MAX_URL_STRING);
                lstrcpyn(pszName, pszURLData, MAX_NAME_QUICKLINK);

                WCHAR szPath[MAX_PATH];

                if (SUCCEEDED(DataObj_GetNameFromFileDescriptor(pdtobj, szPath, ARRAYSIZE(szPath))))
                    PathToDisplayNameW(szPath, pszName, MAX_NAME_QUICKLINK);
                    
            }
            else // if (iDropType == CITBDTYPE_TEXT)
            {
                ASSERT(iDropType == CITBDTYPE_TEXT);

                lstrcpyn(pszUrl, pszURLData, MAX_URL_STRING);
                lstrcpyn(pszName, pszURLData, MAX_NAME_QUICKLINK);
            }
        }
    
        ReleaseStgMediumHGLOBAL(NULL, &stgmedium);
    }
    else
    {
        hRes = E_FAIL;
    }

    return hRes;
}

//  Displays a dialog asking for confirmation of drop-set operations.
//  Returns: User's response to the dialog box: YES = TRUE, NO = FALSE
//
BOOL _ConfirmChangeQuickLink(HWND hwndParent, TCHAR *pszName, int iTarget)
{
    MSGBOXPARAMS mbp;
    TCHAR szHeader[64];
    TCHAR szBuffer [MAX_NAME_QUICKLINK + 64];
    TCHAR szCaption [MAX_NAME_QUICKLINK + 64];
    UINT titleID, textID, iconID;

    switch (iTarget)
    {
    case TBIDM_HOME:
        titleID = IDS_SETHOME_TITLE;
        textID = IDS_SETHOME_TEXT;
        iconID = IDI_HOMEPAGE;
        break;
#if 0
    case TBIDM_SEARCH:
        titleID = IDS_SETSEARCH_TITLE;
        textID = IDS_SETSEARCH_TEXT;
        iconID = IDI_FRAME; // Warning if you unif0 this: IDI_FRAME is not in this dll
        break;
#endif

    default:
        return FALSE;           // We should never get here!
    }
    mbp.cbSize = sizeof (MSGBOXPARAMS);
    mbp.hwndOwner = hwndParent;
    mbp.hInstance = HinstShdocvw();
    mbp.dwStyle = MB_YESNO | MB_USERICON;
    MLLoadString(titleID, szCaption, ARRAYSIZE (szCaption));
    mbp.lpszCaption = szCaption;
    mbp.lpszIcon = MAKEINTRESOURCE (iconID);
    mbp.dwContextHelpId = 0;
    mbp.lpfnMsgBoxCallback = NULL;
    mbp.dwLanguageId = LANGIDFROMLCID (g_lcidLocale);

    MLLoadString(textID, szHeader, ARRAYSIZE (szHeader));
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), szHeader, pszName);
    mbp.lpszText = szBuffer;

    return MessageBoxIndirect(&mbp) == IDYES;
}

//  Creates an instance of CITBarDropTarget. ptr is a pointer to the parent
//  CInternetToolbar.
//
CITBarDropTarget::CITBarDropTarget(HWND hwnd, int iTarget) : 
    _cRef(1), _iDropType(CITBDTYPE_NONE), _hwndParent(hwnd), _iTarget(iTarget)
{
}

STDMETHODIMP CITBarDropTarget::QueryInterface(REFIID iid, void **ppvObj)
{
    if (IsEqualIID (iid, IID_IUnknown) || IsEqualIID (iid, IID_IDropTarget))
    { 
        *ppvObj = SAFECAST(this, IDropTarget*);
        AddRef(); 
        return NOERROR; 
    } 

    *ppvObj = NULL; 
    return E_NOINTERFACE; 
}

STDMETHODIMP_(ULONG) CITBarDropTarget::AddRef()
{
    _cRef++;
    return _cRef;
}

STDMETHODIMP_(ULONG) CITBarDropTarget::Release()
{
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

typedef struct
{
    int iTarget;
    int iDropType;
    HWND hwnd;
    TCHAR szUrl [MAX_URL_STRING];
    TCHAR szName [MAX_NAME_QUICKLINK];
} DROPDATA;


DWORD CALLBACK ITBarDropThreadProc(void *pv)
{
    DROPDATA *pdd = (DROPDATA *)pv;

    switch (pdd->iTarget)
    {
    case TBIDM_HOME:

        if (pdd->iDropType != CITBDTYPE_TEXT)
        {
            if (_ConfirmChangeQuickLink(pdd->hwnd, pdd->szName, pdd->iTarget)) {
                ASSERT(pdd->iTarget == TBIDM_HOME);
                // currently don't support pdd->itarget == TBIDM_SEARCH
                //(pdd->iTarget == TBIDM_HOME) ? DVIDM_GOHOME : DVIDM_GOSEARCH);
                _SetStdLocation(pdd->szUrl, DVIDM_GOHOME);
            }
        }
        break;

    case TBIDM_SEARCH:
        ASSERT(0);
        break;
    }

    LocalFree(pdd);

    return 0;
}

STDMETHODIMP CITBarDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    _DragEnter(_hwndParent, ptl, pdtobj);
    if (_iTarget == TBIDM_FAVORITES)
    {
        if (SUCCEEDED(_GetSpecialDropTarget(CSIDL_FAVORITES, &_pdrop)))
            _pdrop->DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
        else
            *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }
    else if (_iTarget == TBIDM_HOME)
    {
        HKEY                hkeyRest = 0;
        DWORD               dwValue = 0;
        DWORD               dwLen = sizeof(DWORD);

        // Check if setting home page is restricted
    
        if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SET_HOMEPAGE_RESTRICTION, 0,
                         KEY_READ, &hkeyRest) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkeyRest, REGVAL_HOMEPAGE_RESTRICTION, NULL, NULL,
                                (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS
                && dwValue)
            {
                return E_ACCESSDENIED;
            }
    
            RegCloseKey(hkeyRest);
        }
    }

    
    InitClipboardFormats();

    // Find the drop object's data format.
    FORMATETC fe = {g_cfURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_URL;
    }
    else if (fe.cfFormat = CF_HDROP, NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_HDROP;
    }
    else if (fe.cfFormat = CF_TEXT, NOERROR == pdtobj->QueryGetData (&fe))
    {
        _iDropType = CITBDTYPE_TEXT;
        // We want to eventually pick through the text for an
        // URL, but right now we just leave it unmolested.
    }
    DragOver (grfKeyState, ptl, pdwEffect);
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectAvail;
    _DragMove(_hwndParent, ptl);
    if (_iTarget == TBIDM_FAVORITES)
    {
        if (_pdrop)
            return _pdrop->DragOver(grfKeyState, ptl, pdwEffect);

        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }
    ASSERT(!_pdrop);

    if (_iDropType == CITBDTYPE_NONE)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return NOERROR;
    }

    dwEffectAvail = DROPEFFECT_NONE;
    switch (_iTarget)
    {
        case TBIDM_HOME:
        case TBIDM_SEARCH:
            if (_iDropType == CITBDTYPE_TEXT)
            {
                // CF_TEXT doesn't do link.
            }
            else
                dwEffectAvail = DROPEFFECT_LINK;
            break;
    }
    *pdwEffect &= dwEffectAvail;
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    BOOL fSafe = TRUE;
    LPITEMIDLIST pidl;

    if (_pdrop)
    {
        ASSERT(_iTarget == TBIDM_FAVORITES);

        //
        // Force a linking since we are passing straight through to the folder.
        // This avoids confusion when dragging to the toolbar button.
        //
        // FEATURE: this should really go through the "Add to Favorites" UI
        //

        // When forcing a link, make sure that you can move it. If you cannot move it,
        // then we rely on the prefered effect of the data object. Why? Well, the history
        // folder only allows a copy. If you just whack this to LINK, the shell folder hoses
        // the drag images (Does a DAD_SetDragImage(NULL), blowing away the information about
        // the last locked window, without unlocking it.). So, if you can move the item, 
        // you can link to it (I guess), but if you cannot move it, do whatever. 
        //     - (lamadio) 1.3.99
        if (*pdwEffect & DROPEFFECT_MOVE)
            *pdwEffect = DROPEFFECT_LINK;

        if (TBIDM_FAVORITES == _iTarget &&
            SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }

        if (fSafe)
        {
            _pdrop->Drop(pdtobj, grfKeyState, pt, pdwEffect);
        }
        else
        {
            pdtobj->Release();  // Match Release called in _pdrop->Drop.
        }
       
        DAD_DragLeave();

        _pdrop->Release();
        _pdrop = NULL;
    }
    else
    {
        if (TBIDM_HOME == _iTarget &&
            SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_HOME);
            ILFree(pidl);
        }

        if (fSafe)
        {
            DROPDATA *pdd = (DROPDATA *)LocalAlloc (LPTR, sizeof(DROPDATA));
            if (pdd)
            {
                pdd->iTarget = _iTarget;
                pdd->iDropType = _iDropType;
                pdd->hwnd = _hwndParent;

                // do this async so we don't block the source of the drag durring our UI
                if (FAILED(_GetURLData(pdtobj, _iDropType, pdd->szUrl, ARRAYSIZE(pdd->szUrl), pdd->szName)) ||
                    !SHCreateThread(ITBarDropThreadProc, pdd, 0, NULL))
                    LocalFree(pdd);
            }
        }
        DragLeave();
    }
    return NOERROR;
}

STDMETHODIMP CITBarDropTarget::DragLeave(void)
{
    DAD_DragLeave();
    // Check if we should to pass to the favorites dt.
    if (_pdrop)
    {
        ASSERT(_iTarget == TBIDM_FAVORITES);
        _pdrop->DragLeave();
        _pdrop->Release();
        _pdrop = NULL;
    }
    _iDropType = CITBDTYPE_NONE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\logo.h ===
#ifndef _LOGO_H
#define _LOGO_H

typedef HRESULT (* LPUPDATEFN)( void *pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

#define LOGO_HEIGHT 32
#define LOGO_WIDE_WIDTH 194
#define LOGO_WIDTH  80

class CLogoBase
{
public:
    CLogoBase( BOOL fWide = FALSE );
    ~CLogoBase();

    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    static void _Initialize( void );
    static void _Cleanup( void );
    
    virtual IShellFolder * GetSF() PURE;
    virtual HWND GetHWND() PURE;

    inline HIMAGELIST GetLogoHIML( void );
    
    // intialisation functions
    HRESULT InitLogoView( void );
    HRESULT ExitLogoView( void );

    int GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    int GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick );

    HRESULT AddTaskToQueue( IRunnableTask *pTask, DWORD dwPriority, DWORD lParam );
    
    // create the default logo for an item....
    HRESULT CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo);

    HRESULT FlushLogoCache( void );

    HRESULT AddRefLogoCache( void );
    HRESULT ReleaseLogoCache( void );

    // get the task ID used with the task scheduler
    virtual REFTASKOWNERID GetTOID( void ) PURE;

    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache ) PURE;

    HRESULT DitherBitmap( HBITMAP hBmp, HBITMAP * phBmpNew );

    int AddIndicesToLogoList( int iIcon, UINT uIndex );

    int FindLogoFromIcon( int iIcon, int * piLastLogo );
    
protected:
    
    int GetCachedLogoIndex(DWORD dwItem, LPCITEMIDLIST pidl, IRunnableTask **ppTask, DWORD * pdwPriority, DWORD * pdwFlags );
    
    IImageCache * _pLogoCache;              // My be NULL in low memory conditions.
    IShellTaskScheduler * _pTaskScheduler;
    HIMAGELIST _himlLogos;
    SIZEL _rgLogoSize;
    DWORD _dwClrDepth;
    HDSA  _hdsaLogoIndices;

    static CRITICAL_SECTION s_csSharedLogos;
    static long             s_lSharedWideLogosRef;
    static IImageCache *    s_pSharedWideLogoCache;
    static HDSA             s_hdsaWideLogoIndices;

    HPALETTE _hpalHalftone;
    BOOL     _fWide;
};

inline HIMAGELIST CLogoBase::GetLogoHIML( )
{
    return _himlLogos;
}

struct LogoIndex
{
    int iIcon;
    int iLogo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy.h ===
#ifndef __LEGACY_H__
#define __LEGACY_H__

#include "logo.h"

#define CGID_MenuBand CLSID_MenuBand
#define CGID_ISFBand  CLSID_ISFBand
#define SID_SDropBlocker CLSID_SearchBand


// REARCHITECT: An exercise for the reader, how many of these are unused now?
#define MBANDCID_GETFONTS       1       // Command Id for getting font info
#define MBANDCID_RECAPTURE      2       // Take the mouse capture back
#define MBANDCID_NOTAREALSITE   3       // This is not a real site
#define MBANDCID_SELECTITEM     5       // Select an item
#define MBANDCID_POPUPITEM      6       // Popup an item
#define MBANDCID_ITEMDROPPED    7       // Item was dropped into a menu
#define MBANDCID_DRAGENTER      8       // Entering a drag operation
#define MBANDCID_DRAGLEAVE      9       // Leaving a Drag operation
#define MBANDCID_ISVERTICAL     10      // Is this a vertical band
#define MBANDCID_RESTRICT_CM    11      // Disallow ContextMenu
#define MBANDCID_RESTRICT_DND   12      // Disallow Drag And Drop
#define MBANDCID_EXITMENU       13      // Nofity: Exiting Menu
#define MBANDCID_ENTERMENU      14      // Notify: Entering Menu
#define MBANDCID_SETACCTITLE    15      // Sets the title of the band
#define MBANDCID_SETICONSIZE    16
#define MBANDCID_SETFONTS       17
#define MBANDCID_SETSTATEOBJECT 18      // Sets the global state
#define MBANDCID_ISINSUBMENU    19      // Returns S_OK if in submenu, S_FALSE if not.
#define MBANDCID_EXPAND         20      // Cause this band to expand
#define MBANDCID_KEYBOARD       21      // Popuped up because of a keyboard action
#define MBANDCID_DRAGCANCEL     22      // Close menus because of drag
#define MBANDCID_REPOSITION     23      // 
#define MBANDCID_EXECUTE        24      // sent to the site when somethis is executed.
#define MBANDCID_ISTRACKING     25      // Tracking a Context Menu

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);

class CISFBand;
HRESULT CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

typedef enum {
    ISFBID_PRIVATEID        = 1,
    ISFBID_ISITEMVISIBLE    = 2,
    ISFBID_CACHEPOPUP       = 3,
    ISFBID_GETORDERSTREAM   = 4,
    ISFBID_SETORDERSTREAM   = 5,
} ISFBID_FLAGS;

HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

extern long g_lMenuPopupTimeout;

#define QLCMD_SINGLELINE 1

#define CITIDM_VIEWTOOLS     4      // This toggles on/off
#define CITIDM_VIEWADDRESS   5      // This toggles on/off
#define CITIDM_VIEWLINKS     6      // This toggles on/off
#define CITIDM_SHOWTOOLS     7      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWADDRESS   8      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_SHOWLINKS     9      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_EDITPAGE      10
#define CITIDM_BRANDSIZE     11     // brand at minimum always or not
#define CITIDM_VIEWMENU      12      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_VIEWAUTOHIDE  13      // nCmdExecOpt: TRUE or FALSE
#define CITIDM_GETMINROWHEIGHT 14    // gets the minimum height of row 0... for branding
#define CITIDM_SHOWMENU      15
#define CITIDM_STATUSCHANGED 16
#define CITIDM_GETDEFAULTBRANDCOLOR 17
#define CITIDM_DISABLESHOWMENU      18
#define CITIDM_SET_DIRTYBIT         19  // nCmdexecopt equals TRUE or FALSE which will overwrite _fDirty.
#define CITIDM_VIEWTOOLBARCUSTOMIZE       20
#define CITIDM_VIEWEXTERNALBAND_BYCLASSID 21
#define CITIDM_DISABLEVISIBILITYSAVE 22 // bands can choose not to persist their visibility state
#ifdef UNIX
#define CITIDM_SHOWBRAND     25     //nCmdExecOpt:  TRUE or FALSE 
#endif 
#define CITIDM_GETFOLDERSEARCHES        26

// iBar/xBar stuff
#define CITIDM_VIEWLOCKTOOLBAR     27

#define TOOLBAR_MASK 0x80000000

#endif // __LEGACY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\makefile.inc ===
LIBOBJ          = $(CCSHELL_DIR)\lib\$O

clean:
    -del /F /Q $(NTTARGETFILE0)
    -del /F /Q $(NTTARGETFILES)


# These are the dependencies that the RC file has
#
..\browseui.rc: $(SELFREGNAME)


!include $(CCSHELL_DIR)\makefile.inc

#
# Copy browseui libs to shell\lib\$(O)
#
$(LIBOBJ)\browseui.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\browseui.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@

$(LIBOBJ)\browseuip.lib: $(TARGETPATH)\$(TARGET_DIRECTORY)\browseuip.lib
    if not exist $(TARGETPATH)\nul md $(TARGETPATH)
    if not exist $(LIBOBJ)\nul md $(LIBOBJ)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbbehave.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:      mbBehave.h
//
//  Contents:  mediaBar player behavior
//
//  Classes:   CMediaBehavior
//
//------------------------------------------------------------------------

#ifndef _MB_BEHAVE_H_
#define _MB_BEHAVE_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include "dpa.h"
#include "dspsprt.h"

class   CMediaBand;
class   CMediaBehavior;


interface IMediaBehaviorContentProxy  : public IUnknown
{
    STDMETHOD(IsDisableUIRequested)(BOOL *pfRequested) PURE;
    STDMETHOD(OnUserOverrideDisableUI)(void) PURE;
    STDMETHOD(IsNextEnabled)(BOOL *pfEnabled) PURE;
};
// {F4C74D34-AB35-4d67-A7CF-7845548F45A8}
DEFINE_GUID(IID_IMediaBehaviorContentProxy, 0xf4c74d34, 0xab35, 0x4d67, 0xa7, 0xcf, 0x78, 0x45, 0x54, 0x8f, 0x45, 0xa8);

/*
interface IMediaHost2  : public IMediaHost
{
    virtual STDMETHOD(DetachBehavior)(void) PURE;
    virtual STDMETHOD(OnDisableUIChanged)(BOOL fDisabled) PURE;
};
// {895EBF7E-ECA0-4ba8-B0F2-89DEBF70DE65}
DEFINE_GUID(IID_IMediaHost2, 0x895ebf7e, 0xeca0, 0x4ba8, 0xb0, 0xf2, 0x89, 0xde, 0xbf, 0x70, 0xde, 0x65);
*/


//------------------------------------------------------------------------
//------------------------------------------------------------------------
// need an additional operator to easily assign from VARIANTs
class CComDispatchDriverEx : public CComDispatchDriver
{
public:
    IDispatch* operator=(VARIANT vt)
    {
        IDispatch   *pThis = NULL;
        ASSERT((V_VT(&vt) == VT_UNKNOWN) || (V_VT(&vt) == VT_DISPATCH));
        if (V_VT(&vt) == VT_UNKNOWN) 
        {
            pThis = (IDispatch*) AtlComQIPtrAssign((IUnknown**)&p, V_UNKNOWN(&vt), IID_IDispatch);
        }
        else if (V_VT(&vt) == VT_DISPATCH)
        {
            pThis = (IDispatch*)AtlComPtrAssign((IUnknown**)&p, V_DISPATCH(&vt));
        }

        // ISSUE could make more efforts to accept REF variants too
        return pThis;
    }

    // get a property by name with a single parameter
    HRESULT GetPropertyByName1(LPCOLESTR lpsz, VARIANT* pvarParam1, VARIANT* pVar)
    {
        DISPID dwDispID;
        HRESULT hr = GetIDOfName(lpsz, &dwDispID);
        if (SUCCEEDED(hr))
        {
            DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
            return p->Invoke(dwDispID, IID_NULL,
                            LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
                            &dispparams, pVar, NULL, NULL);
        }
        return hr;
    }
};


//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CWMPWrapper
{
public:
    HRESULT             AttachToWMP();


protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj) = 0;
    STDMETHODIMP_(ULONG) _AddRef(void)
                        {
                            _cRef++;
                            return _cRef;
                        }
    STDMETHODIMP_(ULONG) _Release(void)
                        {
                            ASSERT(_cRef > 0);
                            _cRef--;
                            if (_cRef > 0)  return _cRef;
                            delete this;
                            return 0;
                        }
    HRESULT             _getVariantProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, VARIANT *pvtValue, BOOL fCallMethod = FALSE);
    HRESULT             _getStringProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, OUT BSTR *pbstrValue, BOOL fCallMethod = FALSE);

protected:
                        CWMPWrapper(CMediaBehavior* pHost);
    virtual            ~CWMPWrapper();

protected:
    CMediaBehavior    * _pHost;
    CComDispatchDriverEx    _pwmpWrapper;
    BOOL                _fStale;

private:
    ULONG               _cRef;
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaItem        :   public CWMPWrapper,
                            public IMediaItem,
                            protected CImpIDispatch
{
typedef CWMPWrapper super;
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return _AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return _Release(); }
    
    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** IMediaItem
    STDMETHOD(get_sourceURL)(BSTR *pbstrSourceURL);
    STDMETHOD(get_name)(BSTR *pbstrName);
    STDMETHOD(get_duration)(double * pDuration);
    STDMETHOD(get_attributeCount)(long *plCount);
    STDMETHOD(getAttributeName)(long lIndex, BSTR *pbstrItemName);
    STDMETHOD(getItemInfo)(BSTR bstrItemName, BSTR *pbstrVal);

protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CMediaItem*  CMediaItem_CreateInstance(CMediaBehavior* pHost);

                        CMediaItem(CMediaBehavior* pHost);
    virtual            ~CMediaItem();



private:
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaItemNext        :   public CMediaItem
{
public:
protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CMediaItemNext*  CMediaItemNext_CreateInstance(CMediaBehavior* pHost);

                        CMediaItemNext(CMediaBehavior* pHost);
    virtual            ~CMediaItemNext();

private:
};

//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CPlaylistInfo        :   public CWMPWrapper,
                               public IPlaylistInfo,
                               protected CImpIDispatch
{
typedef CWMPWrapper super;
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return _AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return _Release(); }
    
    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    // *** IPlaylistInfo
    STDMETHOD(get_name)(BSTR *pbstrName);
    STDMETHOD(get_attributeCount)(long *plCount);
    STDMETHOD(getAttributeName)(long lIndex, BSTR *pbstrItemName);
    STDMETHOD(getItemInfo)(BSTR bstrItemName, BSTR *pbstrVal);

protected:
    virtual HRESULT     FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj);
    friend CPlaylistInfo*  CPlaylistInfo_CreateInstance(CMediaBehavior* pHost);

                        CPlaylistInfo(CMediaBehavior* pHost);
private:
    virtual            ~CPlaylistInfo();

private:
};



//------------------------------------------------------------------------
//------------------------------------------------------------------------
class CMediaBehavior        :   public IMediaBehavior,
                                public IElementBehavior,
                                public IContentProxy,
                                public IMediaBehaviorContentProxy,
                                protected CImpIDispatch
{
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)
                        {
                            _cRef++;
                            return _cRef;
                        }
    STDMETHODIMP_(ULONG) Release(void)
                        {
                            ASSERT(_cRef > 0);
                            _cRef--;
                            if (_cRef > 0)  return _cRef;
                            delete this;
                            return 0;
                        }

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);

    // *** IElementBehavior ***
    STDMETHOD(Detach)(void);
    STDMETHOD(Init)(IElementBehaviorSite* pBehaviorSite);
    STDMETHOD(Notify)(LONG lEvent, VARIANT* pVar);

    // *** IMediaBehavior ***
    STDMETHOD(playURL)(BSTR bstrURL, BSTR bstrMIME);
    STDMETHOD(stop)();
    STDMETHOD(playNext)();
    
    STDMETHOD(get_currentItem)(IMediaItem **ppMediaItem);
    STDMETHOD(get_nextItem)(IMediaItem **ppMediaItem);
    STDMETHOD(get_playlistInfo)(IPlaylistInfo **ppPlaylistInfo);

    STDMETHOD(get_hasNextItem)(VARIANT_BOOL *pfhasNext);
    STDMETHOD(get_playState)(mbPlayState *pps);
    STDMETHOD(get_openState)(mbOpenState *pos);
    STDMETHOD(get_enabled)(VARIANT_BOOL *pbEnabled);
    STDMETHOD(put_enabled)(VARIANT_BOOL bEnabled);
    STDMETHOD(get_disabledUI)(VARIANT_BOOL *pbDisabled);
    STDMETHOD(put_disabledUI)(VARIANT_BOOL bDisable);

    // *** IContentProxy **
    STDMETHOD(fireEvent)(enum contentProxyEvent event);
    STDMETHOD(OnCreatedPlayer)(void);
    STDMETHOD(detachPlayer)(void);

    // *** IMediaBehaviorContentProxy **
    STDMETHOD(IsDisableUIRequested)(BOOL *pfRequested);
    STDMETHOD(OnUserOverrideDisableUI)(void);
    STDMETHOD(IsNextEnabled)(BOOL *pfEnabled);

    HRESULT             getWMP(IDispatch **ppPlayer);
    HRESULT             getPlayListIndex(LONG *plIndex, LONG *plCount);

protected:
    friend CMediaBehavior* CMediaBehavior_CreateInstance(CMediaBand* pHost);

                        CMediaBehavior(CMediaBand* pHost);
private:
    virtual            ~CMediaBehavior();

private:
    HRESULT             _ConnectToWmpEvents(BOOL fConnect);
    BOOL                _ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[]);

private:
    ULONG               _cRef;
    CMediaBand        * _pHost;
    CComPtr<IElementBehaviorSite>   _pBehaviorSite;
    CComPtr<IElementBehaviorSiteOM>   _pBehaviorSiteOM;
    DWORD               _dwcpCookie;
    BOOL                _fDisabledUI;
    CDPA<CMediaItem>    _apMediaItems;
    BOOL                _fPlaying;
};


//------------------------------------------------------------------------


#endif // _MB_BEHAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbdrop.cpp ===
//
//  Routines for implementing drop target capability to menubands.
//

#include "priv.h"
#include "mbdrop.h"
#include "iface.h"      // for MBIF_

#define SUPERCLASS 


//=================================================================
// Implementation of CMenuBandDropTarget
//=================================================================

// Constructor
CMenuBandDropTarget::CMenuBandDropTarget(HWND hwnd, int idTarget, DWORD dwFlags) : 
    _cRef(1), _hwndParent(hwnd), _idTarget(idTarget), _dwFlagsMBIF(dwFlags)
{
}

STDMETHODIMP_(ULONG) CMenuBandDropTarget::AddRef()
{
    _cRef++;
    return _cRef;
}


STDMETHODIMP_(ULONG) CMenuBandDropTarget::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0) 
        return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP CMenuBandDropTarget::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(CMenuBandDropTarget, IDropTarget),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

*/
STDMETHODIMP CMenuBandDropTarget::DragEnter(IDataObject * pdtobj, DWORD grfKeyState, 
                                  POINTL pt, DWORD * pdwEffect)
{
    // If this item cascades out, then we want to pop the submenu open 
    // after a timer.  We don't allow a drop on the cascadable item
    // itself.  (We could, but then we'd have to default to a location
    // inside the submenu, and I'm lazy right now.)

    if (*pdwEffect & (DROPEFFECT_MOVE | DROPEFFECT_COPY)) 
    {
        if (_dwFlagsMBIF & SMIF_SUBMENU)
        {
            // _idTimer = SetTimer(NULL, 0, 2000, 
        }

        *pdwEffect &= (DROPEFFECT_MOVE | DROPEFFECT_COPY);
    }
    else
        *pdwEffect = DROPEFFECT_NONE;

    return S_OK;
}    


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
STDMETHODIMP CMenuBandDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    *pdwEffect &= (DROPEFFECT_MOVE | DROPEFFECT_COPY);
    return S_OK;
}    


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
STDMETHODIMP CMenuBandDropTarget::DragLeave(void)
{
    // Kill timer, release object
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
STDMETHODIMP CMenuBandDropTarget::Drop(IDataObject * pdtobj, DWORD grfKeyState, POINTL pt, 
                                       DWORD * pdwEffect)
{
    if (*pdwEffect & (DROPEFFECT_MOVE | DROPEFFECT_COPY)) 
    {
        if (_dwFlagsMBIF & SMIF_SUBMENU)
        {
            // We don't allow drops on submenu items.  Must go into
            // cascaded menu.
            *pdwEffect = DROPEFFECT_NONE;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbdrop.h ===
#ifndef _MBDROP_H_
#define _MBDROP_H_

// The CMenuBand class handles all menu behavior for bands.  

class CMenuBandDropTarget : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *dtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    
    CMenuBandDropTarget(HWND hwnd, int idTarget, DWORD dwFlagsMBIF);

protected:

    // Member variables
    int     _cRef;
    HWND    _hwndParent;
    IDropTarget *_pdrop;    // hand on to the the favorites target
    int     _iDropType;     // Which format data is in.
    int     _idTimer;

    int     _idTarget;      // ID of menu item we're hovering over
    DWORD   _dwFlagsMBIF;   // MBIF_*
};


#endif  // _MBDROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbbehave.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:      mbBehave.cpp
//
//  Contents:  mediaBar player behavior
//
//  Classes:   CMediaBehavior
//
//------------------------------------------------------------------------

#include "priv.h"
#define INITGUID        // pull in additional declaration for private mediabar IIDs
#include "initguid.h"
#include "mbBehave.h"
#undef INITGUID
#include "mediaBand.h"
#include "mediautil.h"
#include "varutil.h"
#include <mluisupp.h>
#include "resource.h"

//================================================================================================
//  CMediaBehavior
//================================================================================================

#define NO_COOKIE   -1


// event names fired from this behavior:
// NOTE: need to match the enums in the mbBehave.h with this array!!!
struct _eventInfo {
    LONG        levtCookie;
    LPWSTR      pwszName;
} s_behaviorEvents[] =
{
    NO_COOKIE,  L"OnOpenStateChange",
    NO_COOKIE,  L"OnPlayStateChange",
    NO_COOKIE,  L"OnShow",
    NO_COOKIE,  L"OnHide",
};

#ifndef WMPCOREEVENT_BASE
// ISSUE/010430/davidjen  should be pulled in from wmp.idl, but this file is not part of source tree
#define INITGUID        // define GUID, not only declare it
#include "initguid.h"
DEFINE_GUID(DIID__WMPOCXEvents,0x6BF52A51,0x394A,0x11d3,0xB1,0x53,0x00,0xC0,0x4F,0x79,0xFA,0xA6);
#define WMPCOREEVENT_BASE                       5000
#define DISPID_WMPCOREEVENT_OPENSTATECHANGE     (WMPCOREEVENT_BASE + 1)
#define WMPCOREEVENT_CONTROL_BASE               5100
#define DISPID_WMPCOREEVENT_PLAYSTATECHANGE     (WMPCOREEVENT_CONTROL_BASE + 1)
#undef INITGUID
#endif



// class factories
//------------------------------------------------------------------------
CMediaBehavior *
    CMediaBehavior_CreateInstance(CMediaBand* pHost)
{
    return new CMediaBehavior(pHost);
}

//------------------------------------------------------------------------
CMediaItem *
    CMediaItem_CreateInstance(CMediaBehavior* pHost)
{
    return new CMediaItem(pHost);
}

//------------------------------------------------------------------------
CMediaItemNext *
    CMediaItemNext_CreateInstance(CMediaBehavior* pHost)
{
    return new CMediaItemNext(pHost);
}

//------------------------------------------------------------------------
CPlaylistInfo *
    CPlaylistInfo_CreateInstance(CMediaBehavior* pHost)
{
    return new CPlaylistInfo(pHost);
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaBehavior
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaBehavior::CMediaBehavior(CMediaBand* pHost)
  : CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IMediaBehavior),
    _cRef(0),
    _dwcpCookie(0),
    _fDisabledUI(FALSE),
    _fPlaying(FALSE)
{
    ASSERT(pHost);
    _pHost = pHost;
    if (_pHost)
    {
        _pHost->AddRef();
        HRESULT hr = _pHost->addProxy((IContentProxy*)this);
        ASSERT(SUCCEEDED(hr));
    }
}

//------------------------------------------------------------------------
CMediaBehavior::~CMediaBehavior()
{
    Detach();   // to be sure...
    if (_pHost)
        _pHost->Release();
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMediaBehavior, IElementBehavior),
        QITABENT(CMediaBehavior, IMediaBehavior),
        QITABENT(CMediaBehavior, IDispatch),
        QITABENTMULTI2(CMediaBehavior, DIID__WMPOCXEvents, IDispatch),
        QITABENT(CMediaBehavior, IContentProxy),
        QITABENT(CMediaBehavior, IMediaBehaviorContentProxy),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Detach(void)
{
    _ConnectToWmpEvents(FALSE);

    // detach from behavior site
    if (_pHost)
    {
        _pHost->removeProxy(SAFECAST(this, IContentProxy*));    // optimize: _pHost saves ptr as IContentProxy, this saves a QI
        _pHost->Release();
        _pHost = NULL;
    }
    _fPlaying = FALSE;

    if (_apMediaItems != NULL)
    {
        int cnt = _apMediaItems.GetPtrCount();
        for (int i = 0; i < cnt; i++)
        {
            CMediaItem* pItem = _apMediaItems.GetPtr(i);
            if (pItem) 
                pItem->Release();
        }
        _apMediaItems.Destroy();
    }

    _pBehaviorSite.Release();
    _pBehaviorSiteOM.Release();
    for (int i = 0; i < ARRAYSIZE(s_behaviorEvents); i++)
    {
        s_behaviorEvents[i].levtCookie = NO_COOKIE;
    }
    
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Init(IElementBehaviorSite* pBehaviorSite)
{
    ASSERT(pBehaviorSite);
    if (pBehaviorSite == NULL)  return E_POINTER;

    _pBehaviorSite = pBehaviorSite;

    pBehaviorSite->QueryInterface(IID_PPV_ARG(IElementBehaviorSiteOM, &_pBehaviorSiteOM));
    ASSERT(_pBehaviorSiteOM != NULL);

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Notify(LONG lEvent, VARIANT* pVar)
{
// ISSUE/000923/davidjen 
// these enums require behavior.idl; this idl is only available in inetcore,
// might have to be moved to shell/published or mergedcomponents
/*
    switch (lEvent) {
    case BEHAVIOREVENT_CONTENTCHANGE:
        break;
    case BEHAVIOREVENT_DOCUMENTREADY:
        break;
    }
*/
    return S_OK;
}


// *** IDispatch ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    if (!_ProcessEvent(dispidMember, pdispparams->cArgs, pdispparams->rgvarg))
    {
        return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    return S_OK;
}

//------------------------------------------------------------------------
BOOL CMediaBehavior::_ProcessEvent(DISPID dispid, long lCount, VARIANT varParams[])
{
    BOOL fHandled = FALSE;
    switch (dispid)
    {
      case DISPID_WMPCOREEVENT_PLAYSTATECHANGE:
          ASSERT(lCount == 1);
          ASSERT(V_VT(&varParams[0]) == VT_I4);
          fireEvent(OnPlayStateChange);
          fHandled = TRUE;
          break;
      case DISPID_WMPCOREEVENT_OPENSTATECHANGE:
          ASSERT(lCount == 1);
          ASSERT(V_VT(&varParams[0]) == VT_I4);
          fireEvent(OnOpenStateChange);
          fHandled = TRUE;
          break;
      default:
          fHandled = FALSE;
          break;
    }
    return fHandled;
}


// *** IMediaBehavior ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::playURL(BSTR bstrURL, BSTR bstrMIME)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    _fPlaying = TRUE;
    _pHost->playURL(bstrURL, bstrMIME);
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::stop()
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    return IUnknown_Exec(SAFECAST(_pHost, IMediaBar*), &CLSID_MediaBand, FCIDM_MEDIABAND_STOP, 0, NULL, NULL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::playNext()
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    return IUnknown_Exec(SAFECAST(_pHost, IMediaBar*), &CLSID_MediaBand, FCIDM_MEDIABAND_NEXT, 0, NULL, NULL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_currentItem(IMediaItem **ppMediaItem)
{
    if (ppMediaItem == NULL)
        return E_POINTER;
    *ppMediaItem = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CMediaItem *pItem = CMediaItem_CreateInstance(this);
    if (pItem)
    {
        pItem->AddRef();    // keep object alive with ref count >= 1
        hr = pItem->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pItem->QueryInterface(IID_PPV_ARG(IMediaItem, ppMediaItem));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pItem);     // keep a ref for us
        }
        pItem->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_nextItem(IMediaItem **ppMediaItem)
{
    if (ppMediaItem == NULL)
        return E_POINTER;
    *ppMediaItem = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CMediaItemNext *pItem = CMediaItemNext_CreateInstance(this);
    if (pItem)
    {
        pItem->AddRef();    // keep object alive with ref count >= 1
        hr = pItem->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pItem->QueryInterface(IID_PPV_ARG(IMediaItem, ppMediaItem));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pItem);     // keep a ref for us
        }
        pItem->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_playlistInfo(IPlaylistInfo **ppPlaylistInfo)
{
    if (ppPlaylistInfo == NULL)
        return E_POINTER;
    *ppPlaylistInfo = NULL;

    HRESULT hr = S_OK;
    if (_apMediaItems == NULL) {
        _apMediaItems.Create(2);
    }
    if (_apMediaItems == NULL)
        return E_OUTOFMEMORY;

    CPlaylistInfo *pInfo = CPlaylistInfo_CreateInstance(this);
    if (pInfo)
    {
        pInfo->AddRef();    // keep object alive with ref count >= 1
        hr = pInfo->AttachToWMP();
        if (SUCCEEDED(hr))
        {
            hr = pInfo->QueryInterface(IID_PPV_ARG(IPlaylistInfo, ppPlaylistInfo));
//            pItem->AddRef();
//            _apMediaItems.AppendPtr(pInfo);     // keep a ref for us
        }
        pInfo->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_hasNextItem(VARIANT_BOOL *pfhasNext)
{
    if (pfhasNext == NULL)
    {
        return E_POINTER;
    }
    *pfhasNext = VARIANT_FALSE;
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }

    LONG currTrack = 0;
    LONG cntTracks = 0;
    HRESULT hr = getPlayListIndex(&currTrack, &cntTracks);
    if (SUCCEEDED(hr))
    {
        *pfhasNext = ((currTrack >= 0) && (currTrack < cntTracks - 1)) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_playState(mbPlayState *pps)
{
    if (pps == NULL)
        return E_POINTER;
    *pps = mbpsUndefined;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pps = mbpsUndefined;
        return S_OK;
    }

    CComVariant vtPlayState;
    hr = pwmpPlayer.GetPropertyByName(L"playState", &vtPlayState);
    if (SUCCEEDED(hr) && (V_VT(&vtPlayState) == VT_I4))
    {
        *pps = (mbPlayState) V_I4(&vtPlayState);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_openState(mbOpenState *pos)
{
    if (pos == NULL)
        return E_POINTER;
    *pos = mbosUndefined;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pos = mbosUndefined;
        return S_OK;
    }

    CComVariant vtOpenState;
    hr = pwmpPlayer.GetPropertyByName(L"openState", &vtOpenState);
    if (SUCCEEDED(hr) && (V_VT(&vtOpenState) == VT_I4))
    {
        *pos = (mbOpenState) V_I4(&vtOpenState);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_enabled(VARIANT_BOOL *pbEnabled)
{
    if (pbEnabled == NULL)
        return E_POINTER;
    *pbEnabled = VARIANT_FALSE;

    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, state undefined
        *pbEnabled = VARIANT_FALSE;
        return S_FALSE;
    }

    CComVariant vtEnabled;
    hr = pwmpPlayer.GetPropertyByName(L"enabled", &vtEnabled);
    if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
    {
        *pbEnabled = V_BOOL(&vtEnabled);
    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::put_enabled(VARIANT_BOOL bEnabled)
{
    CComDispatchDriver pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (FAILED(hr) || !pwmpPlayer)
    {
        // player not created yet, fire exception to let scrip know it has no control
        return E_UNEXPECTED;
    }

    CComVariant vtEnabled = bEnabled;
    return pwmpPlayer.PutPropertyByName(L"enabled", &vtEnabled);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::get_disabledUI(VARIANT_BOOL *pbDisabled)
{
    if (pbDisabled == NULL)
        return E_POINTER;
    *pbDisabled = _fDisabledUI ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::put_disabledUI(VARIANT_BOOL bDisable)
{
    _fDisabledUI = bDisable;
    // tell mediaband
    if (_pHost)
    {
        _pHost->OnDisableUIChanged(_fDisabledUI);
    }
    return S_OK;
}


// 
// *** IMediaBehaviorContentProxy ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::OnCreatedPlayer(void)
{
    return _ConnectToWmpEvents(TRUE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::fireEvent(enum contentProxyEvent event)
{
    ASSERT(_pBehaviorSiteOM != NULL);   // called too early, must have received Init() call from Trident first!
    if (!_pBehaviorSiteOM)
        return E_UNEXPECTED;

    if ((event < 0) || (event >= ARRAYSIZE(s_behaviorEvents)))
        return E_INVALIDARG;

    struct _eventInfo *pEvtInfo = &s_behaviorEvents[event];

    HRESULT hr = S_OK;
    // don't have cookie yet, need to register event first!
    if (pEvtInfo->levtCookie == NO_COOKIE)
    {
        // register event with behavior site
        hr = _pBehaviorSiteOM->RegisterEvent(pEvtInfo->pwszName, 0, &pEvtInfo->levtCookie);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
            return hr;
    }
    if (pEvtInfo->levtCookie == NO_COOKIE)
        return E_UNEXPECTED;

    CComPtr<IHTMLEventObj>  pEvt;
    hr = _pBehaviorSiteOM->CreateEventObject(&pEvt);
    if (FAILED(hr))
        return hr;

    // fire into script:
     return _pBehaviorSiteOM->FireEvent(pEvtInfo->levtCookie, pEvt);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::detachPlayer(void)
{
    return _ConnectToWmpEvents(FALSE);
}

// *** IMediaBehaviorContentProxy ***
//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::OnUserOverrideDisableUI()
{
    return put_disabledUI(VARIANT_FALSE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::IsDisableUIRequested(BOOL *pfRequested)
{
    if (!pfRequested)
    {
        return E_POINTER;
    }
    *pfRequested = _fDisabledUI;
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBehavior::IsNextEnabled(BOOL *pfEnabled)
{
    if (!pfEnabled)
    {
        return E_POINTER;
    }
    *pfEnabled = FALSE;

    CComDispatchDriverEx    pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (SUCCEEDED(hr) && pwmpPlayer)
    {
        CComVariant vtControls;
        hr = pwmpPlayer.GetPropertyByName(L"controls", &vtControls);
        if (SUCCEEDED(hr))
        {
            CComDispatchDriverEx pwmpControls;
            pwmpControls = vtControls;
            
            CComVariant vtNext = "Next";
            CComVariant vtEnabled;
            hr = pwmpControls.GetPropertyByName1(L"isAvailable", &vtNext, &vtEnabled);
            if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
            {
                *pfEnabled = (V_BOOL(&vtEnabled) == VARIANT_TRUE);
            }
        }
    }
    return S_OK;
}

//------------------------------------------------------------------------
HRESULT CMediaBehavior::getWMP(IDispatch **ppPlayer)
{
    if (ppPlayer == NULL)
        return E_POINTER;
    *ppPlayer = NULL;
    if (!CMediaBarUtil::IsWMP7OrGreaterCapable() || !_pHost)
    {
        return E_UNEXPECTED;
    }
    if (!_fPlaying)
    {
        return E_ACCESSDENIED;
    }

    HRESULT hr = E_UNEXPECTED;
    CComPtr<IUnknown>    pMediaPlayer;
    hr = _pHost->getMediaPlayer(&pMediaPlayer);
    // getMediaPlayer can return NULL and S_FALSE if player isn't loaded yet!
    if (SUCCEEDED(hr) && pMediaPlayer)
    {
        CComQIPtr<ITIMEMediaElement, &IID_ITIMEMediaElement> pMediaElem = pMediaPlayer;
        if (pMediaElem)
        {
            return pMediaElem->get_playerObject(ppPlayer);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT CMediaBehavior::getPlayListIndex(LONG *plIndex, LONG *plCount)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    CComPtr<IUnknown>    pMediaPlayer;
    HRESULT hr = _pHost->getMediaPlayer(&pMediaPlayer);
    // getMediaPlayer can return NULL and S_FALSE if player isn't loaded yet!
    if (SUCCEEDED(hr) && pMediaPlayer)
    {
        CComQIPtr<ITIMEMediaElement, &IID_ITIMEMediaElement> pMediaElem = pMediaPlayer;
        if (pMediaElem)
        {
            CComPtr<ITIMEPlayList> pPlayList;
            if (SUCCEEDED(pMediaElem->get_playList(&pPlayList)) && pPlayList)
            {
                // current track index
                if (plIndex)
                {
                    CComPtr<ITIMEPlayItem> pPlayItem;
                    if (SUCCEEDED(pPlayList->get_activeTrack(&pPlayItem)) && pPlayItem)
                    {
                        hr = pPlayItem->get_index(plIndex);
                    }
                }
                // number of tracks in playlist
                if (plCount)
                {
                    hr = pPlayList->get_length(plCount);
                }
            }
        }
    }

    return hr;
}


//------------------------------------------------------------------------
HRESULT CMediaBehavior::_ConnectToWmpEvents(BOOL fConnect)
{
    if (   (fConnect && (_dwcpCookie != 0))
        || (!fConnect && (_dwcpCookie == 0))
        || !_pHost)
    {
        return S_FALSE; // no change in connection or no host
    }

    CComPtr<IDispatch>    pwmpPlayer;
    HRESULT hr = getWMP(&pwmpPlayer);
    if (SUCCEEDED(hr) && pwmpPlayer)
    {
        return ConnectToConnectionPoint(SAFECAST(this, IDispatch*), 
                DIID__WMPOCXEvents, fConnect, pwmpPlayer, &_dwcpCookie, NULL);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CWMPWrapper
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CWMPWrapper::CWMPWrapper(CMediaBehavior* pHost)
  : _cRef(0),
    _fStale(FALSE)
{
    ASSERT(pHost);
    _pHost = pHost;
    if (_pHost)
        _pHost->AddRef();
}

//------------------------------------------------------------------------
CWMPWrapper::~CWMPWrapper()
{
    if (_pHost)
        _pHost->Release();
}

//------------------------------------------------------------------------
HRESULT CWMPWrapper::_getVariantProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, VARIANT *pvtValue, BOOL fCallMethod)
{
    if (pvtValue == NULL)
        return E_POINTER;

    HRESULT hr = S_FALSE;
    VariantInit(pvtValue);
    if (!_fStale && _pwmpWrapper)
    {
        if (fCallMethod)
        {
            if (pvtParam != NULL)
            {
                hr = _pwmpWrapper.Invoke1(pwszPropName, pvtParam, pvtValue);
            }
            else
            {
                hr = _pwmpWrapper.Invoke0(pwszPropName, pvtValue);
            }
        }
        else
        {
            if (pvtParam != NULL)
            {
                hr = _pwmpWrapper.GetPropertyByName1(pwszPropName, pvtParam, pvtValue);
            }
            else
            {
                hr = _pwmpWrapper.GetPropertyByName(pwszPropName, pvtValue);
            }
        }
    }

    return hr;
}

//------------------------------------------------------------------------
HRESULT CWMPWrapper::_getStringProp(LPCOLESTR pwszPropName, VARIANT *pvtParam, OUT BSTR *pbstrValue, BOOL fCallMethod)
{
    if (pbstrValue == NULL)
        return E_POINTER;
    *pbstrValue = NULL;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(pwszPropName, pvtParam, &vtValue, fCallMethod);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_BSTR))
    {
        *pbstrValue = SysAllocString(V_BSTR(&vtValue));
    }

    // always return string, even if empty one (e.g. when media object is stale)
    if (SUCCEEDED(hr) && (*pbstrValue == NULL))
    {
        *pbstrValue = SysAllocString(L"");
        hr = S_OK;
    }

    return hr;
}


//------------------------------------------------------------------------
HRESULT CWMPWrapper::AttachToWMP()
{
    HRESULT hr = E_UNEXPECTED;
    if (_pHost)
    {
        CComDispatchDriver pwmpPlayer;
        hr = _pHost->getWMP(&pwmpPlayer);
        if (SUCCEEDED(hr) && pwmpPlayer)
        {
            // walk to WMP media object as signaled by requested type
            CComVariant vtMedia;
            hr = FetchWmpObject(pwmpPlayer, &vtMedia);
            if (SUCCEEDED(hr))
            {
                _pwmpWrapper = vtMedia;
            }
        }
    }
    return hr;
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaItem
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaItem::CMediaItem(CMediaBehavior* pHost)
  : CWMPWrapper(pHost),
    CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IMediaItem)
{
}

//------------------------------------------------------------------------
CMediaItem::~CMediaItem()
{
}


//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMediaItem))
    {
        *ppvObj = (IMediaItem*) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



// *** IMediaItem
//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_sourceURL(BSTR *pbstrSourceURL)
{
    return _getStringProp(L"sourceURL", NULL, pbstrSourceURL);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_name(BSTR *pbstrName)
{
    return _getStringProp(L"name", NULL, pbstrName);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_duration(double * pDuration)
{
    if (pDuration == NULL)
        return E_POINTER;
    *pDuration = 0.0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"duration", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_R8))
    {
        *pDuration = V_R8(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::get_attributeCount(long *plCount)
{
    if (plCount == NULL)
        return E_POINTER;
    *plCount = 0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"attributeCount", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_I4))
    {
        *plCount = V_I4(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::getAttributeName(long lIndex, BSTR *pbstrItemName)
{
    CComVariant vtIndex = lIndex;
    return _getStringProp(L"getAttributeName", &vtIndex, pbstrItemName, TRUE);
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaItem::getItemInfo(BSTR bstrItemName, BSTR *pbstrVal)
{
    CComVariant vtItemName = bstrItemName;
    return _getStringProp(L"getItemInfo", &vtItemName, pbstrVal, TRUE);
}


//------------------------------------------------------------------------
HRESULT CMediaItem::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    return pwmpPlayer.GetPropertyByName(L"currentMedia", pvtWrapperObj);
}


//////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CMediaItemNext
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CMediaItemNext::CMediaItemNext(CMediaBehavior* pHost)
  : CMediaItem(pHost)
{
}

//------------------------------------------------------------------------
CMediaItemNext::~CMediaItemNext()
{
}

//------------------------------------------------------------------------
HRESULT CMediaItemNext::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    if (!_pHost)
    {
        return E_UNEXPECTED;
    }
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    
    HRESULT hr = E_UNEXPECTED;
    CComVariant vtCurrPlayList;
    hr = pwmpPlayer.GetPropertyByName(L"currentPlaylist", &vtCurrPlayList);
    if (SUCCEEDED(hr))
    {
        CComDispatchDriverEx pwmpCurrPlayList;
        pwmpCurrPlayList = vtCurrPlayList;
            
        // what's the index of the current item in play?
        CComPtr<IMediaBarPlayer>    pMediaPlayer;
        LONG cnt = 0;
        LONG currIndex = 0;
        hr = _pHost->getPlayListIndex(&currIndex, &cnt);
        if (SUCCEEDED(hr))
        {
            if (currIndex + 1 < cnt)
            {
                CComVariant vtNext = currIndex + 1;
                return pwmpCurrPlayList.GetPropertyByName1(L"item", &vtNext, pvtWrapperObj);
            }
            else
            {
                return E_UNEXPECTED;
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// class CPlaylistInfo
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//------------------------------------------------------------------------
CPlaylistInfo::CPlaylistInfo(CMediaBehavior* pHost)
  : CWMPWrapper(pHost),
    CImpIDispatch(LIBID_BrowseUI, 1, 0, IID_IPlaylistInfo)
{
}

//------------------------------------------------------------------------
CPlaylistInfo::~CPlaylistInfo()
{
}


//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    if (ppvObj == NULL)
        return E_POINTER;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IPlaylistInfo))
    {
        *ppvObj = (IPlaylistInfo*) this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


// *** IPlaylistInfo
//------------------------------------------------------------------------
//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::get_name(BSTR *pbstrName)
{
    return _getStringProp(L"name", NULL, pbstrName);
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::get_attributeCount(long *plCount)
{
    if (plCount == NULL)
        return E_POINTER;
    *plCount = 0;

    CComVariant vtValue;
    HRESULT hr = _getVariantProp(L"attributeCount", NULL, &vtValue);
    if (SUCCEEDED(hr) && (V_VT(&vtValue) == VT_I4))
    {
        *plCount = V_I4(&vtValue);
    }

    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::getAttributeName(long lIndex, BSTR *pbstrItemName)
{
    CComVariant vtIndex = lIndex;
    return _getStringProp(L"attributeName", &vtIndex, pbstrItemName);
}

//------------------------------------------------------------------------
STDMETHODIMP CPlaylistInfo::getItemInfo(BSTR bstrItemName, BSTR *pbstrVal)
{
    CComVariant vtItemName = bstrItemName;
    return _getStringProp(L"getItemInfo", &vtItemName, pbstrVal, TRUE);
}

//------------------------------------------------------------------------
HRESULT CPlaylistInfo::FetchWmpObject(IDispatch *pdispWmpPlayer, OUT VARIANT *pvtWrapperObj)
{
    CComDispatchDriver pwmpPlayer;
    pwmpPlayer = pdispWmpPlayer;
    return pwmpPlayer.GetPropertyByName(L"currentPlaylist", pvtWrapperObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbutil.cpp ===
#include "priv.h"
#include "mbutil.h"
#include "legacy.h"
#include "mediahlpr.h"
#include "mediautil.h"
#include "mediaband.h"
#include "resource.h"
#include <mluisupp.h>
#include "apithk.h"

CMediaMRU::CMediaMRU()
{
    _hkey = NULL;
}

CMediaMRU::~CMediaMRU()
{
    if (_hkey)
        RegCloseKey(_hkey);
}

VOID CMediaMRU::Load(PTSTR pszKey)
{
    HKEY hkey = NULL;
    if (ERROR_SUCCESS==RegCreateKeyEx(HKEY_CURRENT_USER, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                      NULL, &hkey, NULL))
    {
        _hkey = hkey;
    }
}

VOID CMediaMRU::Add(PTSTR pszData)
{
    if (!_hkey)
        return;

    ASSERT((pszData && *pszData));
        
    TCHAR szData[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];
    for (INT i = MEDIA_MRU_LIMIT-2; i>=0; i--)
    {
        if (!Get(i, szData))
        {
            continue;
        }

        TCHAR szValue[] = TEXT("0");        
        if (!PathUnExpandEnvStringsForUser(NULL, szData, szTemp, ARRAYSIZE(szTemp)))
        {
            StrCpyN(szTemp, szData, ARRAYSIZE(szTemp));
        }
        *szValue = TEXT('0')+(TCHAR)i+1;
        SHSetValue(_hkey, NULL, szValue, REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
    }
    if (!PathUnExpandEnvStringsForUser(NULL, pszData, szTemp, ARRAYSIZE(szTemp)))
    {
        StrCpyN(szTemp, pszData, ARRAYSIZE(szTemp));
    }
    SHSetValue(_hkey, NULL, TEXT("0"), REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
}

VOID CMediaMRU::Delete(INT iWhich)
{
    if (!_hkey)
        return;

    TCHAR szData[INTERNET_MAX_URL_LENGTH];
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];
    for (INT i = iWhich; i<MEDIA_MRU_LIMIT; i++)
    {
        if (!Get(i+1, szData))
        {
            continue;
        }

        TCHAR szValue[] = TEXT("0");        
        if (!PathUnExpandEnvStringsForUser(NULL, szData, szTemp, ARRAYSIZE(szTemp)))
        {
            StrCpyN(szTemp, szData, ARRAYSIZE(szTemp));
        }
        *szValue = TEXT('0')+(TCHAR)i;
        SHSetValue(_hkey, NULL, szValue, REG_EXPAND_SZ, szTemp, (lstrlen(szTemp)+1)*sizeof(TCHAR));
    }
}

BOOL CMediaMRU::Get(INT iWhich, PTSTR pszOut)
{
    BOOL fRet = FALSE;

    TCHAR szValue[] = TEXT("0");        
    DWORD dwType, cb = INTERNET_MAX_URL_LENGTH;

    *szValue = TEXT('0')+(TCHAR)iWhich;
    if (ERROR_SUCCESS==SHGetValue(_hkey, NULL, szValue, &dwType, pszOut, &cb))
    {
        fRet = TRUE;
    }
    return fRet;
}

CMediaWidget::CMediaWidget(HWND hwnd, int cx, int cy)
{
    _hwnd = NULL;
    _hwndParent = hwnd;
    _cx = cx;
    _cy = cy;
}

CMediaWidget::~CMediaWidget()
{
    DESTROY_OBJ_WITH_HANDLE(_hwnd, DestroyWindow);
}

CMediaWidgetButton* 
CMediaWidgetButton_CreateInstance(HWND hwnd, int cx, int cy, int idCommand, int idImageList, int idAlt, int idTooltip, int idTooltipAlt)
{
    CMediaWidgetButton* pmwb = new CMediaWidgetButton(hwnd, cx, cy);
    if (pmwb)
    {
        HRESULT hr = pmwb->Initialize(idCommand, idTooltip, idTooltipAlt);
        if (SUCCEEDED(hr) && idImageList)
        {
            hr = pmwb->SetImageList(idImageList);
        }
        if (SUCCEEDED(hr) && idAlt)
        {
            hr = pmwb->SetAlternateImageList(idAlt);
        }
        if (FAILED(hr))
        {
            delete pmwb;
            pmwb = NULL;
        }
    }
    return pmwb;
}

CMediaWidgetButton::CMediaWidgetButton(HWND hwnd, int cx, int cy) : CMediaWidget(hwnd, cx, cy)
{
    _himl = _himlAlt = NULL;
    _dwMode = MWB_NORMAL;
    _fImageSource = TRUE;
    _iCommand = _iTooltip = _iTooltipAlt = 0;
}

CMediaWidgetButton::~CMediaWidgetButton()
{
    DESTROY_OBJ_WITH_HANDLE(_himl, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlAlt, ImageList_Destroy);
}

HRESULT CMediaWidgetButton::Initialize(int idCommand, int idTooltip, int idTooltipAlt)
{
    HRESULT hr = E_FAIL;
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                           WS_TABSTOP |WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |  
                           TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_TRANSPARENT |
                           CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                           0, 0, 0, 0, _hwndParent, NULL, HINST_THISDLL, NULL);
    if (_hwnd)
    {
        _iCommand = idCommand;
        TBBUTTON tb;
        tb.iBitmap = 0;
        tb.idCommand = idCommand;
        tb.fsState = TBSTATE_ENABLED;
        tb.fsStyle = BTNS_AUTOSIZE | BTNS_BUTTON;
        tb.dwData = 0; //(DWORD_PTR)this;
        tb.iString = 0;

        SendMessage(_hwnd, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwnd, TB_SETMAXTEXTROWS, 0, 0L);
        if (idTooltip)
        {
            if (idTooltipAlt)
            {
                _iTooltip = idTooltip;
                _iTooltipAlt = idTooltipAlt;
            }
            else
            {
                tb.iString = (int)SendMessage(_hwnd, TB_ADDSTRING, (WPARAM)MLGetHinst(), MAKELPARAM(idTooltip, 0));
            }
        }
        SendMessage(_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb);
        SendMessage(_hwnd, TB_SETPADDING, 0, MAKELPARAM(0, 1));
        ShowWindow(_hwnd, SW_SHOW);
        Comctl32_SetDPIScale(_hwnd);
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CMediaWidgetButton::SetImageList(INT iResource)
{
    HRESULT hr = E_FAIL;

    ASSERT(_cx && _cy);
    DESTROY_OBJ_WITH_HANDLE(_himl, ImageList_Destroy);
    _himl = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iResource), _cx, 0, crMask,
                                                 IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (_himl && _hwnd)
    {
        SendMessage(_hwnd, TB_SETIMAGELIST, 0, (LPARAM)_himl);
        SendMessage(_hwnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)_himl);
        SendMessage(_hwnd, TB_SETHOTIMAGELIST, 0, (LPARAM)_himl);

        hr = S_OK;
    }

    return hr;
}

HRESULT CMediaWidgetButton::SetAlternateImageList(INT iResource)
{
    HRESULT hr = E_FAIL;
    ASSERT(_himl);
    ASSERT(_cx && _cy);
    DESTROY_OBJ_WITH_HANDLE(_himlAlt, ImageList_Destroy);
    _himlAlt = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(iResource), _cx, 0, crMask,
                                                 IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (_himlAlt)
    {
        hr = S_OK;
    }
    ASSERT(_iTooltipAlt);
    SetImageSource(TRUE);

    return hr;
}

HRESULT CMediaWidgetButton::SetImageSource(BOOL fImageSource)
{
    ASSERT(_himlAlt);
    if (_himlAlt)
    {
        _fImageSource = fImageSource;
        if (_hwnd)
        {
            InvalidateRect(_hwnd, NULL, FALSE);
            UpdateWindow(_hwnd);

            INT i = fImageSource ? _iTooltip : _iTooltipAlt;
            if (i)
            {
                // ISSUE Why are we doing this? Because on Win9x, the tooltips code isn't working 
                //       no matter how hard I pound.
                TCHAR szText[MAX_PATH];
                if (MLLoadStringW(i, szText, ARRAYSIZE(szText)))
                {
                    TBBUTTONINFO tb = {0};
                    tb.cbSize = sizeof(tb);
                    tb.dwMask = TBIF_TEXT;
                    tb.pszText = szText;
                    SendMessage(_hwnd, TB_SETBUTTONINFO, _iCommand, (LPARAM)&tb);
                }
            }
        }
    }
    return S_OK;
}

HRESULT CMediaWidgetButton::SetMode(DWORD dwMode)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
    SendMessage(_hwnd, TB_GETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
    tbbi.iImage = (INT)dwMode;            
    SendMessage(_hwnd, TB_SETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
    _dwMode = dwMode;
    return S_OK;
}

LRESULT CMediaWidgetButton::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LPNMTBCUSTOMDRAW pnmc = (LPNMTBCUSTOMDRAW)pnm;
    LRESULT lres;

    switch (pnmc->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_PREERASE:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
        {
            HIMAGELIST himl = _fImageSource ? _himl : _himlAlt;
            INT index = MWB_NORMAL;

            if (SendMessage(_hwnd, TB_GETSTATE, (WPARAM)pnmc->nmcd.dwItemSpec, 0) & TBSTATE_ENABLED)
            {
                index = (pnmc->nmcd.uItemState & CDIS_SELECTED) 
                            ? MWB_PRESSED 
                            : (pnmc->nmcd.uItemState & CDIS_HOT) ? MWB_HOT : _dwMode;
            }
            else
            {
                index = MWB_DISABLED;
            }

            if (himl)
            {
                UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
                INT x = pnmc->nmcd.rc.left;
                if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                {
                    x++;
                }
                ImageList_Draw(himl, index, pnmc->nmcd.hdc, x, 1, uFlags);
                lres = CDRF_SKIPDEFAULT;
                break;
            }
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}

BOOL CMediaWidgetButton::IsEnabled()
{
    return ((BOOL)SendMessage(_hwnd, TB_GETSTATE, _iCommand, 0) & TBSTATE_ENABLED);
}

HRESULT CMediaWidgetButton::TranslateAccelerator(LPMSG pMsg)
{
    return (_hwnd && SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)pMsg)) ? S_OK : S_FALSE;
}

CMediaWidgetToggle::CMediaWidgetToggle(HWND hwnd, int cx, int cy) : CMediaWidgetButton(hwnd, cx, cy)
{
    _fState = FALSE;
}

LRESULT CMediaWidgetToggle::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LPNMTBCUSTOMDRAW pnmc = (LPNMTBCUSTOMDRAW)pnm;
    LRESULT lres;

    switch (pnmc->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_PREERASE:
            lres = CDRF_NOTIFYITEMDRAW;
            break;

        case CDDS_ITEMPREPAINT:
        {
            INT index = MWB_NORMAL;
            if (_fState)
            {
                index = MWB_PRESSED;
            }
            else if (pnmc->nmcd.uItemState & CDIS_HOT)
            {
                index = MWB_HOT;
            }

            if (_himl)
            {
                UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
                INT x = pnmc->nmcd.rc.left;
                if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                {
                    x++;
                }
                ImageList_Draw(_himl, index, pnmc->nmcd.hdc, x, 1, uFlags);
                lres = CDRF_SKIPDEFAULT;
                break;
            }
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}


VOID CMediaWidgetToggle::SetState(BOOL fState)
{
    _fState = fState;
    InvalidateRect(_hwnd, NULL, FALSE);
    UpdateWindow(_hwnd);

    INT i = fState ? _iTooltip : _iTooltipAlt;
    if (i)
    {
        TCHAR szText[MAX_PATH];
        if (MLLoadStringW(i, szText, ARRAYSIZE(szText)))
        {
            TBBUTTONINFO tb = {0};
            tb.cbSize = sizeof(tb);
            tb.dwMask = TBIF_TEXT;
            tb.pszText = szText;
            SendMessage(_hwnd, TB_SETBUTTONINFO, _iCommand, (LPARAM)&tb);
        }
    }
}

CMediaWidgetOptions::CMediaWidgetOptions(HWND hwnd, int cx, int cy)  : CMediaWidgetButton(hwnd, cx, cy)
{
    _fDepth = TRUE;
}

HRESULT CMediaWidgetOptions::Initialize(int idCommand, int idTooltip, int idTooltipAlt)
{
    HRESULT hr = E_FAIL;

    _hwnd  = CreateWindowEx(WS_EX_TOOLWINDOW | TBSTYLE_EX_MIXEDBUTTONS | WS_EX_WINDOWEDGE, TOOLBARCLASSNAME, NULL,
                                   WS_TABSTOP| WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                   TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_CUSTOMERASE | TBSTYLE_LIST | TBSTYLE_TRANSPARENT |
                                   CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE,
                                   0, 0, 0, 0, _hwndParent, NULL, HINST_THISDLL, NULL);
    if (_hwnd)
    {
        static const TBBUTTON tbInfoBar[] =
        {
            { I_IMAGECALLBACK, FCIDM_MEDIABAND_PLAYINFO, TBSTATE_ENABLED, BTNS_SHOWTEXT | BTNS_WHOLEDROPDOWN, {0,0}, 0, 0 },
        };

        // Init the toolbar control
        SendMessage(_hwnd, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwnd, TB_SETMAXTEXTROWS, 1, 0L);
        
        RECT rcClient;
        GetClientRect(_hwndParent, &rcClient);
        SendMessage(_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(10,10));
        SendMessage(_hwnd, TB_ADDBUTTONS, ARRAYSIZE(tbInfoBar), (LPARAM)tbInfoBar);
        SendMessage(_hwnd, TB_SETBITMAPSIZE, 0, MAKELONG(0, 0));

        // Need to disable theming on this item
        SetWindowTheme(_hwnd, TEXT(""), TEXT(""));

        ShowWindow(_hwnd, SW_SHOW);
        hr = S_OK;
    }
    
    return hr;
}


LRESULT CMediaWidgetOptions::Draw(LPNMTBCUSTOMDRAW pnm)
{
    LRESULT lres = CDRF_NOTIFYITEMDRAW;

    switch (pnm->nmcd.dwDrawStage) 
    {
        case CDDS_PREPAINT:
        case CDDS_PREERASE:
            break;

        case CDDS_ITEMPREPAINT:
        {
            pnm->clrText = _fDepth ? RGB(255,255,255) : RGB(0,0,0);
            if (_fDepth)
            {
                lres |= TBCDRF_HILITEHOTTRACK;
                pnm->clrHighlightHotTrack = COLOR_BKGND2;
            }          
            break;
        }

        default:
            lres = CDRF_DODEFAULT;
            break;
    }
    return lres;
}


HRESULT CMediaWidgetSeek::Initialize(HWND hwnd)
{
    _hwnd = hwnd;
    return S_OK;
}

HRESULT CMediaWidgetSeek::TranslateAccelerator(LPMSG pMsg)
{
    return S_FALSE;
}

VOID CMediaWidgetSeek::SetState(BOOL fState)
{
    _fState = fState;

    InvalidateRect(_hwnd, NULL, FALSE);
    UpdateWindow(_hwnd);
}


HRESULT CMediaWidgetVolume::Initialize(HWND hwnd)
{
    _hwnd = hwnd;
    return S_OK;
}

HRESULT CMediaWidgetVolume::TranslateAccelerator(LPMSG pMsg)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mediaband.h ===
// mediabar.h : Declaration of the CMediaBand

#ifndef __MEDIABAND_H_
#define __MEDIABAND_H_

#include "dpa.h"
#include "bands.h"
#include "player.h"
#include "mediautil.h"
#include "mbutil.h"
#include "mbBehave.h"
#include "iface.h"

#define ERROREXIT(hr) if(FAILED(hr)){hr = E_FAIL; goto done;}

enum
{
    MW_PLAY = 0,
    MW_STOP,
    MW_BACK,
    MW_NEXT,
    MW_MUTE,
    MW_VOLUME,
    MW_OPTIONS,
    MW_POP,
    MW_SEEK,
    MW_NUMBER 
};


#define WM_MB_DEFERRED_NAVIGATE   (WM_USER + 700)     // lParam: hwnd of window sending this message (used for reflection)


class CMediaBand : public CToolBand, 
                   public IMediaBar,
                   public IWinEventHandler,
                   public INamespaceWalkCB,
                   public IElementBehaviorFactory,
                   public IBrowserBand,
                   public IBandNavigate,
                   public IMediaHost,
                   public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>,
                   public CMediaBarUtil
{
public:
    CMediaBand();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef();  };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };
    
    // IOleCommandTarget
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD       nCmdID,
                              DWORD       nCmdexecopt,
                              VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // IOleWindow
    //  (overriding CNSCBand implementation
    STDMETHODIMP GetWindow(HWND *phwnd);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, VOID ** ppvObj);

    // IInputObject
    //  (overriding CNSCBand/CToolBand's implementation)
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    STDMETHODIMP HasFocusIO();

    // IDockingWindow
    STDMETHODIMP ShowDW(BOOL fShow);
    STDMETHODIMP CloseDW(DWORD dwReserved);
    
    // IElementBehaviorFactory
    STDMETHODIMP FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior);
    
    // IBrowserBand
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, LPVOID *ppv);
    STDMETHODIMP SetBrowserBandInfo(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) { ASSERT(FALSE); return E_NOTIMPL; }
    STDMETHODIMP GetBrowserBandInfo(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) { ASSERT(FALSE); return E_NOTIMPL; }

    // IBandNavigate
    STDMETHOD(Select)(LPCITEMIDLIST pidl);

    // IMediaHost
    STDMETHOD(getMediaPlayer)(IUnknown **ppPlayer);
    STDMETHOD(playURL)(BSTR bstrURL, BSTR bstrMIME);
    STDMETHOD(addProxy)(IUnknown *pProxy);
    STDMETHOD(removeProxy)(IUnknown *pProxy);
    // IMediaHost2
    STDMETHOD(OnDisableUIChanged)(BOOL fDisabled);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // IWinEventHandler
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd);

    // IMediaBar
    STDMETHOD(Notify)(long lReason);
    STDMETHOD(OnMediaError)(int iErrCode);
  
    // IDeskBand
    STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // IPersistStream
    STDMETHODIMP GetClassID(CLSID *pClassID);
    STDMETHODIMP Load(IStream *pStm);
    STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // IDispatch
    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl) { return S_OK; }
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl) { return S_OK; }
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

private:
    ~CMediaBand();

    LRESULT _OnVolumeCustomDraw(LPNMCUSTOMDRAW pnm);
    LRESULT _OnSeekBarCustomDraw(LPNMCUSTOMDRAW pnm);
    
    BOOL  EnsurePlayer();
    BOOL  CreatePlayer();
    VOID  DestroyPlayer();

    STDMETHOD(_TogglePause)();
    STDMETHOD(_PutUrl)(LPWSTR pstrUrl, LPWSTR pstrMime);

    STDMETHOD(_EnumPlayItems)(VOID);

    HRESULT  CreateControls();
    HRESULT  CreateSeekBar();
    HRESULT  CreateVolumeControl();
    HRESULT  CreateParentPane();
    HRESULT  CreateLayoutPane();

    HRESULT  _NavigateMainWindow(LPCTSTR lpstrUrl, bool fSuppressFirstAutoPlay = false);

    HRESULT   InitPlayerPopup();
    HWND      GetBrowserWindow();

    VOID     _ResizeChildWindows(HWND hwnd, LONG width, LONG height, BOOL fRepaint);
    HRESULT  _InitializeMediaUI();
    VOID     _ResizeVideo(LONG* lWidth, LONG* lHeight);

    VOID      AdjustLayout(LONG_PTR lWidth=0,LONG_PTR lHeight=0);
    VOID      DrawBackground(HDC hdc, HWND hwnd);

    LPTSTR GetUrlForStatusBarToolTip();
    
    HRESULT  _OpenInDefaultPlayer(BSTR bstrUrl);
    VOID     _ShowAllWindows(BOOL fShow);
    HRESULT  ShowPlayListMenu(HWND hwnd,RECTL* rc);
    HRESULT  ShowGenericMenu(HWND hwnd, RECTL* rc);
    HRESULT  HandleMenuTasks(INT iTask);
    VOID     ComputeMinMax(MINMAXINFO *pMinMax);
    
    VOID     DockMediaPlayer();

    static INT_PTR  CALLBACK  s_PopupDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_LayoutWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_SeekWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT  CALLBACK  s_VolumeWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static INT_PTR  CALLBACK  s_PromptMimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT GetTrackTitle (BSTR* pbstrTitle);
    VOID GetToolbarSize(HWND hwndTB, SIZE* pSize);

    float GetSeekPos() ;
    VOID  SetSeekPos(float fPosition) ;
    HRESULT Seek(double dblProgress);

    VOID  SetStatusText(LPWSTR lpwStatusInfo);
    VOID  ShowPlayingStatus(BOOL fInitial=FALSE);

    VOID AdjustVideoHeight(BOOL fForceResize=FALSE);
    VOID TogglePlayPause();
    VOID ToggleMute();

    LONG GetLayoutHeight(LONG lWidth=0);
    LONG GetVideoHeight(LONG lWidth=0, BOOL fNewVideo=FALSE);
    LONG GetControlsHeight();

    // Menu helpers
    HRESULT AddToFavorites(BSTR bstrUrl, BSTR bstrTitle);
    HRESULT ResetMimePreferences();
    BOOL    PromptSettings(UINT IDPROMPT);
    
    // Handler for property change notifications
    VOID _OnTitleChange();

    // Navigation timeout helpers
    VOID _OnNavigationTimeOut();
    VOID _UpdateTimeOutCounter(double dblCurrBufProgress, double dblCurrPlayProgress);
    VOID _EndTimeOutCounter();
    VOID _BeginTimeOutCounter(BOOL fClear = TRUE);

    // per mime type checking stuff
    VOID    _HandleAutoPlay(VARIANTARG *pvarargMime, VARIANTARG *pvarargUrl);

    STDMETHODIMP ProfferService(IUnknown         *punkSite, 
                                REFGUID           sidWhat, 
                                IServiceProvider *pService, 
                                DWORD            *pdwCookie);

public:
    // mediabar behavior
    // non-COM public calls

private:
    HRESULT     _AddProxyToList(IUnknown *punkProxy);
    void        _AttachPlayerToProxies(BOOL fAttach);
    void        _DetachProxies();
    BOOL        _isUIDisabled();
    BOOL		_isProxiesNextEnabled();
    void        _OnUserOverrideDisableUI();
    void        _FireEventToProxies(enum contentProxyEvent event);
    void        _CleanupStopTimer();
    BOOL        _IsProxyRunning(void) { return (_apContentProxies && (_apContentProxies.GetPtrCount() > 0)); }
    HRESULT     _EnsureWMPInstalled(BOOL fShowErrorMsg = TRUE);

    BOOL        _fAttached;
    UINT_PTR    _idStopTimer;


private:                                
    double     _dblMediaDur;  // natural length of the media
    int        _iCurTrack;
    PTSTR     _pszStatus;
    HWND     _hwndVolume;
    HWND     _hwndSeek;
    HWND     _hwndPopup;
    HWND     _hwndVideo ;
    HWND     _hwndLayout;
    
    HMENU    _hPlayListMenu;
        
    IMediaBarPlayer    *_pMediaPlayer;

    DWORD               _dwCookieServiceMediaBar;

    // navigation timeout
    DWORD   _dwStartTime;
    LONG    _lTickCount;
    double  _dblLastBufProgress;
    double  _dblLastPlayProgress;

    SIZE           _sizeLayout;
    SIZE           _sizeVideo ;
    BOOL          _fPlayButton:1 ;
    BOOL          _fSeeking:1;    // We are seeking, so don't update the seekbar position while we seek.
    BOOL          _fIsVideo:1;
    BOOL          _fMuted:1;
    BOOL          _fVideoAdjust:1;
    BOOL          _fPlaying:1;
    BOOL          _fPlayEnabled:1;
    BOOL          _fInitialized:1;
    BOOL          _fHiColour:1;
    BOOL          _fUserPaused:1;
    BOOL          _fHighDPI:1;
    float         _scaleX, _scaleY;
    CMediaWidget*   _pmw[MW_NUMBER];
    HIMAGELIST  _himlGripper;
    HBITMAP     _hbmpBackground;
    HIMAGELIST _himlVolumeBack, _himlVolumeFill;
    HIMAGELIST _himlSeekBack, _himlSeekFill;
    HBRUSH _hbrSeekBrush;
    
    VOID        Resize(HWND hwnd, LONG lWidth, LONG lHeight);
    LONG        GetPopoutHeight(BOOL fVideo=FALSE, LONG lWidth=0);
    LONG        GetMinPopoutWidth();
    BOOL        ResetPlayer();
    HRESULT     PlayLocalTrack(INT iTrackNum);
    HRESULT     PlayNextTrack();
    BOOL        SetPlayerControl(UINT ui, BOOL fState);
    BOOL        UpdateBackForwardControls();
    VOID        UpdateMenuItems(HMENU hmenu);
    LPTSTR      _szToolTipUrl;
    BOOL        OnNotify(LPNMHDR pnm, LRESULT* plres);
    VOID        SetPlayPause(BOOL fState);
    VOID        SwitchBitmaps(BOOL fNewSetting);

    HRESULT _GetMusicFromFolder();
    void _ClearFolderItems();


    LPITEMIDLIST *_ppidls;
    UINT _cidls;

    INT         _iElement;
    double      _dblVol;
    TCHAR      _szConnecting[MAX_PATH];
    INT         _iOptionsWidth;
    CComBSTR    _strLastUrl;
    CComBSTR    _strLastMime;
    BOOL        _fLastUrlIsAutoPlay;

    // Content pane
    HWND        _hwndContent;
    DWORD       _dwcpCookie;
    CComPtr<IWebBrowser2> _spBrowser;
    CComBSTR    _strDeferredURL;
    CComBSTR    _strCurrentContentUrl;
    CComPtr<IOleInPlaceActiveObject>  _poipao;
    BOOL        _fContentInFocus;

    VOID        InitContentPane();
    HRESULT     NavigateContentPane(BSTR bstrUrl);
    HRESULT     NavigateContentPane(LPCITEMIDLIST pidl);
    VOID        NavigateMoreMedia();
    HRESULT     _NavigateContentToDefaultURL(void);
    HRESULT     _ConnectToCP(BOOL fConnect);
    HRESULT     _BuildPageURLWithParam(LPCTSTR pszURL, LPCTSTR pszParam, OUT LPTSTR pszBuffer, UINT uiBufSize);
    BOOL        _DeferredNavigate(LPCTSTR pszURL);
    HRESULT     _ContentActivateIO(BOOL fActivate, PMSG pMsg);
    LRESULT     _OnNotify(LPNMHDR pnm);

    BOOL _fSavedPopoutState;
    WINDOWPLACEMENT _wpPopout;
    BOOL _fPopoutHasFocus;
    void ActivatePopout(BOOL fState);

    HKEY _hkeyWMP;
    BOOL _fShow;

    // mediaBehavior
    CDPA<IContentProxy>    _apContentProxies;
};



#define _pmwPlay    ((CMediaWidgetButton*)_pmw[MW_PLAY])
#define _pmwStop    ((CMediaWidgetButton*)_pmw[MW_STOP])
#define _pmwBack    ((CMediaWidgetButton*)_pmw[MW_BACK])
#define _pmwNext    ((CMediaWidgetButton*)_pmw[MW_NEXT])
#define _pmwMute    ((CMediaWidgetToggle*)_pmw[MW_MUTE])
#define _pmwVolume  ((CMediaWidgetVolume*)_pmw[MW_VOLUME])
#define _pmwOptions     ((CMediaWidgetOptions*)_pmw[MW_OPTIONS])
#define _pmwPop     ((CMediaWidgetButton*)_pmw[MW_POP])
#define _pmwSeek    ((CMediaWidgetSeek*)_pmw[MW_SEEK])

#define ISVALIDWIDGET(x)    (x && x->_hwnd)
#endif // __MEDIABAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mbutil.h ===
#ifndef _MEDIAMENU_H_
#define _MEDIAMENU_H_

#include "cowsite.h"

class CMediaBand;

#define MEDIA_MRU_LIMIT         10

class CMediaMRU
{
public:
    CMediaMRU();
    ~CMediaMRU();
    
    VOID Load(PTSTR pszKey);
    VOID Add(PTSTR pszData);
    BOOL Get(INT iWhich, PTSTR pszOut);
    VOID Delete(INT iWhich);

private:
    HKEY _hkey;
};

class CMediaWidget
{
public:
    CMediaWidget(HWND, int cx, int cy);
    ~CMediaWidget();
    virtual LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) = 0;
    virtual BOOL IsEnabled() = 0;
    virtual HRESULT TranslateAccelerator(LPMSG pMsg) = 0;
//private:
    HWND _hwnd, _hwndParent;
    INT _cx, _cy;
};

enum
{
    MWB_NORMAL = 0,
    MWB_DISABLED,
    MWB_HOT,
    MWB_PRESSED
};

class CMediaWidgetButton : public CMediaWidget
{
public:
    CMediaWidgetButton(HWND, int, int);
    ~CMediaWidgetButton();
    HRESULT SetImageList(INT iResource);
    HRESULT SetAlternateImageList(INT iResource);
    HRESULT SetImageSource(BOOL fImageSource);
    HRESULT SetMode(DWORD);
    virtual HRESULT Initialize(int idCommand, int idTooltip=0, int idTooltipAlt=0);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    BOOL IsEnabled();
    HRESULT TranslateAccelerator(LPMSG pMsg);

//private:
    HIMAGELIST _himl, _himlAlt;
    INT _iTooltip, _iTooltipAlt, _iCommand;
    BOOL _fImageSource;
    DWORD _dwMode;
};

CMediaWidgetButton * CMediaWidgetButton_CreateInstance(HWND hwnd, int cx, int cy, int idCommand, int idImageList, int idAlt=0, int idTooltip=0, int idTooltipAlt=0);

class CMediaWidgetToggle : public CMediaWidgetButton
{
public:
    CMediaWidgetToggle(HWND, int, int);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    VOID SetState(BOOL fState);
    BOOL IsEnabled() { return TRUE; };

    BOOL _fState;
};

class CMediaWidgetOptions : public CMediaWidgetButton
{
public:
    CMediaWidgetOptions(HWND, int, int);
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc);
    BOOL IsEnabled() { return TRUE; }
    HRESULT Initialize(int idCommand, int idTooltip=0, int idTooltipAlt=0);
    VOID SetDepth(BOOL fDepth) { _fDepth = fDepth; };

    BOOL _fDepth;
};

class CMediaWidgetVolume : public CMediaWidget
{
public:
    CMediaWidgetVolume() : CMediaWidget(NULL, 0, 0) {};
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) { return CDRF_DODEFAULT; };
    BOOL IsEnabled() { return TRUE; };
    HRESULT TranslateAccelerator(LPMSG pMsg);
    HRESULT Initialize(HWND hwnd);
};

class CMediaWidgetSeek : public CMediaWidget
{
public:
    CMediaWidgetSeek() : CMediaWidget(NULL, 0, 0) { _fState = FALSE; };
    LRESULT Draw(LPNMTBCUSTOMDRAW pnmc) { return CDRF_DODEFAULT; };
    BOOL IsEnabled() { return _fState; };
    HRESULT TranslateAccelerator(LPMSG pMsg);
    HRESULT Initialize(HWND hwnd);
    VOID SetState(BOOL fState);

    BOOL _fState;
 };

#define crMask  RGB(255, 0, 255)
#define COLOR_BKGND          RGB(71, 80, 158)
#define COLOR_BKGND2         RGB(92, 118, 186)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\menubar.h ===
#ifndef _menubar_h
#define _menubar_h


#ifdef __cplusplus

#include "iface.h"
#include "basebar.h"

IMenuPopup* CreateMenuPopup(IMenuPopup *pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* CreateMenuPopup2(IMenuPopup *pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);
HRESULT ShowBandInBandSite(IUnknown* punkBS, IUnknown* punkDB);


class CMenuDeskBar : 
        public CBaseBar
        ,public IMenuPopup
        ,public IObjectWithSite
        ,public IBanneredBar
        ,public IInitializeObject
{
public:    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CBaseBar::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CBaseBar::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return CBaseBar::GetWindow(lphwnd); };
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return CBaseBar::ContextSensitiveHelp(fEnterMode); };

    // *** IDeskBar methods ***
    STDMETHODIMP SetClient(IUnknown* punk) { return CBaseBar::SetClient(punk); };
    STDMETHODIMP GetClient(IUnknown** ppunkClient) { return CBaseBar::GetClient(ppunkClient); };
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return CBaseBar::OnPosRectChangeDB(prc); };

    // *** IInputObjectSite methods (override) ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown * pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IBanneredBar methods ***
    virtual STDMETHODIMP SetIconSize(DWORD iIcon);
    virtual STDMETHODIMP GetIconSize(DWORD* piIcon)
        { ASSERT(piIcon); *piIcon = _iIconSize; return NOERROR;};
    virtual STDMETHODIMP SetBitmap(HBITMAP hBitmap);
    virtual STDMETHODIMP GetBitmap(HBITMAP* phBitmap)
        { ASSERT(phBitmap); *phBitmap = _hbmp; return NOERROR;};

    // *** IInitializeObject methods ***
    // This is for Backwards compatility with Start Menu.
    STDMETHODIMP Initialize() { return NOERROR; }


    CMenuDeskBar();

    
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void _OnCreate();
    virtual void _OnSize();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();
 
    void    _AllowMessageThrough(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _GetPopupWindowPosition(RECT* rcDesired, RECT* rcExclude, RECT *prcResult, SIZE * psizeEdge, UINT uside); 
    void    _PopDown();
    BOOL    _IsMyParent(HWND hwnd);  
    IMenuPopup* _GetMenuBarParent(IUnknown* punk);
    UINT    _GetSide() { return _uSide;};
    HRESULT _PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags);
    LRESULT _DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags);
    void _DoNCPaint(HWND hwnd, HDC hdc);
    void _SelectItem(BOOL bFirst);
    void AdjustForTheme();

    virtual ~CMenuDeskBar();
            
    POINT   _pt;
    IMenuPopup* _pmpParent;
    IMenuPopup* _pmpChild;
    IUnknown* _punkSite;
    UINT    _uSide;


    HBITMAP _hbmp;
    DWORD   _iIconSize;
    SIZE    _sizeBmp;
    COLORREF    _rgb;

    BITBOOL _fActive: 1;

    RECT    _rcExclude;
    BITBOOL _fExcludeRect: 1;  // TRUE: _rcExclude contains valid 
    BITBOOL _fExpanded: 1;
    BITBOOL _fFlatMenuMode: 1;
    BOOL    _fNoBorder;

    friend HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

HRESULT TrackShellMenu(HWND hwnd, LPRECT prc, IShellMenu* psm, DWORD dwFlags);

#endif // __cplusplus
#endif // _menubar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\menuisf.cpp ===
#include "priv.h"
#include "sccls.h"
#include "iface.h"
#include "resource.h"
#include "caggunk.h"
#include "menuisf.h"
#include "menubar.h"
#include "menuband.h"
#include "iaccess.h"
#include "apithk.h"

//=================================================================
// Implementation of CMenuAgent
//
//  The single global object of this class (g_menuagent) is the
//  manager of the message filter proc used to track mouse and
//  keyboard messages on behalf of CTrackPopupBar while a menu is
//  in a modal menu loop in TrackPopupMenu.
//
//  We track these messages so we can pop out of the menu, behaving
//  as if the visual menu bar consisted of a homogeneous menu
//  object.
//
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);

struct CMenuAgent
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndSite;          // hwnd to receive forwarded messages
    HWND        _hwndParent;
    CTrackPopupBar * _ptpbar;
    IMenuPopup * _pmpParent;
    void*       _pvContext;
    HANDLE      _hEvent;

    BITBOOL     _fEscHit: 1;

    // we need to keep track of whether the last selected
    // menu item was on a popup or not.  we can do this by storing the 
    // last WM_MENUSELECT flags
    UINT        _uFlagsLastSelected; 
    HMENU       _hmenuLastSelected;
    POINT       _ptLastMove;

    void    Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, HWND hwndParent, HWND hwndSite);
    void    Reset(void* pvContext);
    void    CancelMenu(void* pvContext);

    static LRESULT CALLBACK MsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
    void _OnMenuSelect(HMENU hmenu, int i, UINT uFlags);
    BOOL _OnKey(WPARAM vkey);
};

// Just one of these, b/c we only need one message filter
CMenuAgent g_menuagent = { 0 };     


/*----------------------------------------------------------
Purpose: Initialize the message filter hook

*/
void CMenuAgent::Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, 
                      HWND hwndParent, HWND hwndSite)
{
    TraceMsg(TF_MENUBAND, "Initialize CMenuAgent");

    ASSERT(IS_VALID_READ_PTR(ptpbar, CTrackPopupBar));
    ASSERT(IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(IS_VALID_HANDLE(hwndSite, WND));

    if (_pvContext != pvContext)
    {
        // When switching contexts, we need to collapse the old menu. This keeps us from
        // hosing the menubands when switching from one browser to another.
        CancelMenu(_pvContext);
        ATOMICRELEASE(_ptpbar);
        ATOMICRELEASE(_pmpParent);
        _pvContext = pvContext;
    }

    pmpParent->SetSubMenu(ptpbar, TRUE);

    _hwndSite = hwndSite;
    _hwndParent = hwndParent;

    // Since the message hook wants to forward messages to the toolbar,
    // we need to ask the pager control to do this
    Pager_ForwardMouse(_hwndSite, TRUE);

    _pmpParent = pmpParent;
    _pmpParent->AddRef();

    _ptpbar = ptpbar;
    _ptpbar->AddRef();

    // HACKHACKHACKHACKHACK (lamadio)
    // On Windows 9x kernel can't handle the reentrancy problem where you have two hooks
    // in two separate processes. When one process looses focus, we collapse the Menu.
    // After that we remove our hook. Problem is: Between the Loosing focus and
    // removing the hook, the other IE process popped up a menu and installed a hook
    // the two hooks mutilate each other.
    if (IsOS(OS_WINDOWS))
    {
        ASSERT(_hEvent == NULL);
        
        _hEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, "Shell.MenuAgent");

        if (!_hEvent)   //event routines return NULL on failure.
            // Don't need to use CreateAllAccessSecurityAttributes since this
            // is Win9x-only code anyway
            _hEvent = CreateEventA(NULL, TRUE, TRUE, "Shell.MenuAgent");

        if (_hEvent)
            WaitForSingleObject(_hEvent, INFINITE);
    }

    if (NULL == _hhookMsg)
    {
        if (_hEvent)
            ResetEvent(_hEvent);
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);
        if (!_hhookMsg && _hEvent)
        {
            SetEvent(_hEvent);
            CloseHandle(_hEvent);
            _hEvent = NULL;
        }
    }

    _fEscHit = FALSE;

    GetCursorPos(&_ptLastMove);
}    


/*----------------------------------------------------------
Purpose: Reset the menu agent; no longer track mouse and keyboard
         messages.  The menuband calls this when it exits menu mode.

*/
void CMenuAgent::Reset(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        _pmpParent->SetSubMenu(_ptpbar, FALSE);

        // The only time to not send MPOS_FULLCANCEL is if the escape
        // key caused the menu to terminate.

        if ( !_fEscHit )
            _pmpParent->OnSelect(MPOS_FULLCANCEL);

        // Eat any mouse-down/up sequence left in the queue.  This is how 
        // we keep the toolbar from getting a mouse-down if the user 
        // clicks on the same menuitem as what is currently popped down.
        // (E.g., click File, then click File again.  W/o this, the menu
        // would never toggle up.)

        MSG msg;

        while (PeekMessage(&msg, _hwndSite, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
            ;   // Do nothing

        Pager_ForwardMouse(_hwndSite, FALSE);

        _hwndSite = NULL;
        _hwndParent = NULL;

        ATOMICRELEASE(_pmpParent);
        ATOMICRELEASE(_ptpbar);

        if (_hhookMsg)
        {
            TraceMsg(TF_MENUBAND, "CMenuAgent: Hook removed");

            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;

            if (_hEvent)
            {
                SetEvent(_hEvent);
                CloseHandle(_hEvent);
                _hEvent = NULL;
            }
        }

        _pvContext = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CMenuAgent::CancelMenu(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        if (_hwndParent)
        {
            ASSERT(IS_VALID_HANDLE(_hwndParent, WND));

            TraceMsg(TF_MENUBAND, "Sending cancel mode to menu");

            // Use PostMessage so USER32 doesn't RIP on us in 
            // MsgHook when it returns from the WM_MOUSEMOVE
            // that triggered this code path in the first place.

            PostMessage(_hwndParent, WM_CANCELMODE, 0, 0);

            // Disguise this as if the escape key was hit,
            // since this is called when the mouse hovers over
            // another menu sibling.
            _fEscHit = TRUE;

            _pmpParent->SetSubMenu(_ptpbar, FALSE);
        }
    }
}    

// store away the identity of the selected menu item.
// if uFlags & MF_POPUP then i is the index.
// otherwise it's the command and we need to convert it to the index.
// we store index always because some popups don't have ids

void CMenuAgent::_OnMenuSelect(HMENU hmenu, int i, UINT uFlags)
{
    _uFlagsLastSelected = uFlags;
    _hmenuLastSelected = hmenu;
}

BOOL CMenuAgent::_OnKey(WPARAM vkey)
{
    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwndSite))
    {
        switch (vkey)
        {
        case VK_LEFT:
          vkey = VK_RIGHT;
          break;

        case VK_RIGHT:
          vkey = VK_LEFT;
          break;
        }
    }

    switch (vkey)
    {
    case VK_RIGHT:
        if (!_hmenuLastSelected || !(_uFlagsLastSelected & MF_POPUP) || (_uFlagsLastSelected & MF_DISABLED) ) 
        {
            // if the currently selected item does not have a cascade, then 
            // we need to cancel out of all of this and tell the top menu bar to go right
            _pmpParent->OnSelect(MPOS_SELECTRIGHT);
        }
        break;
        
    case VK_LEFT:
        if (!_hmenuLastSelected || _hmenuLastSelected == _ptpbar->GetPopupMenu()) {
            // if the currently selected menu item is in our top level menu,
            // then we need to cancel out of all this menu loop and tell the top menu bar
            // to go left 
            _pmpParent->OnSelect(MPOS_SELECTLEFT);
        }
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while in a TrackPopupMenu modal loop.

*/
LRESULT CMenuAgent::MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
#ifdef DEBUG
        if (IsFlagSet(g_dwDumpFlags, DF_MSGHOOK))
            DumpMsg(TEXT("MsgHook"), pmsg);
#endif

        switch (pmsg->message)
        {
        case WM_MENUSELECT:
            // keep track of the items as the are selected.
            g_menuagent._OnMenuSelect(GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam));
            break;
            
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            // Since we've received this msg, any previous escapes
            // (like escaping out of a cascaded menu) should be cleared
            // to prevent a false reason for termination.
            g_menuagent._fEscHit = FALSE;
            break;

        case WM_KEYDOWN:
            if (g_menuagent._OnKey(pmsg->wParam))
                break;
            
        case WM_SYSKEYDOWN:
            g_menuagent._fEscHit = (VK_ESCAPE == pmsg->wParam);
            break;

        case WM_MOUSEMOVE:
            // HACKHACK (isn't all of this a hack?): ignore zero-move
            // mouse moves, so the mouse does not contend with the keyboard.

            POINT pt;
            
            // In screen coords....
            pt.x = GET_X_LPARAM(pmsg->lParam);
            pt.y = GET_Y_LPARAM(pmsg->lParam);

            if (g_menuagent._ptLastMove.x == pt.x && 
                g_menuagent._ptLastMove.y == pt.y)
            {
                TraceMsg(TF_MENUBAND, "CMenuAgent: skipping dup mousemove");
                break;
            }
            g_menuagent._ptLastMove = pt;

            // Since we got a WM_MOUSEMOVE, we need to tell the Menuband global message hook.
            // We need to do this because this message hook steels all of the messages, and
            // the Menuband message hook never updates it's internal cache for removing duplicate
            // WM_MOUSEMOVE messages which cause problems as outlined in CMsgFilter::_HandleMouseMessages
            GetMessageFilter()->AcquireMouseLocation();

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ScreenToClient(g_menuagent._hwndSite, &pt);

            SendMessage(g_menuagent._hwndSite, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    



//=================================================================
// Implementation of a menu deskbar object that uses TrackPopupMenu.
//
// This object uses traditional USER32 menus (via TrackPopupMenu)
// to implement menu behavior.  It uses the CMenuAgent object to 
// help get its work done.  Since the menu deskbar site (_punkSite) 
// sits in a modal loop while any menu is up, it needs to know when
// to quit its loop.  The child object accomplishes this by sending
// an OnSelect(MPOS_FULLCANCEL).
//
// The only time that TrackPopupMenu returns (but we don't want to
// send an MPOS_FULLCANCEL) is if it's b/c the Escape key was hit.
// This just means cancel the current level.  Returning from Popup
// is sufficient for this case.  Otherwise, all other cases of
// returning from TrackPopupMenu means we send a MPOS_FULLCANCEL.
//
// Summary:
//
//  1) User clicked outside the menu.  This is a full cancel.
//  2) User hit the Alt key.  This is a full cancel.
//  3) User hit the Esc key.  This just cancels the current level.
//     (TrackPopupMenu handles this fine.  No notification needs
//     to be sent b/c we want the top-level menu to stay in its
//     modal loop.)
//  4) User selected a menu item.  This is a full cancel.
//
//=================================================================


#undef THISCLASS
#undef SUPERCLASS
#define SUPERCLASS  CMenuDeskBar

STDAPI CTrackPopupBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    CTrackPopupBar * pTPB = new CTrackPopupBar();
    if (pTPB) 
    {
        *ppunk = SAFECAST(pTPB, IOleCommandTarget *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}

HRESULT CTrackPopupBar::InitTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd)
{
    _hmenu = hmenu;
    _hwndParent = hwnd;
    _id = id;
    _pvContext = pvContext;
    return S_OK;
}

// Constructor
CTrackPopupBar::CTrackPopupBar()
{
    _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));
}

// Destructor
CTrackPopupBar::~CTrackPopupBar()
{
    SetSite(NULL);
}


STDMETHODIMP_(ULONG) CTrackPopupBar::AddRef()
{
    return SUPERCLASS::AddRef();
}

STDMETHODIMP_(ULONG) CTrackPopupBar::Release()
{
    return SUPERCLASS::Release();
}

STDMETHODIMP CTrackPopupBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTrackPopupBar, IMenuPopup),
        QITABENT(CTrackPopupBar, IObjectWithSite),
        QITABENT(CTrackPopupBar, IInitTrackPopupBar),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CTrackPopupBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuBandChild)) 
    {
        if (IsEqualIID(riid, IID_IAccessible))
        {
            HRESULT hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(_hmenu, _id);

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }

            return hres;
        }
        else
            return QueryInterface(riid, ppvObj);
    }
    else
        return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the parent menubar to tell us when to
         bail out of the TrackPopupMenu
*/
STDMETHODIMP CTrackPopupBar::OnSelect(DWORD dwType)
{
    switch (dwType)
    {
    case MPOS_CANCELLEVEL:
    case MPOS_FULLCANCEL:
        g_menuagent.CancelMenu(_pvContext);
        break;

    default:
        TraceMsg(TF_WARNING, "CTrackPopupBar doesn't handle this MPOS_ value: %d", dwType);
        break;
    }
    return S_OK;    
}    


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/
STDMETHODIMP CTrackPopupBar::SetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    return E_NOTIMPL;
}    

// HACKHACK: DO NOT TOUCH! This is the only way to select
// the first item for a user menu. TrackMenuPopup by default does
// not select the first item. We pump these messages to our window. 
// User snags these messages, and thinks the user pressed the down button
// and selects the first item for us. The lParam is needed because Win95 gold
// validated this message before using it. Another solution would be to listen
// to WM_INITMENUPOPUP and look for the HWND of the menu. Then send that 
// window the private message MN_SELECTFIRSTVALIDITEM. But thats nasty compared 
// to this. - lamadio 1.5.99
void CTrackPopupBar::SelectFirstItem()
{
    HWND hwndFocus = GetFocus();
    // pulled the funny lparam numbers out of spy's butt.
    if (hwndFocus) {
        PostMessage(hwndFocus, WM_KEYDOWN, VK_DOWN, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_DOWN, 0xD1500001);
#ifdef UNIX
        /* HACK HACK
         * The above PostMessages were causing the second menu item
         * to be selected if you access the menu from the keyboard.
         * The following PostMessages will nullify the above effect.
         * This is to make sure that menus in shdocvw work properly
         * with user32 menus.
         */
        PostMessage(hwndFocus, WM_KEYDOWN, VK_UP, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_UP, 0xD1500001);
#endif /* UNIX */
    }
}
           
DWORD GetBuildNumber()
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (GetVersionEx(&osvi))
        return osvi.dwBuildNumber;
    else
        return 0;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

         Invoke the menu.
*/
STDMETHODIMP CTrackPopupBar::Popup(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    static dwBuildNumber = GetBuildNumber();
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));
    ASSERT(IS_VALID_CODE_PTR(_pmpParent, IMenuPopup));

    // We must be able to talk to the parent menu bar 
    if (NULL == _pmpParent)
        return E_FAIL;

    ASSERT(IS_VALID_HANDLE(_hmenu, MENU));
    ASSERT(IS_VALID_CODE_PTR(_punkSite, IUnknown));
    
    HMENU hmenu = GetSubMenu(_hmenu, _id);
    HWND hwnd;
    TPMPARAMS tpm;
    TPMPARAMS * ptpm = NULL;

    // User32 does not want to fix this for compatibility reasons,
    // but TrackPopupMenu does not snap to the nearest monitor on Single and Multi-Mon
    // systems. This has the side effect that if we pass a non-visible coordinate, then
    // User places menu at a random location on screen. So instead, we're going to bias
    // the point to the monitor.

    MONITORINFO mi = {0};
    mi.cbSize = sizeof(mi);

    HMONITOR hMonitor = MonitorFromPoint(*((POINT*)ppt), MONITOR_DEFAULTTONEAREST);
    GetMonitorInfo(hMonitor, &mi);

    if (ppt->x >= mi.rcMonitor.right)
        ppt->x = mi.rcMonitor.right;

    if (ppt->y >= mi.rcMonitor.bottom)
        ppt->y = mi.rcMonitor.bottom;

    if (ppt->x <= mi.rcMonitor.left)
        ppt->x = mi.rcMonitor.left;

    if (ppt->y <= mi.rcMonitor.top)
        ppt->y = mi.rcMonitor.top;


    if (prcExclude)
    {
        tpm.cbSize = SIZEOF(tpm);
        tpm.rcExclude = *((LPRECT)prcExclude);
        ptpm = &tpm;
    }

    // The forwarding code in CShellBrowser::_ShouldForwardMenu
    // and CDocObjectHost::_ShouldForwardMenu expects the first
    // WM_MENUSELECT to be sent for the top-level menu item.
    // 
    // We need to fake an initial menu select on the top menu band
    // to mimic USER and satisfy this expectation.
    //
    UINT uMSFlags = MF_POPUP;
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(_id, uMSFlags), (LPARAM)_hmenu);
    
    SendMessage(_hwndParent, _nMBIgnoreNextDeselect, NULL, NULL);

    // Initialize the menu agent
    IUnknown_GetWindow(_punkSite, &hwnd);
    
    VARIANTARG v = {0};
    UINT uFlags = TPM_VERTICAL | TPM_TOPALIGN;
    UINT uAnimateFlags = 0;
    if (SUCCEEDED(IUnknown_Exec(_punkSite, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &v))) {
        if (v.vt == VT_I4 && 
            (v.lVal == MENUBAR_RIGHT ||
             v.lVal == MENUBAR_LEFT))
        {
            uFlags = TPM_TOPALIGN;
        }

        switch (v.lVal)
        {
        case MENUBAR_LEFT:      uAnimateFlags = TPM_HORNEGANIMATION;
            break;
        case MENUBAR_RIGHT:     uAnimateFlags = TPM_HORPOSANIMATION;
            break;
        case MENUBAR_TOP:       uAnimateFlags = TPM_VERNEGANIMATION;
            break;
        case MENUBAR_BOTTOM:    uAnimateFlags = TPM_VERPOSANIMATION;
            break;
        }
    }

    g_menuagent.Init(_pvContext, this, _pmpParent, _hwndParent, hwnd);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    if (dwFlags & MPPF_INITIALSELECT)
        SelectFirstItem();

    // This feature only works on build 1794 or greater.
    if (g_bRunOnNT5 && dwBuildNumber >= 1794 && dwFlags & MPPF_NOANIMATE)
        uFlags |= TPM_NOANIMATION;

#ifndef MAINWIN

    if (g_bRunOnMemphis || g_bRunOnNT5)
        uFlags |= uAnimateFlags;

    TrackPopupMenuEx(hmenu, uFlags,
                   ppt->x, ppt->y, _hwndParent, ptpm);
#else
    // Current MainWin's implementation of TrackPopupMenuEx is buggy.
    // I failed to fix it, so I replaced the call by TrackPopupMenu,
    // that provides partial functionality.
    // Hopefully, jluu will be able to fix it.
    TrackPopupMenu(hmenu, uFlags, ppt->x, ppt->y, 0, _hwndParent, 
                   &ptpm->rcExclude);
#endif

    // Tell the parent that the menu is now gone
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);

    g_menuagent.Reset(_pvContext);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mediaband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "resource.h"
#include "dhuihand.h"
#include <varutil.h>
#include "mstimeid.h"
#include <mluisupp.h>
#include "mediahlpr.h"
#include "mediaband.h"
#include "apithk.h"
#include "mbBehave.h"

#define SUPERCLASS  CToolBand

#define MIN_WINDOW_WIDTH     145  
#define MIN_WINDOW_HEIGHT    60
#define MIN_POPOUT_HEIGHT    300
#define MIN_POPOUT_WIDTH     300  
#define MIN_VOLUME_WIDTH     50
#define MIN_VOLUME_HEIGHT    16
#define MIN_HORZ_SPACING     10
#define SEEK_PART_WIDTH     18
#define SEEK_PART_HEIGHT    5
#define SEEK_HEIGHT          16
#define VOLUME_GRIPPER_LENGTH   6
#define COLOR_BKGND16        RGB(192, 192, 192)
#define COLOR_BKGNDMIDDLE   RGB(99, 129, 193)
#define VOLUME_BITMAP_WIDTH 42

#define VIDEO_MIN_HEIGHT    60
#define VIEW_MARGIN_BOTTOM  7
#define VIEW_MARGIN_LEFT     6
#define VIEW_MARGIN_INFO_LEFT     5
#define VIEW_MARGIN_RIGHT    10
#define VIEW_MARGIN_TOP     5
#define VIEW_MARGIN_TOP_VIDEO   6
#define VIEW_MARGIN_BOTTOM  7
#define VIEW_CONTROLS_HEIGHT    33
#define VIEW_CONTROLS_MARGIN    2

#define SCALEX(x)   (_fHighDPI ? ((INT)(((float)(x))*_scaleX)) : (x))
#define SCALEY(x)   (_fHighDPI ? ((INT)(((float)(x))*_scaleY)) : (x))

#define WZ_SMIE_MEDIA_MIME      REG_MEDIA_STR TEXT("\\MimeTypes")
#define REG_VALUE_MRU_INTERNET  REG_MEDIA_STR TEXT("\\Internet")
#define REG_VALUE_PATH           TEXT("MusicPath")

// 
// ISSUE: dilipk: these are localizable strings and need to be moved eventually !!!
//
#define WZ_WINDOWSMEDIA           L"http://www.windowsmedia.com"
 
#define WZ_ASX_MIMETYPE             L"video/x-ms-asx"

static const TCHAR c_szMediaBandProp[] = TEXT("CMediaBand_This");
static const TCHAR c_szMediaBarClassName[]       = TEXT("MediaPane");
static const TCHAR c_szMediaBarPopupClassName[] = TEXT("MediaPopupPane");
static const TCHAR c_szMediaBarLayoutClassName[] = TEXT("MediaLayoutPane");

// ISSUE: these two should be deleted when reg utilities are completely moved to mediautil.cpp
static const UINT MAX_REG_VALUE_LENGTH =  50;

// This is the number of ticks (from MSTIME) to skip each time before polling System Time 
// for the navigation timeout counter
#define POLL_INTERVAL       30
// This is the number of milli-seconds after which navigation times out
#define TIMEOUT_INTERVAL    90000 

static const TCHAR c_szContentUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=511");
static const TCHAR c_szMoreMediaUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=512");
static const TCHAR c_szRadioUrl[] = TEXT("http://go.microsoft.com/fwlink/?LinkId=822");

static const TCHAR c_szOfflineURL[] = TEXT("mbOffline.htm");
static const TCHAR c_szLoadingURL[] = TEXT("mbLoading.htm");
static const TCHAR c_sz404URL[]     = TEXT("mb404.htm");


extern HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig);

//
// ISSUE: this is a temporary guid for the content pane sync feature.
//
static const IID SID_SMediaBarSync = { 0x2efc8085, 0x066b, 0x4823, { 0x9d, 0xb4, 0xd1, 0xe7, 0x69, 0x16, 0xda, 0xa0 } };
static const GUID SID_STimeContent = { 0x1ae98e18, 0xc527, 0x4f78, {0xb2, 0xa2, 0x6a, 0x81, 0x7f, 0x9c, 0xd4, 0xf8}};

// ISSUE where could be #include this GUID from?????
static const GUID CLSID_JITWMP8 = { 0x6BF52A52, 0x394A, 0x11d3, 0xb1, 0x53, 0x00, 0xc0, 0x4f, 0x79, 0xfa, 0xa6 };



CMediaBand::CMediaBand() :
    _fPlayButton(TRUE),
    _fPlayEnabled(TRUE),
    _iCurTrack(-1),
    _lTickCount(-1),
    _iElement(-1),
    _dblVol(-1.0),
    _fHiColour(TRUE),
    _fUserPaused(FALSE),
    _iOptionsWidth(0),
    _hbmpBackground(NULL),
    _hwndContent(NULL),
    _dwcpCookie(0),
    _fContentInFocus(FALSE),
    _hkeyWMP(NULL),
    _fShow(FALSE),
    _fAttached(FALSE)
{
    _sizeLayout.cx = MIN_WINDOW_WIDTH;
    _sizeLayout.cy = MIN_WINDOW_HEIGHT;
    _sizeVideo.cx  = 0 ;
    _sizeVideo.cy  = 0 ;
    _fCanFocus = TRUE;
    _scaleX = _scaleY = 1.0;

    // HighDPI support requires nice comctl32 6.0 functionality.
    if (IsOS(OS_WHISTLERORGREATER))
    {
        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            _scaleX = (GetDeviceCaps(hdcScreen, LOGPIXELSX) / 96.0f);
            _scaleY = (GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0f);
            ReleaseDC(NULL, hdcScreen);
        }
    }
    _fHighDPI = (_scaleX!=1.0) || (_scaleY!=1.0);
}

CMediaBand::~CMediaBand()
{
    DestroyPlayer();

    if (_spBrowser)
    {
        _ConnectToCP(FALSE);
        _spBrowser.Release();
        _poipao.Release();
    }
    DESTROY_OBJ_WITH_HANDLE(_hwndContent, DestroyWindow);

    DESTROY_OBJ_WITH_HANDLE(_hwndPopup, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hwndLayout, DestroyWindow);
    DESTROY_OBJ_WITH_HANDLE(_hPlayListMenu, DestroyMenu);
    DESTROY_OBJ_WITH_HANDLE(_himlSeekBack, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlSeekFill, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlGripper, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlVolumeBack, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_himlVolumeFill, ImageList_Destroy);
    DESTROY_OBJ_WITH_HANDLE(_hbmpBackground, DeleteObject);

    // need to check IsWindow because this window can also be destroyed by CMediaBarPlayer
    if (_hwndVideo && ::IsWindow(_hwndVideo))
        DestroyWindow(_hwndVideo);

    if (_szToolTipUrl)
    {
        delete [] _szToolTipUrl;
    }

    if (_pszStatus)
    {
        delete [] _pszStatus;
    }

    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (_pmw[i])
        {
            delete _pmw[i];
        }
    }

    if (_hkeyWMP)
        RegCloseKey(_hkeyWMP);
}
    


// helper to get up to service provider and to do register/unregister
// two forms:
//      pService != NULL, register, pdwCookie is [out] returns cookie
//      pService == NULL, unregister, *pdwCookie is [in] de-registers the service

STDMETHODIMP CMediaBand::ProfferService(IUnknown *punkSite, REFGUID sidWhat, 
                                        IServiceProvider *pService, DWORD *pdwCookie)
{
    IProfferService *pps;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
    if (SUCCEEDED(hr))
    {
        if (pService)
            hr = pps->ProfferService(sidWhat, pService, pdwCookie);
        else
        {
            hr = pps->RevokeService(*pdwCookie);
            *pdwCookie = 0;
        }
        pps->Release();
    }
    return hr;
}


HRESULT CMediaBand::SetSite(IUnknown *punkSite)
{
    // Make sure we proffer the service only once
    // This is important since we get created multiple times,
    CComPtr<IUnknown> spUnk;

    // Check if we need to revoke our service, or if our service was already proffered by
    // another instance of CMediaBar
    if ((!punkSite && _dwCookieServiceMediaBar) || 
        (punkSite && FAILED(IUnknown_QueryService(punkSite, SID_SMediaBar, IID_PPV_ARG(IUnknown, &spUnk)))))
    {
        // Proffer or Revoke BrandBand service as appropriate
        ProfferService(punkSite ? punkSite : _punkSite, SID_SMediaBar, 
              punkSite ? SAFECAST(this, IServiceProvider *) : NULL, &_dwCookieServiceMediaBar);
        // Failure here does not require special handling
    }

    return SUPERCLASS::SetSite(punkSite);
}

HRESULT CMediaBand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMediaBand, IMediaBar),
        QITABENT(CMediaBand, IWinEventHandler),
        QITABENT(CMediaBand, IObjectWithSite),
        QITABENT(CMediaBand, INamespaceWalkCB),
        QITABENTMULTI(CMediaBand, IDispatch, DWebBrowserEvents2),
        QITABENTMULTI2(CMediaBand, DIID_DWebBrowserEvents2, DWebBrowserEvents2),
        QITABENT(CMediaBand, IElementBehaviorFactory),
        QITABENT(CMediaBand, IBrowserBand),
        QITABENT(CMediaBand, IBandNavigate),
        QITABENT(CMediaBand, IMediaHost),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        hr = SUPERCLASS::QueryInterface(riid, ppv);
    }
    return hr;
}

// *** IWinEventHandler ***
HRESULT CMediaBand::IsWindowOwner(HWND hwnd)
{
    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (_pmw[i] && (hwnd==_pmw[i]->_hwnd))
        {
            return S_OK;
        }
    }

    return S_FALSE;
}

// *** IWinEventHandler ***
HRESULT CMediaBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            HWND hwndControl = GET_WM_COMMAND_HWND(wParam, lParam);
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            
            if (HIWORD(wParam) == BN_CLICKED && hwndControl)
            {
                RECT       rc;
                VARIANTARG var;

                var.vt = VT_I4;
                GetWindowRect(hwndControl, &rc);
                MapWindowPoints(hwndControl, HWND_DESKTOP, (LPPOINT)&rc, 2);
                var.lVal = MAKELONG(rc.left, rc.bottom);
                return Exec(&CLSID_MediaBand, idCmd, 0, &var, NULL);
            }            
        }
        break;
    }
    return S_FALSE;
}


void CMediaBand::_ClearFolderItems()
{
    if (_ppidls)
    {
        FreeIDListArray(_ppidls, _cidls);
        _ppidls = NULL;
    }
    _cidls = 0;
}

// INamespaceWalkCB methods
HRESULT CMediaBand::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (NULL == _hkeyWMP)
    {
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Applications\\mplayer2.exe\\SupportedTypes"), &_hkeyWMP);
    }

    HRESULT hr = S_FALSE;   // default to no
    if (_hkeyWMP)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName))))
        {
            if (ERROR_SUCCESS == RegQueryValueEx(_hkeyWMP, PathFindExtension(szName), NULL, NULL, NULL, NULL))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

STDMETHODIMP CMediaBand::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel) 
{
    TCHAR szText[200];
    MLLoadString(IDS_MEDIABANDSEARCH, szText, ARRAYSIZE(szText));

    SHStrDup(szText, ppszTitle); 
    *ppszCancel = NULL; 
    return S_OK; 
}

HRESULT CMediaBand::_GetMusicFromFolder()
{
    _ClearFolderItems();

    INamespaceWalk *pnsw;
    HRESULT hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        hr = pnsw->Walk(_punkSite, NSWF_ONE_IMPLIES_ALL | NSWF_NONE_IMPLIES_ALL | NSWF_SHOW_PROGRESS, 10, this);
        if (SUCCEEDED(hr))
        {
            hr = pnsw->GetIDArrayResult(&_cidls, &_ppidls);
        }
        pnsw->Release();
    }
    return hr;
}

// *** IOleCommandTarget methods ***
HRESULT CMediaBand::Exec(const GUID *pguidCmdGroup, 
                         DWORD       nCmdID,
                         DWORD       nCmdexecopt, 
                         VARIANTARG *pvarargIn, 
                         VARIANTARG *pvarargOut)
{
    HRESULT hr = S_OK;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CLSID_MediaBand, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
            case FCIDM_MEDIABAND_POPOUT:
                {
                    DockMediaPlayer();
                }
                break;
                
            case FCIDM_MEDIABAND_PLAY:
                if (!_pMediaPlayer || _pMediaPlayer->isStopped())
                {
                    _CleanupStopTimer();
                    hr = _GetMusicFromFolder();
                    if (S_OK == hr)
                    {
                        _strLastUrl.Empty();    // would be nicer to replay same local file if navigated away....
                        PlayLocalTrack(0);
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
                    {
                        // if we already played a media in this session, replay it
                        if (_strLastUrl.Length() > 0)
                        {
                            if (_fLastUrlIsAutoPlay)
                            {
                                // repeat playing last auto-play
                                CComVariant vtURL = _strLastUrl;
                                CComVariant vtMime = _strLastMime;
                                Exec(&CGID_MediaBar, MBID_PLAY, 0, &vtMime, &vtURL);
                            }
                            else
                            {
                                // replay media thru content pane and media bar behavior
                                NavigateContentPane(_strLastUrl);
                            }
                        }
                        else
                        {
                            NavigateMoreMedia();
                        }
                    }
                }
                else
                {
                    _TogglePause();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_PREVIOUS:
                if (EnsurePlayer())
                {
                    LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
                    LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();

                    if (lCurTrack > 0)
                    {
                        _pMediaPlayer->Prev();
                    }
                    else if (_iCurTrack >= 0)
                    {
                        int i = _iCurTrack;
                        _iCurTrack = -1;        // don't auto-step to next on finished event
                        _pMediaPlayer->Stop();  // generates MEDIA_TRACK_FINISHED
                        PlayLocalTrack((i - 1 >= 0) ? i - 1 : 0);
                    }
                    UpdateBackForwardControls();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_NEXT:
                if (EnsurePlayer())
                {
                    LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
                    LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();

                    if ((lCurTrack >= 0) && (lCurTrack < lItemCount - 1))
                    {
                        _pMediaPlayer->Next();
                    }
                    else if (_iCurTrack >= 0)
                    {
                        int i = _iCurTrack;
                        _iCurTrack = -1;        // don't auto-step to next on finished event
                        _pMediaPlayer->Stop();  // generates MEDIA_TRACK_FINISHED
                        PlayLocalTrack(i + 1);
                    }
                    UpdateBackForwardControls();
                    TogglePlayPause();
                }
                break;
                
            case FCIDM_MEDIABAND_STOP:
                // when player is attached thru mediaBar behavior to script in media content pane,
                // we want to give the user a chance to get rid of the script and return to the default media content
                // the first click simply stops the player, clicking again within N secs will also navigate
                // the content pane to the default URL
                if (_idStopTimer == 0)
                {
                    if (_IsProxyRunning())
                    {
                        _idStopTimer = SetTimer(_hwnd, 747, 10000, NULL);
                    }
                    ResetPlayer();
                    _OnUserOverrideDisableUI();
                }
                else
                {
                    // clicked again, navigate media content to default URL
                    _CleanupStopTimer();
                    _NavigateContentToDefaultURL();
                }
                break;
                
            case FCIDM_MEDIABAND_MUTE:
                ToggleMute();
                break;
            }
        }
        else if (IsEqualGUID(CGID_MediaBar, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
            case MBID_PLAY:
                if (pvarargIn && pvarargOut)
                {
                    _CleanupStopTimer();
                    if (_IsProxyRunning())
                    {
                        // user clicked on a media link in the main content pane, unfreeze controls!
                        _OnUserOverrideDisableUI();
                        _DetachProxies();
                        _NavigateContentToDefaultURL();
                    }

                    if (V_VT(pvarargOut) == VT_BSTR)
                    {
                        _strLastUrl = V_BSTR(pvarargOut);
                    }
                    if (V_VT(pvarargIn) == VT_BSTR)
                    {
                        _strLastMime = V_BSTR(pvarargIn);
                    }
                    _fLastUrlIsAutoPlay = TRUE;

                    // ISSUE: fix this to use the right CmdId & CmdIdGroup, not just zero, to prevent collisions.
                    // this is an auto-play command
                    _HandleAutoPlay(pvarargIn, pvarargOut);
                    hr = S_OK;
                }
                break;

            case MBID_POPOUT:
                if (pvarargOut)
                {
                    V_VT(pvarargOut) = VT_BOOL;
                    V_BOOL(pvarargOut) = _hwndPopup && IsWindowVisible(_hwndPopup);
                    hr = S_OK;
                }
                break;

            default:
                ASSERT(FALSE);
                break;
            }
        }
        else
        {
            hr = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
        }
    }
    else
    {
        hr = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    return hr;
}

void CMediaBand::_HandleAutoPlay(VARIANTARG *pvarargMime, VARIANTARG *pvarargUrl)
{
    // check the mime type argument
    if (    (!pvarargMime)
        ||  (VT_BSTR != V_VT(pvarargMime))
        ||  (!V_BSTR(pvarargMime))
        ||  (L'' == (*V_BSTR(pvarargMime))))
    {
        goto done;
    }

    // check the Url argument
    if (    (!pvarargUrl) 
        ||  ( VT_BSTR != V_VT(pvarargUrl))
        ||  (!V_BSTR(pvarargUrl)) 
        ||  (L'' == (*V_BSTR(pvarargUrl))))
    {
        goto done;
    }

    if (EnsurePlayer())
    {
        // reset this to -1 to indicate we are not playing a mymusic track
        _iCurTrack = -1;

#ifdef _USE_MEDIA_MRU
        // ISSUE: temp fix for radio protocol. If this is an ASX mimetype, we know it is radio
        if (!SHRestricted(REST_NORECENTDOCSHISTORY))
        {
            CMediaMRU mmru;
            mmru.Load(REG_VALUE_MRU_INTERNET);
            mmru.Add(V_BSTR(pvarargUrl));
        }
#endif // _USE_MEDIA_MRU

        if (0 == StrCmpNIW(V_BSTR(pvarargMime), WZ_ASX_MIMETYPE, wcslen(WZ_ASX_MIMETYPE)))
        {
            _PutUrl(V_BSTR(pvarargUrl), V_BSTR(pvarargMime));
        }
        else
        {
            _PutUrl(V_BSTR(pvarargUrl), NULL);
        }

        TogglePlayPause();
    
        // clear the url to indicate we are handling this url
        ::VariantClear(pvarargUrl);
    }
    else
    {
        ASSERT(FALSE);
    }
done:
    ;
}

VOID
CMediaBand::_BeginTimeOutCounter(BOOL fClear /* = TRUE */)
{
    _dwStartTime = GetPerfTime();
    _lTickCount = 0;
    if (TRUE == fClear)
    {
        _dblLastBufProgress = 0;
        _dblLastPlayProgress = 0;
    }
}

VOID
CMediaBand::_EndTimeOutCounter()
{
    _lTickCount = -1;
}

VOID
CMediaBand::_UpdateTimeOutCounter(double dblCurrBufProgress, double dblCurrPlayProgress)
{
    BOOL fTimeOut = FALSE;

    // bail if the counter has not been started
    if (_lTickCount < 0)
        return;

    // Order of checking is important here.

    // If play progress is increasing then restart the counter
    if (dblCurrPlayProgress > _dblLastPlayProgress)
    {
        _BeginTimeOutCounter(FALSE);
        _dblLastPlayProgress = dblCurrPlayProgress;
    }
    // if buffering progress is increasing then restart the counter
    else if (dblCurrBufProgress > _dblLastBufProgress)
    {
        _BeginTimeOutCounter(FALSE);
        _dblLastBufProgress = dblCurrBufProgress;
    }
    else
    {
        // both play and buffering progress are stalled, so update the timeout counter

        // We poll the system time every POLL_INTERVAL ticks since we tick at a very high rate
        // (a tick is each time this function is called)

        if ((1 + _lTickCount) == POLL_INTERVAL)
        {
            DWORD dwCurrentTime = GetPerfTime();

            DWORD dwElapsedTime = (dwCurrentTime - _dwStartTime) 
                            + (dwCurrentTime < _dwStartTime ? 0xffffffff : 0); // if timer wraps around 2^32 milliseconds

            if (dwElapsedTime >= TIMEOUT_INTERVAL)
            {
                fTimeOut = TRUE;
            }
        }

        if (fTimeOut)
        {
            _OnNavigationTimeOut();
        }
        else
        {
            // update the poll interval counter and mod it by POLL_INTERVAL 
            _lTickCount =  (1 + _lTickCount) - (static_cast<long>(_lTickCount / POLL_INTERVAL) * POLL_INTERVAL);
        }
    }
}

VOID
CMediaBand::_OnNavigationTimeOut()
{
    _EndTimeOutCounter();

    // stop the player and show the timeout message
    if (EnsurePlayer())
    {
        if (VARIANT_FALSE == _pMediaPlayer->isStopped())
        {
            _pMediaPlayer->Stop();
            TogglePlayPause();

            // Show timeout error message
            TCHAR szText[200];
            szText[0] = TEXT('\0');
            MLLoadString(IDS_MEDIABAND_NAVTIMEOUT, szText, ARRAYSIZE(szText));
            SetStatusText(szText);
        }
    }
}

STDMETHODIMP
CMediaBand::_PutUrl(LPWSTR pstrUrl, LPWSTR pstrMime)
{
    HRESULT hr = E_FAIL;

    if (EnsurePlayer())
    {
        TCHAR szText[200];
        szText[0] = TEXT('\0');

        SetStatusText(_szConnecting);
        hr = _pMediaPlayer->put_type(pstrMime);
        if (SUCCEEDED(hr))
        {
            hr = _pMediaPlayer->put_url(pstrUrl);
            if (SUCCEEDED(hr))
            {
                // start the timeout counter
                if (_dblVol!=-1)
                {
                    _pMediaPlayer->put_volume(_dblVol);
                }
                _pMediaPlayer->put_mute(_fMuted);
                _BeginTimeOutCounter();
                UpdateBackForwardControls();
                SetPlayPause(FALSE);
                SetPlayerControl(FCIDM_MEDIABAND_STOP, TRUE);

                // make sure we undavise from soon-to-be obsolete player object 
                _AttachPlayerToProxies(FALSE);
            }
        }
    }
    return hr;
}

// *** IInputObject methods ***
HRESULT CMediaBand::TranslateAcceleratorIO(LPMSG pMsg)
{
    ASSERT(pMsg);
    TraceMsg(TF_ACCESSIBILITY, "CMediaBand::TranslateAcceleratorIO (hwnd=0x%08X) key=%d", _hwnd, pMsg->wParam);

    BOOL fHasFocus =     (   (_iElement>=0)
                          || (HasFocusIO() == S_OK)
                          || _fContentInFocus);

    if (fHasFocus && IsVK_CtlTABCycler(pMsg))
    {
        // Bail on ctl-tab/F6 if one of our guys already has focus
        return S_FALSE;
    }

    // if any child in focus, let them have a shot at it
    HRESULT hr = S_FALSE;
    if (fHasFocus)
    {
        if (_iElement >=0)
        {
            if (_hwndPopup && IsWindowVisible(_hwndPopup) && (pMsg->message==WM_KEYDOWN) && (pMsg->wParam==VK_ESCAPE))
    	    {
    	        DockMediaPlayer();
                hr = S_OK;
    	    }
            else 
            {
                hr = _pmw[_iElement]->TranslateAccelerator(pMsg);
            }
        }
        else if (_fContentInFocus && _poipao)
        {
            hr = _poipao->TranslateAccelerator(pMsg);
        }
        if (hr == S_OK) 
        {
            return S_OK;    // handled!!
        }
    }

    hr = S_FALSE;
    // try shifting focus to next element
    if (IsVK_TABCycler(pMsg))
    {
        BOOL fReverse = (GetKeyState(VK_SHIFT) < 0);
        if (fReverse)
        {
            // content pane is last tab target, move to last control widget with this backward tab
            if (_fContentInFocus)
            {
                _ContentActivateIO(FALSE, NULL);
                if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
                {
                    _iElement = ARRAYSIZE(_pmw)-1;
                }
                else
                {
                    return S_FALSE;
                }
            }
            else do 
            {
                _iElement--;
                if (_iElement<0)
                {
                    if (_fPopoutHasFocus)
                    {
                        _iElement = ARRAYSIZE(_pmw)-1;
                    }
                    break;
                }
            }
            while (!ISVALIDWIDGET(_pmw[_iElement]) || (!_pmw[_iElement]->IsEnabled()));
        }
        else
        {
            // content pane is last tab target, move away from mediabar with this forward tab
            if (_fContentInFocus)
            {
                _ContentActivateIO(FALSE, NULL);
                return S_FALSE;
            }
            // try next control widget
            if (!(_hwndPopup && IsWindowVisible(_hwndPopup)) || _fPopoutHasFocus)
            {
                if (_iElement<0)
                {
                    _iElement = 0;
                }
                else do 
                {
                    _iElement++;
                    if (_iElement>=ARRAYSIZE(_pmw))
                    {
                        _iElement = _fPopoutHasFocus ? 0 : -1;
                        break;
                    }
                }
                while (!ISVALIDWIDGET(_pmw[_iElement]) || (!_pmw[_iElement]->IsEnabled()));
            }
            // none of the control widgets claimed focus, try content pane
            if (_iElement<0)
            {
                hr = _ContentActivateIO(TRUE, pMsg);
                if (hr == S_OK) {
                    return S_OK;    // handled!!
                }
            }
        }
        if (_iElement<0)
        {
            return S_FALSE;
        }

        ASSERT(ISVALIDWIDGET(_pmw[_iElement]));
        ::SetFocus(_pmw[_iElement]->_hwnd);
        return S_OK;
    }
    
    return S_FALSE; // unhandled non-tab
}

//------------------------------------------------------------------------
HRESULT
    CMediaBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(TF_ACCESSIBILITY, "CMediaBand::UIActivateIO (hwnd=0x%08X) fActivate=%d", _hwnd, fActivate);
    HRESULT hr = S_OK;

    // activation:
    if (fActivate)
    {
        if (!(_hwndPopup && IsWindowVisible(_hwndPopup)) || _fPopoutHasFocus)
        {
            if (_iElement==-1)
            {
                _ContentActivateIO(FALSE, NULL);
                _iElement = 0;
            }
            if (_pmw[_iElement] && _pmw[_iElement]->_hwnd)
            {
                ::SetFocus(_pmw[_iElement]->_hwnd);
            }
        }
        else
        {
            _iElement = -1;
            _ContentActivateIO(TRUE, pMsg);
        }
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
    }
    else
    {
        _ContentActivateIO(FALSE, NULL);
        _iElement = -1;
        if (_hwndPopup && IsWindowVisible(_hwndPopup))
        {
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);
        }            
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT
    CMediaBand::HasFocusIO()
{
    HRESULT hr = SHIsChildOrSelf((_hwndPopup && IsWindowVisible(_hwndPopup)) ? _hwndPopup : _hwnd, ::GetFocus());
    if (hr==S_FALSE)
    {
        // Focus might be in the content pane, which won't be a child if the popout is out
        hr = SHIsChildOrSelf(_hwndContent, ::GetFocus());
    }
    return hr;
}


HRESULT CMediaBand::_ContentActivateIO(BOOL fActivate, PMSG pMsg)
{
    ASSERT(_hwndContent);
    ASSERT(_poipao);

    if (_fContentInFocus == fActivate)
    {
        return S_OK;
    }

    _fContentInFocus = fActivate;
    if (fActivate)
    {
        _iElement = -1;
    }
    int iVerb = fActivate ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE;

    HRESULT hr = S_OK;
    hr = OCHost_DoVerb(_hwndContent, iVerb, pMsg);

    // OCHost UIActivate is different than IInputObject::UIActivateIO.  It
    // doesn't do anything with the lpMsg parameter.  So, we need to pass
    // it to them via TranslateAccelerator.  Since the only case we care
    // about is when they're getting tabbed into (we want them to highlight
    // the first/last link), just do this in the case of a tab.  However,
    // don't give it to them if it's a ctl-tab.  The rule is that you shouldn't
    // handle ctl-tab when UI-active (ctl-tab switches between contexts), and
    // since Trident is always UI-active (for perf?), they'll always reject
    // ctl-tab.


    // suppress sending any tabs
    if (pMsg && _poipao && IsVK_TABCycler(pMsg) && !IsVK_CtlTABCycler(pMsg))
    {
        hr = _poipao->TranslateAccelerator(pMsg);
        // ignore if translate of tab fails when activating!
        if (FAILED(hr) && fActivate) {
            hr = S_OK;
        }
    }

    return hr;
}

LRESULT CMediaBand::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case OCN_ONUIACTIVATE:  // UIActivate
        ASSERT(SHIsSameObject(((LPOCNONUIACTIVATEMSG)pnm)->punk, _poipao));

        _fContentInFocus = TRUE;
        _iElement = -1;
        
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        return OCNONUIACTIVATE_HANDLED;

    case OCN_ONSETSTATUSTEXT:
        {
            HRESULT hr = E_FAIL;
            IShellBrowser *psb;

            hr = QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
            if (SUCCEEDED(hr)) {
                hr = psb->SetStatusTextSB(((LPOCNONSETSTATUSTEXTMSG)pnm)->pwszStatusText);
                psb->Release();
            }
        }
        break;

    default:
        break;
    }

    ASSERT(OCNONUIACTIVATE_HANDLED != 0);
    return 0;
}



// *** IDeskBand methods ***
HRESULT 
CMediaBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;

    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    if (pdbi->dwMask & DBIM_MINSIZE) 
    {
        pdbi->ptMinSize.x = 16;
        pdbi->ptMinSize.y = 16;
    }
    
    if (pdbi->dwMask & DBIM_MAXSIZE) 
    {
        pdbi->ptMaxSize.x = 32000; // random
        pdbi->ptMaxSize.y = 32000; // random
    }

    if (pdbi->dwMask & DBIM_ACTUAL) 
    {
        pdbi->ptActual.x = -1;
        pdbi->ptActual.y = -1;
    }

    if (pdbi->dwMask & DBIM_INTEGRAL) 
    {
        pdbi->ptIntegral.y = 1;
    }

    MLLoadStringW(IDS_MEDIABANDTEXT, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));

    return S_OK;
} 

/***   CMediaBand::IPersistStream::**/
HRESULT CMediaBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MediaBand;
    return S_OK;
}

// *** IPersistStream methods ***
HRESULT CMediaBand::Load(IStream *pstm)
{
    return S_OK;
}

// *** IPersistStream methods ***
HRESULT CMediaBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

// *** IOleWindow methods ***
HRESULT CMediaBand::GetWindow(HWND *phwnd)
{
    if (!_hwnd) 
    {
        CreateParentPane();
    }

    if (!_hwndLayout) 
    {
        CreateLayoutPane();
    }
    if (!_hwndContent)
    {
        InitContentPane();
    }

    if (phwnd)
    {
        *phwnd = _hwnd ;
         return S_OK;
    }
    return SUPERCLASS::GetWindow(phwnd);
}

// *** IDockingWindow methods ***
HRESULT CMediaBand::ShowDW(BOOL fShow)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.

    _fVideoAdjust = FALSE;
    if (fShow)
    {   
        _InitializeMediaUI();

        // FEATURE/010228/davidjen  uncomment this to suppress MediaBar's title bar
#ifdef _SUPPRESS_MB_TITLEBAR
        // hide caption/titlebar
        CComQIPtr<IBandSite, &IID_IBandSite>    pbs = _punkSite;
        if (pbs)
        {
            BANDSITEINFO    bsi;
            bsi.dwMask = BSIM_STYLE;
            HRESULT hr = pbs->GetBandSiteInfo(&bsi);
            if (SUCCEEDED(hr))
            {
                // suppress caption
                bsi.dwStyle |= BSIS_NOCAPTION;
                hr = pbs->SetBandSiteInfo(&bsi);
            }
        }
#endif // _SUPPRESS_MB_TITLEBAR
        
        if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
        {
            RECT rcParent, rc;
            GetClientRect(_hwnd, &rcParent);
            GetClientRect(_hwndLayout, &rc);

            if (RECTWIDTH(rcParent) > 0  || RECTHEIGHT(rcParent) > 0)
            {
                _ResizeChildWindows(_hwndLayout, RECTWIDTH(rc), RECTHEIGHT(rc), TRUE);
                SetWindowPos(_hwnd, NULL, 0, 0,RECTWIDTH(rcParent), RECTHEIGHT(rcParent), SWP_SHOWWINDOW | SWP_NOACTIVATE);
                RedrawWindow(_hwnd, NULL, NULL, RDW_INVALIDATE|RDW_UPDATENOW|RDW_ALLCHILDREN);
            }
        }
    }
    else
    {
        _ShowAllWindows(fShow);
    }
    if (fShow != _fShow)
    {
        _fShow = fShow;
        _FireEventToProxies(_fShow ? OnShow : OnHide);
    }
    return CToolBand::ShowDW(fShow);
}

HRESULT CMediaBand::CloseDW(DWORD dwReserved)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.
    
    WTSUnRegisterSessionNotification(_hwnd);

    DestroyPlayer();

    if (_spBrowser)
    {
        _ConnectToCP(FALSE);
        _spBrowser.Release();
        _poipao.Release();
    }

    if (_hwndLayout && IsWindow(_hwndLayout))
    {
        DestroyWindow(_hwndLayout);
        _hwndLayout = NULL;
    }
    
    if (_hwndPopup && IsWindow(_hwndPopup))
    {
        DestroyWindow(_hwndPopup);
        _hwndPopup = NULL;
    }

    SUPERCLASS::CloseDW(dwReserved);

    return S_OK;
}


//--------------    Interface IElementBehaviorFactory
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::FindBehavior(BSTR bstrBehavior, BSTR bstrBehaviorUrl,
							          IElementBehaviorSite* pSite, IElementBehavior** ppBehavior)
{
    if (ppBehavior == NULL)
    {
        return E_POINTER;
    }
    *ppBehavior = NULL;

    // check namespace and URL
    if (StrCmpIW(bstrBehavior, TEXT("mediaBar")) != 0) {
        return E_NOTIMPL;   // don't know this behavior!!
    }

    HRESULT hr = S_OK;
    // create new behavior instance for this HTML pane
    IContentProxy * pProxy = NULL;
    pProxy = CMediaBehavior_CreateInstance(this);
    if (pProxy)
    {
        hr = pProxy->QueryInterface(IID_IElementBehavior, (void**)ppBehavior);
        if (FAILED(hr))
        {
            // make sure we get rid our reference
            removeProxy(pProxy);
        }
    }
    else {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// IMediaHost
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::getMediaPlayer(IUnknown **ppPlayer)
{
    if (ppPlayer == NULL)
        return E_POINTER;
    *ppPlayer = NULL;

    if (_pMediaPlayer)
    {
        ITIMEMediaElement *pElem = NULL;
        if (SUCCEEDED(_pMediaPlayer->get_mediaElement(&pElem)))
        {
            *ppPlayer = pElem;  // no AddRef, get_mediaElement already did ref counting!!
        }
    }
    return *ppPlayer ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::playURL(BSTR bstrURL, BSTR bstrMIME)
{
    HRESULT hr = _EnsureWMPInstalled();
    if (FAILED(hr))
    {   
        return hr;
    }
    CComVariant varMime = bstrMIME;
    CComVariant varUrl  = bstrURL;

    _strLastUrl = _strCurrentContentUrl;
    _strLastMime.Empty();
    _fLastUrlIsAutoPlay = FALSE;

    _HandleAutoPlay(&varMime, &varUrl);
    return S_OK;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::addProxy(IUnknown *punkProxy)
{
    HRESULT hr = E_POINTER;
    if (punkProxy)
    {
        // add to our array of proxies
        if (_apContentProxies == NULL) {
            _apContentProxies.Create(2);
        }
        if (_apContentProxies == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // want to be sure proxy knows our protocol, also does add ref
        IContentProxy *pProxy = NULL;
        hr = punkProxy->QueryInterface(IID_PPV_ARG(IContentProxy, &pProxy));
        if (SUCCEEDED(hr))
        {
            _apContentProxies.AppendPtr(pProxy);
        }

    }
    return hr;
}

//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::removeProxy(IUnknown *punkProxy)
{
    if (_apContentProxies == NULL)
        return S_FALSE;

    HRESULT hr = S_FALSE;
    int cnt = _apContentProxies.GetPtrCount();
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            if (SHIsSameObject(pProxy, punkProxy))
            {
                _apContentProxies.DeletePtr(i);
                pProxy->Release();
                ResetPlayer();  // privacy issue:
                                    // make sure player is stopped and proxy/behavior in next page cannot access current media
                _fAttached = FALSE;     // force reattaching to player once a new behavior is up
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

// IMediaHost2
//------------------------------------------------------------------------
STDMETHODIMP CMediaBand::OnDisableUIChanged(BOOL fDisabled)
{
    return S_OK;
}


//------------------------------------------------------------------------
void CMediaBand::_AttachPlayerToProxies(BOOL fAttach)
{
    if (_apContentProxies == NULL)
        return;
    if (_fAttached == fAttach)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            HRESULT hr;
            if (fAttach) {
                hr = pProxy->OnCreatedPlayer();
            }
            else {
                pProxy->detachPlayer();
                hr = S_OK;
            }
            if (SUCCEEDED(hr)) {
                _fAttached = fAttach;
            }
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_DetachProxies()
{ 
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    // need to iterate from last to first, call to removeProxy() will also remove it from DPA!
    for (int i = cnt - 1; i >= 0; i--)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            removeProxy(pProxy);
        }
    } 
    _apContentProxies.Destroy();
    return;
}

//------------------------------------------------------------------------
BOOL CMediaBand::_isUIDisabled()
{
    if (_apContentProxies == NULL)
        return FALSE;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            BOOL fQueryDisabled = FALSE;
            pProxy->IsDisableUIRequested(&fQueryDisabled);
            if (fQueryDisabled)
            {
                fDisabled = TRUE;
                break;
            }
        }
    }
    return fDisabled;
}

//------------------------------------------------------------------------
BOOL CMediaBand::_isProxiesNextEnabled()
{
    if (_apContentProxies == NULL)
        return TRUE;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fEnabled = TRUE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            BOOL fQueryEnabled = FALSE;
            pProxy->IsNextEnabled(&fQueryEnabled);
            if (!fQueryEnabled)
            {
                fEnabled = FALSE;
                break;
            }
        }
    }
    return fEnabled;
}


//------------------------------------------------------------------------
void CMediaBand::_OnUserOverrideDisableUI()
{
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        CComQIPtr<IMediaBehaviorContentProxy, &IID_IMediaBehaviorContentProxy> pProxy = _apContentProxies.GetPtr(i);
        if (pProxy)
        {
            pProxy->OnUserOverrideDisableUI();
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_FireEventToProxies(enum contentProxyEvent event)
{
    if (_apContentProxies == NULL)
        return;

    int cnt = _apContentProxies.GetPtrCount();
    BOOL fDisabled = FALSE;
    for (int i = 0; i < cnt; i++)
    {
        IContentProxy* pProxy = _apContentProxies.GetPtr(i);
        ASSERT(pProxy);
        if (pProxy)
        {
            pProxy->fireEvent(event);
        }
    }
}

//------------------------------------------------------------------------
void CMediaBand::_CleanupStopTimer()
{
    if (_idStopTimer != 0)
    {
        KillTimer(_hwnd, _idStopTimer);
        _idStopTimer = 0;
        // make sure user hasn't initiated another media action yet!!!
        SetPlayerControl(FCIDM_MEDIABAND_STOP, FALSE);
    }
}

//------------------------------------------------------------------------
HRESULT CMediaBand::_EnsureWMPInstalled(BOOL fShowErrorMsg)
{
    HRESULT hr = S_OK;
    if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
    {
        // ISSUE: assumption that XP already has matching WMP version
        if (!IsOS(OS_WHISTLERORGREATER))
        {
            // try to web-jit WMP8. 
            uCLSSPEC ucs;
            QUERYCONTEXT qc = { 0 };

            ucs.tyspec = TYSPEC_CLSID;
            ucs.tagged_union.clsid = CLSID_JITWMP8;

            hr = FaultInIEFeature(_hwnd, &ucs, &qc, FIEF_FLAG_FORCE_JITUI);
        }
        if (!CMediaBarUtil::IsWMP7OrGreaterInstalled())
        {
            // still no WMP, user might have aborted or install failed
            if (fShowErrorMsg)
            {
                MLShellMessageBox(_hwnd, MAKEINTRESOURCE(IDS_MEDIABAND_NOWMP7), MAKEINTRESOURCE(IDS_MEDIABAND_NOWMP7TITLE), MB_OK);
            }
            hr = E_UNEXPECTED;
        }
    }
    return hr;
}



// *** IBrowserBand methods ***
STDMETHODIMP CMediaBand::GetObjectBB(REFIID riid, LPVOID *ppv)
{
    return _spBrowser ? _spBrowser->QueryInterface(riid, ppv) : E_UNEXPECTED;
}

// *** IBandNavigate methods ***
STDMETHODIMP CMediaBand::Select(LPCITEMIDLIST pidl)
{
    _strDeferredURL.Empty();    // cancel any deferred navigation (usually during initial launch of mediabar
    return NavigateContentPane(pidl);
}

HRESULT CMediaBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CMediaBand * pmb = new CMediaBand();

    if (!pmb)
        return E_OUTOFMEMORY;

    // if you change this cast, fix up CChannelBand_CreateInstance
    *ppunk = SAFECAST(pmb, IDeskBand *);

    return S_OK;
}

//+-------------------------------------------------------------------------
// Creates Player
//--------------------------------------------------------------------------
BOOL
CMediaBand::EnsurePlayer()
{
    BOOL fResult = _pMediaPlayer ? TRUE : FALSE;
    if (!fResult)
    {
        fResult = CreatePlayer();
    }
    return fResult && _pMediaPlayer;
}


BOOL  
CMediaBand::CreatePlayer()
{
    HRESULT hr = CMediaBarPlayer_CreateInstance(IID_PPV_ARG(IMediaBarPlayer, &_pMediaPlayer));
    if (SUCCEEDED(hr))
    {
        hr = _pMediaPlayer->Init(_hwndLayout, SAFECAST(this, IMediaBar*));
        if (SUCCEEDED(hr))
        {
            hr = _pMediaPlayer->GetVideoHwnd(&_hwndVideo);
        }
        if (FAILED(hr))
        {
            ASSERT(FALSE);
            DestroyPlayer();
        }
    }
    return SUCCEEDED(hr);
}

VOID CMediaBand::DestroyPlayer()
{
    _AttachPlayerToProxies(FALSE);
    if (_pMediaPlayer)
    {
        _pMediaPlayer->DeInit();
        _pMediaPlayer->Release();
        _pMediaPlayer = NULL;
    }
    _DetachProxies();
 }

// notifications from the player

STDMETHODIMP CMediaBand::Notify(long lReason)
{
    HRESULT hr = E_FAIL;
    
    if (EnsurePlayer())
    {
        // update play/pause state
        TogglePlayPause();
        if (!_fAttached) {
            _AttachPlayerToProxies(TRUE);
        }

        switch (lReason)
        {
        case DISPID_TIMESTATE_PROGRESS:
            {
                double dblProgress = _pMediaPlayer->GetTrackProgress();
                if (!_fSeeking)
                {
                    SetSeekPos(static_cast<float>(dblProgress));
                }
                
                // Update download/buffering progress, if any
                {
                    ProgressType ProgType = PT_None;
                    double dblBufProg = 0.0;
                    hr = _pMediaPlayer->GetBufProgress(&dblBufProg, &ProgType);
                    
                    // S_OK only means that there's some buffering going on
                    if ((hr == S_OK) && dblBufProg >= 0.0 && dblBufProg < 100.0)
                    {
                        SetStatusText(_szConnecting);
                    }
                    else
                    {
                        ShowPlayingStatus();
                    }
                    
                    if (TRUE == _pMediaPlayer->IsStreaming())
                    {
                        // if this is streamed then substitute progress with track time
                        // since progress is not meaningful
                        dblProgress = _pMediaPlayer->GetTrackTime();
                        _UpdateTimeOutCounter(dblBufProg, dblProgress);
                    }
                    else
                    {
                        _UpdateTimeOutCounter(dblBufProg, dblProgress);
                    }
                }
            } 
            break; // case DISPID_TIMESTATE_PROGRESS
            
        case MEDIACOMPLETE:
        case TRACK_CHANGE:
            _fPlaying = TRUE;
            ShowPlayingStatus(TRUE);
            AdjustVideoHeight(TRUE);
            _EndTimeOutCounter();
            SetPlayPause(_pMediaPlayer->IsPausePossible());
            UpdateBackForwardControls();
            if (ISVALIDWIDGET(_pmwSeek))
            {
                _pmwSeek->SetState(_pMediaPlayer->IsSeekPossible());
            }
            break;
            
        case MEDIA_TRACK_FINISHED:
            if (_iCurTrack != -1)
            {
                PlayNextTrack();
            }
            else
            {
                _fSeeking = FALSE;
                ResetPlayer();
            }
            break;
            
        case DISPID_TIMEMEDIAELEMENT_TITLE:
            _OnTitleChange();
            ShowPlayingStatus(TRUE);
            break;
        } // switch (lReason)
        hr = S_OK;
    } // end if
    
    return hr;
}

STDMETHODIMP CMediaBand::OnMediaError(int iErrCode)
{
    _EndTimeOutCounter();

    if (-1 == iErrCode)
    {
        // if there is no rich erro info display the generic error message
        TCHAR szText[MAX_PATH];
        szText[0] = TEXT('\0');
        MLLoadString(IDS_MEDIABAND_INVALIDFILE, szText, ARRAYSIZE(szText));
        SetStatusText(szText);
    }
    else
    {
        // ISSUE: to do: display the appropriate error message
        ASSERT(FALSE);
    }

#ifdef PLAY_INDEFAULT
    // delegate the playback to the default player (fix for 24146)
    {
        //
        // ISSUE: What should we do for errors within a playlist??????
        //

        CComBSTR sbstrUrl;
        if (EnsurePlayer() && SUCCEEDED(_pMediaPlayer->get_url(&sbstrUrl)) && (NULL != sbstrUrl.m_str))
        {
            _OpenInDefaultPlayer(sbstrUrl);
        }
    }
#endif

    return S_OK;
}

//+-------------------------------------------------------------------------
// Handler for property change notification
//--------------------------------------------------------------------------
void CMediaBand::_OnTitleChange()
{
    // The status text and playlist menu should be updated here
}

//+-------------------------------------------------------------------------
// Resize the video
//--------------------------------------------------------------------------
void CMediaBand::_ResizeVideo(LONG* plWidth, LONG* plHeight)
{
    if (EnsurePlayer() && _hwndVideo && ::IsWindow(_hwndVideo))
    {
        _pMediaPlayer->Resize(plHeight, plWidth, FALSE); 
    }
}

//+-------------------------------------------------------------------------
// Redraw/show/hide the video window only if something has changed
//--------------------------------------------------------------------------
VOID
CMediaBand::AdjustVideoHeight(BOOL fForceResize)
{
    VARIANT_BOOL vbHasVisual = VARIANT_FALSE;
    
    CComPtr<ITIMEMediaElement> spMediaElem;
    if (_pMediaPlayer && SUCCEEDED(_pMediaPlayer->get_mediaElement(&spMediaElem)))
    {    
        //  Show/hide the video display window
        if (SUCCEEDED(spMediaElem->get_hasVisual(&vbHasVisual)))
        {
            BOOL fVideo = (VARIANT_TRUE == vbHasVisual ? TRUE : FALSE) && _fPlaying;

            if (fVideo)
            {
                if (!IsWindowVisible(_hwndVideo) && !_fIsVideo)
                {                    
                    ShowWindow(_hwndVideo, SW_SHOW);
                    _fVideoAdjust = TRUE;
                    _fIsVideo = TRUE;
                }
            }
            else
            {
                if (IsWindowVisible(_hwndVideo) && _fIsVideo)
                {
                    _fVideoAdjust = TRUE;
                    ShowWindow(_hwndVideo, SW_HIDE);
                    _fIsVideo = FALSE;
                }
            }

            if (!_fVideoAdjust && fForceResize)
            {
                _fVideoAdjust = TRUE;
            }

            // redraw only if something has changed, so that this function can be called very often
            // (e.g. from Notify) without causing excessive drawing. 
            if (_fVideoAdjust)
            {
                _fVideoAdjust = FALSE;
                if (_hwndPopup && IsWindowVisible(_hwndPopup))
                {
                    LONG lHeight = GetPopoutHeight(TRUE, _sizeVideo.cx);
                    
                    SetWindowPos(_hwndPopup, HWND_TOPMOST, 0, 0, _sizeLayout.cx, 
                                 lHeight, SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE);

                    InvalidateRect(_hwndPopup, NULL, TRUE);
                    
                    ShowWindow(_hwndPopup, SW_SHOW);
                    UpdateWindow(_hwndPopup);
                }
                else
                {
                    RECT rcParent;
                    GetClientRect(_hwnd, &rcParent);
                    LONG lHeight = RECTHEIGHT(rcParent);

                    lHeight = GetLayoutHeight();
                    AdjustLayout(RECTWIDTH(rcParent), lHeight);
                    SendMessage(_hwnd, WM_SIZE, (WPARAM)0, (LPARAM) MAKELONG(RECTWIDTH(rcParent), lHeight));
                }   
            }
        }
    }
}


VOID
CMediaBand::AdjustLayout(LONG_PTR lWidth, LONG_PTR lHeight)
{
    RECT rcClient;

    if (!(_hwndPopup && IsWindowVisible(_hwndPopup)))
    {
        GetClientRect(_hwnd, &rcClient);

        if (lWidth<=MIN_WINDOW_WIDTH)
        {
          if (RECTWIDTH(rcClient) < MIN_WINDOW_WIDTH)
             lWidth = MIN_WINDOW_WIDTH ;
          else
             lWidth = RECTWIDTH(rcClient);
        }

        if (lHeight<=MIN_WINDOW_HEIGHT)
        {
            if (RECTHEIGHT(rcClient) < MIN_WINDOW_HEIGHT)
               lHeight = MIN_WINDOW_HEIGHT ;
            else
               lHeight  = RECTHEIGHT(rcClient);
        }
    }
    _ResizeChildWindows(_hwndLayout, (LONG)lWidth, (LONG)lHeight, TRUE);
}

// IServiceProvider implementation
HRESULT CMediaBand::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    HRESULT hr = E_UNEXPECTED;

    if (IsEqualIID(guidService, SID_SMediaBar))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMediaBarSync))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualGUID(guidService, SID_STimeContent))
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = SUPERCLASS::QueryService(guidService, riid, ppvObj);
    }
    return hr;
}

STDMETHODIMP
CMediaBand::_TogglePause()
{
    HRESULT hr = E_FAIL;

    if (EnsurePlayer())
    {
        if (VARIANT_TRUE == _pMediaPlayer->isPaused())
        {
            _fUserPaused = FALSE;
            if (SUCCEEDED(_pMediaPlayer->Resume()))
            {
                _BeginTimeOutCounter();
                hr = S_OK;
            }
        }
        else
        {
            _fUserPaused = TRUE;
            hr = _pMediaPlayer->Pause();
            if (SUCCEEDED(hr))
            {
                _EndTimeOutCounter();
                hr = S_OK;
            }
        }

        TogglePlayPause();
    }
    return hr;
}      

//+-------------------------------------------------------------------------
// Creates and shows buttons
//--------------------------------------------------------------------------
HRESULT 
CMediaBand::CreateControls()
{
    // _pmwPlay
    _pmw[MW_PLAY] = CMediaWidgetButton_CreateInstance(_hwndLayout, 31, 33, FCIDM_MEDIABAND_PLAY, IDB_MEDIABAND_PLAY, IDB_MEDIABAND_PAUSE, IDS_MEDIABAND_PLAY, IDS_MEDIABAND_PAUSE);
    // _pmwStop
    _pmw[MW_STOP] = CMediaWidgetButton_CreateInstance(_hwndLayout, 18, 33, FCIDM_MEDIABAND_STOP, IDB_MEDIABAND_STOP, 0, IDS_MEDIABAND_STOP);
    // _pmwBack
    _pmw[MW_BACK] = CMediaWidgetButton_CreateInstance(_hwndLayout, 22, 16, FCIDM_MEDIABAND_PREVIOUS, IDB_MEDIABAND_BACK, 0, IDS_MEDIABAND_BACK);
    // _pmwNext
    _pmw[MW_NEXT] = CMediaWidgetButton_CreateInstance(_hwndLayout, 22, 16, FCIDM_MEDIABAND_NEXT, IDB_MEDIABAND_NEXT, 0, IDS_MEDIABAND_NEXT);

    _pmw[MW_MUTE] = new CMediaWidgetToggle(_hwndLayout, 22, 16);
    if (_pmwMute)
    {
        HRESULT hr = _pmwMute->Initialize(FCIDM_MEDIABAND_MUTE, IDS_MEDIABAND_UNMUTE, IDS_MEDIABAND_MUTE);
        if (SUCCEEDED(hr))
        {
            hr = _pmwMute->SetImageList(IDB_MEDIABAND_MUTE);
        }
        if (SUCCEEDED(hr))
        {
            hr = _pmwMute->SetAlternateImageList(IDB_MEDIABAND_MUTE);
        }
        _pmwMute->SetState(FALSE);
        if (FAILED(hr))
        {
            delete _pmwMute;
            _pmw[MW_MUTE] = NULL;
        }
    }

    _pmw[MW_OPTIONS] = new CMediaWidgetOptions(_hwndLayout, 16, 16);
    if (_pmwOptions)
    {
        HRESULT hr = _pmwOptions->Initialize(FCIDM_MEDIABAND_MUTE, IDS_MEDIABAND_UNMUTE, IDS_MEDIABAND_MUTE);
        if (FAILED(hr))
        {
            delete _pmwOptions;
            _pmw[MW_OPTIONS] = NULL;
        }
    }

    // _pmwPop
    _pmw[MW_POP] = CMediaWidgetButton_CreateInstance(_hwndLayout, 19, 20, FCIDM_MEDIABAND_POPOUT, IDB_MEDIABAND_POPOUT, IDB_MEDIABAND_POPIN, IDS_MEDIABAND_UNDOCK, IDS_MEDIABAND_DOCK);
    return S_OK;
}


HRESULT
CMediaBand::CreateSeekBar()
{
    DWORD dwWindowStyles = WS_TABSTOP | WS_VISIBLE | WS_CHILD | TBS_NOTICKS | TBS_FIXEDLENGTH; 
    DWORD dwExStyle      = WS_EX_TRANSPARENT;

    _hwndSeek = CreateWindowEx(dwExStyle, TRACKBAR_CLASS, NULL, dwWindowStyles,
                                0, 0, 0, 0, _hwndLayout, (HMENU) FCIDM_MEDIABAND_SEEK, HINST_THISDLL, NULL);

    if (_hwndSeek)
    {
        if (SetProp(_hwndSeek, c_szMediaBandProp, this))
        {
            SetWindowLongPtr(_hwndSeek, GWLP_USERDATA, (LPARAM)(WNDPROC)(GetWindowLongPtr(_hwndSeek, GWLP_WNDPROC)));
            SetWindowLongPtr(_hwndSeek, GWLP_WNDPROC,  (LPARAM)s_SeekWndSubClassProc);
        }
        SendMessage(_hwndSeek, TBM_SETRANGE, (WPARAM)TRUE , (LPARAM)MAKELONG(0, 100));  // min. & max. positions 
        SendMessage(_hwndSeek, TBM_SETPAGESIZE, 0, (LPARAM)4);                  // new page size 
        SendMessage(_hwndSeek, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)0); 

        // ISSUE: For some reason, the length of the trackbar slider is screwed up, and the rect returned by the slider is half the actual width
        SendMessage(_hwndSeek, TBM_SETTHUMBLENGTH, (WPARAM)VOLUME_GRIPPER_LENGTH*2, 0);
        _himlSeekBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_SEEKBACK), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlSeekFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_SEEKFILL), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _pmw[MW_SEEK] = new CMediaWidgetSeek();
        if (_pmwSeek)
        {
            _pmwSeek->Initialize(_hwndSeek);
        }
        Comctl32_SetDPIScale(_hwndSeek);
        ShowWindow(_hwndSeek, SW_SHOW);

        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CMediaBand::CreateVolumeControl()
{
    DWORD dwWindowStyles = WS_TABSTOP | WS_VISIBLE | WS_CHILD | TBS_NOTICKS | TBS_TOOLTIPS;
    DWORD dwExStyle       = WS_EX_TRANSPARENT;

    _hwndVolume = CreateWindowEx(dwExStyle, TRACKBAR_CLASS, NULL, dwWindowStyles,
                                0, 0, 0, 0, _hwndLayout, (HMENU) FCIDM_MEDIABAND_VOLUME, HINST_THISDLL, NULL);

    if (_hwndVolume)
    {
        if (SetProp(_hwndVolume, c_szMediaBandProp, this))
        {
            SetWindowLongPtr(_hwndVolume, GWLP_USERDATA, (LPARAM)(WNDPROC)(GetWindowLongPtr(_hwndVolume, GWLP_WNDPROC)));
            SetWindowLongPtr(_hwndVolume, GWLP_WNDPROC,  (LPARAM)s_VolumeWndSubClassProc);
        }

        SendMessage(_hwndVolume, TBM_SETRANGE, (WPARAM)TRUE , (LPARAM)MAKELONG(0, 100));  // min. & max. positions 
        SendMessage(_hwndVolume, TBM_SETPAGESIZE, 0, (LPARAM) 4);                  // new page size 
        SendMessage(_hwndVolume, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)50); 

        ShowWindow(_hwndVolume, SW_SHOW);

        _himlVolumeBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLBKGND), VOLUME_BITMAP_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlVolumeFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLFILL), VOLUME_BITMAP_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
        _himlGripper = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_VOLTAB), VOLUME_GRIPPER_LENGTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);

        _pmw[MW_VOLUME] = new CMediaWidgetVolume;
        if (_pmwVolume)
        {
            _pmwVolume->Initialize(_hwndVolume);
        }
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT
CMediaBand::CreateLayoutPane()
{
    if (!_hwndLayout)
    {
        WNDCLASS wndclass    = { 0 };
        wndclass.style         = CS_PARENTDC; // | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_LayoutWndProc;
        wndclass.hInstance     = MLGetHinst();
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = c_szMediaBarLayoutClassName;

        SHRegisterClass(&wndclass);

        _hwndLayout = CreateWindowEx(WS_EX_CONTROLPARENT, c_szMediaBarLayoutClassName, NULL, 
                               WS_TABSTOP | WS_VISIBLE | WS_CHILD, 
                               CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT, _hwnd, NULL, MLGetHinst(), (void *)this);


        if (_hwndLayout == NULL)
        {
            ASSERT(FALSE);
            return E_FAIL;        
        }
        else
        {
          ::ShowWindow(_hwndLayout, SW_SHOW);
        }
    }

    return S_OK;
}

#define BACKGROUND_WIDTH    (240/3)
#define BACKGROUND_TOP  12
#define BACKGROUND_MIDDLE 2
#define BACKGROUND_BOTTOM 55

VOID CMediaBand::DrawBackground(HDC hdc, HWND hwnd)
{
    if (_fHiColour)
    {
        HDC hdcSrc = CreateCompatibleDC(hdc);
        if (hdcSrc)
        {
            if (_hbmpBackground)
            {
                RECT rc;
                if (GetClientRect(hwnd, &rc))
                {
                    SelectObject(hdcSrc, _hbmpBackground);

                    UINT xTra = 0;

                    if (g_bRunOnMemphis && IS_WINDOW_RTL_MIRRORED(_hwnd))
                    {
                        rc.right++;
                        xTra++;
                    }

                    // We have 9 regions to paint. First we'll bitblt the corners, and then we'll do middle sections, which can be stretched without
                    // loss of fidelity in a given direction.
                    // |A|B|C|
                    // |D|E|F|
                    // |G|H|I|

                    // Corners are bitblted
                    // A
                    BitBlt(hdc, rc.left, rc.top, BACKGROUND_WIDTH, BACKGROUND_TOP, hdcSrc, 0, 0, SRCCOPY);
                    // C
                    BitBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), rc.top, BACKGROUND_WIDTH, BACKGROUND_TOP, hdcSrc, 2*BACKGROUND_WIDTH, 0, SRCCOPY);
                    // G
                    BitBlt(hdc, rc.left, max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), BACKGROUND_WIDTH, BACKGROUND_BOTTOM, hdcSrc, 0, BACKGROUND_TOP+BACKGROUND_MIDDLE, SRCCOPY);
                    // I
                    BitBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), BACKGROUND_WIDTH*2, BACKGROUND_BOTTOM, hdcSrc, BACKGROUND_WIDTH*2, BACKGROUND_TOP+BACKGROUND_MIDDLE, SRCCOPY);

                    // Middles are all repeated/stetched
                    if (rc.right-BACKGROUND_WIDTH > rc.left+BACKGROUND_WIDTH)
                    {
                        // B
                        StretchBlt(hdc, rc.left+BACKGROUND_WIDTH, rc.top, RECTWIDTH(rc)-2*BACKGROUND_WIDTH+xTra, BACKGROUND_TOP, hdcSrc, BACKGROUND_WIDTH, 0, BACKGROUND_WIDTH, BACKGROUND_TOP, SRCCOPY);
                        // H
                        StretchBlt(hdc, rc.left+BACKGROUND_WIDTH, max(rc.bottom-BACKGROUND_BOTTOM, rc.top+BACKGROUND_TOP), RECTWIDTH(rc)-2*BACKGROUND_WIDTH+xTra, BACKGROUND_BOTTOM, hdcSrc, BACKGROUND_WIDTH, BACKGROUND_TOP+BACKGROUND_MIDDLE, BACKGROUND_WIDTH, BACKGROUND_BOTTOM, SRCCOPY);
                    }

                    if (rc.bottom-BACKGROUND_BOTTOM > rc.top+BACKGROUND_TOP)
                    {
                        // D
                        StretchBlt(hdc, rc.left, rc.top+BACKGROUND_TOP, BACKGROUND_WIDTH, RECTHEIGHT(rc)-BACKGROUND_TOP-BACKGROUND_BOTTOM, 
                                 hdcSrc, 0, BACKGROUND_TOP, BACKGROUND_WIDTH, BACKGROUND_MIDDLE, SRCCOPY);
                        // F
                        StretchBlt(hdc, max(rc.right-BACKGROUND_WIDTH, rc.left+BACKGROUND_WIDTH), rc.top+BACKGROUND_TOP, BACKGROUND_WIDTH, RECTHEIGHT(rc)-BACKGROUND_TOP-BACKGROUND_BOTTOM, 
                                 hdcSrc, BACKGROUND_WIDTH*2, BACKGROUND_TOP, BACKGROUND_WIDTH, BACKGROUND_MIDDLE, SRCCOPY);
                        // E
                        // This section is one solid colour.
                        if (rc.right-BACKGROUND_WIDTH > rc.left+BACKGROUND_WIDTH)
                        {
                            RECT rc2;
                            rc2.left = rc.left+BACKGROUND_WIDTH;
                            rc2.right = rc.right-BACKGROUND_WIDTH;
                            rc2.top = rc.top+BACKGROUND_TOP;
                            rc2.bottom = rc.bottom-BACKGROUND_BOTTOM;
                            SHFillRectClr(hdc, &rc2, COLOR_BKGNDMIDDLE);
                        }
                    }
                }
            }
            DeleteDC(hdcSrc);
        }
    }
    else
    {
        RECT rc;
        if (GetClientRect(hwnd, &rc))
        {
            SHFillRectClr(hdc, &rc, COLOR_BKGND16);
        }
    }

    if (_hwndVideo && IsWindowVisible(_hwndVideo))
    {
        RedrawWindow(_hwndVideo, NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE);
    }
}


// WndProc for main window to go in rebar
LRESULT CALLBACK CMediaBand::s_LayoutWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    if (msg==WM_CREATE)
    {
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
        return 0;
    }
    else if (pmb)
    {
        switch (msg)
        {
        case WM_PAINT:
        {
            break;
        }

        case WM_ERASEBKGND:
            pmb->DrawBackground((HDC)wParam, hWnd);
            return TRUE;

        case WM_SIZE:
            if ((LONG)LOWORD(lParam) <= 0 || (LONG)HIWORD(lParam) <= 0 )
                break;

            pmb->AdjustLayout(LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
            {
            BOOL fNewColours = (SHGetCurColorRes() > 8);
            if (fNewColours!=pmb->_fHiColour)
            {
                pmb->SwitchBitmaps(fNewColours);
            }
            pmb->AdjustVideoHeight(TRUE);
            }
            break;

        case WM_VSCROLL:
        case WM_HSCROLL:
            if ((HWND)lParam == pmb->_hwndSeek)
            {
                SendMessage(pmb->_hwndSeek, msg, wParam, lParam);
            }
            else if ((HWND)lParam == pmb->_hwndVolume)
            {
                SendMessage(pmb->_hwndVolume, msg, wParam, lParam);
            }
            break;

        case WM_NOTIFY:
        {
            LRESULT lres;
            if (pmb->OnNotify((LPNMHDR)lParam, &lres))
            {
                return lres;
            }
            break;
        }
        break;

        case WM_COMMAND:
        {
            LRESULT lres;
            if (pmb->OnWinEvent(hWnd, msg, wParam, lParam, &lres) == S_OK)
                return lres;
        }
        break;
        }
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}


HRESULT CMediaBand::CreateParentPane()
{
    if (!_hwnd)
    {
        WNDCLASS wndclass    = { 0 };
        wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_WndProc;
        wndclass.hInstance     = MLGetHinst();
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = c_szMediaBarClassName;

        SHRegisterClass(&wndclass);
        
        _hwnd = CreateWindowEx(WS_EX_CONTROLPARENT, c_szMediaBarClassName, NULL, 
            WS_TABSTOP | WS_VISIBLE | WS_CHILD, 
            CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
            _hwndParent, NULL, MLGetHinst(), (void *)this);
        
        if (_hwnd == NULL)
        {
            ASSERT(FALSE);
            return E_FAIL;        
        }
        else
        {
            ::ShowWindow(_hwnd, SW_SHOW);
        }
    }
    return S_OK;
}


VOID CMediaBand::Resize(HWND hwnd, LONG lWidth, LONG lHeight)
{
    if (lWidth <= 0 || lHeight <= 0)
        return;
    
    RECT rcParent; 
    if (GetClientRect(_hwnd, &rcParent))
    {
        if (IsWindowVisible(_hwndPopup))
        {
            MoveWindow(_hwndContent, rcParent.left, rcParent.top, RECTWIDTH(rcParent), RECTHEIGHT(rcParent), FALSE);
        }
        else 
        {
            LONG lPaneHeight = GetLayoutHeight();
            MoveWindow(_hwndLayout, rcParent.left, rcParent.bottom-lPaneHeight, lWidth, lPaneHeight, FALSE);
            MoveWindow(_hwndContent, rcParent.left, rcParent.top, lWidth, RECTHEIGHT(rcParent)-lPaneHeight, FALSE);
            InvalidateRect(hwnd, NULL, TRUE);
            UpdateWindow(hwnd);
        }
    }
}



// WndProc for main window to go in rebar
LRESULT CALLBACK CMediaBand::s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    switch (msg)
    {
        case WM_ERASEBKGND:
            break;

        case WM_CREATE:
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
            return 0;

        case WM_SIZE:
            if (pmb)
            {
                pmb->Resize(hWnd, (LONG)LOWORD(lParam), (LONG)HIWORD(lParam));
            }                
            break;

        case WM_MB_DEFERRED_NAVIGATE:
            // navigation cancelled by IBandNavigate::ISelect() call
            if (pmb && (pmb->_strDeferredURL.Length() > 0))
            {
                pmb->NavigateContentPane(pmb->_strDeferredURL);
                pmb->_strDeferredURL.Empty();
            }
            break;

        case WM_NOTIFY:
            if (pmb)
            {
                return pmb->_OnNotify((LPNMHDR)lParam);
            }
            break;

        case WM_COMMAND:
        {
            LRESULT lres;
            if (pmb->OnWinEvent(hWnd, msg, wParam, lParam, &lres) == S_OK)
                return lres;
        }

        case WM_TIMER:
            // timeout of user's second chance to click stop again and navigate to media content pane to default URL
            if (pmb)
            {
                pmb->_CleanupStopTimer();
            }
            break;

        case WM_WTSSESSION_CHANGE:
            // stop playing media when media bar is no more in current terminal server session
            // this avoids "background noise" when user does fast user switching to other login in XP
            // NOTE: logging on as same user remotely will also stop stream
            if (pmb && ((wParam == WTS_CONSOLE_DISCONNECT) || (wParam == WTS_REMOTE_DISCONNECT)))
            {
                pmb->Exec(&CLSID_MediaBand, FCIDM_MEDIABAND_STOP, 0, NULL, NULL);
            }
            break;

        break;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

INT_PTR CALLBACK CMediaBand::s_PopupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = reinterpret_cast<CMediaBand *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
        case WM_CREATE:
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) ((LPCREATESTRUCT)lParam)->lpCreateParams);
            break;

        case WM_ACTIVATE:
            if (pmb)
            {
                pmb->ActivatePopout(LOWORD(wParam)!=WA_INACTIVE);
            }
            return 0;

        case WM_KEYDOWN:
            if (wParam==VK_ESCAPE)
            {
                pmb->DockMediaPlayer();
            }
            break;

        case WM_GETMINMAXINFO:  // prevent it from getting too small or too large
            if (pmb)
            {
                pmb->ComputeMinMax((MINMAXINFO *)lParam);
            }
            break;

        case WM_SIZE:
            if (pmb && IsWindowVisible(hwnd))
            {
               SetWindowPos(pmb->_hwndLayout, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOACTIVATE);
               // MoveWindow(pmb->_hwndLayout, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            }
            break;

        case WM_SYSCOMMAND :
            if (wParam == SC_CLOSE)
                pmb->DockMediaPlayer();
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID CMediaBand::ActivatePopout(BOOL fState)
{
    _fPopoutHasFocus = fState;
    UIActivateIO(fState, NULL);
}

VOID CMediaBand::ComputeMinMax(MINMAXINFO *pMinMax)
{
    pMinMax->ptMinTrackSize.x = GetMinPopoutWidth();
    if (_fIsVideo)
    {
        pMinMax->ptMinTrackSize.y = GetPopoutHeight(FALSE) + VIDEO_MIN_HEIGHT;
    }
    else
    {
        pMinMax->ptMaxTrackSize.y = pMinMax->ptMinTrackSize.y = GetPopoutHeight(FALSE);
    }
}


LRESULT CALLBACK CMediaBand::s_VolumeWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = (CMediaBand*)GetProp(hwnd, c_szMediaBandProp);

    if (!pmb)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldWndProc = (WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
        case WM_HSCROLL:
        case WM_VSCROLL:
        {
             INT_PTR lPos = SendMessage(hwnd, TBM_GETPOS, (WPARAM) 0 ,(LPARAM) 0); 

             switch (LOWORD(wParam))
             {
                case TB_THUMBPOSITION:
                case TB_THUMBTRACK:
                {   
                    if (pmb != NULL)
                    {
                        pmb->_dblVol = (double)lPos;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(pmb->_dblVol);
                        }
                    }
                    InvalidateRect(hwnd,NULL,TRUE);
                    UpdateWindow(hwnd);
                }
                break ;

                case TB_TOP:
                {
                    if (pmb)
                    {
                        pmb->_dblVol = 0;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(0);
                        }
                    }
                }
                break;

                case TB_BOTTOM:
                {
                    if (pmb)
                    {
                        pmb->_dblVol = 100;
                        if (pmb->_pMediaPlayer)
                        {
                            pmb->_pMediaPlayer->put_volume(100);
                        }
                    }
                }
                break;
            }    
        }
        break;
        
        case WM_DESTROY:
        {
            //
            // Unsubclass myself.
            //
            RemoveProp(hwnd, c_szMediaBandProp);
            if (pfnOldWndProc)
            {
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            }
        }
        break;
    }
    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}


LRESULT CALLBACK CMediaBand::s_SeekWndSubClassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMediaBand* pmb = (CMediaBand*)GetProp(hwnd, c_szMediaBandProp);
    
    if (!pmb)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    
    WNDPROC pfnOldWndProc = (WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        break;
        
    case WM_HSCROLL:
        {
            if (pmb && pmb->_pMediaPlayer && pmb->_fPlaying)
            {
                if (pmb->_pMediaPlayer->IsSeekPossible() && !pmb->_isUIDisabled())
                {
                    INT_PTR lPos = SendMessage(hwnd, TBM_GETPOS, (WPARAM) 0 ,(LPARAM) 0); 
                    switch (LOWORD(wParam))
                    {
                    case TB_THUMBPOSITION:
                        {
                            pmb->_fSeeking = FALSE;
                            pmb->Seek(lPos / 100.0);
                            if (!pmb->_fUserPaused)
                            {
                                pmb->_pMediaPlayer->Resume();
                            }
                        }
                        break;
                        
                    case TB_THUMBTRACK:
                        {   
                            pmb->_fSeeking = TRUE;
                            if (!pmb->_fUserPaused)
                            {
                                pmb->_pMediaPlayer->Pause();
                            }
                            pmb->Seek(lPos / 100.0);
                            InvalidateRect(hwnd,NULL,TRUE);
                            UpdateWindow(hwnd);
                        }
                        break;
                        
                    case TB_PAGEUP:
                    case TB_TOP:
                        {
                            double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                            // seek backwards by 5%
                            pmb->Seek(dblProgress - 0.05);
                        }
                        break;
                        
                    case TB_PAGEDOWN:
                    case TB_BOTTOM:
                        {
                            double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                            // seek ahead by 5%
                            pmb->Seek(dblProgress + 0.05);
                        }
                        break;
                    }
                }
                else
                {
                    // disallow seeking by setting the seek position to what it was
                    double dblProgress = pmb->_pMediaPlayer->GetTrackProgress();
                    pmb->SetSeekPos(static_cast<float>(dblProgress));
                }
            }
        }
        break;
        
    case WM_DESTROY:
        {
            //
            // Unsubclass myself.
            //
            RemoveProp(hwnd, c_szMediaBandProp);
            if (pfnOldWndProc)
            {
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            }
        }
        break;
    }
    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}

// sends appropriate resize messages to our children windows
VOID 
CMediaBand::_ResizeChildWindows(HWND hwnd, LONG width, LONG height, BOOL fRepaint)
{
    // Calculate the display rectangle
    RECT rc;
    SIZE sizeTB = {0}, sizePopout = {0};
    LONG lHorzSpacing   = MIN_HORZ_SPACING;
    
    _sizeLayout.cx = width;
    _sizeLayout.cy = GetLayoutHeight();

    SetRect(&rc, 0, 0, width, height); 

    LONG lWidthOffset  = rc.left+lHorzSpacing; 

    HDWP hdwp = BeginDeferWindowPos(10);

    lWidthOffset  = rc.left+lHorzSpacing; 
    if (_fIsVideo && _hwndVideo)
    {
        LONG lWidth, lHeight, lVideoStart = 0;
        
        if (_hwndPopup && IsWindowVisible(_hwndPopup))
        {
            lWidth = width-rc.left-lHorzSpacing*2;
            lHeight = GetVideoHeight();
        }
        else
        {
            lWidth = SCALEX(MIN_WINDOW_WIDTH-rc.left-lHorzSpacing*2);
            lHeight = SCALEY(MIN_WINDOW_WIDTH-rc.left);
        }
        // Resize the video and try to get the video sizes
        _ResizeVideo(&lWidth,&lHeight);

        _sizeVideo.cx  = (LONG)lWidth ;
        _sizeVideo.cy  = (LONG)lHeight ;
        
        if (lWidth >= width-rc.left-lHorzSpacing*2)
            lVideoStart = rc.left + lHorzSpacing;
        else
            lVideoStart =  (width-rc.left-lHorzSpacing*2-lWidth)/2 + rc.left + lHorzSpacing ;        

        DeferWindowPos(hdwp, _hwndVideo, HWND_TOP, (LONG)lVideoStart, rc.top+VIEW_MARGIN_TOP_VIDEO, (LONG)lWidth, (LONG)lHeight, SWP_NOZORDER);
    }
    else
    {
        _sizeVideo.cx  = 0 ;
        _sizeVideo.cy  = 0;
    }

    // Bottom-most row

    LONG lHeightOffset = height - VIEW_MARGIN_BOTTOM;  
    lWidthOffset = rc.left + VIEW_MARGIN_LEFT;

    LONG lSeekY = lHeightOffset, lSeekX = 0;
    if (_pmwPlay && _pmwPlay->_hwnd)
    {
        GetToolbarSize(_pmwPlay->_hwnd, &sizeTB);
        lSeekY = lHeightOffset-sizeTB.cy;
        DeferWindowPos(hdwp, _pmwPlay->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }

    if (_pmwStop && _pmwStop->_hwnd)
    {
        GetToolbarSize(_pmwStop->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwStop->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }
    if (_pmwBack && _pmwBack->_hwnd)
    {
        GetToolbarSize(_pmwBack->_hwnd, &sizeTB);
        lSeekX = lWidthOffset;
        DeferWindowPos(hdwp, _pmwBack->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }
    if (_pmwNext && _pmwNext->_hwnd)
    {
        GetToolbarSize(_pmwNext->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwNext->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        lWidthOffset += sizeTB.cx;
    }

    if (_pmwMute && _pmwMute->_hwnd)
    {
        GetToolbarSize(_pmwMute->_hwnd, &sizeTB);
        LONG lVolumeWidth = SCALEX(MIN_VOLUME_WIDTH);
        lWidthOffset = max(lWidthOffset+lHorzSpacing, (width - sizeTB.cx - lVolumeWidth - VIEW_MARGIN_RIGHT));
        DeferWindowPos(hdwp, _pmwMute->_hwnd, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, sizeTB.cx, sizeTB.cy, SWP_NOZORDER);
        if (_hwndVolume)
        {
            lWidthOffset += sizeTB.cx;
            DeferWindowPos(hdwp, _hwndVolume, HWND_TOP, lWidthOffset, lHeightOffset-sizeTB.cy, lVolumeWidth, SCALEY(MIN_VOLUME_HEIGHT), SWP_NOZORDER);
        }
    }

    lWidthOffset = rc.left + lHorzSpacing;
    if (_hwndSeek)
    {
        LONG lSeekWidth = max(width-lHorzSpacing-lSeekX-2, 0);
        DeferWindowPos(hdwp, _hwndSeek, HWND_TOP, lSeekX+2, lSeekY, lSeekWidth, SCALEY(SEEK_HEIGHT), SWP_NOZORDER);
    }

    lWidthOffset = rc.left + VIEW_MARGIN_INFO_LEFT;
    if (ISVALIDWIDGET(_pmwPop))
    {
        GetToolbarSize(_pmwPop->_hwnd, &sizePopout);
        DeferWindowPos(hdwp, _pmwPop->_hwnd, HWND_TOP, width-sizePopout.cx-VIEW_MARGIN_INFO_LEFT, lSeekY-sizePopout.cy-VIEW_CONTROLS_MARGIN, sizePopout.cx, sizePopout.cy, SWP_NOZORDER);
    }

    if (ISVALIDWIDGET(_pmwOptions))
    {
        GetToolbarSize(_pmwOptions->_hwnd, &sizeTB);
        DeferWindowPos(hdwp, _pmwOptions->_hwnd, HWND_TOP, lWidthOffset, lSeekY-sizeTB.cy-VIEW_CONTROLS_MARGIN, width-lHorzSpacing*3-sizePopout.cx, sizeTB.cy, SWP_NOZORDER);
        _iOptionsWidth = width-lHorzSpacing*3-sizePopout.cx-10;
        SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth));
        SendMessage(_pmwOptions->_hwnd, TB_AUTOSIZE, 0, 0);
    }

    EndDeferWindowPos(hdwp);

    if (fRepaint)
    {
       InvalidateRect(hwnd, NULL, TRUE);
       UpdateWindow(hwnd);
    }
    else
    {
       InvalidateRect(hwnd, NULL, FALSE);
       UpdateWindow(hwnd);
    }
}

LONG CMediaBand::GetControlsHeight()
{
    LONG lHeightOffset = VIEW_MARGIN_TOP;
    // Compute height for options here
    if (ISVALIDWIDGET(_pmwOptions))
    {
        SIZE sizeTB = {0};
        GetToolbarSize(_pmwOptions->_hwnd, &sizeTB);
        lHeightOffset += SCALEY(sizeTB.cy) + VIEW_CONTROLS_MARGIN;
    }
    
    // Rest of controls
    lHeightOffset += VIEW_MARGIN_BOTTOM + SCALEY(VIEW_CONTROLS_HEIGHT);
    return lHeightOffset;
}

LONG CMediaBand::GetLayoutHeight(LONG lWidth)
{
    LONG lHeightOffset = GetControlsHeight();
    if (_hwndVideo && (IsWindowVisible(_hwndVideo) || _fIsVideo))
    {
        LONG lHeight = GetVideoHeight(lWidth);
        if (lHeight>0)
            lHeightOffset += lHeight + VIEW_MARGIN_TOP_VIDEO;
    }
    return lHeightOffset;
}

float 
CMediaBand::GetSeekPos()  
{ 
    INT_PTR lMax = SendMessage(_hwndSeek, TBM_GETRANGEMAX, 0, 0) ;
    INT_PTR lMin = SendMessage(_hwndSeek, TBM_GETRANGEMIN, 0, 0) ;
    INT_PTR lPos = SendMessage(_hwndSeek, TBM_GETPOS, 0, 0)  ;
    return ((float)lPos / (float)(lMax - lMin));
}
    
VOID 
CMediaBand::SetSeekPos(float fPosition)  
{ 
    INT_PTR lMax = SendMessage(_hwndSeek, TBM_GETRANGEMAX, 0, 0) ;
    INT_PTR lMin = SendMessage(_hwndSeek, TBM_GETRANGEMIN, 0, 0) ;
    fPosition *= (lMax - lMin) ;
    INT_PTR lPos = SendMessage(_hwndSeek, TBM_GETPOS, 0, 0)  ;
    if (lPos!=(LONG) fPosition)
    {
        SendMessage(_hwndSeek, TBM_SETPOS, TRUE, (LPARAM) (LONG) fPosition); 
        InvalidateRect(_hwndSeek, NULL,TRUE);
        UpdateWindow(_hwndSeek);
    }
}

HRESULT 
CMediaBand::_InitializeMediaUI()
{
    HRESULT hr = S_OK;

    _fHiColour = (SHGetCurColorRes() > 8);

    if (!_hwndLayout) 
    {
        CreateLayoutPane();
    }
    if (!_hwndContent)
    {
        InitContentPane();
    }

    if (!_fInitialized && _hwndLayout)
    {
        _szConnecting[0] = TEXT('\0');
        MLLoadString(IDS_MEDIABAND_NOWDOWNLOADING, _szConnecting, ARRAYSIZE(_szConnecting));

        _hbmpBackground = LoadBitmap(HINST_THISDLL, MAKEINTRESOURCE(IDB_MEDIABAND_BG_BASE));   

        CreateControls();
        CreateSeekBar();
        CreateVolumeControl();

        ResetPlayer();
        if (!_fHiColour)    
        {
            // Assume high colour. If not, switch to low colour versions.
            SwitchBitmaps(_fHiColour);
        }

        // want to sink notification when fast user switch occurs:
        WTSRegisterSessionNotification(_hwnd, NOTIFY_FOR_THIS_SESSION);

        _fInitialized = TRUE;
    }
    _ShowAllWindows(TRUE);

    return hr;
}

VOID
CMediaBand::_ShowAllWindows(BOOL fShow)
{
    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
//        SendMessage(_hwndPopup, WM_SYSCOMMAND, (WPARAM)SC_CLOSE, (LPARAM)0);
        return;
    }
    
    if (_hwndLayout)
        ShowWindow(_hwndLayout, fShow ? SW_SHOW : SW_HIDE);

    for (int i=0; i < ARRAYSIZE(_pmw); i++)
    {
        if (ISVALIDWIDGET(_pmw[i]))
           ShowWindow(_pmw[i]->_hwnd, fShow ? SW_SHOW : SW_HIDE);
    }
    if (_hwndContent)
    {
        ShowWindow(_hwndContent, fShow ? SW_SHOW : SW_HIDE);
    }
}

VOID
CMediaBand::ToggleMute()
{
    _fMuted = !_fMuted;
    if (_pmwMute)
    {
        _pmwMute->SetState(_fMuted);
    }
    if (_pMediaPlayer)
    {
        _pMediaPlayer->put_mute(_fMuted);
    }
}

VOID 
CMediaBand::TogglePlayPause()
{
    if (!EnsurePlayer())
    {
        return;
    }

    VARIANT_BOOL vbPaused = _pMediaPlayer->isPaused();
    VARIANT_BOOL vbStopped = _pMediaPlayer->isStopped();

    // if player is in paused state, show the play button and vice-versa

    // _fPlayButton==FALSE means that the pause button is currently displayed
    // _fPlayButton==TRUE means that the play button is currently displayed

    if (vbStopped || vbPaused)
    {
        if (!_fPlayButton)
        {
            _fPlayButton = TRUE;
            if (_pmwPlay)
            {
                _pmwPlay->SetMode(MWB_NORMAL);
                _pmwPlay->SetImageSource(TRUE);
            }
        }
    }
    else
    {
        if (_fPlayButton)
        {
            _fPlayButton = FALSE;

            if (_pMediaPlayer->IsPausePossible())
            {
                // ISSUE (akabir): The following line doesn't work correctly
                // _pmwPlay->SetMode(MWB_DISABLED);
            }

            // change button bitmaps
            if (_pmwPlay)
            {
                _pmwPlay->SetImageSource(FALSE);
            }
        }
    }
}

HWND
CMediaBand::GetBrowserWindow()
{
    CComPtr<IWebBrowser2> spWebBrowser;

    // QS for the browser main window
    if (SUCCEEDED(QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &spWebBrowser))))
    {
        LONG_PTR hwndApp;
        if (SUCCEEDED(spWebBrowser->get_HWND(&hwndApp)))
        {
            return ((HWND)hwndApp);
        }
    }
    return NULL;
}

// Called only by CMediaBand::CreateInstance
HRESULT 
CMediaBand::InitPlayerPopup()
{
    HRESULT hr = E_FAIL;

    WNDCLASS wndclass    = { 0 };
    wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc   = (WNDPROC)s_PopupDlgProc;
    wndclass.hInstance     = HINST_THISDLL;
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.lpszClassName = c_szMediaBarPopupClassName;
    wndclass.hIcon         = (HICON)LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDB_TB_MEDIA_HOT));
    wndclass.hbrBackground = NULL;
    
    SHRegisterClass(&wndclass);

    DWORD dwStyle   = (WS_OVERLAPPEDWINDOW & ~(WS_MINIMIZEBOX));
    DWORD dwExStyle =  WS_EX_CONTROLPARENT | (IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0);

    _hwndPopup = CreateWindowEx(dwExStyle, c_szMediaBarPopupClassName, NULL, dwStyle, 
                                CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT, 
                                GetBrowserWindow(), NULL, HINST_THISDLL, (void *)this);

    hr = (_hwndPopup && _hwndLayout) ? S_OK : E_FAIL;

    // modify the properties of the window as appropriate
    if (SUCCEEDED(hr))
    {
        // set parent
        SHSetParentHwnd(_hwndLayout, _hwndPopup);

        WCHAR szTitle[256];
        MLLoadStringW(IDS_MEDIABANDTEXT, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(_hwndPopup, szTitle);

        if (_sizeLayout.cx < GetMinPopoutWidth())
            _sizeLayout.cx = GetMinPopoutWidth();

        if (_fSavedPopoutState)
        {
            SetWindowPlacement(_hwndPopup, &_wpPopout);
        }
        else
        {
            RECT rc = { 0 };
            INT iHeight = GetPopoutHeight(TRUE, _sizeLayout.cx);
            INT x = 10, y = 10;
            if (GetWindowRect(_hwnd, &rc))
            {
                x = IS_WINDOW_RTL_MIRRORED(_hwnd) ? (rc.right - _sizeLayout.cx) : rc.left;
                y =  rc.bottom - iHeight;
                if (y < 0)
                {
                    y = rc.bottom;
                }
            }
            SetWindowPos(_hwndPopup, HWND_TOPMOST, x, y, _sizeLayout.cx, iHeight, SWP_FRAMECHANGED | SWP_SHOWWINDOW);
        }

        ShowWindow(_hwndPopup, SW_SHOW);
        UpdateWindow(_hwndPopup);

        if (_pmwPop && _pmwPop->_hwnd)
        {
            _pmwPop->SetImageSource(FALSE);          
            if (_iElement==MW_POP)
            {
                _fPopoutHasFocus = TRUE;
                UIActivateIO(TRUE, NULL);
            }
        }
    }
    return hr;
}

HRESULT
CMediaBand::GetTrackTitle(BSTR *pbstrTitle)
{
    USES_CONVERSION;

    CComPtr<ITIMEMediaElement> spMediaElem;
    HRESULT hr = E_FAIL;

    if (    !EnsurePlayer() 
        ||  !pbstrTitle)
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrTitle = NULL;

    //
    // if a title is available from the media element, display it
    //

    hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
    if (    FAILED(hr) 
        ||  !spMediaElem.p)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = spMediaElem->get_title(pbstrTitle);
    if (SUCCEEDED(hr) &&  (*pbstrTitle != NULL))
    {
        if (SysStringLen(*pbstrTitle)>0)
        {
            goto done;
        }
        else
        {
            SysFreeString(*pbstrTitle);
            *pbstrTitle = NULL;
        }
    }

    //
    // if title is not available, display the the url 
    //

    hr = _pMediaPlayer->get_url(pbstrTitle);
    if (SUCCEEDED(hr) && *pbstrTitle && (SysStringLen(*pbstrTitle)<=0))
    {
        SysFreeString(*pbstrTitle);
        *pbstrTitle = NULL;
    }

    if (SUCCEEDED(hr) &&  (*pbstrTitle != NULL))
    {
        // If the url is available, display it

        DWORD dwcchUnescaped;
        TCHAR tszPath[MAX_PATH];

        StrCpyN(tszPath, W2T(*pbstrTitle), ARRAYSIZE(tszPath));
        PathStripPath(tszPath);

        if (SUCCEEDED(UrlUnescape(tszPath, NULL, &dwcchUnescaped, URL_UNESCAPE_INPLACE)))
        {
            SysFreeString(*pbstrTitle);
            *pbstrTitle = SysAllocString(tszPath);
        }
    }

    hr = S_OK;
done:
    return hr;
}

VOID
CMediaBand::ShowPlayingStatus(BOOL fInitial)
{
    USES_CONVERSION;

    BSTR bstrTitle = NULL;
    if (EnsurePlayer() && _fPlaying)
    {
        if (!_isUIDisabled())
        {
            GetTrackTitle(&bstrTitle);
            // Display the name of the title
            if (bstrTitle && bstrTitle[0] != 0)
                SetStatusText(W2T(bstrTitle));
        }
        else
        {
            TCHAR szText[MAX_PATH];
            szText[0] = TEXT('\0');
            MLLoadString(IDS_MEDIABAND_PLAYING, szText, ARRAYSIZE(szText));
            SetStatusText(szText);
        }

        CComPtr<ITIMEMediaElement> spMediaElem;
        HRESULT hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
        ERROREXIT(hr)

        // store away the natural length of the media
        hr = spMediaElem->get_mediaDur(&_dblMediaDur);
        ERROREXIT(hr)
    }

done :
    if (bstrTitle)
        SysFreeString(bstrTitle);
}


VOID 
CMediaBand::SetStatusText(LPTSTR lpwStatusInfo)
{
    if (ISVALIDWIDGET(_pmwOptions))
    {
        // change buttons
        TBBUTTONINFO tbbi;
        TCHAR        szText[MAX_PATH];
        
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_BYINDEX | TBIF_TEXT;
        tbbi.pszText = szText ;
        tbbi.cchText = MAX_PATH ;
        SendMessage(_pmwOptions->_hwnd, TB_GETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);

        if (StrCmpIW(tbbi.pszText,lpwStatusInfo))
        {
            tbbi.pszText = lpwStatusInfo;
            if (_pszStatus)
            {
                delete [] _pszStatus;
            }
            _pszStatus = new TCHAR[lstrlen(lpwStatusInfo)+1];
            if (_pszStatus)
            {
                StrCpy(_pszStatus, lpwStatusInfo);
            }
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONINFO, (WPARAM)0, (LPARAM)&tbbi);
            // Need to force a resizing to accommodate new text
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth-1));
            SendMessage(_pmwOptions->_hwnd, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, _iOptionsWidth));
        }
    }
}

HRESULT
CMediaBand::ShowPlayListMenu(HWND hwnd, RECTL* rc)
{
    if (_hPlayListMenu)
    {
        DestroyMenu(_hPlayListMenu);
        _hPlayListMenu = NULL;
    }

    _hPlayListMenu = GetSubMenu(LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_MEDIA_GENERIC)), 0);

    if (_EnumPlayItems() != S_OK)
    {
        DestroyMenu(_hPlayListMenu);
        _hPlayListMenu = NULL;
        return S_OK;
    }

    ASSERT(_pMediaPlayer);
    UINT nID = FCIDM_PLAYITEM_START + (UINT)_pMediaPlayer->GetPlayListItemIndex();
    CheckMenuRadioItem(_hPlayListMenu, FCIDM_PLAYITEM_START, FCIDM_PLAYITEM_END, nID, MF_BYCOMMAND);
    UpdateMenuItems(_hPlayListMenu);

    POINT pt = {rc->left ,rc->bottom};
    int idCmd = TrackPopupMenu(_hPlayListMenu, 
                                TPM_LEFTBUTTON | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                pt.x, pt.y, 0, hwnd, NULL);

    if (idCmd>=FCIDM_PLAYITEM_START && idCmd<=FCIDM_PLAYITEM_END)                                
    {
        UINT  iCurTrack = idCmd - FCIDM_PLAYITEM_START ;
        _pMediaPlayer->SetActiveTrack(iCurTrack);
        UpdateBackForwardControls();
    }
    else
    {
        HandleMenuTasks(idCmd);
    }
    return S_OK;
}

STDMETHODIMP
CMediaBand::_EnumPlayItems()
{
    USES_CONVERSION;

    CComPtr<ITIMEMediaElement> spMediaElem;
    CComPtr<ITIMEPlayList> spPlayList;
    CComVariant svarIndex;
    long lLength = 0;
    INT i = 0;
    MENUITEMINFO mii = { sizeof(mii) };

    HRESULT hr = _pMediaPlayer->get_mediaElement(&spMediaElem);
    ERROREXIT(hr)

    hr = spMediaElem->get_playList(&spPlayList);
    ERROREXIT(hr)

    if (!(spPlayList.p))
       return S_FALSE;

    hr = spPlayList->get_length(&lLength);
    ERROREXIT(hr)

    svarIndex.vt = VT_I4;

    mii.cbSize     = sizeof(mii);
    mii.fMask      = MIIM_ID | MIIM_TYPE | MIIM_STATE;
    mii.fType      = MFT_STRING | MFT_RADIOCHECK;
    mii.fState     = MF_ENABLED;

    for (; i < lLength; i++)
    {
        CComPtr<ITIMEPlayItem> spPlayItem;
        CComBSTR sbstrTitle;
        TCHAR wszPath[40];

        V_I4(&svarIndex) = i;

        hr = spPlayList->item(svarIndex, &spPlayItem);
        ERROREXIT(hr)

        hr = spPlayItem->get_title(&sbstrTitle);
        ERROREXIT(hr)

        mii.wID        = i + FCIDM_PLAYITEM_START;
        if (sbstrTitle.Length() != 0)
        {
            StrCpyN(wszPath, sbstrTitle, ARRAYSIZE(wszPath));
        }
        else
        {
            CComBSTR sbstrSrc;   

            if (SUCCEEDED(spPlayItem->get_src(&sbstrSrc)) && sbstrSrc.Length() != 0)
            {
                PWSTR psz = PathFindFileName(sbstrSrc);
                StrCpyN(wszPath, psz, ARRAYSIZE(wszPath));
            }
            else
            {
                WCHAR szTemplate[64];
                if (!MLLoadStringW(IDS_MEDIABAND_TRACKNUMBER, szTemplate, ARRAYSIZE(szTemplate)))
                {
                    StrCpy(szTemplate, TEXT("%d"));
                }
                wnsprintf(wszPath, ARRAYSIZE(wszPath), szTemplate, i+1);
            }            
        }
        mii.dwTypeData = (LPTSTR)wszPath;
        InsertMenuItem(_hPlayListMenu, i, TRUE, &mii);
    }
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(_hPlayListMenu, i, TRUE, &mii);
    hr = S_OK;
    
done:
    return hr;
}

HRESULT CMediaBand::ShowGenericMenu(HWND hwnd, RECTL* rc)
{
    HMENU hMenu = GetSubMenu(LoadMenu(MLGetHinst(), MAKEINTRESOURCE(MENU_MEDIA_GENERIC)), 0);
    if (hMenu)
    {
        UpdateMenuItems(hMenu);
        int idCmd = TrackPopupMenu(hMenu, 
                                    TPM_LEFTBUTTON | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                    rc->left, rc->bottom, 0, hwnd, NULL);
        HandleMenuTasks(idCmd);
        DestroyMenu(hMenu);
    }

    return S_OK;
}

HRESULT CMediaBand::HandleMenuTasks(INT idCmd)
{
    switch (idCmd)
    {
    case IDM_MEDIA_PLAYINDEFAULT:
        {
            CComBSTR sbstrUrl;

            if (SUCCEEDED(_pMediaPlayer->get_url(&sbstrUrl)) && (NULL != sbstrUrl.m_str))
            {
                _OpenInDefaultPlayer(sbstrUrl);
            }
        }
        break;

    case IDM_MEDIA_ADDTOFAVORITES:
        {
            BSTR bstr = NULL, bstrTitle = NULL;
            if (EnsurePlayer() && !_isUIDisabled() && SUCCEEDED(_pMediaPlayer->get_url(&bstr)) && bstr && SUCCEEDED(GetTrackTitle(&bstrTitle)))
            {
                if (*bstr)
                {
                    AddToFavorites(bstr, bstrTitle);
                }
                SysFreeString(bstr);
            }
            break;
        }

    case IDM_MEDIA_PLAYINBAR:
        ToggleAutoplay(!GetAutoplay());
        break;

    case IDM_MEDIA_ASKTYPES:
        ToggleAutoplayPrompting(!GetAutoplayPrompt());
        break;

    case IDM_MEDIA_RESETTYPES:
        ResetMimePreferences();
        break;

    case IDM_MEDIA_TAKEOVERTYPES:
        if (PromptSettings(IDD_MEDIA_TAKEOVERMIMEPROMPT))
        {
            // do take over file types here
        }
        break;

    case IDM_MEDIA_RADIO_GOTO:
        _NavigateMainWindow(c_szRadioUrl);
        break;

    case IDM_MEDIA_BROADBAND_GUIDE:
        NavigateMoreMedia();
        break;
    }
    return S_OK;
}
    
HRESULT CMediaBand::_NavigateMainWindow(LPCTSTR wstrUrl, bool fSuppressFirstAutoPlay /* = false */) 
{
    CComPtr<IWebBrowser2> spWB2;

    // QS for the media bar
    HRESULT hr = QueryService(SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &spWB2));
    if (SUCCEEDED(hr))
    {
        CComBSTR sbstrUrl(wstrUrl);
        CComVariant svarEmpty;

        if (fSuppressFirstAutoPlay)
        {
            hr = CMediaBarHelper::DisableFirstAutoPlay(spWB2);
            if (FAILED(hr))
                goto done;
        }

        if (sbstrUrl)
        {
            hr = spWB2->Navigate(sbstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

done:
    return hr;
}

HRESULT 
CMediaBand::ResetMimePreferences()
{
    HRESULT hr = S_OK;

    if (PromptSettings(IDD_MEDIA_RESETMIMEPROMPT))
    {
        DWORD dwRet = SHDeleteKey(HKEY_CURRENT_USER, WZ_SMIE_MEDIA_MIME);
        if (ERROR_SUCCESS != dwRet)
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

BOOL CMediaBand::PromptSettings(UINT IDPROMPT)
{
    return (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDPROMPT), GetBrowserWindow(), s_PromptMimeDlgProc, NULL) == IDOK);
}

INT_PTR CALLBACK 
CMediaBand::s_PromptMimeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wParam, lParam)==IDC_MEDIA_MOREINFO)
            {
                SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("mediabar_settings.htm"), ML_CROSSCODEPAGE);
            }
            else
            {
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            }
            break;
    }
    return FALSE;
}

HRESULT 
CMediaBand::AddToFavorites(BSTR bstrUrl, BSTR bstrTitle)
{
    HRESULT hr = E_FAIL;

    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        DockMediaPlayer();
    }

    if (bstrUrl)
    {
        CComPtr<IShellUIHelper> spShellUIHelper;
        
        hr = CoCreateInstance(CLSID_ShellUIHelper, NULL, CLSCTX_INPROC_SERVER,  IID_IShellUIHelper, (void**) &spShellUIHelper);
        if (SUCCEEDED(hr))
        {
            CComVariant svarTitle(bstrTitle);

            hr = spShellUIHelper->AddFavorite(bstrUrl, &svarTitle);
        }
    }
    return hr;
}

LONG
CMediaBand::GetVideoHeight(LONG lSpecifiedWidth, BOOL fNewVideo)
{
    LONG lPaneWidth = lSpecifiedWidth==0 ? SCALEX(MIN_WINDOW_WIDTH) : lSpecifiedWidth;
    LONG lWidth  = lPaneWidth-MIN_HORZ_SPACING*2,
          lHeight = lWidth; // Assumption: Video is never taller than it is wide
    
    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        RECT rcWindow;
        GetClientRect(_hwndPopup,&rcWindow);
        lPaneWidth = RECTWIDTH(rcWindow);
        // minimum widths as per spec

        lWidth  = lPaneWidth - MIN_HORZ_SPACING * 2;

        // Allow for controls.
        if (fNewVideo)
        {
            lHeight = lWidth;
        }
        else
        {
            lHeight = RECTHEIGHT(rcWindow)-GetControlsHeight()-VIEW_MARGIN_TOP_VIDEO;
        }
    }

    // Resize the video and get video sizes
    _ResizeVideo(&lWidth,&lHeight);

    if (lWidth != -1 || lHeight != -1)
        return (lHeight>0 ? lHeight : (lPaneWidth-MIN_HORZ_SPACING*5)) ; 
    else
        return -1;
}


VOID
CMediaBand::DockMediaPlayer()
{
    if (!_hwndPopup)
    {
        InitPlayerPopup();
    }
    else if (IsWindowVisible(_hwndPopup))
    {
        // map the system window close request into a redocking operation instead
        // of closing

        _wpPopout.length = sizeof(_wpPopout);
        _fSavedPopoutState = GetWindowPlacement(_hwndPopup, &_wpPopout);

        // set the parent back to embedded window
        SHSetParentHwnd(_hwndLayout, _hwnd);

        DestroyWindow(_hwndPopup);
        _hwndPopup = NULL;

        if (_pmwPop && _pmwPop->_hwnd)
        {
            _pmwPop->SetImageSource(TRUE);          
        }
    }

    RECT rcParent;
    GetClientRect(_hwnd, &rcParent);
    SendMessage(_hwnd, WM_SIZE, (WPARAM)0, (LPARAM)MAKELONG(RECTWIDTH(rcParent), RECTHEIGHT(rcParent)));
    InvalidateRect(_hwnd, NULL, TRUE);
    UpdateWindow(_hwnd);
}

VOID
CMediaBand::GetToolbarSize(HWND hwndTB, SIZE *pSize)
{
    int nButtons = ToolBar_ButtonCount(hwndTB);
    
    pSize->cx = 0 ;
    pSize->cy = 0 ;
    
    for (int nIndex = 0; nIndex < nButtons; nIndex++)
    {
        RECTL rc ;
        SendMessage(hwndTB, TB_GETITEMRECT, nIndex, (LPARAM)&rc);
        pSize->cx += RECTWIDTH(rc);
        pSize->cy = max(RECTHEIGHT(rc),pSize->cy);
    }
}

//+-------------------------------------------------------------------------
//  Name: Invoke, IDispatch
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
//--------------------------------------------------------------------------
STDMETHODIMP CMediaBand::Invoke(  /* [in] */ DISPID  dispidMember,
                                    /* [in] */ REFIID /*riid*/,
                                    /* [in] */ LCID   /*lcid*/,
                                    /* [in] */ WORD  /*wFlags*/,
                                    /* [out][in] */ DISPPARAMS* pdispparams,
                                    /* [out] */ VARIANT* pVarResult,
                                    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
                                    /* [out] */ UINT*  puArgErr)
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;
    if (!pdispparams)
        return E_INVALIDARG;

    // show our friendly 404 page on navigation error:
    if (dispidMember == DISPID_NAVIGATEERROR)
    {
        // validate expected param list
        if (   (pdispparams->cArgs != 5)
            || (pdispparams->rgvarg[4].vt != VT_DISPATCH)               // IWebBrowser2 as IDispatch
            || (pdispparams->rgvarg[3].vt != (VT_BYREF | VT_VARIANT))   // target URL as BSTR
            || (pdispparams->rgvarg[2].vt != (VT_BYREF | VT_VARIANT))   // target frame as BSTR
            || (pdispparams->rgvarg[1].vt != (VT_BYREF | VT_VARIANT))   // status code as VT_I4
            || (pdispparams->rgvarg[0].vt != (VT_BYREF | VT_BOOL)))     // Cancel as VT_BOOL, OUT param
        {
            ASSERTMSG(0, "unexpected param list for NavigateError");
            return E_INVALIDARG;
        }
        LPCTSTR pszURL = W2CT(VariantToStrCast(&pdispparams->rgvarg[3]));
        int iStatus = VariantToInt(pdispparams->rgvarg[1]);
        
        // can't navigate to page, give help page
        TCHAR szResURL[2*MAX_URL_STRING];   // expect URL to help page and original URL
        HRESULT hr;
        hr = _BuildPageURLWithParam(c_sz404URL, pszURL, szResURL, ARRAYSIZE(szResURL));
        if (FAILED(hr)) {
            return hr;
        }

        // navigate deferred, caller of this Invoke() will cancel the current navigation
        _DeferredNavigate(szResURL);

        // have our own page, cancel the std error page:
        ASSERT(pdispparams->rgvarg[0].vt == (VT_BYREF | VT_BOOL));
        *V_BOOLREF(&pdispparams->rgvarg[0]) = VARIANT_TRUE;
    }

    // just for additional leak protection: give up proxy refs if not done already
    // before we get out of current document context
    if (dispidMember == DISPID_BEFORENAVIGATE)
    {
        _DetachProxies();
    }

    return S_OK;
}


LRESULT
CMediaBand::_OnVolumeCustomDraw(LPNMCUSTOMDRAW pnm)
{
    RECT rcClient;
    GetClientRect(pnm->hdr.hwndFrom, &rcClient);

    switch (pnm->dwDrawStage) 
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;

        case CDDS_PREERASE:
            return CDRF_NOTIFYITEMDRAW;
            
        case CDDS_ITEMPREPAINT:
        {
            HDC hdc = (HDC)pnm->hdc;
            RECT rcFill;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETCHANNELRECT, (WPARAM)0, (LPARAM)(LPRECT)&rcFill);
            RECT rcThumb;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETTHUMBRECT, 0L, (LPARAM)&rcThumb);

            SHFillRectClr(hdc, &rcClient, _fHiColour ? COLOR_BKGND : COLOR_BKGND16);
            UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);
            if (_himlVolumeBack)
            {
                ImageList_Draw(_himlVolumeBack, 0, hdc, rcClient.left, rcClient.top, uFlags);
            }
            if (_himlVolumeFill)
            {
                ImageList_DrawEx(_himlVolumeFill, 0, hdc, rcClient.left, rcClient.top, rcThumb.left, SEEK_HEIGHT, 0, 0, uFlags);
            }
            if (_himlGripper)
            {
                ImageList_Draw(_himlGripper, 0, hdc, rcThumb.left, 0, uFlags);
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}

LRESULT
CMediaBand::_OnSeekBarCustomDraw(LPNMCUSTOMDRAW pnm)
{
    RECT rcClient;
    GetClientRect(pnm->hdr.hwndFrom, &rcClient);

    switch (pnm->dwDrawStage) 
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;

        case CDDS_PREERASE:
            return CDRF_NOTIFYITEMDRAW;
            
        case CDDS_ITEMPREPAINT:
        {
            HDC hdc = (HDC)pnm->hdc;

            SHFillRectClr(hdc, &rcClient, _fHiColour ? COLOR_BKGND2 : COLOR_BKGND16);

            RECT rcFill;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETCHANNELRECT, (WPARAM)0, (LPARAM)(LPRECT)&rcFill);
            RECT rcThumb;
            SendMessage(pnm->hdr.hwndFrom, TBM_GETTHUMBRECT, 0L, (LPARAM)&rcThumb);
            int x, y = 1+(SEEK_HEIGHT-SEEK_PART_HEIGHT)/2;
            UINT uFlags = ILD_TRANSPARENT | (IsOS(OS_WHISTLERORGREATER) ? ILD_DPISCALE : 0);

            // always draw background with progress
            if (_himlSeekBack)
            {
                INT lPartWidth = SCALEX(SEEK_PART_WIDTH);
                x = rcFill.left;
                ImageList_Draw(_himlSeekBack, 0, hdc, x, y, uFlags);
                x = rcFill.right - lPartWidth;
                int inx = rcFill.left + lPartWidth;
                while (inx < x)
                {
                    ImageList_Draw(_himlSeekBack, 1, hdc, inx, y, uFlags);
                    inx += lPartWidth;
                }
                ImageList_Draw(_himlSeekBack, 2, hdc, x, y, uFlags);
            }

            if (pnm->dwItemSpec==TBCD_THUMB)
            {

                if ((!(pnm->uItemState & CDIS_DISABLED)) && ISVALIDWIDGET(_pmwSeek) && _pmwSeek->IsEnabled())
                {

                    x = rcFill.left;
                    int seekWidth = rcThumb.left-x;
                    if (_himlSeekFill && seekWidth)
                    {
                        if (seekWidth < SEEK_PART_WIDTH)
                        {
                            ImageList_DrawEx(_himlSeekFill, 0, hdc, x, y, seekWidth, SEEK_PART_HEIGHT, 0, 0, uFlags);
                        }
                        else
                        {
                            ImageList_Draw(_himlSeekFill, 0, hdc, x, y, uFlags);
                            x += SEEK_PART_WIDTH;
                            while ((rcThumb.left-x)>0)
                            {
                                ImageList_DrawEx(_himlSeekFill, 1, hdc, x, y, min(SEEK_PART_WIDTH, (rcThumb.left-x)), SEEK_PART_HEIGHT, 0, 0, uFlags);
                                x += SEEK_PART_WIDTH;
                            }
                        }
                        
                    }

                    INT iState = MWB_NORMAL;
                    if (pnm->uItemState & CDIS_SELECTED)
                    {
                        iState = MWB_PRESSED;
                    }
                    else if (pnm->uItemState & CDIS_HOT)
                    {
                        iState = MWB_HOT;
                    }
                    if (_himlGripper)
                    {
                        ImageList_Draw(_himlGripper, iState, hdc, rcThumb.left, 0, uFlags);
                    }
                }
            }
        }
        return CDRF_SKIPDEFAULT;
    }
    return CDRF_DODEFAULT;
}


LONG        
CMediaBand::GetPopoutHeight(BOOL fMeasureVideo, LONG lWidth)
{
    LONG lHeight = (fMeasureVideo ? GetLayoutHeight(lWidth) : GetControlsHeight())
                    + GetSystemMetrics(SM_CYSIZE) 
                    + GetSystemMetrics(SM_CYEDGE)*2
                    + GetSystemMetrics(SM_CYSIZEFRAME)*2;
    return lHeight;
}


LONG        
CMediaBand::GetMinPopoutWidth()
{
    return MIN_POPOUT_WIDTH + (GetSystemMetrics(SM_CXBORDER) + GetSystemMetrics(SM_CXFRAME))*2;
}


BOOL        
CMediaBand::ResetPlayer()
{
    _iCurTrack = -1;
    _fPlaying = FALSE;
    if (ISVALIDWIDGET(_pmwSeek))
    {
        _pmwSeek->SetState(FALSE);
    }
    if (_pMediaPlayer)
    {
        _pMediaPlayer->Stop();
        SetSeekPos(0.0);
        TogglePlayPause();
        if (_hwndVideo && IsWindowVisible(_hwndVideo))
        {
            _fIsVideo = FALSE;
            ShowWindow(_hwndVideo, SW_HIDE);
        }
        AdjustVideoHeight(TRUE);    
    }
    
    TCHAR szTitle[MAX_PATH];
    MLLoadStringW(IDS_MEDIABAND_MYMUSIC, szTitle, ARRAYSIZE(szTitle));
    SetStatusText(szTitle);
    
    SetPlayerControl(FCIDM_MEDIABAND_PREVIOUS, FALSE);
    SetPlayerControl(FCIDM_MEDIABAND_NEXT, FALSE);
    // while timer is running , give user a second chance to click stop again and reset media content pane
    if (_idStopTimer == 0)
    {
        SetPlayerControl(FCIDM_MEDIABAND_STOP, FALSE);
    }
    SetPlayPause(TRUE);
    return TRUE;
}

HRESULT CMediaBand::PlayLocalTrack(int iTrackNum)
{
    HRESULT hr = E_FAIL;

    if (_ppidls && (iTrackNum < (int)_cidls))
    {
        // to avoid pot. privacy leak, unload mediabar behavior
        if (_IsProxyRunning())
        {
            // user clicked on a media link in the main content pane, unfreeze controls!
            _OnUserOverrideDisableUI();
            _DetachProxies();
            _NavigateContentToDefaultURL();
        }

        TCHAR szFile[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(_ppidls[iTrackNum], SHGDN_FORPARSING, szFile, ARRAYSIZE(szFile), NULL)))
        {
            _iCurTrack = iTrackNum;

            if (EnsurePlayer())
                _PutUrl(szFile, NULL);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CMediaBand::PlayNextTrack()
{
    if (EnsurePlayer() && (_iCurTrack != -1))
    {
        LONG_PTR lCurTrack  = _pMediaPlayer->GetPlayListItemIndex();
        LONG_PTR lItemCount = _pMediaPlayer->GetPlayListItemCount();
        if ((lItemCount <= 1) || (lCurTrack == lItemCount - 1))
        {
            PlayLocalTrack(_iCurTrack + 1);
        }
        else
        {
            ResetPlayer();
        }
    }
    return S_OK;
}

BOOL CMediaBand::SetPlayerControl(UINT ui, BOOL fState)
{
    CMediaWidget* pmw = NULL;

    switch (ui)
    {
    case FCIDM_MEDIABAND_PREVIOUS:
        // while UI frozen by mediabar behavior, previous is always disabled
        if (fState && _pMediaPlayer)
        {
            fState = _pMediaPlayer->IsSkippable();
        }
        if (_isUIDisabled())
        {
            fState = FALSE; // override to always disable
        }
        pmw = _pmwBack;
        break;

    case FCIDM_MEDIABAND_NEXT:
        // only override if any of the proxies are running
        if (fState && _pMediaPlayer)
        {
            fState = _pMediaPlayer->IsSkippable();
        }
        if (_apContentProxies != NULL)
        {
            if (_isUIDisabled() && _pMediaPlayer && !_pMediaPlayer->IsSeekPossible())
            {
                fState = FALSE;
            }
            // only force a disabled next button if stream has NOSKIP attribute set
            if (!_isProxiesNextEnabled())
            {
                fState = FALSE;
            }
        }
        pmw = _pmwNext;
        break;

    case FCIDM_MEDIABAND_STOP:
        pmw = _pmwStop;
        break;

    default:
        ASSERT(FALSE);
        break;
    }
        
    if (pmw && pmw->_hwnd)
    {
        SendMessage(pmw->_hwnd, TB_ENABLEBUTTON, ui, MAKELONG(fState, 0));
    }
    return TRUE;
}


BOOL        
CMediaBand::UpdateBackForwardControls()
{
    BOOL fPrevious = FALSE, fNext = FALSE;
    if (_iCurTrack != -1)
    {
        fPrevious = _iCurTrack != 0;
        fNext = ((_iCurTrack + 1) < (int)_cidls);
    }
    else if (EnsurePlayer())
    {
        LONG_PTR lItemCount= _pMediaPlayer->GetPlayListItemCount();
        if (lItemCount > 1)
        {
            LONG_PTR lCurTrack = _pMediaPlayer->GetPlayListItemIndex();
            fPrevious = (lCurTrack > 0);
            fNext = lCurTrack < lItemCount - 1;
        }
    }
    SetPlayerControl(FCIDM_MEDIABAND_PREVIOUS, fPrevious);
    SetPlayerControl(FCIDM_MEDIABAND_NEXT, fNext);
    return TRUE;
}

HRESULT 
CMediaBand::Seek(double dblProgress)
{
    HRESULT hr = S_OK;
    if (EnsurePlayer())
    {
        hr = _pMediaPlayer->Seek(dblProgress);
        if (SUCCEEDED(hr))
        {
            // play/pause state may have been changed by Seek
            TogglePlayPause();
        }
    }
    return hr;
}

LPTSTR 
CMediaBand::GetUrlForStatusBarToolTip()
{
    USES_CONVERSION;

    LPTSTR szRet = NULL;

    if (_pMediaPlayer)
    {
        if (_pMediaPlayer->isStopped())
        {
            return _pszStatus;       
        }

        CComBSTR sbstrUrl;

        HRESULT hr = _pMediaPlayer->get_url(&sbstrUrl);
        if (    SUCCEEDED(hr) 
            &&  (sbstrUrl.m_str) 
            &&  (sbstrUrl.Length()>0))
        {
            szRet = W2T(sbstrUrl);
            if (szRet)
            {
                //
                // The tooltip structure (NMTTDISPINFO.lpszText) requires a pointer to a private buffer.
                // Store the pointer so we can free it later.
                //

                int len = lstrlen(szRet);

                delete [] _szToolTipUrl;

                _szToolTipUrl = new TCHAR[len + 1];

                if (_szToolTipUrl)
                {
                    memcpy(_szToolTipUrl, szRet, sizeof(TCHAR) * (len + 1));
                }                

                szRet = _szToolTipUrl;
            }
        }
    }

    return szRet;
}

VOID CMediaBand::UpdateMenuItems(HMENU hmenu)
{
    ASSERT(hmenu);
    CComBSTR sbstrUrl;
    
    if (GetAutoplay())
    {
        CheckMenuItem(hmenu, IDM_MEDIA_PLAYINBAR, MF_BYCOMMAND | MF_CHECKED);
    }

    if (GetAutoplayPrompt())
    {
        CheckMenuItem(hmenu, IDM_MEDIA_ASKTYPES, MF_BYCOMMAND | MF_CHECKED);
    }

    if (!_pMediaPlayer || _pMediaPlayer->isStopped() || FAILED(_pMediaPlayer->get_url(&sbstrUrl)) || !sbstrUrl.m_str || (sbstrUrl.Length()<=0) || _isUIDisabled())
    {
        DeleteMenu(hmenu, IDM_MEDIA_PLAYINDEFAULT, MF_BYCOMMAND);
        DeleteMenu(hmenu, IDM_MEDIA_ADDTOFAVORITES, MF_BYCOMMAND);
        DeleteMenu(hmenu, 0, MF_BYPOSITION);
    }
}


BOOL CMediaBand::OnNotify(LPNMHDR pnm, LRESULT* plres)
{
    ASSERT(plres);
    BOOL fRet = FALSE;

    switch (pnm->code) 
    {
        case NM_CUSTOMDRAW:
        {
            LRESULT lres;
            LPNMCUSTOMDRAW pnmc = (LPNMCUSTOMDRAW)pnm;
            if (pnm->hwndFrom == _hwndVolume)
            {
                lres = _OnVolumeCustomDraw(pnmc);
            }
            else if (pnm->hwndFrom == _hwndSeek)
            {
                lres = _OnSeekBarCustomDraw(pnmc);                        
            }
            else 
            {
                for (int i=0; i<ARRAYSIZE(_pmw); i++)
                {
                    if (_pmw[i] && (pnm->hwndFrom == _pmw[i]->_hwnd))
                    {
                        lres = _pmw[i]->Draw((LPNMTBCUSTOMDRAW)pnm);
                    }
                }                        
            }
            
            fRet = TRUE;
            *plres = lres;
        }
        break;
        
        case TBN_DROPDOWN:
        {
            LPNMTOOLBAR lpnmTB = ((LPNMTOOLBAR)pnm);
            HWND hwndTB = pnm->hwndFrom;
            UINT nCmdID = lpnmTB->iItem;

            //  figure out coordinates to use
            INT_PTR iBtn = SendMessage(hwndTB, TB_GETHOTITEM, 0, 0);

            RECTL rc ;
            SendMessage(hwndTB, TB_GETITEMRECT, iBtn, (LPARAM)&rc);
            MapWindowPoints(hwndTB, HWND_DESKTOP, (LPPOINT)&rc , 2);

            if (_pmwOptions && hwndTB==_pmwOptions->_hwnd)
            {
                if (_pMediaPlayer && (_pMediaPlayer->GetPlayListItemCount() > 0) && !_pMediaPlayer->isStopped() && !_isUIDisabled() && _pMediaPlayer->IsSkippable())
                {
                    ShowPlayListMenu(hwndTB, &rc);
                }
                else
                {
                    ShowGenericMenu(hwndTB, &rc);
                }
            }
            else
            {
                VARIANTARG var;
                var.vt  = VT_I4;
                var.lVal = MAKELONG(rc.left, rc.bottom);
                *plres = Exec(&CLSID_MediaBand, nCmdID, 0, &var, NULL);
                fRet = TRUE;
            } // end of else
        }
        break;
        
        case TBN_GETDISPINFO:
        {
            LPNMTBDISPINFO lptbi = (LPNMTBDISPINFO)pnm;

            if (lptbi->hdr.hwndFrom == _pmwPlay->_hwnd && lptbi->dwMask & TBNF_IMAGE)
            {
                TBBUTTONINFO tbbi;
                tbbi.dwMask = TBIF_COMMAND | TBIF_STATE;
                SendMessage(lptbi->hdr.hwndFrom, TB_GETBUTTONINFO, (WPARAM)lptbi->idCommand, (LPARAM)&tbbi);

                if (_fPlayButton)
                   lptbi->iImage = (!(tbbi.fsState & TBSTATE_INDETERMINATE) && (tbbi.fsState & TBSTATE_PRESSED)) ? 3 : 1 ;
                else
                   lptbi->iImage = (!(tbbi.fsState & TBSTATE_INDETERMINATE) && (tbbi.fsState & TBSTATE_PRESSED)) ? 2 : 0 ;

                lptbi->dwMask |= TBNF_DI_SETITEM;
            }
            else if (_pmwOptions && (lptbi->hdr.hwndFrom ==_pmwOptions->_hwnd))
            {
                lptbi->iImage = 0;
                lptbi->dwMask |= TBNF_DI_SETITEM;
            }
        }
        break;

        case TTN_GETDISPINFO: 
        { 
            LPNMTTDISPINFO pnmtt = (LPNMTTDISPINFO)pnm; 
            pnmtt->hinst = MLGetHinst(); 

            switch (pnmtt->hdr.idFrom) 
            { 
                case FCIDM_MEDIABAND_POPOUT: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_hwndPopup ? IDS_MEDIABAND_DOCK : IDS_MEDIABAND_UNDOCK);
                    break; 

                case FCIDM_MEDIABAND_PLAY: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_fPlayButton ? IDS_MEDIABAND_PLAY : IDS_MEDIABAND_PAUSE);
                    break; 
                                                
                case FCIDM_MEDIABAND_MUTE: 
                    pnmtt->lpszText = (PTSTR)MAKEINTRESOURCE(_fMuted ? IDS_MEDIABAND_UNMUTE : IDS_MEDIABAND_MUTE);
                    break; 

                case FCIDM_MEDIABAND_PLAYINFO:
                {
                    if (_pMediaPlayer && !_isUIDisabled())
                    {
                        LPTSTR szUrl = GetUrlForStatusBarToolTip();
                        if (szUrl)
                        {
                            pnmtt->lpszText = szUrl;
                        }
                    }
                    break;
                }
            } 
        }
    } 

    return fRet;
}


HRESULT 
CMediaBand::_OpenInDefaultPlayer(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;

    if (    !bstrUrl 
        ||  !(*bstrUrl))
    {
        hr = E_FAIL;
        goto done;
    }

    // suppress first autoplay and navigate main IE window
    hr = _NavigateMainWindow(bstrUrl, true);    
    if (FAILED(hr))
    {
        goto done;
    }

    if (_hwndPopup && IsWindowVisible(_hwndPopup))
    {
        DockMediaPlayer();
    }
    // pause/stop the playback
    if (_pMediaPlayer->IsPausePossible())
    {
        _pMediaPlayer->Pause();
    }
    else
    {
        _pMediaPlayer->Stop();
    }

    hr = S_OK;
done:
    return hr;
}

VOID
CMediaBand::SetPlayPause(BOOL fState)
{
    _fPlayEnabled = fState;
    if (_pmwPlay && _pmwPlay->_hwnd)
    {
        SendMessage(_pmwPlay->_hwnd, TB_SETSTATE, FCIDM_MEDIABAND_PLAY, MAKELONG((_fPlayEnabled ? TBSTATE_ENABLED : 0), 0));
        InvalidateRect(_pmwPlay->_hwnd, NULL, FALSE);
        UpdateWindow(_pmwPlay->_hwnd);
    }
}

INT idNormalHi[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PLAY, //    MW_PLAY = 0,
IDB_MEDIABAND_STOP, //    MW_STOP,
IDB_MEDIABAND_BACK, //    MW_BACK,
IDB_MEDIABAND_NEXT, //    MW_NEXT,
IDB_MEDIABAND_MUTE, //    MW_MUTE,
IDB_MEDIABAND_VOLBKGND, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPOUT, //    MW_POP,
IDB_MEDIABAND_SEEKBACK, //    MW_SEEK,
};

INT idAltHi[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PAUSE, //    MW_PLAY = 0,
0, //    MW_STOP,
0, //    MW_BACK,
0, //    MW_NEXT,
0, //    MW_MUTE,
IDB_MEDIABAND_VOLFILL, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPIN, //    MW_POP,
IDB_MEDIABAND_SEEKFILL, //    MW_SEEK,
};

INT idNormalLo[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PLAY16, //    MW_PLAY = 0,
IDB_MEDIABAND_STOP16, //    MW_STOP,
IDB_MEDIABAND_BACK16, //    MW_BACK,
IDB_MEDIABAND_NEXT16, //    MW_NEXT,
IDB_MEDIABAND_MUTE16, //    MW_MUTE,
IDB_MEDIABAND_VOLBKGND16, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPOUT16, //    MW_POP,
IDB_MEDIABAND_SEEKBACK16, //    MW_SEEK,
};

INT idAltLo[MW_NUMBER] = 
{ 
IDB_MEDIABAND_PAUSE16, //    MW_PLAY = 0,
0, //    MW_STOP,
0, //    MW_BACK,
0, //    MW_NEXT,
0, //    MW_MUTE,
IDB_MEDIABAND_VOLFILL16, //    MW_VOLUME,
0, //    MW_OPTIONS,
IDB_MEDIABAND_POPIN16, //    MW_POP,
IDB_MEDIABAND_SEEKFILL16, //    MW_SEEK,
};

    
VOID        
CMediaBand::SwitchBitmaps(BOOL fNewSetting)
{
    INT* idAlt = fNewSetting ? idAltHi : idAltLo;
    INT* idNormal = fNewSetting ? idNormalHi : idNormalLo;

    for (int i=0; i<MW_NUMBER; i++)
    {
        if (ISVALIDWIDGET(_pmw[i]))
        {
            switch (i)
            {
            case MW_SEEK:
                DESTROY_OBJ_WITH_HANDLE(_himlSeekBack, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlSeekFill, ImageList_Destroy);
                _himlSeekBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idNormal[i]), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlSeekFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idAlt[i]), SEEK_PART_WIDTH, 0, crMask,
                                             IMAGE_BITMAP, LR_CREATEDIBSECTION);

                break;

            case MW_OPTIONS:
                {
                CMediaWidgetOptions* pmwb = (CMediaWidgetOptions*)_pmw[i];
                pmwb->SetDepth(fNewSetting);
                }
                break;

            case MW_VOLUME:
                DESTROY_OBJ_WITH_HANDLE(_himlVolumeBack, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlVolumeFill, ImageList_Destroy);
                DESTROY_OBJ_WITH_HANDLE(_himlGripper, ImageList_Destroy);
                _himlVolumeBack = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idNormal[i]), VOLUME_BITMAP_WIDTH, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlVolumeFill = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(idAlt[i]), VOLUME_BITMAP_WIDTH, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                _himlGripper = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(fNewSetting ? IDB_MEDIABAND_VOLTAB : IDB_MEDIABAND_VOLTAB16), 6, 0, crMask,
                                                     IMAGE_BITMAP, LR_CREATEDIBSECTION);
                break;

            default:
                // The rest are buttons
                {
                CMediaWidgetButton* pmwb = (CMediaWidgetButton*)_pmw[i];
                pmwb->SetImageList(idNormal[i]);
                if (idAlt[i])
                {
                    pmwb->SetAlternateImageList(idAlt[i]);
                }
                }
                break;
            }
        }
    }

    _fHiColour = fNewSetting;
    InvalidateRect(_hwnd, NULL, TRUE);
    UpdateWindow(_hwnd);
}


VOID
CMediaBand::InitContentPane()
{
    SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
    shdrc.cbSize = sizeof (SHDRC);
    shdrc.dwFlags |= SHDRCF_OCHOST;
    if (_hwnd && IsWindow(_hwnd) && DllRegisterWindowClasses(&shdrc))
    {
        // Create an OCHost window
        _hwndContent = CreateWindow(OCHOST_CLASS, NULL,
                                    WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_TABSTOP,
                                    0, 0, 0, 0,
                                    _hwnd, NULL, HINST_THISDLL, NULL);
        
        if (_hwndContent)
        {
            OCHINITSTRUCT ocs;
            ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
            ocs.clsidOC  = CLSID_WebBrowser;
            ocs.punkOwner = SAFECAST(this, IDispatch*);
            
            if (SUCCEEDED(OCHost_InitOC(_hwndContent, (LPARAM)&ocs)))
            {
                OCHost_QueryInterface(_hwndContent, IID_PPV_ARG(IWebBrowser2, &_spBrowser));
                OCHost_QueryInterface(_hwndContent, IID_PPV_ARG(IOleInPlaceActiveObject, &_poipao));
                OCHost_DoVerb(_hwndContent, OLEIVERB_INPLACEACTIVATE, FALSE);
                _ConnectToCP(TRUE);
            }
            _NavigateContentToDefaultURL();
        }
    }
}

HRESULT
CMediaBand::_ConnectToCP(BOOL fConnect)
{
    // get ready to sink the OCHost's browser events
    if (!_spBrowser)
    {
        return E_FAIL;
    }
    if (!fConnect && (_dwcpCookie == 0))
    {
        return S_FALSE; //
    }
    return ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect, _spBrowser, &_dwcpCookie, NULL);
}

HRESULT CMediaBand::NavigateContentPane(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    if (_spBrowser && bstrUrl)
    {
        _strCurrentContentUrl = bstrUrl;

        CComVariant svarEmpty;
        svarEmpty.vt = VT_NULL;
        hr = _spBrowser->Navigate(bstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    }
    return hr;
}

HRESULT CMediaBand::NavigateContentPane(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    if (_spBrowser && pidl)
    {
        TCHAR szURL[MAX_URL_STRING];

        if (SUCCEEDED(::IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING)))
        {
            _strCurrentContentUrl = szURL;
        }
        else
        {
            _strCurrentContentUrl.Empty();
        }

        CComVariant svarEmpty;
        svarEmpty.vt = VT_NULL;
        CComVariant varURL;
        InitVariantFromIDList(&varURL, pidl);

        hr = _spBrowser->Navigate2(&varURL, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    }
    return hr;
}


VOID CMediaBand::NavigateMoreMedia()
{
    _NavigateMainWindow(c_szMoreMediaUrl);
}

HRESULT CMediaBand::_NavigateContentToDefaultURL()
{
    TCHAR szResURL[2*MAX_URL_STRING];   // expect URL to help page and original URL
    HRESULT hr;
    LPCTSTR pszStartURL = NULL;
    
    // load inital page, this is always a local resource
    BOOL fSuppressOnline = SHRegGetBoolUSValue(REG_MEDIA_STR, TEXT("SuppressOnlineContent"), FALSE, FALSE);
    BOOL fStayOffline =    SHIsGlobalOffline()
        || fSuppressOnline 
        || SHRestricted2W(REST_No_MediaBarOnlineContent, NULL, 0);
    
    // ISSUE/010426/davidjen  with the restriction set,
    //              do we need a second offline page without external links, only MyMusic???????????????
    if (fStayOffline)
    {
        pszStartURL = c_szOfflineURL;
    }
    else
    {
        pszStartURL = c_szLoadingURL;
    }
    
    hr = _BuildPageURLWithParam(pszStartURL, NULL, szResURL, ARRAYSIZE(szResURL));
    if (FAILED(hr))
    {
        StrCpyN(szResURL, c_szOfflineURL, ARRAYSIZE(szResURL));
        hr = S_OK;
    }
    NavigateContentPane(szResURL);
    
    // if online, try navigating to windowsmedia.com
    if (!fStayOffline)
    {
        _DeferredNavigate(c_szContentUrl);
    }
    return S_OK;
}

HRESULT
CMediaBand::_BuildPageURLWithParam(LPCTSTR pszURL, LPCTSTR pszParam, OUT LPTSTR pszBuffer, UINT uiBufSize)
{
    USES_CONVERSION;
    // build a string of the form:  "res://d:\winnt\system32\browselc.dll\helppage.htm#http://www.windowsmedia.com/xyz.html"
    HRESULT hr = S_OK;

    ASSERT(pszBuffer);
    hr = MLBuildResURLWrap(TEXT("browselc.dll"), HINST_THISDLL, ML_CROSSCODEPAGE,
                           T2W((LPTSTR)pszURL), pszBuffer, uiBufSize, TEXT("browseui.dll"));
    
    if (SUCCEEDED(hr) && pszParam && (lstrlen(pszParam) > 0))
    {
        StrCatBuff(pszBuffer, TEXT("#"), uiBufSize);
        StrCatBuff(pszBuffer, pszParam, uiBufSize);
    }

    return hr;
}

BOOL CMediaBand::_DeferredNavigate(LPCTSTR pszURL)
{
    ASSERT(_strDeferredURL.Length() == 0);
    _strDeferredURL = pszURL;
    return PostMessage(_hwnd, WM_MB_DEFERRED_NAVIGATE, 0, (LPARAM) _hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\multimon.cpp ===
#include "priv.h"
//=============================================================================
//
// This function defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\menubar.cpp ===
#include "priv.h"
#include "sccls.h"
#include "basebar.h"
#include "bands.h"
#include "menubar.h"
#include "menuband.h"
#include "isfband.h"

#include "apithk.h"
// APPCOMPAT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define THISCLASS CMenuDeskBar
#define SUPERCLASS CBaseBar


// Don't fade the menu if it's larger than this magical number. Based on experiments
// on a Pentium II - 233
#define MAGICAL_NO_FADE_HEIGHT  600

// For TraceMsg
#define DM_POPUP   DM_TRACE

#define UP    0
#define DOWN  1
#define LEFT  2
#define RIGHT 3

#ifdef ENABLE_CHANNELS
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);
#endif  // ENABLE_CHANNELS

// Used by performance timing mode
extern DWORD g_dwStopWatchMode;  // Shell performance mode
extern HMENU g_hmenuStopWatch;
extern UINT g_idCmdStopWatch;

HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CMenuDeskBar *pwbar = new CMenuDeskBar();
    if (pwbar)
    {
        *ppunk = SAFECAST(pwbar, IMenuPopup*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


CMenuDeskBar::CMenuDeskBar() : SUPERCLASS()
{
    _dwMode = DBIF_VIEWMODE_VERTICAL; 
    
    _iIconSize = BMICON_SMALL;
}

CMenuDeskBar::~CMenuDeskBar()
{
    SetSite(NULL);
}


STDMETHODIMP CMenuDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IMenuPopup),
        QITABENT(THISCLASS, IObjectWithSite),
        QITABENT(THISCLASS, IBanneredBar),
        QITABENT(THISCLASS, IInitializeObject),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubmenu method

*/
STDMETHODIMP CMenuDeskBar::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (fSet)
    {
        if (_pmpChild)
            _pmpChild->Release();
        
        _pmpChild = pmp;
        _pmpChild->AddRef();    
    }
    else
    {
        if (_pmpChild && SHIsSameObject(pmp, _pmpChild))
        {
            _pmpChild->Release();
            _pmpChild = NULL;
        }
    }
    return S_OK;
}


void CMenuDeskBar::_PopDown()
{
    DAD_ShowDragImage(FALSE);
    if (_pmpChild)
        _pmpChild->OnSelect(MPOS_CANCELLEVEL);
    
//    ShowWindow(_hwnd, SW_HIDE);
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);
    ShowDW(FALSE);
    if (_pmpParent)
    {
        _pmpParent->SetSubMenu(this, FALSE);
    }
    UIActivateIO(FALSE, NULL);
    _fActive = FALSE;
    DAD_ShowDragImage(TRUE);
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CMenuDeskBar::OnSelect(DWORD dwSelectType)
{
    switch (dwSelectType)
    {
    case MPOS_CHILDTRACKING:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;
        
    case MPOS_SELECTRIGHT:
    case MPOS_SELECTLEFT:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_EXECUTE:
    case MPOS_FULLCANCEL:
        _PopDown();
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_CANCELLEVEL:
        _PopDown();
        break;
        
    }
    
    return S_OK;
} 

void SetExpandedBorder(HWND hwnd, BOOL fExpanded)
{
#ifdef MAINWIN
    // IEUNIX : WS_DLGFRAME implementaion looks ugly on UNIX.
    fExpanded = TRUE;
#endif

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

    if (fExpanded)
    {
        dwStyle |= WS_BORDER;
        dwStyle &= ~WS_DLGFRAME;
    }
    else
    {
        dwStyle &= ~WS_BORDER;
        dwStyle |= WS_DLGFRAME;
    }

    SetWindowLong(hwnd, GWL_STYLE, dwStyle);
    SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    UpdateWindow(hwnd);
}

void CMenuDeskBar::_OnCreate()
{
    if (!_fFlatMenuMode)
        SetExpandedBorder(_hwnd, _fExpanded);
}


DWORD CMenuDeskBar::_GetClassStyle()
{
    DWORD dwStyle = CS_SAVEBITS; // Faster repaint for menus when they go away
    
    if (IsOS(OS_WHISTLERORGREATER))
    {
        dwStyle |= CS_DROPSHADOW;   // Cool dropshadow effect on whistler....
    }

    return dwStyle;
}

DWORD CMenuDeskBar::_GetExStyle()
{
#ifndef MAINWIN
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
#else
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_MW_UNMANAGED_WINDOW;
#endif
}

// We use the following structure to pass a whole bunch of information from 
// the GetPopupWindowPosition to WillFit function. We have WillFit function 
// to cut the amount of duplicate code in getpopup window position. The order 
// in which different the sides are checked is the only difference for popping 
// up a window on a particular side.
//
// Having this function helps us to do that check by means of a parameter instead 
// of repeating portions of code again and again.

typedef struct  {
    RECT rcAvail;           // Available dimensions b/t monitor edge and exclude edge
    SIZE sizeAdjust;          // Size of menu edge
    int  cyMonitor;         // Size of monitor 
    int  cxMonitor;
    int  cx;                // Size of menu
    int  cy;
    int  cyExtendDiff;      // Difference b/t calc'd size and available size
    RECT *prcResult;
    RECT *prcExclude;       // Exclude rect
    RECT *prcMonitor;
} PopupInfo;

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3 

/*----------------------------------------------------------
Purpose: Attempt to fit and position a menu in the given direction
         relative to an exclude rect.

         Setting fForce to TRUE will cause the menu size to be adjusted
         to fit, if necessary.

         This function only sets the top and left coords, not the bottom
         and right coords.
         
         Returns TRUE if the desired direction can be accomplished.

*/
BOOL WillFit(PopupInfo * pinfo, int side, BOOL fForce)
{
    BOOL bRet = FALSE;
    LPRECT prcResult = pinfo->prcResult;
    
    pinfo->cyExtendDiff = 0;
    
    switch(side)
    {
    case TOP:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.top;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    

            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;    
        }

        // Can the menu be positioned above?
        if (pinfo->cy <= pinfo->rcAvail.top)
        {
            // Yes
            prcResult->top  = pinfo->prcExclude->top - pinfo->cy;
            
            goto AdjustHorzPos;
        }
        break;
        
    case BOTTOM:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.bottom;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    
            
            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;
        }

        // Can the menu be positioned below?
        if (pinfo->cy <= pinfo->rcAvail.bottom)
        {
            // Yes
            prcResult->top = pinfo->prcExclude->bottom;

AdjustHorzPos:            
            prcResult->left = max(pinfo->prcExclude->left, pinfo->prcMonitor->left);

            // Can the menu be positioned relative to its left edge (hanging right)?
            if (prcResult->left + pinfo->cx >= pinfo->prcMonitor->right)
            {
                // No; move it in so it is on the screen
                //  (cx has already been adjusted to fit inside the monitor dimensions)
                prcResult->left = pinfo->prcMonitor->right - pinfo->cx - 1;
            }
            bRet = TRUE;
        }
        break;
        
    case LEFT:
        // Can the menu be positioned to the left?
        if (pinfo->cx <= pinfo->rcAvail.left || fForce)
        {
            // Yes
            
            // When cascading left, the menu does not overlap.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->left - pinfo->cx - 1;

            goto AdjustVerticalPos;
        }
        break;

    case RIGHT:
        // Can the menu be positioned to the right?
        if (pinfo->cx  <=  pinfo->rcAvail.right || fForce)
        {
            // Yes
            
            // Adjust the menu to slightly overlap the parent menu.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->right - pinfo->sizeAdjust.cx;

AdjustVerticalPos:            
            prcResult->top = pinfo->prcExclude->top - pinfo->sizeAdjust.cy;

            // Can the menu be positioned relative to its top edge (hanging down)?
            if (prcResult->top + pinfo->cy >= pinfo->prcMonitor->bottom)
            {
                // No; can it be positioned relative to its bottom edge (hanging up)?
                prcResult->top = pinfo->prcExclude->bottom + pinfo->sizeAdjust.cy - pinfo->cy;
                
                if (prcResult->top < pinfo->prcMonitor->top)
                {
                    // No; move the menu so it fits, but isn't vertically snapped.
                    //  (cy has already been adjusted to fit inside the monitor
                    //  dimensions)
                    prcResult->top = pinfo->prcMonitor->bottom - pinfo->cy - 1;
                }
            }
            
            bRet = TRUE;

        }
        break;
    }
    return bRet;

}


void CMenuDeskBar::_GetPopupWindowPosition(RECT* prcDesired, RECT* prcExclude, 
                                           RECT *prcResult, SIZE * psizeAdjust, UINT uSide) 
{
    PopupInfo info;
    MONITORINFO mi;
    HMONITOR hMonitor;
    RECT rcMonitor;
    int cyExtendDiff = 0;

    // Is this going to display the banner bitmap?
    if (_iIconSize == BMICON_LARGE)
    {
        // Yes; add that to the dimensions
        prcDesired->right += _sizeBmp.cx;
    }

    // First get the monitor information
    hMonitor = MonitorFromRect(prcExclude, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        rcMonitor = mi.rcMonitor;

        // Set the result rectangle same as the desired window
        prcResult->left = prcDesired->left;
        prcResult->top  = prcDesired->top;

        // Calculate some sizes needed for calculation
        info.rcAvail.left   = prcExclude->left - rcMonitor.left;
        info.rcAvail.right  = rcMonitor.right - prcExclude->right;
        info.rcAvail.top    = prcExclude->top - rcMonitor.top;
        info.rcAvail.bottom = rcMonitor.bottom - prcExclude->bottom;

        info.sizeAdjust = *psizeAdjust;
    
        info.cyMonitor = RECTHEIGHT(rcMonitor); 
        info.cxMonitor = RECTWIDTH(rcMonitor);

        info.cx  = RECTWIDTH(*prcDesired);
        info.cy = RECTHEIGHT(*prcDesired);

        // If the desired rect is bigger than monitor then clip it to the monitor size
        if (info.cy > info.cyMonitor)
            info.cy = info.cyMonitor;

        if (info.cx > info.cxMonitor)
            info.cx = info.cxMonitor;

        info.prcResult = prcResult;
        info.prcExclude = prcExclude;
        info.prcMonitor = &rcMonitor;

        //Now Adjust the rectangle for the correct position
        switch(uSide)
        {
        int iSide;

        case MENUBAR_TOP:
    
            if (WillFit(&info, TOP, FALSE))
            {
                _uSide = MENUBAR_TOP;
            }
            else 
            {
                // We couldn't fit it above, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, BOTTOM, FALSE))
                    _uSide = MENUBAR_BOTTOM;
                // We can't fit it below either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
            }
            break;

        case MENUBAR_BOTTOM:
    
            if (WillFit(&info, BOTTOM, FALSE))
            {
                _uSide = MENUBAR_BOTTOM;
            }
            else
            {   
                // We couldn't fit it below, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, TOP, FALSE))
                    _uSide = MENUBAR_TOP;

                // We can't fit it above either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
            }
            break;

        case MENUBAR_LEFT:

            if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) > (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;

        case MENUBAR_RIGHT:

            if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) >= (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;
        }
    
        // Finally set the bottom and right

        if (prcResult->top < rcMonitor.top)
            prcResult->top = rcMonitor.top;
        if (prcResult->left < rcMonitor.left)
            prcResult->left = rcMonitor.left;

        prcResult->bottom = prcResult->top  + info.cy;
        prcResult->right  = prcResult->left + info.cx;

        if (prcResult->bottom > rcMonitor.bottom)
        {
            // -2 for some breathing room at the edge of the screen
            prcResult->bottom = rcMonitor.bottom - 2;
            prcResult->top = prcResult->bottom - info.cy;
        }
    }
}

HRESULT CMenuDeskBar::_PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    BOOL bSetFocus = (dwFlags & MPPF_SETFOCUS);
    RECT rcDesired;
    RECT rcExclude;
    RECT rc;
    SIZE sizeAdjust;
    UINT uAnimateSide;

    BOOL bMirroredWindow=IS_WINDOW_RTL_MIRRORED(_hwnd);

    static const iPosition[] = {MENUBAR_TOP, MENUBAR_LEFT, MENUBAR_RIGHT, MENUBAR_BOTTOM};

    if (dwFlags & MPPF_POS_MASK)
    {
        UINT uPosIndex = ((dwFlags & MPPF_POS_MASK) >> 29) - 1;
        ASSERT(uPosIndex < 4);
        _uSide = iPosition[uPosIndex];
    }

    if (bSetFocus)
        SetForegroundWindow(_hwnd);
    
    _pt = *(POINT*)ppt;

    // Get the size of the ideal client rect of the child
    RECT rcChild = {0};

    // (scotth): This only sets the bottom and the right values
    _pDBC->GetSize(DBC_GS_IDEAL, &rcChild);

    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

    // Adjust for the window border style
    rcDesired = rcChild;        // use rcDesired as a temp variable
    if (!_fNoBorder)
    {
        AdjustWindowRectEx(&rcChild, dwStyle, FALSE, dwExStyle);
    }

    // Calculate the edge of the menu border, and add a fudge factor so
    // left/right-cascaded menus overlap the parent menu a bit and are
    // correctly aligned vertically.

    sizeAdjust.cx = (RECTWIDTH(rcChild) - RECTWIDTH(rcDesired)) / 2;
    sizeAdjust.cy = (RECTHEIGHT(rcChild) - RECTHEIGHT(rcDesired)) / 2;

    if (prcExclude)
    {
        CopyRect(&rcExclude, (RECT*)prcExclude);

        //
        // If mirroring is enabled, let's mirror this guy
        // by simulating a different mirrored rect. This is
        // only for dropdown menus. [samera]
        //  
        if (bMirroredWindow)           
        {
            if ((_uSide != MENUBAR_LEFT)    &&
                (_uSide != MENUBAR_RIGHT) )
            {  
                int x;
                int iW  = rcExclude.right-rcExclude.left;
                int icW = (rcChild.right-rcChild.left);


                if( icW > iW )
                {
                    x = icW - iW;
                    rcExclude.left  -= x ;
                    rcExclude.right -= x ;
                }
                else
                {
                    x = iW - icW;
                    rcExclude.left  += x;
                    rcExclude.right += x;
                }

                ppt->x = rcExclude.left;
            }

        }

        TraceMsg(DM_POPUP, "Parent Side is %d ", _uSide);
        switch(_uSide) 
        {
        case MENUBAR_LEFT :
            rcDesired.left = rcExclude.left - rcChild.right;  // right is width
            rcDesired.top  = rcExclude.top;
            break;

        case MENUBAR_RIGHT :
            rcDesired.left = rcExclude.right;
            rcDesired.top  = rcExclude.top;
            break;
            
        case MENUBAR_TOP:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.top - rcChild.bottom;  // bottom is height
            break;

        case MENUBAR_BOTTOM:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.bottom;
            break;

        default:
            rcDesired.left   = _pt.x;
            rcDesired.top    = _pt.y;
        }
    }
    else
    {
        SetRectEmpty(&rcExclude);

        rcDesired.left   = _pt.x;
        rcDesired.top    = _pt.y;
    }

    rcDesired.right  =  rcDesired.left + RECTWIDTH(rcChild);
    rcDesired.bottom =  rcDesired.top + RECTHEIGHT(rcChild);

    _GetPopupWindowPosition(&rcDesired, &rcExclude, &rc, &sizeAdjust, _uSide);

    UINT uFlags = SWP_NOOWNERZORDER;
    if (!bSetFocus)
        uFlags |= SWP_NOACTIVATE;

    //
    // Open the menus properly. In case of a RTL mirrored window,
    // flip the animation side. [samera]
    //
    if( bMirroredWindow )
    {
        switch( _uSide )
        {
        case MENUBAR_LEFT:
            uAnimateSide = MENUBAR_RIGHT;
        break;
        case MENUBAR_RIGHT:
            uAnimateSide = MENUBAR_LEFT;
        break;
        default:
            uAnimateSide = _uSide;
        }
    }
    else
    {
        uAnimateSide = _uSide;
    }

    TraceMsg(TF_MENUBAND, "CMenuBar::_PositionWindow (%d,%d,%d,%d)",
        rc.left, rc.top, rc.right, rc.bottom);

    // Last minuite tweak. Since we're in large icon, we need to add this
    // so that the bitmap is painted correctly.
    if(_iIconSize == BMICON_LARGE && _fExpanded)
        rc.right += 1;

    // We _DO_ want to do a Z-Order position when this flag is specified. This is
    // for full repositioning where we need to preserve the overlap state of all bands.
    // Otherwize we just want to size the bar without changing it's z-order.
    if (!(dwFlags & MPPF_FORCEZORDER) && 
        (S_OK == IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild,
         &CGID_MenuBand, MBANDCID_ISINSUBMENU, 0, NULL, NULL)))
    {
        uFlags |= SWP_NOZORDER;
    }

    // If it's bigger than this magical number, then we don't animate. change to taste
  
    if (RECTHEIGHT(rc) > MAGICAL_NO_FADE_HEIGHT)
        dwFlags |= MPPF_NOANIMATE;

    AnimateSetMenuPos(_hwnd, &rc, uFlags, uAnimateSide, dwFlags & MPPF_NOANIMATE);

    // Save information so we can later resize this window
    // We already have: _pt, _uSide
    if (prcExclude)
    {
        _fExcludeRect = TRUE;
        CopyRect(&_rcExclude, (RECT*)prcExclude);
    }
    else
        _fExcludeRect = FALSE;
    return S_OK;
} 

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CMenuDeskBar::Popup(POINTL* ppt, RECTL* prcExclude, DWORD dwFlags)
{
    HRESULT hr;

    // Is the caller telling us to reposition?
    if (dwFlags & MPPF_REPOSITION)
    {
        if (ppt == NULL)
            ppt = (POINTL*)&_pt;

        if (prcExclude == NULL)
            prcExclude = (RECTL*)&_rcExclude;

        // Yes; Then we don't need to do any First show stuff.
        _PositionWindow(ppt, prcExclude, dwFlags);
        return S_OK;
    }

    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));



    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    if (g_dwStopWatchMode)
        StopWatch_Start(SWID_MENU, TEXT("Menu Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);
    
    if (_pmpParent) 
    {
        _pmpParent->SetSubMenu(this, TRUE);
    }

    IOleCommandTarget* poct;
    hr = IUnknown_QueryService(_punkChild, SID_SMenuBandChild, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (SUCCEEDED(hr))
    {
        // We need to do this before the ShowDW. This saves us from doing the setting twice
        // Because in the ShowDW of MenuBand, we actually go an initialize the toolbar with
        // the current default setting which should be "No Keyboard Cues." If we set the state
        // here, then the state will be "Show keyboard cues." Then we will update the toolbar. 
        if (dwFlags & MPPF_KEYBOARD)
            poct->Exec(&CGID_MenuBand, MBANDCID_KEYBOARD, 0, NULL, NULL);
    }
    else
    {
        ASSERT(poct == NULL);
    }
    
    _NotifyModeChange(_dwMode);
    hr = ShowDW(TRUE);

    if (SUCCEEDED(hr) && _pmpParent)
    {
        VARIANT varg;
        hr = IUnknown_Exec(_pmpParent, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &varg);
        if (SUCCEEDED(hr))
        {
            if (varg.vt == VT_I4)
            {
                _uSide = (UINT) varg.lVal;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IEPlaySound(TEXT("MenuPopup"), TRUE);

        _PositionWindow(ppt, prcExclude, dwFlags);

        // Set focus
        UIActivateIO(TRUE, NULL);
    
        _fActive = TRUE;

        // Select the first/last item?
        if ((dwFlags & (MPPF_INITIALSELECT | MPPF_FINALSELECT)) && poct)
        {
            DWORD nCmd = (dwFlags & MPPF_INITIALSELECT) ? MBSI_FIRSTITEM : MBSI_LASTITEM;
            poct->Exec(&CGID_MenuBand, MBANDCID_SELECTITEM, nCmd, NULL, NULL);
        }
    }

    ATOMICRELEASE(poct);
    
    if (g_dwStopWatchMode)
    {
        TCHAR szMenu[32];
        TCHAR szText[256];

        *szMenu = '\0';
        if(g_hmenuStopWatch != NULL)
            GetMenuString(g_hmenuStopWatch, 0, szMenu, ARRAYSIZE(szMenu)-1, MF_BYPOSITION);

        wnsprintf(szText, ARRAYSIZE(szText) - 1, TEXT("Menu %d %s%sStop"), g_idCmdStopWatch, szMenu, *szMenu ?TEXT(" ") :TEXT(""));
        StopWatch_Stop(SWID_MENU, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
    }

    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
        
    return hr;
} 


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

Returns: 
Cond:    --
*/
HRESULT CMenuDeskBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CMenuDeskBar::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    if (_fShow)
        _PopDown();

    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pmpParent);
    
    _punkSite = punkSite;
    
    if (_punkSite)
    {    
        _punkSite->AddRef();
        IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &_pmpParent));
    }
    else
    {
        CloseDW(0);
    }
        
    return S_OK;
} 


/*----------------------------------------------------------
Purpose: IObjectWithSite::GetSite method

*/
STDMETHODIMP CMenuDeskBar::GetSite(REFIID riid, LPVOID* ppvSite)
{
    if (_punkSite)
    {
        return _punkSite->QueryInterface(riid, ppvSite);
    }

    *ppvSite = NULL;
    return E_FAIL;
} 

void CMenuDeskBar::AdjustForTheme()
{
    if (_fFlatMenuMode)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_BORDER);
    }
    else if (!_fExpanded)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_CLIPCHILDREN | WS_DLGFRAME);
    }
}


/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec method

*/
STDMETHODIMP CMenuDeskBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBCID_EMPTY:
            // if we have no bands left, close
            OnSelect(MPOS_FULLCANCEL);
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case MBCID_GETSIDE :
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _GetSide();
                return S_OK;

            case MBCID_RESIZE:
                if (_fActive)
                {
                    if (_fExcludeRect)
                        _PositionWindow((POINTL *)&_pt, (RECTL *)&_rcExclude, 0);
                    else
                        _PositionWindow((POINTL *)&_pt, NULL, 0);
                }
                return S_OK;

            case MBCID_SETEXPAND:
                if ((BOOL)_fExpanded != (BOOL)nCmdexecopt && !_fFlatMenuMode)
                {
                    _fExpanded = nCmdexecopt;

                    SetExpandedBorder(_hwnd, _fExpanded);
                }
                return S_OK;

            case MBCID_SETFLAT:
                {
                    _fFlatMenuMode = BOOLIFY(nCmdexecopt);
                    AdjustForTheme();
                }
                break;

            case MBCID_NOBORDER:
                {
                    _fNoBorder = BOOLIFY(nCmdexecopt);
                    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
                }
                break;

            default : 
                return OLECMDERR_E_NOTSUPPORTED;

        }   
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}    

    
/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuPopup)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
             IsEqualIID(guidService, SID_SMenuBandChild))
    {
        // SID_SMenuBandBottom queries down
        return IUnknown_QueryService(_punkChild, guidService, riid, ppvObj);
    }
    else
    {
        HRESULT hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
        
        if (FAILED(hres))
        {
            hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
        }
        
        return hres;
    }
        
} 

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetIconSize(DWORD iIcon)
{
    HRESULT hres;

    _iIconSize = iIcon;

    hres = IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild, &CGID_MenuBand, 
        MBANDCID_SETICONSIZE, iIcon == BMICON_SMALL? ISFBVIEWMODE_SMALLICONS: ISFBVIEWMODE_LARGEICONS, NULL, NULL);


    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetBitmap(HBITMAP hBitmap)
{
    ASSERT(hBitmap);
    BITMAP bm;
    _hbmp = hBitmap;

    if (_hbmp)
    {
        if(!GetObject(_hbmp, sizeof(bm), &bm))
            return E_FAIL;
        _sizeBmp.cx = bm.bmWidth;
        _sizeBmp.cy = bm.bmHeight;

        // Hack to get color
        HDC hdc = GetDC(_hwnd);
        if (hdc)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, _hbmp);
                _rgb = GetPixel(hdcMem, 0, 0);
                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }
            ReleaseDC(_hwnd, hdc);
        }
    }

    return NOERROR;
}

void CMenuDeskBar::_OnSize()
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);

    if(_iIconSize == BMICON_LARGE)
    {
        rc.left += _sizeBmp.cx;
        if (_fExpanded)
            rc.left++;
    }

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER|SWP_FRAMECHANGED);

    rc.right = rc.left;
    rc.left -= _sizeBmp.cx;
    if (_fShow)
        InvalidateRect(_hwnd, &rc, TRUE);
}

LRESULT CMenuDeskBar::_DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags)
{
    HDC hdcmem;
    HBITMAP hbmpOld;
    RECT rc;
    HBRUSH   hbrush;
    int iDC = SaveDC(hdc);

    GetClientRect(hwnd, &rc);

    //Create a compatable DC
    hdcmem = CreateCompatibleDC(hdc);
    if(hdcmem)
    {
        // Offset the stuff we're paining if we're expanded
        BYTE bOffset = 0;
        // Store this for the Bar fill cycle
        int cyBitmap = 0;

        if (!_fFlatMenuMode)
        {
            bOffset = _fExpanded? 1 : 0;
        }

        if (_sizeBmp.cy <= RECTHEIGHT(rc) + 1)
        {
            //Select the bitmap into the memory DC
            hbmpOld = (HBITMAP)SelectObject(hdcmem, _hbmp);

            //Blit to the window
            BitBlt(hdc, bOffset, rc.bottom - _sizeBmp.cy - bOffset, _sizeBmp.cx, _sizeBmp.cy, hdcmem, 0, 0, SRCCOPY);

            // Ok, We need to subtract this value to see how much we need to paint for the banner.
            cyBitmap = _sizeBmp.cy;

            //Restore the DC
            SelectObject(hdcmem, hbmpOld);
        }

        rc.right = _sizeBmp.cx + bOffset;

        if (_fExpanded && !_fFlatMenuMode && !_fNoBorder)
            DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_LEFT | BF_TOP | BF_BOTTOM);

        //Paint the rest
        hbrush = CreateSolidBrush(_rgb);
        if(hbrush)
        {
            rc.bottom -= cyBitmap + bOffset;

            if (_fExpanded)
            {
                rc.left += bOffset;
                rc.top += bOffset;
            }

            FillRect(hdc, &rc, hbrush);
            DeleteObject(hbrush);
        }


        //Delete the DC.
        DeleteDC(hdcmem);
    }

    RestoreDC(hdc, iDC);
    return 0;
}

void CMenuDeskBar::_DoNCPaint(HWND hwnd, HDC hdc)
{
    if (!_fNoBorder)
    {
        RECT rc;

        // Since we need to paint the border, we get the window rect
        GetWindowRect(hwnd, &rc);
        // then change the rect so that it represents values relative to 
        // the origin.
        OffsetRect(&rc, -rc.left, -rc.top);

        if (hdc)
        {
            if (_fFlatMenuMode)
            {
                SHOutlineRect(hdc, &rc, GetSysColor(COLOR_3DSHADOW));
            }
            else 
                DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);
        }
    }
}


LRESULT CMenuDeskBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    LRESULT lres;

    switch (uMsg) 
    {
#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
        break;
#endif

    case WM_GETOBJECT:
        if (lParam == OBJID_MENU)
        {
            IAccessible* pacc;
            if (SUCCEEDED(QueryService(SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc))))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
                pacc->Release();

                return lres;
            }
        }
        break;


    case WM_NCCREATE:
        //
        // Since this is a mirrored menu, then open it
        // on the left (mirrored) edge if possible. WillFit(...) will
        // ensure this for us [samera]
        //
        // Mirror the menu initially if its window is mirrored
        //
        ASSERT(_uSide == 0);
        if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            _uSide = MENUBAR_LEFT;
        else
            _uSide = MENUBAR_RIGHT;
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) 
        {
            if (_fActive && !_pmpChild) 
            {
                
                // if we were active, and the thing going active now
                // is not one of our parent menubars, then cancel everything.
                
                // if it's a parent of ours going active, assume that
                // they will tell us to die when they want us to...
                if (!_IsMyParent((HWND)lParam))
                    OnSelect(MPOS_FULLCANCEL);
            }
        } 
        else 
        {
            if (_pmpChild) 
            {
                // if we're becoming active, and we have a child, that child should go away
                _pmpChild->OnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case WM_PRINTCLIENT:
        if (_iIconSize == BMICON_LARGE)
        {
            _DoPaint(hwnd, (HDC)wParam, (DWORD)lParam);
            return 0;
        }
        break;

    case WM_PAINT:
        // Paint the banner if we're in showing large icons
        if (_iIconSize == BMICON_LARGE)
        {
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            _DoPaint(hwnd, ps.hdc, 0);
            EndPaint(hwnd, &ps);
            return 0;
        }
        break;

   case WM_PRINT:
        if ((_fFlatMenuMode || _fExpanded) && PRF_NONCLIENT & lParam)
        {
            HDC hdc = (HDC)wParam;

            DefWindowProcWrap(hwnd, WM_PRINT, wParam, lParam);

            // Do this after so that we look right...
            _DoNCPaint(hwnd, hdc);

            return 1;
        }
        break;

    case WM_NCCALCSIZE:
        if (_fNoBorder)
        {
            return 0;
        }
        else
        {
            return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        break;

    case WM_NCPAINT:
        if (_fNoBorder)
        {
            return 0;
        }
        else if (_fExpanded || _fFlatMenuMode)
        {    
            HDC hdc;    
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                _DoNCPaint(hwnd, hdc);
                ReleaseDC(hwnd, hdc);
            }
            return 1;
        } 
        break;

    case WM_NCHITTEST:
        lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

        switch (lres)
        {
        case HTBOTTOM:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTLEFT:
        case HTRIGHT:
        case HTTOP:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            // Don't allow the window to be resized
            lres = HTBORDER;
            break;

        case HTTRANSPARENT:
            // Don't let a click go thru to the window underneath
            lres = HTCLIENT;
            break;

        }
        return lres;

        // HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
        // (lamadio) 1.25.99
        // This hack is here to fix a problem on down level Windows with Integrated
        // IE4.01, IE5 and Office 2000.
        // The bug revolves around Start Menu not being destroyed when Explorer.exe shuts
        // down. Start Menu unregisters itself at CloseDW, but since the menubar never gets
        // destroyed, Start Menu never deregisters itself.
        // When an System service, such as MSTASK.dll keeps shell32 alive in the background,
        // it leaves an outstanding reference to a change notify. When a new user logs in,
        // O2k and IE5 fire up group conv, generating more than 10 change notify events in the
        // start menu. This causes the batching code to be fired up: Which does not really
        // work without the shell started. GroupConv also adds these events using memory 
        // alloced from it's process heap. Since there is an outstanding change notify handler
        // these pidls get forced to be handled. Shell32 then faults derefing a bad pidl.
        // By detecting an Endsession, we can eliminate this problem. Doing a SetClient(NULL)
        // cause Menubar to free it's references to MenuSite. Menusite, calls CloseDW on menuband
        // menuband then causes MNFolder to unregister itself. Since no one is listening any more
        // the crash is avoided.

    case WM_ENDSESSION:
        if (wParam != 0)
        {
            SetClient(NULL);
        }
        break;

    }
    
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
} 

IMenuPopup* CMenuDeskBar::_GetMenuBarParent(IUnknown* punk)
{
    IMenuPopup *pmp = NULL;
    IObjectWithSite* pows;
    punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));

    if (pows)
    {    
        IServiceProvider* psp;
        pows->GetSite(IID_PPV_ARG(IServiceProvider, &psp));
        
        if (psp)
        {    
            psp->QueryService(SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
            psp->Release();
        }
        
        pows->Release();
    }
    
    return pmp;
}


// this assumes that hwnd is a toplevel window and that the menudeskbars are also 
// the only hosts and are themselves toplevel
BOOL CMenuDeskBar::_IsMyParent(HWND hwnd)
{
    BOOL fRet = FALSE;
    if (hwnd)
    {
        HWND hwndMenu;
        
        IMenuPopup *pmpParent = _pmpParent;
        if (pmpParent)
            pmpParent->AddRef();
        
        while (pmpParent && !fRet &&
               SUCCEEDED(IUnknown_GetWindow(pmpParent, &hwndMenu)))
        {
            if (hwndMenu == hwnd)
            {
                fRet = TRUE;
            }
            
            IMenuPopup* pmpNext = _GetMenuBarParent(pmpParent);
            pmpParent->Release();
            pmpParent = pmpNext;
        }
    }

    return fRet;
}

IMenuPopup* CreateMenuPopup(IMenuPopup* pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return CreateMenuPopup2(pmpParent, NULL, psf, pidl, pbi, bMenuBand);
}

IMenuPopup* CreateMenuPopup2(IMenuPopup* pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    
    ASSERT(pmb == NULL || IS_VALID_CODE_PTR(pmb, IMenuBand));
    ASSERT(psf == NULL || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(pmpParent == NULL || IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(pidl && IS_VALID_PIDL(pidl));
    ASSERT(pbi == NULL || IS_VALID_READ_PTR(pbi, BANDINFOSFB));

    IMenuPopup* pmp = NULL;
    IDeskBand *pdb = NULL;
    IBandSite *pbs = NULL;
    HRESULT hres = E_FAIL;

    if (!pdb) 
    {
        TraceMsg(TF_MENUBAND, "CreateMenuPopup2 : Did not find a this (0x%x) band.", pidl);

        if (bMenuBand)
        {
            pdb = CMenuBand_Create(psf, pidl, FALSE);
        }
        else
            pdb = CISFBand_CreateEx(psf, pidl);

        if (pdb) 
        {
            if (pbi) 
            {
                IShellFolderBand *pisfBand;
                if (SUCCEEDED(pdb->QueryInterface(IID_IShellFolderBand, (LPVOID*)&pisfBand))) 
                {
                    pisfBand->SetBandInfoSFB(pbi);
                    pisfBand->Release();
                }
            }

            if (!pmpParent) 
            {
                const CLSID * pclsid;

                if (bMenuBand)
                    pclsid = &CLSID_MenuBandSite;
                else
                    pclsid = &CLSID_RebarBandSite;

                CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (LPVOID*)&pbs);

                if (pbs) 
                {

                    if (bMenuBand)
                    {
                        BANDSITEINFO bsinfo;

                        // Don't show the gripper for vertical menubands
                        bsinfo.dwMask = BSIM_STYLE;
                        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
                        pbs->SetBandSiteInfo(&bsinfo);
                    }

                    CMenuDeskBar *pcmdb = new CMenuDeskBar();
                    if (pcmdb)
                    {
                        if (SUCCEEDED(pcmdb->SetClient(pbs))) 
                            pcmdb->QueryInterface(IID_IMenuPopup, (LPVOID *)&pmp);

                        pcmdb->Release();
                    }
                }
            }

            if (pbs) 
            {
                pbs->AddBand(pdb);
            }
        }
    }
    
    ATOMICRELEASE(pdb);
    ATOMICRELEASE(pbs);
    if (!pmp)
        IUnknown_Set((IUnknown**) &pmp, pmpParent);
    

    return pmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\mrulist.cpp ===
/**************************************************************\
    FILE: mrulist.cpp

    DESCRIPTION:
        CMRUList implements the Shell Name Space List or DriveList.
    This will store a pidl and be able to populate the AddressBand
    combobox with the shell name space that includes that PIDL.
\**************************************************************/

#include "priv.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "autocomp.h"
#include <urlhist.h>
#include <winbase.h>
#include <wininet.h>

#define SUPERCLASS CAddressList



///////////////////////////////////////////////////////////////////
// #DEFINEs
#define MRU_LIST_MAX_CONST            25

///////////////////////////////////////////////////////////////////
// Data Structures
typedef struct tagSIZESTRCOMBO
{
    DWORD dwStringSize; // Size in Characters (not bytes)
    LPTSTR lpszString;
    int iImage;
    int iSelectedImage;
} SIZESTRCOMBO;

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CMRUList

    DESCRIPTION:
        The MRU List will contain the type MRU history for the
    browser.  This is an IAddressList used by the Address Band/Bar.
\**************************************************************/

class CMRUList  : public CAddressList
                , public IMRU
                , public IPersistStream
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP Refresh(DWORD dwType);
    virtual STDMETHODIMP Save(void);

  // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_MRUList; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm) { return S_OK; }
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP IsDirty(void) { return S_FALSE; }
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize) { return E_NOTIMPL; }

    // *** IMRU methods ***
    virtual STDMETHODIMP AddEntry(LPCWSTR pszEntry);


    // IWinEventHandler
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CMRUList();
    ~CMRUList(void);        // This is now an OLE Object and cannot be used as a normal Class.

    // Address List Modification Functions
    HRESULT _UpdateMRUEntry(LPCTSTR szNewValue, int nIndex, int iImage , int iISelectedImage);
    HRESULT _LoadList(void);
    HKEY _GetRegKey(BOOL fCreate);
    HRESULT _UpdateMRU(void);
    int _FindInMRU(LPCTSTR szURL);
    HRESULT _MRUMerge(HKEY kKey);
    BOOL _MoveAddressToTopOfMRU(int nMRUIndex);
    HRESULT _PopulateOneItem(void);
    HRESULT _Populate(void);
    void _InitCombobox(void);
    HRESULT _SetTopItem(void);

    // Friend Functions
    friend IAddressList * CMRUList_Create(void);

    //////////////////////////////////////////////////////
    //  Private Member Variables
    //////////////////////////////////////////////////////
    BOOL                _fDropDownPopulated;// Have we populated the drop down yet?
    BOOL                _fListLoaded;       // Have we loaded the Type-in MRU?
    BOOL                _fMRUUptodate;      // Is it necessary to update the MRU?
    BOOL                _fNeedToSave;      // Do we need to update the registry?
    SIZESTRCOMBO        _szMRU[MRU_LIST_MAX_CONST];  // MRU list.
    int                 _nMRUSize;          // Number of entries in MRU used.
};




//=================================================================
// Implementation of CMRUList
//=================================================================


/****************************************************\
    FUNCTION: CMRUList_Create

    DESCRIPTION:
        This function will create an instance of the
    CMRUList COM object.
\****************************************************/
IAddressList * CMRUList_Create(void)
{
    CMRUList *p = new CMRUList();

    return p;
}


/****************************************************\

    Address Band Constructor

\****************************************************/
CMRUList::CMRUList()
{
}


/****************************************************\

    Address Band destructor

\****************************************************/
CMRUList::~CMRUList()
{
    // loop through every potential saved URL in registry.
    if (_fListLoaded)
    {
        for (int nIndex = 0; (nIndex < MRU_LIST_MAX_CONST) && (_szMRU[nIndex].lpszString); nIndex++)
        {
            LocalFree(_szMRU[nIndex].lpszString);
        }
    }
}


//===========================
// *** IUnknown Interface ***
HRESULT CMRUList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IMRU))
    {
        *ppvObj = SAFECAST(this, IMRU*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid,ppvObj);
    }

    AddRef();
    return S_OK;
}

ULONG CMRUList::AddRef()
{
    return SUPERCLASS::AddRef();
}

ULONG CMRUList::Release()
{
    return SUPERCLASS::Release();
}


//================================
// *** IAddressList Interface ***

/****************************************************\
    FUNCTION: Connect

    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/

HRESULT CMRUList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    HRESULT hr = S_OK;

    _fVisible = fConnect;
    if (!_hwnd)
        _hwnd = hwnd;
    ASSERT(_hwnd);

    if (fConnect)
    {
        // This needs to come before because it setups up
        // pointers that we need.
        SUPERCLASS::Connect(fConnect, hwnd, pbs, pbp, pac);

        // Initial combobox parameters.
        if (_pbp && _pbp->IsConnected() == S_FALSE)
        {
            // Do these tasks only the first time and only if
            // we are not in a browser window (because it will come
            // from the navigation complete).
            _PopulateOneItem();
        }
    }
    else
    {
        _UpdateMRU();    // Save contents of MRU because the ComboBox will be purged.
        _fDropDownPopulated = FALSE;

        // This call needs to come after _UpdateMRU() because
        // it releases pointers that we need.
        SUPERCLASS::Connect(fConnect, hwnd, pbs, pbp, pac);
    }
    return hr;
}


/****************************************************\
    FUNCTION: _SetTopItem

    DESCRIPTION:
        TODO.
\****************************************************/
HRESULT CMRUList::_SetTopItem(void)
{
    COMBOBOXEXITEM cbexItem = {0};
    LPCTSTR pszData = _szMRU[0].lpszString;

    if (pszData) {
        cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        cbexItem.iItem = -1;
        cbexItem.pszText =(LPTSTR)pszData;
        cbexItem.cchTextMax = lstrlen(pszData);
        if(_szMRU[0].iImage == -1 ||  _szMRU[0].iSelectedImage == -1) {
            _GetUrlUI(NULL,pszData, &(_szMRU[0].iImage),\
                                      &(_szMRU[0].iSelectedImage));
        }

        cbexItem.iImage =_szMRU[0].iImage;
        cbexItem.iSelectedImage = _szMRU[0].iSelectedImage;

        SendMessage(_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
    }
    return S_OK;
}


//================================
// *** IMRU Interface ***
/*******************************************************************
    FUNCTION: AddEntry

    DESCRIPTION:
        Adds the specified URL to the top of the address bar
    combo box.  Limits the number of URLs in combo box to
    MRU_LIST_MAX_CONST.
********************************************************************/
HRESULT CMRUList::AddEntry(LPCWSTR pszEntry)
{
    HRESULT hr = S_OK;

    _fNeedToSave = TRUE;
    if (_fDropDownPopulated)
    {
        _ComboBoxInsertURL(pszEntry, MAX_URL_STRING, MRU_LIST_MAX_CONST);
        _fMRUUptodate = FALSE;
    }
    else
    {
        int nMRUIndex;

        if (!_fListLoaded)
            _LoadList();

        // Since we don't own the ComboBox, we need to add it to
        // the end of our MRU data.
        nMRUIndex = _FindInMRU(pszEntry);  // Now make it the top most.

        if (-1 != nMRUIndex)
        {
            // We already have this entry in our list, so all we need
            // to do is move it to the top.
            _MoveAddressToTopOfMRU(nMRUIndex);
            return hr;
        }


        for (nMRUIndex = 0; nMRUIndex < MRU_LIST_MAX_CONST; nMRUIndex++)
        {
            if (!_szMRU[nMRUIndex].lpszString)
            {   // We found an empty spot.
                _UpdateMRUEntry(pszEntry, nMRUIndex, -1, -1);
                break;  // We are done.
            }
        }



        if (MRU_LIST_MAX_CONST == nMRUIndex)
        {
            // The MRU is full so we will replace the last entry.
            _UpdateMRUEntry(pszEntry, --nMRUIndex, -1, -1);
        }

        _MoveAddressToTopOfMRU(nMRUIndex);  // Now make it the top most.
    }
    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: AddEntry(), URL=%s", pszEntry);
    return hr;
}


//================================
// *** IPersistStream Interface ***

/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        TODO.
\****************************************************/

HRESULT CMRUList::Save(IStream *pstm, BOOL fClearDirty)
{
    // APPCOMPAT: There currently is a bug in the shell that it leaks
    //         an object.  This causes CAddressBand to never be
    //         destructed when hosted in the TaskBar.
    //         Since we normally call IAddressList::SaveList() in the
    //         destructor, we will now need to call it
    //         from here in that case.
    if (_pbp && _pbp->IsConnected() == S_FALSE)
    {
        Save();
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: _InitCombobox

    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/

void CMRUList::_InitCombobox()
{
    HIMAGELIST himlSysSmall;
    Shell_GetImageLists(NULL, &himlSysSmall);

    SendMessage(_hwnd, CBEM_SETIMAGELIST, 0, (LPARAM)himlSysSmall);
    SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE, 0,0);
    SUPERCLASS::_InitCombobox();
}

HKEY CMRUList::_GetRegKey(BOOL fCreate)
{
    BOOL fIsConnected = FALSE;
    HKEY hKey;
    DWORD result;
    LPCTSTR pszKey;

    if (_pbp)
        fIsConnected = (_pbp->IsConnected() == S_OK);
    if (fIsConnected)
        pszKey = SZ_REGKEY_TYPEDURLMRU;
    else
        pszKey = SZ_REGKEY_TYPEDCMDMRU;

    if (fCreate)
        result = RegCreateKey(HKEY_CURRENT_USER, pszKey, &hKey);
    else
        result = RegOpenKey(HKEY_CURRENT_USER, pszKey, &hKey);

    if (result != ERROR_SUCCESS)
        return NULL;

    return hKey;
}

/****************************************************\
    FUNCTION: _LoadList

    DESCRIPTION:
        When the ComboBox is switched to this MRU
    AddressList, the contents need to be populated.  Before
    that happens, we copy the data to the combobox
    from the registry.
\****************************************************/

HRESULT CMRUList::_LoadList(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD dwCount;
    TCHAR szAddress[MAX_URL_STRING+1];

    ASSERT(!_fListLoaded);
    ASSERT(_hwnd);

    hKey = _GetRegKey(TRUE);
    ASSERT(hKey);
    if (!hKey)
        return E_FAIL;


    for (dwCount = 0; dwCount < MRU_LIST_MAX_CONST ; dwCount++)
    {
        hr = GetMRUEntry(hKey, dwCount, szAddress, SIZECHARS(szAddress), NULL);

        if (SUCCEEDED(hr))
            _UpdateMRUEntry(szAddress, (int)dwCount, -1, -1);
        else
        {
            _szMRU[dwCount].lpszString = NULL;
            _szMRU[dwCount].iImage = -1;
            _szMRU[dwCount].iSelectedImage = -1;
        }
    }


    RegCloseKey(hKey);
    _fListLoaded = TRUE;

    return hr;
}


/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        When this object is closed, we save the contents
    to the registry.
\****************************************************/

HRESULT CMRUList::Save(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD result;
    TCHAR szValueName[10];   // big enough for "url99"
    int nCount;
    int nItems = (_fDropDownPopulated) ? ComboBox_GetCount(_hwnd) : _nMRUSize;

    if (!_fListLoaded || !_fNeedToSave) // Don't save the registry if we don't need to.
        return S_OK;

    if (!_fMRUUptodate)
        hr = _UpdateMRU();

    hKey = _GetRegKey(TRUE);
    ASSERT(hKey);
    if (!hKey)
        return E_FAIL;

    hr = _MRUMerge(hKey);  // Merge if the list has been modified.

    // loop through every potential saved URL in registry.
    for (nCount = 0; nCount < MRU_LIST_MAX_CONST; nCount++)
    {
        // make a value name a la "url1" (1-based for historical reasons)
        wnsprintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, nCount+1);

        // for every combo box item we have, get the corresponding
        // text and save it in the registry
        if (nCount < nItems && _szMRU[nCount].lpszString)
        {
            // store it in registry and off to the next one.
            result = SHSetValue(hKey, NULL, szValueName, REG_SZ, (CONST BYTE *) _szMRU[nCount].lpszString,
                    _szMRU[nCount].dwStringSize*SIZEOF(TCHAR));
        }
        else
        {
            // if we get here, we've run out of combo box items (or
            // failed to retrieve text for one of them).  Delete any
            // extra items that may be lingering in the registry.
            SHDeleteValue(hKey, NULL, szValueName);
        }
    }
    _fNeedToSave = FALSE;

    RegCloseKey(hKey);
    return hr;
}


/****************************************************\
    FUNCTION: _MRUMerge

    DESCRIPTION:
        This function will merge the current contents
    of the saved MRU.  This means that if the Address
    Band is being closed, it will load the MRU again
    because it could have been saved by a AddressBar
    that was recently closed down.  The merge happens
    like this: If the MRU is not full, items
    in the registry will be appended to the end
    of the MRU if they don't currently exist in the
    MRU.
\****************************************************/
HRESULT CMRUList::_MRUMerge(HKEY hKey)
{
    HRESULT hr = S_OK;
    UINT nCount;
    UINT nNextFreeSlot = _nMRUSize;
    long lResult;
    TCHAR szValueName[10];   // big enough for "url99"
    TCHAR szAddress[MAX_URL_STRING+1];
    DWORD dwAddress;

    ASSERT(_fListLoaded);
    ASSERT(hKey);


    for (nCount = 0; (nCount < MRU_LIST_MAX_CONST) && (nNextFreeSlot < MRU_LIST_MAX_CONST); nCount++)
    {
        // make a value name a la "url1" (1-based for historical reasons)
        wnsprintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, nCount+1);

        dwAddress = SIZEOF(szAddress);

        lResult = SHQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) szAddress, &dwAddress);
        if (ERROR_SUCCESS == lResult)
        {
            if (-1 == _FindInMRU(szAddress))
            {
                // We found a unique item.  Add it to our free slot.
                _UpdateMRUEntry(szAddress, nNextFreeSlot++, -1, -1);
            }
        }
        else
            break;
    }


    // REARCHITECT: Because the AddressBand is always closed after all
    //         AddressBars when the shell is shut down, anything
    //         new in the AddressBars will be ignored if the
    //         MRU in the AddressBand is full.  Revisit.

    return hr;
}


/****************************************************\
    FUNCTION: _UpdateMRU

    DESCRIPTION:
        Save the contents of the Combobox because
    it will be purged for the next AddressList.
\****************************************************/
HRESULT CMRUList::_UpdateMRU(void)
{
    HRESULT hr = S_OK;
    TCHAR szAddress[MAX_URL_STRING+1];
    // get the number of items in combo box
    int nItems;
    int nCount;

    if (!_hwnd)
        return S_OK;

    if (!_fDropDownPopulated)
        return S_OK;        // Nothing to update.
    nItems = ComboBox_GetCount(_hwnd);

    ASSERT(_hwnd);

    // loop through every potential saved URL in registry.
    for (nCount = 0; nCount < MRU_LIST_MAX_CONST; nCount++)
    {
        // for every combo box item we have, get the corresponding
        // text and save it in our local array.
        if (nCount < nItems)
        {
            COMBOBOXEXITEM cbexItem = {0};

            cbexItem.mask = CBEIF_TEXT|CBEIF_IMAGE|CBEIF_SELECTEDIMAGE;
            cbexItem.pszText = szAddress;
            cbexItem.cchTextMax = ARRAYSIZE(szAddress);
            cbexItem.iItem = nCount;

            if (SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM) &cbexItem))
            {
                hr = _UpdateMRUEntry(szAddress, nCount, cbexItem.iImage, cbexItem.iSelectedImage);
            }
        }
        else
        {
            if (_szMRU[nCount].lpszString)
            {
                // Free this array entry because it's not being used.
                LocalFree(_szMRU[nCount].lpszString);
                _szMRU[nCount].lpszString = NULL;
                _szMRU[nCount].iImage = -1;
                _szMRU[nCount].iSelectedImage = -1;

                _nMRUSize--;
            }
        }
    }
    _fMRUUptodate = TRUE;

    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: _UpdateMRU().");
    return hr;
}


/****************************************************\
    FUNCTION: _UpdateMRUEntry

    DESCRIPTION:
        When the ComboBox is switched to this MRU
    AddressList, the contents need to be populated.  Before
    that happens, we copy the data to the combobox
    from the registry.
\****************************************************/
HRESULT CMRUList::_UpdateMRUEntry(LPCTSTR szNewValue, int nIndex, int iImage , int iSelectedImage)
{
    DWORD dwStrSize = lstrlen(szNewValue);

    if (!szNewValue)
    {
        // The caller wants us to free the string.
        if (_szMRU[nIndex].lpszString)
        {
            // We have a string that needs freeing.
            LocalFree(_szMRU[nIndex].lpszString);
            _szMRU[nIndex].lpszString = NULL;
            _nMRUSize--;
        }
        return S_OK;
    }

    if (!(_szMRU[nIndex].lpszString))
    {
        // We need to create the string buffer
        _szMRU[nIndex].dwStringSize = dwStrSize+1;
        _szMRU[nIndex].lpszString = (LPTSTR) LocalAlloc(LPTR, _szMRU[nIndex].dwStringSize*SIZEOF(TCHAR));
        if (!(_szMRU[nIndex].lpszString))
            return E_FAIL;
        _nMRUSize++;
    }

    if (dwStrSize + 1 > _szMRU[nIndex].dwStringSize)
    {
        // We need to increase the size of the buffer.
        LocalFree(_szMRU[nIndex].lpszString);
        _szMRU[nIndex].dwStringSize = dwStrSize+1;
        _szMRU[nIndex].lpszString = (LPTSTR) LocalAlloc(LPTR, _szMRU[nIndex].dwStringSize*SIZEOF(TCHAR));
        if (!(_szMRU[nIndex].lpszString))
            return E_FAIL;
    }

    lstrcpyn(_szMRU[nIndex].lpszString, szNewValue, _szMRU[nIndex].dwStringSize);
    _szMRU[nIndex].iImage = iImage;
    _szMRU[nIndex].iSelectedImage = iSelectedImage;


    return S_OK;
}


/****************************************************\
    FUNCTION: _Populate

    DESCRIPTION:
        fills in the entire combo.

    WARNING!!!!!!!!:
        This is expensive, don't do it unless absolutely
    necessary!
\****************************************************/
HRESULT CMRUList::_Populate(void)
{
    HRESULT hr = S_OK;
    CShellUrl *psu;

    if (!_fListLoaded)
        hr = _LoadList();  // Load Data

    if (_fDropDownPopulated)
        return S_OK;    // We are already populated.

    psu = new CShellUrl();

    if (psu)
    {
        // We need to set the "Shell Path" so that we can find
        // the correct icons for items in "desktop" and in
        // Desktop/My Computer".
        SetDefaultShellPath(psu);

        // Give it a parent for displaying message boxes
        psu->SetMessageBoxParent(_hwnd);
            
        // read values from registry and put them in combo box
        COMBOBOXEXITEM cbexItem = {0};
        cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;

        for (cbexItem.iItem = 0; cbexItem.iItem < MRU_LIST_MAX_CONST ; cbexItem.iItem++)
        {
            if (_szMRU[cbexItem.iItem].lpszString)
            {
                cbexItem.pszText = _szMRU[cbexItem.iItem].lpszString;
                cbexItem.cchTextMax = _szMRU[cbexItem.iItem].dwStringSize;

                //Do Image creation when we actually populate
                if(_szMRU[cbexItem.iItem].iImage == -1 ||   _szMRU[cbexItem.iItem].iSelectedImage == -1) {
                    _GetUrlUI(psu,_szMRU[cbexItem.iItem].lpszString, &(_szMRU[cbexItem.iItem].iImage),\
                                                               &(_szMRU[cbexItem.iItem].iSelectedImage));
                }

                // initialize the image indexes
                cbexItem.iImage = _szMRU[cbexItem.iItem].iImage;
                cbexItem.iSelectedImage = _szMRU[cbexItem.iItem].iSelectedImage;

                SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
            }
            else
                break;  // Stop populating when we hit the max.
        }
        _fDropDownPopulated = TRUE;

        //Delete the shell url object
        delete psu;
    } else {
        // low mem
        hr = E_OUTOFMEMORY;
    }

    TraceMsg(TF_BAND|TF_GENERAL, "CMRUList: _Populate(). This is a VERY EXPENSIVE operation.");
    return hr;
}


/****************************************************\
    FUNCTION: _PopulateOneItem

    DESCRIPTION:
        This just files the ComboBox's edit control.
    We do this when we want to postpone populating
    the entire drop down list.
\****************************************************/
HRESULT CMRUList::_PopulateOneItem(void)
{
    HRESULT hr = S_OK;

    if (!_fListLoaded)
        hr = _LoadList();  // Load Data

    if (_fDropDownPopulated)
        return S_OK;    // We are already populated.

    hr = _SetTopItem();
    return hr;
}


/****************************************************\
    FUNCTION: Refresh

    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CMRUList::Refresh(DWORD dwType)
{
    HRESULT hr = S_OK;

    if (OLECMD_REFRESH_ENTIRELIST == dwType)
    {
        // Force a refresh.  We don't move the contents
        // of the of the Combobox to the MRU because the
        // user wanted to refresh the Combobox because
        // it's contents may be tainted.
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
        _fDropDownPopulated = FALSE;
    }

    return hr;
}


//================================
// *** Internal/Private Methods ***


/*******************************************************************
    FUNCTION: _MoveAddressToTopOfMRU

    PARAMETERS:
        nMRUIndex - index of be moved to top.

    DESCRIPTION:
        This function will move the specified index to the top of
    the list.
********************************************************************/
BOOL CMRUList::_MoveAddressToTopOfMRU(int nMRUIndex)
{
    int nCurrent;
    SIZESTRCOMBO sscNewTopItem;
    _fNeedToSave = TRUE;

    ASSERT(nMRUIndex < MRU_LIST_MAX_CONST);

    // Save off new top item info.
    sscNewTopItem.dwStringSize = _szMRU[nMRUIndex].dwStringSize;
    sscNewTopItem.lpszString = _szMRU[nMRUIndex].lpszString;
    sscNewTopItem.iImage  = _szMRU[nMRUIndex].iImage;
    sscNewTopItem.iSelectedImage = _szMRU[nMRUIndex].iSelectedImage;

    for (nCurrent = nMRUIndex; nCurrent > 0; nCurrent--)
    {
        // Move item down in list.
        _szMRU[nCurrent].dwStringSize = _szMRU[nCurrent-1].dwStringSize;
        _szMRU[nCurrent].lpszString = _szMRU[nCurrent-1].lpszString;
        _szMRU[nCurrent].iImage = _szMRU[nCurrent-1].iImage;
        _szMRU[nCurrent].iSelectedImage = _szMRU[nCurrent-1].iSelectedImage;
    }

    // Set new top item.
    _szMRU[0].dwStringSize    = sscNewTopItem.dwStringSize;
    _szMRU[0].lpszString      = sscNewTopItem.lpszString;
    _szMRU[0].iImage          = sscNewTopItem.iImage;
    _szMRU[0].iSelectedImage  = sscNewTopItem.iSelectedImage;

    return TRUE;
}


/*******************************************************************
    FUNCTION: _FindInMRU

    PARAMETERS:
        szURL - URL to see if it exists in list.

    DESCRIPTION:
        Search through MRU for URL.  Return value will be -1 if not
    found or index if found.
********************************************************************/
int CMRUList::_FindInMRU(LPCTSTR szURL)
{
    int nCurrent;

    for (nCurrent = 0; (nCurrent < MRU_LIST_MAX_CONST) && _szMRU[nCurrent].lpszString; nCurrent++)
    {
        if (0 == StrCmpN(_szMRU[nCurrent].lpszString, szURL, _szMRU[nCurrent].dwStringSize))
        {
            // We found it.
            return nCurrent;
        }
    }

    return -1;
}



HRESULT CMRUList::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch(uMsg) {
    case WM_WININICHANGE:
    {
        HKEY hkey = _GetRegKey(FALSE);
        if (hkey) {
            RegCloseKey(hkey);
        } else {

            // reset if the key is gone
            if (_fVisible) {
                SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
            }
            _fDropDownPopulated = FALSE;
            _fListLoaded = FALSE;
        }
    }
        break;
    }

    return SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\onetree.h ===
#ifndef _onetree_h
#define _onetree_h

#ifdef __cplusplus
extern "C" {
#endif

#define OTGetRootFolder()                 (s_pshfRoot->AddRef(), s_pshfRoot)
#define OTGetRootParentFolder()           (s_pshfRootParent->AddRef(), s_pshfRootParent)


#define OTIsShared(lpnd)                    ((lpnd)->dwAttribs & SFGAO_SHARE)
#define OTIsRemovableRoot(lpnd)             (((lpnd)->dwAttribs & (SFGAO_REMOVABLE | SFGAO_FILESYSANCESTOR)) == (SFGAO_REMOVABLE | SFGAO_FILESYSANCESTOR))
#define OTGetSubNode(lpn, szSubFolderID)    FindKid(lpn, szSubFolderID, TRUE)
#define OTGetRootNode()                     (OTAddRef(s_lpnRoot), s_lpnRoot)
#define OTInvalidateAll()                   DoInvalidateAll(s_lpnRoot, -1)
#define OTAddRef(lpnd)                      ((lpnd)->cRef++)

typedef struct _OTCompareInfo
{
    BOOL bFound;
    BOOL fRooted;
    LPSHELLFOLDER psf;
} OTCompareInfo, *LPOTCompareInfo;

typedef struct _OTEnumInfo
{
    BOOL fTimedOut : 1;
    BOOL fAllowTimeout :1;
} OTEnumInfo, *LPEnumInfo;

typedef struct _OneTreeNode
{

#ifdef DEBUG
#define OTDEBUG_SIG ((TEXT('O') << 16) + (TEXT('T') << 8) + TEXT('N'))
    DWORD       dwDebugSig;
#endif

    struct _OneTreeNode * lpnParent;

    HDPA        hdpaKids;               // HASNOKIDS || KIDSUNKNOWN || array of kids

    LPTSTR      lpText;                 // The text for this item
    int         iImage;           
    int         iSelectedImage;

    BITBOOL     fMark          : 1;
    BITBOOL     fRoot          : 1;
    BITBOOL     fInvalid       : 1;
    BITBOOL     fShared        : 1;
    BITBOOL     fRemovable     : 1;
    BITBOOL     fInserted      : 1; // this means that this item was forceably added..  it's not safe to remove it if it doesn't show up in enumeration
    BITBOOL     fHasAttributes : 1;
    BITBOOL     fValidatePidl   :1; // this means the item was invalidated specifically by fsnotify (as opposed to not fully fetched yet)
                                    // so on the next call to GetAttributesOf, we need to pass SFGAO_VALIDATE
    BYTE        cChildren;
    DWORD       dwAttribs;
    DWORD       dwDropEffect;
    DWORD       dwLastChanged;
    int         cRef;
    LPITEMIDLIST  pidl;                // this needs to be at the end because it grows
} OneTreeNode, * LPOneTreeNode;

typedef struct _NMOTFSEINFO {
    NMHDR nmhdr;
    LONG lEvent;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlExtra;
} NMOTFSEINFO, *LPNMOTFSEINFO;

#define OTN_FSE         CWM_ONETREEFSE
// from shelldll
#define IDOI_SHARE    1

#define NOKIDS          ((HDPA)-1)
#define KIDSUNKNOWN     ((HDPA)0)

extern LPOneTreeNode s_lpnRoot;
extern LPSHELLFOLDER s_pshfRoot;

extern LPSHELLFOLDER   s_pshfRoot;
extern LPSHELLFOLDER   s_pshfRootParent;

#ifdef FOR_GEORGEST
void DebugDumpNode(LPOneTreeNode lpn, LPTSTR lpsz);
#else
#define DebugDumpNode(lpn, lpsz)
#endif

BOOL OneTree_Initialize(LPCITEMIDLIST pidlRootClass);
void OneTree_Terminate();
void OneTree_GetAltColor(void);

#define OTILIsEqual(pidl1, pidl2)   IEILIsEqual((pidl1), (pidl2), FALSE)
BOOL WINAPI OTILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
BOOL OTIsCompressed(LPOneTreeNode lpNode);
BOOL OTIsBold(LPOneTreeNode lpNode);

STDAPI_(void) OTAssumeThread();

// any calls to this MUST BE IN A CRIT section!

LPITEMIDLIST OTCloneFolderID(LPOneTreeNode lpn);
LPTSTR OTGetNodeName(LPOneTreeNode lpn, LPTSTR pszText, int cch);
HRESULT WINAPI OTRealBindToFolder(LPOneTreeNode lpNode, LPSHELLFOLDER *ppshf);
LPSHELLFOLDER WINAPI OTBindToFolder(LPOneTreeNode lpnd);
HRESULT OTBindToParentFolder(LPOneTreeNode lpNode, IShellFolder **ppsf, LPITEMIDLIST *ppidlChild);
HRESULT WINAPI OTBindToParent(LPOneTreeNode lpnd, LPSHELLFOLDER *ppshf);
HRESULT WINAPI OTBindToFolderEx(LPOneTreeNode lpnd, LPSHELLFOLDER *ppshf);
HRESULT WINAPI OTRealBindToFolder(LPOneTreeNode lpNode, LPSHELLFOLDER *ppshf);
LPOneTreeNode WINAPI OTGetNthSubNode(HWND hwndOwner, LPOneTreeNode lpnd, UINT i);
void WINAPI OTInvalidateAttributeRecursive(LPOneTreeNode lpn);
BOOL WINAPI OTSubNodeCount(HWND hwndOwner, LPOneTreeNode lpNode, LPEnumInfo pei, UINT* pcnd, BOOL fInteractive);
BOOL WINAPI OTHasSubFolders(LPOneTreeNode lpnd);
void WINAPI OTNodeFillTV_ITEM(LPOneTreeNode lpnd, LPTV_ITEM lpItem);
void WINAPI OTUnregister(HWND hwndTree);
void WINAPI OTRegister(HWND hwndTree);
void WINAPI OTGetImageIndex(LPOneTreeNode lpnd, int *lpiImage, int * lpiSelectedImage);
void WINAPI OTGetDefaultImageIndices(int *lpiImage, int *lpiSelectedImage);
void WINAPI OTRelease(LPOneTreeNode lpNode);
void DoInvalidateAll(LPOneTreeNode lpNode, int iImage);
LPOneTreeNode WINAPI OTGetParent(LPOneTreeNode lpnd);
void OTActivate();

#define OTASF_ALLOWDUP          0x00000001
#define OTASF_MAYBESIMPLE       0x00000002
HRESULT WINAPI OTAddSubFolder(LPOneTreeNode lpnd, LPCITEMIDLIST pidl, DWORD dwFlags, LPOneTreeNode *ppndOut);

LPITEMIDLIST WINAPI OTCreateIDListFromNode(LPOneTreeNode lpnd);
BOOL WINAPI OTGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, int fType);

int CALLBACK OTTreeViewCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

LPOneTreeNode WINAPI OTGetNodeFromIDListEx(LPCITEMIDLIST pidl, UINT uFlags, HRESULT* phresOut);
#define OTGetNodeFromIDList(pidl, uFlags) OTGetNodeFromIDListEx(pidl, uFlags, (HRESULT*)NULL)

// onetree get node flags
#define OTGNF_VALIDATE   0x01
#define OTGNF_TRYADD     0x02
#define OTGNF_NEARESTMATCH 0x04

#ifdef __cplusplus
}
#endif


#endif // _onetree_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\nt5.cpp ===
#include "priv.h"
#include "shbrows2.h"
#include "commonsb.h"
#include "resource.h"

//
//
//  If you want NT5 defines in the above headerfiles, you gotta set _WIN32_WINNT
//  to 0x0500, which the standard browseui build does not do...
//
//  So we do it here in nt5.cpp.
//
//


// WM_APPCOMMAND handling
//
typedef struct tagAppCmd
{
    UINT idAppCmd;
    UINT idCmd;
} APPCMD;

BOOL CShellBrowser2::_OnAppCommand(WPARAM wParam, LPARAM lParam)
{
    static APPCMD rgcmd[] =
    {
        { APPCOMMAND_BROWSER_BACKWARD, FCIDM_NAVIGATEBACK },
        { APPCOMMAND_BROWSER_FORWARD, FCIDM_NAVIGATEFORWARD },
        { APPCOMMAND_BROWSER_REFRESH, FCIDM_REFRESH },
        { APPCOMMAND_BROWSER_STOP, FCIDM_STOP },
        { APPCOMMAND_BROWSER_SEARCH, FCIDM_VBBSEARCHBAND }, // FCIDM_SEARCHPAGE ?
        { APPCOMMAND_BROWSER_FAVORITES, FCIDM_VBBFAVORITESBAND },
        { APPCOMMAND_BROWSER_HOME, FCIDM_STARTPAGE },
        { APPCOMMAND_LAUNCH_MAIL, FCIDM_MAIL }
    };

    UINT idAppCmd = GET_APPCOMMAND_LPARAM(lParam);
    BOOL bRet = FALSE;

    for (int i = 0 ; i < ARRAYSIZE(rgcmd) ; i++)
    {
        if (rgcmd[i].idAppCmd == idAppCmd)
        {
            OnCommand(GET_WM_COMMAND_MPS(rgcmd[i].idCmd,
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         GET_WM_COMMAND_CMD(wParam, lParam)));
            bRet = TRUE;
            break;
        }
    }
    return bRet;
}

// Our NT5 version of the WndProc
//
LPARAM CShellBrowser2::_WndProcBSNT5(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPARAM lRet = 0;
    switch(uMsg)
    {
       case WM_APPCOMMAND:
       {
          if (_OnAppCommand(wParam, lParam))
             lRet = 1;
          break;
       }
       default:
          break;
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\player.cpp ===
// MediaBarPlayer.cpp

#include "priv.h"

#include "dispex.h"
#include "player.h"
#include "resource.h"
#include "math.h"
#include "mediautil.h"
#include "mbBehave.h"


#define WZ_PLAY                 L"beginElement"
#define WZ_STOP                 L"endElement"
#define WZ_PAUSE                L"pauseElement"
#define WZ_RESUME               L"resumeElement"
#define WZ_URL                  L"src"
#define WZ_VOLUME               L"volume"
#define WZ_MUTE                 L"mute"
#define WZ_REGISTERED_TIME_NAME L"HTMLTIME"
#define WZ_BODY                 L"body"
#define WZ_PLAYER               L"player"
#define WZ_ONMEDIACOMPLETE      L"onmediacomplete"
#define WZ_MEDIACOMPLETE        L"mediacomplete"
#define WZ_ONMEDIAERROR         L"onmediaerror"
#define WZ_MEDIAERROR           L"mediaerror"
#define WZ_ONTRACKCHANGE       L"ontrackchange"
#define WZ_TRACKCHANGE         L"trackchange"
#define WZ_ONEND                L"onend"
#define WZ_END                  L"end"
#define WZ_PARAM                L"Param"

/////////////////////// Convenience macros ////////////////////
//
// used in QI calls, 
// e.g. IOleSite * pSite;  p->QI( IID_TO_PPV(IOleInPlaceSite, &pSite) ) 
// would cause a C2440 as _src is not really a _type **.
// Note: the riid must be the _type prepended by IID_.
//
#define IID_TO_PPV(_type,_src)      IID_##_type, \
                                    reinterpret_cast<void **>(static_cast<_type **>(_src))
// Explicit directive to ignore a return value
#define IGNORE_RETURN(_call)        static_cast<void>((_call))
#define ERROREXIT(hr) if(FAILED(hr)){hr = E_FAIL; goto done;}
#define IGNORE_HR(hr) IGNORE_RETURN(hr)
#define TIME_INFINITE HUGE_VAL

static inline double
Clamp(double min, double val, double max)
{
    if (val < min)
    {
        val = min;
    }
    else if (val > max)
    {
        val = max;
    }

    return val;
}


/****************************************************\
    FUNCTION: CMediaBarPlayer_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    MediaBarPlayer COM object.
\****************************************************/
HRESULT CMediaBarPlayer_CreateInstance(REFIID riid, void ** ppvObj)
{
    // aggregation checking is handled in class factory

    CComObject<CMediaBarPlayer> * pMediaBarPlayer = NULL;

    *ppvObj = NULL;

    HRESULT hr = CComObject<CMediaBarPlayer>::CreateInstance(&pMediaBarPlayer);
    if (FAILED(hr))
        return hr;

    hr = pMediaBarPlayer->QueryInterface(riid, ppvObj);
    if (FAILED(hr))
        delete pMediaBarPlayer;

    return hr;
}

//+-------------------------------------------------------------------------
// Constructor
//--------------------------------------------------------------------------
CMediaBarPlayer::CMediaBarPlayer() :
    _dwDocumentEventConPtCookie(0),
    _dwCookiePropNotify(0),
    _pMediaBar(NULL),
    _hwnd(NULL)
{
}

//+-------------------------------------------------------------------------
// Destructor
//--------------------------------------------------------------------------
CMediaBarPlayer::~CMediaBarPlayer()
{
    _DestroyHost();
}

//+-------------------------------------------------------------------------
// Creates the control host
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_CreateHost(HWND hWnd)
{
    HRESULT hr = E_FAIL;
    
    if (_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }
    
    if (hWnd && ::IsWindow(hWnd) &&  _pMediaBar)
    {
        // Register the OCHost window class
        SHDRC shdrc = {sizeof(SHDRC), SHDRCF_OCHOST};
        shdrc.cbSize = sizeof (SHDRC);
        shdrc.dwFlags |= SHDRCF_OCHOST;
        if (DllRegisterWindowClasses(&shdrc))
        {
            // Create an OCHost window
            _hwnd = CreateWindow(OCHOST_CLASS, NULL,
                (WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS) & ~(WS_HSCROLL|WS_VSCROLL),
                0, 0, 0, 0,
                hWnd, NULL, HINST_THISDLL, NULL);
            
            if (_hwnd)
            {
                OCHINITSTRUCT ocs;
                ocs.cbSize = SIZEOF(OCHINITSTRUCT);   
                ocs.clsidOC  = CLSID_WebBrowser;
                ocs.punkOwner = SAFECAST(_pMediaBar, IUnknown*);
                
                hr = OCHost_InitOC(_hwnd, (LPARAM)&ocs);
                ERROREXIT(hr)
                
                OCHost_QueryInterface(_hwnd, IID_PPV_ARG(IWebBrowser2, &_spBrowser));
                OCHost_DoVerb(_hwnd, OLEIVERB_INPLACEACTIVATE, FALSE);
            }
        }
    }

    if (!_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }

    // navigate to the page containing the player
    {
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);

        // generate the url for the HTML resource containing the player
        CComBSTR sbstrURL(OLESTR("res://"));
        sbstrURL.Append(szModule);
        sbstrURL.Append(OLESTR("/"));
        TCHAR szResID[11];
        wnsprintf(szResID, _MAX_PATH, _T("%d"), IDH_PLAYER);
        sbstrURL.Append(szResID);

        hr = _Navigate(sbstrURL.m_str);
        ERROREXIT(hr)
    }
  
    // listen to events
    hr = _InitEventSink();
    ERROREXIT(hr)
        
    hr = S_OK;
done:
    if (FAILED(hr))
    {
        _DestroyHost();
    }
    
    return hr;
}


STDMETHODIMP
CMediaBarPlayer::_Navigate(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarEmpty;
    
    if (!bstrUrl || !_spBrowser.p)
    {
        hr = E_FAIL;
        goto done;
    }
   
    hr = _spBrowser->Navigate(bstrUrl, &svarEmpty, &svarEmpty, &svarEmpty, &svarEmpty);
    ERROREXIT(hr)
 
    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Destroys the control host
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_DestroyHost()
{
    _AttachPlayerEvents(FALSE);

    _UnhookPropNotifies();

    _DeInitEventSink();

    if (_spMediaElem.p)
    {
        _spMediaElem.Release();
    }

    if (_spMediaElem2.p)
    {
