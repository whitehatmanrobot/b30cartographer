AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\faxxp.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.cpp

Abstract:

    This module contains routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Handle errors and get proper server name in ServiceEntry.

    dd/mm/yy -author-
        description

--*/

#include "faxxp.h"
#include "debugex.h"

#pragma hdrstop


//
// globals
//

LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
HINSTANCE           g_FaxXphInstance;
HMODULE             g_hModRichEdit;
MAPIUID             g_FaxGuid = FAX_XP_GUID;



extern "C"
DWORD
FaxXpDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    DWORD dwRet = TRUE;
    DBG_ENTER(TEXT("FaxXpDllEntry"),dwRet,TEXT("Reason=%d,Context=%d"),Reason,Context);

    if (Reason == DLL_PROCESS_ATTACH)
    {
        g_FaxXphInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );
    }

    if (Reason == DLL_PROCESS_DETACH)
    {
    }

    return dwRet;
}


STDINITMETHODIMP
XPProviderInit(
    HINSTANCE hInstance,
    LPMALLOC lpMalloc,
    LPALLOCATEBUFFER lpAllocateBuffer,
    LPALLOCATEMORE lpAllocateMore,
    LPFREEBUFFER lpFreeBuffer,
    ULONG ulFlags,
    ULONG ulMAPIVer,
    ULONG * lpulProviderVer,
    LPXPPROVIDER * lppXPProvider
    )

/*++

Routine Description:

    Entry point called by the MAPI spooler when a profile uses this
    transport. The spooler calls this method and expects a pointer to an
    implementation of the IXPProvider interface. MAPI uses the returned
    IXPProvider interface pointer to logon on the transport provider.

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hr = S_OK;
    CXPProvider * pXPProvider = NULL;
    DBG_ENTER(TEXT("XPProviderInit"),hr,TEXT("ulFlags=%d,ulMAPIVer=%d"),ulFlags,ulMAPIVer);

    gpfnAllocateBuffer = lpAllocateBuffer;
    gpfnAllocateMore = lpAllocateMore;
    gpfnFreeBuffer = lpFreeBuffer;

    if (!g_hModRichEdit)
    {
        g_hModRichEdit = LoadLibrary( _T("RICHED32.DLL") );
    }

    __try
    {
        pXPProvider = new CXPProvider( hInstance );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // Do nothing (InitializeCriticalSection threw exception)
        //
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (!pXPProvider)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    *lppXPProvider = (LPXPPROVIDER)pXPProvider;
    *lpulProviderVer = CURRENT_SPI_VERSION;

exit:
    return hr;
}


HRESULT STDAPICALLTYPE
CreateDefaultPropertyTags(
    LPPROFSECT pProfileObj
    )

/*++

Routine Description:

    Creates the default property tags & values.

Arguments:

    pProfileObj - Profile object.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult;
    DBG_ENTER(TEXT("CreateDefaultPropertyTags"),hResult);

    SPropValue spvProps[NUM_FAX_PROPERTIES] = { 0 };
    PPRINTER_INFO_2 PrinterInfo;
    DWORD CountPrinters;
    LPTSTR FaxPrinterName = NULL;
    LOGFONT FontStruct;
    HFONT hFont;


    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters );
    if (PrinterInfo)
    {
        DWORD i;
        for (i=0; i<CountPrinters; i++)
        {
            if (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)
            {
                FaxPrinterName = StringDup( PrinterInfo[i].pPrinterName );
                if(NULL == FaxPrinterName)
                {
                    VERBOSE(MEM_ERR, TEXT("StringDup Failed in xport\\faxxp.cpp\\CreateDefaultPropertyTags"));
                    hResult = E_OUTOFMEMORY;
                    return hResult;
                }
                break;
            }
        }
    }

    spvProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;
    spvProps[PROP_FAX_PRINTER_NAME].Value.bin.cb = ((FaxPrinterName) ? (_tcslen(FaxPrinterName) + 1)*sizeof(TCHAR)
                                                                  : (_tcslen(_T("")+1) * sizeof(TCHAR)));
    spvProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE) ((FaxPrinterName) ?
                                                               FaxPrinterName : StringDup(_T("")));

    spvProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    spvProps[PROP_COVERPAGE_NAME].Value.bin.cb = (_tcslen(_T("")) + 1) * sizeof(TCHAR);
    spvProps[PROP_COVERPAGE_NAME].Value.bin.lpb= (LPBYTE) StringDup(_T(""));

    spvProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    spvProps[PROP_USE_COVERPAGE].Value.ul      = 0;

    spvProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    spvProps[PROP_SERVER_COVERPAGE].Value.ul   = 0;

    hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
    GetObject( hFont, sizeof(LOGFONT), &FontStruct );
    if(FontStruct.lfHeight > 0)
    {
        FontStruct.lfHeight *= -1;
    }
    FontStruct.lfWidth = 0;

    spvProps[PROP_FONT].ulPropTag              = PR_FONT;
    spvProps[PROP_FONT].Value.bin.cb           = sizeof(LOGFONT);
    spvProps[PROP_FONT].Value.bin.lpb          = (LPBYTE) &FontStruct;

    spvProps[PROP_SEND_SINGLE_RECEIPT].ulPropTag     = PR_SEND_SINGLE_RECEIPT;
    spvProps[PROP_SEND_SINGLE_RECEIPT].Value.ul      = TRUE;

    spvProps[PROP_ATTACH_FAX].ulPropTag     = PR_ATTACH_FAX;
    spvProps[PROP_ATTACH_FAX].Value.ul      = FALSE;

    spvProps[PROP_LINK_COVERPAGE].ulPropTag     = PR_LINK_COVERPAGE;
    spvProps[PROP_LINK_COVERPAGE].Value.ul      = 0;

    LPSPropProblemArray lpProblems = NULL;

    hResult = pProfileObj->SetProps( sizeof(spvProps)/sizeof(SPropValue), spvProps, &lpProblems);

    if(FAILED(hResult))
    {
        hResult = ::GetLastError();
        CALL_FAIL(GENERAL_ERR, TEXT("SetProps"), hResult);
        goto exit;
    }

    if (lpProblems)
    {
        hResult =  MAPI_E_NOT_FOUND;
        MAPIFreeBuffer(lpProblems);
    }

exit:
    return hResult;
}


HRESULT STDAPICALLTYPE
ServiceEntry(
    HINSTANCE          hInstance,
    LPMALLOC           pMallocObj,
    LPMAPISUP          pSupObj,
    ULONG              ulUIParam,
    ULONG              ulFlags,
    ULONG              ulContext,
    ULONG              ulCfgPropCount,
    LPSPropValue       pCfgProps,
    LPPROVIDERADMIN    pAdminProvObj,
    LPMAPIERROR *      ppMAPIError
    )

/*++

Routine Description:

    Called by the profile setup API to display the provider
    configuration properties for this transport provider

Arguments:

    Refer to MAPI Documentation for this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult = S_OK;
    DBG_ENTER(TEXT("ServiceEntry"),hResult,TEXT("ulFlags=%d,ulContext=%d"),ulFlags,ulContext);

    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    LPSPropValue pProps = NULL;
    FAXXP_CONFIG FaxConfig = {0};
    PPRINTER_INFO_2 PrinterInfo = NULL;
    INT_PTR nDlgRes;

    //
    // First check if the context of the call is UNINSTALL
    // If it is then pSupObj == NULL
    //
    if (ulContext == MSG_SERVICE_UNINSTALL)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_DELETE)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_INSTALL)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_PROVIDER_CREATE || 
        ulContext == MSG_SERVICE_PROVIDER_DELETE)
    {
        hResult = MAPI_E_NO_SUPPORT;
        goto exit;
    }

    Assert(NULL != pSupObj);
    
    pSupObj->GetMemAllocRoutines( &gpfnAllocateBuffer, &gpfnAllocateMore, &gpfnFreeBuffer );

    hResult = pAdminProvObj->OpenProfileSection(&g_FaxGuid,
                                                NULL,
                                                MAPI_MODIFY,
                                                &pProfileObj);
    if (hResult)
    {
        goto exit;
    }

    if (ulContext == MSG_SERVICE_CREATE)
    {
        CreateDefaultPropertyTags( pProfileObj );
        goto exit;
    }
    
    if (ulContext != MSG_SERVICE_CONFIGURE)
    {
        goto exit;
    }

    //
    //get fax related props from profileObj, to give them as initial values for the DlgBox
    //
    hResult = pProfileObj->GetProps((LPSPropTagArray) &sptFaxProps,
                                    0,
                                    &PropCount,
                                    &pProps);
    if (!HR_SUCCEEDED(hResult))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProps"), hResult);
        goto exit;
    }

    FaxConfig.PrinterName = StringDup( (LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb);
    if (NULL == FaxConfig.PrinterName)
    {
        hResult = E_OUTOFMEMORY;
        goto exit;
    }

    FaxConfig.CoverPageName = StringDup((LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb);
    if (NULL == FaxConfig.CoverPageName)
    {
        hResult = E_OUTOFMEMORY;
        goto exit;
    }

    FaxConfig.UseCoverPage      = GetDwordProperty( pProps, PROP_USE_COVERPAGE );
    FaxConfig.ServerCoverPage   = GetDwordProperty( pProps, PROP_SERVER_COVERPAGE );
    FaxConfig.SendSingleReceipt = GetDwordProperty( pProps, PROP_SEND_SINGLE_RECEIPT );
    FaxConfig.bAttachFax        = GetDwordProperty( pProps, PROP_ATTACH_FAX );
    FaxConfig.LinkCoverPage     = GetDwordProperty(pProps, PROP_LINK_COVERPAGE);

    //
    // If we fail getting server name we will default to local
    //
    FaxConfig.ServerName = NULL;
    GetServerNameFromPrinterName(FaxConfig.PrinterName,&FaxConfig.ServerName);

    if (!GetBinaryProperty( pProps, PROP_FONT, &FaxConfig.FontStruct, sizeof(FaxConfig.FontStruct)))
    {
        HFONT hFont = (HFONT) GetStockObject( SYSTEM_FIXED_FONT );
        GetObject( hFont, sizeof(LOGFONT), &FaxConfig.FontStruct );
        if(FaxConfig.FontStruct.lfHeight > 0)
        {
            FaxConfig.FontStruct.lfHeight *= -1;
        }
        FaxConfig.FontStruct.lfWidth = 0;
    }

    //
    //open a dialogBox to let user config those props
    //    
    nDlgRes = DialogBoxParam(hInstance,
                             MAKEINTRESOURCE(FAX_CONFIG_DIALOG),
                             (HWND)ULongToHandle(ulUIParam),
                             ConfigDlgProc,
                             (LPARAM) &FaxConfig);
    if(IDOK != nDlgRes)
    {
        goto exit;
    }

    //
    //update props' value in the profileObj
    //
    pProps[PROP_FAX_PRINTER_NAME].ulPropTag  = PR_FAX_PRINTER_NAME;

    pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE) FaxConfig.PrinterName;
    pProps[PROP_FAX_PRINTER_NAME].Value.bin.cb =  (_tcslen(FaxConfig.PrinterName) + 1)*sizeof(TCHAR) ;
                                                                
    pProps[PROP_COVERPAGE_NAME].ulPropTag    = PR_COVERPAGE_NAME;
    pProps[PROP_COVERPAGE_NAME].Value.bin.lpb   = (LPBYTE)FaxConfig.CoverPageName;
    pProps[PROP_COVERPAGE_NAME].Value.bin.cb =  (_tcslen(FaxConfig.CoverPageName) + 1)*sizeof(TCHAR) ;

    pProps[PROP_USE_COVERPAGE].ulPropTag     = PR_USE_COVERPAGE;
    pProps[PROP_USE_COVERPAGE].Value.ul      = FaxConfig.UseCoverPage;

    pProps[PROP_SERVER_COVERPAGE].ulPropTag  = PR_SERVER_COVERPAGE;
    pProps[PROP_SERVER_COVERPAGE].Value.ul   = FaxConfig.ServerCoverPage;

    pProps[PROP_FONT].ulPropTag              = PR_FONT;
    pProps[PROP_FONT].Value.bin.lpb          = (LPBYTE)&FaxConfig.FontStruct;
    pProps[PROP_FONT].Value.bin.cb           = sizeof(FaxConfig.FontStruct);

    pProps[PROP_SEND_SINGLE_RECEIPT].ulPropTag     = PR_SEND_SINGLE_RECEIPT;
    pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul      = FaxConfig.SendSingleReceipt;

    pProps[PROP_ATTACH_FAX].ulPropTag      = PR_ATTACH_FAX;
    pProps[PROP_ATTACH_FAX].Value.ul       = FaxConfig.bAttachFax;

    pProps[PROP_LINK_COVERPAGE].ulPropTag  = PR_LINK_COVERPAGE;
    pProps[PROP_LINK_COVERPAGE].Value.ul   = FaxConfig.LinkCoverPage;

    hResult = pProfileObj->SetProps( PropCount, pProps, NULL);

    if (FaxConfig.PrinterName)
    {
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = NULL;
    }
    if (FaxConfig.CoverPageName)
    {
        MemFree( FaxConfig.CoverPageName );
        FaxConfig.CoverPageName = NULL;
    }
    if (FaxConfig.ServerName)
    {
        MemFree(FaxConfig.ServerName);
        FaxConfig.ServerName = NULL;
    }

exit:
    if (pProfileObj)
    {
        pProfileObj->Release();
    }

    if (pProps)
    {
        MAPIFreeBuffer( pProps );
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\faxxp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxxp.h

Abstract:

    Fax transport provider header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Change GetServerName to GetServerNameFromPrinterName.
        Add GetServerNameFromPrinterInfo.

    dd/mm/yy -author-
        description

--*/

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <tchar.h>
#include <stdio.h>
#include <fxsapip.h>

#include "resource.h"
#include "faxreg.h"
#include "faxmapip.h"
#include "faxutil.h"
#include "devmode.h"


#define MAX_FILENAME_EXT                    4
#define CPFLAG_LINK                         0x0100

#define SERVER_COVER_PAGE                   1   
#define SHORTCUT_COVER_PAGE                 2
#define TRANSPORT_DLL_NAME_STRING           FAX_MAIL_TRANSPORT_MODULE_NAME

#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|

#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)

#define XPID_NAME                           0
#define XPID_EID                            1
#define XPID_SEARCH_KEY                     2
#define NUM_IDENTITY_PROPS                  3

#define RECIP_ROWID                         0
#define RECIP_NAME                          1
#define RECIP_EMAIL_ADR                     2
#define RECIP_TYPE                          3
#define RECIP_RESPONSIBILITY                4
#define RECIP_DELIVER_TIME                  5
#define RECIP_REPORT_TIME                   6
#define RECIP_REPORT_TEXT                   7
#define RECIP_ADDR_TYPE                     8
#define TABLE_RECIP_PROPS                   9

#define MSG_DISP_TO                         0
#define MSG_SUBJECT                         1
#define MSG_CLASS                           2
#define MSG_BODY                            3
#define MSG_FLAGS                           4
#define MSG_SIZE                            5
#define MSG_PRIORITY                        6
#define MSG_IMPORTANCE                      7
#define MSG_SENSITIVITY                     8
#define MSG_DR_REPORT                       9
#define MSG_SENDER_ENTRYID                 10
#define NUM_MSG_PROPS                      11

#define MSG_ATTACH_METHOD                   0
#define MSG_ATTACH_NUM                      1
#define MSG_ATTACH_EXTENSION                2
#define MSG_ATTACH_FILENAME                 3
#define MSG_ATTACH_PATHNAME                 4
#define MSG_ATTACH_LFILENAME                5
#define MSG_ATTACH_TAG                      6
#define NUM_ATTACH_PROPS                    7
#define NUM_ATTACH_TABLE_PROPS              2


typedef struct _USER_INFO {
    TCHAR BillingCode[64];
    TCHAR Company[128];
    TCHAR Dept[128];
} USER_INFO, *PUSER_INFO;


const static SizedSPropTagArray ( NUM_ATTACH_TABLE_PROPS, sptAttachTableProps) =
{
    NUM_ATTACH_TABLE_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM
    }
};

const static SizedSPropTagArray ( NUM_ATTACH_PROPS, sptAttachProps) =
{
    NUM_ATTACH_PROPS,
    {
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_EXTENSION_A,
        PR_ATTACH_FILENAME_A,
        PR_ATTACH_PATHNAME_A,
        PR_ATTACH_LONG_FILENAME_A,
        PR_ATTACH_TAG
    }
};

const static SizedSPropTagArray (TABLE_RECIP_PROPS, sptRecipTable) =
{
    TABLE_RECIP_PROPS,
    {
        PR_ROWID,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_RECIPIENT_TYPE,
        PR_RESPONSIBILITY,
        PR_DELIVER_TIME,
        PR_REPORT_TIME,
        PR_REPORT_TEXT_A,
        PR_ADDRTYPE_A
    }
};

static const SizedSPropTagArray(NUM_MSG_PROPS, sptPropsForHeader) =
{
    NUM_MSG_PROPS,
    {
        PR_DISPLAY_TO_A,
        PR_SUBJECT_A,
        PR_BODY_A,
        PR_MESSAGE_CLASS_A,
        PR_MESSAGE_FLAGS,
        PR_MESSAGE_SIZE,
        PR_PRIORITY,
        PR_IMPORTANCE,
        PR_SENSITIVITY,
        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED,
        PR_SENDER_ENTRYID
    }
};

extern LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function
extern LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function
extern LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function
extern HINSTANCE           g_FaxXphInstance;
extern MAPIUID             g_FaxGuid;


LPVOID
MapiMemAlloc(
    SIZE_T Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters
    );

PVOID
MyGetPrinter(
    LPTSTR  PrinterName,
    DWORD   level
    );

void
ErrorMsgBox(
    HINSTANCE hInstance,
    DWORD     dwMsgId
);

/*
 -  GetServerNameFromPrinterInfo
 -
 *  Purpose:
 *      Get the Server name, given a PRINTER_INFO_2 structure
 *
 *  Arguments:
 *      [in] ppi2 - Address of PRINTER_INFO_2 structure
 *      [out] lpptszServerName - Address of string pointer for returned name.
 *
 *  Returns:
 *      BOOL - TRUE: sucess , FALSE: failure.
 *
 *  Remarks:
 *      This inline function retrieves the server from a printer info structure
 *      in the appropriate way for win9x and NT. 
 */
inline BOOL 
GetServerNameFromPrinterInfo(PPRINTER_INFO_2 ppi2,LPTSTR *lpptszServerName)
{   
    if (!ppi2)
    {
        return FALSE;
    }
#ifndef WIN95

    *lpptszServerName = NULL;
    if (ppi2->pServerName)
    {
        if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pServerName,2))))
        {
            return FALSE;
        }
    }
    return TRUE;

#else //WIN95
    
    //
    // Formatted: \\Server\port
    //
    if (!(ppi2->pPortName))
    {
        return FALSE;
    }
    if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pPortName,2))))
    {
        return FALSE;
    }
    _tcstok(*lpptszServerName,TEXT("\\"));

#endif //WIN95

    return TRUE;
}


BOOL
GetServerNameFromPrinterName(
    LPTSTR PrinterName,
    LPTSTR *ppszServerName
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    );

DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    LPVOID Buffer,
    DWORD SizeOfBuffer
    );



class CXPProvider : public IXPProvider
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    MAPI_IXPPROVIDER_METHODS(IMPL);

public :
    CXPProvider( HINSTANCE hInst );
    ~CXPProvider();

private :
    ULONG               m_cRef;
    CRITICAL_SECTION    m_csTransport;
    HINSTANCE           m_hInstance;
};


class CXPLogon : public IXPLogon
{
public:
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObj );
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP InitializeStatusRow(ULONG ulFlags);
    STDMETHODIMP GrowAddressList(LPADRLIST *ppAdrList, ULONG ulResizeBy, ULONG *pulOldAndNewCount);
    MAPI_IXPLOGON_METHODS(IMPL);

private:
    void WINAPI CheckSpoolerYield( BOOL fReset = FALSE );
    void WINAPI UpdateStatus( BOOL fAddValidate=FALSE, BOOL fValidateOkState=FALSE );
    BOOL WINAPI LoadStatusString( LPTSTR pString, UINT uStringSize );
    DWORD SendFaxDocument(LPMESSAGE pMsgObj,LPSTREAM lpstmT,BOOL UseRichText,LPSPropValue pMsgProps,LPSRowSet pRecipRows /*LPSPropValue pRecipProps*/);
    PVOID MyGetPrinter(LPTSTR PrinterName,DWORD Level);

    DWORD PrintAttachmentToFile(IN  LPMESSAGE      pMsgObj,
                                IN  PFAXXP_CONFIG  pFaxConfig,
                                OUT LPTSTR*        lpptstrOutAttachments);

    BOOL  PrintRichText(HWND hWndRichEdit,HDC hDC);
    DWORD PrintPlainText(HDC hDC,LPSTREAM lpstmT,LPTSTR tszSubject, PFAXXP_CONFIG FaxConfig);

    DWORD PrintFaxDocumentToFile(
	   IN  LPMESSAGE        pMsgObj,
	   IN  LPSTREAM         lpstmT,
	   IN  BOOL             UseRichText,
	   IN  PFAXXP_CONFIG    pFaxConfig, 
           IN  LPTSTR           tszSubject,
	   OUT LPTSTR*          lpptstrMessageFileName
	   );

    DWORD PrintMessageToFile(IN LPSTREAM         lpstmT,
                             IN BOOL             UseRichText,
                             IN PFAXXP_CONFIG    pFaxConfig,
                             IN  LPTSTR          tszSubject,
                             OUT LPTSTR*         lpptstrOutDocument);


public :
    CXPLogon( HINSTANCE hInstance, LPMAPISUP pSupObj, LPTSTR ProfileName );
    ~CXPLogon();

    inline void WINAPI AddStatusBits
                    (DWORD dwNewBits) { m_ulTransportStatus |= dwNewBits; }
    inline void WINAPI RemoveStatusBits
                    (DWORD dwOldBits) { m_ulTransportStatus &= ~dwOldBits; }
    inline DWORD WINAPI GetTransportStatusCode
                    () { return m_ulTransportStatus; }

private :
    ULONG               m_cRef;
    HINSTANCE           m_hInstance;
    BOOL                m_fABWDSInstalled;
    ULONG               m_ulTransportStatus;
    LPWSTR              m_CpBuffer;
    DWORD               m_CpBufferSize;

public :
    LPMAPISUP           m_pSupObj;
    HANDLE              m_hUIMutex;
    HRESULT             m_hRemoteActionErr;
    BOOL                m_fCancelPending;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix GetServerName as GetServerNameFromPrinterName.

    dd-mm-yy -author-
        description

--*/

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop


//
// globals
//

BOOL oleInitialized;



LPVOID
MapiMemAlloc(
    SIZE_T Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr=NULL;
    HRESULT hResult;

	// [Win64bug] gpfnAllocateBuffer should accpet size_t as allocating size
    hResult = gpfnAllocateBuffer( DWORD(Size), &ptr );
    if (S_OK == hResult) 
    {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) 
    {
        gpfnFreeBuffer( ptr );
    }
}

PVOID
MyEnumPrinters(
    LPTSTR   pServerName,
    DWORD   level,
    PDWORD  pcPrinters
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
	DBG_ENTER(TEXT("MyEnumPrinters"));

    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;
    // first, we give no printer information buffer, so the function fails, but returns 
    // in cb the number of bytes needed. then we allocate enough memory, 
    // and call the function again, this time with all of the needed parameters.

    if (! EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                       pServerName,
                       level,
                       NULL,
                       0,
                       &cb,
                       pcPrinters)                         //the call failed
        && (::GetLastError() == ERROR_INSUFFICIENT_BUFFER) //this is the reason for failing
        && (pPrinterInfo = (PBYTE)MemAlloc(cb))            //we managed to allocate more memory
        && EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                     pServerName,
                     level,
                     pPrinterInfo,
                     cb,
                     &cb,
                     pcPrinters))                       //and now the call succeded
    {
        return pPrinterInfo;
    }

    MemFree(pPrinterInfo);
    return NULL;
}


HRESULT WINAPI
OpenServiceProfileSection(
    LPMAPISUP    pSupObj,
    LPPROFSECT * ppProfSectObj
    )

/*++

Routine Description:

    This function opens the profile section of this service, where the
    properties of a FAX provider (AB, MS, or XP) are stored.

Arguments:

    pSupObj         - Pointer to the provider support object
    ppProfSectObj   - Where we return a pointer to the service profile
                      section of the provider

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult;
	DBG_ENTER(TEXT("OpenServiceProfileSection"),hResult);

    SPropTagArray sptService = { 1, { PR_SERVICE_UID } };
    LPPROFSECT pProvProfSectObj;
    ULONG cValues;
    LPSPropValue pProp;
    

    //
    // Get the PROVIDER profile section
    //
    hResult = pSupObj->OpenProfileSection(
        NULL,
        MAPI_MODIFY,
        &pProvProfSectObj
        );
    if (!hResult) 
    {
        // Get the UID of the profile section of the service where this provider is installed
        hResult = pProvProfSectObj->GetProps (&sptService, FALSE, &cValues, &pProp);
        if (SUCCEEDED(hResult)) 
        {
            if (S_OK == hResult) 
            {
                // Now, with the obtained UID, open the profile section of the service
                hResult = pSupObj->OpenProfileSection ((LPMAPIUID)pProp->Value.bin.lpb,
                                                       MAPI_MODIFY,
                                                       ppProfSectObj);
            } 
            else 
            {
                hResult = E_FAIL;
            }
            MemFree( pProp ); 
        }
        pProvProfSectObj->Release();
    }
    return hResult;
}


LPTSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
	LPTSTR Pstr = NULL;

    if (Path == NULL || Path[0] == 0) 
	{
        return Path;
    }

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr && (*_tcsinc(Pstr)) == '\0' )
	{
		// the last character is a backslash, truncate it...
		_tcsset(Pstr,TEXT('\0'));
		Pstr = _tcsdec(Path,Pstr);
	}

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr )
	{
		_tcsnset(_tcsinc(Pstr),TEXT('\0'),1);
	}

    return Path;
}


PDEVMODE
GetPerUserDevmode(
    LPTSTR PrinterName
    )
{
    PDEVMODE DevMode = NULL;
    LONG Size;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), ::GetLastError() ));
        return NULL;
    }

    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            NULL,
                            NULL,
                            0
                            );

    if (Size < 0) 
    {
        goto exit;
    }
    
    DevMode = (PDEVMODE) MemAlloc( Size );

    if (DevMode == NULL) 
    {
        goto exit;
    }
    
    Size = DocumentProperties(
                            NULL,
                            hPrinter,
                            PrinterName,
                            DevMode,
                            NULL,
                            DM_OUT_BUFFER
                            );

    if (Size < 0) 
    {
        MemFree( DevMode );
        DevMode = NULL;
        goto exit;
    }


exit:
    
    ClosePrinter( hPrinter );
    return DevMode;
}



DWORD
GetDwordProperty(
    LPSPropValue pProps,
    DWORD PropId
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) 
    {
        return 0;
    }

    return pProps[PropId].Value.ul;
}


DWORD
GetBinaryProperty(
    LPSPropValue pProps,
    DWORD PropId,
    LPVOID Buffer,
    DWORD SizeOfBuffer
    )
{
    if (PROP_TYPE(pProps[PropId].ulPropTag) == PT_ERROR) 
    {
        return 0;
    }

    if (pProps[PropId].Value.bin.cb > SizeOfBuffer) 
    {
        return 0;
    }

    CopyMemory( Buffer, pProps[PropId].Value.bin.lpb, pProps[PropId].Value.bin.cb );

    return pProps[PropId].Value.bin.cb;
}


PVOID
MyGetPrinter(
    LPTSTR   PrinterName,
    DWORD    level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
	DBG_ENTER(TEXT("MyGetPrinter"));

    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenPrinter"), ::GetLastError());
		return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        ::GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}


BOOL
GetServerNameFromPrinterName(
    LPTSTR lptszPrinterName,
    LPTSTR *pptszServerName
    )

/*++

Routine Description:

    retrieve the server name given a printer name

Arguments:

    [in] lptszPrinterName - Identifies the printer in question
    [out] lptszServerName - Address of pointer to output string buffer. 
                            NULL indicates local server.
                            The caller is responsible to free the buffer which 
                            pointer is given in this parameter.

Return Value:

    BOOL: TRUE - operation succeeded , FALSE: failed

--*/
{
	BOOL    bRes = FALSE;
	DBG_ENTER(TEXT("GetServerNameFromPrinterName"),bRes);

    PPRINTER_INFO_2 ppi2 = NULL;
    LPTSTR  lptstrBuffer = NULL;
    
    if (lptszPrinterName) 
    {
        if (ppi2 = (PPRINTER_INFO_2) MyGetPrinter(lptszPrinterName,2))
        {
            bRes = GetServerNameFromPrinterInfo(ppi2,&lptstrBuffer);
            MemFree(ppi2);
            if (bRes)
            {
                *pptszServerName = lptstrBuffer;
            }
        }
    }
    return bRes;
}

LPTSTR
ConvertAStringToTString(LPCSTR lpcstrSource)
{
	LPTSTR lptstrDestination;

	if (!lpcstrSource)
		return NULL;

#ifdef	UNICODE
    lptstrDestination = AnsiStringToUnicodeString( lpcstrSource );
#else	// !UNICODE
	lptstrDestination = StringDup( lpcstrSource );
#endif	// UNICODE
	
	return lptstrDestination;
}

LPSTR
ConvertTStringToAString(LPCTSTR lpctstrSource)
{
	LPSTR lpstrDestination;

	if (!lpctstrSource)
		return NULL;

#ifdef	UNICODE
    lpstrDestination = UnicodeStringToAnsiString( lpctstrSource );
#else	// !UNICODE
	lpstrDestination = StringDup( lpctstrSource );
#endif	// UNICODE
	
	return lpstrDestination;
}

void
ErrorMsgBox(
    HINSTANCE hInstance,
    DWORD     dwMsgId
)
/*++

Routine Description:

    Display error message box

Arguments:

    hInstance  - [in] resource instance handle
    dwMsgId    - [in] string resource ID

Return Value:

    none

--*/
{
    TCHAR* ptCaption=NULL;
    TCHAR  tszCaption[MAX_PATH];
    TCHAR  tszMessage[MAX_PATH];

    DBG_ENTER(TEXT("ErrorMsgBox"));

    if(!LoadString( hInstance, IDS_FAX_MESSAGE, tszCaption, sizeof(tszCaption) / sizeof(tszCaption[0])))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
    }
    else
    {
        ptCaption = tszCaption;
    }

    if(!LoadString( hInstance, dwMsgId, tszMessage, sizeof(tszMessage) / sizeof(tszMessage[0])))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
        Assert(FALSE);
        return;
    }

    MessageBeep(MB_ICONEXCLAMATION);
    AlignedMessageBox(NULL, tszMessage, ptCaption, MB_OK | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXXP32)
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
DLLENTRY=FaxXpDllEntry
DLLDEF=..\faxxp32.def

USE_CRTDLL=1
USE_STL=1

INCLUDES=\
  $(INCLUDES); \
  $(FAXROOT)\print\faxprint\inc; \
  $(FAXROOT)\exchange\inc;

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
  $(FAXLIB)\*\faxtiffp.lib		\
  $(FAXLIB)\*\faxrend.lib		\
  $(FAXROOT)\util\debugex\unicode\obj\*\debugex.lib \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib

!else
LINKLIBS_INT=\
  $(FAXLIB)\win95\*\faxtiffp.lib		\
  $(FAXLIB)\win95\*\faxrend.lib			\
  $(FAXROOT)\util\debugex\ansii\obj\*\debugex.lib   \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib
!endif

TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib       \
  $(BASEDIR)\public\sdk\lib\*\user32.lib      \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib      \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib    \
  $(FAXLIB)\*\$(WINFAX).lib					  \
  $(LINKLIBS_INT)

SOURCES=\
  ..\config.cpp  \
  ..\faxdoc.cpp  \
  ..\faxxp.cpp   \
  ..\util.cpp    \
  ..\xplogon.cpp \
  ..\xpprov.cpp  \
  ..\faxxp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\resource.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Fax transport provider resource header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/


#define IDS_NO_FAX_PRINTER             101
#define IDS_CANT_ACCESS_PRINTER        102
#define IDS_RESOURCES_UNAVAIL          103
#define IDS_CANT_PRINT                 104
#define IDS_CANT_ACCESS_MSG_DATA       105
#define IDS_CANT_ACCESS_PROFILE        106
#define IDS_BAD_ATTACHMENTS            107
#define IDS_FONT_REGULAR               108
#define IDS_FONT_ITALIC                109
#define IDS_FONT_BOLD                  110
#define IDS_PERSONAL                   111
#define IDS_FAX_MESSAGE                112
#define IDS_CANT_ACCESS_SERVER         113
#define IDS_CANT_PRINT_BODY            114
#define IDS_FAILED_MESSAGE             115
#define IDS_OUT_OF_MEM                 116
#define IDS_INTERNAL_ERROR  	       117
#define IDS_SUBJECT_FORMAT             118
#define IDS_PERSONAL_CP_FORBIDDEN      119
#define IDS_BAD_CANNONICAL_ADDRESS     120
#define IDS_NO_MSG_ATTACHMENTS         121
#define IDS_NO_MSG_BODY                122
#define IDS_EMPTY_MESSAGE              123

#define IDC_STATIC                      -1
#define IDC_PRINTER_LIST               201
#define IDC_USE_COVERPAGE              202
#define IDC_COVERPAGE_LIST             203
#define IDC_SET_FONT                   204
#define IDC_FONT_NAME                  205
#define IDC_FONT_STYLE                 206
#define IDC_FONT_SIZE                  207
#define IDCSTATIC_FONT                 208
#define IDCSTATIC_FONTSTYLE            209
#define IDCSTATIC_FONTSIZE             210
#define IDC_COVERPAGE_LIST_LABEL       211
#define IDCSTATIC_FONT_GROUP           212
#define IDC_STATIC_ICON                213
#define IDC_STATIC_TITLE               214
#define IDC_STATIC_PRINTERS            215
#define IDC_SEND_SINGLE_RECEIPT        216
#define IDS_NO_SUBMIT_RITHTS           217
#define IDC_ATTACH_FAX                 218
#define IDS_MESSAGE_DOC_NAME           219

#define FAX_CONFIG_DIALOG              501

#define IDI_FAX                        601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\xpprov.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xpprov.cpp

Abstract:

    This module contains the CXPProvider class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define INITGUID
#define USES_IID_IXPProvider
#define USES_IID_IXPLogon
#define USES_IID_IMAPIStatus
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIControl
#define USES_IID_IMAPIContainer
#define USES_IID_IMAPIFolder
#define USES_IID_IMAPITableData
#define USES_IID_IStreamDocfile
#define USES_PS_PUBLIC_STRINGS

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop



CXPProvider::CXPProvider(
    HINSTANCE hInst
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInst   - Handle to instance of this XP DLL

Return Value:

    None.

--*/

{
    m_hInstance = hInst;
    m_cRef = 1;
    InitializeCriticalSection( &m_csTransport );
}


CXPProvider::~CXPProvider()

/*++

Routine Description:

    Close down and release resources and libraries.

Arguments:

    None.

Return Value:

    None.

--*/

{
    m_hInstance = NULL;
    DeleteCriticalSection( &m_csTransport );
}


STDMETHODIMP
CXPProvider::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    *ppvObj = NULL;
    if (riid == IID_IXPProvider || riid == IID_IUnknown) {
        *ppvObj = (LPVOID)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPProvider::Shutdown(
    ULONG * pulFlags
    )

/*++

Routine Description:

    Stub method.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	DBG_ENTER(TEXT("CXPProvider::Shutdown"));
	
    return S_OK;
}


STDMETHODIMP
CXPProvider::TransportLogon(
    LPMAPISUP pSupObj,
    ULONG ulUIParam,
    LPTSTR pszProfileName,
    ULONG *pulFlags,
    LPMAPIERROR *ppMAPIError,
    LPXPLOGON *ppXPLogon
    )

/*++

Routine Description:

    Display the logon dialog to show the options saved in the profile for
    this provider and allow changes to it. Save new configuration settings
    back in the profile.
    Create a new CXPLogon object and return it to the spooler. Also,
    initialize the properties array for each address type handled
    by this transport. Check all the flags and return them to the spooler

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPProvider::TransportLogon"),hResult);

    CXPLogon *LogonObj = new CXPLogon( m_hInstance, pSupObj, pszProfileName );
    if (!LogonObj) {
		hResult = E_OUTOFMEMORY;
        goto exit;
    }

    hResult = LogonObj->InitializeStatusRow(0);

    if(HR_SUCCEEDED(hResult))
    {
        *ppXPLogon = LogonObj;
    }
    else
    {
        delete LogonObj;
    }

exit:
    return hResult;
}

STDMETHODIMP_(ULONG)
CXPProvider::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPProvider::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxbvt.inc ===
BINPLACE_OVERRIDE_FLAGS=
C_DEFINES=$(C_DEFINES) -DBUILD_PRODUCT=$(BUILD_PRODUCT)

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG
!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
MSC_OPTIMIZATION=-Od
!endif
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS=$(FAXROOT)\util\unicode\$O\faxutil.lib
!else
C_DEFINES=$(C_DEFINES) -D_MBCS
LINKLIBS=$(FAXROOT)\util\ansii\$O\faxutil.lib
!endif

C_DEFINES=$(C_DEFINES) -DTAPI_CURRENT_VERSION=0x00020000 -DNT5BETA2

FAXLIB=$(FAXROOT)\lib
FAXBVTROOT=$(FAXROOT)\FaxBVT

INCLUDES=$(FAXROOT)\inc;$(FAXROOT)\build

MSC_WARNING_LEVEL=/W3 /WX
LINKER_FLAGS=-IGNORE:4006,4088,4104

COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h -FI$(FAXROOT)\inc\warning.h

!if $(PPC)
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /W3 /WX
!endif

#
# force the build lab's checked
# build machines to have full symbolic
# debug info
#
!if "$(NTDEBUG)" == "cvp"
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -Z
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
!endif

#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(FAXROOT)\NT_coffbase.txt
BINPLACE_PLACEFILE=$(FAXBVTROOT)\NT_placefil.txt


#
# Figure out where to place the images
#

!ifndef OVERRIDE_DEFAULT_BINPLACE
_NTTREE=$(_NTTREE)\Test\BVT
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\xplogon.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    xplogon.cpp

Abstract:

    This module contains the XPLOGON class implementation.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxxp.h"
#include "debugex.h"
#pragma hdrstop

#include <mbstring.h>

LPSTR gszFAXAddressType = FAX_ADDRESS_TYPE_A;
LPSTR *gpszXPAddressTypes;

LPSTR	ConvertTStringToAString(LPCTSTR lpctstrSource);


CXPLogon::CXPLogon(
    HINSTANCE       hInstance,
    LPMAPISUP       pSupObj,
    LPTSTR          ProfileName
    )

/*++

Routine Description:

    Constructor of the object. Parameters are passed to initialize the
    data members with the appropiate values.

Arguments:

    hInstance   - Instance of the provider DLL
    pSupObj     - Pointer to IMAPISupport object used in
                  CXPLogon methods

Return Value:

    None.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::CXPLogon"));

    m_cRef           = 1;
    m_hInstance      = hInstance;
    m_pSupObj        = pSupObj;
    m_fABWDSInstalled = FALSE;

	m_ulTransportStatus = 0;

    m_pSupObj->AddRef();
}


CXPLogon::~CXPLogon()

/*++

Routine Description:

    Destructor of CXPLogon. Releases memory allocated for internal
    properties during the life of this transport logon object.

Arguments:

    None.

Return Value:

    None.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::~CXPLogon"));

    // Release the IMAPISupport object
    m_pSupObj->Release();
    m_pSupObj = NULL;
}


STDMETHODIMP
CXPLogon::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )

/*++

Routine Description:

    Returns a pointer to a interface requested if the interface is
    supported and implemented by this object. If it is not supported, it
    returns NULL.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    // OLE requires NULLing parameter
    *ppvObj = NULL;
    // If this is one of the two IID return an interface pointer to it
    if (riid == IID_IXPLogon || riid == IID_IUnknown) 
    {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }
    // This object does not support the interface requested
    return E_NOINTERFACE;
}


STDMETHODIMP
CXPLogon::AddressTypes(
    ULONG *        pulFlags,
    ULONG *        pcAdrType,
    LPTSTR **      pppAdrTypeArray,
    ULONG *        pcMAPIUID,
    LPMAPIUID **   pppMAPIUIDArray
    )

/*++

Routine Description:

    Called by the MAPI Spooler when initializing this XP logon object to
    allow the transport to register the address it will handle.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    S_OK always

--*/

{
	HRESULT hr = S_OK;
	DBG_ENTER(TEXT("CXPLogon::AddressTypes"),hr);

    *pcAdrType = 1;
    *pulFlags = 0;
    gpszXPAddressTypes = &gszFAXAddressType;
    *pppAdrTypeArray = (LPTSTR*)gpszXPAddressTypes;
    *pcMAPIUID = 0;
    *pppMAPIUIDArray = NULL;
    return hr;
}


STDMETHODIMP
CXPLogon::RegisterOptions(
    ULONG *         pulFlags,
    ULONG *         pcOptions,
    LPOPTIONDATA *  ppOptions
    )

/*++

Routine Description:

    This transport does not registers any per-recipient or per-message
    option processing, so we return 0 options. And NULL in the OPTIONDATA
    structure pointer.

Arguments:

    Refer to OLE Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::RegisterOptions"),hResult);

    *pulFlags = 0;
    *pcOptions = 0;
    *ppOptions = NULL;
    return hResult;
}


STDMETHODIMP
CXPLogon::InitializeStatusRow(
    ULONG ulFlags
    )

/*++

Routine Description:

    To initialize or modify the status properties of a CXPLogon
    object. This function allocates an array with NUM_STATUS_ROW_PROPS
    properties and initializes them.

Arguments:

    ulFlags - 0 if the properties are being created the first time.
              MODIFY_FLAGS if a change is being made to the properties

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::InitializeStatusRow"),hResult);

    #define NUM_STATUS_ROW_PROPS    7
    SPropValue spvStatusRow[NUM_STATUS_ROW_PROPS] = { 0 };
    ULONG i = 0;

    //
    // Set the PR_PROVIDER_DISPLAY property: The transport readable name
    //
    spvStatusRow[i].ulPropTag = PR_PROVIDER_DISPLAY_A;
    spvStatusRow[i++].Value.lpszA = TRANSPORT_DISPLAY_NAME_STRING;

    //
    // Set the PR_RESOURCE_METHODS property. These are the methods implemented
    // in the our IMAPIStatus implementation (CMAPIStatus class.)
    //
    spvStatusRow[i].ulPropTag = PR_RESOURCE_METHODS;
    //
    // we support ALL the methods in our implementation of IMAPIStatus interface (except the WRITABLE ones)
    //
    spvStatusRow[i++].Value.l = STATUS_SETTINGS_DIALOG |
                                STATUS_FLUSH_QUEUES |
                                STATUS_VALIDATE_STATE;

    //
    // Set the PR_STATUS_CODE property.
    //
    spvStatusRow[i].ulPropTag = PR_STATUS_CODE;
    spvStatusRow[i++].Value.l = GetTransportStatusCode();

    //
    // Set the PR_STATUS_STRING property
    //
    TCHAR szStatus[64];
    LoadStatusString (szStatus, sizeof(szStatus));
    spvStatusRow[i].ulPropTag = PR_STATUS_STRING_A;
    spvStatusRow[i++].Value.lpszA = ConvertTStringToAString(szStatus);
    //
    // Set the PR_DISPLAY_NAME property
    //
    spvStatusRow[i].ulPropTag = PR_DISPLAY_NAME_A;
    spvStatusRow[i++].Value.lpszA = TRANSPORT_DISPLAY_NAME_STRING;

    //
    // Set the PR_REMOTE_PROGRESS property
    //
    spvStatusRow[i].ulPropTag = PR_REMOTE_PROGRESS;
    spvStatusRow[i++].Value.l = -1; // Not initialized

    //
    // Set the PR_REMOTE_VALIDATE_OK property
    //
    spvStatusRow[i].ulPropTag = PR_REMOTE_VALIDATE_OK;
    spvStatusRow[i++].Value.b = TRUE;

    //
    // Write the entries on the provider's session status row
    //
    hResult = m_pSupObj->ModifyStatusRow (i, spvStatusRow, ulFlags);
    return hResult;
}


VOID WINAPI
CXPLogon::UpdateStatus(
    BOOL fAddValidate,
    BOOL fValidateOkState
    )

/*++

Routine Description:

    Updates the transport status row of this transport in the MAPI Mail
    subsystem. Updates the flags according the internal state flags
    maintained in status code of the transport and loads a readable status
    string to reset the status row. The caller of this method should update
    the status code member variable prior to calling UpdateStatus()

Arguments:

    fAddValidate
    fValidateOkState

Return Value:

    None.

--*/

{
	HRESULT hResult = S_OK;
    DBG_ENTER(TEXT("CXPLogon::UpdateStatus"),hResult);

    ULONG cProps = 1;
    SPropValue rgProps[1] = { 0 };

    rgProps[0].ulPropTag = PR_STATUS_CODE;
    rgProps[0].Value.l = GetTransportStatusCode();

    hResult = m_pSupObj->ModifyStatusRow( cProps, rgProps, STATUSROW_UPDATE );
}


BOOL WINAPI
CXPLogon::LoadStatusString(
    LPTSTR pString,
    UINT uStringSize
    )

/*++

Routine Description:

    Loads a string from the transport's stringtable. This method is called
    by the CXPLogon::UpdateStatus method when updating a status row. This
    method loads the string based on the status bits of the transport
    status code

Arguments:

    pString      - Pointer to a string which will hold the status string
    uStringSize  - Maximum number of characters allowed in the string

Return Value:

   TRUE     - If the string was found in the string table.
   FALSE    - The string was not found. The String indicated by
              pString is set to hold 0 characters

--*/

{
	BOOL bRet = TRUE;
	DBG_ENTER(TEXT("CXPLogon::LoadStatusString"),bRet);

    _tcscpy( pString, _T("Status String") );
    return bRet;
}


STDMETHODIMP
CXPLogon::TransportNotify(
    ULONG * pulFlags,
    LPVOID * ppvData
    )

/*++

Routine Description:

    Update the status row registered by this transport with MAPI.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::TransportNotify"),hResult,TEXT("ulFlags=%d"),*pulFlags);

    ULONG ulOldStatus = GetTransportStatusCode();

    if (*pulFlags & NOTIFY_BEGIN_INBOUND) 
    {
        RemoveStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_INBOUND) 
    {
        RemoveStatusBits( STATUS_INBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND) 
    {
        AddStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND) 
    {
        RemoveStatusBits( STATUS_OUTBOUND_ENABLED );
    }
    if (*pulFlags & NOTIFY_BEGIN_OUTBOUND_FLUSH) 
    {
        m_pSupObj->SpoolerNotify( NOTIFY_SENTDEFERRED, NULL );
    }
    if (*pulFlags & NOTIFY_END_OUTBOUND_FLUSH) 
    {
        RemoveStatusBits( STATUS_OUTBOUND_FLUSH );
    }
    if (*pulFlags & NOTIFY_END_INBOUND_FLUSH) 
    {
        RemoveStatusBits( STATUS_INBOUND_FLUSH );
    }

    if (ulOldStatus != GetTransportStatusCode()) 
    {
        UpdateStatus();
    }

    return hResult;
}

STDMETHODIMP
CXPLogon::Idle(
    ULONG ulFlags
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    S_OK always.

--*/

{
	//
	// We should not get called here, because we told
    // the spooler not to call us here.
	//
	DBG_ENTER(TEXT("CXPLogon::Idle"));

	Assert(false);
    return S_OK;
}


STDMETHODIMP
CXPLogon::TransportLogoff(
    ULONG ulFlags
    )

/*++

Routine Description:

    This method is called by the spooler when the transport should do final
    arragements before it gets released.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::TransportLogoff"),hResult,TEXT("ulFlags=%d"),ulFlags);

    //
    // We should attempt to remove the transport's status row from
    // the system
    //
    hResult = m_pSupObj->ModifyStatusRow (0, NULL, 0);

	if (S_OK != hResult)
	{
		CALL_FAIL (GENERAL_ERR, TEXT("ModifyStatusRow"), hResult);

		//
		// Don't fail the call
		//
		hResult = S_OK;
	}
    return hResult;
}


STDMETHODIMP
CXPLogon::SubmitMessage(
    ULONG     ulFlags,
    LPMESSAGE pMsgObj,
    ULONG *   pulMsgRef,
    ULONG *   pulReturnParm
    )

/*++

Routine Description:

    This method is called by the spooler when a client submits a
    message to a recipient whose address type this transport handles.
    The spooler calls this method twice for each deferred message.
    The first time (before the delivery time) when the message is
    submitted by the client, we simply return. The message is then queued
    by the spooler for later delivery. We keep track of when it's time
    to send deferred messages.

    The second time we're called, the state variable will be 'READY' and
    we go ahead and start the actual transmission. While we're in the
    body of this function, the implied state is 'SENDING'

    If the client logs out of this session, any pending messages get
    queued again the next time it logs in.

    In this transport we get a recipient table, we restrict the table for
    unmarked recipients. After the table is ready we invoke a helper
    method to do the actual transmission.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	LPADRLIST pOurAdrList = NULL;
    ULONG ulRow, ulRecipCount = 0;
    LPSPropValue pProps;
    FILETIME ft;
    SYSTEMTIME st;
    BOOL bSentSuccessfully;
    ULONG cValues;
    LPSPropValue pMsgProps = NULL;
    BOOL NeedDeliveryReport;
    TCHAR szHeaderText[1024];
    LPSTREAM lpstmT = NULL;
    DWORD dwRslt;
    TCHAR ErrorText[256],FailedText[256];
    BOOL UseRichText = FALSE;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPMAPITABLE pTable = NULL;
    LPSRowSet pRecipRows = NULL;

    SPropValue   propResponsibility = {0};
    SPropValue   propAddrType = {0};
    SRestriction RestrictAnd[2] = {0};
    SRestriction Restriction = {0};
    DWORD        dwRowCount = 0;

    DBG_ENTER(TEXT("CXPLogon::SubmitMessage"),hResult,TEXT("ulFlags=%d"),ulFlags);

    CheckSpoolerYield( TRUE );
    
    //
    // Get the recipient table from the message
    //
    hResult = pMsgObj->GetRecipientTable( FALSE , &pTable );
    if (hResult) 
    {
        goto ErrorExit;
    }

    //
    // The spooler marks all the message recipients this transport has to
    // handle with PR_RESPONSIBILITY set to FALSE
    // and PR_ADDRTYPE_A is FAX
    //
    propResponsibility.ulPropTag = PR_RESPONSIBILITY;
    propResponsibility.Value.b   = FALSE;

    propAddrType.ulPropTag   = PR_ADDRTYPE_A;
    propAddrType.Value.lpszA = FAX_ADDRESS_TYPE_A;

    RestrictAnd[0].rt                        = RES_PROPERTY;
    RestrictAnd[0].res.resProperty.relop     = RELOP_EQ;
    RestrictAnd[0].res.resProperty.ulPropTag = PR_RESPONSIBILITY;
    RestrictAnd[0].res.resProperty.lpProp    = &propResponsibility;

    RestrictAnd[1].rt                        = RES_PROPERTY;
    RestrictAnd[1].res.resProperty.relop     = RELOP_EQ;
    RestrictAnd[1].res.resProperty.ulPropTag = PR_ADDRTYPE_A;
    RestrictAnd[1].res.resProperty.lpProp    = &propAddrType;

    Restriction.rt               = RES_AND;
    Restriction.res.resAnd.cRes  = 2;
    Restriction.res.resAnd.lpRes = RestrictAnd;

    hResult = pTable->Restrict( &Restriction, 0 );
    if (hResult) 
    {
        goto ErrorExit;
    }

    hResult = pTable->GetRowCount(0, &dwRowCount);
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    if(0 == dwRowCount)
    {
        //
        // There are no fax recipients
        //
        goto ErrorExit;
    }

    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();

    hResult = HrAddColumns(
        pTable,
        (LPSPropTagArray) &sptRecipTable,
        gpfnAllocateBuffer,
        gpfnFreeBuffer
        );
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    hResult = HrQueryAllRows(
        pTable,
        NULL,
        NULL,
        NULL,
        0,
        &pRecipRows
        );
    if (FAILED(hResult)) 
    {
        goto ErrorExit;
    }

    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();

    //
    //Get the message properties
    //
    hResult = pMsgObj->GetProps(
                (LPSPropTagArray) &sptPropsForHeader, 
                0, 
                &cValues, 
                &pMsgProps
                );
    if (!HR_SUCCEEDED(hResult)) 
    {
        CALL_FAIL(GENERAL_ERR, TEXT("GetProps"), hResult);
        goto ErrorExit;
    }

    hResult = pMsgObj->OpenProperty(
                PR_RTF_COMPRESSED, 
                &IID_IStream, 
                0, 
                0, 
                (LPUNKNOWN*) &lpstmT
                );
    if (FAILED(hResult)) 
    {
        hResult = pMsgObj->OpenProperty(
                    PR_BODY, 
                    &IID_IStream, 
                    0, 
                    0, 
                    (LPUNKNOWN*) &lpstmT
                    );
        if (FAILED(hResult)) 
        {
            //
            // the message body is empty
            //
            lpstmT = NULL;
        }
        hResult = S_OK;
    } 
    else 
    {
        UseRichText = TRUE;
    }
   
    
    if (PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED == pMsgProps[MSG_DR_REPORT].ulPropTag && pMsgProps[MSG_DR_REPORT].Value.b) 
    {
        NeedDeliveryReport = TRUE;
    } 
    else 
    {
        NeedDeliveryReport = FALSE;
    }

    GetSystemTime (&st);
  	if(!SystemTimeToFileTime(&st, &ft))
	{
        dwRslt = ::GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("SystemTimeToFileTime"), dwRslt);
    }
    //
    // submit the fax 
    //
    dwRslt = SendFaxDocument
            ( 
            pMsgObj, 
            lpstmT, 
            UseRichText, 
            pMsgProps, 
            pRecipRows 
            );

    bSentSuccessfully = (dwRslt == S_OK);

    for (ulRow=0; ulRow<pRecipRows->cRows; ulRow++) 
    {
        pProps = pRecipRows->aRow[ulRow].lpProps;

        //
        // Update the PR_RESPONSIBILITY to TRUE, so that MAPI will ask another transport 
        // provider to try and send it.
        //
        pProps[RECIP_RESPONSIBILITY].ulPropTag = PR_RESPONSIBILITY;
        pProps[RECIP_RESPONSIBILITY].Value.b = TRUE;
            
        if (!bSentSuccessfully) 
        {
            //
            // for each recipient: insert NDR string as a property value, update delivery time as NULL, 
            // and live the PR_RESPONSIBILITY == false, so that MAPI will try to send the fax via another 
            // transport provider. 
            //
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_NULL;
            LoadString( g_FaxXphInstance, IDS_FAILED_MESSAGE, FailedText, sizeof(FailedText) / sizeof(FailedText[0]));
            LoadString( g_FaxXphInstance, dwRslt, ErrorText, sizeof(ErrorText) / sizeof(ErrorText[0]));
            wsprintf( szHeaderText,_T("\t%s\r\n\t%s\r\n"),FailedText,ErrorText);
			LPSTR pTmpStr = ConvertTStringToAString(szHeaderText);
            if (!pTmpStr)
            {
                hResult = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;                
            }
            LPSTR pStrA;
            hResult = gpfnAllocateMore( CbtszsizeA(pTmpStr), pProps, (LPVOID *)&pStrA );
            if (SUCCEEDED(hResult)) 
            {
                //
                // Copy the formatted string and hook it into the pre-allocated (by MAPI) column
                //
                _mbscpy ((PUCHAR)pStrA, (PUCHAR)pTmpStr);//pStrA is preAllocated. no need to check for NULL
                pProps[RECIP_REPORT_TEXT].ulPropTag = PR_REPORT_TEXT_A;
                pProps[RECIP_REPORT_TEXT].Value.lpszA = pStrA;
            } 
            else 
            {
                pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
                pProps[RECIP_REPORT_TEXT].Value.err = hResult;
            }
			MemFree(pTmpStr);
            pTmpStr = NULL;
            gpfnFreeBuffer(pStrA); //allocated with gpfnAllocateMore which is MAPIAllocateMore
            pStrA = NULL;
        } 
        else 
        {
            //
            // for each recipient: insert DR string as a property value, update delivery time, 
            // For delivery report, each recipient must have this property set.
            // Otherwise the spooler will default to generate an NDR instead.
            //
            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_DELIVER_TIME;
            pProps[RECIP_DELIVER_TIME].Value.ft = ft;

            pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT));
            pProps[RECIP_REPORT_TEXT].Value.err = S_OK;
        }

        //
        // add this recipient to a recipients list, that includes only the recipients we've tried 
        // to send to. (we either succeeded to queue all of them or we failed to queue all of them).
        //

        //
        // Does the list where this recipient goes have enough room for one more entry?
        // If not, resize the address list to hold QUERY_SIZE more entries.
        //
        if (!(pOurAdrList ) || ((pOurAdrList)->cEntries + 1 > ulRecipCount)) 
        {
            hResult= GrowAddressList( &pOurAdrList , 10, &ulRecipCount );
            if (hResult) 
            {
                goto ErrorExit;
            }
        }

        //
        // We have room now so store the new ADRENTRY. As part of the
        // storage, we're going to copy the SRow pointer from the SRowSet
        // into the ADRENTRY. Once we've done this, we won't need the
        // SRowSet any more ... and the SRow will be released when
        // we unwind OurAdrList
        //
        (pOurAdrList)->aEntries[(pOurAdrList)->cEntries].cValues = pRecipRows->aRow[ulRow].cValues;
        (pOurAdrList)->aEntries[(pOurAdrList)->cEntries].rgPropVals = pRecipRows->aRow[ulRow].lpProps;

        //
        // Increase the number of entries in the address list
        //
        (pOurAdrList)->cEntries++;
    }


    //
    // Now we need to save changes on the message and close it.
    // After this, the message object can't be used.
    //
    hResult = pMsgObj->SaveChanges(0);
    switch (hResult)
    {
        case S_OK:  
        case MAPI_E_NO_ACCESS:
                    break;
        case MAPI_E_OBJECT_DELETED:

        case MAPI_E_OBJECT_CHANGED:
                    goto ErrorExit;
        default:    break;
    }

    
    //
    // Let the MAPI spooler do other things
    //
    CheckSpoolerYield();
     
    //
    // change our MsgObj's recipients list, so that it'll include only those that got the message.
    //
    if(pOurAdrList)
    {
        hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pOurAdrList);
        hResult = S_OK; 
        //
        // We'll drop the error code from the modify recipients call
        //
    }
        
    if (bSentSuccessfully) 
    {    
        if ((NeedDeliveryReport) && (pOurAdrList))
		{
			VERBOSE (DBG_MSG, TEXT("xport\\xplogon.cpp\\SubmitMessage: Sending delivery Report"));
        	//
            //let spooler know he has to send delivery rec. to those addresses. 
            //
			hResult = m_pSupObj->StatusRecips( pMsgObj, pOurAdrList);
            if (!HR_FAILED(hResult))
			{
				//
                // If we were successful, we should null out the pointer becase MAPI released
				// the memory for this structure. And we should not try to release it
				// again in the cleanup code.
                //
				pOurAdrList = NULL;
	        }
        }
    }

    if (! bSentSuccessfully) 
    {
        if(pOurAdrList)
        {
            hResult = pMsgObj->ModifyRecipients( MODRECIP_MODIFY, pOurAdrList);

            //
            // We'll drop the error code from the modify recipients call
            //
            VERBOSE (DBG_MSG, TEXT("xport\\xplogon.cpp\\SubmitMessage: Sending UnDelivery Report"));
            //
            //let spooler know he has to send undelivery rec. to those addresses. 
            //
            hResult = m_pSupObj->StatusRecips( pMsgObj, pOurAdrList);
            if (!HR_FAILED(hResult)) 
            {
                //
                // If we were successful, we should null out the pointer becase MAPI released
                // the memory for this structure. And we should not try to release it
                // again in the cleanup code.
                //
                pOurAdrList = NULL;
            }
        }
    }

ErrorExit:
     //
     // Release the table, we're finished with it
     //
    if (pTable) 
    {
        pTable->Release();
    }

    if (pRecipRows) 
    {
        FreeProws( pRecipRows );
    }

    if (pMsgProps) 
	{
        MemFree( pMsgProps );
		pMsgProps = NULL;
    }

    if (lpstmT) 
    {
        lpstmT->Release();
    }
    if(pOurAdrList)
    {
        MAPIFreeBuffer(pOurAdrList);    
    }
    
    //
    // In case there is a warning or error floating around, don't let it escape to the spooler.
    //
    if (FAILED(hResult)) 
    {
        //
        // We default to MAPI_E_NOT_ME so that the spooler would attempt handle
        // the message to other transport (currently running in this profile)
        // that handle the same address type as ours.
        //
        hResult = MAPI_E_NOT_ME;
    } 
    else 
    {
        hResult = S_OK;
    }
	return hResult;
}


STDMETHODIMP
CXPLogon::GrowAddressList(
    LPADRLIST *ppAdrList,
    ULONG     ulResizeBy,
    ULONG     *pulOldAndNewCount
    )

/*++

Routine Description:

    In this function, given an address list with pulOldAndNewCount of
    entries, we resize the address list to hold the old number of
    entries plus the ulResizeBy entries. The old address list contents
    are copied to the new list and the count reset. The memory for the
    old address list is released here.

Arguments:

    ppAdrList           - Pointer to an address where the old address list
                          is and where the new resized address list will
                          be returned
    ulResizeBy          - Number of new address entries to add to the list
    pulOldAndNewCount   - Number of entries in the old address list. In
                          this parameter, upon sucessful return, will have
                          the number of in the new address list

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::GrowAddressList"),hResult);

    LPADRLIST pNewAdrList;
    // Calculate how big the new buffer for the expanded address list should be
    ULONG cbSize = CbNewADRLIST ((*pulOldAndNewCount) + ulResizeBy);
    // Allocate the memory for it
    hResult = gpfnAllocateBuffer (cbSize, (LPVOID *)&pNewAdrList);
    if (hResult) 
    {
        // We can't continue
        return hResult;
    }

    // Zero-out all memory for neatness
    ZeroMemory (pNewAdrList, cbSize);

    // If we had entries in the old address list, copy the memory from
    // the old addres list into the new expanded list
    if ((*pulOldAndNewCount)) 
    {
        CopyMemory( pNewAdrList, *ppAdrList, CbNewADRLIST ((*pulOldAndNewCount)) );
    }

    // Set the number of entries in the new address list to the OLD size
    pNewAdrList->cEntries = (*pulOldAndNewCount);

    // We must return the number of available entries in the new expanded address list
    (*pulOldAndNewCount) += ulResizeBy;

    // Free the old memory and put the new pointer in place
    gpfnFreeBuffer (*ppAdrList);
    *ppAdrList = pNewAdrList;
    return hResult;
}


STDMETHODIMP
CXPLogon::EndMessage(
    ULONG ulMsgRef,
    ULONG *pulFlags
    )

/*++

Routine Description:

    This method is called by the spooler for each message we're to
    deliver. It's the mate to SubmitMessage. We're called here twice
    for each deferred message and once for non-deferred (realtime)
    messages.

    We first check the transport state, and if we're
    WAITING for the scheduled delivery time to arrive, we return
    END_DONT_RESEND in *pulFlags, which tells the spooler to queue this
    message for deferred delivery.

    If the state is SENDING, we're getting called here after
    a message has been dequeued and delivered. Return 0 in *pulFlags
    to tell the spooler the message has been delivered.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::EndMessage"),hResult);

    *pulFlags = 0;
    return hResult;
}


STDMETHODIMP
CXPLogon::Poll(
    ULONG *pulIncoming
    )

/*++

Routine Description:

    Stub method. We should not get called here, because we told
    the spooler not to call us here.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::StartMessage(
    ULONG      ulFlags,
    LPMESSAGE  pMsgObj,
    ULONG *    pulMsgRef
    )

/*++

Routine Description:

    This method gets called when an incoming message is pending to be
    processed.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::StartMessage"));
	
	//
	//We should not get called here since we don't deal with incoming messages
	//
	Assert(false);
    return S_OK;
}


STDMETHODIMP
CXPLogon::OpenStatusEntry(
    LPCIID          pInterface,
    ULONG           ulFlags,
    ULONG *         pulObjType,
    LPMAPISTATUS *  ppEntry
    )

/*++

Routine Description:

    This method is called to get an IMAPIStatus object for this XPLOGON
    session.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
	HRESULT hResult = S_OK;
	DBG_ENTER(TEXT("CXPLogon::OpenStatusEntry"),hResult);
	
    if (MAPI_MODIFY & ulFlags) 
    {
		hResult = E_ACCESSDENIED;
        goto exit;
    }

    *pulObjType = MAPI_STATUS;

exit:
    return hResult;
}


STDMETHODIMP
CXPLogon::ValidateState(
    ULONG ulUIParam,
    ULONG ulFlags
    )

/*++

Routine Description:

    This function gets caller by a client in order to validate the
    transport logon properties. This function open the profile with the
    most up-to-date properties and then compares them to what the transport
    has stored internally.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}


STDMETHODIMP
CXPLogon::FlushQueues(
    ULONG       ulUIParam,
    ULONG       cbTargetTransport,
    LPENTRYID   pTargetTransport,
    ULONG       ulFlags
    )

/*++

Routine Description:

    Called by the MAPI spooler when, upon request of the client or
    ourselves, we need to flush the inbound or outbound queue.
    Here we make connections to the server to download messages, refresh
    the remote message headers, and request the spooler to send us any
    deferred messages.
    Transport connecting only in FlushQueues() allow the MAPI spooler to
    better manage contention of multiple transport accessing common
    communication resources (such as COM ports) and let the spooler give us
    messages to process when is best for the overall subsystem.

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    return S_OK;
}

void WINAPI
CXPLogon::CheckSpoolerYield(
    BOOL fReset
    )

/*++

Routine Description:

    Enforce the 0.2 second rule for transport that need to yield to the
    MAPI spooler.  Called periodically while processing a message to
    determine if we have used more than 0.2 seconds.  If so, then call
    SpoolerYield(), else just continue.
    This is called with fReset set to TRUE when we first enter one
    of the Transport Logon methods (usually one that is known to
    take a long time like StartMessage() or SubmitMessage(). )

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    DWORD dwStop;
    static DWORD dwStart;
    if (fReset)
    {
        dwStart = GetTickCount();
    }
    else
    {
        dwStop = GetTickCount();
        if ((dwStop - dwStart) > 200) // 200 milliseconds
        {
            m_pSupObj->SpoolerYield (0);
            dwStart = GetTickCount();
        }
    }
}

STDMETHODIMP_(ULONG)
CXPLogon::AddRef()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ++m_cRef;
    return m_cRef;
}


STDMETHODIMP_(ULONG)
CXPLogon::Release()

/*++

Routine Description:

Arguments:

    Refer to MAPI Documentation on this method.

Return Value:

    An HRESULT.

--*/

{
    ULONG ulCount = --m_cRef;
    if (!ulCount) 
    {
        delete this;
    }

    return ulCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\bvt.cpp ===
//
//
// Filename:    bvt.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        30-Dec-98
//
//


#pragma warning(disable :4786)

#include "bvt.h"
#include <iniutils.h>

// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
BOOL    g_fFaxServer = FALSE;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
BOOL    g_fNT4OrLater = FALSE;

// szCompareTiffFiles:
//  indicates whether to comapre the tiffs at the end of the test
//
BOOL g_fCompareTiffFiles = FALSE;

// szUseSecondDeviceToSend:
//  specifies whether the second device should be used to send faxes
//
BOOL g_fUseSecondDeviceToSend = FALSE;

//
// Bvt files
//
LPTSTR  g_szBvtDir     = NULL; //TEXT("C:\\CometBVT\\FaxBvt");
LPTSTR  g_szBvtDocFile = NULL;
LPTSTR  g_szBvtHtmFile = NULL;
LPTSTR  g_szBvtBmpFile = NULL;
LPTSTR  g_szBvtTxtFile = NULL;


//
// global recipient profiles (used in test cases)
//
FAX_PERSONAL_PROFILE g_RecipientProfile[3] = {0,0,0};
std::map<tstring, tstring>  g_RecipientMap[3];
DWORD g_RecipientsCount = sizeof(g_RecipientProfile) / sizeof(FAX_PERSONAL_PROFILE);

//
// extern, input ini file path
//
extern TCHAR* g_InputIniFile;

#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR TEXT("true")

//
// counts the number of successfully sent faxes
//
static DWORD g_dwFaxesCount = 0;

//
//
//
BOOL GetIsThisNT4OrLater(void)
{
    DWORD dwOsVersion = ::GetVersion();
    _ASSERTE(dwOsVersion);

    //
    // check if OS is NT4 or later
    //

    if (dwOsVersion >= 0x80000000)
    {
        // Win32 with Windows 3.1 or Win9x
        // Fax Server invocation
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        return(FALSE);
    }

    // Windows NT/2000
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwOsVersion)));
    if (dwWindowsMajorVersion < 4)
    {
        // NT 3.??
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax CLIENT (WIN9X) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        return(FALSE);
    }

    // Windows NT4 or later
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d [GetIsThisNT4OrLater]\r\nWill Run Fax SERVER (NT4\\NT5) Tests\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
    return(TRUE);
}


//
// GetBoolFromStr:
//
static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("\n3rd param is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}

//
// static function, set recipient's default profile
//
static void SetDefaultRecipientProfile(const DWORD dwIndex)
{
    
    _ASSERTE( (dwIndex >= 0) && (dwIndex < g_RecipientsCount));
    
    g_RecipientProfile[dwIndex].lptstrName = TEXT("Default Recipient Number");
    g_RecipientProfile[dwIndex].lptstrFaxNumber = NULL;
    g_RecipientProfile[dwIndex].lptstrCompany = TEXT("Default Recipient Number Company");
    g_RecipientProfile[dwIndex].lptstrStreetAddress = TEXT("Default Recipient Number Company");
    g_RecipientProfile[dwIndex].lptstrCity = TEXT("Default Recipient Number City");
    g_RecipientProfile[dwIndex].lptstrState = TEXT("Default Recipient Number State");
    g_RecipientProfile[dwIndex].lptstrZip = TEXT("Default Recipient Number Zip");
    g_RecipientProfile[dwIndex].lptstrCountry = TEXT("Default Recipient Number Country");
    g_RecipientProfile[dwIndex].lptstrTitle = TEXT("Default Recipient Number Title");
    g_RecipientProfile[dwIndex].lptstrDepartment = TEXT("Default Recipient Number Department");
    g_RecipientProfile[dwIndex].lptstrOfficeLocation = TEXT("Default Recipient Number OfficeLocation");
    g_RecipientProfile[dwIndex].lptstrHomePhone = TEXT("Default Recipient Number HomePhone");
    g_RecipientProfile[dwIndex].lptstrEmail = TEXT("Default Recipient Number EMail");
    g_RecipientProfile[dwIndex].lptstrBillingCode = TEXT("Default Recipient Number BillingCode");
    g_RecipientProfile[dwIndex].lptstrTSID = TEXT("Default Recipient Number TSID");
}


// Forward declerations:

#ifdef _NT5FAXTEST
//
// Use legacy API
//

#define SetupPort SetupPort_OLD
//
// SetupPort_OLD:
//  Private module function used to set port configuration.
//  See end of file.
//
// _OLD because it uses old NT5Fax winfax.dll APIs
//
static BOOL SetupPort_OLD(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO       pPortInfo,
    IN DWORD                dwFlags,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    );

#else // !_NT5FAXTEST
//
// Use private extended API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
);

#define SetupPort SetupPort_NEW
//
// SetupPort_NEW:
//  Private module function used to set port configuration.
//  See end of file.
//
// _NEW because it uses new BosFax fxsapi.dll APIs
//
static BOOL SetupPort_NEW(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO_EX    pPortInfo,
    IN BOOL                 bSend,
    IN BOOL                 bReceive,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    );

#endif // #ifdef _NT5FAXTEST

//
// SendRegularFax:
//  Private module function used to send a fax
//  See end of file.
//
static BOOL SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Server_SendRegularFax:
//  Private module function used to send a fax from a Fax Server
//  See end of file.
//
static BOOL Server_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Client_SendRegularFax:
//  Private module function used to send a fax from a Fax Client
//  See end of file.
//
static BOOL Client_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// Client_SendBroadcastFax:
//  Private module function used to send a broadcast (3 * same recipient)
//  See end of file.
//
static BOOL Client_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// PollJobAndVerify:
//  Private module function used to poll job status
//  See end of file.
//
static BOOL PollJobAndVerify(
    HANDLE /* IN */ hFaxSvc,
    MY_MSG_ID /* IN */ MsgId
);

//
// Server_SendBroadcastFax:
//  Private module function used to send a broadcast fax from a Fax Server.
//  See end of file.
//
static BOOL Server_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// SendFaxFromApp:
//  Private module function used to send a fax from application
//
//  See end of file.
//
static BOOL SendFaxFromApp(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);


//
// TurnOffCfgWzrd:
//  Turns off implicit invocation of Configuration Wizard.
//
//  See end of file.
//
static BOOL TurnOffCfgWzrd(void);


//
// EmptyFaxQueue:
//  Removes all jobs from the fax queue.
//
//  See end of file.
//
static BOOL EmptyFaxQueue(HANDLE hFaxServer);


//
// InitRecipientProfiles:
//  Initializes three recipients profiles with hard coded user info
//  according to
//
VOID InitRecipientProfiles()
{
    DWORD dwIndex;

    for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
    {
        g_RecipientProfile[dwIndex].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    }

    try
    {
        //
        // Read the list of recipients records from ini file.
        std::vector<tstring> RecipientsList =  INI_GetSectionList( g_InputIniFile,
                                                               RECIPIENTS_SECTION);

        for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
        {
            if(RecipientsList.size() > dwIndex )
            {
                tstring tstrRecipientEntry = RecipientsList[dwIndex];
                g_RecipientMap[dwIndex] = INI_GetSectionEntries(g_InputIniFile,
                                                                tstrRecipientEntry);

                if(!g_RecipientMap[dwIndex].empty())
                {
                    std::map<tstring, tstring>::iterator iterMap;

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Name"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrName = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("FaxNumber"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrFaxNumber = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Company"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCompany = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("StreetAddress"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrStreetAddress = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("City"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCity = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("State"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrState = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Zip"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrZip = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Country"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrCountry = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Title"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrTitle = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Department"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrDepartment = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficeLocation"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrOfficeLocation = const_cast<TCHAR*>((iterMap->second).c_str());
                    }
                    
                    iterMap = g_RecipientMap[dwIndex].find(TEXT("HomePhone"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrHomePhone = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("OfficePhone"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrOfficePhone = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("Email"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrEmail = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("BillingCode"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrBillingCode = const_cast<TCHAR*>((iterMap->second).c_str());
                    }

                    iterMap = g_RecipientMap[dwIndex].find(TEXT("TSID"));
                    if(iterMap != g_RecipientMap[dwIndex].end())
                    {
                        g_RecipientProfile[dwIndex].lptstrTSID = const_cast<TCHAR*>((iterMap->second).c_str());
                    }
                }
                else
                {
                    SetDefaultRecipientProfile(dwIndex);
                }

            }
            else
            {
                SetDefaultRecipientProfile(dwIndex);
            }

        }
    }
    catch(Win32Err& err)
    {
        ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nException in InitRecipientProfiles:\r\n%s\r\n"),
                TEXT(__FILE__),
                __LINE__,
                err.description()
                );

        // set default recipients profile
        for(dwIndex = 0; dwIndex < g_RecipientsCount; dwIndex++)
        {
            SetDefaultRecipientProfile(dwIndex);
        }
        
    }

}




static
BOOL
DeleteFilesInDir(
    LPCTSTR     szDir
    )
{
    BOOL                fRetVal = FALSE;
    DWORD               dwFileAttrib = -1;
    BOOL                fHasDirectoryAttrib = FALSE;
    CFilenameVector*    pDirFileVector = NULL;
    DWORD ec = 0;

    _ASSERTE(NULL != szDir);

    dwFileAttrib = ::GetFileAttributes(szDir);
    if ( -1 != dwFileAttrib)
    {
        // got file attributes for szDir
        fHasDirectoryAttrib = FILE_ATTRIBUTE_DIRECTORY & dwFileAttrib;
        if ( !fHasDirectoryAttrib )
        {
            // szDir is not a directory
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nGetFileAttributes returned %d => %s is not a directory\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwFileAttrib,
                szDir
                );
            goto ExitFunc;
        }
        if (FALSE == ::GetTiffFilesOfDir(szDir, &pDirFileVector))
        {
            goto ExitFunc;
        }
        if (FALSE == ::DeleteVectorFiles(pDirFileVector))
        {
            goto ExitFunc;
        }
    }
    else
    {
        // GetFileAttributes failed
        ec = ::GetLastError();
        if ((ERROR_PATH_NOT_FOUND != ec) && (ERROR_FILE_NOT_FOUND != ec))
        {
            // error
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nGetFileAttributes failed with GetLastError()=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                ec
                );
            goto ExitFunc;
        }
        // we do not consider ERROR_PATH_NOT_FOUND and ERROR_FILE_NOT_FOUND an error
    }
    fRetVal = TRUE;

ExitFunc:
    if (pDirFileVector)
    {
        ::FreeVector(pDirFileVector);
        delete(pDirFileVector);
    }
    return(fRetVal);
}

//
// SetBvtGlobalFileVars:
//  Sets BVT global variables (g_szBvtDir, g_szBvtDocFile, g_szBvtHtmFile, g_szBvtBmpFile)
//  according to szBvtDir command line parameter
//
static
BOOL
SetBvtGlobalFileVars(
    LPCTSTR     szBvtDir
    )
{
    BOOL fRetVal = FALSE;
    DWORD dwSize = 0;

    _ASSERTE(szBvtDir);

    //
    // setup Bvt files global parameters
    //
    g_szBvtDir = (LPTSTR)szBvtDir;
    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_DOC_FILE) + 1)*sizeof(TCHAR);
    g_szBvtDocFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtDocFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtDocFile, dwSize);
    _stprintf(g_szBvtDocFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_DOC_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_HTM_FILE) + 1)*sizeof(TCHAR);
    g_szBvtHtmFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtHtmFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtHtmFile, dwSize);
    _stprintf(g_szBvtHtmFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_HTM_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_BMP_FILE) + 1)*sizeof(TCHAR);
    g_szBvtBmpFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtBmpFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtBmpFile, dwSize);
    _stprintf(g_szBvtBmpFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_BMP_FILE);

    dwSize = (_tcslen(g_szBvtDir) + _tcslen(BVT_BACKSLASH) + _tcslen(BVT_TXT_FILE) + 1)*sizeof(TCHAR);
    g_szBvtTxtFile = (LPTSTR) malloc(dwSize);
    if (NULL == g_szBvtTxtFile)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(g_szBvtTxtFile, dwSize);
    _stprintf(g_szBvtTxtFile, TEXT("%s%s%s"), g_szBvtDir, BVT_BACKSLASH, BVT_TXT_FILE);

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Fax BVT files:\r\ng_szBvtDir=%s\r\ng_szBvtDocFile=%s\r\ng_szBvtHtmFile=%s\r\ng_szBvtBmpFile=%s\r\ng_szBvtTxtFile=%s\r\n"),
        g_szBvtDir,
        g_szBvtDocFile,
        g_szBvtHtmFile,
        g_szBvtBmpFile,
        g_szBvtTxtFile
        );

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(g_szBvtDocFile);
        g_szBvtDocFile = NULL;
        free(g_szBvtHtmFile);
        g_szBvtHtmFile = NULL;
        free(g_szBvtBmpFile);
        g_szBvtBmpFile = NULL;
        free(g_szBvtTxtFile);
        g_szBvtTxtFile = NULL;
        // we didn't alloc g_szBvtDir so we don't free
    }
    return(fRetVal);
}

//
// EmptyDirectories:
//  Deletes files in szReceiveDir, szSentDir and szInboxArchiveDir directories
//  if these directories exist.
//  Note - func does not consider it an error if the directories do not exist.
//
static
BOOL
EmptyDirectories(
    LPCTSTR     szReceiveDir,
    LPCTSTR     szSentDir,
    LPCTSTR     szInboxArchiveDir
    )
{
    BOOL                fRetVal = FALSE;

    _ASSERTE(NULL != szReceiveDir);
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szInboxArchiveDir);

    // empty the "received faxes" dir
    if (FALSE == ::DeleteFilesInDir(szReceiveDir))
    {
        goto ExitFunc;
    }

    // empty the "sent faxes" dir
    if (FALSE == ::DeleteFilesInDir(szSentDir))
    {
        goto ExitFunc;
    }

    // empty the "Inbox Archive" dir
    if (FALSE == ::DeleteFilesInDir(szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);

}

//
//
//
static
BOOL
GetIsThisServerBvt(
    LPCTSTR szServerName,
    BOOL*   pfServerBvt
    )
{
    BOOL fRetVal = FALSE;

    _ASSERTE(szServerName);
    _ASSERTE(pfServerBvt);

    TCHAR   szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   dwComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    LPTSTR  szComputerNameUP = NULL;
    LPTSTR  szServerNameUP = NULL;
    ZeroMemory(szComputerName, (MAX_COMPUTERNAME_LENGTH+1)*sizeof(TCHAR));

    if (FALSE == ::GetComputerName(szComputerName, &dwComputerNameSize))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nGetComputerName returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // convert to upper case
    szServerNameUP = ::_tcsdup(szServerName);
    if (NULL == szServerNameUP)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n_tcsdup returned NULL with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // NOTE: upper case conversion is in place
    // no value reserved for error
    szServerNameUP = ::_tcsupr(szServerNameUP);
    szComputerNameUP = ::_tcsupr(szComputerName);

    if (0 == ::_tcscmp(szServerNameUP, szComputerNameUP))
    {
        // Fax Server invocation
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("\r\nRunning Fax SERVER Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
            );
        (*pfServerBvt) = TRUE;
    }
    else
    {
        // Fax Client invocation
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("\r\nRunning Fax CLIENT Tests\r\nszServerNameUP=%s\r\nszComputerNameUP=%s\r\n"),
            szServerNameUP,
            szComputerNameUP
            );
        (*pfServerBvt) = FALSE;
    }

    fRetVal = TRUE;

ExitFunc:
    free(szServerNameUP);
    return(fRetVal);
}


//
// TestSuiteSetup:
//  changes the Fax server configuration for the tests
//  Note: Logger is already running
//
BOOL TestSuiteSetup(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber1,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage,
    LPCTSTR     szReceiveDir,
    LPCTSTR     szSentDir,
    LPCTSTR     szInboxArchiveDir,
    LPCTSTR     szBvtDir,
    LPCTSTR     szCompareTiffFiles,
    LPCTSTR     szUseSecondDeviceToSend
    )
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber1);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);
    _ASSERTE(NULL != szReceiveDir);
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szInboxArchiveDir);
    _ASSERTE(NULL != szBvtDir);
    _ASSERTE(NULL != szCompareTiffFiles);
    _ASSERTE(NULL != szUseSecondDeviceToSend);

    BOOL                fRetVal                 = FALSE;
    HANDLE              hFaxSvc                 = NULL;
    int                 nPortIndex              = 0;
    DWORD               dwNumFaxPorts           = 0;


#ifdef _NT5FAXTEST
    // Testing NT5 Fax (with old winfax.dll)

    PFAX_CONFIGURATION  pFaxSvcConfig = NULL;
    PFAX_PORT_INFO      pFaxPortsConfig = NULL;

#else
    // Testing Bos Fax (with new fxsapi.dll)

    PFAX_OUTBOX_CONFIG      pOutboxConfig = NULL;
    PFAX_ARCHIVE_CONFIG     pArchiveConfig = NULL;
    PFAX_PORT_INFO_EX       pFaxPortsConfig = NULL;
#endif
    
    //
    // initialize global recipient profiles
    //
    InitRecipientProfiles();

    //
    // set g_fCompareTiffFiles according to szCompareTiffFiles
    //
    if (FALSE == GetBoolFromStr(szCompareTiffFiles, &g_fCompareTiffFiles))
    {
        goto ExitFunc;
    }

    // log command line params using elle logger
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Fax BVT params:\r\n\tszServerName=%s\r\n\tszFaxNumber1=%s\r\n\tszFaxNumber2=%s\r\n\tszDocument=%s\r\n\tszCoverPage=%s\r\n\tszReceiveDir=%s\r\n\tszSentDir=%s\r\n\tszInboxArchiveDir=%s\r\n\tszBvtDir=%s\r\n\tszCompareTiffFiles=%s\r\n\tszUseSecondDeviceToSend=%s\r\n"),
        szServerName,
        szFaxNumber1,
        szFaxNumber2,
        szDocument,
        szCoverPage,
        szReceiveDir,
        szSentDir,
        szInboxArchiveDir,
        szBvtDir,
        szCompareTiffFiles,
        szUseSecondDeviceToSend
        );

    //
    // set g_fUseSecondDeviceToSend according to szUseSecondDeviceToSend
    //
    if (FALSE == GetBoolFromStr(szUseSecondDeviceToSend, &g_fUseSecondDeviceToSend))
    {
        goto ExitFunc;
    }

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Faxes will be sent from %s to %s\r\n"),
        g_fUseSecondDeviceToSend ? szFaxNumber2 : szFaxNumber1,
        g_fUseSecondDeviceToSend ? szFaxNumber1 : szFaxNumber2
        );

    //
    // Empty fax file directories
    //
    if (FALSE == EmptyDirectories(szReceiveDir, szSentDir, szInboxArchiveDir))
    {
        goto ExitFunc;
    }

    //
    // Set bvt global file variables
    //
    if (FALSE == SetBvtGlobalFileVars(szBvtDir))
    {
        goto ExitFunc;
    }

    //
    // Setup fax service
    //
    if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szServerName,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Empty fax queue
    //
    if (FALSE == EmptyFaxQueue(hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nEmptyFaxQueue failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#ifdef _NT5FAXTEST
    // NT5Fax Test using old winfax.dll APIs

    // Retrieve the fax service configuration
    if (!FaxGetConfiguration(hFaxSvc, &pFaxSvcConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    //check that FaxGetConfiguration allocated
    _ASSERTE(pFaxSvcConfig);

    pFaxSvcConfig->Retries = 0;
    pFaxSvcConfig->PauseServerQueue = FALSE;
    pFaxSvcConfig->ArchiveOutgoingFaxes = TRUE;
    pFaxSvcConfig->ArchiveDirectory = szSentDir;

    //
    //We now use bBranding because we don't compare to a refrence directory,
    // so we can use time stamps
    //
    pFaxSvcConfig->Branding = TRUE;

    // Set the fax service configuration
    if (!FaxSetConfiguration(hFaxSvc, pFaxSvcConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup the two ports
    //

    // Retrieve the fax ports configuration
    if (!FaxEnumPorts(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);

    // make sure we have at least TEST_MIN_PORTS ports for test
    if (BVT_MIN_PORTS > dwNumFaxPorts)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
        goto ExitFunc;
    }
    else
    {
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE:%s LINE:%d\ndwNumFaxPorts=%d\nTEST_MIN_PORTS=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
    }
    // we know there are at least 2 (==TEST_MIN_PORTS) devices


    // Set 1st device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[0],
                    g_fUseSecondDeviceToSend ? FPF_RECEIVE : FPF_SEND,
                    szFaxNumber1,
                    szFaxNumber1,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // Set 2nd device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[1],
                    g_fUseSecondDeviceToSend ? FPF_SEND : FPF_RECEIVE,
                    szFaxNumber2,
                    szFaxNumber2,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // set all other devices as Receive=No and Send=No
    // NOTE: nPortIndex is 0 based
    for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
    {
        if (FALSE == SetupPort(
                        hFaxSvc,
                        &pFaxPortsConfig[nPortIndex],
                        MY_FPF_NONE,
                        DEV_TSID,
                        DEV_CSID,
                        szReceiveDir
                        )
            )
        {
            goto ExitFunc;
        }
    }

#else
    // BosFax Test using new fxsapi.dll and "extended" APIs

    //
    // Setup Service Outbox configuration
    //

    if (!FaxGetOutboxConfiguration(hFaxSvc, &pOutboxConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pOutboxConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetOutboxConfiguration returned:\r\ndwSizeOfStruct=%d\r\nbAllowPersonalCP=%d\r\nbUseDeviceTSID=%d\r\ndwRetries=%d\r\ndwRetryDelay=%d\r\r\ndtDiscountStart.Hour=%i\r\ndtDiscountStart.Minute=%i\r\ndtDiscountEnd.Hour=%i\r\ndtDiscountEnd.Minute=%i\r\ndwAgeLimit=%d\r\nbBranding=%d"),
        TEXT(__FILE__),
        __LINE__,
        pOutboxConfig->dwSizeOfStruct,
        pOutboxConfig->bAllowPersonalCP,
        pOutboxConfig->bUseDeviceTSID,
        pOutboxConfig->dwRetries,
        pOutboxConfig->dwRetryDelay,
        pOutboxConfig->dtDiscountStart.Hour,
        pOutboxConfig->dtDiscountStart.Minute,
        pOutboxConfig->dtDiscountEnd.Hour,
        pOutboxConfig->dtDiscountEnd.Minute,
        pOutboxConfig->dwAgeLimit,
        pOutboxConfig->bBranding
        );

    pOutboxConfig->bAllowPersonalCP = TRUE;
    pOutboxConfig->dwRetries = 0;

    //
    //We now use bBranding because we don't compare to a refrence directory,
    // so we can use time stamps
    //
    pOutboxConfig->bBranding = TRUE;


    if (!FaxSetOutboxConfiguration(hFaxSvc, pOutboxConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetOutboxConfiguration returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup Service Queue configuration
    //
    if (!FaxSetQueue(hFaxSvc, 0))  // inbox and outbox not blocked, outbox not paused
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetQueue returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Setup Service Inbox Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, &pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration Inbox, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
        TEXT(__FILE__),
        __LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
        );

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szInboxArchiveDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


    // Workaround for EdgeBug#8969
    //pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_INBOX, pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration Inbox, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);
    pArchiveConfig = NULL;

    //
    // Setup Service SentItems Archive configuration
    //
    if (!FaxGetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, &pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pArchiveConfig);

    ::lgLogDetail(
        LOG_X,
        2,
        TEXT("FILE:%s LINE:%d FaxGetArchiveConfiguration SentItems, returned:\r\ndwSizeOfStruct=%d\r\nbUseArchive=%d\r\nlpcstrFolder=%s\r\nbSizeQuotaWarning=%d\r\ndwSizeQuotaHighWatermark=%d\r\ndwSizeQuotaLowWatermark=%d\r\ndwAgeLimit=%d"),
        TEXT(__FILE__),
        __LINE__,
        pArchiveConfig->dwSizeOfStruct,
        pArchiveConfig->bUseArchive,
        pArchiveConfig->lpcstrFolder,
        pArchiveConfig->bSizeQuotaWarning,
        pArchiveConfig->dwSizeQuotaHighWatermark,
        pArchiveConfig->dwSizeQuotaLowWatermark,
        pArchiveConfig->dwAgeLimit
        );

    pArchiveConfig->bUseArchive = TRUE;
    pArchiveConfig->lpcstrFolder = (LPTSTR)szSentDir;
    pArchiveConfig->bSizeQuotaWarning = FALSE;


    // Workaround for EdgeBug#8969
    //pArchiveConfig->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

    if (!FaxSetArchiveConfiguration(hFaxSvc, FAX_MESSAGE_FOLDER_SENTITEMS, pArchiveConfig))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetArchiveConfiguration SentItems, returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    FaxFreeBuffer(pArchiveConfig);

    pArchiveConfig = NULL;

    //
    // Setup the two ports
    //

    // Retrieve the fax ports configuration
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPortsEx returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);

    // make sure we have at least TEST_MIN_PORTS ports for test
    if (BVT_MIN_PORTS > dwNumFaxPorts)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
        goto ExitFunc;
    }
    else
    {
        ::lgLogDetail(
            LOG_X,
            1,
            TEXT("FILE:%s LINE:%d\r\ndwNumFaxPorts=%d\r\nTEST_MIN_PORTS=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwNumFaxPorts,
            BVT_MIN_PORTS
            );
    }
    // we know there are at least 2 (==TEST_MIN_PORTS) devices

    ::lgLogDetail(
        LOG_X,
        7,
        TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration BEFORE setting\r\n"),
        TEXT(__FILE__),
        __LINE__
        );
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);

    // Set 1st device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[0],
                    !g_fUseSecondDeviceToSend,   //bSend
                    g_fUseSecondDeviceToSend,    //bReceive
                    szFaxNumber1,
                    szFaxNumber1,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // Set 2nd device as Send only or Receive only (note pFaxPortsConfig array is 0 based)
    if (FALSE == SetupPort(
                    hFaxSvc,
                    &pFaxPortsConfig[1],
                    g_fUseSecondDeviceToSend,    //bSend
                    !g_fUseSecondDeviceToSend,   //bReceive
                    szFaxNumber2,
                    szFaxNumber2,
                    szReceiveDir
                    )
        )
    {
        goto ExitFunc;
    }

    // set all other devices as Receive=No and Send=No
    // NOTE: nPortIndex is 0 based
    for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
    {
        if (FALSE == SetupPort(
                        hFaxSvc,
                        &pFaxPortsConfig[nPortIndex],
                        FALSE,  //bSend
                        FALSE,  //bReceive
                        DEV_TSID,
                        DEV_CSID,
                        szReceiveDir
                        )
            )
        {
            goto ExitFunc;
        }
    }

    FaxFreeBuffer(pFaxPortsConfig);
    pFaxPortsConfig = NULL;

    // Retrieve the fax ports configuration (to print new settings)
    if (!FaxEnumPortsEx(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    _ASSERTE(pFaxPortsConfig);
    ::lgLogDetail(
        LOG_X,
        7,
        TEXT("FILE:%s LINE:%d\r\nLogging Ports Configuration AFTER setting\r\n"),
        TEXT(__FILE__),
        __LINE__
        );
    LogPortsConfiguration(pFaxPortsConfig, dwNumFaxPorts);

#endif

    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    if (FALSE == GetIsThisServerBvt(szServerName, &g_fFaxServer))
    {
        // GetIsThisServerBvt failed
        goto ExitFunc;
    }

    //
    // Set g_fFaxServer (indicates whether to use Server or Client test)
    //
    g_fNT4OrLater = GetIsThisNT4OrLater();
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("FILE:%s LINE:%d\r\ng_fNT4OrLater=%d\r\n"),
        TEXT(__FILE__),
        __LINE__,
        g_fNT4OrLater
        );

    //
    // Turn off Configuration Wizard
    //
    if (FALSE == TurnOffCfgWzrd())
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d TurnOffCfgWzrd returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:

#ifndef _NT5FAXTEST
    // Testing Bos Fax (with new fxsapi.dll)
    ::FaxFreeBuffer(pOutboxConfig);
    ::FaxFreeBuffer(pArchiveConfig);
#endif

    ::FaxFreeBuffer(pFaxPortsConfig);
    if (FALSE == ::FaxClose(hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}


//
// TestCase1:
//  Send a fax + CP.
//
BOOL TestCase1(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        1,
        TEXT("TC#1: Send a fax + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase2:
//  Send just a CP.
//
BOOL TestCase2( 
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;
    LPCTSTR szDocumentNULL = NULL;

    ::lgBeginCase(
        2,
        TEXT("TC#2: Send just a CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocumentNULL, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase3:
//  Send a fax with no CP.
//
BOOL TestCase3(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);

    BOOL fRetVal = FALSE;
    LPCTSTR szCoverPageNULL = NULL;

    ::lgBeginCase(
        3,
        TEXT("TC#3: Send a fax with no CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPageNULL);

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase4:
//  Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL TestCase4(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        4,
        TEXT("TC#4: Send a broadcast (doc + CP)")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s\r\n"),
        szServerName,
        szFaxNumber2,
        szDocument,
        szCoverPage
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                szDocument,
                                szCoverPage
                                );

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase5:
//  Send a broadcast of only CPs (3 times the same recipient).
//
BOOL TestCase5(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        5,
        TEXT("TC#5: Send a broadcast of only CPs")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=NULL\r\n\tCoverPage=%s\r\n"),
        szServerName,
        szFaxNumber2,
        szCoverPage
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                NULL,
                                szCoverPage
                                );

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase6:
//  Send a broadcast without CPs (3 times the same recipient).
//
BOOL TestCase6(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szDocument
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szDocument);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        6,
        TEXT("TC#6: Send a broadcast without CPs")
        );
    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Server=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=NULL\r\n"),
        szServerName,
        szFaxNumber2,
        szDocument
        );

    fRetVal = Server_SendBroadcastFax(
                                szServerName,
                                szFaxNumber2,
                                szDocument,
                                NULL
                                );

    ::lgEndCase();
    return(fRetVal);
}

//
// TestCase7:
//  Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
BOOL TestCase7(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        7,
        TEXT("TC#7: Send a fax (*.doc file) + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtDocFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase8:
//  Send a fax (*.bmp file = BVT_BMP_FILE) + CP.
//
BOOL TestCase8(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        8,
        TEXT("TC#8: Send a fax (*.bmp file) + CP")
        );

    fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtBmpFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase9:
//  Send a fax (*.htm file = BVT_HTM_FILE) + CP.
//
BOOL TestCase9(
    LPCTSTR     szServerName,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        9,
        TEXT("TC#9: Send a fax (*.htm file) + CP")
        );

    //
    //Currently IExplorer has a bug in PrintTo Verb, so we skip this test
    //
    //fRetVal = SendRegularFax(szServerName, szFaxNumber2, g_szBvtHtmFile, szCoverPage);
    fRetVal = TRUE;
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("Currently IExplorer has a bug in PrintTo Verb, so we skip this test")
        );


    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase10:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
BOOL TestCase10(
    LPCTSTR     szServerName,
    LPCTSTR     szPrinterName,
    LPCTSTR     szWzrdRegHackKey,
    LPCTSTR     szFaxNumber2,
    LPCTSTR     szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber2);
    _ASSERTE(NULL != szCoverPage);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        10,
        TEXT("TC#10: Send a fax from Notepad (*.txt file) + CP")
        );

    fRetVal = SendFaxFromApp(szServerName, szPrinterName, szWzrdRegHackKey, szFaxNumber2, g_szBvtTxtFile, szCoverPage);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase11:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) without CP.
//
BOOL TestCase11(
    LPCTSTR     szServerName,
    LPCTSTR     szPrinterName,
    LPCTSTR     szWzrdRegHackKey,
    LPCTSTR     szFaxNumber2
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        11,
        TEXT("TC#11: Send a fax from Notepad (*.txt file) without CP")
        );

    fRetVal = SendFaxFromApp(szServerName, szPrinterName, szWzrdRegHackKey, szFaxNumber2, g_szBvtTxtFile, NULL);

    ::lgEndCase();
    return(fRetVal);
}


//
// TestCase12:
//  Compare all sent faxes (*.tif files) in directory szSentDir
//  with the received (*.tif) files in szReceiveDir
//
BOOL TestCase12(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReceiveDir
    )
{
    _ASSERTE(NULL != szSentDir);
    _ASSERTE(NULL != szReceiveDir);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        12,
        TEXT("TC#12: Compare SENT Files To RECEIVED Files")
        );

    // sleep a little - to allow for routing of last sent file.
    ::lgLogDetail(
        LOG_X,
        4,
        TEXT("Sleeping for 20 sec (to allow for routing of last received file)\r\n")
        );
    Sleep(20000);

    if (FALSE == DirToDirTiffCompare(szSentDir, szReceiveDir, TRUE, g_dwFaxesCount))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szSentDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    ::lgEndCase();
    return(fRetVal);
}



//
// TestCase13:
//  Compare all Inbox routed faxes (*.tif files) in directory szInboxArchiveDir
//  with the received (*.tif) files in szReceiveDir
//
BOOL TestCase13(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReceiveDir
    )
{
    _ASSERTE(NULL != szInboxArchiveDir);
    _ASSERTE(NULL != szReceiveDir);

    BOOL fRetVal = FALSE;

    ::lgBeginCase(
        13,
        TEXT("TC#13: Compare ROUTED Files To RECEIVED Files")
        );

    if (FALSE == DirToDirTiffCompare(szInboxArchiveDir, szReceiveDir, FALSE, g_dwFaxesCount))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("DirToDirTiffCompare(%s , %s) failed\r\n"),
            szInboxArchiveDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    ::lgEndCase();
    return(fRetVal);
}


//
// TestSuiteShutdown:
//  Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
    BOOL fRetVal = TRUE;

    //
    // End test suite (logger)
    //
    if (!::lgEndSuite())
    {
        //
        //this is not possible since API always returns TRUE
        //but to be on the safe side (we use printf() here since the logger is not active).
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgEndSuite returned FALSE\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        fRetVal = FALSE;
    }

    //
    // Close the Logger
    //
    if (!::lgCloseLogger())
    {
        //this is not possible since API always returns TRUE
        //but to be on the safe side (we use printf() here since the logger is not active).
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgCloseLogger returned FALSE\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        fRetVal = FALSE;
    }

    return(fRetVal);
}


#ifdef _NT5FAXTEST
//
// SetupPort_OLD:
//  Private module function, used to set port configuration.
//
// Parameters:
//  hFaxSvc         IN parameter.
//                  A handle to the Fax service.
//
//  pPortInfo       IN parameter.
//                  A pointer to the original port configuration, as returned
//                  from a call to FaxGetPort or FaxEnumPorts.
//
//  dwFlags         IN parameter.
//                  Bit flags that specify the new capabilities of the fax port.
//                  See FAX_PORT_INFO for more information.
//
//  szTsid          IN parameter.
//                  A string that specifies the new transmitting station identifier.
//
//  szCsid          IN parameter.
//                  A string that specifies the new called station identifier.
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort_OLD(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO       pPortInfo,
    IN DWORD                dwFlags,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    )
{
    BOOL    fRetVal = FALSE;
    HANDLE  hPort = NULL;
    DWORD   dwRoutingInfoSize = 0;
    BYTE*   pRoutingInfo = NULL;
    LPDWORD pdwRoutingInfoMask =NULL;
    LPWSTR  szRoutingDir = NULL;

    // check in params
    _ASSERTE(NULL != hFaxSvc);
    _ASSERTE(NULL != pPortInfo);
    _ASSERTE(NULL != szTsid);
    _ASSERTE(NULL != szCsid);
    _ASSERTE(NULL != szReceiveDir);

    // Set pPortInfo as required
    pPortInfo->Flags = dwFlags;
    pPortInfo->Tsid  = szTsid;
    pPortInfo->Csid  = szCsid;

    // get the device Id
    DWORD dwDeviceId = pPortInfo->DeviceId;

    // open the port for configuration
    if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // set the device configuration
    if(!FaxSetPort(hPort, pPortInfo))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetPort returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // set device inbound "StoreInFolder" routing
    //
    // this info is read as UNICODE on the server
    // so we take the TCHAR string szReceiveDir and "convert" it to unicode
    //
    dwRoutingInfoSize = sizeof(DWORD) + (sizeof(WCHAR)*(::_tcslen(szReceiveDir)+1)); // MS StoreInFolder routing method expects DWORD followed by UNICODE string
    pRoutingInfo = (BYTE*) malloc(dwRoutingInfoSize);
    if (NULL == pRoutingInfo)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pRoutingInfo, dwRoutingInfoSize);
    pdwRoutingInfoMask = (LPDWORD)pRoutingInfo;
    (*pdwRoutingInfoMask) = LR_STORE;  // to indicate StoreInFolder Routing Method is active
    szRoutingDir = (LPWSTR)(pRoutingInfo + sizeof(DWORD)); //szRoutingDir is UNICODE

#ifndef _UNICODE
    // ANSI //

    // need to "convert" szReceiveDir into UNICODE (szRoutingDir);
    if (!::MultiByteToWideChar(
                        CP_ACP,
                        0,
                        szReceiveDir,
                        -1,
                        szRoutingDir,
                        (dwRoutingInfoSize - sizeof(DWORD))
                        )
       )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#else
    // UNICODE //

    ::_tcscpy(szRoutingDir, szReceiveDir);
    if (0 != ::_tcscmp(szRoutingDir, szReceiveDir))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d tcscmp returned FALSE szRoutingDir=%s szReceiveDir=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szRoutingDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

#endif

    if(!FaxSetRoutingInfo(
        hPort,
        REGVAL_RM_FOLDER_GUID,
        pRoutingInfo,
        dwRoutingInfoSize
        )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxRouteSetRoutingInfo returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    free(pRoutingInfo);
    if (FALSE == ::FaxClose(hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}

#else // !_NT5FAXTEST

//
// SetupPort_NEW:
//  Private module function, used to set port configuration.
//
// Parameters:
//  hFaxSvc         IN parameter.
//                  A handle to the Fax service.
//
//  pPortInfo       IN parameter.
//                  A pointer to the original port configuration, as returned
//                  from a call to FaxGetPort or FaxEnumPorts.
//
//  dwFlags         IN parameter.
//                  Bit flags that specify the new capabilities of the fax port.
//                  See FAX_PORT_INFO for more information.
//
//  szTsid          IN parameter.
//                  A string that specifies the new transmitting station identifier.
//
//  szCsid          IN parameter.
//                  A string that specifies the new called station identifier.
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort_NEW(
    IN HANDLE               hFaxSvc,
    IN PFAX_PORT_INFO_EX    pPortInfo,
    IN BOOL                 bSend,
    IN BOOL                 bReceive,
    IN LPCTSTR              szTsid,
    IN LPCTSTR              szCsid,
    IN LPCTSTR              szReceiveDir
    )
{
    BOOL    fRetVal = FALSE;
    HANDLE  hPort = NULL;
    DWORD   dwRoutingInfoSize = 0;
    BYTE*   pRoutingInfo = NULL;
    LPDWORD pdwRoutingInfoMask =NULL;
    LPWSTR  szRoutingDir = NULL;

    // check in params
    _ASSERTE(NULL != hFaxSvc);
    _ASSERTE(NULL != pPortInfo);
    _ASSERTE(NULL != szTsid);
    _ASSERTE(NULL != szCsid);
    _ASSERTE(NULL != szReceiveDir);

    // Set pPortInfo as required
    pPortInfo->bSend        = bSend;
    pPortInfo->ReceiveMode     = bReceive ? FAX_DEVICE_RECEIVE_MODE_AUTO : FAX_DEVICE_RECEIVE_MODE_OFF;
    pPortInfo->lptstrTsid   = (LPTSTR)szTsid;
    pPortInfo->lptstrCsid   = (LPTSTR)szCsid;

    // get the device Id
    DWORD dwDeviceId = pPortInfo->dwDeviceID;

    // set the device configuration
    if(!FaxSetPortEx(hFaxSvc, dwDeviceId, pPortInfo))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxSetPortEx for dwDeviceId=%d returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwDeviceId,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    // open the port for configuration (we need this for setting routing info)
    if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // set device inbound "StoreInFolder" routing
    //
    // this info is read as UNICODE on the server
    // so we take the TCHAR string szReceiveDir and "convert" it to unicode
    //
    dwRoutingInfoSize = sizeof(DWORD) + (sizeof(WCHAR)*(::_tcslen(szReceiveDir)+1)); // MS StoreInFolder routing method expects DWORD followed by UNICODE string
    pRoutingInfo = (BYTE*) malloc(dwRoutingInfoSize);
    if (NULL == pRoutingInfo)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pRoutingInfo, dwRoutingInfoSize);
    pdwRoutingInfoMask = (LPDWORD)pRoutingInfo;
    (*pdwRoutingInfoMask) = LR_STORE;  // to indicate StoreInFolder Routing Method is active
    szRoutingDir = (LPWSTR)(pRoutingInfo + sizeof(DWORD)); //szRoutingDir is UNICODE

#ifndef _UNICODE
    // ANSI //

    // need to "convert" szReceiveDir into UNICODE (szRoutingDir);
    if (!::MultiByteToWideChar(
                        CP_ACP,
                        0,
                        szReceiveDir,
                        -1,
                        szRoutingDir,
                        (dwRoutingInfoSize - sizeof(DWORD))
                        )
       )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nMultiByteToWideChar failed with err=0x%8X\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

#else
    // UNICODE //

    ::_tcscpy(szRoutingDir, szReceiveDir);
    if (0 != ::_tcscmp(szRoutingDir, szReceiveDir))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d tcscmp returned FALSE szRoutingDir=%s szReceiveDir=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szRoutingDir,
            szReceiveDir
            );
        goto ExitFunc;
    }

#endif

    if(!FaxSetRoutingInfo(
            hPort,
            REGVAL_RM_FOLDER_GUID,
            pRoutingInfo,
            dwRoutingInfoSize
            )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxRouteSetRoutingInfo returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    if(!FaxEnableRoutingMethod(
            hPort,
            REGVAL_RM_FOLDER_GUID,
            TRUE
            )
      )
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxEnableRoutingMethod returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    fRetVal = TRUE;

ExitFunc:
    free(pRoutingInfo);
    if (FALSE == ::FaxClose(hPort))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
    }
    return(fRetVal);
}
#endif // #ifdef _NT5FAXTEST
//
// SendRegularFax:
//  Sends a fax (uses Server or Client according to computer name).
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    BOOL fRetVal = FALSE;

    if (TRUE == g_fNT4OrLater)
    {
        // use Fax Server Func
        fRetVal = Server_SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);
    }
    else
    {
        // use Fax Client Func
        fRetVal = Client_SendRegularFax(szServerName, szFaxNumber2, szDocument, szCoverPage);
    }

    return(fRetVal);
}


//////////////////////////// Fax Server Functions ////////////////////////////


//
// Server_SendRegularFax:
//  Sends a fax from a Fax Server.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Server_SendRegularFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;
    FAX_SENDER_STATUS myFaxSenderStatus;

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Send a fax with the following parameters:\r\n\tServer=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s"),
        szServerName,
        szFaxNumber2,
        szDocument,
        szCoverPage
        );

    CFaxSender myFaxSender(szServerName);  //if constructor fail an assertion is raised
    fRetVal = myFaxSender.send( szDocument, szCoverPage, szFaxNumber2);
    myFaxSenderStatus = myFaxSender.GetLastStatus();
    if (FALSE == fRetVal)
    {
        // send failed
        ::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send returned FALSE"));
    }
    else
    {
        // send succeeded
        // update successfully sent faxes counter

        g_dwFaxesCount++;

        ::lgLogDetail(
            LOG_X,
            3,
            TEXT("myFaxSender.send returned TRUE, sucessfully sent faxes counter updated to %ld"),
            g_dwFaxesCount
            );
    }

    CotstrstreamEx os;
    os<<myFaxSenderStatus;
    LPCTSTR myStr = os.cstr();
    ::lgLogDetail(LOG_X,3,myStr);
    delete[]((LPTSTR)myStr);

    return(fRetVal);
}


//////////////////////////// Fax Client Functions ////////////////////////////


//
// Client_SendRegularFax:
//  Sends a fax from a Fax Client.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Client_SendRegularFax(
    IN LPCTSTR      szServerName,
    IN LPCTSTR      szFaxNumber,
    IN LPCTSTR      szDocument,
    IN LPCTSTR      szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber);

    BOOL                fRetVal = FALSE;
    HANDLE              hFaxSvc = NULL;
    FAX_JOB_PARAM       FaxJobParams;
    FAX_COVERPAGE_INFO  CPInfo;
    PFAX_COVERPAGE_INFO pCPInfo = NULL;
    DWORD               dwJobId = 0;
    DWORD               dwErr = 0;

    ::lgLogDetail(
        LOG_X,
        1,
        TEXT("Send a fax with the following parameters:\r\n\tServer=%s\r\n\tFaxNumber=%s\r\n\tDocument=%s\r\n\tCoverPage=%s"),
        szServerName,
        szFaxNumber,
        szDocument,
        szCoverPage
        );

    if (FALSE == ::FaxConnectFaxServer(szServerName, &hFaxSvc))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\n FaxConnectFaxServer failed with err=%d"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // queue the send job
    //
    
    // Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;  //send fax immediately

    // Initialize the FAX_COVERPAGE_INFO struct
    ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
    if (NULL != szCoverPage)
    {
        // Set the FAX_COVERPAGE_INFO struct
        CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
        CPInfo.CoverPageName = szCoverPage;
        CPInfo.Note = TEXT("NOTE1\r\nNOTE2\r\nNOTE3\r\nNOTE4");
        CPInfo.Subject = TEXT("SUBJECT");   
        pCPInfo = &CPInfo;
    }

    if (FALSE == ::FaxSendDocument(hFaxSvc, szDocument, &FaxJobParams, pCPInfo, &dwJobId))
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxSendDocument returned FALSE with GetLastError=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }

    //
    // Poll the queued job status
    //  this is because we can't use the io comp port from the client machine
    //

    if (FALSE == ::PollJobAndVerify(hFaxSvc, dwJobId))
    {
        goto ExitFunc;
    }

    fRetVal = TRUE;

    // update successfully sent faxes counter
    g_dwFaxesCount++;

    ::lgLogDetail(
        LOG_X,
        3,
        TEXT("sucessfully sent faxes counter updated to %ld"),
        g_dwFaxesCount
        );

ExitFunc:
    return(fRetVal);
}


#ifdef _NT5FAXTEST
//
// This version uses legacy API
//
BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORD /* IN */ dwJobId)
{
    // get job repeatedly and verify its states make sense
    // should be QUEUED-DIALING-SENDING*X-COMPLETED

    _ASSERTE(NULL != hFaxSvc);

    BOOL                fRetVal = FALSE;
    PFAX_JOB_ENTRY      pJobEntry = NULL;
    DWORD               dwStatus = 0;
    DWORD               dwLastStatus = 0; //there is no such status code
    DWORD               dwCurrentStatus = 0; //there is no such status code
    UINT                uLoopCount = 0;
    DWORD               dwErr = 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJob(hFaxSvc, dwJobId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (((FPS_COMPLETED == dwLastStatus) || (FPS_AVAILABLE == dwLastStatus)) &&
                (ERROR_INVALID_PARAMETER == dwErr))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxGetJob returned FALSE with GetLastError=%d dwLastStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwErr,
                dwLastStatus
                );
            goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);

        dwStatus = pJobEntry->Status;

        //TO DO: better documentation
        switch (dwStatus)
        {
        case FPS_INITIALIZING:
            if (0 == dwLastStatus)
            {
                //first time that we get FPS_INITIALIZING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_INITIALIZING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_INITIALIZING != dwLastStatus) &&
                (0 != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_INITIALIZING;
            break;

        case FPS_DIALING:
            if ((FPS_INITIALIZING == dwLastStatus) ||
                (0 == dwLastStatus))
            {
                //first time that we get FPS_DIALING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_DIALING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_INITIALIZING != dwLastStatus) &&
                (0!= dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_DIALING;
            break;

        case FPS_SENDING:
            if (FPS_DIALING == dwLastStatus)
            {
                //first time that we get FPS_SENDING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_SENDING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_DIALING != dwLastStatus) &&
                (FPS_SENDING != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_SENDING;
            break;

        case FPS_COMPLETED:
            if (FPS_SENDING == dwLastStatus)
            {
                //first time that we get FPS_COMPLETED
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_COMPLETED\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_SENDING != dwLastStatus) &&
                (FPS_COMPLETED != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_COMPLETED;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case FPS_AVAILABLE:
            if (FPS_COMPLETED == dwLastStatus)
            {
                //first time that we get FPS_AVAILABLE
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=FPS_AVAILABLE\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId
                    );
            }
            if ((FPS_COMPLETED != dwLastStatus) &&
                (FPS_AVAILABLE != dwLastStatus))
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
            }
            dwLastStatus = FPS_AVAILABLE;
            fRetVal = TRUE;
            goto ExitFunc;
            break;

        case 0:
            //WORKAROUND
            // since pJobEntry->Status is initialized to 0 and is set only
            // a bit after the job state is set to JS_INPROGRESS

            //remove JS_NOLINE modifier
            dwCurrentStatus = (pJobEntry->QueueStatus) & ~JS_NOLINE;
            switch (dwCurrentStatus)
            {
            case JS_INPROGRESS:
            case JS_PENDING:
                //ok
                /*
                ::lgLogDetail(
                    LOG_X,
                    9,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state %d (dwStatus=%d)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                 */
                break; // from inner switch

            case JS_COMPLETED:
                if (FPS_AVAILABLE == dwLastStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n JobId %d is in state 0x%08X (dwStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwJobId,
                    pJobEntry->QueueStatus,
                    dwStatus
                    );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\n JobId %d has dwStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwJobId,
                dwStatus
                );
            goto ExitFunc;
            break; // from outer switch
        }

        if (pJobEntry)
        {
            FaxFreeBuffer(pJobEntry);
            pJobEntry = NULL;
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nMAX_LOOP_COUNT > uLoopCount\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:

    if (pJobEntry)
    {
        FaxFreeBuffer(pJobEntry);
    }

    return(fRetVal);
}

#else // ! _NT5FAXTEST
//
// This version uses extended private API
//

BOOL PollJobAndVerify(HANDLE /* IN */ hFaxSvc, DWORDLONG /* IN */ dwlMsgId)
{
    // get job repeatedly and verify its states make sense
    // should be PENDING - INPROGRESS (DIALING) - INPROGRESS (TRANSMITTING) * X - COMPLETED

    _ASSERTE(NULL != hFaxSvc);

    BOOL                fRetVal                 = FALSE;
    PFAX_JOB_ENTRY_EX   pJobEntry               = NULL;
    DWORD               dwLastExtendedStatus    = 0; //there is no such status code
    UINT                uLoopCount              = 0;
    DWORD               dwErr                   = 0;

    while(TRUE)
    {
        if (FALSE == ::FaxGetJobEx(hFaxSvc, dwlMsgId, &pJobEntry))
        {
            dwErr = ::GetLastError();
            //TO DO: document better
            if (FAX_ERR_MESSAGE_NOT_FOUND == dwErr &&
                (JS_EX_TRANSMITTING == dwLastExtendedStatus ||
                 JS_EX_CALL_COMPLETED == dwLastExtendedStatus))
            {
                //this is ok, job was probably completed and was removed from queue
                fRetVal = TRUE;
                goto ExitFunc;
            }
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxGetJobEx returned FALSE with GetLastError=%d dwLastStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwErr,
                dwLastExtendedStatus
                );
            goto ExitFunc;
        }

        _ASSERTE(NULL != pJobEntry);


        //TO DO: better documentation
        switch (pJobEntry->pStatus->dwExtendedStatus)
        {
        case JS_EX_INITIALIZING:
            if (0 == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_INITIALIZING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_INITIALIZING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if(JS_EX_INITIALIZING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_INITIALIZING;
            break;

        case JS_EX_DIALING:
            if ((JS_EX_INITIALIZING == dwLastExtendedStatus) ||
                (0 == dwLastExtendedStatus))
            {
                //first time that we get JS_EX_DIALING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_DIALING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_DIALING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_DIALING;
            break;

        case JS_EX_TRANSMITTING:
            if (JS_EX_DIALING == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_TRANSMITTING
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_TRANSMITTING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_TRANSMITTING != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_TRANSMITTING;
            break;

        case JS_EX_CALL_COMPLETED            :
            if (JS_EX_TRANSMITTING == dwLastExtendedStatus)
            {
                //first time that we get JS_EX_CALL_COMPLETED
                ::lgLogDetail(
                    LOG_X,
                    3,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=JS_EX_TRANSMITTING\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId
                    );
            }
            else if (JS_EX_CALL_COMPLETED != dwLastExtendedStatus)
            {
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
            }
            dwLastExtendedStatus = JS_EX_CALL_COMPLETED;
            break;

        case 0:
            // 1) JS_PENDING and JS_COMPLETED don't have extended status
            // 2) we can fail into time interval between pJobStatus->dwQueueStatus and
            //    pJobStatus->dwExtendedStatus updates

            //remove JS_NOLINE modifier
            switch (pJobEntry->pStatus->dwQueueStatus & ~JS_NOLINE)
            {
            case JS_PENDING:
            case JS_INPROGRESS:
                // ok
                break; // from inner switch

            case JS_COMPLETED:
                //
                // TODO: Should check the device is idle
                //

                if (JS_EX_TRANSMITTING == dwLastExtendedStatus)
                {
                    //ok - job completed successfully
                    fRetVal = TRUE;
                    goto ExitFunc;
                }
                break; // from inner switch

            default:
                ::lgLogError(
                    LOG_SEV_1,
                    TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x is in state 0x%08X (dwExtendedStatus=0x%08X)\r\n"),
                    TEXT(__FILE__),
                    __LINE__,
                    dwlMsgId,
                    pJobEntry->pStatus->dwQueueStatus,
                    pJobEntry->pStatus->dwExtendedStatus
                    );
                goto ExitFunc;
                break; // from inner switch
            }
            break; // from outer switch

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\n MsgId 0x%I64x has dwExtendedStatus=%d\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwlMsgId,
                pJobEntry->pStatus->dwExtendedStatus
                );
            goto ExitFunc;
            break; // from outer switch
        }

        if (pJobEntry)
        {
            FaxFreeBuffer(pJobEntry);
            pJobEntry = NULL;
        }

        //TO DO:
        //Sleep must be short so that we will not miss the required device status to succeed
        Sleep(1);
        // make sure we will break from while
        uLoopCount++;
        if (MAX_LOOP_COUNT < uLoopCount)
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nMAX_LOOP_COUNT > uLoopCount\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }

    } // of while()

    fRetVal = TRUE;

ExitFunc:

    if (pJobEntry)
    {
        FaxFreeBuffer(pJobEntry);
    }

    return(fRetVal);
}

#endif // #ifdef _NT5FAXTEST


static BOOL Client_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    //for now NO SUPPORT
    _ASSERTE(FALSE);
    //TO DO: setlasterror
    return(FALSE);
}



#ifdef _NT5FAXTEST
//
// This version uses legacy API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO      pPortsConfig,
    const DWORD         dwNumOfPorts
)
{
    _ASSERTE(pPortsConfig);
    _ASSERTE(dwNumOfPorts);

    DWORD   dwLoopIndex = 0;
    for(dwLoopIndex = 0; dwLoopIndex < dwNumOfPorts; dwLoopIndex++)
    {
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d Port Number %d\r\nSizeOfStruct=%d\r\nDeviceID=%d\r\nState=%d\r\nFlags=%d\r\nRings=%d\r\nPriority=%d\r\nDeviceName=%s\r\nTsid=%s\r\nCsid=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwLoopIndex,
            pPortsConfig[dwLoopIndex].SizeOfStruct,
            pPortsConfig[dwLoopIndex].DeviceID,
            pPortsConfig[dwLoopIndex].State,
            pPortsConfig[dwLoopIndex].Flags,
            pPortsConfig[dwLoopIndex].Rings,
            pPortsConfig[dwLoopIndex].Priority,
            pPortsConfig[dwLoopIndex].DeviceName,
            pPortsConfig[dwLoopIndex].Tsid,
            pPortsConfig[dwLoopIndex].Csid
            );
    }
}

#else // !_NT5FAXTEST
//
// This version uses extended private API
//

static VOID LogPortsConfiguration(
    PFAX_PORT_INFO_EX   pPortsConfig,
    const DWORD         dwNumOfPorts
)
{
    _ASSERTE(pPortsConfig);
    _ASSERTE(dwNumOfPorts);

    DWORD   dwLoopIndex = 0;
    for(dwLoopIndex = 0; dwLoopIndex < dwNumOfPorts; dwLoopIndex++)
    {
        ::lgLogDetail(
            LOG_X,
            7,
            TEXT("FILE:%s LINE:%d Port Number %d\r\ndwSizeOfStruct=%d\r\ndwDeviceID=%d\r\nlpctstrDeviceName=%s\r\nlptstrDescription=%s\r\nlpctstrProviderName=%s\r\nlpctstrProviderGUID=%s\r\nbSend=%d\r\nbReceive=%d\r\ndwRings=%d\r\nlptstrCsid=%s\r\n\r\nlptstrTsid=%s\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwLoopIndex,
            pPortsConfig[dwLoopIndex].dwSizeOfStruct,
            pPortsConfig[dwLoopIndex].dwDeviceID,
            pPortsConfig[dwLoopIndex].lpctstrDeviceName,
            pPortsConfig[dwLoopIndex].lptstrDescription,
            pPortsConfig[dwLoopIndex].lpctstrProviderName,
            pPortsConfig[dwLoopIndex].lpctstrProviderGUID,
            pPortsConfig[dwLoopIndex].bSend,
            pPortsConfig[dwLoopIndex].ReceiveMode,
            pPortsConfig[dwLoopIndex].dwRings,
            pPortsConfig[dwLoopIndex].lptstrCsid,
            pPortsConfig[dwLoopIndex].lptstrTsid
            );
    }
}
#endif // #ifdef _NT5FAXTEST

//
// Server_SendBroadcastFax:
//  Sends a fax broadcast from a Fax Server.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to use.
//
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL Server_SendBroadcastFax(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szFaxNumber2);

    BOOL fRetVal = FALSE;
    FAX_SENDER_STATUS myFaxSenderStatus;
    CotstrstreamEx os;
    LPCTSTR myStr = NULL;

    // create the fax sending object
    CFaxSender myFaxSender(szServerName);  //if constructor fail an assertion is raised

    // create a broadcast object with 3 recipients
    CFaxBroadcast myFaxBroadcastObj;

    // set cover page
    if (FALSE == myFaxBroadcastObj.SetCPFileName(szCoverPage))
    {
        ::lgLogError(LOG_SEV_1,TEXT("myFaxBroadcastObj.SetCPFileName() failed"));
        goto ExitFunc;
    }

    // add 1st recipient to broadcast
    g_RecipientProfile[0].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[0]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("1st myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    // add 2nd recipient to broadcast
    g_RecipientProfile[1].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[1]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("2nd myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    // add 3rd recipient to broadcast
    g_RecipientProfile[2].lptstrFaxNumber = (LPTSTR)szFaxNumber2;
    if (FALSE == myFaxBroadcastObj.AddRecipient(&g_RecipientProfile[2]))
    {
        ::lgLogError(LOG_SEV_1,TEXT("3rd myFaxBroadcastObj.AddRecipient() failed"));
        goto ExitFunc;
    }

    fRetVal = myFaxSender.send_broadcast( szDocument, &myFaxBroadcastObj);
    myFaxSenderStatus = myFaxSender.GetLastStatus();
    if (FALSE == fRetVal)
    {
        // test case failed
        ::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send_broadcast returned FALSE"));
    }
    else
    {
        // test case succeeded
        // update successfully sent faxes counter

        g_dwFaxesCount += g_RecipientsCount;

        ::lgLogDetail(
            LOG_X,
            3,
            TEXT("myFaxSender.send_broadcast returned TRUE, sucessfully sent faxes counter updated to %ld"),
            g_dwFaxesCount
            );
    }

    os<<myFaxSenderStatus;
    myStr = os.cstr();
    ::lgLogDetail(LOG_X,3,myStr);
    delete[]((LPTSTR)myStr);
    
ExitFunc:
    return(fRetVal);
}


//
// SendFaxFromApp:
//  Sends a fax from application.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//  szPrinterName       IN parameter.
//                      Name of Fax server to use.
//
//  szRegHackKeyName    IN parameter.
//                      Name of registry hack key.
//
//  szFaxNumber2        IN parameter
//                      Phone number to send fax to.
//
//  szDocument          IN parameter
//                      Filename of document to send.
//
//  szCoverPage         IN parameter
//                      Filename of cover page to send (may be NULL).
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL SendFaxFromApp(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
)
{
    SHELLEXECUTEINFO ShellExecInfo;

    HKEY               hkWzrdHack                 = NULL;
    DWORD              dwTestsCount               = 1;
    TCHAR              tszRecipientName[]         = TEXT("Recipient");
    LPTSTR             lptstrRecipientMultiString = NULL;
    HANDLE             hFaxServer                 = NULL;
    DWORD              dwJobsReturned             = 0;
    MY_MSG_ID          MsgId                      = 0;
    DWORD              dwMultiStringBytes         = 0;
    DWORD              dwEC                       = ERROR_SUCCESS;
    BOOL               fRetVal                    = FALSE;
    PMY_FAX_JOB_ENTRY  pJobs                      = NULL;
    int                i                          = 0;  //used as an index in a for loop

    _ASSERTE(NULL != szServerName);
    _ASSERTE(NULL != szPrinterName);
    _ASSERTE(NULL != szWzrdRegHackKey);
    _ASSERTE(NULL != szFaxNumber);
    _ASSERTE(NULL != szDocument);

    if (!szCoverPage)
    {
        // no cover page should be used
        szCoverPage = TEXT("");
    }

    // Allocate memory for multistring: recipient name + '\0', fax number + '\0', '\0'
    dwMultiStringBytes = (_tcslen(tszRecipientName) + _tcslen(szFaxNumber) + 3) * sizeof(TCHAR);
    lptstrRecipientMultiString = (LPTSTR)malloc(dwMultiStringBytes);
    if (NULL == lptstrRecipientMultiString)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nmalloc() failed\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        dwEC = ERROR_NOT_ENOUGH_MEMORY;
        goto ExitFunc;
    }

    // Combine recipient name and number into multistring
    _stprintf(lptstrRecipientMultiString, TEXT("%s%c%s%c"), tszRecipientName, (TCHAR)'\0', szFaxNumber, (TCHAR)'\0');

    // Create (or open if already exists) the SendWizard registry hack key
    dwEC = RegCreateKey(HKEY_LOCAL_MACHINE, szWzrdRegHackKey, &hkWzrdHack);
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegCreateKey() failed to open %s key (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            szWzrdRegHackKey,
            dwEC
            );
        goto ExitFunc;
    }

    // Set desired cover page
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKECOVERPAGE,
        0,
        REG_SZ,
        (CONST BYTE *)szCoverPage,
        (_tcslen(szCoverPage) + 1) * sizeof(TCHAR)
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKECOVERPAGE,
            dwEC
            );
        goto ExitFunc;
    }

    // Set tests count to 1
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKETESTSCOUNT,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwTestsCount,
        sizeof(dwTestsCount)
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKETESTSCOUNT,
            dwEC
            );
        goto ExitFunc;
    }

    // Set desired recipient
    dwEC = RegSetValueEx(
        hkWzrdHack,
        REGVAL_FAKERECIPIENT,
        0,
        REG_MULTI_SZ,
        (CONST BYTE *)lptstrRecipientMultiString,
        dwMultiStringBytes
        );
    if (ERROR_SUCCESS != dwEC)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nRegSetValueEx() failed to set %s value (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_FAKERECIPIENT,
            dwEC
            );
        goto ExitFunc;
    }

    if (!FaxConnectFaxServer(szServerName, &hFaxServer))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxConnectFaxServer() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    

    //
    //Before we print this job, let's verify that the queue is empty like we expect it
    //
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    if (0 != dwJobsReturned)
    {
        //
        //We still have jobs in the queue, this is not what we expect,exit with failure
        //
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nThere're still %d jobs in the fax queue\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwJobsReturned
            );
        goto ExitFunc;
    }

    // Initialize ShellExecInfo structure
    ZeroMemory(&ShellExecInfo, sizeof(ShellExecInfo));
    ShellExecInfo.cbSize           = sizeof(ShellExecInfo);
    ShellExecInfo.fMask            = SEE_MASK_FLAG_NO_UI;
    ShellExecInfo.lpVerb           = TEXT("printto");
    ShellExecInfo.lpFile           = szDocument;
    ShellExecInfo.lpParameters     = szPrinterName;
    ShellExecInfo.nShow            = SW_SHOWNORMAL;

    // Print document, using "printto" verb
    if (FALSE == ShellExecuteEx(&ShellExecInfo))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nShellExecuteEx() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }

    for (i=0;i<10;i++)
    {
        if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
        {
            dwEC = GetLastError();
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs() failed (ec = %ld)\r\n"),
                TEXT(__FILE__),
                __LINE__,
                dwEC
                );
            goto ExitFunc;
        }
        if (0 != dwJobsReturned)
        {
            //
            //Great, the job is queued, exit this loop and proceed with the test
            //
            break;
        }

        //
        //Got not yet queued, sleep for a second and try again
        //
        Sleep(1000);
    }


    // only currently sent job is expected to be in the queue (sent and received)
    switch(dwJobsReturned)
    {
    case 1:
        MsgId = MyGetMsgId(pJobs[0]);
        break;
    case 2:
        if (MyGetJobType(pJobs[0]) == JT_SEND && MyGetJobType(pJobs[1]) == JT_RECEIVE)
        {
            MsgId = MyGetMsgId(pJobs[0]);
            break;
        }
        else if (MyGetJobType(pJobs[0]) == JT_RECEIVE && MyGetJobType(pJobs[1]) == JT_SEND)
        {
            MsgId = MyGetMsgId(pJobs[1]);
            break;
        }
        else
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d\r\nThere're 2 jobs in the queue, but we expect a sending job and a receiving job\r\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFunc;
        }
    default:
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nNo outgoing job in the queue\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

    if (!::PollJobAndVerify(hFaxServer, MsgId))
    {
        goto ExitFunc;
    }

    // update successfully sent faxes counter
    g_dwFaxesCount++;

    ::lgLogDetail(
        LOG_X,
        3,
        TEXT("sucessfully sent faxes counter updated to %ld"),
        g_dwFaxesCount
        );

    fRetVal = TRUE;

ExitFunc:


    if (lptstrRecipientMultiString)
    {
        free(lptstrRecipientMultiString);
    }
    if (hkWzrdHack)
    {
        RegCloseKey(hkWzrdHack);
    }
    if (hFaxServer)
    {
        FaxClose(hFaxServer);
    }
    if (pJobs)
    {
        FaxFreeBuffer(pJobs);
    }

    if (ERROR_SUCCESS != dwEC)
    {
        SetLastError(dwEC);
    }

    return fRetVal;
}


//
// TurnOffCfgWzrd:
//  Turns off implicit invocation of Configuration Wizard.
//
// NOTE: This function is private to this module, it is not exported.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
static BOOL TurnOffCfgWzrd()
{
    DWORD           dwVersion       = 0;
    DWORD           dwMajorWinVer   = 0;
    DWORD           dwMinorWinVer   = 0;
    HKEY            hkService       = NULL;
    HKEY            hkUserInfo      = NULL;
    const DWORD     dwValue         = 1;
    DWORD           dwEC            = ERROR_SUCCESS;

    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));

    if (!(dwMajorWinVer == 5 && dwMinorWinVer >= 1))
    {
        // OS is not Windows XP - Configuration Wizard doesn't exist

        goto ExitFunc;
    }

    // set the flag responsible for service part
    dwEC = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAXSERVER,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkService,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegOpenKeyEx failed to open %s key (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAXSERVER,
            dwEC
            );
        goto ExitFunc;
    }
    dwEC = RegSetValueEx(
        hkService,
        REGVAL_CFGWZRD_DEVICE,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegSetValueEx failed to set %s value (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_DEVICE,
            dwEC
            );
        goto ExitFunc;
    }

    // set the flag responsible for user part
    dwEC = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        REGKEY_FAX_SETUP,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hkUserInfo,
        NULL
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n RegOpenKeyEx failed to open %s key (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGKEY_FAX_SETUP,
            dwEC
            );
        goto ExitFunc;
    }
    dwEC = RegSetValueEx(
        hkUserInfo,
        REGVAL_CFGWZRD_USER_INFO,
        0,
        REG_DWORD,
        (CONST BYTE *)&dwValue,
        sizeof(dwValue)
        );
    if (dwEC != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\nRegSetValueEx failed to set %s value (ec = %ld)\n"),
            TEXT(__FILE__),
            __LINE__,
            REGVAL_CFGWZRD_USER_INFO,
            dwEC
            );
        goto ExitFunc;
    }

ExitFunc:

    if (hkService)
    {
        RegCloseKey(hkService);
    }
    if (hkUserInfo)
    {
        RegCloseKey(hkUserInfo);
    }

    if (ERROR_SUCCESS != dwEC)
    {
        SetLastError(dwEC);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}



//
// EmptyFaxQueue:
//  Removes all jobs from the fax queue.
//
static BOOL EmptyFaxQueue(HANDLE hFaxServer)
{
    PMY_FAX_JOB_ENTRY   pJobs           = NULL;
    DWORD               dwJobsReturned  = 0;
    DWORD               dwInd           = 0;
    DWORD               dwEC            = 0;

    if (!hFaxServer)
    {
        _ASSERTE(FALSE);
        dwEC = ERROR_INVALID_PARAMETER;
        goto ExitFunc;
    }

    // Get enumeration of all jobs in the server queue
    //
    // According to current definition of MyFaxEnumJobs macro in !_NT5FAXTEST mode,
    // this call will not return jobs of JT_ROUTING type. It means, these jobs will not be deleted.
    // This will not make a trouble, because these jobs will not be returnes by subsequent calls as well.
    //
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }

    _ASSERTE(pJobs);

    // Delete all the jobs
    for (dwInd = 0; dwInd < dwJobsReturned; dwInd++)
    {
        if (!FaxAbort(hFaxServer, MyGetJobId(pJobs[dwInd])))
        {
            lgLogError(
                LOG_SEV_2, 
                TEXT("FILE:%s LINE:%ld FaxAbort failed for JobId = 0x%lx (ec = 0x%08lX)"),
                TEXT(__FILE__),
                __LINE__,
                MyGetJobId(pJobs[dwInd]),
                GetLastError()
                );
        }
    }

    // FaxAbort is asynchronous.
    // Sleep 30 sec to give all jobs to be actually deleted from the queue.
    Sleep(1000 * 30);

    FaxFreeBuffer(pJobs);
    pJobs = NULL;

    // Make sure the queue is empty
    if (!MyFaxEnumJobs(hFaxServer, &pJobs, &dwJobsReturned))
    {
        dwEC = GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFaxEnumJobs*() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwEC
            );
        goto ExitFunc;
    }
    if (dwJobsReturned > 0)
    {
        dwEC = ERROR_CAN_NOT_COMPLETE;
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\r\nFailed to delete jobs from the queue\r\n"),
            TEXT(__FILE__),
            __LINE__
            );
        goto ExitFunc;
    }

ExitFunc:

    if (pJobs)
    {
        FaxFreeBuffer(pJobs);
    }

    if (dwEC != ERROR_SUCCESS)
    {
        SetLastError(dwEC);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummydirtiffcmp.cpp ===
#include "..\VerifyTiffFiles\DirTiffCmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummybvt.cpp ===
#include "Bvt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummycometfax.cpp ===
#include "..\FaxSender\CometFax.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfaxbroadcast.cpp ===
#include "..\FaxSender\FaxBroadCast.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfaxcompport.cpp ===
#include "..\FaxSender\FaxCompPort.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\bvt.h ===
//
//
// Filename:    bvt.h
// Author:      Sigalit Bar (sigalitb)
// Date:        30-Dec-98
//
//

#ifndef _BVT_H_
#define _BVT_H_

#include <windows.h>

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST

#include <TCHAR.H>
#include <crtdbg.h>


#include <faxreg.h> // for setting MS Routing Extension information

#include <log.h>
#include "..\FaxSender\FaxSender.h"
#include "..\VerifyTiffFiles\dirtiffcmp.h"

//
// input/output files declarations
//
#define PARAMS_INI_FILE     TEXT("Params.ini")
#define PARAMS_SECTION      TEXT("General")
#define RECIPIENTS_SECTION  TEXT("Recipients")
#define TEST_SECTION        TEXT("Test")

#ifdef __cplusplus
extern "C" {
#endif

//
// Bvt files
//
extern LPTSTR  g_szBvtDir;
extern LPTSTR  g_szBvtDocFile;
extern LPTSTR  g_szBvtHtmFile;
extern LPTSTR  g_szBvtBmpFile;
extern LPTSTR  g_szBvtTxtFile;


// due to Ronen's FaxSendDocumentEx changes, full path needed (regression)
#define BVT_BACKSLASH   TEXT("\\")
#define BVT_DOC_FILE    TEXT("file.doc")
#define BVT_BMP_FILE    TEXT("file.bmp")
#define BVT_HTM_FILE    TEXT("file.htm")
#define BVT_TXT_FILE    TEXT("file.txt")

#define BVT_MIN_PORTS   2

#define DEV_TSID    TEXT("Comet dev")
#define DEV_CSID    TEXT("Comet dev")

#define MY_FPF_NONE         0

#define MAX_LOOP_COUNT      (60*60*1000)

// SendWizard registry hack
#define REGKEY_WZRDHACK         TEXT("Software\\Microsoft\\Fax\\UserInfo\\WzrdHack")
#define REGVAL_FAKECOVERPAGE    TEXT("FakeCoverPage")
#define REGVAL_FAKETESTSCOUNT   TEXT("FakeTestsCount")
#define REGVAL_FAKERECIPIENT    TEXT("FakeRecipient0")

typedef enum 
{
    LANGUAGE_ENG = 1,
    LANGUAGE_JPN,
    LANGUAGE_GER
}BVT_LANGUAGE;

extern FAX_PERSONAL_PROFILE g_RecipientProfile1;
extern FAX_PERSONAL_PROFILE g_RecipientProfile2;
extern FAX_PERSONAL_PROFILE g_RecipientProfile3;


// Indicates whether to invoke Server or Client tests.
// This variable is set at TestSuiteSetup() according to szServerName and the machine name.
// That is, if szServerName==<machine name> g_fFaxServer will be set to TRUE
extern BOOL    g_fFaxServer;

// Indicates whether the test is running on an OS that is NT4 or later
// If the OS is NT4 or later then Server_ functions will be invoked
// else Client_ functions will be invoked
extern BOOL    g_fNT4OrLater;


//
// TestSuiteSetup:
//  Initializes logger and changes the Fax server configuration
//  for the tests.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber1    IN parameter
//                  Phone number of first device installed on server.
//                  Will be set up as sending device.
//
//  szFaxNumber2    IN parameter
//                  Phone number of second device installed on server.
//                  Will be set up as receiving device.
//
//  szDocument      IN parameter
//                  Filename of document to be used in tests.
//                  The function only prints this string to logger (for debugging).
//
//  szCoverPage     IN parameter
//                  Filename of cover page to be used in tests.
//                  The function only prints this string to logger (for debugging).
//
//  szReceiveDir    IN parameter
//                  Name of "received faxes" directory to be used in tests.
//
//  szSentDir       IN parameter.
//                  Name of "sent faxes" directory to be used in tests.
//
//  szInboxArchiveDir   IN parameter.
//                      Name of directory to store (archive) incoming faxes in.
//
//  szBvtDir        IN parameter.
//                  Name of directory containing bvt files.
//
//  szCompareTiffFiles      IN parameter.
//                          Specifies whether or not to compare the tiffs at the end of the test.
//
//  szUseSecondDeviceToSend     IN parameter.
//                              Specifies whether the second device should be used to send faxes.
//                              Otherwize, the first device is used.
//                              The order of devices is according to an enumeration, the Fax service returns.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestSuiteSetup(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber1,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage,
    LPCTSTR     /* IN */    szReceiveDir,
    LPCTSTR     /* IN */    szSentDir,
    LPCTSTR     /* IN */    szInboxArchiveDir,
    LPCTSTR     /* IN */    szBvtDir,
    LPCTSTR     /* IN */    szCompareTiffFiles,
    LPCTSTR     /* IN */    szUseSecondDeviceToSend
);

//
// TestCase1:
//  Send a fax + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase1(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase2:
//  Send just a CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase2(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase3:
//  Send a fax with no CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase3(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument
);

//
// TestCase4:
//  Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase4(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase5:
//  Send a broadcast of only CPs (3 times the same recipient).
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase5(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase6:
//  Send a broadcast without CPs (3 times the same recipient).
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send faxes to.
//
//  szDocument      IN parameter
//                  Filename of document to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase6(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szDocument
);

//
// TestCase7:
//  Send a fax (*.doc file = BVT_DOC_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase7(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase8:
//  Send a fax (*.bmp file = BVT_BMP_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase8(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase9:
//  Send a fax (*.htm file = BVT_HTM_FILE) + CP.
//
// Parameters:
//  szServerName    IN parameter.
//                  Name of Fax server to setup.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase9(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase10:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
// Parameters:
//  szPrinterName   IN parameter.
//                  Name of fax local printer or printer connection.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
//  szCoverPage     IN parameter
//                  Filename of cover page to send.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase10(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber2,
    LPCTSTR     /* IN */    szCoverPage
);

//
// TestCase11:
//  Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP.
//
// Parameters:
//  szPrinterName   IN parameter.
//                  Name of fax local printer or printer connection.
//  
//  szFaxNumber2    IN parameter
//                  Phone number to send fax to.
//
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase11(
    LPCTSTR     /* IN */    szServerName,
    LPCTSTR     /* IN */    szPrinterName,
    LPCTSTR     /* IN */    szWzrdRegHackKey,
    LPCTSTR     /* IN */    szFaxNumber2
);

//
// TestCase12:
//  Compare all sent faxes (*.tif files) in directory szSentDir 
//  with the received (*.tif) files in szReceive
//
// Parameters:
//  szSentDir           IN parameter.
//                      Name of directory at which all (BVT) sent faxes are stored.
//  szReceive           IN parameter.
//                      Name of directory at which all (BVT) received faxes are stored.
//  
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase12(
    LPTSTR     /* IN */    szSentDir,
    LPTSTR     /* IN */    szReceiveDir
    );

//
// TestCase13:
//  Compare all routed faxes (*.tif files) in directory szInboxArchiveDir 
//  with the received (*.tif) files in szReceive
//
// Parameters:
//  szInboxArchiveDir   IN parameter.
//                      Name of directory at which all (BVT) routed faxes are stored.
//  szReceive           IN parameter.
//                      Name of directory at which all (BVT) received faxes are stored.
//  
// Return Value:
//  TRUE if successful, otherwise FALSE.
//
BOOL TestCase13(
    LPTSTR     /* IN */    szInboxArchiveDir,
    LPTSTR     /* IN */    szReceiveDir
    );


//
// TestSuiteShutdown:
//  Perform test suite cleanup (close logger).
//
// Return Value:
//  TRUE if successful, FALSE otherwise.
//
BOOL TestSuiteShutdown(void);


#ifdef __cplusplus
}
#endif 

#endif //_BVT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfaxevent.cpp ===
#include "..\FaxSender\FaxEvent.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfaxsender.cpp ===
#include "..\FaxSender\FaxSender.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfaxeventex.cpp ===
#include "..\FaxSender\FaxEventEx.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummymain.cpp ===
#include "Main.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummylogelle.cpp ===
#include "..\Include\LogElle.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyfilenamevec.cpp ===
#include "..\VerifyTiffFiles\FilenameVec.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummystreamex.cpp ===
#include "..\FaxSender\StreamEx.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummysendinfo.cpp ===
#include "..\FaxSender\SendInfo.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummywcsutil.cpp ===
#include "..\FaxSender\Wcsutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\dummyvectiffcmp.cpp ===
#include "..\VerifyTiffFiles\VecTiffCmp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\bvt\main.cpp ===
//
//
// Filename:    main.cpp
// Author:      Sigalit Bar
// Date:        30-dec-98
//
//

#pragma warning(disable :4786)

#include "bvt.h"
#include <iniutils.h>
#include "RegHackUtils.h"

#define HELP_SWITCH_1        "/?"
#define HELP_SWITCH_2        "/H"
#define HELP_SWITCH_3        "-?"
#define HELP_SWITCH_4        "-H"

#define MAX_ARGS    12 //including exe name

#define ARGUMENT_IS_SERVER_NAME                 1
#define ARGUMENT_IS_FAX_NUMBER1                 2
#define ARGUMENT_IS_FAX_NUMBER2                 3
#define ARGUMENT_IS_DOC                         4
#define ARGUMENT_IS_CP                          5
#define ARGUMENT_IS_RECEIVE_DIR                 6
#define ARGUMENT_IS_SENT_DIR                    7
#define ARGUMENT_IS_INBOX_ARCHIVE_DIR           8
#define ARGUMENT_IS_BVT_DIR                     9
#define ARGUMENT_IS_TIFF_COMPARE_ENABLED        10
#define ARGUMENT_IS_USE_SECOND_DEVICE_TO_SEND   11

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;

//
// global input parameters file path
//
TCHAR* g_InputIniFile = NULL;


// szCompareTiffFiles:
//  indicates whether to comapre the tiffs at the end of the test
//
extern BOOL g_fCompareTiffFiles;

// szUseSecondDeviceToSend:
//  specifies whether the second device should be used to send faxes
//
extern BOOL g_fUseSecondDeviceToSend;

//
// UsageInfo:
//  Outputs application's proper usage
//
void
UsageInfo(void)
{
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("FaxBVT.exe - BVT for Windows XP builds (CHK and FRE)\n\n")
        TEXT("Usage:\n")
        TEXT("FaxBVT.exe \n\t - Start running the BVT\n")
        TEXT("FaxBVT.exe /? \n\t - Show help info for the BVT")
        );
        
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n\n\t Input ini file should be: \"")
        PARAMS_INI_FILE
        TEXT("\" and should have the following sections:\n")
        TEXT("[General]\n")
        TEXT("\t server_name fax_number1 fax_number2 document cover_page receive_dir sent_dir \n")
        TEXT("\t server_name ---------->the name of the fax server (without the \\\\)\n")
        TEXT("\t fax_number1 ---------->the fax number of the 1st device on server\n")
        TEXT("\t fax_number2 ---------->the fax number of the 2nd device on server\n")
        TEXT("\t document ------------->the full path of the document to send\n")
        TEXT("\t cover_page ----------->the full path to the cover page to send\n")
        TEXT("\t receive_dir ---------->the full path to the receive directory of receiving device\n")
        TEXT("\t sent_dir ------------->the full path to the sent archive directory\n")
        TEXT("\t inbox_dir ------------>the full path to the inbox archive directory\n")
        TEXT("\t bvt_dir -------------->the full path to the bvt directory\n")
        TEXT("\t CompareTiffFiles ----->flag indicating if to compared the tiff files at the end of the test")
        TEXT("\t UseSecondDeviceToSend->flag indicating if the second device (first device otherwise) should be used to send")
        );
    
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n[Recipients]\n")
        TEXT("\t This section should list Name of other sections which to include in a broadcast job")
        );
    
    ::lgLogDetail(
        LOG_X,
        0,
        TEXT("\n[RecipientX]\n")
        TEXT("\t This section should include the following details:\n")
        TEXT("\t Name\n")
        TEXT("\t FaxNumber\n")
        TEXT("\t Company\n")
        TEXT("\t StreetAddress\n")
        TEXT("\t City\n")
        TEXT("\t State\n")
        TEXT("\t Zip\n")
        TEXT("\t Country\n")
        TEXT("\t Title\n")
        TEXT("\t Department\n")
        TEXT("\t OfficeLocation\n")
        TEXT("\t HomePhone\n")
        TEXT("\t OfficePhone\n")
        TEXT("\t Email\n")
        TEXT("\t BillingCode\n")
        TEXT("\t TSID")
        );
}


//
// ParseCmdLineParams:
//  Parses the command line parameters, saves a copy of them,
//  and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//  argc                IN parameter.
//                      command line number of arguments.
//  argvA[]             IN parameter.
//                      command line args (in MBCS).
//  pszServerName       OUT parameter.
//                      Pointer to string to copy 1st argument to.
//                      Represents the name of fax server to use.
//  pszFaxNumber1       OUT parameter.
//                      Pointer to string to copy 2nd argument to.
//                      Represents the fax number of 1st device on the
//                      above fax server.
//  pszFaxNumber2       OUT parameter.
//                      Pointer to string to copy 3rd argument to.
//                      Represents the fax number of 2nd device on the
//                      above fax server.
//  pszDocument         OUT parameter.
//                      Pointer to string to copy 4th argument to.
//                      Represents the name of document to use with tests.
//  pszCoverPage        OUT parameter.
//                      Pointer to string to copy 5th argument to.
//                      Represents the name of the cover page to use
//                      with tests.
//  pszReceiveDir       OUT parameter.
//                      Pointer to string to copy 6th argument to.
//                      Represents the name of directory to route received 
//                      faxes to.
//  pszSentDir          OUT parameter.
//                      Pointer to string to copy 7th argument to.
//                      Represents the name of directory to store (archive)  
//                      sent faxes in.
//  pszInboxArchiveDir  OUT parameter.
//                      Pointer to string to copy 8th argument to.
//                      Represents the name of directory to store (archive)  
//                      incoming faxes in.
//  pszBvtDir           OUT parameter.
//                      Pointer to string to copy 9th argument to.
//                      Represents the name of directory containing bvt  
//                      files.
//  pszCompareTiffFiles     OUT parameter.
//                          Pointer to string to copy 10th argument to.
//                          Represents whether or not to compare the tiffs at the end of the test.
//
//  pszUseSecondDeviceToSend    OUT parameter.
//                              Pointer to string to copy 11th argument to.
//                              Specifies whether the second device should be used to send faxes.
//                              Otherwize, the first device is used.
//                              The order of devices is according to an enumeration, the Fax service returns.
//
// Return Value:
//  TRUE on success and FALSE on failure.
//
//
BOOL 
LoadTestParams(
    LPCTSTR      /* IN */   tstrIniFileName,
    LPTSTR*      /* OUT */  pszServerName,
    LPTSTR*      /* OUT */  pszFaxNumber1,
    LPTSTR*      /* OUT */  pszFaxNumber2,
    LPTSTR*      /* OUT */  pszDocument,
    LPTSTR*      /* OUT */  pszCoverPage,
    LPTSTR*      /* OUT */  pszReceiveDir,
    LPTSTR*      /* OUT */  pszSentDir,
    LPTSTR*      /* OUT */  pszInboxArchiveDir,
    LPTSTR*      /* OUT */  pszBvtDir,
    LPTSTR*      /* OUT */  pszCompareTiffFiles,
    LPTSTR*      /* OUT */  pszUseSecondDeviceToSend
    )
{
    _ASSERTE(pszServerName);
    _ASSERTE(pszDocument);
    _ASSERTE(pszFaxNumber1);
    _ASSERTE(pszFaxNumber2);
    _ASSERTE(pszCoverPage);
    _ASSERTE(pszReceiveDir);
    _ASSERTE(pszSentDir);
    _ASSERTE(pszInboxArchiveDir);
    _ASSERTE(pszBvtDir);
    _ASSERTE(pszCompareTiffFiles);
    _ASSERTE(pszUseSecondDeviceToSend);
    
    // Declarations
    //
    DWORD   dwArgLoopIndex;
    DWORD   dwArgSize;
    LPTSTR  aszParam[MAX_ARGS];

    //
    // Read the list of test parameters from ini file.
    std::vector<tstring> ParamsList;
    try
    {
        ParamsList =  INI_GetSectionList(tstrIniFileName,PARAMS_SECTION);
    }
    catch(Win32Err& err)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\n INI_GetSectionList failed with error = %d\n"),
            TEXT(__FILE__),
            __LINE__,
            err.error()
            );
        return FALSE;
    }

    std::vector<tstring>::iterator iterList;
    //
    // Check number of parameters
    //
    if ( ParamsList.size() != (MAX_ARGS - 1))  
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("\nInvalid invocation of FaxBVT.exe\n\nFaxBVT.exe Help:\n")
            );
        ::UsageInfo();
        return FALSE;
    }

    //
    // Initialize awcsParam[]
    //
    for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
    {
        aszParam[dwArgLoopIndex] = NULL;
    }

    //
    // Loop on arguments in list
    //
    for (iterList = ParamsList.begin(), dwArgLoopIndex = 1; iterList != ParamsList.end(); iterList++, dwArgLoopIndex++) 
    {
        //
        // Determine the memory required for the parameter
        //
        dwArgSize = (_tcsclen((*iterList).c_str()) + 1) * sizeof(TCHAR);

        //
        // Allocate the memory for the parameter
        //
        _ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
            g_hMainHeap, 
            HEAP_ZERO_MEMORY, 
            dwArgSize
            );
        if(NULL == aszParam[dwArgLoopIndex])
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFuncFail;
        }

    
        ::_tcscpy(aszParam[dwArgLoopIndex],(*iterList).c_str());
        if (_tcscmp(aszParam[dwArgLoopIndex],(*iterList).c_str()))
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
                TEXT(__FILE__),
                __LINE__
                );
            goto ExitFuncFail;
        }
    
        //
        // Treat each argument accordingly
        //
        switch (dwArgLoopIndex)
        {
        case ARGUMENT_IS_SERVER_NAME:
            //server_name param
            (*pszServerName) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_FAX_NUMBER1:
            //fax_number1 param
            (*pszFaxNumber1) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_FAX_NUMBER2:
            //fax_number2 param
            (*pszFaxNumber2) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_DOC:
            //document param
            (*pszDocument) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_CP:
            //cover_page param
            (*pszCoverPage) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_RECEIVE_DIR:
            //receive_dir param
            (*pszReceiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_SENT_DIR:
            //sent_dir param
            (*pszSentDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_INBOX_ARCHIVE_DIR:
            //inbox_dir param
            (*pszInboxArchiveDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_BVT_DIR:
            //bvt_dir param
            (*pszBvtDir) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_TIFF_COMPARE_ENABLED:
            //comapre the tiff files at the end of the test
            (*pszCompareTiffFiles) = aszParam[dwArgLoopIndex];
            break;

        case ARGUMENT_IS_USE_SECOND_DEVICE_TO_SEND:
            //comapre the tiff files at the end of the test
            (*pszUseSecondDeviceToSend) = aszParam[dwArgLoopIndex];
            break;

        default:
            _ASSERTE(FALSE);
            return FALSE;
        }// switch (dwIndex)

    }//for (iterList = ParamsList.begin(); iterList != ParamsList.end(); iterList++) 


    //If all is well then we do NOT free 
    //pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
    //since these allocations were the purpose of the function.
    return(TRUE);

ExitFuncFail:

    //
    // Free allocations
    //
    DWORD i;
    //0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
    for (i=0; i<MAX_ARGS; i++) 
    {
        if (NULL == aszParam[i]) continue;
        if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
                TEXT(__FILE__),
                __LINE__,
                i,
                ::GetLastError()
                );
            return(FALSE);
        }
    }

    //
    //reset OUT parameters
    //
    (*pszServerName) = NULL;
    (*pszFaxNumber1) = NULL;
    (*pszFaxNumber2) = NULL;
    (*pszDocument) = NULL;
    (*pszCoverPage) = NULL;
    (*pszReceiveDir) = NULL;
    (*pszSentDir) = NULL;
    (*pszInboxArchiveDir) = NULL;
    (*pszBvtDir) = NULL;

    return(FALSE);
}


//

//
// main body of application.
//
int __cdecl
main(int argc, char* argv[])
{
    int nReturnValue = 0; //to indicate success

    LPTSTR szServerName = NULL;
    LPTSTR szFaxNumber1 = NULL;
    LPTSTR szFaxNumber2 = NULL;
    LPTSTR szDocument = NULL;
    LPTSTR szCoverPage = NULL;
    LPTSTR szReceiveDir = NULL;
    LPTSTR szSentDir = NULL;
    LPTSTR szInboxArchiveDir = NULL;
    LPTSTR szBvtDir = NULL;
    LPTSTR tstrCurrentDirectory = NULL;
    LPTSTR szCompareTiffFiles = NULL;
    LPTSTR szUseSecondDeviceToSend = NULL;
    LPTSTR tstrPrinterConnectionName = NULL;
    LPTSTR tstrWzrdRegHackKey = NULL;
    LPTSTR tstrDialTo = NULL;
    tstring tstrParamsFilePath;

    PSID pCurrentUserSid = NULL;

    DWORD dwFuncRetVal = 0;
    DWORD cbDir = 0;
    BOOL bRes = FALSE;


    //
    // Check for help switch
    //
    // If this is the second argument, it may be one of several help switches defined.
    // A help switch can appear only as the second argument.
    if (2 <= argc)
    {
        if (! (!::_strcmpi (HELP_SWITCH_1, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_2, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_3, argv[1])) || 
              (!::_strcmpi (HELP_SWITCH_4, argv[1]))
            ) 
        {
            //
            //We use printf here since the logger isn't invoked yet
            //
            ::_tprintf(TEXT("Invalid invokation of BVT.exe\n\n"));
        }
        ::_tprintf(TEXT("FaxBVT.exe - BVT for Windows XP builds (CHK and FRE)\n\n"));
        ::_tprintf(TEXT("Usage:\n"));
        ::_tprintf(TEXT("FaxBVT.exe \n\t - Start running the BVT\n"));
        ::_tprintf(TEXT("FaxBVT.exe /? \n\t - Show help info for the BVT\n"));
        exit(1);
    }


    //
    // Init logger
    //
    if (!::lgInitializeLogger())
    {
        //
        // we use printf() here since the logger is not active
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgInitializeLogger failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    //
    // Begin test suite (logger)
    //
    if(!::lgBeginSuite(TEXT("BVT suite")))
    {
        //
        // we use printf() here since the logger is not active
        //
        ::_tprintf(TEXT("FILE:%s LINE:%d\r\nlgBeginSuite failed with GetLastError()=%d\r\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    
    
    //
    // Set g_hMainHeap to process heap
    //
    g_hMainHeap = NULL;
    g_hMainHeap = ::GetProcessHeap();
    if(NULL == g_hMainHeap)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    //
    // Get current directory path
    cbDir = GetCurrentDirectory(
        0,                      // size of directory buffer
        tstrCurrentDirectory    // directory buffer
        ); 
    
    if(!cbDir)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    
    tstrCurrentDirectory = (TCHAR*)::HeapAlloc( g_hMainHeap, 
                                                HEAP_ZERO_MEMORY, 
                                                cbDir * sizeof(TCHAR));
    if(NULL == tstrCurrentDirectory)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
            TEXT(__FILE__),
            __LINE__
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    dwFuncRetVal = GetCurrentDirectory(
        cbDir,                  // size of directory buffer
        tstrCurrentDirectory    // directory buffer
        ); 

    if((dwFuncRetVal + 1 != cbDir))
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\nGetCurrentDirectory failed with GetLastError()=%d\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    // Compose the test params ini file.
    tstrParamsFilePath = tstrCurrentDirectory;
    tstrParamsFilePath += TEXT("\\");
    tstrParamsFilePath += PARAMS_INI_FILE; 
    g_InputIniFile = const_cast<TCHAR*>(tstrParamsFilePath.c_str());
    //
    // Parse the command line
    //
    if(!::LoadTestParams(
            tstrParamsFilePath.c_str(),
            &szServerName,
            &szFaxNumber1,
            &szFaxNumber2,
            &szDocument,
            &szCoverPage,
            &szReceiveDir,
            &szSentDir,
            &szInboxArchiveDir,
            &szBvtDir,
            &szCompareTiffFiles,
            &szUseSecondDeviceToSend
            )
        )
    {
        nReturnValue = 1; // to indicate failure
        goto ExitFunc;
    }

    //
    //Test case0 is setting up the BVT params
    //
    ::lgBeginCase(
        0,
        TEXT("TC#0: Setup BVT params")
        );

    bRes = TestSuiteSetup(
        szServerName,
        szFaxNumber1,
        szFaxNumber2,
        szDocument,
        szCoverPage,
        szReceiveDir,
        szSentDir,
        szInboxArchiveDir,
        szBvtDir,
        szCompareTiffFiles,
        szUseSecondDeviceToSend
        );

    tstrDialTo = g_fUseSecondDeviceToSend ? szFaxNumber1 : szFaxNumber2;
    
    if (!g_fFaxServer)
    {
        // Use printer connection

        // Allocate memory for printer connecton name: "\\", server, "\", printer, '\0'
        tstrPrinterConnectionName = (TCHAR*)::HeapAlloc(
            g_hMainHeap, 
            HEAP_ZERO_MEMORY, 
            (_tcslen(szServerName) + _tcslen(FAX_PRINTER_NAME) + 4)* sizeof(TCHAR)
            );
        if(NULL == tstrPrinterConnectionName)
        {
            ::lgLogError(
                LOG_SEV_1, 
                TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
                TEXT(__FILE__),
                __LINE__
                );
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }

        // Combine server and printer into printer connection
        _stprintf(tstrPrinterConnectionName, TEXT("\\\\%s\\%s"), szServerName, FAX_PRINTER_NAME);

        // Add printer connection
        if (!AddPrinterConnection(tstrPrinterConnectionName))
        {
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d Failed to add printer connection to %s (ec = %ld)\r\n"),
                TEXT(__FILE__),
                __LINE__,
                tstrPrinterConnectionName,
                ::GetLastError()
                );
            goto ExitFunc;
        }
    }

    dwFuncRetVal = GetCurrentUserSid((PBYTE*)&pCurrentUserSid);
    if (dwFuncRetVal != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\r\nGetCurrentUserSid() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwFuncRetVal
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    dwFuncRetVal = FormatUserKeyPath(pCurrentUserSid, REGKEY_WZRDHACK, &tstrWzrdRegHackKey);
    if (dwFuncRetVal != ERROR_SUCCESS)
    {
        ::lgLogError(
            LOG_SEV_1, 
            TEXT("FILE:%s LINE:%d\r\nFormatUserKeyPath() failed (ec = %ld)\r\n"),
            TEXT(__FILE__),
            __LINE__,
            dwFuncRetVal
            );
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }

    ::lgEndCase();
    if (FALSE == bRes)
    {
        nReturnValue = 1; // to indicate failure
        goto ExitFunc;
    }


    //Send a fax + CP
    ::_tprintf(TEXT("\nRunning TestCase1 (Send a fax + CP)...\n"));
    if (FALSE == TestCase1(         
                        szServerName,
                        tstrDialTo,
                        szDocument,
                        szCoverPage
                        )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase1 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase1 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send just a CP
    ::_tprintf(TEXT("\nRunning TestCase2 (Send just a CP)...\n"));
    if (FALSE == TestCase2(         
                    szServerName,
                    tstrDialTo,
                    szCoverPage
                    )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase2 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase2 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax with no CP
    ::_tprintf(TEXT("\nRunning TestCase3 (Send a fax with no CP)...\n"));
    if (FALSE == TestCase3(         
                    szServerName,
                    tstrDialTo,
                    szDocument
                    )
        )
    {
        ::_tprintf(TEXT("\nTest TestCase3 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase3 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

//
// For now, no broadcast test cases for NT5 Fax
//
#ifndef _NT5FAXTEST
        // Testing BOS Fax (with new fxsapi.dll)

    //Send a broadcast of fax + CP (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase4 (Send a broadcast of fax + CP)...\n"));
         if (FALSE == TestCase4(            
                            szServerName,
                            tstrDialTo,
                            szDocument,
                            szCoverPage
                            )
            )
        {
            ::_tprintf(TEXT("\nTest TestCase4 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase4 PASSED\n"));
        }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    }


    //Send a broadcast of only CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase5 (Send a broadcast of only CP)...\n"));
        if (FALSE == TestCase5(         
                            szServerName,
                            tstrDialTo,
                            szCoverPage
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase5 FAILED\n"));
        nReturnValue = 1; //to indicate failure
            goto ExitFunc;

        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase5 PASSED\n"));
        }
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a broadcast without CPs (3 * same recipient)
    // ** invoke broadcast tests for NT4 or later only **
    if (TRUE == g_fNT4OrLater)
    {
        ::_tprintf(TEXT("\nRunning TestCase6 (Send a broadcast without CP)...\n"));
        if (FALSE == TestCase6(         
                            szServerName,
                            tstrDialTo,
                            szDocument
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase6 FAILED\n"));
        nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase6 PASSED\n"));
        }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    }

#endif

    //Send a fax (*.doc file) + CP
    ::_tprintf(TEXT("\nRunning TestCase7 (Send a fax (*.doc file) + CP)...\n"));
    if (FALSE == TestCase7(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase7 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase7 PASSED\n"));
    }

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);
    
    //Send a fax (*.bmp file) + CP
    ::_tprintf(TEXT("\nRunning TestCase8 (Send a fax (*.bmp file) + CP)...\n"));
    if (FALSE == TestCase8(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase8 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase8 PASSED\n"));
    }

    

    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax (*.htm file) + CP
    ::_tprintf(TEXT("\nRunning TestCase9 (Send a fax (*.htm file) + CP)...\n"));
    if (FALSE == TestCase9(         
                        szServerName,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase9 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase9 PASSED\n"));
    }



    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax from Notepad (*.txt file = BVT_TXT_FILE) + CP
    ::_tprintf(TEXT("\nRunning TestCase10 (Send a fax from Notepad (*.txt file) + CP)...\n"));
    if (FALSE == TestCase10(            
                        szServerName,
                        tstrPrinterConnectionName ? tstrPrinterConnectionName : FAX_PRINTER_NAME,
                        tstrWzrdRegHackKey,
                        tstrDialTo,
                        szCoverPage
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase10 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase10 PASSED\n"));
    }



    // WORKAROUND - to avoid FaxRegisterForServerNotifications bug
    Sleep(5000);

    //Send a fax from Notepad (*.txt file = BVT_TXT_FILE) without CP
    ::_tprintf(TEXT("\nRunning TestCase11 (Send a fax from Notepad (*.txt file) without CP)...\n"));
    if (FALSE == TestCase11(            
                        szServerName,
                        tstrPrinterConnectionName ? tstrPrinterConnectionName : FAX_PRINTER_NAME,
                        tstrWzrdRegHackKey,
                        tstrDialTo
                        )
       )
    {
        ::_tprintf(TEXT("\nTest TestCase11 FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\n\tTestCase11 PASSED\n"));
    }
    
    if (TRUE == g_fCompareTiffFiles)
    {
        //
        //We sent the faxes, now compare the archived directories
        //The compare will be:
        //Compare #1: SentArchive with ReceivedArchive
        //Compare #2: RouteArchive with ReceivedArchive
        //If both compares succeed, it means that all 3 directories are the same
        //
        ::lgLogDetail(
            LOG_X,
            0,
            TEXT("All faxes have been sent\n\tCompare the archived directories")
            );
        
        //
        //Compare all "received faxes" in directory szReceiveDir
        //with the files in szReceiveDir
        //
        ::_tprintf(TEXT("\nRunning TestCase12 (Compare szSentDir with szReceiveDir)...\n"));
        if (FALSE == TestCase12(
                szSentDir,
                szReceiveDir
                )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase12 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase12 PASSED\n"));
        }

    
        //
        //Compare all "Inbox Routed" in directory szInboxArchiveDir
        //with the files in szReceiveDir
        //
        ::_tprintf(TEXT("\nRunning TestCase13 (Compare szInboxArchiveDir with szReceiveDir)...\n"));
        if (FALSE == TestCase13(
                            szInboxArchiveDir,
                            szReceiveDir
                            )
           )
        {
            ::_tprintf(TEXT("\nTest TestCase13 FAILED\n"));
            nReturnValue = 1; //to indicate failure
            goto ExitFunc;
        }
        else
        {
            ::_tprintf(TEXT("\n\tTestCase13 PASSED\n"));
        }
    }

    //
    // Output suite results to console
    //
    if (nReturnValue)
    {
        ::_tprintf(TEXT("\nTest Suite FAILED\n"));
        nReturnValue = 1; //to indicate failure
        goto ExitFunc;
    }
    else
    {
        ::_tprintf(TEXT("\nTest Suite PASSED\n"));
    }

    //
    //If we reach here, all is good
    //
    _ASSERTE(0 == nReturnValue);

ExitFunc:
    TestSuiteShutdown();

    // free command line params
    if (szServerName) 
    {
        HeapFree(g_hMainHeap, 0, szServerName);
    }
    if (szFaxNumber1) 
    {
        HeapFree(g_hMainHeap, 0, szFaxNumber1);
    }
    if (szFaxNumber2) 
    {
        HeapFree(g_hMainHeap, 0, szFaxNumber2);
    }
    if (szDocument) 
    {
        HeapFree(g_hMainHeap, 0, szDocument);
    }
    if (szCoverPage) 
    {
        HeapFree(g_hMainHeap, 0, szCoverPage);
    }
    if (szReceiveDir) 
    {
        HeapFree(g_hMainHeap, 0, szReceiveDir);
    }
    if (szSentDir) 
    {
        HeapFree(g_hMainHeap, 0, szSentDir);
    }
    if (szInboxArchiveDir) 
    {
        HeapFree(g_hMainHeap, 0, szInboxArchiveDir);
    }
    if (szBvtDir) 
    {
        HeapFree(g_hMainHeap, 0, szBvtDir);
    }
    if (szCompareTiffFiles) 
    {
        HeapFree(g_hMainHeap, 0, szCompareTiffFiles);
    }
    if (szUseSecondDeviceToSend) 
    {
        HeapFree(g_hMainHeap, 0, szUseSecondDeviceToSend);
    }
    if (tstrCurrentDirectory) 
    {
        HeapFree(g_hMainHeap, 0, tstrCurrentDirectory);
    }
    if (tstrPrinterConnectionName) 
    {
        HeapFree(g_hMainHeap, 0, tstrPrinterConnectionName);
    }
    if (pCurrentUserSid)
    {
        delete pCurrentUserSid;
    }
    if (tstrWzrdRegHackKey)
    {
        // remove SendWizard registry hack
        dwFuncRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, tstrWzrdRegHackKey);
        if (ERROR_SUCCESS != dwFuncRetVal && ERROR_FILE_NOT_FOUND != dwFuncRetVal)
        {
            ::_tprintf(TEXT("\n\nFailed to remove SendWizard registry hack (ec=%ld)\n"), dwFuncRetVal);
        }

        delete tstrWzrdRegHackKey;
    }

    return(nReturnValue);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\cometfax.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

// Module name:		fax.cpp
// Author:			Sigalit Bar (sigalitb)
// Date:			28-Jul-98


//
// Description:
//		This file contains the implementation of module "fax.h".
//



#include "CometFax.h"



// g_hHeap is a global handle to the process heap
HANDLE  g_hHeap = NULL;


//
// fnFaxPrint
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrint(
    HANDLE    /* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR   /* IN */	szFaxNumber,	//fax number to call
    LPCTSTR   /* IN */	szDocumentName,	//name of document to fax
    LPCTSTR   /* IN */	szCPName,		//name of cover page to fax
    LPDWORD  /* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlMessageId		//pointer to set to the fax msg id of the fax
)
{
	DWORD				dwRecipientJobs = 0;
	DWORD				dwLoopIndex = 0;
	DWORD				dwJobId = 0;
	DWORDLONG			dwlMessageId = 0;
	BOOL				fRetVal = FALSE;

	_ASSERTE(NULL != pdwLastError);

    // FaxJobParams is the FAX_JOB_PARAM struct
    FAX_JOB_PARAM       FaxJobParams;

    // Initialize the FAX_JOB_PARAM struct
    ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

    // Set the FAX_JOB_PARAM struct
    FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    FaxJobParams.RecipientNumber = szFaxNumber;
    FaxJobParams.RecipientName = szFaxNumber;
    FaxJobParams.ScheduleAction = JSA_NOW;	//send fax immediately

	// pCPInfo is the pointer to the FAX_COVERPAGE_INFO struct
	PFAX_COVERPAGE_INFO pCPInfo = NULL;
	// CPInfo is the FAX_COVERPAGE_INFO struct
	FAX_COVERPAGE_INFO CPInfo;
	// Initialize the FAX_COVERPAGE_INFO struct
	ZeroMemory(&CPInfo, sizeof(FAX_COVERPAGE_INFO));
	if (NULL != szCPName)
	{
		// Set the FAX_COVERPAGE_INFO struct
		CPInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
		CPInfo.CoverPageName = _tcsdup(szCPName);
		if (NULL == CPInfo.CoverPageName)
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("_tcsdup returned NULL with GetLastError=%d\n"),
				(*pdwLastError));
			goto ExitFunc;
		}
		CPInfo.Note = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
		CPInfo.Subject = TEXT("SUBJECT");	

		pCPInfo = &CPInfo;
	}

    if (!FaxSendDocument(hFaxSvcHandle, szDocumentName, &FaxJobParams, pCPInfo, &dwJobId))
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocument returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
		goto ExitFunc;
    }

#ifndef _NT5FAXTEST
//
// Extended private API - MessageId available
//
	if (pdwlMessageId)
	{
		PFAX_JOB_ENTRY_EX		pFaxRecipientJobs = NULL;

		//
		// get the job's dwlMessageId
		//
		if (!FaxEnumJobsEx(hFaxSvcHandle, JT_SEND, &pFaxRecipientJobs, &dwRecipientJobs))
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FaxEnumJobsEx returned FALSE with GetLastError=%d\n"),
				(*pdwLastError));
			goto ExitFunc;
		}
		_ASSERTE(pFaxRecipientJobs);
		_ASSERTE(dwRecipientJobs);

		for (dwLoopIndex = 0; dwLoopIndex < dwRecipientJobs; dwLoopIndex++)
		{
			if (pFaxRecipientJobs[dwLoopIndex].pStatus->dwJobID == dwJobId)
			{
				// this is our job => get the msg id
				dwlMessageId = pFaxRecipientJobs[dwLoopIndex].dwlMessageId;
			}
		}
		_ASSERTE(dwlMessageId);

		(*pdwlMessageId) = dwlMessageId;
	}
#endif // #ifndef _NT5FAXTEST

	(*pdwFaxId) = dwJobId;
	fRetVal = TRUE;

ExitFunc:
    return fRetVal;
}


#ifdef _NT5FAXTEST
//
// fnFaxPrintBroadcast_OLD
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_OLD(
    IN	HANDLE    	hFaxSvcHandle,	//handle to the fax service
    IN	LPCTSTR   	szDocumentName,	//name of document to fax
    IN	LPVOID    	pContext,		//pointer to a CFaxBroadcastObj 
    OUT	LPDWORD  	pdwFaxId,		//pointer to set to the fax job id of the fax
	OUT	LPDWORD	 	pdwLastError	//pointer to set to last error encountered during send
)
{
	BOOL fRetVal = FALSE;

	if (NULL == pContext)
	{
		(*pdwLastError) = E_INVALIDARG;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nfnFaxPrintBroadcast got a NULL pContext\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
	}

/*
	// FaxSendDocumentForBroadcast not defined in new winfax.h
	// TO DO: release from comment once we re-implement FaxSendDocumentForBroadcast

    if (!FaxSendDocumentForBroadcast(
				hFaxSvcHandle, 
				szDocumentName, 
				pdwFaxId, 
				DefaultFaxRecipientCallback, 
				pContext
				)
		) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocumentForBroadcast returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
        goto ExitFunc;
    }

  	fRetVal = TRUE;
*/
	//
	// Start HACK - FaxSendDocumentForBroadcast not defined in new winfax.h (so fail)
	//
	_ASSERTE(FALSE);
  	fRetVal = FALSE;
	*pdwLastError = ERROR_CALL_NOT_IMPLEMENTED;
	::lgLogError(
		LOG_SEV_1, 
		TEXT("FILE:%s LINE:%d\nReturning *pdwLastError=ERROR_CALL_NOT_IMPLEMENTED since FaxSendDocumentForBroadcast not defined in new winfax.h\n"),
		TEXT(__FILE__),
		__LINE__
		);
	//
	// End HACK - FaxSendDocumentForBroadcast not defined in new winfax.h
	//

ExitFunc:
    return(fRetVal);
}

#else // ! _NT5FAXTEST
//
// fnFaxPrintBroadcast_NEW
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_NEW(
    HANDLE		/* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR		/* IN */	szDocumentName,	//name of document to fax
    LPVOID		/* IN */	pContext,		//pointer to a CFaxBroadcastObj 
    LPDWORD		/* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD		/* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlParentMessageId,//pointer to set to the fax msg id of the fax
	DWORDLONG**	/* OUT */	ppdwlRecipientIds,	// array of recipient ids
	DWORD*		/* OUT */	pdwNumOfRecipients	//number of recipient ids in pdwlRecipientIds	
)
{
	BOOL fRetVal = FALSE;
    CFaxBroadcast*          pFaxBroadcast  = NULL;
    PFAX_COVERPAGE_INFO_EX  pCoverPageInfo = NULL;
    PFAX_PERSONAL_PROFILE   pRecipientList = NULL;
    DWORD                   dwNumRecipients = 0;
    FAX_JOB_PARAM_EX        JobParams;
    DWORDLONG               dwlParentJobId  = 0;
    PDWORDLONG              pdwlTmpRecipientIds = NULL;
    FAX_PERSONAL_PROFILE    Sender;
    DWORD                   dwLoopIndex = 0;

    //START declerations
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    PFAX_JOB_ENTRY_EX pJobEntry = NULL;
	PFAX_JOB_ENTRY_EX pBroadcastJobEntry = NULL;
    DWORD             dwRecipient0SessionJobId = 0;
    DWORD             dwParentSessionJobId = 0;
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    //END declerations

	// caller must have both ppdwlRecipientIds and pdwNumOfRecipients
	// NULL, or both not NULL
	if (NULL != ppdwlRecipientIds)
	{
		_ASSERTE(NULL != pdwNumOfRecipients);
	}
	else
	{
		_ASSERTE(NULL == pdwNumOfRecipients);
	}

	if (NULL == pContext)
	{
		(*pdwLastError) = E_INVALIDARG;
		::lgLogError(
			LOG_SEV_1, 
			TEXT("fnFaxPrintBroadcast got a NULL pContext\n")
			);
        goto ExitFunc;
	}
    pFaxBroadcast = (CFaxBroadcast*) pContext;
    if (FALSE == pFaxBroadcast->GetBroadcastParams(
                                    &pCoverPageInfo,
                                    &dwNumRecipients,
                                    &pRecipientList
                                    )
       )
    {
		(*pdwLastError) = E_INVALIDARG;
        goto ExitFunc;
    }
    // NOTE: GetBroadcastParams may return dwNumRecipients=0 and pRecipientList=NULL 

    // alloc recipient id array pdwTmpRecipientIds 
    if (0 != dwNumRecipients)
    {
        pdwlTmpRecipientIds = (PDWORDLONG) malloc (dwNumRecipients*sizeof(DWORDLONG));
        if (NULL == pdwlTmpRecipientIds)
        {
            (*pdwLastError) = ::GetLastError();
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("File=%s Line=%d\nmalloc failed with err=0x%08X\n"),
                TEXT(__FILE__),
                __LINE__,
                (*pdwLastError)
			    );
            goto ExitFunc;
        }
        ZeroMemory(pdwlTmpRecipientIds, dwNumRecipients*sizeof(DWORDLONG));
    }

    // Set JobParams
    ZeroMemory(&JobParams, sizeof(FAX_JOB_PARAM_EX));
    JobParams.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
    JobParams.dwScheduleAction = JSA_NOW;	//send fax immediately
	JobParams.lptstrDocumentName = TEXT("Doc Display Name");

    // Set Sender profile
    ZeroMemory(&Sender, sizeof(FAX_PERSONAL_PROFILE));
    Sender.dwSizeOfStruct =sizeof(FAX_PERSONAL_PROFILE);

    // Send
    if (FALSE == ::FaxSendDocumentEx(
                        hFaxSvcHandle, 
                        szDocumentName,
                        pCoverPageInfo,
                        &Sender,
                        dwNumRecipients,
                        pRecipientList,
                        &JobParams,
                        &dwlParentJobId,
                        pdwlTmpRecipientIds
                        )
       )
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FaxSendDocumentEx returned FALSE with GetLastError=%d\n"),
			(*pdwLastError));
        goto ExitFunc;
    }

	// removing the hack below
	// now causes FaxBVT.exe to not work with 
	// g_fUseExtendedEvents=FALSE and _NT5FAXTEST not defined
	dwParentSessionJobId = 0xcdcdcdcd; //HACK to avoid an assert
//
//	The hack below is currently removed because there is
//	no way of getting the session id of a parent job
//	(FaxGetParentJobId was removed and
//	FaxGetJobEx fails with invalid param for parent job id)
//
/*
    //START
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    // we need to get a DWORD session id for the parent job 
    // so we can see its notifications

    // first get a session id for a recipient
    if (!FaxGetJobEx(hFaxSvcHandle, pdwlTmpRecipientIds[0], &pJobEntry))
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE: %s LINE: %d\nFaxGetJobEx returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
    _ASSERTE(pJobEntry);
    dwRecipient0SessionJobId = pJobEntry->pStatus->dwJobID;
	::lgLogDetail(
		LOG_X,
        1, 
		TEXT("FILE: %s LINE: %d\ndwlRecipientJobId = %i64u\ndwlBroadcastId = %i64u"),
        TEXT(__FILE__),
        __LINE__,
		pdwlTmpRecipientIds[0],
		dwlParentJobId
        );

    // now, get the parent session id to support legacy notification mechanism

//
//	FaxGetParentJobId was removed from fxsapi.dll (but we may put it back)
//
//    if (!FaxGetParentJobId(hFaxSvcHandle, dwRecipient0SessionJobId, &dwParentSessionJobId))
//    {
//		(*pdwLastError) = ::GetLastError();
//		::lgLogError(
//			LOG_SEV_1, 
//			TEXT("FILE: %s LINE: %d\nFaxGetParentJobId returned FALSE with GetLastError=%d\n"),
//            TEXT(__FILE__),
//            __LINE__,
//			(*pdwLastError));
//        goto ExitFunc;
//    }
//

//
//	Currently, FaxGetJobEx fails with invalid param for parent job id 
//	(we may change this for testing)
//
	if (!FaxGetJobEx(hFaxSvcHandle, dwlParentJobId, &pBroadcastJobEntry))
    {
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE: %s LINE: %d\nFaxGetJobEx returned FALSE with GetLastError=%d\n"),
            TEXT(__FILE__),
            __LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
    _ASSERTE(pBroadcastJobEntry);
    _ASSERTE(pBroadcastJobEntry->pStatus);
    dwParentSessionJobId = pBroadcastJobEntry->pStatus->dwJobID;

  ::lgLogDetail(
		LOG_X,
        1, 
		TEXT("FILE: %s LINE: %d\ndwParentSessionJobId = %d\n"),
        TEXT(__FILE__),
        __LINE__,
		dwParentSessionJobId
        );
    //////////////////////////////////////////////////////
    // HACK to support legacy notifications mechanism	//
    //////////////////////////////////////////////////////
    //END
*/

    // log all ids
	::lgLogDetail(
		LOG_X,
        3, 
		TEXT("\nParentJobId = %I64x with %d Recipients\n"),
		dwlParentJobId,
        dwNumRecipients
        );
    for (dwLoopIndex = 0; dwLoopIndex < dwNumRecipients; dwLoopIndex++)
    {
		::lgLogDetail(
			LOG_X,
            3, 
			TEXT("\nJobId of Recipient(%d) = %I64x\n"),
            dwLoopIndex,
			pdwlTmpRecipientIds[dwLoopIndex]
            );
    }

    // set OUT params
    (*pdwFaxId) = dwParentSessionJobId;
	(*pdwLastError) = ERROR_SUCCESS;

	if (pdwlParentMessageId)
	{
		(*pdwlParentMessageId) = dwlParentJobId;
	}
	if (ppdwlRecipientIds)
	{
		(*ppdwlRecipientIds) = pdwlTmpRecipientIds;
		_ASSERTE(pdwNumOfRecipients);
		(*pdwNumOfRecipients) = dwNumRecipients;
	}
	fRetVal = TRUE;

ExitFunc:
    // free all tmp allocs
	if (pCoverPageInfo)
    {
        free(pCoverPageInfo->lptstrCoverPageFileName);
        free(pCoverPageInfo);
    }
    if (pRecipientList)
    {
        for (dwLoopIndex = 0; dwLoopIndex < dwNumRecipients; dwLoopIndex++)
        {
            free(pRecipientList[dwLoopIndex].lptstrFaxNumber);
        }
        free(pRecipientList);
    }
   	if (NULL == ppdwlRecipientIds)
	{
		// we don't have any use for the allocated pdwlTmpRecipientIds =>
		// free it
		free(pdwlTmpRecipientIds);
	}
    FaxFreeBuffer(pJobEntry);
    return(fRetVal);
}

#endif // #ifdef _NT5FAXTEST


//
// PortIsSendEnabled
//	Checks if device with id dwDeviceId is configured as "send enabled"
//	according to the configuration described by pFaxPortsConfig, with
//	dwNumFaxPorts representing the number of ports that pFaxPortsConfig
//	contains.
//
BOOL
PortIsSendEnabled(
    PFAX_PORT_INFO  /* IN */ pFaxPortsConfig,	//array of FAX_PORT_INFO structs
    DWORD           /* IN */ dwNumFaxPorts,		//number of FAX_PORT_INFO structs in above array
    DWORD           /* IN */ dwDeviceId			//id of device in question
)
{
	DWORD dwIndex;
    for (dwIndex = 0; dwIndex < dwNumFaxPorts; dwIndex++) 
	{
        if (pFaxPortsConfig[dwIndex].DeviceId != dwDeviceId) continue;
		if (pFaxPortsConfig[dwIndex].Flags & FPF_SEND)
		{
            return TRUE;
        }
    }
	return FALSE;
}


//
// SendFax:
//	Sends a fax containing the document szDocumentName to fax number
//	szFaxNumber and collects all the FAX_EVENT@s from hCompletionPort
//	into SendInfo. The fax job id is returned via pdwFaxId and the
//	last error encountered is returned via pdwLastError.
//
// IMPORTANT:
//	This is a SYNCHRONOUS send.
//	The function waits until the fax session has completed, accumulating
//	all the FAX_EVENT@s generated by the send job into the OUT parameter
//	SendInfo.
//
BOOL
SendFax(
    LPCTSTR		/* IN */	szFaxNumber,
    LPCTSTR		/* IN */	szDocumentName,
	LPCTSTR		/* IN */	szCPName,
	LPCTSTR		/* IN */	szMachineName,
	HANDLE		/* IN */	hCompletionPort,
	LPVOID		/* IN */	pContext,
    LPDWORD		/* OUT */	pdwFaxId,
    DWORDLONG*	/* OUT */	pdwlMessageId,
	CSendInfo&	/* OUT */	SendInfo,
	LPDWORD		/* OUT */	pdwLastError
)
{
	// hFaxSvcHandle is the handle to the local fax service
    HANDLE				hFaxSvcHandle	= NULL;
    // pFaxSvcConfig is a pointer to the fax service configuration
    PFAX_CONFIGURATION  pFaxSvcConfig	= NULL;
    // pFaxPortsConfig is a pointer to the fax ports configuration
    PFAX_PORT_INFO      pFaxPortsConfig	= NULL;
    // dwNumFaxPorts is the number of fax ports
    DWORD               dwNumFaxPorts;
    // dwNumAvailFaxPorts is the number of send enabled fax ports
    DWORD               dwNumAvailFaxPorts;
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT          pFaxEvent = NULL;
    // pFaxInfo is a pointer to the FAX_INFO structs
    PFAX_INFO           pFaxInfo = NULL;
	// broadcast obj 
	CFaxBroadcast* thisBroadcastObj = NULL;
	// function's return value
	BOOL fReturnValue = FALSE;

	// fxsapi.dll function pointers
	LPVOID pVoidFunc = NULL;
	DWORDLONG*	pdwlTmpMessageId = NULL;
	DWORDLONG**	ppdwlRecipientIds = NULL;
	DWORD*		pdwNumOfRecipients = NULL;

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwLastError parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check that we can set *pdwFaxId
	if (NULL == pdwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwFaxId parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check that we can set *pdwlMessageId
	if (NULL == pdwlMessageId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwlMessageId parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwlMessageId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with hCompletionPort parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
    // Get the handle to the process heap
	//
    g_hHeap = GetProcessHeap();
	if (NULL == g_hHeap)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetProcessHeap returned NULL pointer with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
	}

	//
    // Connect to the fax service
	//
	hFaxSvcHandle = NULL;
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//WHITE BOX tells us that a Fax Service HANDLE
	//is in actuality a pointer to a node in a linked list =>
	//for maximum verification, we check the API didn't return NULL
	_ASSERTE(hFaxSvcHandle);

	//
	// Retrieve the fax service configuration
	//
    if (!FaxGetConfiguration(hFaxSvcHandle, &pFaxSvcConfig)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//This API returns a pointer, so for max verification
	//we check it is not NULL
	_ASSERTE(pFaxSvcConfig);

	//
	//We set the Retries parameter to 0 
	//since we want a single try (no retry).       
	//
	pFaxSvcConfig->Retries = 0;
	//Q:
	//check that not paused
	//pFaxSvcConfig->PauseServerQueue = 0;

/*
	//BUG - getting 0xC0000005 (AV) error
    if (!FaxSetConfiguration(hFaxSvcHandle, pFaxSvcConfig)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
*/

	//
    // Retrieve the fax ports configuration
	//
    if (!FaxEnumPorts(hFaxSvcHandle, &pFaxPortsConfig, &dwNumFaxPorts)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
    }
	//API returns pointer to port config, for max
	//verification we check it isn't NULL
	_ASSERTE(pFaxPortsConfig);
	//API returns number of ports, for max verification
	//we check it isn't 0.
	_ASSERTE(dwNumFaxPorts);
	//Note: We ASSERT because...
	//There must be at least one port, otherwise the
	//Fax Service would not start 
	//(FaxConnectFaxService would have failed).
	//In any way if this is the situation (pFaxPortsConfig==NULL)
	//or (dwNumFaxPorts == 0) we cannot continue
	//since faxes cannot be sent.


	//
    // Retrieve the number of send enabled fax ports
	//
	DWORD dwIndex;
    for (dwIndex = 0, dwNumAvailFaxPorts = 0; dwIndex < dwNumFaxPorts; dwIndex++) 
	{
        if (pFaxPortsConfig[dwIndex].Flags & FPF_SEND) 
		{
            dwNumAvailFaxPorts++;
        }
    }
	//If there are no send enabled ports, then return with FALSE and ERROR_INVALID_DATA
    if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("There are no Send enabled ports. Fax will not be sent\n"));
		(*pdwLastError) = ERROR_INVALID_DATA;
        goto ExitFunc;
    }

	//
    // Initialize the FAX_INFO struct 
	// pFaxInfo is used to indicate completion and pass or fail
	// inside the following while on GetQueuedCompletionStatus loop.
	//
    pFaxInfo = (PFAX_INFO)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, sizeof(FAX_INFO));
	if (NULL == pFaxInfo)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d HeapAlloc returned NULL pointer with GetLastError=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
        goto ExitFunc;
	}


#ifndef _NT5FAXTEST
	// Testing Bos Fax (with new fxsapi.dll)
	pdwlTmpMessageId = &(pFaxInfo->dwlMessageId);
	ppdwlRecipientIds = &(pFaxInfo->pdwlRecipientMessageIds);
	pdwNumOfRecipients = &(pFaxInfo->dwNumOfRecipients);
	// Note: when testing NT5Fax 
	//		 pdwlMessageId  and ppdwlRecipientIds remain NULL
	//		 and pdwNumOfRecipients remains 0
#endif

	//
	// Log the doc name and fax number of fax.
	//
	if (NULL == pContext) //this is a regular fax
	{
		::lgLogDetail(
			LOG_X, 
			3, 
			TEXT("Printing a fax:\n  Document Name: %s\n  Fax Number: %s.\n"), 
			szDocumentName, 
			szFaxNumber);

		//
		// "Print" the fax (no cover page)
		// Actually fnFaxPrint just adds the job to the Fax Service queue.
		//
		if (!fnFaxPrint(
				hFaxSvcHandle, 
				szFaxNumber, 
				szDocumentName, 
				szCPName, 
				&(pFaxInfo->dwFaxId), 
				pdwLastError,
				pdwlTmpMessageId
				)
			) 
		{
			goto ExitFunc;
		}

		pFaxInfo->dwNumOfRecipients = 1; // this is a non-broadcast fax
	}
	else	//this is a broadcast
	{
		::lgLogDetail(
			LOG_X, 
			3, 
			TEXT("Printing a broadcast:\n  Document Name: %s\n"), 
			szDocumentName
			);
		thisBroadcastObj = (CFaxBroadcast*)pContext;
		thisBroadcastObj->outputAllToLog(LOG_X,1);

#ifndef _NT5FAXTEST
		// Testing Bos Fax (with new fxsapi.dll)

		//
		// Broadcast the fax 
		//
		if (!fnFaxPrintBroadcast(
				hFaxSvcHandle,
				szDocumentName, 
				pContext,
				&(pFaxInfo->dwFaxId), 
				pdwLastError,
				pdwlTmpMessageId, 
				ppdwlRecipientIds,
				pdwNumOfRecipients
				)
			) 
		{
			goto ExitFunc;
		}
#else
		// Testing NT5 Fax (with old winfax.dll)

		//
		// Broadcast the fax 
		//
		if (!fnFaxPrintBroadcast(
				hFaxSvcHandle,
				szDocumentName, 
				pContext,
				&(pFaxInfo->dwFaxId), 
				pdwLastError
				)
			) 
		{
			goto ExitFunc;
		}
#endif

	}


	//if succeeded log that fax was queued
	::lgLogDetail(
		LOG_X,
		4, 
		TEXT("Fax queuing SUCCESS. JobId=%u dwlMessageId=%I64u\n"),
		pFaxInfo->dwFaxId,
		pFaxInfo->dwlMessageId
		);
	(*pdwFaxId) = pFaxInfo->dwFaxId;
	(*pdwlMessageId) = pFaxInfo->dwlMessageId;


	fReturnValue = WatchFaxEvents(
						hCompletionPort,
						pFaxPortsConfig,
						dwNumFaxPorts,
						dwNumAvailFaxPorts,
						pFaxInfo, 
						SendInfo, 
						pdwLastError
						);
	if (FALSE == fReturnValue)
	{
		goto ExitFunc;
	}

	//fReturnValue is defaultly FALSE and 
	//is should be true only if WatchFax@Events succeeded.

ExitFunc:

    // Free the FAX_INFO struct
	if (NULL != pFaxInfo)
	{
		free(pFaxInfo->pdwlRecipientMessageIds);

		if (FALSE == ::HeapFree(g_hHeap, 0, pFaxInfo))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d HeapFree returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}

    // Free the fax ports configuration
	if (NULL != pFaxPortsConfig) FaxFreeBuffer(pFaxPortsConfig);
	if (NULL != pFaxSvcConfig) FaxFreeBuffer(pFaxSvcConfig);

    // Disconnect from the fax service
	if (NULL != hFaxSvcHandle)
	{
		if (!FaxClose(hFaxSvcHandle))
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				(*pdwLastError)
				);
			fReturnValue = FALSE;
		}
	}

    return fReturnValue;
}


//
// AbortFax
//	Aborts the fax job with dwJobId on the local Fax Server,
//	and returns the last error encountered via pdwLastError.
//
// IMPORTANT:
//	This is an ASYNCHRONOUS abort.
//	It delivers the abort request to the local Fax Server 
//	and returns.
//
BOOL AbortFax(
	LPCTSTR		/* IN */	szMachineName,
	const DWORD	/* IN */	dwJobId,
	LPDWORD		/* OUT */	pdwLastError)
{
	BOOL fReturnValue = FALSE;
	HANDLE hFaxSvcHandle = NULL;
	PMY_FAX_JOB_ENTRY JobsArray = NULL;

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d pdwLastError parameter is equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS;

    // Connect to the local fax service
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
    }

	//
	// Get an array of jobs on queue
	//
	DWORD dwJobsNum;
	if (!MyFaxEnumJobs(hFaxSvcHandle,&JobsArray,&dwJobsNum))
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumJobs returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
	}


	//
	// Log whether this job is on queue
	//
	DWORD index;
	BOOL fJobExists; // do NOT put =FALSE on this line, it causes compile error
					 // because of "goto ExitLevel1" above.
	fJobExists = FALSE;
	for (index=0;index<dwJobsNum;index++)
	{
		if (MyGetJobId(JobsArray[index]) == dwJobId)
		{
			fJobExists = TRUE;
		}
	}
	if (fJobExists)
	{
		::lgLogDetail(LOG_X, 7, TEXT("Job#%d EXISTS on queue."),dwJobId);
	}
	else
	{
		::lgLogDetail(LOG_X, 7, TEXT("Job#%d does NOT EXIST on queue."),dwJobId);
	}

	//
	// Abort the job
	//
	//Note: Even if job not on queue we call this API
	if (!FaxAbort(hFaxSvcHandle,dwJobId)) 
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxAbort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError));
		goto ExitFunc;
    }

	::lgLogDetail(LOG_PASS, 1, TEXT("Abort job#%d PASS\n"),dwJobId);
	fReturnValue = TRUE;

ExitFunc:
	//Free JobsArray
	if (NULL != JobsArray) FaxFreeBuffer(JobsArray);

	//Free hFaxSvcHandle
	if (NULL != hFaxSvcHandle)
	{
		if (!FaxClose(hFaxSvcHandle)) 
		{
			(*pdwLastError) = ::GetLastError();
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				(*pdwLastError));
		}
	}

    return(fReturnValue);
}



//
// InitFaxQueue:
//	Initializes the Fax Service queue so that it will post
//	all FAX_EVENTs to an I\O completion port.
//
BOOL InitFaxQueue(
	LPCTSTR		/* IN */	szMachineName,
	HANDLE&		/* OUT */	hComPortHandle,
	DWORD&		/* OUT */	dwLastError,
	HANDLE&		/* OUT */	hServerEvents
	)
{
	dwLastError = ERROR_SUCCESS;	//if func succeeds - OUT DWORD is ERROR_SUCCESS
	hComPortHandle = NULL;			//if func fails - OUT HANDLE is NULL'ed

	HANDLE hCompletionPort = NULL;
	HANDLE hFaxSvcHandle = NULL;
	BOOL fReturnValue = FALSE;

#ifndef _NT5FAXTEST
//
// Use extended notifications mechanism
//
	DWORD	dwEventTypes = 0;
	hServerEvents = NULL;
#endif

    // Connect to the fax service
    if (!FaxConnectFaxServer(szMachineName, &hFaxSvcHandle)) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxConnectFaxServer returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
        goto ExitFunc;
    }

    // Create the completion port
    hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    if (NULL == hCompletionPort) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CreateIoCompletionPort returned FALSE with GetLastError=%d\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
        goto ExitFunc;
    }

#ifdef _NT5FAXTEST
//
// Use legacy notifications mechanism
//
	// Initialize the fax event queue
	if (!FaxInitializeEventQueue(hFaxSvcHandle, hCompletionPort, 0, NULL, 0)) 
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxInitializeEventQueue returned FALSE with GetLastError=0x%08x\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
		goto ExitFunc;
	}
#else // ! _NT5FAXTEST
//
// Use extended notifications mechanism
//
	dwEventTypes = (	FAX_EVENT_TYPE_IN_QUEUE	|
						FAX_EVENT_TYPE_OUT_QUEUE |
						FAX_EVENT_TYPE_CONFIG |
						FAX_EVENT_TYPE_ACTIVITY	|
						FAX_EVENT_TYPE_QUEUE_STATE |
						FAX_EVENT_TYPE_IN_ARCHIVE |
						FAX_EVENT_TYPE_OUT_ARCHIVE |
						FAX_EVENT_TYPE_FXSSVC_ENDED
					); // all server events

	if (!FaxRegisterForServerEvents(
								hFaxSvcHandle,
								dwEventTypes,
								hCompletionPort,
								0,
								NULL,
								0,
								&hServerEvents
								)
		)
	{
		dwLastError = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nFaxRegisterForServerEvents returned FALSE with GetLastError=0x%08x\n"), 
			TEXT(__FILE__),
			__LINE__,
			dwLastError);
		goto ExitFunc;
	}
#endif // #ifdef _NT5FAXTEST

	hComPortHandle = hCompletionPort;
	fReturnValue = TRUE;

ExitFunc:
	//
    // Disconnect from the fax service
	//
	if (NULL != hFaxSvcHandle)
	{
		if(!FaxClose(hFaxSvcHandle))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"), 
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}
	if (FALSE == fReturnValue)
	{
		if (hCompletionPort)
		{
			// Close the completion port
			if(!CloseHandle(hCompletionPort))
			{
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d\nCloseHandle returned FALSE with GetLastError=%d\n"), 
					TEXT(__FILE__),
					__LINE__,
					::GetLastError());
			}
			hCompletionPort = NULL;
		}
	}

    return fReturnValue;
}


#ifdef _NT5FAXTEST
//
// WatchFaxLegacyEvents:
//	collects all the FAX_EVENTs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxLegacyEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT          pFaxEvent = NULL;
    DWORD               dwBytes = 0;
    ULONG_PTR           pulCompletionKey = 0;
	// function's return value
	BOOL fReturnValue = FALSE;

	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE: %s LINE:%d\n[WatchFaxLegacyEvents] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pdwLastError parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check pFaxInfo is valid
	if (NULL == pFaxInfo)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxInfo parameter equal to NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxInfo);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check dwFaxId is valid
	if (0 == pFaxInfo->dwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxInfo->dwFaxId parameter equal to 0\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != pFaxInfo->dwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with hCompletionPort parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If pFaxPortsConfig is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!pFaxPortsConfig) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with pFaxPortsConfig parameter equal to NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxPortsConfig);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumFaxPorts is 0 return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with dwNumFaxPorts parameter equal to 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumAvailFaxPorts is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SendFax Called with dwNumAvailFaxPorts parameter equal to 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumAvailFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	// Handle fax events on the completion port
	//
	BOOL fReturnValueOfGetQueuedCompletionStatus;
    while ( fReturnValueOfGetQueuedCompletionStatus =
			::GetQueuedCompletionStatus(
				hCompletionPort, 
				&dwBytes, 
				&pulCompletionKey, 
				(LPOVERLAPPED *) &pFaxEvent, 
				MAX_COMP_PORT_WAIT_TIME) 
			) 
	{
		//check that pFaxEvent is legitimate
		//if not log and return FALSE and ERROR_INVALID_DATA
		if (FALSE == _CrtIsValidPointer((const void*) pFaxEvent, sizeof(FAX_EVENT), TRUE) )
		{
			(*pdwLastError) = ERROR_INVALID_DATA;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d _CrtIsValidPointer returned FALSE\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		//We are only interested in events with a specific JobId
		//and the general (non-job related) events with JobId -1
		if ((pFaxEvent->JobId != pFaxInfo->dwFaxId) && (-1 != pFaxEvent->JobId)) 
		{
			goto ContinueWhile; 
		}

		//
		// Handle the different types of events
		//
		switch (pFaxEvent->EventId)
		{

		//
		// General events with JobId=-1
		//

		case FEI_FAXSVC_ENDED:				
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_FAXSVC_STARTED:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_INITIALIZING:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

		case FEI_MODEM_POWERED_OFF:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			//If a send enabled port was powered off
			//we update the number of ports "available"
			//for sending.
            if (
				::PortIsSendEnabled(
					pFaxPortsConfig,
					dwNumFaxPorts,
					pFaxEvent->DeviceId
					)
				) 
			{
				dwNumAvailFaxPorts--;
			}
			//If there are no more send enabled ports
			//then fax cannot be sent, so we return FALSE
			//and ERROR_INVALID_DATA
            if (0 == dwNumAvailFaxPorts) 
			{
				::lgLogError(LOG_SEV_1, TEXT("There are no send enablede Fax ports.\n"));
				(*pdwLastError) = ERROR_INVALID_DATA;
                goto ExitFunc;
            }
			else
			{
				//At any case we want to log how many ports remain
				//Even if there was actually no change
				::lgLogDetail(
					LOG_X,
					4, 
					TEXT("There are %d available Fax ports.\n"),
					dwNumAvailFaxPorts);
			}
            break;

		case FEI_MODEM_POWERED_ON:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			//We suspect this event is never generated, so "hack"
			_ASSERTE(FALSE); 
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			//If this port is send enabled, then increment
			//the number of "available" send ports
            if (
				::PortIsSendEnabled(
					pFaxPortsConfig,
					dwNumFaxPorts,
					pFaxEvent->DeviceId
					)
				) 
			{
				dwNumAvailFaxPorts++;
			}
			::lgLogDetail(LOG_X,4, TEXT("There are %d send enabled Fax ports.\n"),dwNumAvailFaxPorts);
            break;

        case FEI_RINGING:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
			//The Fax Service detected that
			//one of its devices is ringing
			//Not interesting => dismiss.
			break;

        case FEI_IDLE:
			//This is a JobId=-1 event.
			_ASSERTE(pFaxEvent->JobId == -1);
            // If job is complete then we return TRUE
            if ((pFaxInfo->bComplete) && (pFaxEvent->DeviceId == pFaxInfo->dwDeviceId))
			{
				// Add Event to OUT parameter 
				SendInfo.AddItem(*pFaxEvent);
				// We return TRUE, since we exit earlier if the send failed
				fReturnValue = TRUE;
				goto ExitFunc;
            }
            break;

		//
		// Send job events
		//

        case FEI_DIALING:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			//Set the device used to perform the send job
			pFaxInfo->dwDeviceId = pFaxEvent->DeviceId;
			//Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_NO_DIAL_TONE:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			//Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NO_DAIL_TONE for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_JOB_QUEUED:
        case FEI_HANDLED: //TO DO: make sure what we want here Esp. pFaxEvent->DeviceId == ???
        case FEI_SENDING:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_LINE_UNAVAILABLE:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_LINE_UNAVAILABLE for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_BUSY:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_BUSY for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_NO_ANSWER:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NO_ANSWER for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_FATAL_ERROR:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// a FATAL_ERROR can happen before dialing so 
			// pFaxInfo->dwDeviceId might still 0 =>
			// This event should have the DeviceId that was used to dial or 0
			_ASSERTE((pFaxEvent->DeviceId == pFaxInfo->dwDeviceId) || (0 == pFaxInfo->dwDeviceId));
			//This event indicates that send failed.
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_FATAL_ERROR for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_COMPLETED:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			//This event indicates that send succeeded.
			//But we stil wait for the idle event of this device.
			//set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = TRUE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
            break;

        case FEI_ABORTING:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// a FATAL_ERROR can happen before dialing so 
			// pFaxInfo->dwDeviceId might still 0 =>
			// This event should have the DeviceId that was used to dial or 0
			_ASSERTE((pFaxEvent->DeviceId == pFaxInfo->dwDeviceId) || (0 == pFaxInfo->dwDeviceId));
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ABORTING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_DELETED:
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			if (0 == pFaxEvent->DeviceId)
			{
				//this is a broadcast job => ok
				pFaxInfo->bPass = TRUE;
				fReturnValue = TRUE;
			}
			else 
			{
				//this is a regular job => failure
				pFaxInfo->bPass = FALSE;
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FEI_DELETED for job %d on port %d"),
					pFaxEvent->JobId,
					pFaxEvent->DeviceId
					);
				(*pdwLastError) = ERROR_INVALID_DATA;
			}
			goto ExitFunc;

        case FEI_DISCONNECTED:		//CAN ??
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_DISCONNECTED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_BAD_ADDRESS:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_BAD_ADDRESS for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_CALL_DELAYED:		
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_CALL_DELAYED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

        case FEI_CALL_BLACKLISTED:	
			//This event should be with JobId==<our send job id>
			_ASSERTE(pFaxEvent->JobId == pFaxInfo->dwFaxId);
			// This event should have the DeviceId that was used to dial
			_ASSERTE(pFaxEvent->DeviceId == pFaxInfo->dwDeviceId);
			// Set the complete flag
			pFaxInfo->bComplete = TRUE;
			// Set the pass flag
			pFaxInfo->bPass = FALSE;
			// Add Event to OUT parameter 
			SendInfo.AddItem(*pFaxEvent);
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_CALL_BLACKLISTED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			(*pdwLastError) = ERROR_INVALID_DATA;
            goto ExitFunc;

		//
		// Receive job events
		//

        case FEI_RECEIVING:			
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_RECEIVING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        case FEI_NOT_FAX_CALL:		
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_NOT_FAX_CALL for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        case FEI_ANSWERED:			
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ANSWERED for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

		//
		// Routing job events
		//

        case FEI_ROUTING:
		//We should never get this event
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FEI_ROUTING for job %d on port %d"),
				pFaxEvent->JobId,
				pFaxEvent->DeviceId
				);
			_ASSERTE(FALSE);			
			break;

        default:
			::lgLogError(
				LOG_SEV_4, 
				TEXT("FILE:%s LINE:%d SEND FAX FATAL ERROR - State out of enumaration scope 0x%x.\n"),
				TEXT(__FILE__),
				__LINE__,
                pFaxEvent->EventId
                );
			_ASSERTE(FALSE);
            break;
		}

ContinueWhile:
        // Free the pFaxEvent packet
        if (NULL != ::LocalFree(pFaxEvent))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d LocalFree did not return NULL with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			//we do NOT exit the function upon such an error and do not return FALSE.
		}
		pFaxEvent = NULL;
    }

	//
	//Check if we left while because GetQueuedCompletionStatus failed
	//
	if (FALSE == fReturnValueOfGetQueuedCompletionStatus)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetQueuedCompletionStatus returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError)
			);
		goto ExitFunc;
	}

	//fReturnValue is defaultly FALSE and 
	//is set to TRUE at relevent cases inside switch.

ExitFunc:
	//Free any "left over" pFaxEvent
	if (NULL != pFaxEvent)
	{
        if (NULL != ::LocalFree(pFaxEvent))
		{
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d LocalFree did not return NULL with GetLastError=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError());
		}
	}

    return fReturnValue;
}

#else // ! _NT5FAXTEST

///
//
// HandleOutQueueEvent:
//
BOOL
HandleOutQueueExtendedEvent(
	PFAX_EVENT_EX	/* IN */	pFaxEventEx,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
	BOOL			fRetVal = FALSE;
	FAX_EVENT_JOB	JobInfo = {0};
	PFAX_JOB_STATUS	pJobData = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
	DWORDLONG		dwlMessageId = 0;
	LPCTSTR			strQueueStatus = NULL;
	LPCTSTR			strExtendedStatus = NULL;


	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	_ASSERTE(pFaxEventEx);
	_ASSERTE(pFaxInfo);
	_ASSERTE(pdwLastError);
	_ASSERTE(FAX_EVENT_TYPE_OUT_QUEUE == pFaxEventEx->EventType);

	//
	// get field values from pFaxEventEx
	// 
	JobInfo = (pFaxEventEx->EventInfo).JobInfo;
	pJobData = JobInfo.pJobData;
	dwlMessageId = JobInfo.dwlMessageId;

	switch(JobInfo.Type)
	{
		case FAX_JOB_EVENT_TYPE_ADDED:
		case FAX_JOB_EVENT_TYPE_REMOVED:
			//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
			SendInfo.AddItem(*pFaxEventEx);
			break;

		case FAX_JOB_EVENT_TYPE_STATUS:
		dwQueueStatus = pJobData->dwQueueStatus;
		dwExtendedStatus = pJobData->dwExtendedStatus;
		strQueueStatus = GetQueueStatusTStr(dwQueueStatus);
		strExtendedStatus = GetExtendedStatusTStr(dwExtendedStatus);
		if (pJobData->lpctstrExtendedStatus)
		{
			lpctstrExtendedStatus = pJobData->lpctstrExtendedStatus;
		}
		else
		{
			lpctstrExtendedStatus = TEXT("(null)");
		}
		switch (dwQueueStatus)
		{
			case JS_INPROGRESS:
				if (JS_EX_PROPRIETARY <= dwExtendedStatus)
				{
					// this is a proprietary extended status so 
					// do nothing
					SendInfo.AddItem(*pFaxEventEx);
					break;
				}
				switch (dwExtendedStatus)
				{
					case JS_EX_INITIALIZING:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						//Set the device used to perform the send job
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//pFaxInfo->dwDeviceId = pJobData->dwDeviceID;
						SendInfo.AddItem(*pFaxEventEx);
						break;

					case JS_EX_DIALING:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						//Set the device used to perform the send job
						pFaxInfo->dwDeviceId = pJobData->dwDeviceID;
						SendInfo.AddItem(*pFaxEventEx);
						break;

					case JS_EX_TRANSMITTING:
					case JS_EX_HANDLED:
                    case JS_EX_CALL_COMPLETED:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						SendInfo.AddItem(*pFaxEventEx);
						break;

					default:
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						_ASSERTE(FALSE);
						goto ExitFunc;
						break;
				} //switch (dwExtendedStatus)
				break;

	        case JS_COMPLETED:
				//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
				_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
				if (1 == pFaxInfo->dwNumOfRecipients)
				{
					// this is a regular (non-broadcast) fax
					pFaxInfo->bComplete = TRUE;
					pFaxInfo->bPass = TRUE;
				}
				else
				{
					// this is a broadcast fax
					_ASSERTE(pFaxInfo->dwNumOfCompletedRecipients < pFaxInfo->dwNumOfRecipients);
					pFaxInfo->dwNumOfCompletedRecipients++; // mark that a recipient completed
					if (pFaxInfo->dwNumOfCompletedRecipients == pFaxInfo->dwNumOfRecipients)
					{
						// all the recipients completed =>
						// broadcast is completed
						pFaxInfo->bComplete = TRUE;
						pFaxInfo->bPass = TRUE;
					}
				}
				SendInfo.AddItem(*pFaxEventEx);
				break;

			case JS_RETRIES_EXCEEDED:
			case JS_FAILED:
			case JS_RETRYING:
				switch (dwExtendedStatus)
				{
					case JS_EX_LINE_UNAVAILABLE:
					case JS_EX_BUSY:
					case JS_EX_NO_ANSWER:
					case JS_EX_BAD_ADDRESS:
					case JS_EX_FATAL_ERROR:
					case JS_EX_NO_DIAL_TONE:
					case JS_EX_DISCONNECTED:
					case JS_EX_CALL_DELAYED:
					case JS_EX_CALL_BLACKLISTED:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//This event indicates that send failed.
						SendInfo.AddItem(*pFaxEventEx);
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						(*pdwLastError) = ERROR_INVALID_DATA;
						goto ExitFunc;
						break;

					default:
						//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
						_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
						//This event indicates that send failed.
						SendInfo.AddItem(*pFaxEventEx);
						::lgLogError(
							LOG_SEV_1, 
							TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nExtendedStatus Out of Scope - QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
							TEXT(__FILE__),
							__LINE__,
							strQueueStatus,
							strExtendedStatus,
							lpctstrExtendedStatus,
							dwlMessageId,
							pJobData->dwDeviceID
							);
						_ASSERTE(FALSE);
						goto ExitFunc;
						break;

				} //switch (dwExtendedStatus)
				break;

			case JS_DELETING:
			case JS_CANCELED:
				//_ASSERTE(dwlMessageId == pFaxInfo->dwlMessageId);
				_ASSERTE(pFaxInfo->dwDeviceId == pJobData->dwDeviceID);
				//This event indicates that send failed.
				SendInfo.AddItem(*pFaxEventEx);
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nGot QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
					TEXT(__FILE__),
					__LINE__,
					strQueueStatus,
					strExtendedStatus,
					lpctstrExtendedStatus,
					dwlMessageId,
					pJobData->dwDeviceID
					);
				(*pdwLastError) = ERROR_INVALID_DATA;
				goto ExitFunc;
				break;

			default:
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\nQueueStatus Out of Scope - QueueStatus=%s ExtendedStatus=%s lpctstrExtendedStatus=%s for messageId=%I64u on port %d"),
					TEXT(__FILE__),
					__LINE__,
					strQueueStatus,
					strExtendedStatus,
					lpctstrExtendedStatus,
					dwlMessageId,
					pJobData->dwDeviceID
					);
				_ASSERTE(FALSE);
				(*pdwLastError) = ERROR_INVALID_DATA;
				goto ExitFunc;
				break;

		} //switch (dwQueueStatus)
		break;

		default:
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d [HandleOutQueueExtendedEvent]\n- JobInfo.Type=0x%08X is out of enumaration scope\n"),
				TEXT(__FILE__),
				__LINE__,
				JobInfo.Type
				);
			_ASSERTE(FALSE);
			break;
	} //switch(JobInfo.Type)

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}


///
//
// WatchFaxExtendedEvents:
//	collects all the FAX_EVENT_EXs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxExtendedEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
)
{
	BOOL				fReturnValue = FALSE;
    // pFaxEvent is a pointer to the fax port event
    PFAX_EVENT_EX       pFaxEventEx = NULL;
    DWORD               dwBytes = 0;
    ULONG_PTR           pulCompletionKey = 0;
	FAX_EVENT_JOB		EventJobInfo = {0};
	DWORD				dwLoopIndex = 0;
	BOOL				fOneOfMyRecipientMsgIds = FALSE;

	::lgLogDetail(
		LOG_X,
		7,
		TEXT("FILE: %s LINE:%d\n[WatchFaxExtendedEvents] Entry"),
		TEXT(__FILE__),
		__LINE__
		);

	//Check that we can set *pdwLastError
	if (NULL == pdwLastError)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pdwLastError == NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pdwLastError);
        goto ExitFunc;
	}
	(*pdwLastError) = ERROR_SUCCESS; //if all will be well *pdwLastError will remain so.

	//Check pFaxInfo is valid
	if (NULL == pFaxInfo)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxInfo parameter == NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxInfo);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//Check dwFaxId is valid
	if (0 == pFaxInfo->dwFaxId)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxInfo->dwFaxId == 0\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != pFaxInfo->dwFaxId);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
	}

	//
	//If Completion port is not initialized return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!hCompletionPort) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot hCompletionPort == NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != hCompletionPort);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If pFaxPortsConfig is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (!pFaxPortsConfig) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot pFaxPortsConfig == NULL (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(NULL != pFaxPortsConfig);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumFaxPorts is 0 return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot dwNumFaxPorts == 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	//If dwNumAvailFaxPorts is NULL return ERROR_INVALID_PARAM in *pdwLastError
	//
	if (0 == dwNumAvailFaxPorts) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\nGot dwNumAvailFaxPorts == 0 (ERROR_INVALID_PARAM returned)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		_ASSERTE(0 != dwNumAvailFaxPorts);
		(*pdwLastError) = ERROR_INVALID_PARAMETER;	
        goto ExitFunc;
    }

	//
	// Handle fax events on the completion port
	//
	BOOL fReturnValueOfGetQueuedCompletionStatus;
    while ( fReturnValueOfGetQueuedCompletionStatus =
			::GetQueuedCompletionStatus(
				hCompletionPort, 
				&dwBytes, 
				&pulCompletionKey, 
				(LPOVERLAPPED *) &pFaxEventEx, 
				MAX_COMP_PORT_WAIT_TIME) 
			) 
	{
		//check that pFaxEvent is legitimate
		//if not log and return FALSE and ERROR_INVALID_DATA
		if (FALSE == _CrtIsValidPointer((const void*) pFaxEventEx, sizeof(FAX_EVENT_EX), TRUE) )
		{
			(*pdwLastError) = ERROR_INVALID_DATA;
			::lgLogError(
				LOG_SEV_1, 
				TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\n_CrtIsValidPointer returned FALSE\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}

		//We are only interested in OUT_QUEUE events with a specific JobId.
		//Other events we simply log.
		switch (pFaxEventEx->EventType)
		{
			case FAX_EVENT_TYPE_IN_QUEUE:
			case FAX_EVENT_TYPE_CONFIG:
			case FAX_EVENT_TYPE_ACTIVITY:
			case FAX_EVENT_TYPE_QUEUE_STATE:
			case FAX_EVENT_TYPE_IN_ARCHIVE:
			case FAX_EVENT_TYPE_OUT_ARCHIVE:
				// this is not an event regarding our send job (so just log it)
				LogExtendedEvent(pFaxEventEx);
				goto ContinueWhile; 
				break;

			case FAX_EVENT_TYPE_OUT_QUEUE:
				EventJobInfo = (pFaxEventEx->EventInfo).JobInfo;
				if ( NULL == pFaxInfo->pdwlRecipientMessageIds )
				{
					// this is a regular (non-broadcast) fax
					if (EventJobInfo.dwlMessageId != pFaxInfo->dwlMessageId)
					{
						// this is not an event regarding our send job
						LogExtendedEvent(pFaxEventEx);
						goto ContinueWhile; 
					}
				}
				else
				{
					// this is a broadcast fax
					_ASSERTE(pFaxInfo->dwNumOfRecipients);
					fOneOfMyRecipientMsgIds = FALSE;
					for (dwLoopIndex = 0; dwLoopIndex < pFaxInfo->dwNumOfRecipients; dwLoopIndex++)
					{
						if (EventJobInfo.dwlMessageId == pFaxInfo->pdwlRecipientMessageIds[dwLoopIndex])
						{
							fOneOfMyRecipientMsgIds = TRUE;
						}
					}
					if (FALSE == fOneOfMyRecipientMsgIds)
					{
						// this is not an event regarding our send job
						LogExtendedEvent(pFaxEventEx);
						goto ContinueWhile; 
					}
				}
				// this is an event regarding our send job
				if (!HandleOutQueueExtendedEvent(
											pFaxEventEx,
											pFaxInfo,
											SendInfo,
											pdwLastError
											)
				   )
				{
					// failure
					goto ExitFunc;
				}
				if (TRUE == pFaxInfo->bComplete)
				{
					// completed successfully
					_ASSERTE(TRUE == pFaxInfo->bPass);
					goto ExitWhile;
				}
				break;

			default:
				::lgLogError(
					LOG_SEV_1, 
					TEXT("FILE:%s LINE:%d [WatchFaxExtendedEvents]\n- pFaxEventEx->EventType=0x%08X is out of enumaration scope\n"),
					TEXT(__FILE__),
					__LINE__,
					pFaxEventEx->EventType
					);
				_ASSERTE(FALSE);
				break;
		}

ContinueWhile:
        // Free the pFaxEvent packet
        FaxFreeBuffer(pFaxEventEx);
		pFaxEventEx = NULL;
    }

ExitWhile:
	//
	//Check if we left while because GetQueuedCompletionStatus failed
	//
	if (FALSE == fReturnValueOfGetQueuedCompletionStatus)
	{
		(*pdwLastError) = ::GetLastError();
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d GetQueuedCompletionStatus returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			(*pdwLastError)
			);
		goto ExitFunc;
	}

	// we only get here if all is ok
	_ASSERTE(TRUE == pFaxInfo->bPass);
	_ASSERTE(TRUE == pFaxInfo->bComplete);
	fReturnValue = TRUE; 

ExitFunc:
	//Free any "left over" pFaxEvent
	if (NULL != pFaxEventEx)
	{
        FaxFreeBuffer(pFaxEventEx);
		pFaxEventEx = NULL;
	}

    return fReturnValue;
}

#endif // #ifdef _NT5FAXTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\cometfax.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		CometFax.h
// Author:			Sigalit Bar (sigalitb)
// Date:			28-Jul-98
//


//
// Description:
//	Using the NT5.0 Fax Service API this module exports some
//	tailored Fax related actions.
//
//	This module exports the ability to:
//	* Send a fax and collect FAX_EVENT information relating
//    to the Fax Service job that is executing the send.
//	* Abort a fax.
//	* Initialize the Fax Service queue in a way that allows
//	  "monitoring" any FAX_EVENTs generated.
//
//
//	The module uses the elle logger wraper implemented
//	in LogElle.c to log any fax related errors. 
//	Therefor the logger must be initialized before 
//	calling any of its methods.
//



#ifndef _COMET_FAX_H_
#define _COMET_FAX_H_


#include <stdio.h>
#include <windows.h>
#include <assert.h>
#include <crtdbg.h>
#include <math.h>
#include <log.h>
#include "SendInfo.h"
#include "FaxBroadcast.h"

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST

typedef struct _FAX_INFO {
    DWORD		dwFaxId;				// Fax session job id
    DWORDLONG   dwlMessageId;			// Extended Fax msg id (parent msg id for broadcast)
	DWORDLONG*	pdwlRecipientMessageIds;// recipient msg ids (for broadcast)
	DWORD		dwNumOfRecipients;		// number of recipients (for broadcast)
	DWORD		dwNumOfCompletedRecipients;		// number of recipients that completed successfully (for broadcast)
    DWORD		dwDeviceId;				// Current device of the fax job
    BOOL		bComplete;				// Indicates the fax job is complete
    BOOL		bPass;					// Indicates the fax job was successful
} FAX_INFO, *PFAX_INFO;

//
// Maximum time to wait on completion ports for a packet.
//
#define MAX_COMP_PORT_WAIT_TIME (60*60*1000)

//
// InitFaxQueue:
//	Initializes the Fax Service queue so that it will post
//	all FAX_EVENTs to an I\O completion port.
//
// Arguments:
//	szMachineName		IN parameter
//						Specifies the name of the machine on which
//						the Fax Service is located.
//						To specify local machine, pass NULL.
//
//  hComPortHandle		OUT parameter
//						If the function returned TRUE then this
//						parameter holds the I\O completion port
//						handle.
//						If the function returned FALSE this 
//						parameter is NULL.
//
//  dwLastError			OUT parameter.
//						If the function returned TRUE then this
//						parameter is ERROR_SUCCESS (0).
//						If the function returned FALSE then this
//						parameter holds the last error.
//
// Return Value:
//	TRUE if successful otherwise FALSE.
//
// Note:
//	The function creates the completion port and it is
//	the caller's responsibility to close it.
//
BOOL InitFaxQueue(
	/* IN  */ LPCTSTR	szMachineName,
	/* OUT */ HANDLE&	hComPortHandle, 
	/* OUT */ DWORD&	dwLastError,
	/* OUT */ HANDLE&	hServerEvents
	);

BOOL
fnFaxPrint(
    HANDLE    /* IN */	hFaxSvcHandle,	//handle to the fax service
    LPCTSTR   /* IN */	szFaxNumber,	//fax number to call
    LPCTSTR   /* IN */	szDocumentName,	//name of document to fax
    LPCTSTR   /* IN */	szCPName,		//name of cover page to fax
    LPDWORD  /* OUT */	pdwFaxId,		//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,	//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlMessageId = NULL	//pointer to set to the fax msg id of the fax
);

//
// fnFaxPrintBroadcast_OLD	(using old NT5 Fax winfax.dll)
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_OLD(
    IN	HANDLE    	hFaxSvcHandle,	//handle to the fax service
    IN	LPCTSTR   	szDocumentName,	//name of document to fax
    IN	LPVOID    	pContext,		//pointer to a CFaxBroadcastObj 
    OUT	LPDWORD  	pdwFaxId,		//pointer to set to the fax job id of the fax
	OUT	LPDWORD	 	pdwLastError	//pointer to set to last error encountered during send
);

//
// fnFaxPrintBroadcast_NEW	(using new Bos Fax fxsapi.dll)
//	Sends a fax containing szDocumentName to number szFaxNumber,
//	using hFaxSvcHandle as the HANDLE to the Fax Server, and 
//	returns the JobId via pdwFaxId and the last error encountered 
//	via pdwLastError.
//	Returns TRUE on success (job queued to Fax Server Queue successfully)
//	and FALSE on failure.
//
BOOL
fnFaxPrintBroadcast_NEW(
    HANDLE    /* IN */	hFaxSvcHandle,					//handle to the fax service
    LPCTSTR   /* IN */	szDocumentName,					//name of document to fax
    LPVOID    /* IN */	pContext,						//pointer to a CFaxBroadcastObj 
    LPDWORD  /* OUT */	pdwFaxId,						//pointer to set to the fax job id of the fax
	LPDWORD	 /* OUT */	pdwLastError,					//pointer to set to last error encountered during send
    DWORDLONG*  /* OUT */	pdwlParentMessageId = NULL,	//pointer to set to the parent msg id of the fax
	DWORDLONG**	/* OUT */	ppdwlRecipientIds = NULL,	//pointer to an array of recipient ids (allocated by fnFaxPrintBroadcast)
	DWORD*		/* OUT */	pdwNumOfRecipients = NULL	//number of recipient ids in pdwlRecipientIds	
);

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)
#define fnFaxPrintBroadcast fnFaxPrintBroadcast_OLD
#else
// Testing Bos Fax (with new fxsapi.dll)
#define fnFaxPrintBroadcast fnFaxPrintBroadcast_NEW
#endif

//
// SendFax:
//	Sends a fax containing the document szDocumentName to fax number
//	szFaxNumber and collects all the FAX_EVENTs from hCompletionPort
//	into SendInfo. The fax job id is returned via pdwFaxId and the
//	last error encountered is returned via pdwLastError.
//
// IMPORTANT:
//	This is a SYNCHRONOUS send.
//	The function waits until the fax session has completed, accumulating
//	all the FAX_EVENTs generated by the send job into the OUT parameter
//	SendInfo.
//
// Parameters:
//	szFaxNumber			IN parameter.
//						A string representing the fax number to send the fax to.
//	szDocumentName		IN parameter.
//						A string containing the name of the document to fax.
//	szMachineName		IN parameter.
//						A string containing the name of the machine on which the
//						Fax Service is located.
//	hCompletionPort		IN parameter.
//						The I\O Completion port used by the Fax Service Queue to
//						post all FAX_EVENTs. This is the port we get the events from.
//	pContext			IN parameter.
//						If this parameter is NULL it is ignored.
//						IF it is not NULL then it must be a pointer to a CFaxBroadcastObj
//						which will be used to send a broadcast.
//	pdwFaxId			OUT parameter.
//						The JobId corresponding to the Fax Service send job that
//						was created (and queued) to handle the fax sending.
//	pdwlMessageId		OUT parameter.
//						The MessageId corresponding to the Fax Service send job that
//						was created (and queued) to handle the fax sending.
//	SendInfo			OUT parameter.
//						An instance of class CSendInfo in which all relevant 
//						FAX_EVENTs are stored.
//	pdwLastError		OUT parameter.
//						The last error we encountered while sending the desired fax.
//
// ReturnValue:
//	This function returnes TRUE if the fax sending was completed successfully. 
//	That includes -
//	1. The hCompletionPort parameter is a valid opened port returned from
//	   a call to InitFaxQueue().
//	2. pdwFaxId and pdwLastError are both not NULL.
//	3. The fax send job was successfully queued to the Fax Service Queue,
//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
//	   and that szFaxNumber is a valid telephone number.
//	4. The job was successfully executed by the Fax Service, that is the fax
//	   session took place and completed successfully.
//	Otherwise returns FALSE.
//
BOOL SendFax(
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocumentName,
	LPCTSTR		/* IN */	szCPName,
	LPCTSTR		/* IN */	szMachineName,
	HANDLE		/* IN */	hCompletionPort,
	LPVOID		/* IN */	pContext,		
	LPDWORD		/* OUT */	pdwFaxId,
    DWORDLONG*	/* OUT */	pdwlMessageId,
	CSendInfo&	/* OUT */	SendInfo,
	LPDWORD		/* OUT */	pdwLastError
	);

#ifdef _NT5FAXTEST
#define WatchFaxEvents WatchFaxLegacyEvents
//
// WatchFaxLegacyEvents:
//	collects all the FAX_EVENTs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxLegacyEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
	);
#else // ! _NT5FAXTEST
#define WatchFaxEvents WatchFaxExtendedEvents
///
//
// WatchFaxExtendedEvents:
//	collects all the FAX_EVENT_EXs of the job with pFaxInfo->dwFaxId 
//  from hCompletionPort.
//	last error encountered is returned via pdwLastError.
//
BOOL
WatchFaxExtendedEvents(
	HANDLE			/* IN */	hCompletionPort,
    PFAX_PORT_INFO	/* IN */	pFaxPortsConfig,
    DWORD			/* IN */	dwNumFaxPorts,
    DWORD			/* IN */	dwNumAvailFaxPorts,
	PFAX_INFO	/* IN OUT */	pFaxInfo,
	CSendInfo&	/* OUT */		SendInfo,
	LPDWORD		/* OUT */		pdwLastError
);
#endif // #ifdef _NT5FAXTEST

//
// AbortFax
//	Aborts the fax job with dwJobId on the local Fax Server,
//	and returns the last error encountered via pdwLastError.
//
// IMPORTANT:
//	This is an ASYNCHRONOUS abort.
//	It delivers the abort request to the local Fax Server 
//	and returns.
//
// Parameters:
//	szMachineName	IN parameter.
//					The machine on which the Fax Server is located.
//	dwJobId			IN parameter.
//					The JobId of the job to abort.
//	pdwLastError	OUT parameter.
//					Set to the last error encountered while  
//					requesting the abort from the server.
// Return Value:
//	TRUE if the abort request succeeded and pdwLastError is not NULL.
//	FALSE otherwise.
//
// Note:
//	This function is designed with the thought that since send()
//	is synchrouneos, only a separate thread (having knowledge
//	of the send JobId) will be able to perform a successful
//	abort() on it.
//	
// Another Note:
//	This function does not receive an OUT parameter of type
//	CSendInfo&, which means that it does not accumulate the
//	FAX_EVENTs caused by the request to abort.
//
BOOL AbortFax(
	LPCTSTR			/* IN */	szMachineName,
	const DWORD		/* IN */	dwJobId,
	LPDWORD			/* OUT */	pdwLastError
	);


#endif //_COMET_FAX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxbroadcast.cpp ===
//
//
// Filename:	FaxBroadcast.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		31-Dec-98
//
//


#include "FaxBroadcast.h"

//
// frees all string fields of pRecipientProfile 
//
static
VOID
FreeRecipientProfile(
    IN OUT PFAX_PERSONAL_PROFILE   pRecipientProfile 
)
{
    if (NULL == pRecipientProfile)
    {
        return;
    }
    free(pRecipientProfile->lptstrName);
    free(pRecipientProfile->lptstrFaxNumber);
    free(pRecipientProfile->lptstrCompany);
    free(pRecipientProfile->lptstrStreetAddress);
    free(pRecipientProfile->lptstrCity);
    free(pRecipientProfile->lptstrState);
    free(pRecipientProfile->lptstrZip);
    free(pRecipientProfile->lptstrCountry);
    free(pRecipientProfile->lptstrTitle);
    free(pRecipientProfile->lptstrDepartment);
    free(pRecipientProfile->lptstrOfficeLocation);
    free(pRecipientProfile->lptstrHomePhone);
    free(pRecipientProfile->lptstrOfficePhone);
    free(pRecipientProfile->lptstrEmail);
    free(pRecipientProfile->lptstrBillingCode);
    free(pRecipientProfile->lptstrTSID);
    // NULL pDstRecipientProfile
    ZeroMemory(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    // but set dwSizeOfStruct
    pRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

}

//
//
// Note: if one of the string allocations fails then
//       all previous allocations are freed
//       and pDstRecipientProfile is nulled.
//       
static
BOOL
CopyRecipientProfile(
    OUT PFAX_PERSONAL_PROFILE   pDstRecipientProfile, 
    IN  LPCFAX_PERSONAL_PROFILE pSrcRecipientProfile
)
{
    BOOL fRetVal = FALSE;

    _ASSERTE(pDstRecipientProfile);
    _ASSERTE(pSrcRecipientProfile);
    _ASSERTE(sizeof(FAX_PERSONAL_PROFILE) == pSrcRecipientProfile->dwSizeOfStruct);

    // dwSizeOfStruct
    pDstRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    // lptstrName
	if (NULL != pSrcRecipientProfile->lptstrName)
    {
	    pDstRecipientProfile->lptstrName = ::_tcsdup(pSrcRecipientProfile->lptstrName);
	    if (NULL == pDstRecipientProfile->lptstrName)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrFaxNumber
	if (NULL != pSrcRecipientProfile->lptstrFaxNumber)
    {
	    pDstRecipientProfile->lptstrFaxNumber = ::_tcsdup(pSrcRecipientProfile->lptstrFaxNumber);
	    if (NULL == pDstRecipientProfile->lptstrFaxNumber)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCompany
	if (NULL != pSrcRecipientProfile->lptstrCompany)
    {
	    pDstRecipientProfile->lptstrCompany = ::_tcsdup(pSrcRecipientProfile->lptstrCompany);
	    if (NULL == pDstRecipientProfile->lptstrCompany)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrStreetAddress
	if (NULL != pSrcRecipientProfile->lptstrStreetAddress)
    {
	    pDstRecipientProfile->lptstrStreetAddress = ::_tcsdup(pSrcRecipientProfile->lptstrStreetAddress);
	    if (NULL == pDstRecipientProfile->lptstrStreetAddress)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCity
	if (NULL != pSrcRecipientProfile->lptstrCity)
    {
	    pDstRecipientProfile->lptstrCity = ::_tcsdup(pSrcRecipientProfile->lptstrCity);
	    if (NULL == pDstRecipientProfile->lptstrCity)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrState
	if (NULL != pSrcRecipientProfile->lptstrState)
    {
	    pDstRecipientProfile->lptstrState = ::_tcsdup(pSrcRecipientProfile->lptstrState);
	    if (NULL == pDstRecipientProfile->lptstrState)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrZip
	if (NULL != pSrcRecipientProfile->lptstrZip)
    {
	    pDstRecipientProfile->lptstrZip = ::_tcsdup(pSrcRecipientProfile->lptstrZip);
	    if (NULL == pDstRecipientProfile->lptstrZip)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrCountry
	if (NULL != pSrcRecipientProfile->lptstrCountry)
    {
	    pDstRecipientProfile->lptstrCountry = ::_tcsdup(pSrcRecipientProfile->lptstrCountry);
	    if (NULL == pDstRecipientProfile->lptstrCountry)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrTitle
	if (NULL != pSrcRecipientProfile->lptstrTitle)
    {
	    pDstRecipientProfile->lptstrTitle = ::_tcsdup(pSrcRecipientProfile->lptstrTitle);
	    if (NULL == pDstRecipientProfile->lptstrTitle)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrDepartment
	if (NULL != pSrcRecipientProfile->lptstrDepartment)
    {
	    pDstRecipientProfile->lptstrDepartment = ::_tcsdup(pSrcRecipientProfile->lptstrDepartment);
	    if (NULL == pDstRecipientProfile->lptstrDepartment)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrOfficeLocation
	if (NULL != pSrcRecipientProfile->lptstrOfficeLocation)
    {
	    pDstRecipientProfile->lptstrOfficeLocation = ::_tcsdup(pSrcRecipientProfile->lptstrOfficeLocation);
	    if (NULL == pDstRecipientProfile->lptstrOfficeLocation)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrHomePhone
	if (NULL != pSrcRecipientProfile->lptstrHomePhone)
    {
	    pDstRecipientProfile->lptstrHomePhone = ::_tcsdup(pSrcRecipientProfile->lptstrHomePhone);
	    if (NULL == pDstRecipientProfile->lptstrHomePhone)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrOfficePhone
	if (NULL != pSrcRecipientProfile->lptstrOfficePhone)
    {
	    pDstRecipientProfile->lptstrOfficePhone = ::_tcsdup(pSrcRecipientProfile->lptstrOfficePhone);
	    if (NULL == pDstRecipientProfile->lptstrOfficePhone)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrEmail
	if (NULL != pSrcRecipientProfile->lptstrEmail)
    {
	    pDstRecipientProfile->lptstrEmail = ::_tcsdup(pSrcRecipientProfile->lptstrEmail);
	    if (NULL == pDstRecipientProfile->lptstrEmail)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrBillingCode
	if (NULL != pSrcRecipientProfile->lptstrBillingCode)
    {
	    pDstRecipientProfile->lptstrBillingCode = ::_tcsdup(pSrcRecipientProfile->lptstrBillingCode);
	    if (NULL == pDstRecipientProfile->lptstrBillingCode)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    // lptstrTSID
	if (NULL != pSrcRecipientProfile->lptstrTSID)
    {
	    pDstRecipientProfile->lptstrTSID = ::_tcsdup(pSrcRecipientProfile->lptstrTSID);
	    if (NULL == pDstRecipientProfile->lptstrTSID)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    GetLastError()
			    );
		    goto ExitFunc;
	    }
    }

    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        FreeRecipientProfile(pDstRecipientProfile);
    }
    return(fRetVal);
}

//
// CFaxBroadcast:
//
CFaxBroadcast::CFaxBroadcast(void):
	m_szCPFileName(NULL)
{
}

//
// ~CFaxBroadcast:
//
CFaxBroadcast::~CFaxBroadcast(void)
{

	//
	// remove (and free) all items from vector
	//
	FreeAllRecipients();
}


//
// AddRecipient:
//	Adds a recipient's profile to the broadcast.
//
// Note:
//	pRecipientProfile and all its fields are duplicated by AddRecipient.
//
BOOL CFaxBroadcast::AddRecipient(LPCFAX_PERSONAL_PROFILE /* IN */ pRecipientProfile)
{
    BOOL                    fRetVal = FALSE;
    PFAX_PERSONAL_PROFILE   pNewRecipientProfile = NULL;

    _ASSERTE(pRecipientProfile);
    _ASSERTE(sizeof(FAX_PERSONAL_PROFILE) == pRecipientProfile->dwSizeOfStruct);

    //
    // allocate the new profile
    //
    pNewRecipientProfile = (PFAX_PERSONAL_PROFILE)malloc(sizeof(FAX_PERSONAL_PROFILE));
    if (NULL == pNewRecipientProfile)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(pNewRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    pNewRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    //
    // duplicate all string fields
    //
    if (!CopyRecipientProfile(pNewRecipientProfile, pRecipientProfile))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CopyRecipientProfile failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }

    //
    // Log if lptstrFaxNumber is NULL
    //
	if (NULL == pNewRecipientProfile->lptstrFaxNumber)
	{
		// we allow to add a NULL recipient number (for testing fax service)
		::lgLogDetail(
			LOG_X, 
			2,
			TEXT("FILE:%s LINE:%d pSrcRecipientProfile->lptstrFaxNumber is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
	}

	//
	// add the new profile pointer at end of recipient list
	//
	m_FaxRecipientVector.push_back(pNewRecipientProfile);
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(pNewRecipientProfile);
    }
    return(fRetVal);
}
	
//
// ClearAllRecipients:
//	Removes all the recipient number strings from instance.
//	=> empties vector.
//
void CFaxBroadcast::ClearAllRecipients(void)
{
	m_FaxRecipientVector.clear();
}

//
// FreeAllRecipients:
//
void CFaxBroadcast::FreeAllRecipients(void)
{
	PFAX_PERSONAL_PROFILE pRecipientProfile = NULL;
	UINT uSize = m_FaxRecipientVector.size();
	UINT uIndex = 0;

	//
	//free strings in vector
	//
	for (uIndex = 0; uIndex < uSize; uIndex++)
	{
		pRecipientProfile = (PFAX_PERSONAL_PROFILE)m_FaxRecipientVector[uIndex];
        if(pRecipientProfile)
        {
            free(pRecipientProfile->lptstrName);
            free(pRecipientProfile->lptstrFaxNumber);
            free(pRecipientProfile->lptstrCompany);
            free(pRecipientProfile->lptstrStreetAddress);
            free(pRecipientProfile->lptstrCity);
            free(pRecipientProfile->lptstrState);
            free(pRecipientProfile->lptstrZip);
            free(pRecipientProfile->lptstrCountry);
            free(pRecipientProfile->lptstrTitle);
            free(pRecipientProfile->lptstrDepartment);
            free(pRecipientProfile->lptstrOfficeLocation);
            free(pRecipientProfile->lptstrHomePhone);
            free(pRecipientProfile->lptstrOfficePhone);
            free(pRecipientProfile->lptstrEmail);
            free(pRecipientProfile->lptstrBillingCode);
            free(pRecipientProfile->lptstrTSID);
            free(pRecipientProfile);
        }
		m_FaxRecipientVector[uIndex] = NULL;
	}

	//
	//empty vector
	//
	ClearAllRecipients();
}

//
// GetNumberOfRecipients:
//	Returns the number of recipients in the broadcast.
//
DWORD CFaxBroadcast::GetNumberOfRecipients(void) const
{
	return(m_FaxRecipientVector.size());
}

//
// SetCPFileName:
//	Sets the Cover Page file that will be used for the broadcast.
//
// NOTE: function has its own copy of szCPFileName,
//		 that is, it duplicates the IN param string.
BOOL CFaxBroadcast::SetCPFileName(
	LPCTSTR	/* IN */	szCPFileName
)
{
	LPTSTR szTmpCPFilename = NULL;

	if (NULL == szCPFileName)
	{
		goto ExitFunc;
	}

	//duplicate the IN param
	szTmpCPFilename = ::_tcsdup(szCPFileName);
	if (NULL == szTmpCPFilename)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

ExitFunc:
	// free previous CP filename string
	delete(m_szCPFileName);
	// set new CP filename
	m_szCPFileName = szTmpCPFilename;

	return(TRUE);
}

//
// GetCPFileName:
//	Retreives the Cover Page filename.
//
// NOTE: pszCPFileName points to a copy of m_szCPFileName
//		 Function allocates memory for OUT param, caller must free.
//
BOOL CFaxBroadcast::GetCPFileName(
	LPTSTR*	/* OUT */	pszCPFileName
) const
{
	LPTSTR szTmpCPFilename = NULL;

	//
	// check OUT param
	//
	if (NULL == pszCPFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d OUT param pszCPFileName is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	if(NULL == m_szCPFileName)
	{
		goto ExitFunc;
	}

	//
	// copy m_szCPFileName
	//
	szTmpCPFilename = ::_tcsdup(m_szCPFileName);
	if (NULL == szTmpCPFilename)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

ExitFunc:

	// set OUT param
	(*pszCPFileName) = szTmpCPFilename;

	return(TRUE);
}

//
// GetRecipient:
//	Retreives the number (as string) of a recipient in the broadcast.
//	
// NOTE: dwRecipientIndex is 1 based and the vector is 0 based.
//		 pszRecipientNumber is a copy of the requested recipient's number string.
//		 Function allocates memory for OUT param, caller must free.
//
BOOL CFaxBroadcast::GetRecipient(
	DWORD	                /* IN */	dwRecipientIndex,
	PFAX_PERSONAL_PROFILE*	/* OUT */	ppRecipientProfile
) const
{
    BOOL fRetVal = FALSE;
	PFAX_PERSONAL_PROFILE pTmpRecipientProfile = NULL;
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

	//
	// check OUT param
	//
	if (NULL == ppRecipientProfile)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d OUT param pszRecipientNumber is NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
        _ASSERTE(ppRecipientProfile);
		return(FALSE);
	}

	UINT uSize = m_FaxRecipientVector.size();
	//NOTE: dwRecipientIndex is 1 based.
	if (dwRecipientIndex > uSize)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d dwRecipientIndex (%d) > uSize (%d)\n"),
			TEXT(__FILE__),
			__LINE__,
			dwRecipientIndex,
			uSize
			);
		return(FALSE);
	}

	//NOTE: dwIndex and vector are 0 based.
	DWORD dwIndex = (dwRecipientIndex - 1);

	pRecipientProfile = m_FaxRecipientVector.at(dwIndex); // at returns the pointer
	if (NULL == pRecipientProfile)
	{
		::lgLogDetail(
			LOG_X, 
			2,
			TEXT("FILE:%s LINE:%d m_FaxRecipientVector.at(%d) returned NULL\n"),
			TEXT(__FILE__),
			__LINE__,
			dwRecipientIndex
			);
        (*ppRecipientProfile) = NULL;
		return(TRUE);
	}

    //
    // allocate the new profile
    //
    pTmpRecipientProfile = (PFAX_PERSONAL_PROFILE)malloc(sizeof(FAX_PERSONAL_PROFILE));
    if (NULL == pTmpRecipientProfile)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
        goto ExitFunc;
    }
    ZeroMemory(pTmpRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));
    pTmpRecipientProfile->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    //
    // duplicate all string fields
    //
    if (!CopyRecipientProfile(pTmpRecipientProfile, pRecipientProfile))
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d CopyRecipientProfile failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }

    (*ppRecipientProfile) = pTmpRecipientProfile;
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        free(pTmpRecipientProfile);
    }
	return(fRetVal);
}

/*
//
// operator<<:
//	Appends a string representation of all the fields of a given CFaxBroadcast
//	instance.
//
CostrstreamEx& operator<<(
	IN OUT CostrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os<<"No Recipients"<<endl;
		return(os);
	}

	os<<endl;
	LPCSTR str = NULL;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		str = NULL;
		os << "Recipient#"<<(index+1)<<": "<<endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
		if (NULL == pRecipientProfile)
		{
			os<<"pRecipientProfile = <NULL>"<<endl;
            continue;
		}

        //
        // add all profile strings to stream
        //

        //lptstrName
		str = ::DupTStrAsStr(pRecipientProfile->lptstrName);
        os<<"lptstrName = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrFaxNumber
		str = ::DupTStrAsStr(pRecipientProfile->lptstrFaxNumber);
        os<<"lptstrFaxNumber = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);

        //lptstrCompany
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCompany);
        os<<"lptstrCompany = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrStreetAddress
		str = ::DupTStrAsStr(pRecipientProfile->lptstrStreetAddress);
        os<<"lptstrStreetAddress = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrCity
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCity);
        os<<"lptstrCity = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrState
		str = ::DupTStrAsStr(pRecipientProfile->lptstrState);
        os<<"lptstrState = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrZip
		str = ::DupTStrAsStr(pRecipientProfile->lptstrZip);
        os<<"lptstrZip = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrCountry
		str = ::DupTStrAsStr(pRecipientProfile->lptstrCountry);
        os<<"lptstrCountry = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrTitle
		str = ::DupTStrAsStr(pRecipientProfile->lptstrTitle);
        os<<"lptstrTitle = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrDepartment
		str = ::DupTStrAsStr(pRecipientProfile->lptstrDepartment);
        os<<"lptstrDepartment = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOfficeLocation
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOfficeLocation);
        os<<"lptstrOfficeLocation = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrHomePhone
		str = ::DupTStrAsStr(pRecipientProfile->lptstrHomePhone);
        os<<"lptstrHomePhone = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOfficePhone
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOfficePhone);
        os<<"lptstrOfficePhone = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrOrganizationalMail
		str = ::DupTStrAsStr(pRecipientProfile->lptstrOrganizationalMail);
        os<<"lptstrOrganizationalMail = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrInternetMail
		str = ::DupTStrAsStr(pRecipientProfile->lptstrInternetMail);
        os<<"lptstrInternetMail = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrBillingCode
		str = ::DupTStrAsStr(pRecipientProfile->lptstrBillingCode);
        os<<"lptstrBillingCode = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);
        //lptstrTSID
		str = ::DupTStrAsStr(pRecipientProfile->lptstrTSID);
        os<<"lptstrTSID = ";
		if (NULL == str)
		{
			os<<"<NULL>"<<endl;
		}
		else
		{
			os << str <<endl; //append string to stream
		}
		delete[]((LPTSTR)str);

	}

	return(os);
}
*/

//
// operator<<:
//	Appends a string representation of all the fields of a given CFaxBroadcast
//	instance.
//
CostrstreamEx& operator<<(
	CostrstreamEx&			        /* IN OUT */	os, 
	const FAX_PERSONAL_PROFILE&	    /* IN */		RecipientProfile
)
{

    os<<endl;
	LPCSTR str = NULL;

    //
    // add all profile strings to stream
    //

    //lptstrName
	str = ::DupTStrAsStr(RecipientProfile.lptstrName);
    os<<TEXT("\tlptstrName = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrFaxNumber
	str = ::DupTStrAsStr(RecipientProfile.lptstrFaxNumber);
    os<<TEXT("\tlptstrFaxNumber = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);

    //lptstrCompany
	str = ::DupTStrAsStr(RecipientProfile.lptstrCompany);
    os<<TEXT("\tlptstrCompany = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrStreetAddress
	str = ::DupTStrAsStr(RecipientProfile.lptstrStreetAddress);
    os<<TEXT("\tlptstrStreetAddress = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrCity
	str = ::DupTStrAsStr(RecipientProfile.lptstrCity);
    os<<TEXT("\tlptstrCity = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrState
	str = ::DupTStrAsStr(RecipientProfile.lptstrState);
    os<<TEXT("\tlptstrState = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrZip
	str = ::DupTStrAsStr(RecipientProfile.lptstrZip);
    os<<TEXT("\tlptstrZip = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrCountry
	str = ::DupTStrAsStr(RecipientProfile.lptstrCountry);
    os<<TEXT("\tlptstrCountry = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrTitle
	str = ::DupTStrAsStr(RecipientProfile.lptstrTitle);
    os<<TEXT("\tlptstrTitle = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrDepartment
	str = ::DupTStrAsStr(RecipientProfile.lptstrDepartment);
    os<<TEXT("\tlptstrDepartment = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrOfficeLocation
	str = ::DupTStrAsStr(RecipientProfile.lptstrOfficeLocation);
    os<<TEXT("\tlptstrOfficeLocation = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrHomePhone
	str = ::DupTStrAsStr(RecipientProfile.lptstrHomePhone);
    os<<TEXT("\tlptstrHomePhone = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrOfficePhone
	str = ::DupTStrAsStr(RecipientProfile.lptstrOfficePhone);
    os<<TEXT("\tlptstrOfficePhone = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrEmail
	str = ::DupTStrAsStr(RecipientProfile.lptstrEmail);
    os<<TEXT("\tlptstrEmail = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrBillingCode
	str = ::DupTStrAsStr(RecipientProfile.lptstrBillingCode);
    os<<TEXT("\tlptstrBillingCode = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);
    //lptstrTSID
	str = ::DupTStrAsStr(RecipientProfile.lptstrTSID);
    os<<TEXT("\tlptstrTSID = ");
	if (NULL == str)
	{
		os<<TEXT("<NULL>")<<endl;
	}
	else
	{
		os << str <<endl; //append string to stream
	}
	delete[]((LPTSTR)str);

	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_PERSONAL_PROFILE
//	instance.
//
CotstrstreamEx& operator<<(
	CotstrstreamEx&			        /* IN OUT */	os, 
	const FAX_PERSONAL_PROFILE&	    /* IN */		RecipientProfile
)
{

    os << endl;

    //
    // add all profile strings to stream
    //

    //lptstrName
    os << TEXT("\tlptstrName = ");
	if (NULL == RecipientProfile.lptstrName)
	{
		os<< TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrName << endl; //append string to stream
	}

    //lptstrFaxNumber
    os << TEXT("\tlptstrFaxNumber = ");
	if (NULL == RecipientProfile.lptstrFaxNumber)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrFaxNumber <<endl; //append string to stream
	}

    //lptstrCompany
    os << TEXT("\tlptstrCompany = ");
	if (NULL == RecipientProfile.lptstrCompany)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCompany <<endl; //append string to stream
	}

    //lptstrStreetAddress
    os << TEXT("\tlptstrStreetAddress = ");
	if (NULL == RecipientProfile.lptstrStreetAddress)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrStreetAddress << endl; //append string to stream
	}

    //lptstrCity
    os << TEXT("\tlptstrCity = ");
	if (NULL == RecipientProfile.lptstrCity)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCity << endl; //append string to stream
	}

    //lptstrState
    os << TEXT("\tlptstrState = ");
	if (NULL == RecipientProfile.lptstrState)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrState << endl; //append string to stream
	}

    //lptstrZip
    os << TEXT("\tlptstrZip = ");
	if (NULL == RecipientProfile.lptstrZip)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrZip << endl; //append string to stream
	}

    //lptstrCountry
    os << TEXT("\tlptstrCountry = ");
	if (NULL == RecipientProfile.lptstrCountry)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrCountry << endl; //append string to stream
	}

    //lptstrTitle
    os << TEXT("\tlptstrTitle = ");
	if (NULL == RecipientProfile.lptstrTitle)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrTitle << endl; //append string to stream
	}

    //lptstrDepartment
    os << TEXT("\tlptstrDepartment = ");
	if (NULL == RecipientProfile.lptstrDepartment)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrDepartment << endl; //append string to stream
	}

    //lptstrOfficeLocation
    os << TEXT("\tlptstrOfficeLocation = ");
	if (NULL == RecipientProfile.lptstrOfficeLocation)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrOfficeLocation << endl; //append string to stream
	}

    //lptstrHomePhone
    os << TEXT("\tlptstrHomePhone = ");
	if (NULL == RecipientProfile.lptstrHomePhone)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrHomePhone << endl; //append string to stream
	}

    //lptstrOfficePhone
    os << TEXT("\tlptstrOfficePhone = ");
	if (NULL == RecipientProfile.lptstrOfficePhone)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrOfficePhone << endl; //append string to stream
	}

    //lptstrEmail
    os << TEXT("\tlptstrEmail = ");
	if (NULL == RecipientProfile.lptstrEmail)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrEmail << endl; //append string to stream
	}

    //lptstrBillingCode
    os << TEXT("\tlptstrBillingCode = ");
	if (NULL == RecipientProfile.lptstrBillingCode)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrBillingCode << endl; //append string to stream
	}

    //lptstrTSID
    os << TEXT("\tlptstrTSID = ");
	if (NULL == RecipientProfile.lptstrTSID)
	{
		os << TEXT("<NULL>") << endl;
	}
	else
	{
		os << RecipientProfile.lptstrTSID << endl; //append string to stream
	}

	return(os);
}



CostrstreamEx& operator<<(
	IN OUT CostrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os<<TEXT("No Recipients")<<endl;
		return(os);
	}

	os<<endl;
	LPCSTR str = NULL;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		str = NULL;
		os << TEXT("Recipient#")<<(index+1)<<TEXT(": ")<<endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os<<TEXT("pRecipientProfile = <NULL>")<<endl;
            continue;
	    }

        os << pRecipientProfile << endl;
    }
    return(os);
}

CotstrstreamEx& operator<<(
	IN OUT CotstrstreamEx&		os, 
	IN const CFaxBroadcast&	    FaxBroadcastObj
)
{
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == FaxBroadcastObj.m_FaxRecipientVector.size())
	{
		os << TEXT("No Recipients") << endl;
		return(os);
	}

	os<<endl;
	UINT uSize = FaxBroadcastObj.m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
		os << TEXT("Recipient#") << (index+1) << TEXT(": ") <<  endl; //append recipient index number
        pRecipientProfile = FaxBroadcastObj.m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os << TEXT("pRecipientProfile = <NULL>") << endl;
            continue;
	    }

        os << pRecipientProfile << endl;
    }
    return(os);
}


//
// outputAllToLog:
//	Outputs a description of all the recipients in the instance's
//	recipient list to the logger in use.
//
void CFaxBroadcast::outputAllToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
) const
{
	LPCTSTR szLogStr = NULL;	
	LPCFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

    if (0 == m_FaxRecipientVector.size())
	{
	    ::lgLogDetail(dwSeverity,dwLevel,TEXT("No Recipients\n"));
        return;
	}

	LPCSTR str = NULL;
	UINT uSize = m_FaxRecipientVector.size();
	int index = 0;
	for (index = 0; index < uSize; index++) 
	{
    	CotstrstreamEx os;
		str = NULL;
		os <<endl<<TEXT("Recipient#")<<(index+1)<<TEXT(": ")<<endl; //append recipient index number
        pRecipientProfile = m_FaxRecipientVector.at(index);
	    if (NULL == pRecipientProfile)
	    {
		    os<<TEXT("pRecipientProfile = <NULL>")<<endl;
	    }
        else
        {
            os << (*pRecipientProfile);
        }
	    //CotstrstreamEx::cstr() returns copy of stream buffer
	    //it allocates string, caller should free.		
	    szLogStr = os.cstr();
        _ASSERTE(szLogStr);
							    
	    ::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log recipient list string
	    delete[]((LPTSTR)szLogStr); //free string (allocated by CotstrstreamEx::cstr())
    }

}


#ifndef _NT5FAXTEST
// For Ronen's FaxSendDocumetEx changes:
//    "replace" DefaultFaxRecipientCallback with
//    CFaxBroadcast::GetBroadcastParams(
//                          OUT	LPFAX_COVERPAGE_INFO_EXW* lpcCoverPageInfo,
//	                        OUT	LPFAX_PERSONAL_PROFILEW*  lpcSenderProfile,
//	                        OUT	LPDWORD dwNumRecipients,
//   	                    OUT	LPFAX_PERSONAL_PROFILEW*	lpcRecipientList
//                          )
//    It will alloc and set OUT params, since caller doesn't know num of recipients

BOOL CFaxBroadcast::GetBroadcastParams(
    PFAX_COVERPAGE_INFO_EX*     /* OUT */	ppCoverPageInfo,
    PDWORD                      /* OUT */	pdwNumRecipients,
    PFAX_PERSONAL_PROFILE*	    /* OUT */	ppRecipientList
    ) const
{
    BOOL fRetVal = FALSE;

    PFAX_COVERPAGE_INFO_EX    pTmpCoverPageInfo = NULL;
    DWORD                     dwTmpNumRecipients = 0;
    PFAX_PERSONAL_PROFILE     pTmpRecipientList = NULL;
    LPCFAX_PERSONAL_PROFILE   pRecipientProfile = NULL;
    DWORD                     dwLoopIndex = 0;

    //
    // check OUT params are valid
    //
    if (NULL == ppCoverPageInfo)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == ppCoverPageInfo\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }
    if (NULL == pdwNumRecipients)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == pdwNumRecipients\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }
    if (NULL == ppRecipientList)
    {
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\nGetBroadcastParams got NULL == ppRecipientList\n"),
			TEXT(__FILE__),
			__LINE__
			);
        goto ExitFunc;
    }


    //
    // Cover Page 
    //

    // if m_szCPFileName != NULL we alloc and set pTmpCoverPageInfo,
    // else we leave pTmpCoverPageInfo = NULL
    if (NULL != m_szCPFileName)
    {
        // alloc pTmpCoverPageInfo
        pTmpCoverPageInfo = (PFAX_COVERPAGE_INFO_EX) malloc (sizeof(FAX_COVERPAGE_INFO_EX));
	    if (NULL == pTmpCoverPageInfo)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%08X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                ::GetLastError()
			    );
		    goto ExitFunc;
	    }
        ZeroMemory(pTmpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));

        // set pTmpCoverPageInfo
        pTmpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
	    pTmpCoverPageInfo->bServerBased = FALSE; 
	    pTmpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV; 
	    pTmpCoverPageInfo->lptstrCoverPageFileName = ::_tcsdup(m_szCPFileName);
	    if (NULL == pTmpCoverPageInfo->lptstrCoverPageFileName)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\n_tcsdup returned NULL\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
		    goto ExitFunc;
	    }
	    pTmpCoverPageInfo->lptstrNote = TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4");
	    pTmpCoverPageInfo->lptstrSubject = TEXT("SUBJECT");
    } // of if (NULL != m_szCPFileName)


    //
    // Number Of Recipients
    //

    dwTmpNumRecipients = m_FaxRecipientVector.size();


    //
    // Recipient Profile List
    //

    if (0 == dwTmpNumRecipients)
    {
        // we allow this so that we could test FaxSendDocumentEx's response
        // but there is no need to alloc pTmpRecipientList
		::lgLogDetail(
			LOG_X,
            1, 
			TEXT("FILE:%s LINE:%d\ncalled GetBroadcastParams() on a CFaxBroadcast object with ZERO recipients\n"),
			TEXT(__FILE__),
			__LINE__
			);
    }
    else
    {
        // alloc pTmpRecipientList
        pTmpRecipientList = (PFAX_PERSONAL_PROFILE) malloc (dwTmpNumRecipients*sizeof(FAX_PERSONAL_PROFILE));
	    if (NULL == pTmpRecipientList)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nmalloc failed with err=0x%08X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                ::GetLastError()
			    );
		    goto ExitFunc;
	    }
        ZeroMemory(pTmpRecipientList, dwTmpNumRecipients*sizeof(FAX_PERSONAL_PROFILE));
    }

    //
    // set pTmpRecipientList members
    //
    // NOTE: if (0 == dwTmpNumRecipients) then we don't go into loop
    for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; dwLoopIndex++)
    {
    	pRecipientProfile = m_FaxRecipientVector.at(dwLoopIndex); // at returns the pointer
	    if (NULL == pRecipientProfile)
	    {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nInternal Error - m_FaxRecipientVector.at(%d) returned NULL\n"),
			    TEXT(__FILE__),
			    __LINE__,
			    dwLoopIndex
			    );
            _ASSERTE(pRecipientProfile);
		    goto ExitFunc;
	    }

        // set the recipient's profile
        if (!CopyRecipientProfile(&pTmpRecipientList[dwLoopIndex], pRecipientProfile))
        {
		    ::lgLogError(
			    LOG_SEV_1, 
			    TEXT("FILE:%s LINE:%d\nCopyRecipientProfile failed\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
            goto ExitFunc;
        }
    } // of for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; iLoopIndex++)


    //
    // set OUT params
    //
    (*ppCoverPageInfo) = pTmpCoverPageInfo;
    (*pdwNumRecipients) = dwTmpNumRecipients;
    (*ppRecipientList) = pTmpRecipientList;
        
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        // free all Tmp allocs
	    if (pTmpCoverPageInfo)
        {
            free(pTmpCoverPageInfo->lptstrCoverPageFileName);
            free(pTmpCoverPageInfo);
        }
        if (pTmpRecipientList)
        {
            for (dwLoopIndex = 0; dwLoopIndex < dwTmpNumRecipients; dwLoopIndex++)
            {
                FreeRecipientProfile(&pTmpRecipientList[dwLoopIndex]);
            }
            free(pTmpRecipientList);
        }
    }
    return(fRetVal);
}
#endif // #ifndef _NT5FAXTEST

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)

//
// DefaultFaxRecipientCallback:
//	A default implementation of the required FAX_RECIPIENT_CALLBACK.
//  This function is used by CFaxSender::send_broadcast(), to send a broadcast
//  fax. 
//  That is, CFaxSender::send_broadcast() will invoke FaxSendDocumentForBroadcast
//	giving it a CFaxBroadcast instance as its Context parameter and the
//	exported DefaultFaxRecipientCallback function as its final parameter.
//  The FaxSendDocumentForBroadcast function calls this callback function to 
//  retrieve user-specific information for the transmission. 
//  FaxSendDocumentForBroadcast calls FAX_RECIPIENT_CALLBACK multiple times, 
//  once for each designated fax recipient, passing it the Context parameter.
//
// NOTE: dwRecipientNumber is 1 based.
//
// Return Value:
//	The function returns TRUE to indicate that the FaxSendDocumentForBroadcast function 
//	should queue an outbound fax transmission, using the data pointed to by the 
//	JobParams and CoverpageInfo parameters. 
//	The function returns FALSE to indicate that there are no more fax transmission jobs 
//	to queue, and calls to FAX_RECIPIENT_CALLBACK should be terminated. 
//
BOOL CALLBACK DefaultFaxRecipientCallback(
	HANDLE					/* IN */	hFaxHandle,
	DWORD					/* IN */	dwRecipientNumber,
	LPVOID					/* IN */	pContext,
	PFAX_JOB_PARAM			/* IN OUT */	JobParams,
	PFAX_COVERPAGE_INFO		/* IN OUT */	CoverpageInfo 
)
{
	BOOL fRetVal = FALSE;
	LPTSTR szCPFileName = NULL;
	LPTSTR szCPNote = NULL;
	LPTSTR szCPSubject = NULL;
	LPTSTR szRecipientNumber = NULL;
	PFAX_PERSONAL_PROFILE pRecipientProfile = NULL;

	_ASSERTE(NULL != pContext);
	// cast the pContext param to CFaxBroadcast
	CFaxBroadcast* thisFaxBroadcastObj = (CFaxBroadcast*)pContext;

	// return FALSE to indicate no more recipients
	if (dwRecipientNumber > thisFaxBroadcastObj->GetNumberOfRecipients())
	{
		goto ExitFunc;
	}

	// get a copy of the RecipientProfile from list
	if (FALSE == thisFaxBroadcastObj->GetRecipient(dwRecipientNumber,&pRecipientProfile))
	{
		goto ExitFunc;
	}
	_ASSERTE(pRecipientProfile);
	_ASSERTE(pRecipientProfile->lptstrFaxNumber);

	// copy number string of recipient dwRecipientNumber from profile
	szRecipientNumber = ::_tcsdup(pRecipientProfile->lptstrFaxNumber);
	if (NULL == szRecipientNumber)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// get a copy of the Cover Page filename
	if (FALSE == thisFaxBroadcastObj->GetCPFileName(&szCPFileName))
	{
		goto ExitFunc;
	}

	// set the Note field of the Cover Page
	szCPNote = ::_tcsdup(TEXT("NOTE1\nNOTE2\nNOTE3\nNOTE4"));
	if (NULL == szCPNote)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// set the Subject field of the Cover Page
	szCPSubject = ::_tcsdup(TEXT("SUBJECT"));
	if (NULL == szCPSubject)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d\n_tcsdup failed with ec=0x%08X\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
	}

	// set OUT params
    JobParams->RecipientNumber = szRecipientNumber;
	CoverpageInfo->CoverPageName = szCPFileName;
	CoverpageInfo->Note = szCPNote;
	CoverpageInfo->Subject = szCPSubject;
	fRetVal = TRUE;

ExitFunc:
	FreeRecipientProfile(pRecipientProfile);
	if (FALSE == fRetVal)
	{
		// function failed so free all allocations
		::free(szRecipientNumber);
		::free(szCPFileName);
		::free(szCPNote);
		::free(szCPSubject);
	}

	return(fRetVal);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxcompport.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxCompPort.h
// Author:		Sigalit Bar (sigalitb)
// Date:		16-Aug-98
//

//
// Description:
//		This file contains the description of 
//		class CFaxCompletionPort which is designed 
//		to represent the I\O Completion Port used
//		by the NT5.0 Fax Service Queue.
//
//		The class calls the NT5.0 Fax Service API
//		FaxInitializeEventQueue() with the local
//		server and a completion port, thus causing
//		the server to post every FAX_EVENT that is
//		generated to the completion port.
//		To examine the FAX_EVENTs posted use
//		GetQueuedCompletionStatus with the port HANDLE
//		returned from CFaxCompletionPort::GetCompletionPortHandle()
//

#ifndef _FAX_COMP_PORT_H_
#define _FAX_COMP_PORT_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>
#include "streamEx.h"
#include "CometFax.h"



class CFaxCompletionPort
{
public:
	CFaxCompletionPort();
	~CFaxCompletionPort(void);


	//
	// GetCompletionPortHandle:
	//	Creates an I\O completion port and "connects" it
	//	to the local NT5.0 Fax Server.
	//
	// Arguments:
	//	szMachineName		IN parameter.
	//						The machine on which the Fax Server is located.
	//
	//  hComPortHandle		OUT parameter
	//						If the function returned TRUE then this
	//						parameter holds the I\O completion port
	//						handle.
	//						If the function returned FALSE this 
	//						parameter is NULL.
	//
	//  dwLastError			OUT parameter.
	//						If the function returned TRUE then this
	//						parameter is ERROR_SUCCESS (0).
	//						If the function returned FALSE then this
	//						parameter holds the last error.
	//
	// Return Value:
	//	TRUE if successful otherwise FALSE.
	//
	// Note:
	//	Only one I\O completion port can be "connected" to
	//	the Fax Server Queue (due to a limitation of the
	//	API FaxInitializeEventQueue), so the first time this
	//	function is called, a completion port is created and
	//	FaxInitializedEventQueue is called. The created port 
	//	is stored in the private member m_hCompletionPort.
	//	Subsequent calls to this function return m_hCompletionPort.
	//
	BOOL GetCompletionPortHandle(
			LPCTSTR		/* IN */	szMachineName,
			HANDLE&		/* OUT */	hComPortHandle, 
			DWORD&		/* OUT */	dwLastError
			);

private:

	//The I\O Completion Port "connected" to the Fax Server Queue.
	HANDLE	m_hCompletionPort;
	HANDLE	m_hServerEvents;

};


#endif //_FAX_COMP_PORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxevent.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEvent.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		23-Jul-98
//


//
// Description:
//		This file contains the implementation of module "FaxEvent.h".
//


#include "FaxEvent.h"

//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
CostrstreamEx& AppendEventIdStrToOs(CostrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId)
{
	switch(EventId)
	{
	case FEI_DIALING:
		os<<TEXT("FEI_DIALING (");
		break;

	case FEI_SENDING:
		os<<TEXT("FEI_SENDING (");
		break;

	case FEI_RECEIVING:
		os<<TEXT("FEI_RECEIVING (");
		break;

	case FEI_COMPLETED:
		os<<TEXT("FEI_COMPLETED (");
		break;

	case FEI_BUSY:
		os<<TEXT("FEI_BUSY (");
		break;

	case FEI_NO_ANSWER:
		os<<TEXT("FEI_NO_ANSWER (");
		break;

	case FEI_BAD_ADDRESS:
		os<<TEXT("FEI_BAD_ADDRESS (");
		break;

	case FEI_NO_DIAL_TONE:
		os<<TEXT("FEI_NO_DIAL_TONE (");
		break;

	case FEI_DISCONNECTED:
		os<<TEXT("FEI_DISCONNECTED (");
		break;

	case FEI_FATAL_ERROR:
		os<<TEXT("FEI_FATAL_ERROR (");
		break;

	case FEI_NOT_FAX_CALL:
		os<<TEXT("FEI_NOT_FAX_CALL (");
		break;

	case FEI_CALL_DELAYED:
		os<<TEXT("FEI_CALL_DELAYED (");
		break;

	case FEI_CALL_BLACKLISTED:
		os<<TEXT("FEI_CALL_BLACKLISTED (");
		break;

	case FEI_RINGING:
		os<<TEXT("FEI_RINGING (");
		break;

	case FEI_ABORTING:
		os<<TEXT("FEI_ABORTING (");
		break;

	case FEI_ROUTING:
		os<<TEXT("FEI_ROUTING (");
		break;

	case FEI_MODEM_POWERED_ON:
		os<<TEXT("FEI_MODEM_POWERED_ON (");
		break;

	case FEI_MODEM_POWERED_OFF:
		os<<TEXT("FEI_MODEM_POWERED_OFF (");
		break;

	case FEI_IDLE :
		os<<TEXT("FEI_IDLE  (");
		break;

	case FEI_FAXSVC_ENDED :
		os<<TEXT("FEI_FAXSVC_ENDED  (");
		break;

	case FEI_ANSWERED :
		os<<TEXT("FEI_ANSWERED  (");
		break;

	case FEI_JOB_QUEUED :
		os<<TEXT("FEI_JOB_QUEUED  (");
		break;

	case FEI_DELETED:
		os<<TEXT("FEI_DELETED (");
		break;

	case FEI_FAXSVC_STARTED :
		os<<TEXT("FEI_FAXSVC_STARTED  (");
		break;

	case FEI_INITIALIZING :
		os<<TEXT("FEI_FAXSVC_INITIALIZING  (");
		break;

	case FEI_LINE_UNAVAILABLE :
		os<<TEXT("FEI_LINE_UNAVAILABLE  (");
		break;

	case FEI_HANDLED :
		os<<TEXT("FEI_HANDLED  (");
		break;

	default:
		_ASSERTE(FALSE);
		break;
	}
	os<<EventId<<TEXT(")");
	return(os);
}

//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
CotstrstreamEx& AppendEventIdStrToOs(CotstrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId)
{
	switch(EventId)
	{
	case FEI_DIALING:
		os << TEXT("FEI_DIALING (");
		break;

	case FEI_SENDING:
		os << TEXT("FEI_SENDING (");
		break;

	case FEI_RECEIVING:
		os << TEXT("FEI_RECEIVING (");
		break;

	case FEI_COMPLETED:
		os << TEXT("FEI_COMPLETED (");
		break;

	case FEI_BUSY:
		os << TEXT("FEI_BUSY (");
		break;

	case FEI_NO_ANSWER:
		os << TEXT("FEI_NO_ANSWER (");
		break;

	case FEI_BAD_ADDRESS:
		os << TEXT("FEI_BAD_ADDRESS (");
		break;

	case FEI_NO_DIAL_TONE:
		os << TEXT("FEI_NO_DIAL_TONE (");
		break;

	case FEI_DISCONNECTED:
		os << TEXT("FEI_DISCONNECTED (");
		break;

	case FEI_FATAL_ERROR:
		os<<TEXT("FEI_FATAL_ERROR (");
		break;

	case FEI_NOT_FAX_CALL:
		os << TEXT("FEI_NOT_FAX_CALL (");
		break;

	case FEI_CALL_DELAYED:
		os << TEXT("FEI_CALL_DELAYED (");
		break;

	case FEI_CALL_BLACKLISTED:
		os << TEXT("FEI_CALL_BLACKLISTED (");
		break;

	case FEI_RINGING:
		os << TEXT("FEI_RINGING (");
		break;

	case FEI_ABORTING:
		os << TEXT("FEI_ABORTING (");
		break;

	case FEI_ROUTING:
		os << TEXT("FEI_ROUTING (");
		break;

	case FEI_MODEM_POWERED_ON:
		os << TEXT("FEI_MODEM_POWERED_ON (");
		break;

	case FEI_MODEM_POWERED_OFF:
		os << TEXT("FEI_MODEM_POWERED_OFF (");
		break;

	case FEI_IDLE :
		os << TEXT("FEI_IDLE  (");
		break;

	case FEI_FAXSVC_ENDED :
		os << TEXT("FEI_FAXSVC_ENDED  (");
		break;

	case FEI_ANSWERED :
		os << TEXT("FEI_ANSWERED  (");
		break;

	case FEI_JOB_QUEUED :
		os << TEXT("FEI_JOB_QUEUED  (");
		break;

	case FEI_DELETED:
		os << TEXT("FEI_DELETED (");
		break;

	case FEI_FAXSVC_STARTED :
		os << TEXT("FEI_FAXSVC_STARTED  (");
		break;

	case FEI_INITIALIZING :
		os << TEXT("FEI_FAXSVC_INITIALIZING  (");
		break;

	case FEI_LINE_UNAVAILABLE :
		os << TEXT("FEI_LINE_UNAVAILABLE  (");
		break;

	case FEI_HANDLED :
		os << TEXT("FEI_HANDLED  (");
		break;

	default:
		_ASSERTE(FALSE);
		break;
	}
	os << EventId << TEXT(")");
	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent)
{
	os<<TEXT("SizeOfStruct:\t")<<aFaxEvent.SizeOfStruct<<endl;

	// convert the FAX_EVENT's time field to representable form
	os<<TEXT("TimeStamp:\t");
	FILETIME localFileTime;
	if (FALSE == ::FileTimeToLocalFileTime(&(aFaxEvent.TimeStamp),&localFileTime))
	{
		os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=)")<<GetLastError();
		return(os);
	}

	SYSTEMTIME lpSystemTime;
	if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
	{
		os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
		return(os);
	}
	os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
	os<<lpSystemTime.wHour<<TEXT(":");
	if (lpSystemTime.wMinute < 10) 
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wMinute<<TEXT(":");
	if (lpSystemTime.wSecond < 10)
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wSecond;
	os<<TEXT("  (d/m/yy  h:mm:ss)")<<endl;

	os<<TEXT("DeviceId:\t")<<aFaxEvent.DeviceId<<endl;

	// convert EventId to a descriptive string
	os<<TEXT("EventId:\t");
	::AppendEventIdStrToOs(os, aFaxEvent.EventId);
	os<<endl;

	os<<TEXT("JobId:\t\t")<<aFaxEvent.JobId;

	return(os);
}

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent)
{
	os<<TEXT("SizeOfStruct:\t")<<aFaxEvent.SizeOfStruct<<endl;

	// convert the FAX_EVENT's time field to representable form
	os<<TEXT("TimeStamp:\t");
	FILETIME localFileTime;
	if (FALSE == ::FileTimeToLocalFileTime(&(aFaxEvent.TimeStamp),&localFileTime))
	{
		os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
		return(os);
	}

	SYSTEMTIME lpSystemTime;
	if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
	{
		os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
		return(os);
	}
	os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
	os<<lpSystemTime.wHour<<TEXT(":");
	if (lpSystemTime.wMinute < 10) 
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wMinute<<TEXT(":");
	if (lpSystemTime.wSecond < 10)
	{
		os<<TEXT("0");
	}
	os<<lpSystemTime.wSecond;
	os<<TEXT("  (d/m/yy  h:m:ss)")<<endl;

	os<<TEXT("DeviceId:\t")<<aFaxEvent.DeviceId<<endl;

	// convert EventId to a descriptive string
	os<<TEXT("EventId:\t");
	::AppendEventIdStrToOs(os, aFaxEvent.EventId);
	os<<endl;

	os<<TEXT("JobId:\t\t")<<aFaxEvent.JobId;

	return(os);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxcompport.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxCompPort.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		16-Aug-98
//


//
//	Description:
//		This file contains the implementation of class CFaxCompletionPort.
//


#include "FaxCompPort.h"


CFaxCompletionPort::CFaxCompletionPort():
	m_hCompletionPort(NULL),
	m_hServerEvents(NULL)
{
}


CFaxCompletionPort::~CFaxCompletionPort(void)
{
	if (NULL != m_hCompletionPort)
	{
		if(!::CloseHandle(m_hCompletionPort))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\nCloseHandle failed with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
		}
	}
	if (NULL != m_hServerEvents)
	{
		if (FALSE == FaxUnregisterForServerEvents(m_hServerEvents))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\nFaxUnregisterForServerEvents(m_hEventHandle=0x%08X) failed with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				m_hServerEvents,
				::GetLastError()
				);
		}
	}
}


//
// GetCompletionPortHandle:
//	Creates an I\O completion port and "connects" it
//	to the local NT5.0 Fax Server.
//
// Return Value:
//	The Completion port if successful.
//	Otherwise NULL.
//
// Note:
//	Only one I\O completion port can be "connected" to
//	the Fax Server Queue (due to a limitation of the
//	API FaxInitializeEventQueue), so the first time this
//	function is called, a completion port is created and
//	FaxInitializedEventQueue is called. The created port 
//	is stored in the private member m_hCompletionPort.
//	Subsequent calls to this function return m_hCompletionPort.
//
BOOL CFaxCompletionPort::GetCompletionPortHandle(
	LPCTSTR szMachineName,
	HANDLE& hComPortHandle, 
	DWORD& dwLastError)
{
	BOOL fReturnValue = TRUE;

	// set OUT param dwLAstError
	dwLastError = ERROR_SUCCESS;

	//
	// Check if we already created and "connected" a completion port.
	// If we did then m_hCompletionPort would not be NULL.
	//
	if (NULL == m_hCompletionPort) 	
	{
		// No Completion Port exists, so create one.
		fReturnValue = ::InitFaxQueue(
			szMachineName,
			m_hCompletionPort,
			dwLastError,
			m_hServerEvents
			);// create and "connect" port.

			// reminder:
			// if completion port creation failed (InitFaxQueue failed)=>
			// dwLastError was set to last error
			// and m_hCompletionPort was set to NULL.
			// if completion port creation succeeded (InitFaxQueue succeeded)=>
			// dwLastError was set to ERROR_SUCCESS (0)
			// and m_hCompletionPort was set comp port handle.

		
		// OUT param dwLastError was set by InitFaxQueue()
					
	}

	// set OUT param to new m_hCompletionPort
	hComPortHandle = m_hCompletionPort;

	return(fReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxbroadcast.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
//
// Filename:	FaxBroadcast.h
// Author:		Sigalit Bar (sigalitb)
// Date:		31-Dec-98
//
//


//
// Description:
//		This file contains the description of 
//		class CFaxBroadcast. This class was designed
//		to allow for broadcast fax sending
//		using the NT5.0 Fax Service API (winfax.h).
//
//		The class has methods that enable it to:
//		* Add a recipient to a broadcast.
//		* Clear the broadcast recipient list, that is remove all
//		  recipients from the broadcast.
//		* Set the Cover Page to use with broadcast.
//		* Output instance information to a stream (CotstrstreamEx).
//		* Return a string description of the instance.
//		
//		
// Usage:
//		An instance of this class can be given to the
//		CFaxSender::send_broadcast() and a broadcast fax sending will be performed.
//		That is, CFaxSender::send_broadcast() will extract the needed parameters for
//      FaxSendDocumentEx from the CFaxBroadcast instance, and will invoke 
//      FaxSendDocumentEx with these parameters.
//
// Comments:
//		The class uses the elle logger wraper implemented
//		in LogElle.c to log any errors.
//
//		Streams are used for i/o handling (streamEx.cpp).
//

#ifndef _FAX_BROADCAST_H_
#define _FAX_BROADCAST_H_


#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <vector>

#include <windows.h>
#include <crtdbg.h>

#ifdef _NT5FAXTEST
#include <WinFax.h>
#else // ! _NT5FAXTEST
#include <fxsapip.h>
#endif // #ifdef _NT5FAXTEST

#include <log.h>
#include "streamEx.h"
#include "wcsutil.h"

using namespace std ;

#ifdef _NT5FAXTEST
// Testing NT5 Fax (with old winfax.dll)

//
// DefaultFaxRecipientCallback:
//	A default implementation of the required FAX_RECIPIENT_CALLBACK.
//  This function is used by CFaxSender::send_broadcast(), to send a broadcast
//  fax. 
//  That is, CFaxSender::send_broadcast() will invoke FaxSendDocumentForBroadcast
//	giving it a CFaxBroadcast instance as its Context parameter and the
//	exported DefaultFaxRecipientCallback function as its final parameter.
//  The FaxSendDocumentForBroadcast function calls this callback function to 
//  retrieve user-specific information for the transmission. 
//  FaxSendDocumentForBroadcast calls FAX_RECIPIENT_CALLBACK multiple times, 
//  once for each designated fax recipient, passing it the Context parameter.
//
// Parameters:
//	FaxHandle			IN parameter.
//						A handle to the Fax Service that will be used to broadcast
//						fax.
//	RecipientNumber		IN parameter.
//						Indicates the number of times the FaxSendDocumentForBroadcast 
//						function has called the FAX_RECIPIENT_CALLBACK function. 
//						Each function call corresponds to one designated fax recipient, 
//						and the index is relative to 1. 
//
//  Context				IN parameter.
//						A pointer to a CFaxBroadcast instance.
//
//  PFAX_JOB_PARAM		IN OUT parameter.
//						Pointer to a FAX_JOB_PARAM structure that contains the information
//						necessary for the fax server to send the fax transmission to the 
//						designated recipient. 
//						The structure includes, among other items, the recipient's fax 
//						number, sender and recipient data, an optional billing code, and 
//						job scheduling information. 
//						The fax server queues the fax transmission according to the details 
//						specified by the FAX_JOB_PARAM structure.
//						Note - The Fax Service allocates and frees this structure.
//
//	PFAX_COVERPAGE_INFO	IN OUT parameter.
//						Pointer to a FAX_COVERPAGE_INFO structure that contains cover 
//						page data to display on the cover page of the fax document for the 
//						designated recipient. This parameter must be NULL if a cover page 
//						is not required. 
//						Note - The Fax Service allocates and frees this structure.
//
// Return Value:
//	The function returns TRUE to indicate that the FaxSendDocumentForBroadcast function 
//	should queue an outbound fax transmission, using the data pointed to by the 
//	JobParams and CoverpageInfo parameters. 
//	The function returns FALSE to indicate that there are no more fax transmission jobs 
//	to queue, and calls to FAX_RECIPIENT_CALLBACK should be terminated. 
//
BOOL CALLBACK DefaultFaxRecipientCallback(
	HANDLE				/* IN */		FaxHandle,
	DWORD				/* IN */		RecipientNumber,
	LPVOID				/* IN */		Context,
	PFAX_JOB_PARAM		/* IN OUT */	JobParams,
	PFAX_COVERPAGE_INFO	/* IN OUT */	CoverpageInfo OPTIONAL
);
#endif //_NT5FAXTEST



//
// CFaxRecipientVector:
//	An STL list of LPCFAX_PERSONAL_PROFILEs.
//	Intended to contain the personal profiles of the broadcast recipients.
//
#ifdef _C_FAX_RECIPIENT_LIST_
#error "redefinition of _C_FAX_RECIPIENT_LIST_"
#else
#define _C_FAX_RECIPIENT_LIST_
typedef vector< LPCFAX_PERSONAL_PROFILE > CFaxRecipientVector;
#endif //_C_FAX_RECIPIENT_LIST_


//
// CFaxBroadcast:
//	This class was designed to allow for broadcast fax sending
//	using the NT5.0 Fax Service API (winfax.h).
class CFaxBroadcast{

public:

	//
	// CFaxBroadcast:
	//
	CFaxBroadcast(void);

	//
	// ~CFaxBroadcast:
	//
	~CFaxBroadcast(void);

	//
	// AddRecipient:
	//	Adds a recipient's number (as string) to the broadcast.
	//
	// Parameters:
	//	pRecipientProfile	IN parameter.
	//						The recipient profile to add to the broadcast.
	//
	// Return Value:
	//	The function returns TRUE if the profile was successfully added to
	//	the broadcast and FALSE otherwise.
	//
	// Note:
	//	pRecipientProfile and all its fields are duplicated by AddRecipient.
	//
	BOOL AddRecipient(LPCFAX_PERSONAL_PROFILE /* IN */ pRecipientProfile);

	//
	// ClearAllRecipients:
	//	Removes all the recipient profiles from instance.
	//	=> empties vector.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	None.
	//
	void ClearAllRecipients(void);


	// FreeAllRecipients:
	//	Frees all recipient profiles (and their string fields) in vector and empties vector.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	None.
	//
	void FreeAllRecipients(void);

	//
	// SetCPFileName:
	//	Sets the Cover Page file that will be used for the broadcast.
	//
	// Parameters:
	//	szCPFileName	IN parameter.
	//					The Cover Page filename.
	//
	// Return Value:
	//	The function returns TRUE upon success and FALSE otherwise.
	//
	BOOL SetCPFileName(
		LPCTSTR	/* IN */	szCPFileName
		);

	//
	// GetNumberOfRecipients:
	//	Returns the number of recipients in the broadcast.
	//
	// Parameters:
	//	None.
	//
	// Return Value:
	//	The number of recipients currently in the broadcast.
	//
	DWORD GetNumberOfRecipients(void) const;

	//
	// GetRecipient:
	//	Retreives the number (as string) of a recipient in the broadcast.
	//	
	// Parameters:
	//	dwRecipientIndex	IN parameter.
	//						The index of the recipient for which we want to retreive
	//						the number.
	//						This is a 1 based index.
	//	ppRecipientProfile	OUT parameter.
	//						An all level copy of the requested recipient's profile.
	//						The function allocates the memory for the profile and its fields
	//						and the caller must free it.
	//
	// NOTE: dwRecipientIndex is 1 based and the vector is 0 based.
	//
	// Return Value:
	//	The function returns TRUE upon success and FALSE otherwise.
	//
	BOOL GetRecipient(
		DWORD	                /* IN */	dwRecipientIndex,
		PFAX_PERSONAL_PROFILE*	/* OUT */	ppRecipientProfile
		) const;

	//
	// GetCPFileName:
	//	Retreives the Cover Page filename.
	//
	// Parameters:
	//	pszCPFileName	OUT parameter.
	//					A copy of the Cover Page filename.
	//					The function allocates the memory for this string and
	//					the caller must free it.
	//
	// Return Value:
	//	The function return TRUE upon success and FALSE otherwise.
	//
	BOOL GetCPFileName(
		LPTSTR*	/* OUT */	pszCPFileName
		) const;

    //
    // GetBroadcastParams:
    //  Retreives params for all recipients
    //
    //    It will alloc and set OUT params, since caller doesn't know num of recipients
    BOOL GetBroadcastParams(
        PFAX_COVERPAGE_INFO_EX*    /* OUT */	ppCoverPageInfo,
        PDWORD                      /* OUT */	pdwNumRecipients,
        PFAX_PERSONAL_PROFILE*	    /* OUT */	ppRecipientList
        ) const;

	//
	// outputAllToLog:
	//	Outputs a description of all the number strings in the instance
	//	to the elle logger.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD /* IN */ dwSeverity, 
		const DWORD /* IN */ dwLevel
		) const;

	//
	// operator<<:
	//	Appends a string representation of all the fields of a given CFaxBroadcast
	//	instance.
	//
	// Parameters:
	//	os					IN OUT parameter.
	//						The output stream to which the string will be appended.
	//	FaxBroadcastObj		IN parameter.
	//						The CFaxBroadcast instance which the generated string 
	//						will represent.
	//
	// Return Value:
	//	The updated stream.
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&			/* IN OUT */	os, 
		const CFaxBroadcast&	/* IN */		FaxBroadcastObj
		);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&			/* IN OUT */	os, 
		const CFaxBroadcast&	/* IN */		FaxBroadcastObj
		);

private:

	// The Cover Page filename that will be used with the broadcast.
	LPTSTR								m_szCPFileName;

	// An STL vector of strings.
	// Each string represents a recipient's phone number.
	CFaxRecipientVector					m_FaxRecipientVector;

};




#endif //_FAX_BROADCAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxevent.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEvent.h
// Author:	Sigalit Bar (sigalitb)
// Date:		23-Jul-98
//

//
// Description:
//	This file contains FAX_EVENT (winfax.h) related functions.
//	These methods allow for easier printing of FAX_EVENTs.
//


#ifndef _FAX_EVENT_H_
#define _FAX_EVENT_H_

#include <crtdbg.h>
#include <WinFax.h>
#include "streamEx.h"


//
// AppendEventIdStrToOs:
//	Inserts a string describing the event's numeric id (EventId) into the given stream.
//
// Parameters:
//	EventId		The numeric id of a fax event (FAX_EVENT.EventId), to generate the
//				corresponding descriptive string by.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& AppendEventIdStrToOs(CostrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId);


//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT.
//
// Parameters:
//	aFaxEvent	The FAX_EVENT which the generated string will represent.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent);
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT& /* IN */ aFaxEvent);
CotstrstreamEx& AppendEventIdStrToOs(CotstrstreamEx& /* IN OUT */ os, const DWORD /* IN */ EventId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxeventex.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:    FaxEvent.cpp
// Author:      Sigalit Bar (sigalitb)
// Date:        23-Jul-98
//


//
// Description:
//      This file contains the implementation of module "FaxEvent.h".
//


#include "FaxEventEx.h"
#include "wcsutil.h"


//
// TSTR string arrays for enum types
//

LPCTSTR g_tstrFaxJobEventTypes[] =
{
    TEXT("FAX_JOB_EVENT_TYPE_ADDED"),
    TEXT("FAX_JOB_EVENT_TYPE_REMOVED"),
    TEXT("FAX_JOB_EVENT_TYPE_STATUS")
};

LPCTSTR g_tstrFaxConfigEventTypes[] =
{
    TEXT("FAX_CONFIG_TYPE_SMTP"),
    TEXT("FAX_CONFIG_TYPE_ACTIVITY_LOGGING"),
    TEXT("FAX_CONFIG_TYPE_OUTBOX"),
    TEXT("FAX_CONFIG_TYPE_SENTITEMS"),
    TEXT("FAX_CONFIG_TYPE_INBOX"),
    TEXT("FAX_CONFIG_TYPE_SECURITY"),
    TEXT("FAX_CONFIG_TYPE_EVENTLOGS"),
    TEXT("FAX_CONFIG_TYPE_DEVICES"),
    TEXT("FAX_CONFIG_TYPE_OUT_GROUPS"),
    TEXT("FAX_CONFIG_TYPE_OUT_RULES")
};

LPCTSTR g_tstrFaxEventTypes[] =
{
    TEXT("FAX_EVENT_TYPE_IN_QUEUE"),    //= 0x0001
    TEXT("FAX_EVENT_TYPE_OUT_QUEUE"),   //= 0x0002
    TEXT("FAX_EVENT_TYPE_CONFIG"),      //= 0x0004
    TEXT("FAX_EVENT_TYPE_ACTIVITY"),    //= 0x0008
    TEXT("FAX_EVENT_TYPE_QUEUE_STATE"), //= 0x0010
    TEXT("FAX_EVENT_TYPE_IN_ARCHIVE"),  //= 0x0020
    TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE"), //= 0x0040
    TEXT("FAX_EVENT_TYPE_FXSSVC_ENDED") //= 0x0080
};

LPCTSTR g_tstrFaxQueueStatus[] =
{
    TEXT("JS_PENDING"),             //= 0x00000001
    TEXT("JS_INPROGRESS"),          //= 0x00000002
    TEXT("JS_DELETING"),            //= 0x00000004
    TEXT("JS_FAILED"),              //= 0x00000008
    TEXT("JS_PAUSED"),              //= 0x00000010
    TEXT("JS_NOLINE"),              //= 0x00000020
    TEXT("JS_RETRYING"),            //= 0x00000040
    TEXT("JS_RETRIES_EXCEEDED"),    //= 0x00000080
    TEXT("JS_COMPLETED"),           //= 0x00000100
    TEXT("JS_CANCELED"),            //= 0x00000200
    TEXT("JS_CANCELING"),           //= 0x00000400
    TEXT("JS_ROUTING")              //= 0x00000800
};


LPCTSTR g_tstrFaxExtendedStatus[] =
{
    TEXT("JS_EX_DISCONNECTED"),
    TEXT("JS_EX_INITIALIZING"),
    TEXT("JS_EX_DIALING"),
    TEXT("JS_EX_TRANSMITTING"),
    TEXT("JS_EX_ANSWERED"),
    TEXT("JS_EX_RECEIVING"),
    TEXT("JS_EX_LINE_UNAVAILABLE"),
    TEXT("JS_EX_BUSY"),
    TEXT("JS_EX_NO_ANSWER"),
    TEXT("JS_EX_BAD_ADDRESS"),
    TEXT("JS_EX_NO_DIAL_TONE"),
    TEXT("JS_EX_FATAL_ERROR"),
    TEXT("JS_EX_CALL_DELAYED"),
    TEXT("JS_EX_CALL_BLACKLISTED"),
    TEXT("JS_EX_NOT_FAX_CALL"),
    TEXT("JS_EX_PARTIALLY_RECEIVED"),
    TEXT("JS_EX_HANDLED"),
    TEXT("JS_EX_CALL_COMPLETED"),
    TEXT("JS_EX_CALL_ABORTED")
};


LPCTSTR g_tstrFaxQueueStates[] =
{
    TEXT("FAX_INCOMING_BLOCKED"),   // = 0x0001,
    TEXT("FAX_OUTBOX_BLOCKED"),     // = 0x0002,
    TEXT("FAX_OUTBOX_PAUSED")       // = 0x0004
};

//
// ANSI string arrays for enum types
//

LPCSTR g_strFaxJobEventTypes[] =
{
    "FAX_JOB_EVENT_TYPE_ADDED",
    "FAX_JOB_EVENT_TYPE_REMOVED",
    "FAX_JOB_EVENT_TYPE_STATUS"
};

LPCSTR g_strFaxConfigEventTypes[] =
{
    "FAX_CONFIG_TYPE_SMTP",
    "FAX_CONFIG_TYPE_ACTIVITY_LOGGING",
    "FAX_CONFIG_TYPE_OUTBOX",
    "FAX_CONFIG_TYPE_SENTITEMS",
    "FAX_CONFIG_TYPE_INBOX",
    "FAX_CONFIG_TYPE_SECURITY",
    "FAX_CONFIG_TYPE_EVENTLOGS",
    "FAX_CONFIG_TYPE_DEVICES",
    "FAX_CONFIG_TYPE_OUT_GROUPS",
    "FAX_CONFIG_TYPE_OUT_RULES"
};

LPCSTR g_strFaxEventTypes[] =
{
    "FAX_EVENT_TYPE_IN_QUEUE",    //= 0x0001
    "FAX_EVENT_TYPE_OUT_QUEUE",   //= 0x0002
    "FAX_EVENT_TYPE_CONFIG",        //= 0x0004
    "FAX_EVENT_TYPE_ACTIVITY",    //= 0x0008
    "FAX_EVENT_TYPE_QUEUE_STATE", //= 0x0010
    "FAX_EVENT_TYPE_IN_ARCHIVE",  //= 0x0020
    "FAX_EVENT_TYPE_OUT_ARCHIVE", //= 0x0040
    "FAX_EVENT_TYPE_FXSSVC_ENDED" //= 0x0080
};

LPCSTR g_strFaxQueueStatus[] =
{
    "JS_PENDING",             //= 0x00000001
    "JS_INPROGRESS",          //= 0x00000002
    "JS_DELETING",            //= 0x00000004
    "JS_FAILED",              //= 0x00000008
    "JS_PAUSED",              //= 0x00000010
    "JS_NOLINE",              //= 0x00000020
    "JS_RETRYING",            //= 0x00000040
    "JS_RETRIES_EXCEEDED",    //= 0x00000080
    "JS_COMPLETED",           //= 0x00000100
    "JS_CANCELED",            //= 0x00000200
    "JS_CANCELING",           //= 0x00000400
};                                              

LPCSTR g_strFaxExtendedStatus[] =
{
    "JS_EX_DISCONNECTED",
    "JS_EX_INITIALIZING",
    "JS_EX_DIALING",
    "JS_EX_TRANSMITTING",
    "JS_EX_ANSWERED",
    "JS_EX_RECEIVING",
    "JS_EX_LINE_UNAVAILABLE",
    "JS_EX_BUSY",
    "JS_EX_NO_ANSWER",
    "JS_EX_BAD_ADDRESS",
    "JS_EX_NO_DIAL_TONE",
    "JS_EX_FATAL_ERROR",
    "JS_EX_CALL_DELAYED",
    "JS_EX_CALL_BLACKLISTED",
    "JS_EX_NOT_FAX_CALL",
    "JS_EX_PARTIALLY_RECEIVED",
    "JS_EX_HANDLED",
    "JS_EX_CALL_COMPLETED",
    "JS_EX_CALL_ABORTED"
};


LPCSTR g_strFaxQueueStates[] =
{
    "FAX_INCOMING_BLOCKED",     // = 0x0001,
    "FAX_OUTBOX_BLOCKED",       // = 0x0002,
    "FAX_OUTBOX_PAUSED"         // = 0x0004
};

///
//
// GetQueueStatusStr:
//
LPCSTR
GetQueueStatusStr(
    IN  const DWORD dwQueueStatus
)
{
    DWORD   dwQueueStatusIndex = 0;

    _ASSERTE(dwQueueStatus >= JS_PENDING);
    _ASSERTE(dwQueueStatus <= JS_ROUTING);
    _ASSERTE(dwQueueStatusIndex < (sizeof(g_strFaxQueueStatus)/sizeof(g_strFaxQueueStatus[0])));
    if(0 != dwQueueStatus)
    {
        dwQueueStatusIndex = (log(dwQueueStatus)/log(2));
    }
    // else dwQueueStatusIndex remains 0.

    return(g_strFaxQueueStatus[dwQueueStatusIndex]);
}

///
//
// GetQueueStatusTStr:
//
LPCTSTR
GetQueueStatusTStr(
    IN  const DWORD dwQueueStatus
)
{
    DWORD   dwQueueStatusIndex = 0;

    _ASSERTE(dwQueueStatus >= JS_PENDING);
    _ASSERTE(dwQueueStatus <= JS_ROUTING);
    _ASSERTE(dwQueueStatusIndex < (sizeof(g_tstrFaxQueueStatus)/sizeof(g_tstrFaxQueueStatus[0])));
    if(0 != dwQueueStatus)
    {
        dwQueueStatusIndex = (log(dwQueueStatus)/log(2));
    }
    // else dwQueueStatusIndex remains 0.

    return(g_tstrFaxQueueStatus[dwQueueStatusIndex]);
}

///
//
// GetExtendedStatusStr:
//
LPCSTR
GetExtendedStatusStr(
    IN  const DWORD dwExtendedStatus
)
{
    DWORD dwExtendedStatusIndex = 0;
    if (0 == dwExtendedStatus)
    {
        return("0x00000000");
    }
    if (dwExtendedStatus >= JS_EX_PROPRIETARY)
    {
        return("JS_EX_PROPRIETARY");
    }

    _ASSERTE(dwExtendedStatus <= JS_EX_CALL_ABORTED);
    dwExtendedStatusIndex = dwExtendedStatus - 1;
    _ASSERTE(dwExtendedStatusIndex < (sizeof(g_strFaxExtendedStatus)/sizeof(g_strFaxExtendedStatus[0])));
    return(g_strFaxExtendedStatus[dwExtendedStatusIndex]);
}

///
//
// GetExtendedStatusTStr:
//
LPCTSTR
GetExtendedStatusTStr(
    IN  const DWORD dwExtendedStatus
)
{
    DWORD dwExtendedStatusIndex = 0;
    if (0 == dwExtendedStatus)
    {
        return(TEXT("0x00000000"));
    }

    if (dwExtendedStatus >= JS_EX_PROPRIETARY)
    {
        return(TEXT("JS_EX_PROPRIETARY"));
    }

    _ASSERTE(dwExtendedStatus <= JS_EX_CALL_ABORTED);
    dwExtendedStatusIndex = dwExtendedStatus - 1;
    _ASSERTE(dwExtendedStatusIndex < (sizeof(g_tstrFaxExtendedStatus)/sizeof(g_tstrFaxExtendedStatus[0])));
    return(g_tstrFaxExtendedStatus[dwExtendedStatusIndex]);
}

///
//
// LogExtendedEvent:
//
void
LogExtendedEvent(
    PFAX_EVENT_EX   /* IN */ pFaxEventEx,
    const DWORD     /* IN */ dwSeverity,
    const DWORD     /* IN */ dwLevel
)
{
    CotstrstreamEx os;
    LPCTSTR szLogStr;   //string to be sent to logger

    os << TEXT("FaxExtendedEvent -")<<endl;
    os << (*pFaxEventEx);
    szLogStr = os.cstr();   
                            
    ::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
    delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())

}

//
// operator<<:
//  Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
CostrstreamEx& operator<<(
    CostrstreamEx& /* IN OUT */ os,
    const FAX_EVENT_EX& /* IN */ FaxEventEx
    )
{
    FAX_EVENT_JOB   EventJobInfo = {0};
    DWORD           dwEventTypeIndex = 0;
    LPCSTR          strEventType = NULL;
    LPCSTR          strJobEventType = NULL;
    LPCSTR          strConfigEventType = NULL;
    LPCSTR          strQueueStatus = NULL;
    LPCSTR          strExtendedStatus = NULL;
    LPCSTR          strProprietaryExtendedStatus = NULL;
    LPCSTR          strDeviceName = NULL;
    LPCSTR          strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwDeviceId = 0;
    LPCTSTR         lpctstrDeviceName = NULL;
    CHAR            strMessageId[20] = {0};

    os<<TEXT("SizeOfStruct:\t")<<FaxEventEx.dwSizeOfStruct<<endl;

    // convert the FAX_EVENT's time field to representable form
    os<<TEXT("TimeStamp:\t");
    FILETIME localFileTime;
    if (FALSE == ::FileTimeToLocalFileTime(&(FaxEventEx.TimeStamp),&localFileTime))
    {
        os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
        return(os);
    }

    SYSTEMTIME lpSystemTime;
    if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
    {
        os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FileTimeToSystemTime failed with ec=0x%08X\n"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        _ASSERTE(FALSE);
        return(os);
    }
    os<<lpSystemTime.wDay<<TEXT("/")<<lpSystemTime.wMonth<<TEXT("/")<<lpSystemTime.wYear<<TEXT("  ");
    os<<lpSystemTime.wHour<<TEXT(":");
    if (lpSystemTime.wMinute < 10)
    {
        os<<TEXT("0");
    }
    os<<lpSystemTime.wMinute<<TEXT(":");
    if (lpSystemTime.wSecond < 10)
    {
        os<<TEXT("0");
    }
    os<<lpSystemTime.wSecond;
    os<<TEXT("  (d/m/yy  h:mm:ss)")<<endl;

    dwEventTypeIndex = log(FaxEventEx.EventType)/log(2);
    _ASSERTE(dwEventTypeIndex < (sizeof(g_strFaxEventTypes)/sizeof(g_strFaxEventTypes[0])));

    strEventType = g_strFaxEventTypes[dwEventTypeIndex];
    os<<TEXT("EventType:\t")<<strEventType<<endl;

    switch (FaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            EventJobInfo = (FaxEventEx.EventInfo).JobInfo;
            strJobEventType = g_strFaxJobEventTypes[EventJobInfo.Type];
            ::_ui64toa(EventJobInfo.dwlMessageId, strMessageId, 16);
            os<<TEXT("dwlMessageId:\t")<<strMessageId<<endl;
            os<<TEXT("JobEventType:\t")<<strJobEventType<<endl;
            if (FAX_JOB_EVENT_TYPE_STATUS == EventJobInfo.Type)
            {
                _ASSERTE(EventJobInfo.pJobData);
                dwDeviceId = EventJobInfo.pJobData->dwDeviceID;
                _ASSERTE(dwDeviceId);
                lpctstrDeviceName = EventJobInfo.pJobData->lpctstrDeviceName;
                _ASSERTE(lpctstrDeviceName);
                dwQueueStatus = EventJobInfo.pJobData->dwQueueStatus;
                dwExtendedStatus = EventJobInfo.pJobData->dwExtendedStatus;
                lpctstrExtendedStatus = EventJobInfo.pJobData->lpctstrExtendedStatus;
                strQueueStatus = GetQueueStatusStr(dwQueueStatus);
                strExtendedStatus = GetExtendedStatusStr(dwExtendedStatus);
                os<<TEXT("Extended Event JobData-")<<endl;
                if (lpctstrDeviceName)
                {
                    strDeviceName = ::DupTStrAsStr(lpctstrDeviceName);
                    if (NULL == strDeviceName)
                    {
                        os<<TEXT("lpctstrDeviceName:\t ERROR - DupTStrAsStr() failed")<<endl;
                    }
                    else
                    {
                        os<<TEXT("lpctstrDeviceName:\t")<<strDeviceName<<endl;
                    }
                }
                else
                {
                    os<<TEXT("lpctstrDeviceName:\t (null)")<<endl;
                }
                os<<TEXT("dwDeviceId:\t")<<dwDeviceId<<endl;
                os<<TEXT("QueueStatus:\t")<<strQueueStatus<<endl;
                os<<TEXT("ExtendedStatus:\t")<<strExtendedStatus<<endl;
                if (lpctstrExtendedStatus)
                {
                    strProprietaryExtendedStatus = ::DupTStrAsStr(lpctstrExtendedStatus);
                    if (NULL == strProprietaryExtendedStatus)
                    {
                        os<<TEXT("lpctstrExtendedStatus:\t ERROR - DupTStrAsStr() failed")<<endl;
                    }
                    else
                    {
                        os<<TEXT("lpctstrExtendedStatus:\t")<<strProprietaryExtendedStatus<<endl;
                    }
                }
                else
                {
                    os<<TEXT("lpctstrExtendedStatus:\t (null)")<<endl;
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            _ASSERTE((FaxEventEx.EventInfo).ConfigType < (sizeof(g_strFaxQueueStatus)/sizeof(g_strFaxQueueStatus[0])));
            strConfigType = g_strFaxConfigEventTypes[(FaxEventEx.EventInfo).ConfigType];
            os<<TEXT("ConfigType:\t")<<strConfigType<<endl;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            os<<TEXT("dwIncomingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwIncomingMessages<<endl;
            os<<TEXT("dwRoutingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwRoutingMessages<<endl;
            os<<TEXT("dwOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwOutgoingMessages<<endl;
            os<<TEXT("dwDelegatedOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwDelegatedOutgoingMessages<<endl;
            os<<TEXT("dwQueuedMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwQueuedMessages<<endl;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            os<<TEXT("dwQueueStates:\t")<<(FaxEventEx.EventInfo).dwQueueStates<<endl;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                FaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    delete[]((LPSTR)strDeviceName);
    delete[]((LPSTR)strProprietaryExtendedStatus);
    return(os);
}

//
// operator<<:
//  Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
CotstrstreamEx& operator<<(
    CotstrstreamEx& /* IN OUT */ os,
    const FAX_EVENT_EX& /* IN */ FaxEventEx
    )
{
    FAX_EVENT_JOB   EventJobInfo = {0};
    DWORD           dwEventTypeIndex = 0;
    LPCTSTR         strEventType = NULL;
    LPCTSTR         strJobEventType = NULL;
    LPCTSTR         strConfigEventType = NULL;
    LPCTSTR         strQueueStatus = NULL;
    LPCTSTR         strExtendedStatus = NULL;
    LPCTSTR         strProprietaryExtendedStatus = NULL;
    LPCTSTR         strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwDeviceId = 0;
    LPCTSTR         lpctstrDeviceName = NULL;
    TCHAR           strMessageId[20] = {0};

    os<<TEXT("SizeOfStruct:\t")<<FaxEventEx.dwSizeOfStruct<<endl;

    // convert the FAX_EVENT's time field to representable form
    os<<TEXT("TimeStamp:\t");
    FILETIME localFileTime;
    if (FALSE == ::FileTimeToLocalFileTime(&(FaxEventEx.TimeStamp),&localFileTime))
    {
        os<<TEXT("Time Conversion (FileTimeToLocalFileTime) Failed with Error=")<<GetLastError();
        return(os);
    }

    SYSTEMTIME lpSystemTime;
    if(FALSE == ::FileTimeToSystemTime(&localFileTime,&lpSystemTime))
    {
        os<<TEXT("Time Conversion (FileTimeToSystemTime) Failed with Error=")<<GetLastError();
        return(os);
    }
    DWORD   dwDay = lpSystemTime.wDay;
    DWORD   dwMonth = lpSystemTime.wMonth;
    DWORD   dwYear = lpSystemTime.wYear;
    DWORD   dwHour = lpSystemTime.wHour;
    DWORD   dwMinute = lpSystemTime.wMinute;
    DWORD   dwSecond = lpSystemTime.wSecond;
    os<<dwDay<<TEXT("/")<<dwMonth<<TEXT("/")<<dwYear<<TEXT("  ");
    os<<dwHour<<TEXT(":");
    if (dwMinute < 10)
    {
        os<<TEXT("0");
    }
    os<<dwMinute<<TEXT(":");
    if (dwSecond < 10)
    {
        os<<TEXT("0");
    }
    os<<dwSecond;
    os<<TEXT("  (d/m/yy  h:m:ss)")<<endl;

    dwEventTypeIndex = log(FaxEventEx.EventType)/log(2);
    _ASSERTE(dwEventTypeIndex < (sizeof(g_tstrFaxEventTypes)/sizeof(g_tstrFaxEventTypes[0])));

    strEventType = g_tstrFaxEventTypes[dwEventTypeIndex];
    os<<TEXT("EventType:\t")<<strEventType<<endl;

    switch (FaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            EventJobInfo = (FaxEventEx.EventInfo).JobInfo;
            strJobEventType = g_tstrFaxJobEventTypes[EventJobInfo.Type];
            ::_ui64tot(EventJobInfo.dwlMessageId, strMessageId, 16);
            os<<TEXT("dwlMessageId:\t")<<strMessageId<<endl;
            os<<TEXT("JobEventType:\t")<<strJobEventType<<endl;
            os<<TEXT("EventType:\t")<<strEventType<<endl;
            if (FAX_JOB_EVENT_TYPE_STATUS == EventJobInfo.Type)
            {
                _ASSERTE(EventJobInfo.pJobData);
                dwDeviceId = EventJobInfo.pJobData->dwDeviceID;
                _ASSERTE(dwDeviceId);
                lpctstrDeviceName = EventJobInfo.pJobData->lpctstrDeviceName;
                _ASSERTE(lpctstrDeviceName);
                dwQueueStatus = EventJobInfo.pJobData->dwQueueStatus;
                dwExtendedStatus = EventJobInfo.pJobData->dwExtendedStatus;
                lpctstrExtendedStatus = EventJobInfo.pJobData->lpctstrExtendedStatus;
                strQueueStatus = GetQueueStatusTStr(dwQueueStatus);
                strExtendedStatus = GetExtendedStatusTStr(dwExtendedStatus);
                strProprietaryExtendedStatus = lpctstrExtendedStatus;
                os<<TEXT("Extended Event JobData-")<<endl;
                os<<TEXT("lpctstrDeviceName:\t")<<lpctstrDeviceName<<endl;
                os<<TEXT("dwDeviceId:\t")<<dwDeviceId<<endl;
                os<<TEXT("QueueStatus:\t")<<strQueueStatus<<endl;
                os<<TEXT("ExtendedStatus:\t")<<strExtendedStatus<<endl;
                if (NULL != strProprietaryExtendedStatus)
                {
                    os<<TEXT("ProprietaryExtendedStatus:\t")<<strProprietaryExtendedStatus<<endl;
                }
                else
                {
                    os<<TEXT("ProprietaryExtendedStatus:\t(null)")<<endl;
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            _ASSERTE((FaxEventEx.EventInfo).ConfigType < (sizeof(g_tstrFaxQueueStatus)/sizeof(g_tstrFaxQueueStatus[0])));
            strConfigType = g_tstrFaxConfigEventTypes[(FaxEventEx.EventInfo).ConfigType];
            os<<TEXT("ConfigType:\t")<<strConfigType<<endl;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            os<<TEXT("dwIncomingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwIncomingMessages<<endl;
            os<<TEXT("dwRoutingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwRoutingMessages<<endl;
            os<<TEXT("dwOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwOutgoingMessages<<endl;
            os<<TEXT("dwDelegatedOutgoingMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwDelegatedOutgoingMessages<<endl;
            os<<TEXT("dwQueuedMessages:\t")<<(FaxEventEx.EventInfo).ActivityInfo.dwQueuedMessages<<endl;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            os<<TEXT("dwQueueStates:\t")<<(FaxEventEx.EventInfo).dwQueueStates<<endl;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CostrstreamEx& operator<<]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                FaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    return(os);
}


//
//
//
BOOL CopyFaxExtendedEvent(
    OUT FAX_EVENT_EX**  ppDstFaxEventEx,
    IN  FAX_EVENT_EX    SrcFaxEventEx
)
{
    BOOL fRetVal = FALSE;
    FAX_EVENT_EX*   pDstFaxEventEx = NULL;
    DWORD           dwEventTypeIndex = 0;
    LPCTSTR         strEventType = NULL;
    LPCTSTR         strJobEventType = NULL;
    LPCTSTR         strConfigEventType = NULL;
    LPCTSTR         strQueueStatus = NULL;
    LPCTSTR         strExtendedStatus = NULL;
    LPCTSTR         strProprietaryExtendedStatus = NULL;
    LPCTSTR         strConfigType = NULL;
    DWORD           dwQueueStatus = 0;
    DWORD           dwExtendedStatus = 0;
    LPCTSTR         lpctstrExtendedStatus = NULL;
    DWORD           dwQueueStatusIndex = 0;
    FAX_EVENT_JOB*  pSrcEventJobInfo = NULL;
    FAX_EVENT_JOB*  pDstEventJobInfo = NULL;

    pDstFaxEventEx = (FAX_EVENT_EX*) malloc (sizeof(FAX_EVENT_EX));
    if (NULL == pDstFaxEventEx)
    {
        ::lgLogError(
            LOG_SEV_1,
            TEXT("FILE:%s LINE:%d\n[CSendInfo::AddItem] new failed with ec=0x%08X"),
            TEXT(__FILE__),
            __LINE__,
            ::GetLastError()
            );
        goto ExitFunc;
    }
    ZeroMemory(pDstFaxEventEx, sizeof(FAX_EVENT_EX));

    pDstFaxEventEx->dwSizeOfStruct = SrcFaxEventEx.dwSizeOfStruct;
    pDstFaxEventEx->TimeStamp = SrcFaxEventEx.TimeStamp;
    pDstFaxEventEx->EventType = SrcFaxEventEx.EventType;

    switch (SrcFaxEventEx.EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            pSrcEventJobInfo = &((SrcFaxEventEx.EventInfo).JobInfo);
            pDstEventJobInfo = &((pDstFaxEventEx->EventInfo).JobInfo);
            pDstEventJobInfo->dwlMessageId = pSrcEventJobInfo->dwlMessageId;
            pDstEventJobInfo->Type = pSrcEventJobInfo->Type;
            pDstEventJobInfo->pJobData = NULL;
            if (FAX_JOB_EVENT_TYPE_STATUS == pSrcEventJobInfo->Type)
            {
                _ASSERTE(pSrcEventJobInfo->pJobData);
                pDstEventJobInfo->pJobData = (PFAX_JOB_STATUS) malloc (sizeof(FAX_JOB_STATUS));
                if(NULL == pDstEventJobInfo->pJobData)
                {
                    ::lgLogError(
                        LOG_SEV_1,
                        TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n malloc failed with ec=0x%08X\n"),
                        TEXT(__FILE__),
                        __LINE__,
                        ::GetLastError()
                        );
                    goto ExitFunc;
                }
                ZeroMemory(pDstEventJobInfo->pJobData, sizeof(FAX_JOB_STATUS));
                pDstEventJobInfo->pJobData->dwSizeOfStruct = pSrcEventJobInfo->pJobData->dwSizeOfStruct;
                pDstEventJobInfo->pJobData->dwValidityMask = pSrcEventJobInfo->pJobData->dwValidityMask;
                pDstEventJobInfo->pJobData->dwJobID = pSrcEventJobInfo->pJobData->dwJobID;
                pDstEventJobInfo->pJobData->dwJobType = pSrcEventJobInfo->pJobData->dwJobType;
                pDstEventJobInfo->pJobData->dwSize = pSrcEventJobInfo->pJobData->dwSize;
                pDstEventJobInfo->pJobData->dwPageCount = pSrcEventJobInfo->pJobData->dwPageCount;
                pDstEventJobInfo->pJobData->dwCurrentPage = pSrcEventJobInfo->pJobData->dwCurrentPage;
                pDstEventJobInfo->pJobData->tmScheduleTime = pSrcEventJobInfo->pJobData->tmScheduleTime;
                // TODO: the field was removed. New field was added: EndTime
                //pDstEventJobInfo->pJobData->tmTransmissionTime = pSrcEventJobInfo->pJobData->tmTransmissionTime;
                pDstEventJobInfo->pJobData->dwDeviceID = pSrcEventJobInfo->pJobData->dwDeviceID;
                pDstEventJobInfo->pJobData->dwRetries = pSrcEventJobInfo->pJobData->dwRetries;
                pDstEventJobInfo->pJobData->dwQueueStatus = pSrcEventJobInfo->pJobData->dwQueueStatus;
                pDstEventJobInfo->pJobData->dwExtendedStatus = pSrcEventJobInfo->pJobData->dwExtendedStatus;

                if (pSrcEventJobInfo->pJobData->lpctstrExtendedStatus)
                {
                    pDstEventJobInfo->pJobData->lpctstrExtendedStatus = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrExtendedStatus);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrExtendedStatus)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrTsid)
                {
                    pDstEventJobInfo->pJobData->lpctstrTsid = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrTsid);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrTsid)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrCsid)
                {
                    pDstEventJobInfo->pJobData->lpctstrCsid = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrCsid);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrCsid)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrDeviceName)
                {
                    pDstEventJobInfo->pJobData->lpctstrDeviceName = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrDeviceName);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrDeviceName)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrCallerID)
                {
                    pDstEventJobInfo->pJobData->lpctstrCallerID = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrCallerID);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrCallerID)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
                if (pSrcEventJobInfo->pJobData->lpctstrRoutingInfo)
                {
                    pDstEventJobInfo->pJobData->lpctstrRoutingInfo = ::_tcsdup(pSrcEventJobInfo->pJobData->lpctstrRoutingInfo);
                    if (NULL == pDstEventJobInfo->pJobData->lpctstrRoutingInfo)
                    {
                        ::lgLogError(
                            LOG_SEV_1,
                            TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n _tcsdup failed with ec=0x%08X\n"),
                            TEXT(__FILE__),
                            __LINE__,
                            ::GetLastError()
                            );
                        goto ExitFunc;
                    }
                }
            }
            break;

        case FAX_EVENT_TYPE_CONFIG:
            (pDstFaxEventEx->EventInfo).ConfigType = SrcFaxEventEx.EventInfo.ConfigType;
            break;

        case FAX_EVENT_TYPE_ACTIVITY:
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwIncomingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwIncomingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwRoutingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwRoutingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwOutgoingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwOutgoingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwDelegatedOutgoingMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwDelegatedOutgoingMessages;
            (pDstFaxEventEx->EventInfo).ActivityInfo.dwQueuedMessages = SrcFaxEventEx.EventInfo.ActivityInfo.dwQueuedMessages;
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            (pDstFaxEventEx->EventInfo).dwQueueStates = SrcFaxEventEx.EventInfo.dwQueueStates;
            break;

        default:
            ::lgLogError(
                LOG_SEV_1,
                TEXT("FILE:%s LINE:%d [CopyFaxExtendedEvent]\n- FaxEventEx.EventType=0x%08X is out of enumaration scope\n"),
                TEXT(__FILE__),
                __LINE__,
                SrcFaxEventEx.EventType
                );
            _ASSERTE(FALSE);
            break;
    }

    (*ppDstFaxEventEx) = pDstFaxEventEx;
    fRetVal = TRUE;

ExitFunc:
    if (FALSE == fRetVal)
    {
        switch (SrcFaxEventEx.EventType)
        {
            case FAX_EVENT_TYPE_IN_QUEUE:
            case FAX_EVENT_TYPE_OUT_QUEUE:
            case FAX_EVENT_TYPE_IN_ARCHIVE:
            case FAX_EVENT_TYPE_OUT_ARCHIVE:
                if ((pDstFaxEventEx->EventInfo).JobInfo.pJobData)
                {
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrTsid);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCsid);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrDeviceName);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCallerID);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo);
                    free((LPTSTR)(pDstFaxEventEx->EventInfo).JobInfo.pJobData);
                    ZeroMemory((pDstFaxEventEx->EventInfo).JobInfo.pJobData, sizeof(FAX_JOB_STATUS));
                }
                break;

            default:
                // no strings to free
                break;
        }
    }
    return(fRetVal);
}

//
// FreeFaxExtendedEvent:
//  Frees all memory associated with pFaxEventEx
//
void FreeFaxExtendedEvent(
    IN  FAX_EVENT_EX*   pFaxEventEx
)
{
    _ASSERTE(pFaxEventEx);
    switch (pFaxEventEx->EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
        case FAX_EVENT_TYPE_OUT_QUEUE:
        case FAX_EVENT_TYPE_IN_ARCHIVE:
        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            if ((pFaxEventEx->EventInfo).JobInfo.pJobData)
            {
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrTsid);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCsid);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrDeviceName);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrCallerID);
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo);
                ZeroMemory((pFaxEventEx->EventInfo).JobInfo.pJobData, sizeof(FAX_JOB_STATUS));
                free((LPTSTR)(pFaxEventEx->EventInfo).JobInfo.pJobData);
            }
            break;

        default:
            // no strings to free
            break;
    }
    ZeroMemory(pFaxEventEx, sizeof(FAX_EVENT_EX));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxeventex.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename:	FaxEventEx.h
// Author:	Sigalit Bar (sigalitb)
// Date:		30-Jan-2000
//

//
// Description:
//	This file contains FAX_EVENT_EX (winfax.h) related functions.
//	These methods allow for easier printing of FAX_EVENT_EXs.
//


#ifndef _FAX_EVENT_EX_H_
#define _FAX_EVENT_EX_H_

#include <crtdbg.h>
#include <math.h>

#include <fxsapip.h>
#include "streamEx.h"


//
// CopyFaxExtendedEvent:
//	Creates a copy of SrcFaxEventEx in *pDstFaxEventEx
//	Note- this func allocates the memory for the copy, and the caller should free.
//
BOOL CopyFaxExtendedEvent(
	OUT	FAX_EVENT_EX**	pDstFaxEventEx, 
	IN	FAX_EVENT_EX	SrcFaxEventEx
	);

//
// FreeFaxExtendedEvent:
//	Frees all memory associated with pFaxEventEx
//
void FreeFaxExtendedEvent(
	IN	FAX_EVENT_EX*	pFaxEventEx
	);

//
// operator<<:
//	Appends a string representation of all the fields of a given FAX_EVENT_EX.
//
// Parameters:
//	FaxEventEx	The FAX_EVENT_EX which the generated string will represent.
//	os			The output stream to which the string will be appended.
//
// Return Value:
//	The updated stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const FAX_EVENT_EX& /* IN */ FaxEventEx);
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const FAX_EVENT_EX& /* IN */ FaxEventEx);


///
//
// GetQueueStatusStr:
//	This func returns the ANSI string representation of dwQueueStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCSTR
GetQueueStatusStr(
	IN	const DWORD	dwQueueStatus
);

///
//
// GetQueueStatusTStr:
//	This func returns the TSTR string representation of dwQueueStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCTSTR
GetQueueStatusTStr(
	IN	const DWORD	dwQueueStatus
);

///
//
// GetExtendedStatusStr:
//	This func returns the ANSI string representation of dwExtendedStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCSTR
GetExtendedStatusStr(
	IN	const DWORD	dwExtendedStatus
);

///
//
// GetExtendedStatusTStr:
//	This func returns the TSTR string representation of dwExtendedStatus
//	Note - the returned string is global and should *not* be freed.
//
LPCTSTR
GetExtendedStatusTStr(
	IN	const DWORD	dwExtendedStatus
);


//
//
// LogExtendedEvent:
//	Logs the extended event *pFaxEventEx using the Elle logger,
//	with severity=dwSeverity and log level=dwLevel
//
void
LogExtendedEvent(
	PFAX_EVENT_EX	/* IN */ pFaxEventEx,
	const DWORD		/* IN */ dwSeverity = LOG_X, 
	const DWORD		/* IN */ dwLevel = 9
);

#endif //_FAX_EVENT_EX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\personalprofile.h ===
#ifndef __PERSONAL_PROFILE_H__
#define __PERSONAL_PROFILE_H__

typedef struct _FAX_PERSONAL_PROFILEA
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPSTR      lptstrName;                  // Name of person
    LPSTR      lptstrFaxNumber;             // Fax number
    LPSTR      lptstrCompany;               // Company name
    LPSTR      lptstrStreetAddress;         // Street address
    LPSTR      lptstrCity;                  // City
    LPSTR      lptstrState;                 // State
    LPSTR      lptstrZip;                   // Zip code
    LPSTR      lptstrCountry;               // Country
    LPSTR      lptstrTitle;                 // Title
    LPSTR      lptstrDepartment;            // Department
    LPSTR      lptstrOfficeLocation;        // Office location
    LPSTR      lptstrHomePhone;             // Phone number at home
    LPSTR      lptstrOfficePhone;           // Phone number at office
    LPSTR      lptstrEmail;                 // Personal e-mail address
    LPSTR      lptstrBillingCode;           // Billing code
    LPSTR      lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEA, *PFAX_PERSONAL_PROFILEA;
typedef struct _FAX_PERSONAL_PROFILEW
{
    DWORD      dwSizeOfStruct;              // Size of this structure
    LPWSTR     lptstrName;                  // Name of person
    LPWSTR     lptstrFaxNumber;             // Fax number
    LPWSTR     lptstrCompany;               // Company name
    LPWSTR     lptstrStreetAddress;         // Street address
    LPWSTR     lptstrCity;                  // City
    LPWSTR     lptstrState;                 // State
    LPWSTR     lptstrZip;                   // Zip code
    LPWSTR     lptstrCountry;               // Country
    LPWSTR     lptstrTitle;                 // Title
    LPWSTR     lptstrDepartment;            // Department
    LPWSTR     lptstrOfficeLocation;        // Office location
    LPWSTR     lptstrHomePhone;             // Phone number at home
    LPWSTR     lptstrOfficePhone;           // Phone number at office
    LPWSTR     lptstrEmail;                 // Personal e-mail address
    LPWSTR     lptstrBillingCode;           // Billing code
    LPWSTR     lptstrTSID;                  // Tsid
} FAX_PERSONAL_PROFILEW, *PFAX_PERSONAL_PROFILEW;
#ifdef UNICODE
typedef FAX_PERSONAL_PROFILEW FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEW PFAX_PERSONAL_PROFILE;
#else
typedef FAX_PERSONAL_PROFILEA FAX_PERSONAL_PROFILE;
typedef PFAX_PERSONAL_PROFILEA PFAX_PERSONAL_PROFILE;
#endif // UNICODE

typedef const FAX_PERSONAL_PROFILEW * LPCFAX_PERSONAL_PROFILEW;
typedef const FAX_PERSONAL_PROFILEA * LPCFAX_PERSONAL_PROFILEA;

#ifdef UNICODE
        typedef LPCFAX_PERSONAL_PROFILEW LPCFAX_PERSONAL_PROFILE;
#else
        typedef LPCFAX_PERSONAL_PROFILEA LPCFAX_PERSONAL_PROFILE;
#endif

#endif // #ifndef __PERSONAL_PROFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar
// Date:		30-dec-98
//
//


#include "test.h"

#define HELP_SWITCH_1        TEXT("/?")
#define HELP_SWITCH_2        TEXT("/H")
#define HELP_SWITCH_3        TEXT("-?")
#define HELP_SWITCH_4        TEXT("-H")

#define MAX_ARGS	6 //including exe name

#define ARGUMENT_IS_SERVER_NAME		1
#define ARGUMENT_IS_FAX_NUMBER		2
#define ARGUMENT_IS_DOC				3
#define ARGUMENT_IS_CP				4
#define ARGUMENT_IS_BROADCAST		5

//
// global pointer to process heap
//
HANDLE g_hMainHeap = NULL;


//
// UsageInfo:
//	Outputs application's proper usage and exits process.
//
void
UsageInfo(void)
{
	::_tprintf(TEXT("WindowsXPFaxSender\n\n"));
	::_tprintf(TEXT("WindowsXPFaxSender server_name fax_number document cover_page broadcast\n"));
	::_tprintf(TEXT("    server_name	The name of the fax server (without the \\\\)\n"));
	::_tprintf(TEXT("    fax_number		The fax number of the 1st device on server\n"));
	::_tprintf(TEXT("    document		The full path of the document to send\n"));
	::_tprintf(TEXT("    cover_page		The full path to the cover page to send\n"));
	::_tprintf(TEXT("    Broadcast		TRUE or FALSE to indicate if to send to a single recipient or a broadcast\n"));
	::_tprintf(TEXT("\n"));
	exit(0);
}


//
// ParseCmdLineParams:
//	Parses the command line parameters, saves a copy of them,
//	and converts from MBCS to UNICODE if necessary.
//
// Parameters:
//	argc				IN parameter.
//						command line number of arguments.
//	argvA[]				IN parameter.
//						command line args (in MBCS).
//	pszServerName		OUT parameter.
//						Pointer to string to copy 1st argument to.
//						Represents the name of fax server to use.
//	pszFaxNumber		OUT parameter.
//						Pointer to string to copy 2nd argument to.
//						Represents the fax number of 1st device on the
//						above fax server.
//	pszDocument			OUT parameter.
//						Pointer to string to copy 3rd argument to.
//						Represents the name of document to use with tests.
//	pszCoverPage		OUT parameter.
//						Pointer to string to copy 4th argument to.
//						Represents the name of the cover page to use
//						with tests.
//
//	pszBroadcast		OUT parameter.
//						Pointer to string to copy 5th argument to.
//						Represents a flag to indicate if to send a single 
//						or a broadcast job.
//
// Return Value:
//	TRUE on success and FALSE on failure.
//
//
BOOL 
ParseCmdLineParams(
	const INT	/* IN */	argc,
	CHAR *		/* IN */	argvA[],
	LPTSTR*		/* OUT */	pszServerName,
	LPTSTR*		/* OUT */	pszFaxNumber,
	LPTSTR*		/* OUT */	pszDocument,
	LPTSTR*		/* OUT */	pszCoverPage,
	LPTSTR*		/* OUT */	pszBroadcast
	)
{
	_ASSERTE(pszServerName);
	_ASSERTE(pszDocument);
	_ASSERTE(pszFaxNumber);
	_ASSERTE(pszCoverPage);
	_ASSERTE(pszBroadcast);

	DWORD	dwArgLoopIndex;
	DWORD	dwArgSize;
	LPTSTR	aszParam[MAX_ARGS];

	//
	// Check number of parameters
	//
	if ( ( argc != MAX_ARGS ) && ( argc != 2 ) )  
	{
		::_tprintf(TEXT("\nInvalid invokation of WindowsXPFaxSender.exe\n\n"));
		::_tprintf(TEXT("WindowsXPFaxSender.exe Help:\n"));
		::UsageInfo(); //UsageInfo() exits process.
	}

	//
	// Initialize awcsParam[]
	//
	for (dwArgLoopIndex = 0; dwArgLoopIndex < MAX_ARGS; dwArgLoopIndex++)
	{
		aszParam[dwArgLoopIndex] = NULL;
	}

	//
	// Loop on arguments in argvA[]
	//
    for (dwArgLoopIndex = 1; dwArgLoopIndex < (DWORD) argc; dwArgLoopIndex++) 
	{
		//
        // Determine the memory required for the parameter
		//
        dwArgSize = (::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(TCHAR);

		//
        // Allocate the memory for the parameter
		//
		_ASSERTE(g_hMainHeap);
        aszParam[dwArgLoopIndex] = (TCHAR*)::HeapAlloc(
			g_hMainHeap, 
			HEAP_ZERO_MEMORY, 
			dwArgSize
			);
		if(NULL == aszParam[dwArgLoopIndex])
		{
			::_tprintf(TEXT("FILE:%s LINE:%d\n HeapAlloc returned NULL\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFuncFail;
		}

		//
		// Copy content of argument from argvA[index] to new allocation
		//
#ifdef _UNICODE
		// argvA[] is a CHAR*, so it needs to be converted to a WCHAR* ifdef UNICODE
        // Convert awcsParam
		if (!::MultiByteToWideChar(
			CP_ACP, 
			0, 
			argvA[dwArgLoopIndex], 
			-1, 
			aszParam[dwArgLoopIndex], 
			(::lstrlenA(argvA[dwArgLoopIndex]) + 1) * sizeof(WCHAR))
			)
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n MultiByteToWideChar failed With GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#else //_MBCS
		::strcpy(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]);
		if (strcmp(aszParam[dwArgLoopIndex],argvA[dwArgLoopIndex]))
		{
			::_tprintf(
				TEXT("FILE:%s LINE:%d\n string copy or compare failed\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFuncFail;
		}
#endif
		//
		// Check for help switch
		//
		// If this is the second argument, it may be one of several help switches defined.
		// A help switch can appear only as the second argument.
        if (2 == argc)
		{
			if (! (!::lstrcmpi(HELP_SWITCH_1, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_2, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_3, aszParam[dwArgLoopIndex])) || 
				  (!::lstrcmpi(HELP_SWITCH_4, aszParam[dwArgLoopIndex]))
				) 
			{
				::_tprintf(TEXT("Invalid invokation of CometFaxSender.exe\n\n"));
			}
			::UsageInfo(); //UsageInfo() exits the process.
		}

		//
		// Treat each argument accordingly
		//
		switch (dwArgLoopIndex)
		{
		case ARGUMENT_IS_SERVER_NAME:
			//server_name param
			(*pszServerName) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_FAX_NUMBER:
			//fax_number1 param
			(*pszFaxNumber) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_DOC:
			//document param
			(*pszDocument) = aszParam[dwArgLoopIndex];
			break;

		case ARGUMENT_IS_CP:
			//cover_page param
			(*pszCoverPage) = aszParam[dwArgLoopIndex];
			break;
		
		case ARGUMENT_IS_BROADCAST:
			//broadcast param
			(*pszBroadcast) = aszParam[dwArgLoopIndex];
			break;

		default:
			::_tprintf(TEXT("FILE:%s LINE:%d\n default reached dwArgLoopIndex=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				dwArgLoopIndex
				);
			_ASSERTE(FALSE);
			return FALSE;
		}// switch (dwIndex)

	}//for (dwIndex = 1; dwIndex < (DWORD) argc; dwIndex++)


	//If all is well then we do NOT free 
	//pszServerName, pszFaxNumber1, pszFaxNumber2, pszDocument and pszCoverPage,
	//since these allocations were the purpose of the function.
	return(TRUE);

ExitFuncFail:

	//
	// Free allocations
	//
	DWORD i;
	//0 to MAX_ARGS is ok, since that is aszParam array size and we NULLed all of it first
	for (i=0; i<MAX_ARGS; i++) 
	{
		if (NULL == aszParam[i]) continue;
		if (FALSE == ::HeapFree(g_hMainHeap, 0, aszParam[i]))
		{
			::_tprintf(TEXT("FILE:%s LINE:%d loop#%d\nHeapFree returned FALSE with GetLastError()=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				i,
				::GetLastError()
				);
			return(FALSE);
		}
	}

	//
	//reset OUT parameters
	//
	(*pszServerName) = NULL;
	(*pszFaxNumber) = NULL;
	(*pszDocument) = NULL;
	(*pszCoverPage) = NULL;
	(*pszBroadcast) = NULL;

	return(FALSE);
}




//
// main body of application.
//
int __cdecl
main(
	INT   argc,
    CHAR  *argvA[]
)
{
	BOOL bRet = FALSE;
	int nReturnValue = 1; //"default" return value is to indicate error

	LPTSTR szServerName = NULL;
	LPTSTR szFaxNumber = NULL;
	LPTSTR szDocument = NULL;
	LPTSTR szCoverPage = NULL;
	LPTSTR szBroadcast = NULL;

	HINSTANCE hModWinfax = NULL;
	LPVOID pVoidTempFunc = NULL;

	//
	// Set g_hMainHeap to process heap
	//
	g_hMainHeap = NULL;
	g_hMainHeap = ::GetProcessHeap();
	if(NULL == g_hMainHeap)
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nGetProcessHeap returned NULL with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Parse the command line
	//
	bRet = ::ParseCmdLineParams(
		argc,
		argvA,
		&szServerName,
		&szFaxNumber,
		&szDocument,
		&szCoverPage,
		&szBroadcast
		);

	if (FALSE == bRet)
	{
		goto ExitFunc;
	}


	//
	// "Debug" printing of the command line parameters after parsing
	//
#ifdef _DEBUG
	::_tprintf(
		TEXT("DEBUG DEBUG DEBUG\nServer=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\nBroadcast=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage,
		szBroadcast
		);
#endif

	bRet = TestSuiteSetup(
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);
	
	if (FALSE == bRet)
	{
		goto ExitFunc;
	}

	if (0 == _tcsicmp(szBroadcast,TEXT("TRUE")))
	{
		//
		//Send a broadcast with CP (3 * same recipient)
		//
		bRet = TestCase2(			
			szServerName,
			szFaxNumber,
			szDocument,
			szCoverPage
			);
	}
	else
	{

		//
		//Send a single recp fax + CP
		//
		bRet = TestCase1(			
			szServerName,
			szFaxNumber,
			szDocument,
			szCoverPage
			);
	}


ExitFunc:
	
	//
	//We don't check the return code of TestSuiteShutdown() since we don't want to fail
	// the whole test case due to a problem with the logger.
	//
	TestSuiteShutdown();
	
	if (TRUE == bRet)
	{
		return(0);
	}
	else
	{
		return(1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxsender.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		FaxSender.cpp
// Author:			Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//


//
//	Description:
//		This file contains the implementation of class CFaxSender.
//


#include "FaxSender.h"



///////////////////////
// FAX_SENDER_STATUS //
///////////////////////

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CostrstreamEx& operator<<(
	IN OUT	CostrstreamEx&				os, 
	IN		const FAX_SENDER_STATUS&	SenderStatus)
{
	os<<endl;
	os<<"\tLastErrorFromFaxService:\t";
	
	if (ERROR_SUCCESS == SenderStatus.LastErrorFromFaxService)
	{
		os<<"ERROR_SUCCESS (0)";
	}
	else
	{
		CHAR strLastErr[20] = {0};
		::_ultoa(SenderStatus.LastErrorFromFaxService, strLastErr, 16);
		_ASSERTE(strLastErr[0]);
		os << strLastErr;
	}

	os<<endl;
	os<<"\tLastEventFromFaxQueue:\t\t";
	if (NULL == SenderStatus.pLastEventFromFaxQueue)
	{
		os<<"NO_FAX_EVENTS";
	}
	else
	{
		os<<(*SenderStatus.pLastEventFromFaxQueue);
	}

	return(os);
}

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CotstrstreamEx& operator<<(
	CotstrstreamEx&				/* IN OUT */	os, 
	const FAX_SENDER_STATUS&	/* IN */		SenderStatus)
{
	os << endl;
	os << TEXT("\tLastErrorFromFaxService:\t");
	if (ERROR_SUCCESS == SenderStatus.LastErrorFromFaxService)
	{
		os << TEXT("ERROR_SUCCESS (0)");
	}
	else
	{
		TCHAR tstrLastErr[20] = {0};
		::_ultot(SenderStatus.LastErrorFromFaxService, tstrLastErr, 16);
		_ASSERTE(tstrLastErr[0]);
		os << tstrLastErr;
	}

	os<<endl;
	os<<TEXT("\tLastEventExFromFaxQueue:\t\t");
	if (NULL == SenderStatus.pLastEventFromFaxQueue)
	{
		os<<TEXT("NO_FAX_EVENTS");
	}
	else
	{
		os<<(*SenderStatus.pLastEventFromFaxQueue);
	}

	return(os);
}


////////////////
// CFaxSender //
////////////////

#ifdef _NT5FAXTEST
	// Testing NT5 Fax (with old winfax.dll)
//
// private static member of CFaxSender
//
CFaxCompletionPort CFaxSender::m_TheFaxCompletionPort;
#endif

CFaxSender::CFaxSender(LPCTSTR szMachineName ):
	m_dwSendJobId(0),
	m_dwlSendJobMessageId(0),
	m_fSendSuccess(FALSE),
	m_szSendFileName(NULL),
	m_szCPFileName(NULL),
	m_szSendRecipientNumber(NULL)
{
	m_szMachineName = NULL; // do NOT remove this line or SetMachineName() assertion will fail
	if ( FALSE == SetMachineName(szMachineName))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d SetMachineName(%s) returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__,
			szMachineName
			);
		_ASSERTE(FALSE);
	}
	m_SendStatus.pLastEventFromFaxQueue = NULL;
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
}	


CFaxSender::~CFaxSender( void )
{
	delete(m_szMachineName);
	delete(m_szSendFileName);
	delete(m_szCPFileName);
	delete(m_szSendRecipientNumber);
}


//
// GetSendInfo:
//	Returns a const reference to instance member m_SendInfo.
//
const CSendInfo& CFaxSender::GetSendInfo( void ) const
{
	return(m_SendInfo);
}


//
// GetLastStatus:
//	Returns a const reference to instance member m_SendStatus.
//
const FAX_SENDER_STATUS& CFaxSender::GetLastStatus( void ) const
{
	return(m_SendStatus);	
}


//
// GetJobId:
//	Returns a const copy of instance member m_dwSendJobId.
//
const DWORD CFaxSender::GetJobId(void) const
{
	return(m_dwSendJobId);
}


//
// send:
//	Sends a fax synchronouslly and accumulates
//	every FAX_EVENT relevant to it. 
//	This implies that an I\O Completion Port 
//  is created and the Fax Service Queue is set
//	to post all FAX_EVENTs to it (see class
//	CFaxCompletionPort for details).
//
BOOL CFaxSender::send(
	LPCTSTR /* IN */ szFileName, 
	LPCTSTR /* IN */ szCPFileName, 
	LPCTSTR /* IN */ szRecipientNumber
	)
{
	DWORD dwLastError = ERROR_SUCCESS; 	// Used for Last error returned from call to ::SendFax

	//
	// Reset instance members
	//
	m_dwSendJobId = 0;
	m_fSendSuccess = FALSE;
	m_SendInfo.RemoveAll();
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
	m_SendStatus.pLastEventFromFaxQueue = NULL;

	//
	// Set filename and recipient number members to new values
	//
	BOOL fReturnValueOfSetSendFileName;
	BOOL fReturnValueOfSetCPFileName;
	BOOL fReturnValueOfSetSendRecipientNumber;
	fReturnValueOfSetSendFileName = SetSendFileName(szFileName);
	fReturnValueOfSetCPFileName = SetCPFileName(szCPFileName);
	fReturnValueOfSetSendRecipientNumber = SetSendRecipientNumber(szRecipientNumber);
	// If either of members could not be set return FALSE
	if ((FALSE == fReturnValueOfSetSendFileName) ||
		(FALSE == fReturnValueOfSetCPFileName) ||
		(FALSE == fReturnValueOfSetSendRecipientNumber))
	{
		return(FALSE);
	}

	// Get the completion port used with the Fax Service Queue
	HANDLE hCompletionPort = NULL;
	if (!m_TheFaxCompletionPort.GetCompletionPortHandle(
			m_szMachineName,
			hCompletionPort,
			m_SendStatus.LastErrorFromFaxService))
	{
		return(FALSE);
	}
	_ASSERTE(NULL != hCompletionPort);

	//
	// Send the fax
	//
	m_fSendSuccess = ::SendFax(
		m_szSendRecipientNumber,
		m_szSendFileName,
		m_szCPFileName,
		m_szMachineName,
		hCompletionPort,
		NULL,
		&m_dwSendJobId,
		&m_dwlSendJobMessageId,
		m_SendInfo,
		&dwLastError
		);

	//
	// Set m_SendStatus to new values
	//
	m_SendStatus.LastErrorFromFaxService = dwLastError;
#ifdef _NT5FAXTEST
// Legacy API
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwSendJobId);
#else
// Extended private API - MessageId is available
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwlSendJobMessageId);
#endif

	return(m_fSendSuccess);
}

//
// send_broadcast:
//	Sends a broadcast fax synchronouslly and accumulates
//	every FAX_EVENT relevant to it. 
//	This implies that an I\O Completion Port 
//  is created and the Fax Service Queue is set
//	to post all FAX_EVENTs to it (see class
//	CFaxCompletionPort for details).
//
BOOL CFaxSender::send_broadcast(
	LPCTSTR				/* IN */ szFileName, 
	CFaxBroadcast*		/* IN */ pmyFaxBroadcastObj
	)
{
	DWORD dwLastError = ERROR_SUCCESS; 	// Used for Last error returned from call to ::SendFax

	//
	// Reset instance members
	//
	m_dwSendJobId = 0;
	m_fSendSuccess = FALSE;
	m_SendInfo.RemoveAll();
	m_SendStatus.LastErrorFromFaxService = ERROR_SUCCESS;
	m_SendStatus.pLastEventFromFaxQueue = NULL;

	//
	// Set filename and recipient number members to new values
	//
	BOOL fReturnValueOfSetSendFileName;
	BOOL fReturnValueOfSetCPFileName;
	BOOL fReturnValueOfSetSendRecipientNumber;
	fReturnValueOfSetSendFileName = SetSendFileName(szFileName);
	fReturnValueOfSetCPFileName = SetCPFileName(NULL);
	fReturnValueOfSetSendRecipientNumber = SetSendRecipientNumber(NULL);
	// If either of members could not be set return FALSE
	if ((FALSE == fReturnValueOfSetSendFileName) ||
		(FALSE == fReturnValueOfSetCPFileName) ||
		(FALSE == fReturnValueOfSetSendRecipientNumber))
	{
		return(FALSE);
	}

	// Get the completion port used with the Fax Service Queue
	HANDLE hCompletionPort = NULL;
	if (!m_TheFaxCompletionPort.GetCompletionPortHandle(
			m_szMachineName,
			hCompletionPort,
			m_SendStatus.LastErrorFromFaxService))
	{
		return(FALSE);
	}
	_ASSERTE(NULL != hCompletionPort);

	//
	// Send the fax
	//
	m_fSendSuccess = ::SendFax(
		m_szSendRecipientNumber,
		m_szSendFileName,
		m_szCPFileName,
		m_szMachineName,
		hCompletionPort,
		(LPVOID)(pmyFaxBroadcastObj),
		&m_dwSendJobId,
		&m_dwlSendJobMessageId,
		m_SendInfo,
		&dwLastError
		);

	//
	// Set m_SendStatus to new values
	//
	m_SendStatus.LastErrorFromFaxService = dwLastError;

#ifdef _NT5FAXTEST
// Legacy API
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwSendJobId);
#else
// Extended private API - MessageId is available
	m_SendInfo.GetLastJobEvent(&m_SendStatus.pLastEventFromFaxQueue, m_dwlSendJobMessageId);
#endif

	return(m_fSendSuccess);
}

//
// abort:
//	Asynchronouslly aborts the send fax job with JobId equal to m_dwSendJobId.
//
// Note:
//	Since send() is synchronous, any synchronous abort() will fail.
//	Thus it only makes sense to call this method from a separate
//	thread (which has a reference to the instance).
//
// IMPORTANT:
//	Since the implementation of class CFaxSender is NOT thread safe
//	we choose that abort() will not change any of the instance's
//	members.
//	Thus the only way to tell whether the abort succeeded or failed 
//	is via the function's return value.
//
// Return Value:
//	TRUE if the request to abort succeeded.
//	Otherwise FALSE.
//
BOOL CFaxSender::abort(void)
{
	DWORD dwLastError;
	//We do not use dwLastError, since we just want
	//to log it, and ::AbortFax already does that for us.
	return(::AbortFax(m_szMachineName,m_dwSendJobId,&dwLastError));
}


//
// operator<<
//	Outputs a description of every one of the instance's 
//	members to the given stream.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const CFaxSender& /* IN */ Sender) 
{
	Sender.InsertAllButEventsIntoOs(os);
	os<<"Events:"<<endl;
	os<<Sender.m_SendInfo;
	return(os);
}

//
// operator<<
//	Outputs a description of every one of the instance's 
//	members to the given stream.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const CFaxSender& /* IN */ Sender) 
{
	Sender.InsertAllButEventsIntoOs(os);
	os<<TEXT("Events:")<<endl;
	os<<Sender.m_SendInfo;
	return(os);
}


//
// cstr:
//	Returns a string which contains all the instance's information.
//	
LPCTSTR CFaxSender::cstr(void) const
{
	CostrstreamEx myOs;

	myOs<<endl;
	myOs<<(*this); //use operator << of class to "print" to stream
	return(myOs.cstr());
	//above is OK since cstr() allocates string
}


//
// outputAllToLog:
//	Outputs a description of every one of the instance's 
//	members to the logger. Including ALL the events 
//	accumulated in the instance's m_SendInfo member.
//
void CFaxSender::outputAllToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
	) const
{
	CostrstreamEx os;

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance information"));

	os<<endl;
	InsertAllButEventsIntoOs(os);
	
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(dwSeverity,dwLevel,myStr);
	delete[]((LPTSTR)myStr);

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance fax events"));
	m_SendInfo.outputAllToLog(dwSeverity,dwLevel);

}


//
// outputJobToLog:
//	Outputs a description of every one of the instance's 
//	members to the logger.
//	ONLY the fax events with JobId equal to the instance's
//	m_dwSendJobId member are outputed to the logger (NOT ALL 
//	events).
//
void CFaxSender::outputJobToLog(
	const DWORD /* IN */ dwSeverity, 
	const DWORD /* IN */ dwLevel
	) const
{
	CostrstreamEx os;

	::lgLogDetail(dwSeverity,dwLevel,TEXT("Logging CFaxSender instance information"));

	os<<endl;
	InsertAllButEventsIntoOs(os);
	
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(dwSeverity,dwLevel,myStr);
	delete[]((LPTSTR)myStr);

	::lgLogDetail(
		dwSeverity,
		dwLevel,
		TEXT("Logging CFaxSender instance fax events for job#%d"),
		m_dwSendJobId);

#ifdef _NT5FAXTEST
// Legacy API
	// log event info (FAX_EVENT)
	m_SendInfo.outputJobToLog(m_dwSendJobId,dwSeverity,dwLevel);
#else
// Extended private API - MessageId is available
	// log extended event info (FAX_EVENT_EX)
	m_SendInfo.outputJobToLog(m_dwlSendJobMessageId,dwSeverity,dwLevel);
#endif

}


//
// SetSendFileName:
//	Sets the instance's m_szSendFileName to szStr.
//	A copy of szStr is created and m_szSendFileName
//	is set to point to it.
//
BOOL CFaxSender::SetSendFileName(LPCTSTR szStr)
{
	delete(m_szSendFileName);
	m_szSendFileName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szSendFileName = ::_tcsdup(szStr);
	if (NULL == m_szSendFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}
//
// SetCPFileName:
//	Sets the instance's m_szCPFileName to szStr.
//	A copy of szStr is created and m_szCPFileName
//	is set to point to it.
//
BOOL CFaxSender::SetCPFileName(LPCTSTR szStr)
{
	delete(m_szCPFileName);
	m_szCPFileName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szCPFileName = ::_tcsdup(szStr);
	
	if (NULL == m_szCPFileName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}
//
// SetMachineName:
//	Sets the instance's m_szMachineName to szStr.
//	A copy of szStr is created and m_szMachineName
//	is set to point to it.
//  This function is only called once from the
//	constructor.
//
BOOL CFaxSender::SetMachineName(LPCTSTR szStr)
{
	_ASSERTE(NULL == m_szMachineName);
	//m_szMachineName = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szMachineName = ::_tcsdup(szStr);
	if (NULL == m_szMachineName)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}


//
// SetSendRecipientNumber:
//	Sets the instance's m_szSendRecipientNumber to szStr.
//	A copy of szStr is created and m_szSendRecipientNumber
//	is set to point to it.
//
BOOL CFaxSender::SetSendRecipientNumber(LPCTSTR szStr)
{
	delete(m_szSendRecipientNumber);
	m_szSendRecipientNumber = NULL;

	if (NULL == szStr) return(TRUE);

	//dup
	m_szSendRecipientNumber = ::_tcsdup(szStr);
	if (NULL == m_szSendRecipientNumber)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(FALSE);
	}

	return(TRUE);
}

//
// InsertAllButEventsIntoOs:
//	Appends a string description of all the instance's members
//	except for m_SendInfo.
//
CostrstreamEx& CFaxSender::InsertAllButEventsIntoOs(IN OUT	CostrstreamEx&	os) const
{
	LPCSTR szConvertedStr;


	os<<"m_szMachineName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szMachineName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_dwSendJobId:\t\t"<<m_dwSendJobId<<endl;

	os<<"m_szSendFileName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szSendFileName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_szCPFileName:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szCPFileName);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_szSendRecipientNumber:\t";
	//stream takes MBCS only, so convert if necessary
	szConvertedStr = ::DupTStrAsStr(m_szSendRecipientNumber);
	if (NULL == szConvertedStr)
	{
		os<<"NULL"<<endl;
	}
	else
	{
		os<<szConvertedStr<<endl;
	}
	delete[] ((LPSTR)szConvertedStr);

	os<<"m_fSendSuccess:\t\t";
	if (TRUE == m_fSendSuccess)
	{
		os<<"TRUE"<<endl;
	}
	else
	{
		os<<"FALSE"<<endl;
	}

	os<<"m_SendStatus:\t\t";
	os<<m_SendStatus<<endl;

	return(os);
}

//
// InsertAllButEventsIntoOs:
//	Appends a string description of all the instance's members
//	except for m_SendInfo.
//
CotstrstreamEx& CFaxSender::InsertAllButEventsIntoOs(CotstrstreamEx& /* IN OUT */ os) const
{

	os << TEXT("m_szMachineName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szMachineName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szMachineName << endl;
	}

	os << TEXT("m_dwSendJobId:\t\t") << m_dwSendJobId << endl;

	os << TEXT("m_szSendFileName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szSendFileName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szSendFileName << endl;
	}

	os << TEXT("m_szCPFileName:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szCPFileName)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szCPFileName << endl;
	}

	os << TEXT("m_szSendRecipientNumber:\t");
	//stream takes MBCS only, so convert if necessary
	if (NULL == m_szSendRecipientNumber)
	{
		os << TEXT("NULL") << endl;
	}
	else
	{
		os << m_szSendRecipientNumber << endl;
	}

	os << TEXT("m_fSendSuccess:\t\t");
	if (TRUE == m_fSendSuccess)
	{
		os << TEXT("TRUE") << endl;
	}
	else
	{
		os<< TEXT("FALSE") << endl;
	}

	os << TEXT("m_SendStatus:\t\t");
	os << m_SendStatus << endl;

	return(os);
}

#ifndef _NT5FAXTEST
// Availlable in extended private API only
const DWORDLONG CFaxSender::GetMessageId(void) const
{
	return(m_dwlSendJobMessageId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\streamex.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename: streamEx.cpp
// Author:   Sigalit Bar
// Date:     22-Jul-98
//

//
//	Description:
//	This file contains the implementation of class CostrstreamEx.
//  
//  Modified on 19-Dec-99 by Miris: 
//	Added class CotstrstreamEx implementation.
// 
//


#include "streamEx.h"



//
// cstr:
//	Returns a const string representation of the stream
//	and resets the stream's insertion point to the start
//	of the stream's buffer.
//
LPCTSTR CostrstreamEx::cstr(void)
{
	//make sure there is an "end string"
	(*this)<<ends;
	
	//ostrstream::str() returns the pointer to the stream's buffer,
	//and freezes the buffer. We are responsible to either unfreeze
	//the array or free it ourselves. 
	//we choose to unfreeze (before we return), using reset().
	char* szStr = str();	
							
	//ostrstream::str() returns NULL on error, so do we.
	if (NULL == szStr) return(NULL);	

	//
	//Handle both UNICODE and MBCS
	//

	int len = lstrlenA(szStr);
	len = len + 1;

#ifdef _UNICODE

	//we need to allocate a wchar string 
	wchar_t* wscStr = new wchar_t[len];
	if (NULL == wscStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d malloc returned NULL\n"),
			TEXT(__FILE__),
			__LINE__);
		return(NULL);
	}

	//we need to convert the string to mb
	if ((size_t)(-1) == mbstowcs(wscStr, szStr, len))
	{
		//mbstowcs returns (size_t)(-1) on error
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d wcstombs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);

		return(NULL);
	}

	//we reset the stream buffer
	reset();

	return((LPCWSTR) wscStr);

#else //MBCS

	//we create our own copy of the stream's buffer and return it.
	char* szStr2;
	szStr2 = _tcsdup(szStr);
	if (NULL == szStr2)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

	//we reset the stream buffer
	reset();

	return((LPCSTR) szStr2);
#endif

}


//
// reset:
//	Unfreezes the stream's buffer (if it is frozen) and
//	resets the stream's buffer.
//	That is, the insertion point of the stream is reset
//	to the start of the stream's buffer (overwriting 
//	the buffer's contents), and the stream
//	is made submissive to changes.
//
void CostrstreamEx::reset(void)
{
	rdbuf()->freeze( 0 );
	seekp(0);
}




//
// cstr:
//	Returns a copy of const tstring representation of the stream.
//
LPCTSTR CotstrstreamEx::cstr(void)
{
	//ostrstream::str() returns the pointer to the stream's buffer,
	//and freezes the buffer. 
	tstring tszStr = str();	
							
	//ostrstream::str() returns NULL on error, so do we.
	if (NULL == tszStr.c_str()) return(NULL);	

	//we create our own copy of the stream's buffer and return it.
	TCHAR* tszStr2;
	tszStr2 = _tcsdup(tszStr.c_str());
	if (NULL == tszStr2)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

	return((LPCTSTR) tszStr2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\sendinfo.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		SendInfo.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CSendInfo which is designed to 
//		contain FAX_EVENT structures received 
//		from the NT5.0 Fax Service (winfax.h). 
//		Each instance of this class contains a
//		private list of FAX_EVENTs.
//
//		The class has methods that enable it to:
//		* Add a FAX_EVENT to a class instance.
//		* Remove All events from a class instance.
//		* Get the last event (related to a specific
//		  NT5.0 Fax Service job ID) from a class
//		  instance.
//		* Return all instance information in a string.
//		* Output instance information to logger.
//
//
//	The class uses the elle logger wraper implemented
//	in LogElle.c to log any fax related errors.
//	Streams are used for i/o handling (streamEx.cpp).
//
// Note:
//		This class uses logging functions (log.h)
//		therefor the logger must be initialized before
//		any call to these functions is made.
//		The functions using the logger are -
//			AddItem()
//			OutpoutAllToLog()
//			OutputJobToLog()
//

#ifndef _SEND_INFO_H_
#define _SEND_INFO_H_

#include <stdlib.h>
#include <stdio.h>
#include <TCHAR.H>
#include <list>

#include <windows.h>


#include <log.h>
#include "streamEx.h"


// Following are summary of definitions of some "function-like" macros:
//
//
//  Macro             _NT5FAXTEST defined                       _NT5FAXTEST not defined
//  ----------------  ---------------------------------------   -----------------------------------------------
//
//  MyGetJobId        receives FAX_JOB_ENTRY, returns JobId     receives FAX_JOB_ENTRY_EX, returns dwJobId
//
//  MyGetMsgId        receives FAX_JOB_ENTRY, returns JobId     receives FAX_JOB_ENTRY_EX, returns dwlMessageId
//
//  MyGetJobType      receives FAX_JOB_ENTRY, returns JobType   receives FAX_JOB_ENTRY_EX, returns dwJobType
//
//  MyGetEventMsgId   receives FAX_EVENT, returns JobId         receives FAX_EVENT_EX, returns dwlMessageId
//
//  MyGetEventType    receives FAX_EVENT, returns EventId       receives FAX_EVENT_EX, returns EventType


#ifdef _NT5FAXTEST
//
// Use legacy API
//

#include <WinFax.h>

// FAX_PERSONAL_PROFILE is defined in fxsapip.h and hence is unaccessible in _NT5FAXTEST mode.
// Since it's used all over FaxSender and CometBVT projects, we #include the definition here.
// Note, that this definition is local for FaxSender and ComentBVT and exists in _NT5FAXTEST mode
// only, when extended APIs are not used. In ! _NT5FAXTEST mode the original version of definition
// from fxsapip.h is used.
#include "PersonalProfile.h"

#include "FaxEvent.h"

typedef FAX_EVENT MY_FAX_EVENT;
typedef DWORD MY_MSG_ID;
#define MyGetEventMsgId(Event)	((Event).JobId)
#define MyGetEventType(Event)	((Event).EventId)

typedef PFAX_JOB_ENTRY PMY_FAX_JOB_ENTRY;
#define MyGetJobId(Job)								((Job).JobId)
#define MyGetMsgId(Job)								((Job).JobId)
#define MyGetJobType(Job)							((Job).JobType)
#define MyFaxEnumJobs(hServer, pBuffer, pCount) 	FaxEnumJobs((hServer), (pBuffer), (pCount))

#else // ! _NT5FAXTEST
//
// Use extended private API
//

#include <fxsapip.h>
#include "FaxEventEx.h"

typedef FAX_EVENT_EX MY_FAX_EVENT;
typedef DWORDLONG MY_MSG_ID;
#define MyGetEventMsgId(Event)	((Event).EventInfo.JobInfo.dwlMessageId)
#define MyGetEventType(Event)	((Event).EventType)

typedef PFAX_JOB_ENTRY_EX PMY_FAX_JOB_ENTRY;
#define MyGetJobId(Job)								((Job).pStatus->dwJobID)
#define MyGetMsgId(Job)								((Job).dwlMessageId)
#define MyGetJobType(Job)							((Job).pStatus->dwJobType)
#define MyFaxEnumJobs(hServer, pBuffer, pCount) 	FaxEnumJobsEx((hServer), JT_UNKNOWN | JT_SEND | JT_RECEIVE, (pBuffer), (pCount))

#endif // #ifdef _NT5FAXTEST


using namespace std ;

// CFaxEventList
// an STL list of FAX_EVENTs
#ifdef _C_FAX_EVENT_LIST_
#error "redefinition of _C_FAX_EVENT_LIST_"
#else
#define _C_FAX_EVENT_LIST_
typedef list< MY_FAX_EVENT > CFaxEventList;
#endif

//
// The "event id" returned for a non-existent event
// Used in function GetLastJobEvent()
// 
#define NO_FAX_EVENTS 0

class CSendInfo 
{
public:
	CSendInfo(void);
	~CSendInfo(void);

	//
	// AddItem:
	//	Creates a deep level copy of NewFaxEvent and places it at the end of the
	//	instance's private list of FAX_EVENT@s.
	//	The description of the added item is also logged with logging 
	//	level 9 to the logger in use.
	//
	// Parameters:
	//	NewFaxEvent		IN parameter.
	//					the FAX_EVENT@ that will be copied and 
	//					added to the list.
	// Return Value:
	//	TRUE if succeeded, FALSE otherwise.
	//
	BOOL AddItem(const MY_FAX_EVENT /* IN */ NewFaxEvent);

	//
	// RemoveAll:
	//	Removes all items from the instance's private list of
	//	FAX_EVENT@s and deallocates them.
	//
	void RemoveAll(void);

	//
	// GetLastJobEvent:
	//	Returns the last event in the instance's private list of
	//	FAX_EVENT@s, that is associated with Fax Service job ID,
	//	and its event ID.
	//
	// Parameters:
	//	dwJobId		IN parameter.
	//				the Fax Service job ID to look for in the instance's
	//				FAX_EVENTs list.
	//	LastEvent	OUT parameter.
	//				the last event in the instance's FAX_EVENT list that
	//				has a job ID equal to dwJobId.
	// Return Value:
	//	The LastEvent's EventId value.
	//	If there are no FAX_EVENT@s with desired JobId,
	//	then the function returns NO_FAX_EVENTS.
	//
	DWORD GetLastJobEvent(
		MY_FAX_EVENT**	/* OUT */	ppLastEvent, 
		MY_MSG_ID		/* IN  */	MsgId
		) const;

	//
	// cstr:
	//	Returns a string which contains all the instance's information.
	//	
	// Return Value:
	//	The formated string describing every FAX_EVENT@ in the instance's 
	//	list.
	//	This string is allocated by the function and should be freed by
	//	the caller.
	//
	LPCTSTR cstr(void) const;

	//
	// outputAllToLog:
	//	Outputs a description of all the FAX_EVENT@s in the instance's
	//	list to the logger in use.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD		/* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD		/* IN */	dwLevel = 1
		) const;

	//
	// outputJobToLog:
	//	Outputs a description of those FAX_EVENT@s in the instance's
	//	list that have JobId field equal to dwJobId, to the logger in use.
	//
	// Parameters:
	//	dwJobId			IN parameter.
	//					the job ID whose FAX_EVENT@s are to be outputed 
	//					to the logger.
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputJobToLog(
		MY_MSG_ID		/* IN */	MsgId, 
		const DWORD		/* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD		/* IN */	dwLevel = 1
		) const;

	//
	// operator<<:
	//	Outputs a description of all the FAX_EVENTs in the instance's
	//	list to (the stream) os.
	//
	// Parameters:
	//	os			IN OUT parameter.
	//				the stream to which the description is appended.
	//	SendInfo	IN parameter.
	//				the CSendInfo instance whose description will be
	//				appended to the stream.
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&		/* IN OUT */	os, 
		const CSendInfo&	/* IN */		SendInfo
		);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&		/* IN OUT */	os, 
		const CSendInfo&	/* IN */		SendInfo
		);

private:

	// a list of FAX_EVENT@s
	CFaxEventList m_EventList;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\sendinfo.cpp ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		SendInfo.cpp
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//


//
//	Description:
//		This file contains the implementation of class CSendInfo.
//


#include "SendInfo.h"

CSendInfo::CSendInfo(void)
{
}

CSendInfo::~CSendInfo(void)
{
	RemoveAll();
}


//
// AddItem:
//	Creates a copy of NewFaxEvent and places it at the end of the
//	instance's private list of FAX_EVENT@s.
//
//	The description of the added item is logged with logging level 9.
//
BOOL CSendInfo::AddItem(const MY_FAX_EVENT /* IN */ NewFaxEvent)
{
	BOOL			fRetVal = FALSE;
	MY_FAX_EVENT*	pFaxEvent = NULL;
	LPCTSTR pszLogStr;	// string to be given to logging function
	CotstrstreamEx os;	// stream to append list description to

#ifdef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT
	pFaxEvent = &NewFaxEvent;
#else
// MY_FAX_EVENT is FAX_EVENT_EX
	if (FALSE == CopyFaxExtendedEvent(&pFaxEvent, NewFaxEvent))
	{
		goto ExitFunc;
	}
#endif

	_ASSERTE(pFaxEvent);

	//
	// Add to list (copy and add at end of list)
	//
	m_EventList.push_back(*pFaxEvent);

#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
	// we can now free the FAX_EVENT_EX that CopyFaxExtendedEvent allocated
	// since push_back copied it
	// note - we don't free what the FAX_EVENT_EX pointer members are pointing at
	//		  just the Fax_EVENT_EX struct itself
	free(pFaxEvent);
#endif

	//
	// Log a description of the event (logging level 9)
	//
	os<<endl;
	os<<TEXT("FaxEvent#")<<m_EventList.size()<<TEXT(":")<<endl;	//append list size to stream
	os<<TEXT("***********************************************")<<endl;
	os<<NewFaxEvent<<endl;	//append list description

	pszLogStr = os.cstr(); //convert stream to a string (cstr() allocates and caller frees)
	::lgLogDetail(LOG_SEVERITY_DONT_CARE, 9, pszLogStr); //log
	delete[]((LPTSTR)pszLogStr); //free string that cstr() allocated

	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}


//
// RemoveAll:
//	Removes all items from the instance's private list of
//	FAX_EVENTs and deallocates them.
//
void CSendInfo::RemoveAll(void)
{
#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
	CFaxEventList::iterator eventIterator;
	int index;
	for (index = 1, eventIterator = m_EventList.begin(); 
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		MY_FAX_EVENT* pFaxEvent = &(*eventIterator);
		FreeFaxExtendedEvent(pFaxEvent);
	}
#endif

	m_EventList.clear();
}
	

//
// GetLastJobEvent:
//	Returns the last event in the instance's private list of
//	FAX_EVENT@s, that is associated with Fax Service job ID,
//	and its event ID.
//
// Parameters:
//	MsgId		IN parameter.
//				the Fax Service job ID to look for in the instance's
//				FAX_EVENT@s list.
//	LastEvent	OUT parameter.
//				the last event in the instance's FAX_EVENT@ list with
//				desired MsgId.
// Return Value:
//  For FAX_EVENT    - EventId
//  For FAX_EVENT_EX - EventType
//	If there are no FAX_EVENT@s with desired MsgId,
//	then the function returns NO_FAX_EVENTS.
//
DWORD CSendInfo::GetLastJobEvent(MY_FAX_EVENT** /* OUT */ ppLastEvent, MY_MSG_ID /* IN  */ MsgId) const
{
	_ASSERTE(ppLastEvent);

	if (0 == m_EventList.size())
	{
		return(NO_FAX_EVENTS);
	}

	_ASSERTE(MsgId != 0);

	//goes over list from finish to start,
	//returning first event with matching MsgId
	//in OUT param LastEvent
	CFaxEventList::const_iterator eventIterator;
	for (eventIterator = m_EventList.end(); 
		 eventIterator != m_EventList.begin(); 
		 eventIterator--) 
	{

#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
		if (! ((FAX_EVENT_TYPE_OUT_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_OUT_ARCHIVE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_ARCHIVE == eventIterator->EventType)
			  )
		   )
		{
			// this (extended) event does not have a msg id
			continue;
		}
#endif
		// this event has a MsgId
		if (MyGetEventMsgId(*eventIterator) != MsgId) 
		{
			// this is not our MsgId
			continue;
		}

		// found first event with MsgId
		(*ppLastEvent) = const_cast<MY_FAX_EVENT*>(&(*eventIterator));
		return(MyGetEventType(*eventIterator));
	}

	return(NO_FAX_EVENTS);
}


//
// cstr:
//	Returns a string which contains all the instance's information.
//
//  String is allocated by function and should be freed by caller.
//	
LPCTSTR CSendInfo::cstr(void) const
{
	CostrstreamEx myOs;	//stream to append description of list to

	myOs << endl;
	myOs << (*this);	//append list description to stream

	return(myOs.cstr());//CostrstreamEx::cstr() returns copy of stream buffer
						//it allocates string, caller should free.
}


//
// operator<<:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to (the stream) os.
//
CostrstreamEx& operator<<(CostrstreamEx& /* IN OUT */ os, const CSendInfo& /* IN */ SendInfo)
{
	if (0 == SendInfo.m_EventList.size())
	{
		os<<TEXT("No Fax Events")<<endl;
	}

	CFaxEventList::const_iterator eventIterator;
	int index;
	for (index = 1, eventIterator = SendInfo.m_EventList.begin(); 
		 eventIterator != SendInfo.m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //append event number
		os << (*eventIterator) <<endl; //append event to stream
	}

	return(os);
}


//
// operator<<:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to (the stream) os.
//
CotstrstreamEx& operator<<(CotstrstreamEx& /* IN OUT */ os, const CSendInfo& /* IN */ SendInfo)
{
	if (0 == SendInfo.m_EventList.size())
	{
		os<<TEXT("No Fax Events")<<endl;
	}

	CFaxEventList::const_iterator eventIterator;
	int index;
	for (index = 1, eventIterator = SendInfo.m_EventList.begin(); 
		 eventIterator != SendInfo.m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //append event number
		os << (*eventIterator) <<endl; //append event to stream
	}

	return(os);
}


//
// outputAllToLog:
//	Outputs a description of all the FAX_EVENT@s in the instance's
//	list to the logger in use.
//
void CSendInfo::outputAllToLog(const DWORD /* IN */ dwSeverity, const DWORD /* IN */ dwLevel) const
{
	CostrstreamEx os;

	if (0 == m_EventList.size())
	{
		::lgLogDetail(dwSeverity,dwLevel,TEXT("No Fax Events"));
	}

	LPCTSTR szLogStr;	//string to be sent to logger

	CFaxEventList::const_iterator eventIterator;
	int index;

	for (index = 1, eventIterator = m_EventList.begin();
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //appending event number to stream
		os << (*eventIterator) <<endl;	//appending event description to stream

		//CostrstreamEx::cstr() returns copy of stream buffer
		//it allocates string, caller should free.		
		szLogStr = os.cstr();	
								
		::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
		delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())
	}
}


//
// outputJobToLog:
//	Outputs a description of those FAX_EVENT_EXs in the instance's
//	list that have MsgId field equal to dwlMsgId, to the logger in use.
//
void CSendInfo::outputJobToLog(
	const MY_MSG_ID	/* IN */ MsgId, 
	const DWORD		/* IN */ dwSeverity, 
	const DWORD		/* IN */ dwLevel
	) const
{
	CostrstreamEx os;
	LPCTSTR szLogStr = NULL; //string to be sent to logger
	int index = 0;

	if (0==m_EventList.size())
	{
		::lgLogDetail(dwSeverity,dwLevel,TEXT("No Fax Events"));
		return;
	}

	CFaxEventList::const_iterator eventIterator;
	for (index = 1, eventIterator = m_EventList.begin(); 
		 eventIterator != m_EventList.end(); 
		 index++, eventIterator++
		) 
	{
#ifndef _NT5FAXTEST
// MY_FAX_EVENT is FAX_EVENT_EX
		if (! ((FAX_EVENT_TYPE_OUT_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_QUEUE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_OUT_ARCHIVE == eventIterator->EventType) ||
			   (FAX_EVENT_TYPE_IN_ARCHIVE == eventIterator->EventType)
			  )
		   )
		{
			// this (extended) event does not have a msg id
			continue;
		}
#endif
		// this event has a MsgId
		if (MyGetEventMsgId(*eventIterator) != MsgId) 
		{
			// this is not our MsgId
			continue;
		}
		// found event with MsgId
		os << TEXT("FaxEvent#")<<index<<TEXT(":")<<endl; //appending event number to stream
		os << (*eventIterator) <<endl;	//appending event description to stream

		szLogStr = os.cstr();	//CostrstreamEx::cstr() returns copy of stream buffer
								//it allocates string, caller should free.
		::lgLogDetail(dwSeverity,dwLevel,szLogStr); //log event string
		delete[]((LPTSTR)szLogStr); //free string (allocated by CostrstreamEx::cstr())
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\faxsender.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Module name:		FaxSender.h
// Module author:	Sigalit Bar (sigalitb)
// Date:			23-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CFaxSender. This class was designed
//		to allow for tailored fax related actions
//		using the NT5.0 Fax Service API (winfax.h).
//
//		The class has methods that enable it to:
//		* Get a const reference to private members
//		  m_SendInfo, m_dwSendJobId and m_SendStatus.
//		* Output instance information to the logger.
//		* Output instance information to a stream (CotstrstreamEx).
//		* Return a string description of the instance.
//		* Send a fax synchronouslly and accumulate
//		  every FAX_EVENT relevant to it.
//		* Abort a fax asynchronouslly.
//
//		The class uses the elle logger wraper implemented
//		in LogElle.c to log any fax related errors.
//
//		Streams are used for i/o handling (streamEx.cpp).
//


#ifndef _FAX_SENDER_H_
#define _FAX_SENDER_H_

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>
#include "streamEx.h"
#include "SendInfo.h"
#include "CometFax.h"

#include "FaxCompPort.h"
#include "wcsutil.h"

//
// FAX_SENDER_STATUS
//
typedef struct _FAX_SENDER_STATUS
{
	MY_FAX_EVENT	*pLastEventFromFaxQueue;	
	DWORD			LastErrorFromFaxService;
} FAX_SENDER_STATUS, *PFAX_SENDER_STATUS;

//
//	operator<< (for struct FAX_SENDER_STATUS)
//
CostrstreamEx& operator<<(
	IN OUT	CostrstreamEx&				os, 
	IN		const FAX_SENDER_STATUS&	SenderStatus);

CotstrstreamEx& operator<<(
	CotstrstreamEx&				/* IN OUT */	os, 
	const FAX_SENDER_STATUS&	/* IN */		SenderStatus);


//
// CFaxSender
//
class CFaxSender
{
public:

	//
	// CFaxSender:
	//	Constructor.
	//
	// Parameters:
	//	szMachineName	IN Parameter.
	//					Default value of parameter is NULL.
	//					A string representing the name of the Fax Server we want to
	//					use. 
	//					This parameter may be the name of a machine (without the \\)
	//					on which a Fax Service is installed, or NULL to indicate the
	//					local Fax Service.
	//
	CFaxSender(LPCTSTR /* IN */ szMachineName = NULL);

	//
	// ~CFaxSender:
	//
	~CFaxSender( void );

	//
	// send:
	//	Sends a fax synchronouslly and accumulates
	//	every FAX_EVENT relevant to it. 
	//	This implies that an I\O Completion Port 
	//  is created and the Fax Service Queue is set
	//	to post all FAX_EVENTs to it (see class
	//	CFaxCompletionPort for details).
	//
	// Parameters:
	//	szFileName			IN parameter.
	//						Name of file to send in fax.
	//	szRecipientNumber	IN parameter.
	//						Number of fax to send fax to.
	//
	// Return Value:
	//	This function returnes TRUE if the fax sending was completed successfully. 
	//	That includes -
	//	1. The fax send job was successfully queued to the Fax Service Queue,
	//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
	//	   and that szFaxNumber is a valid telephone number.
	//	2. The job was successfully executed by the Fax Service, that is, the fax
	//	   session took place and completed successfully.
	//	Otherwise returns FALSE.
	//
	BOOL send(
		LPCTSTR /* IN */ szFileName, 
		LPCTSTR /* IN */ szCPFileName, 
		LPCTSTR /* IN */ szRecipientNumber
		);

	
	//
	// send_broadcast:
	//	Sends a broadcast fax synchronouslly and accumulates
	//	every FAX_EVENT relevant to it. 
	//	This implies that an I\O Completion Port 
	//  is created and the Fax Service Queue is set
	//	to post all FAX_EVENTs to it (see class
	//	CFaxCompletionPort for details).
	//
	// Parameters:
	//	szFileName			IN parameter.
	//						Name of file to send in fax.
	//	myFaxBroadcastObj	IN parameter.
	//						The broadcast object. Contains the numbers
	//						of all recipients and the cover page.
	//
	// Return Value:
	//	This function returnes TRUE if the fax sending was completed successfully. 
	//	That includes -
	//	1. The fax send job was successfully queued to the Fax Service Queue,
	//	   which also implies that szFaxNumber and szDocumentName are both not NULL,
	//	   and that szFaxNumber is a valid telephone number.
	//	2. The job was successfully executed by the Fax Service, that is, the fax
	//	   session took place and completed successfully.
	//	Otherwise returns FALSE.
	//
	BOOL send_broadcast(
		LPCTSTR				/* IN */ szFileName, 
		CFaxBroadcast*		/* IN */ pmyFaxBroadcastObj
		);

	
	//
	// abort:
	//	Asynchronouslly aborts the send fax job with JobId equal to m_dwSendJobId.
	//
	// Note:
	//	Since send() is synchronous, any synchronous abort() will fail.
	//	Thus it only makes sense to call this method from a separate
	//	thread (which has a reference to the instance).
	//
	// IMPORTANT:
	//	Since the implementation of class CFaxSender is NOT thread safe
	//	(the class members are not protected to prevent simultaneous access)
	//	we choose that abort() will not change any of the instance's
	//	members.
	//	Thus the only way to tell whether the abort succeeded or failed 
	//	is via the function's return value.
	//
	// Return Value:
	//	TRUE if the request to abort succeeded.
	//	Otherwise FALSE.
	//
	BOOL abort(void);


	//
	// GetSendInfo:
	//	Returns a const reference to instance member m_SendInfo.
	//
	const CSendInfo& GetSendInfo( void ) const;


	//
	// GetJobId:
	//	Returns a const copy of instance member m_dwSendJobId.
	//
	const DWORD GetJobId(void) const;

	
	//
	// GetMessageId:
	//	Returns a const copy of instance member m_dwlSendJobMessageId.
	//
	const DWORDLONG GetMessageId(void) const;

	
	//
	// GetLastStatus:
	//	Returns a const reference to instance member m_SendStatus.
	//
	const FAX_SENDER_STATUS& GetLastStatus( void ) const;


	//
	// cstr:
	//	Returns a string which contains all the instance's information.
	//	
	// Return Value:
	//	The formated string describing every one of the instance's 
	//	members.
	//	This string is allocated by the function and should be freed by
	//	the caller.
	//
	LPCTSTR cstr(void) const;


	//
	// outputAllToLog:
	//	Outputs a description of every one of the instance's 
	//	members to the logger. Including ALL the events 
	//	accumulated in the instance's m_SendInfo member.
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputAllToLog(
		const DWORD /* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD /* IN */	dwLevel = 1
		) const;


	//
	// outputJobToLog:
	//	Outputs a description of every one of the instance's 
	//	members to the logger.
	//	ONLY the fax events with JobId equal to the instance's
	//	m_dwSendJobId member are outputed to the logger (NOT ALL 
	//	events).
	//
	// Parameters:
	//	dwSeverity		IN parameter.
	//					the severity level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ LOG_PASS, 
	//					  LOG_X, LOG_SEVERITY_DONT_CARE,
	//					  LOG_SEV_1, LOG_SEV_2, LOG_SEV_3, LOG_SEV_4 } 
	//	dwLevel			IN parameter.
	//					the logging level with which the information
	//					will be logged in the logger.
	//					Value is one of 
	//					{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }
	//
	void outputJobToLog(
		const DWORD /* IN */	dwSeverity = LOG_SEVERITY_DONT_CARE, 
		const DWORD /* IN */	dwLevel = 1
		) const;


	//
	// operator<<
	//	Outputs a description of every one of the instance's 
	//	members to the given stream.
	//
	// Parameters:
	//	os		IN OUT parameter.
	//			Stream to append the descriptive string to.
	//	Sender	A const reference to the CFaxSender instance whose
	//			descriptive string we want to append to the stream.
	//
	// Return Value:
	//	A reference to the updated stream (os).
	//
	friend CostrstreamEx& operator<<(
		CostrstreamEx&		/* IN OUT */	os, 
		const CFaxSender&	/* IN */		Sender);

	friend CotstrstreamEx& operator<<(
		CotstrstreamEx&		/* IN OUT */	os, 
		const CFaxSender&	/* IN */		Sender);

private:

	// The machine name on which the Fax Server is located.
	// This member is set during creation and cannot be changed.
	LPTSTR				m_szMachineName;

	// The I\O Completion Port used to "communicate" with
	// the Fax Service Queue.
#ifndef _NT5FAXTEST
	// Testing Bos Fax (with new fxsapi.dll)
	CFaxCompletionPort	m_TheFaxCompletionPort;
#else
	// Testing NT5 Fax (with old winfax.dll)
	static CFaxCompletionPort	m_TheFaxCompletionPort;
#endif

	// A CSendInfo instance used to accumulate all the
	// FAX_EVENT@s received via the Queue completion port.
	CSendInfo			m_SendInfo;

	// The Fax Service JobId of the job corresponding to
	// the last call to the instance's send() method.
	DWORD				m_dwSendJobId;

#ifndef _NT5FAXTEST
	// The Fax Service Msg Id of the message corresponding to
	// the last call to the instance's send() method.
	// Availlable in extended private API only
	DWORDLONG			m_dwlSendJobMessageId;
#endif

	// The filename corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szSendFileName;

	// The filename corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szCPFileName;

	// The fax number corresponding to
	// the last call to the instance's send() method.
	LPTSTR				m_szSendRecipientNumber;

	// An indication of whether the last call to
	// the instance's send() method succeeded or failed.
	// TRUE for success and FALSE for failure.
	BOOL				m_fSendSuccess;

	// The last fax related error and the eventId of the
	// last FAX_EVENT, corresponding to the last call to
	// the instance's send() method.
	FAX_SENDER_STATUS	m_SendStatus;


	//
	// SetSendFileName:
	//	Sets the instance's m_szSendFileName to szStr.
	//	A copy of szStr is created and m_szSendFileName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szSendFileName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetSendFileName(LPCTSTR szStr);

	//
	// SetCPFileName:
	//	Sets the instance's m_szCPFileName to szStr.
	//	A copy of szStr is created and m_szCPFileName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szCPFileName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetCPFileName(LPCTSTR szStr);

	//
	// SetMachineName:
	//	Sets the instance's m_szMachineName to szStr.
	//	A copy of szStr is created and m_szMachineName
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szMachineName to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetMachineName(LPCTSTR szStr);
	
	//
	// SetSendRecipientNumber:
	//	Sets the instance's m_szSendRecipientNumber to szStr.
	//	A copy of szStr is created and m_szSendRecipientNumber
	//	is set to point to it.
	//
	// Parameters:
	//	szStr	string to set m_szSendRecipientNumber to.
	//
	// Return Value:
	//	TRUE if set is successful and FALSE otherwise.
	//
	BOOL SetSendRecipientNumber(LPCTSTR szStr);


	//
	// InsertAllButEventsIntoOs:
	//	Appends a string description of all the instance's members
	//	except for m_SendInfo.
	//
	// Parameters:
	//	os		IN OUT parameter.
	//			Stream to append the instance's descriptive string to.
	//
	// Return Value:
	//	The updated stream (os).
	//
	CostrstreamEx& InsertAllButEventsIntoOs(CostrstreamEx&  /* IN OUT */ os) const;
	CotstrstreamEx& InsertAllButEventsIntoOs(CotstrstreamEx&  /* IN OUT */ os) const;

};



#endif  //_FAX_SENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\streamex.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

//
// Filename: streamEx.h
// Author:   Sigalit Bar
// Date:     22-Jul-98
//

//
// Description:
//		This file contains the description of 
//		class CostrstreamEx which is designed  
//		to make handling of string streams easier. 
//		This class adds two more methods over its
//		base class (the STL ostrstream). 
//
//		The class has methods that enable it to:
//		* Do whatever an ostrstream instance can do.
//		* Return the stream's string representation.
//		* Reset the stream.
//
//
//	The class uses the elle logger wraper implemented
//	in LogElle.c to log errors. Therefor the logger
//	must be initialized before calling any of its methods.
//
//
//
//  Modified on 19-Dec-99 by Miris: 
//	Added declaration of class CotstrstreamEx derived from otstringstream.
//  The class allows tstring manipulation and does not convert unicode strings
//  to multibytes strings
//  
//  	The class has methods that enable it to:
//		* Do whatever an otstringstream instance can do.
//		* Return the stream's string representation.

//	The class uses the elle logger wraper implemented
//	in LogElle.c to log errors. Therefor the logger
//	must be initialized before calling any of its methods.
//
//  This class supports the functionality of CostrstreamEx, however we do
//  keep CostrstreamEx declarations since othere tests use it.
//
//


#ifndef _STREAM_EX_H_
#define _STREAM_EX_H_

#include <tstring.h>

using namespace std;

#include <log.h>


class CostrstreamEx : public ostrstream
{
public:
	CostrstreamEx(void) {};
	~CostrstreamEx(void) {};

	//
	// cstr:
	//	Returns a const string representation of the stream
	//	and resets the stream's insertion point to the start
	//	of the stream's buffer.
	//
	// Note:
	//  This function returns a COPY of the stream's buffer
	//	and resets the stream's buffer.
	//	This has two implications-
	//	A. This function allocates memory for the string it
	//     returns, and the caller is responsible to free it.
	//	B. After a call to this function the stream's buffer
	//	   is reset, that is the insertion point of the stream
	//	   is reset to the start of the stream's buffer
	//	   (overwriting the buffer's contents).
	//
	// Another Note:
	//	cstr automatically appends an "ends" (end string) 
	//	to the stream before converting the buffer to a 
	//	string (ostrstream.str() does not).
	//
	// Example:
	//	The following code -
	//		CstrstreamEx os;
	//		LPCTSTR str;
	//		os<<"ABC";
	//		os<<"123"<<endl;
	//		str = os.cstr();
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//		os<<"ZXW";
	//		os<<"987"<<endl;
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//	Will produce the output-
	//		str=ABC123
	//		str=ZXW987
	//
	LPCTSTR cstr(void);


	//
	// reset:
	//	Unfreezes the stream's buffer (if it is frozen) and
	//	resets the stream's buffer.
	//	That is, the insertion point of the stream is reset
	//	to the start of the stream's buffer (overwriting 
	//	the buffer's contents), and the stream
	//	is made submissive to changes.
	//
	void reset(void);

};

class CotstrstreamEx : public otstringstream
{
public:
	CotstrstreamEx(void) {};
	~CotstrstreamEx(void) {};

	//
	// cstr:
	//	Returns a const tstring representation of the stream
	//	and resets the stream's insertion point to the start
	//	of the stream's buffer.
	//
	// Note:
	//  This function returns a COPY of the stream's buffer
	//	and resets the stream's buffer.
	//	This has two implications-
	//	A. This function allocates memory for the string it
	//     returns, and the caller is responsible to free it.
	//	B. After a call to this function the stream's buffer
	//	   is reset, that is the insertion point of the stream
	//	   is reset to the start of the stream's buffer
	//	   (overwriting the buffer's contents).
	//
	// Another Note:
	//	cstr automatically appends an "ends" (end string) 
	//	to the stream before converting the buffer to a 
	//	string (ostrstream.str() does not).
	//
	// Example:
	//	The following code -
	//		CtstrstreamEx os;
	//		LPCTSTR str;
	//		os<<TEXT("ABC");
	//		os<<TEXT("123")<<endl;
	//		str = os.cstr();
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//		os<<TEXT("ZXW");
	//		os<<TEXT("987")<<endl;
	//		_tprintf(TEXT("str=%s\n"),str);
	//		delete[](str);
	//	Will produce the output-
	//		str=ABC123
	//		str=ZXW987
	//
	LPCTSTR cstr(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\test.h ===
//
//
// Filename:	test.h
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#ifndef _TEST_H_
#define _TEST_H_

#include <windows.h>
#include <fxsapip.h>

#include <TCHAR.H>
#include "crtdbg.h"

#include <log.h>
#include "FaxSender.h"


#ifdef __cplusplus
extern "C" {
#endif

#define TEST_ARCHIVE_DIR	TEXT("C:\\CometBVT\\FaxBVT\\Faxes\\SentFaxes")
#define TEST_MIN_PORTS		1

#define MY_FPF_NONE			0

#define DEV1_TSID			TEXT("CometFax dev1")
#define DEV1_CSID			TEXT("CometFax dev1")
#define DEV2_TSID			TEXT("CometFax dev2")
#define DEV2_CSID			TEXT("CometFax dev2")
#define DEV_TSID			TEXT("CometFax dev>2")
#define DEV_CSID			TEXT("CometFax dev>2")

//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber		IN parameter
//					Phone number of first device installed on server.
//					Will be set up as sending device.
//
//	szDocument		IN parameter
//					Filename of document to be used in tests.
//					The function only prints this string to logger (for debugging).
//
//	szCoverPage		IN parameter
//					Filename of cover page to be used in tests.
//					The function only prints this string to logger (for debugging).
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase1:
//	Send a fax + CP.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber		IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestCase2:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to setup.
//  
//	szFaxNumber 	IN parameter
//					Phone number to send faxes to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
BOOL WINAPIV TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);

//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
BOOL WINAPIV TestSuiteShutdown(void);



#ifdef __cplusplus
}
#endif 

#endif //_TEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\wcsutil.cpp ===
//
//
// Filename:	wcsutil.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//

#include "wcsutil.h"


//
// DupTStrAsStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
LPCSTR DupTStrAsStr(LPCTSTR /* IN */ str)
{

	if (NULL == str) return(NULL);
	char* szStr = NULL;

#ifdef UNICODE
	int len = ::wcslen(str) + 1;
	szStr = new char[len];
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d new returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(NULL);
	}
	szStr[len-1] = NULL;
	if ((size_t)(-1) == ::wcstombs(szStr, str, len))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d wcstombs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#else
	szStr = ::_tcsdup(str);
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdupreturned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#endif

	//caller must free this allocation
	return(szStr);
}

//
// DupTStrAsWStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CWSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
LPCWSTR DupTStrAsWStr(LPCTSTR /* IN */ str)
{

	if (NULL == str) return(NULL);
	wchar_t* szStr = NULL;

#ifdef UNICODE
	szStr = ::_tcsdup(str);
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d _tcsdup returned NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}
#else
	int len = ::strlen(str) + 1;
	szStr = new wchar_t[len];
	if (NULL == szStr)
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d new returned NULL with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			GetLastError()
			);
		return(NULL);
	}
	szStr[len-1] = NULL;
	if ((size_t)(-1) == ::mbstowcs(szStr, str, len))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d mbstowcs returned -1 (cannot convert)\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(NULL);
	}

#endif

	//caller must free this allocation
	return(szStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\wcsutil.h ===
//
//
// Filename:	wcsutil.h
// Author:		Sigalit Bar (sigalitb)
// Date:		6-Jan-99
//
//



#ifndef _WCS_UTIL_H_
#define _WCS_UTIL_H_


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <TCHAR.H>

#include <log.h>

//
// DupTStrAsStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
// Parameters:
//	str		The string to be duplicated
//
// Return Value:
//	A new allocation containing the required convertion.
//	If an error occured the return value is NULL.
//
// Note:
//	Even if no actual convertion took place, new memory is allocated.
//
LPCSTR DupTStrAsStr(LPCTSTR /* IN */ str);


//
// DupTStrAsWStr:
//	Duplicates a CTSTR (CWSTR or CSTR) as a CWSTR.
//	The needed memory is allocated and the needed convertion is made.
//	The caller is responsible to free the returned string.
//
// Parameters:
//	str		The string to be duplicated
//
// Return Value:
//	A new allocation containing the required convertion.
//	If an error occured the return value is NULL.
//
// Note:
//	Even if no actual convertion took place, new memory is allocated.
//
LPCWSTR DupTStrAsWStr(LPCTSTR /* IN */ str);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\elle.h ===
/*
 -  ELLE.H
 -
 *  Purpose:
 *      Header file for the Mac version of the ELLE Logging system.
 *
 *
 */

#ifndef _ELLE_
#define _ELLE_


#include <windows.h>

typedef unsigned long   ULONG;

#ifdef WIN32
#define _export
#endif


// Other defines
#define MAXERRMSG      256


// ELLE CallBack type needs to include void* parameter so compiler
// knows how to properly clean the stack after the call.
typedef void (_export CALLBACK *ELLECALLBACK)(void *);


/*
 -  LSQL
 -
 *  Purpose:
 *      The contents of this data structure describe an SQL logging
 *      session in the ELLE sub-system.
 */

typedef struct _lsql
{
    BOOL    fSQLParse;                // specifies write to SQL parse file
    BOOL    fSQLDirect;               // specifies write to SQL parse file
    char    szSQLFileName[64];        // SQL parse file name
    char    szServerName[32];         // SQL server name
    char    szDataBase[32];           // SQL database name
    char    szTableName[32];          // SQL table name (results)
    char    szUserID[16];             // user account ID on SQL server
    char    szPassword[16];           // password for user account
    WORD    wErrorRpt;                // error reporting method
} LSQL, FAR * LPLSQL;

#define fmSQLParse          ((ULONG)   1)
#define fmSQLDirect         ((ULONG)   2)
#define fmSQLFileName       ((ULONG)   4)
#define fmSQLServerName     ((ULONG)   8)
#define fmSQLDataBase       ((ULONG)  16)
#define fmSQLTableName      ((ULONG)  32)
#define fmSQLUserID         ((ULONG)  64)
#define fmSQLPassword       ((ULONG) 128)
#define fmSQLErrorRpt       ((ULONG) 256)
#define fmSQLAll            ((ULONG) 0xffffffff)


/*
 -  LFILE
 -
 *  Purpose:
 *      Defines the attributes of the local file logging in the
 *      ELLE sub-system.
 */

typedef struct _lfile
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to file
    char    szFileName[64];           // local log file name
    BOOL    fAppendMode;              // 1 = append, 0 = overwrite
    BOOL    fWritten;                 // indicates if we've written yet
    WORD    wErrorRpt;                // error reporting method
} LFILE, FAR * LPLFILE;

#define fmFILELogLevel      ((ULONG)  1)
#define fmFILEDetailLevel   ((ULONG)  2)
#define fmFILEFileName      ((ULONG)  4)
#define fmFILEAppendMode    ((ULONG)  8)
#define fmFILEErrorRpt      ((ULONG) 16)
#define fmFILEAll           ((ULONG) 0xffffffff)


/*
 -  LCOMM
 -
 *  Purpose:
 *      Defines the attributes of the comm port logging in the
 *      ELLE sub-system.
 */

typedef struct _lcomm
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wCommPort;                // which port: 0 = "com1", 1 = "com2", or 2 = "com3"
    WORD    wErrorRpt;                // error reporting method
    char    szSpeed[7];               // com port speed (EX: "1200", "9600", "19200")
} LCOMM, FAR * LPLCOMM;

#define fmCOMMLogLevel      ((ULONG)  1)
#define fmCOMMDetailLevel   ((ULONG)  2)
#define fmCOMMPort          ((ULONG)  4)
#define fmCOMMErrorRpt      ((ULONG)  8)
#define fmCOMMAll           ((ULONG) 0xffffffff)


/*
 -  LVIEWPORT
 -
 *  Purpose:
 *      Defines the attributes of the MS Test Viewport logging in the
 *      ELLE sub-system.
 */

typedef struct _viewport
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wErrorRpt;                // error reporting method
    BOOL    fHideWhenDone;            // flag for having the viewport be hidden
                                      // when last copy of elle is de-inited.
    BOOL    fClearEachSuite;          // flag for having the viewport be cleared
                                      // before each suite begins.
} LVIEWPORT, FAR * LPLVIEWPORT;

#define fmVIEWPORTLogLevel       ((ULONG)  1)
#define fmVIEWPORTDetailLevel    ((ULONG)  2)
#define fmVIEWPORTErrorRpt       ((ULONG)  4)
#define fmVIEWPORTHideWhenDone   ((ULONG)  8)
#define fmVIEWPORTClearEachSuite ((ULONG) 16)
#define fmVIEWPORTAll            ((ULONG) 0xffffffff)


/*
 -  EcMSTViewport() flags
 -
 * Purpose:
 *        Flags for indicating which operation should be done.
 *        Used with the EcMSTViewport() API. Normally Elle will
 *        handle everything here, but if you want to manipulate
 *        the viewer yourself, use these EcMSTViewport() with
 *        these flags.
 */
#define fmCREATE_MST_VIEWPORT     ((int) 0x0001)   // indicates the MSTest Viewport should be created and used.
#define fmCONNECT_MST_VIEWPORT    ((int) 0x0002)   // indicates that Elle should connect to the MSTest Viewport
#define fmDISCONNECT_MST_VIEWPORT ((int) 0x0004)   // indicates that Elle should disconnect from the MSTest Viewport
#define fmCLEAR_MST_VIEWPORT      ((int) 0x0010)   // indicates the MSTest Viewport should be Cleared
#define fmSHOW_MST_VIEWPORT       ((int) 0x0020)   // indicates the MSTest Viewport should be Shown
#define fmHIDE_MST_VIEWPORT       ((int) 0x0040)   // indicates the MSTest Viewport should be Hidden


/*
 -  LDBGOUT
 -
 *  Purpose:
 *      Defines the attributes of the MS Test Viewport logging in the
 *      ELLE sub-system.
 */

typedef struct _ldbgout
{
    WORD    wLogLevel;                // which log level: case, step, detail
    WORD    wDetailLevel;             // how much detail to log to comm term
    WORD    wErrorRpt;                // error reporting method
} LDBGOUT, FAR * LPLDBGOUT;

#define fmDBGOUTLogLevel       ((ULONG)  1)
#define fmDBGOUTDetailLevel    ((ULONG)  2)
#define fmDBGOUTErrorRpt       ((ULONG)  4)
#define fmDBGOUTAll            ((ULONG) 0xffffffff)


/*
 -  LOG
 -
 *  Purpose:
 *      Defines information that is global to the ELLE
 *      logging sub-system.
 */

#define cbSuiteNameMax  512

typedef struct _logsys
{
    char    szSuiteName[cbSuiteNameMax];         // defined by tester
    char    szTestCase[cbSuiteNameMax];          // verbose test case identifier
    WORD    wTestType;                // SL_CLASS, SL_STRESS, etc.

    WORD    fwCaseStatus;             // global status of current test case
    WORD    fwSuiteStatus;            // global status of current test suite
    WORD    fwSysStatus;              // global status of ELLE sub-system
    char    szErrMsg[MAXERRMSG];      // error message for ELLE sub-system

    BOOL    fVersion;                 // 1 = ship, 2 = debug, 3 = test

    BOOL    fFile;                    // are we logging to a file?
    BOOL    fComm;                    // are we logging to the comm port?
    BOOL    fSQL;                     // are we logging to SQL database?
    BOOL    fViewport;                // are we logging to the Viewport?
    BOOL    fDbgOut;                  // are we logging to the Debug Output?
    WORD    wErrorRpt;                // error reporting method
    BOOL    fDetailBuffer;            // are we using the Detail Buffer?
    BOOL    fBeginEndChecking;        // check for incorrect nesting of Begin/EndSuite and Begin/EndCase calls. Defaults to FALSE.
} LOGSYS, FAR * LPLOGSYS;

#define fmLOGSuiteName      ((ULONG) 0x00000001)
#define fmLOGTestCase       ((ULONG) 0x00000002)
#define fmLOGTestType       ((ULONG) 0x00000004)
#define fmLOGCaseStatus     ((ULONG) 0x00000008)
#define fmLOGSuiteStatus    ((ULONG) 0x00000010)
#define fmLOGSysStatus      ((ULONG) 0x00000020)
#define fmLOGErrMsg         ((ULONG) 0x00000040)
#define fmLOGVersion        ((ULONG) 0x00000080)
#define fmLOGFile           ((ULONG) 0x00000100)
#define fmLOGComm           ((ULONG) 0x00000200)
#define fmLOGSql            ((ULONG) 0x00000400)
#define fmLOGViewport       ((ULONG) 0x00000800)
#define fmLOGDbgOut         ((ULONG) 0x00001000)
#define fmLOGDetailBuf      ((ULONG) 0x00002000)
#define fmLOGErrorRpt       ((ULONG) 0x00004000)
#define fmLOGAll            ((ULONG) 0xffffffff)


/*
 -  Constants used by the ELLE logging system
 -
 */

#define     L_ERRORRPT1 ((WORD) 0)    // don't report errors
#define     L_ERRORRPT2 ((WORD) 1)    // report errors to a message box (default)
#define     L_ERRORRPT3 ((WORD) 2)    // log errors to event logger

#define     L_ADHOC     ((WORD) 0)    // defines an adhoc test (catch-all)
#define     L_CLASS     ((WORD) 1)    // defines a "class" test case
#define     L_STRESS    ((WORD) 2)    // defines a "stress" test case
#define     L_BOUNDARY  ((WORD) 3)    // defines a "boundary" test case
#define     L_MEMORY    ((WORD) 4)    // defines a "memory" test case
#define     L_RES_FAIL  ((WORD) 5)    // defines a "resource failure" case
#define     L_STD_DLG   ((WORD) 6)    // defines a "standard dialog" case

#define     L_FAIL      ((WORD) 0)
#define     L_PASS      ((WORD) 1)
#define     L_ABORT     ((WORD) 2)
#define     L_DONT_CARE ((WORD) 3)
#define     L_X         ((WORD) 3)

#define     L_SHIP      ((WORD) 1)
#define     L_DEBUG     ((WORD) 2)
#define     L_TEST      ((WORD) 3)

#define     L_COM1      ((WORD) 0)
#define     L_COM2      ((WORD) 1)
#define     L_COM3      ((WORD) 2)

#define     L_CASE      ((WORD) 1)
#define     L_STEP      ((WORD) 2)
#define     L_DETAIL    ((WORD) 3)

#define     L_MODEMPORT     0
#define     L_PRINTERPORT   1


/* Define the Elle interface to the outside world */

#ifdef __cplusplus
extern "C" {
#endif

#ifdef NT

// wide/unicode versions on functions that involve strings
VOID FAR PASCAL LogStepW(WORD, LPWSTR);
VOID FAR PASCAL LogDetailW(WORD, WORD, LPWSTR);
VOID FAR CDECL  LogStepFW(WORD, LPWSTR, ...);
VOID FAR CDECL  LogDetailFW(WORD, WORD, LPWSTR, ...);
VOID FAR PASCAL BeginCaseW(ULONG, LPWSTR);
VOID FAR PASCAL AbortCaseW(LPWSTR);
VOID FAR PASCAL BeginSuiteW(LPWSTR);
VOID FAR PASCAL SetHeaderW(LPWSTR, LPWSTR);
VOID FAR PASCAL GetHeaderW(LPWSTR, LPWSTR);
BOOL FAR PASCAL VerifyManualW(LPWSTR);
VOID FAR PASCAL LogNoteW(LPWSTR);
VOID FAR CDECL  LogNoteFW(LPWSTR, ...);

//Define a generic unicode calling APIs. Note, they are not exported, so if
//you want to use it in VB or MS Test, you need to define it yourself
#ifdef UNICODE // If UNICODE, then route generic calls into wide functions.

#define ULogStep      LogStepW
#define ULogDetail    LogDetailW
#define ULogStepF     LogStepFW
#define ULogDetailF   LogDetailFW
#define UBeginCase    BeginCaseW
#define UAbortCase    AbortCaseW
#define UBeginSuite   BeginSuiteW
#define USetHeader    SetHeaderW
#define UGetHeader    GetHeaderW
#define UVerifyManual VerifyManualW
#define ULogNote      LogNoteW
#define ULogNoteF     LogNoteFW

#endif //#ifdef UNICODE
#endif // #ifdef NT


//even if you are not using UNICODE, you can still use the U... APIs.
#ifndef UNICODE

#define ULogStep      LogStep
#define ULogDetail    LogDetailA
#define ULogStepF     LogStepF
#define ULogDetailF   LogDetailF
#define UBeginCase    BeginCase
#define UAbortCase    AbortCase
#define UBeginSuite   BeginSuite
#define USetHeader    SetHeader
#define UGetHeader    GetHeader
#define UVerifyManual VerifyManual
#define ULogNote      LogNote
#define ULogNoteF     LogNoteF

#endif // #ifndef UNICODE

//avoid to export LogDetail(), MS Test 4.0 has a function with the same name, so 
//we will have a problem to run MS Test. If you are using C/C++, you are OK since
//we #define it and the preprocess will take care of it, but if you are using VB,
// use LogDetailA() or LogDetailF() instead. 
#define LogDetail    LogDetailA	



// ASCII versions on functions that involve strings
VOID FAR PASCAL LogStep(WORD, LPSTR);
VOID FAR PASCAL LogDetailA(WORD, WORD, LPSTR);
VOID FAR CDECL  LogStepF(WORD, LPSTR, ...);
VOID FAR CDECL  LogDetailF(WORD, WORD, LPSTR, ...);
VOID FAR PASCAL BeginCase(ULONG, LPSTR);
VOID FAR PASCAL AbortCase(LPSTR);
VOID FAR PASCAL BeginSuite(LPSTR);
VOID FAR PASCAL SetHeader(LPSTR, LPSTR);
VOID FAR PASCAL GetHeader(LPSTR, LPSTR);
BOOL FAR PASCAL VerifyManual(LPSTR);
VOID FAR PASCAL LogNote(LPSTR);
VOID FAR CDECL  LogNoteF(LPSTR, ...);

// All non-unicode dependant functions
BOOL FAR PASCAL EcInitElle();
BOOL FAR PASCAL EcDeInitElle();
VOID FAR PASCAL EndCase();
VOID FAR PASCAL EndSuite();
VOID FAR PASCAL SetFileLevel(WORD);
VOID FAR PASCAL SetCommLevel(WORD);
VOID FAR PASCAL SetViewportLevel(WORD);
VOID FAR PASCAL SetDbgOutLevel(WORD);
VOID FAR PASCAL SetStatus(WORD);
WORD FAR PASCAL GetStatus();
VOID FAR PASCAL SetLogSys(BOOL, LPLOGSYS, ULONG);
BOOL FAR PASCAL GetLogSys(LPLOGSYS, ULONG);
BOOL FAR PASCAL LogMenu(HWND);
VOID FAR PASCAL SetSQLSys(BOOL, LPLSQL, ULONG);
BOOL FAR PASCAL GetSQLSys(LPLSQL, ULONG);
VOID FAR PASCAL SetFileSys(BOOL, LPLFILE, ULONG);
BOOL FAR PASCAL GetFileSys(LPLFILE, ULONG);
VOID FAR PASCAL SetCommSys(BOOL, LPLCOMM, ULONG);
BOOL FAR PASCAL GetCommSys(LPLCOMM, ULONG);
VOID FAR PASCAL SetViewportSys(BOOL, LPLVIEWPORT, ULONG);
BOOL FAR PASCAL GetViewportSys(LPLVIEWPORT, ULONG);
VOID FAR PASCAL SetDbgOutSys(BOOL, LPLDBGOUT, ULONG);
BOOL FAR PASCAL GetDbgOutSys(LPLDBGOUT, ULONG);
HWND FAR PASCAL SetViewport(HWND);
VOID FAR PASCAL SetCallback(ELLECALLBACK);
VOID FAR PASCAL SaveChanges();
BOOL FAR PASCAL EcMSTViewport(HWND, ULONG);

#ifdef __cplusplus
}
#endif

#endif // _ELLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\faxsender\test.cpp ===
//
//
// Filename:	bvt.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		30-Dec-98
//
//

#include "test.h"

//forward declerations:

//
// SetupPort:
//	Private module function used to set port configuration
// 
static BOOL SetupPort(
	IN  HANDLE				hFaxSvc,
	IN  PFAX_PORT_INFO		pPortInfo,
	IN  DWORD				dwFlags,
	IN  LPCTSTR				szTsid,
	IN  LPCTSTR				szCsid
	);

//
// SendRegularFax: 
//	Private module function used to send a fax
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber2,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
);




//
// TestSuiteSetup:
//	Initializes logger and changes the Fax server configuration
//	for the tests.
//
BOOL WINAPIV TestSuiteSetup(
	LPCTSTR		szServerName,
	LPCTSTR		szFaxNumber,
	LPCTSTR		szDocument,
	LPCTSTR		szCoverPage)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	HANDLE hFaxSvc = NULL;
	DWORD dwNumFaxPorts = 0;
	int nPortIndex = 0;
	PFAX_CONFIGURATION pFaxSvcConfig = NULL;
	PFAX_PORT_INFO	pFaxPortsConfig = NULL;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("BVT suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// log CometFaxSender.exe params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("CometFaxSender params:\n\tszServerName=%s\n\tszFaxNumber1=%s\n\tszDocument=%s\n\tszCoverPage=%s\n\t"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	//
	// Setup fax service
	//
	if (!FaxConnectFaxServer(szServerName,&hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\nFaxConnectFaxServer(%s) failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			szServerName,
			::GetLastError()
			);
        goto ExitFunc;
	}

	//
	// Setup Service configuration
	//

	// Retrieve the fax service configuration
    if (!FaxGetConfiguration(hFaxSvc, &pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxGetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	//check that FaxGetConfiguration allocated
	_ASSERTE(pFaxSvcConfig);

	pFaxSvcConfig->Retries = 0;
	pFaxSvcConfig->PauseServerQueue = FALSE;
	pFaxSvcConfig->ArchiveOutgoingFaxes = TRUE;
	pFaxSvcConfig->ArchiveDirectory = TEST_ARCHIVE_DIR;
	pFaxSvcConfig->Branding = TRUE;

	// Set the fax service configuration
    if (!FaxSetConfiguration(hFaxSvc, pFaxSvcConfig)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetConfiguration returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }

	//
	// Setup the two ports
	//

    // Retrieve the fax ports configuration
    if (!FaxEnumPorts(hFaxSvc, &pFaxPortsConfig, &dwNumFaxPorts)) 
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxEnumPorts returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
        goto ExitFunc;
    }
	_ASSERTE(pFaxPortsConfig);

	if (TEST_MIN_PORTS > dwNumFaxPorts)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE:%s LINE:%d\n dwNumFaxPorts(=%d) < TEST_MIN_PORTS(=%d)\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			TEST_MIN_PORTS
			);
        goto ExitFunc;
	}
	else
	{
		::lgLogDetail(
			LOG_X, 
			1,
			TEXT("FILE:%s LINE:%d\ndwNumFaxPorts=%d\nTEST_MIN_PORTS=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwNumFaxPorts,
			TEST_MIN_PORTS
			);
	}


    // Set 1st device as Send only (note pFaxPortsConfig array is 0 based)
	if (FALSE == SetupPort(
					hFaxSvc, 
					&pFaxPortsConfig[0], 
					FPF_SEND, 
					DEV1_TSID, 
					DEV1_CSID
					)
		)
	{
		goto ExitFunc;
	}

	if (2 <= dwNumFaxPorts)
	{
		// Set 2nd device as Receive only (note pFaxPortsConfig array is 0 based)
		if (FALSE == SetupPort(
						hFaxSvc, 
						&pFaxPortsConfig[1], 
						FPF_RECEIVE, 
						DEV2_TSID, 
						DEV2_CSID
						)
			)
		{
			goto ExitFunc;
		}

		// set all other devices as Receive=No and Send=No
		// NOTE: nPortIndex is 0 based
		for (nPortIndex = 2; nPortIndex < dwNumFaxPorts; nPortIndex++)
		{
			if (FALSE == SetupPort(
							hFaxSvc, 
							&pFaxPortsConfig[nPortIndex], 
							MY_FPF_NONE, 
							DEV_TSID, 
							DEV_CSID
							)
				)
			{
				goto ExitFunc;
			}
		}
	}

	fRetVal = TRUE;

ExitFunc:
	::FaxFreeBuffer(pFaxPortsConfig);
	if (FALSE == ::FaxClose(hFaxSvc))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}


//
// TestCase1:
//	Send a fax + CP.
//
BOOL TestCase1(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;

	::lgBeginCase(
		1,
		TEXT("TC#1: Send a fax + CP")
		);

	fRetVal = SendRegularFax(szServerName, szFaxNumber, szDocument, szCoverPage);

	::lgEndCase();
	return(fRetVal);
}


//
// TestCase2:
//	Send a broadcast (3 times the same recipient) with cover pages.
//
BOOL TestCase2(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	FAX_SENDER_STATUS myFaxSenderStatus;
	CostrstreamEx os;
	LPCTSTR myStr = NULL;
    FAX_PERSONAL_PROFILE RecipientProfile = {0};

	::lgBeginCase(
		1,
		TEXT("TC#2: Send a broadcast with CP (3 * same recipient)")
		);
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	// create the fax sending object
	CFaxSender myFaxSender(TRUE, szServerName);  //if constructor fails an assertion is raised

	// create a broadcast object with 3 recipients
	CFaxBroadcast myFaxBroadcastObj;
	if (FALSE == myFaxBroadcastObj.SetCPFileName(szCoverPage))
	{
		::lgLogError(LOG_SEV_1,TEXT("myFaxBroadcastObj.SetCPFileName() failed"));
		goto ExitFunc;
	}
	// add 1st recipient to broadcast
    RecipientProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    RecipientProfile.lptstrName = TEXT("Recipient Number1");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("1st myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}
	// add 2nd recipient to broadcast
    RecipientProfile.lptstrName = TEXT("Recipient Number2");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("2nd myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}
	// add 3rd recipient to broadcast
    RecipientProfile.lptstrName = TEXT("Recipient Number3");
    RecipientProfile.lptstrFaxNumber = (LPTSTR)szFaxNumber;
	if (FALSE == myFaxBroadcastObj.AddRecipient(&RecipientProfile))
	{
		::lgLogError(LOG_SEV_1,TEXT("3rd myFaxBroadcastObj.AddRecipient() failed"));
		goto ExitFunc;
	}

	myFaxBroadcastObj.outputAllToLog(LOG_X,1);

	fRetVal = myFaxSender.send_broadcast( szDocument, &myFaxBroadcastObj,TRUE);
	myFaxSenderStatus = myFaxSender.GetLastStatus();
	if (FALSE == fRetVal)
	{
		// test case failed
		::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send_broadcast returned FALSE"));
	}
	else
	{
		// test case succeeded
		::lgLogDetail(LOG_X,1,TEXT("myFaxSender.send_broadcast returned TRUE"));
	}

	// log the last status returned from the fax sending object
	os<<myFaxSenderStatus;
	myStr = os.cstr();
	::lgLogDetail(LOG_X,1,myStr);
	delete[]((LPTSTR)myStr);

ExitFunc:
	::lgEndCase();
	return(fRetVal);
}


//
// TestSuiteShutdown:
//	Perform test suite cleanup (close logger).
//
BOOL TestSuiteShutdown(void)
{
	BOOL fRetVal = TRUE;

	//
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		fRetVal = FALSE;
	}

	return(fRetVal);
}


//
// SetupPort:
//	Private module function, used to set port configuration.
// 
// Parameters:
//	hFaxSvc			IN parameter.
//					A handle to the Fax service.
//
//	pPortInfo		IN parameter.
//					A pointer to the original port configuration, as returned 
//					from a call to FaxGetPort or FaxEnumPorts.
//
//	dwFlags			IN parameter.
//					Bit flags that specify the new capabilities of the fax port.
//					See FAX_PORT_INFO for more information.
//
//	szTsid			IN parameter.
//					A string that specifies the new transmitting station identifier.
//
//	szCsid			IN parameter.
//					A string that specifies the new called station identifier.
//
// Return Value:
//	TRUE if successful, FALSE otherwise.
//
static BOOL SetupPort(
	IN  HANDLE				hFaxSvc,
	IN  PFAX_PORT_INFO		pPortInfo,
	IN  DWORD				dwFlags,
	IN  LPCTSTR				szTsid,
	IN  LPCTSTR				szCsid
	)
{
	BOOL fRetVal = FALSE;
	HANDLE hPort = NULL;

	// check in params
	_ASSERTE(NULL != hFaxSvc);
	_ASSERTE(NULL != pPortInfo);
	_ASSERTE(NULL != szTsid);
	_ASSERTE(NULL != szCsid);

	// Set pPortInfo as required
	pPortInfo->Flags = dwFlags;
	pPortInfo->Tsid	 = szTsid;
	pPortInfo->Csid  = szCsid;

	// get the device Id
	DWORD dwDeviceId = pPortInfo->DeviceId;

	// open the port for configuration
	if(!FaxOpenPort(hFaxSvc, dwDeviceId, PORT_OPEN_MODIFY, &hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxOpenPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	// set the device configuration
	if(!FaxSetPort(hPort, pPortInfo))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxSetPort returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}

	fRetVal = TRUE;

ExitFunc:
	if (FALSE == ::FaxClose(hPort))
	{
		::lgLogError(
			LOG_SEV_1, 
			TEXT("FILE:%s LINE:%d FaxClose returned FALSE with GetLastError=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}
	return(fRetVal);
}

//
// SendRegularFax:
//	Sends a fax.
//
// NOTE: This function is private to this module, it is not exported.
//
// Parameters:
//	szServerName	IN parameter.
//					Name of Fax server to use.
//  
//	szFaxNumber2	IN parameter
//					Phone number to send fax to.
//
//	szDocument		IN parameter
//					Filename of document to send.
//
//	szCoverPage		IN parameter
//					Filename of cover page to send.
//
// Return Value:
//	TRUE if successful, otherwise FALSE.
//
static BOOL SendRegularFax(
	LPCTSTR		/* IN */	szServerName,
	LPCTSTR		/* IN */	szFaxNumber,
	LPCTSTR		/* IN */	szDocument,
	LPCTSTR		/* IN */	szCoverPage
)
{
	_ASSERTE(NULL != szServerName);
	_ASSERTE(NULL != szFaxNumber);
	_ASSERTE(NULL != szDocument);
	_ASSERTE(NULL != szCoverPage);

	BOOL fRetVal = FALSE;
	FAX_SENDER_STATUS myFaxSenderStatus;

	::lgLogDetail(
		LOG_X,
		1,
		TEXT("Server=%s\nFaxNumber=%s\nDocument=%s\nCoverPage=%s\n"),
		szServerName,
		szFaxNumber,
		szDocument,
		szCoverPage
		);

	CFaxSender myFaxSender(TRUE, szServerName);  //if constructor fails an assertion is raised
	fRetVal = myFaxSender.send( szDocument, szCoverPage, szFaxNumber,TRUE);
	myFaxSenderStatus = myFaxSender.GetLastStatus();
	if (FALSE == fRetVal)
	{
		// test case failed
		::lgLogError(LOG_SEV_1,TEXT("myFaxSender.send returned FALSE"));
	}
	else
	{
		// test case succeeded
		::lgLogDetail(LOG_X,1,TEXT("myFaxSender.send returned TRUE"));
	}

	CostrstreamEx os;
	os<<myFaxSenderStatus;
	LPCTSTR myStr = os.cstr();
	::lgLogDetail(LOG_X,1,myStr);
	delete[]((LPTSTR)myStr);


	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\log.h ===
#ifndef __LOG_WRAPPER_H__
#define __LOG_WRAPPER_H__

#ifdef __cplusplus
extern "C"
{
#endif

BOOL __cdecl lgInitializeLogger();

BOOL __cdecl lgCloseLogger();


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite);
BOOL __cdecl lgEndSuite();

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase);
BOOL __cdecl lgEndCase();

int __cdecl lgSetLogLevel(const int nLogLevel);

/*
#define LOG_TYPE_FILE 0x01
#define LOG_TYPE_VIEWPORT 0x02
#define LOG_TYPE_COMM 0x04
#define LOG_TYPE_DEBUG 0x08

DWORD __cdecl lgSetLogType(DWORD dwLogTo);
*/

BOOL __cdecl lgDisableLogging();

BOOL __cdecl lgEnableLogging();

//
// severity values
//
#define LOG_PASS -1

#define LOG_X 0
#define LOG_SEVERITY_DONT_CARE 0

#define LOG_SEV_1 1
#define LOG_SEV_2 2
#define LOG_SEV_3 3
#define LOG_SEV_4 4

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...);
void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...);

BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer);

#ifdef __cplusplus
}
#endif


#endif //__LOG_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\iniutils.h ===
//
// Ini File Utilities
//
//
#ifndef _INI_UTILS
#define _INI_UTILS

#include <string>
#include <vector>
#include <map>
#include <comdef.h>

//utilities
#include <ptrs.h>
#include <testruntimeerr.h>
#include <tstring.h>

// Declarations
//
std::map<tstring, tstring> INI_GetSectionEntries( const tstring& FileName,
												  const tstring& SectionName);
std::vector<tstring> INI_GetSectionList( const tstring& FileName,
										 const tstring& SectionName);
std::map<tstring, DWORD> INI_GetSectionNames( const tstring& FileName);


/*------------------------------------------------------------------------------------
   function: INI_GetSectionEntries
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - map of section entries, pairs of key and value( display format)
   ------------------------------------------------------------------------------------*/
inline std::map<tstring, tstring> INI_GetSectionEntries( const tstring& FileName,
														 const tstring& SectionName)
{
	const SECTION_DATA_SIZE = 4*1024;
	
	std::map<tstring, tstring> SectionEntries;
	SPTR<TCHAR> tchDataString( new TCHAR[SECTION_DATA_SIZE]); // for section data

	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionEntries;
	}

	DWORD res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                    SECTION_DATA_SIZE, FileName.c_str());
			
	if( res == (SECTION_DATA_SIZE - 2)) // suspect - buffer is too small
	{
		tchDataString = ( new TCHAR[ 2*SECTION_DATA_SIZE]);
		res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                2*SECTION_DATA_SIZE, FileName.c_str());
	
		if( res == ( 2*SECTION_DATA_SIZE -2 )) // buffer is too small
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_INSUFFICIENT_BUFFER, TEXT(""));
		}
	}

	tstring Key, Value;
	int Proplen = 0, Separindex;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		tstring EntryStr = tstring(Propstr, Proplen); 
		Key = EntryStr;
		Separindex =  EntryStr.find_first_of(TEXT("="));
		if(Separindex != tstring::npos)
		{
			Value = EntryStr.substr(Separindex + 1);
			Key = EntryStr.substr(0, Separindex);
		}
		else
		{
			Value = TEXT("");
		}
		
		SectionEntries.insert(std::map<tstring, tstring>::value_type(Key, Value));
		Propstr = Propstr + Proplen + 1;
	}

	return SectionEntries;

}

/*------------------------------------------------------------------------------------
   function: inline std::vector<tstring> INI_GetSectionList( const tstring& FileName,
 
   [in]  const tstring& FileName - INI file path.
   [in]  const tstring& SectionName - name of requested section data.
   return  - map of section entries, pairs of key and value( display format)
   ------------------------------------------------------------------------------------*/
inline std::vector<tstring> INI_GetSectionList( const tstring& FileName,
											    const tstring& SectionName)
{
	const SECTION_DATA_SIZE = 4*1024;
	
	std::vector<tstring> SectionList;
	SPTR<TCHAR> tchDataString( new TCHAR[SECTION_DATA_SIZE]); // for section data

	if(SectionName == TEXT("") || FileName == TEXT(""))
	{
		return SectionList;
	}

	DWORD res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                    SECTION_DATA_SIZE, FileName.c_str());
			
	if( res == (SECTION_DATA_SIZE - 2)) // suspect - buffer is too small
	{
		tchDataString = ( new TCHAR[ 2*SECTION_DATA_SIZE]);
		res = GetPrivateProfileSection(	SectionName.c_str(), tchDataString.get(),    
						                2*SECTION_DATA_SIZE, FileName.c_str());
	
		if( res == ( 2*SECTION_DATA_SIZE -2 )) // buffer is too small
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_INSUFFICIENT_BUFFER, TEXT(""));
		}
	}

	tstring Key, Value;
	int Proplen = 0, Separindex;

	LPTSTR Propstr = tchDataString.get();
	while( Proplen = _tcslen(Propstr) ) // walk on data buffer
	{
	
		tstring EntryStr = tstring(Propstr, Proplen); 
		Key = EntryStr;
		Separindex =  EntryStr.find_first_of(TEXT("="));
		if(Separindex != tstring::npos)
		{
			Value = EntryStr.substr(Separindex + 1);
			Key = EntryStr.substr(0, Separindex);
		}
		else
		{
			Value = TEXT("");
		}
		
		SectionList.push_back( Key);
		Propstr = Propstr + Proplen + 1;
	}

	return SectionList;

}

/*------------------------------------------------------------------------------------
   function: INI_GetSectionNames
 
   [in]  tstring& FileName - INI file path.
   return - vector of section names in ini file.
   ------------------------------------------------------------------------------------*/
inline std::map<tstring, DWORD> INI_GetSectionNames( const tstring& FileName)
{
	const SECTION_NAMES_SIZE = 4*1024;
	
	std::map<tstring, DWORD> SectionNames;
	SPTR<TCHAR> tchNamesString( new TCHAR[SECTION_NAMES_SIZE]); // for section names

	DWORD res = GetPrivateProfileSectionNames( tchNamesString.get(), SECTION_NAMES_SIZE,
											   FileName.c_str());

	if( res == (SECTION_NAMES_SIZE - 2)) // suspect - buffer is too small
	{
		tchNamesString =  (new TCHAR[ 2*SECTION_NAMES_SIZE]);
		res = GetPrivateProfileSectionNames( tchNamesString.get(), 2*SECTION_NAMES_SIZE,
											 FileName.c_str());
			
		if( res == ( 2*SECTION_NAMES_SIZE - 2 )) // buffer is too small
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_INSUFFICIENT_BUFFER, TEXT(""));
		}
	}

	tstring Namestr;
	int Proplen = 0;

	LPTSTR Propstr = tchNamesString.get();
	while( Proplen = _tcslen(Propstr)) // walk on names buffer
	{
		Namestr = Propstr;
		SectionNames.insert(std::map<tstring, DWORD>::value_type(Namestr, 0));;
	
		Propstr = Propstr + Proplen + 1;
	}

	return SectionNames;
}


#endif // _INI_UTILS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\bmp2tiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bmp2tiff.c

Abstract:

    This file contains support for converting a
    Windows BMP file to a TIFF file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "test.h"
#pragma hdrstop




DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    )

/*++

Routine Description:

    Converts a BMP file to a TIFF file.

Arguments:

    BmpFile             - BMP file name
    TiffFile            - TIFF file name
    CompressionType     - Compression method, see tifflib.h

Return Value:

    None.

--*/

{
    HANDLE hFileIn;
    HANDLE hMapIn;
    LPVOID FilePtrIn;
    HANDLE hTiff;
    PBMPINFO BmpInfo;
    DWORD LineWidth;
    DWORD FileSize;
    LPBYTE Bits;
    DWORD i,j;
    LPBYTE SrcPtr;
    DWORD RealWidth;
    BYTE BitBuffer[(1728/8)*2];


    hFileIn = CreateFile(
        BmpFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFileIn != INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    hMapIn = CreateFileMapping(
        hFileIn,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!hMapIn) {
        return GetLastError();
    }

    FilePtrIn = MapViewOfFile(
        hMapIn,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!FilePtrIn) {
        return GetLastError();
    }

    FileSize = GetFileSize( hFileIn, NULL );

    BmpInfo = (PBMPINFO) FilePtrIn;

    LineWidth = BmpInfo->SizeImage / BmpInfo->Height;
    Bits = (LPBYTE) ( (LPBYTE)FilePtrIn + BmpInfo->Offset );
    SrcPtr = ((LPBYTE)FilePtrIn + BmpInfo->Offset) + (LineWidth * (BmpInfo->Height - 1));
    RealWidth = Align( 8, BmpInfo->Width ) / 8;

    hTiff = TiffCreate( TiffFile, CompressionType, LineWidth*8, 1, 1 );
    if (!hTiff) {
        return GetLastError();
    }

    TiffStartPage( hTiff );

    for (i=0; i<BmpInfo->Height; i++) {
        FillMemory( BitBuffer, sizeof(BitBuffer), 0xff );
        CopyMemory( BitBuffer, SrcPtr, RealWidth );
        if (BmpInfo->Width % 8) {
            BitBuffer[BmpInfo->Width/8] |= 0xf;
        }
        for (j=0; j<sizeof(BitBuffer); j++) {
            BitBuffer[j] ^= 0xff;
        }
        SrcPtr -= LineWidth;
        TiffWrite( hTiff, BitBuffer );
    }

    TiffEndPage( hTiff );

    UnmapViewOfFile( FilePtrIn );
    CloseHandle( hMapIn );
    CloseHandle( hFileIn );

    TiffClose( hTiff );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\logelle.c ===
//
// this is an implementation of the log.h interface to support ELLE logging.
// you must implicitly link you project to your logger's lib.
// you may use this implementation as a reference for impementing other loggers
//


#pragma warning( disable:4201)
#include <windows.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include "log.h"


#ifdef UNICODE 
	#define NT // for elle 
#endif// UNICODE  

//
// include your logger header file here
//
#include "..\..\include\elle.h"


//***************************************************
//
// static function declarations
//
//***************************************************
static WORD _SevToElle(DWORD dwSeverity);



//***************************************************
//
// static variables to hold the state of the logger
//
//***************************************************

//
// ELLE's internals
//
//static LOGSYS s_LogSys;

//
// logging is disabled by default, and turned on by lgInitializeLogger()
//
static long s_lDisableLogging = TRUE;


//
// initialize your logger, or if it is an object, create an instance of it.
//
BOOL __cdecl lgInitializeLogger()
{
	s_lDisableLogging = FALSE;
	return EcInitElle();

}



//
// close your logger, or if it is an object, delete it.
//
BOOL __cdecl lgCloseLogger()
{
	s_lDisableLogging = TRUE;
	return EcDeInitElle();

}


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite)
{
#ifdef UNICODE
	char MultiByteStr[1024];
	int nSizeOfMultiByteStr = sizeof(MultiByteStr);
	BOOL fDefaultCharUsed;
	int nRet;

	memset(MultiByteStr, 0, nSizeOfMultiByteStr);

	nRet = WideCharToMultiByte(  
		CP_ACP,         // ANSI code page
		0,         // performance and mapping flags
		szSuite, // address of wide-character string
		lstrlen(szSuite),       // number of characters in string
		MultiByteStr,  // address of buffer for new string
		nSizeOfMultiByteStr,      // size of buffer
		"*",  // address of default for unmappable characters
		&fDefaultCharUsed   // address of flag set when default char. used
		);
	//
	//BUGBUG: check return values
	//
	_ASSERTE(!fDefaultCharUsed);

	BeginSuite(MultiByteStr);
#else
	BeginSuite((LPSTR)szSuite);
#endif//UNICODE

	return TRUE;
							 
}

BOOL __cdecl lgEndSuite()
{
	EndSuite();
	return TRUE;
}

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase)
{
#ifdef UNICODE
	BeginCaseW(dwCase, (LPTSTR)szCase);
#else
	BeginCase(dwCase, (LPTSTR)szCase);
#endif
	return TRUE;
}



BOOL __cdecl lgEndCase()
{
	EndCase();
	return TRUE;
}


//
// set the log level.
// 9 is most details, 0 is least.
// return value is not supported.
//
int __cdecl lgSetLogLevel(const int nLogLevel)
{
	SetFileLevel((WORD)nLogLevel);
	SetCommLevel((WORD)nLogLevel);
	SetViewportLevel((WORD)nLogLevel);
	SetDbgOutLevel((WORD)nLogLevel);

	return 0;
}


BOOL __cdecl lgDisableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 1L);
}

BOOL __cdecl lgEnableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 0L);
}

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...)
{
	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#else
        LogDetailA(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#endif
		va_end(args);
    }
}

void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...)
{
	UNREFERENCED_PARAMETER(dwSeverity);

	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(L_FAIL,0,(LPTSTR)msg);
#else
        LogDetailA(L_FAIL,0,(LPTSTR)msg);
#endif
		va_end(args);
    }

}

//
// if you can log to a remote machine, set it here.
// it is irrelevant for ELLE.
//
BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer)
{
	UNREFERENCED_PARAMETER(szLogServer);
	return FALSE;
}



static WORD _SevToElle(DWORD dwSeverity)
{
	switch(dwSeverity)
	{
	case LOG_PASS: return (WORD)L_PASS;
	case LOG_X: return (WORD)L_X;
	case LOG_SEV_1:
	case LOG_SEV_2:
	case LOG_SEV_3:
	case LOG_SEV_4:
		return (WORD)L_FAIL;

	default:
		_ASSERTE(FALSE);

	}

	//
	// to remove the warning
	//
	return (WORD)L_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\ptrs.h ===
/*
 * Pointers classes
 *
 * Counter - A thread safe counter class
 * SPTR - Smart pointer with, a pointer class with reference count
 * aptr - Auto pointer
 * aaptr - Array Auto pointer
 */

#ifndef __PTRS_H
#define __PTRS_H


#include <windows.h>
#include <testruntimeerr.h>

#pragma warning( disable: 4284)

/*
 * A thread safe counter class
 */
class Counter
{
public:
	typedef LONG value_type;

	Counter(value_type v = 0) : value(v) {};

	operator value_type() const {return value;}

	value_type operator++() { return InterlockedIncrement(&value); }
	value_type operator++(int) { return InterlockedIncrement(&value)-1;}
	value_type operator--() { return InterlockedDecrement(&value);}
	value_type operator--(int)  { return InterlockedDecrement(&value)+1;} 
	value_type operator=(value_type v) {return InterlockedExchange(&value, v);}

private:
	value_type value;
};

/*
 * Smart pointer - pointer with reference count.
 *                 When the reference count reaches 0, the pointer is deleted.
 *
 * Usage directions:
 * SPTR<C> pi(new int);
 * SPTR<C> p2 = pi;
...
 * NOTES:
 *   - operator=(T*) is not supported on purpose.
 */

class SPTR_ANY;

/*
 * Base class for Smart Pointer, for implementation of SPTR_ANY.
 */
class SPTR_base
{
public:
	virtual ~SPTR_base() {}
	bool operator==(const SPTR_base& ptr) { return eq(ptr); }
	bool operator< (const SPTR_base& ptr) { return lt(ptr); }

protected:
	virtual bool eq(const SPTR_base& ptr) const = 0;
	virtual bool lt(const SPTR_base& ptr) const = 0;
	virtual SPTR_base* clone() const = 0;

	friend class SPTR_ANY;
};

/*
 * SPTR
 */
template<class T>
class SPTR : public SPTR_base
{
public:
	SPTR(T* ptr = NULL): 
		p(ptr)
	{
		new_counter();
	}

	template<class T2> SPTR(const SPTR<T2>& ptr) :
	counter(ptr.get_counter()),
	/*
	 * If you want to be able to copy a base class to a
	 * derived class, you should change the following line
	 * to something like:
	 *    p(dynamic_cast<T*>(ptr.get()))
	 * NOTES: dynamic_cast returns 0 if the cast had failed.
	 */
	p(ptr.get())
	{
		++*counter;
	}

	SPTR(const SPTR& ptr) : 
	counter(ptr.counter),
	p(ptr.p)
	{
		++*counter;
	}

	~SPTR() { unlink(); }

	bool operator==(const SPTR& ptr) const { return p == ptr.p; }
	bool operator< (const SPTR& ptr) const { return p < ptr.p; }

	template <class T2> SPTR& operator=(const SPTR<T2>& ptr)
	{
		if (static_cast<const SPTR_base*>(this) != static_cast<const SPTR_base*>(&ptr))
		{
			  unlink();
			/*
			 * If you want to be able to copy a base class to a
			 * derived class, you should change the following line
			 * to something line:
			 *    p = dynamic_cast<T*>(ptr.get());
			 * NOTE: dynamic_cast returns 0 if the cast had failed.
			 */
			  p = ptr.get();
			  counter = ptr.get_counter();
			  ++*counter;
		}
		return *this;
	}

	SPTR& operator=(const SPTR& ptr)
	{
		if (this != &ptr)
		{
		  unlink();
		  p = ptr.p;
		  counter = ptr.counter;
		  ++*counter;
		}
		return *this;
	}

	SPTR& operator=(const T* pt)
	{
		unlink();
		p = const_cast<T*>(pt);
		new_counter();
		return *this;
	}

	T* get() const  {return p;}
	T** getaddress(){return &p;} //TODO: const?
	T* release()
	{
		if (!--(*counter)) 
		{
		  delete counter;
		}
		T* retval = p;
		p = NULL;
		return retval;
	}
  
	T* operator-> () {return get();}
	T& operator*() { return *get(); }
	//  T** operator&(); // Don't remember why I don't like this operator.
	operator T*() { return get(); }

	Counter* get_counter() const {return counter;}

protected:

	void unlink()
	{
		if (!--(*counter))
		{
		  delete p;
		  p = NULL;
		  delete counter;
		  counter = NULL;
		}
	}

	bool eq(const SPTR_base& ptr) const
	{
		const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
		return *this == sptr_ptr;
	}

	bool lt(const SPTR_base& ptr) const
	{
		const SPTR& sptr_ptr = static_cast<const SPTR&>(ptr);
		return *this < sptr_ptr;
	}

	SPTR_base* clone() const { return new SPTR(*this); }

	void new_counter()
	{
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" sptr, new"));
		}
	}

	T* p;
	Counter *counter;
};


/*
 * SPTR_ANY: A class that can hold any type of smart pointer.
 */

class SPTR_ANY
{
public:
	SPTR_ANY(const SPTR_base& ptr) { p = ptr.clone(); }
	SPTR_ANY(const SPTR_ANY& ptr) { p = ptr.p->clone(); }
	~SPTR_ANY() { delete p; }
	SPTR_ANY& operator=(const SPTR_ANY& ptr) {delete p; p = ptr.p->clone(); return *this;}
	bool operator==(const SPTR_ANY& ptr) { return *p == *ptr.p; }
	bool operator< (const SPTR_ANY& ptr) { return *p < *ptr.p; }

protected:
	SPTR_base* p;
};

/*
 * Smart pointer for storage of data in STL sets, etc
 * The difference is in the < and == operators, so that find will work
 * on the value and no on the pointers.
 *
 * Never tested, probably does not work....
 */
template<class T>
class SPSTL : public SPTR<T>
{
	SPSTL(T* ptr = NULL) : SPTR<T>(ptr) {}
	SPSTL(const SPSTL& ptr) : SPTR<T>(ptr) {}
	bool operator==(const SPSTL& a2) {return *this == *a2;}
	bool operator<(const SPSTL& a2) {return *this < *a2;}
};

/*------------------------- Auto pointer class -------------------------*/

template<class T>
class aptr
{
protected:
	T* p;
	void cleanup() { delete p; }
public:
	aptr(T* value = NULL) : p(value) {}
	~aptr() { cleanup(); }
	T* operator=(T* value) { cleanup(); p = value; return p; }
	T* operator->() { return p; }
	T& operator*() { return *p; }
	T** operator&() { return &p; }
	operator T*() { return p;}
	T* get() {return p;}
	T* release() { T* t = p; p = NULL; return t; }
};

/*----------------------- Array Auto pointer class ---------------------*/

template<class T>
class aaptr
{
protected:
	T* p;
	Counter *counter;
	void cleanup()
	{ 
		if (!--(*counter))
		{
		  delete[] p;
		  p = NULL;
		  delete counter;
		  counter = NULL;
		}
	}

public:
	aaptr(T* value = NULL) : p(value)
	{
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" aaptr, new"));
		}
	}
	~aaptr() 
	{ 
		cleanup();
	}
	T* operator=(T* value) 
	{
		cleanup(); 
		p = value;
		counter = new Counter(1);
		if(!counter)
		{
			THROW_TEST_RUN_TIME_WIN32(ERROR_OUTOFMEMORY, TEXT(" aaptr, new"));
		}
		return p; 
	}
	T* operator->() { return p; }
	T& operator*() { return *p; }
	T** operator&() { return &p; }
	operator T*() { return p;}
	T* get() {return p;}
	T* release() 
	{ 
		if (!--(*counter)) 
		{
		  delete counter;
		  counter = NULL;
		}
		
		T* t = p;
		p = NULL;
		return t;
	}

	aaptr(const aaptr& ptr) : 
	counter(ptr.counter),
	p(ptr.p)
	{
		++*counter;
	}

	aaptr& operator=(const aaptr& ptr)
	{
		if (this != &ptr)
		{
			cleanup();
			p = ptr.p;
			counter = ptr.counter;
		    ++*counter;
		}
		return *this;
	}
};
#endif // __PTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\testit\main.c ===
#include "..\TiffTools\TiffTools.h"

int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;
    int cbDifferentPixels;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    if (4 != argc)
    {
        _tprintf(TEXT("Usage: %s <1st tiff> <2nd tiff> <bool: fSkipFirstLineOfSecondFile>\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 1\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 0\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent1.tif c:\\sent2.tif 0\n"), argv[0]);
        return -1;
    }

    cbDifferentPixels = TiffCompare(argv[1], argv[2], _ttoi(argv[3]));
    return cbDifferentPixels;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\tstring.h ===
//---------------------------------------------------------------------------
//
//
// File:        TSTRING.H
//
// Contents:    tstring C++ type for TCHAR strings
//
//---------------------------------------------------------------------------

#ifndef _TSTRING_H
#define _TSTRING_H

#include <windows.h>
#include <Wtypes.h>
#include <tchar.h>

// stl
#include <string>
#include <iostream>
#include <sstream>
#include <strstream>

using namespace std;
typedef std::basic_string<TCHAR, char_traits<TCHAR>, allocator<TCHAR> > tstring;
typedef std::basic_string<OLECHAR, char_traits<OLECHAR>, allocator<OLECHAR> > olestring;
typedef std::basic_istringstream<TCHAR> itstringstream;
typedef std::basic_ostringstream<TCHAR> otstringstream;
typedef std::basic_stringstream<TCHAR>  tstringstream;
typedef std::basic_istringstream<WCHAR> iwstringstream;
typedef std::basic_ostringstream<WCHAR> owstringstream;
typedef std::basic_stringstream<WCHAR>  wstringstream;


#endif //#ifndef _TSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\reghackutils.h ===
#ifndef _REG_HACK_UTILS_H
#define _REG_HACK_UTILS_H

// standard
#include <windows.h>
#ifndef WIN__95
#include <ntsecapi.h>
#endif
#include <tchar.h>
#include <assert.h>


inline BOOL GetTextualSid( const PSID pSid, LPTSTR tstrTextualSid, LPDWORD cchSidSize);

inline DWORD FormatUserKeyPath( const PSID pSid, const PTCHAR tstrRegRoot, PTCHAR* ptstrCurrentUserKeyPath);

inline DWORD GetCurrentUserSid(PBYTE* pSidUser);

inline BOOL IsNTSystemVersion();

#ifndef WIN__95
//
// Concatenates tstrRegRoot path and a the string representation of the current user's SID.
//
// [in]   tstrRegRoot - Registry root prefix.
// [out]  ptstrCurrentUserKeyPath - Returns a string that represents the current
//        user's root key in the Registry.  Caller must call MemFree
//		  to free the buffer when done with it.
//
// Returns win32 error.

inline DWORD FormatUserKeyPath( const PSID pSid,
								const PTCHAR tstrRegRoot, 
								PTCHAR* ptstrCurrentUserKeyPath)
{
    HANDLE hToken = NULL;
	BYTE* bTokenInfo = NULL;
	TCHAR* tstrTextualSid = NULL;
 	DWORD cchSidSize = 0;
	DWORD dwFuncRetStatus = ERROR_SUCCESS;

	
	assert(pSid);

	if(!GetTextualSid( pSid, NULL, &cchSidSize))
	{
		dwFuncRetStatus = GetLastError();
		if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
		{
			goto Exit;
		}
		dwFuncRetStatus = ERROR_SUCCESS;
	}

	tstrTextualSid = new TCHAR[cchSidSize];
	if(!tstrTextualSid)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	if(!GetTextualSid( pSid, tstrTextualSid, &cchSidSize))
	{
		dwFuncRetStatus = GetLastError();
		goto Exit;
	}

	// allocate an extra char for '\'
	*ptstrCurrentUserKeyPath = new TCHAR[_tcslen(tstrRegRoot) + cchSidSize + 2];
	if(!tstrTextualSid)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	*ptstrCurrentUserKeyPath[0] = TEXT('\0');
	if(tstrRegRoot[0] != TEXT('\0'))
	{
		_tcscat(*ptstrCurrentUserKeyPath,tstrRegRoot);
		if(tstrRegRoot[_tcslen(tstrRegRoot) - 1] != TEXT('\\'))
		{
			_tcscat(*ptstrCurrentUserKeyPath,TEXT("\\"));
		}
	}

	_tcscat(*ptstrCurrentUserKeyPath,tstrTextualSid);

Exit:
	if(hToken)
	{
		CloseHandle(hToken);
	}
	if(bTokenInfo)
	{
		delete bTokenInfo;
	}
	if(tstrTextualSid)
	{
		delete tstrTextualSid;
	}

	return dwFuncRetStatus;

}

//
// return current user SID
//
DWORD GetCurrentUserSid(PBYTE* pSidUser)
{
	
	HANDLE hToken = NULL;
	DWORD dwFuncRetStatus = ERROR_SUCCESS;
	BYTE* bTokenInfo = NULL;
	PSID pReturnedUseSid;

	assert(pSidUser);

	// Open impersonated token
    if(!OpenThreadToken( GetCurrentThread(),
						 TOKEN_READ,
						 TRUE,
						 &hToken))
	{
		dwFuncRetStatus = GetLastError();
	}

	if(dwFuncRetStatus != ERROR_SUCCESS)
	{
		if(dwFuncRetStatus != ERROR_NO_TOKEN)
		{
			return dwFuncRetStatus;
		}
		
		// Thread is not impersonating a user, get the process token
		if(!OpenProcessToken( GetCurrentProcess(),
                              TOKEN_READ,
                              &hToken))
		{
			return GetLastError();
		}
    }

   	DWORD cbBuffer;

	// Get user's token information
	if(!GetTokenInformation( hToken,
							 TokenUser,
							 NULL,
							 0,
							 &cbBuffer))
	{
		dwFuncRetStatus = GetLastError();
		if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
		{
			goto Exit;
		}

		dwFuncRetStatus = ERROR_SUCCESS;
	}

	bTokenInfo = new BYTE[cbBuffer];
	if(!bTokenInfo)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}
	
	if(!GetTokenInformation( hToken,
							 TokenUser,
							 bTokenInfo,
							 cbBuffer,
							 &cbBuffer))
	{
		
		dwFuncRetStatus = GetLastError();
		goto Exit;
	}

	pReturnedUseSid = ( ((TOKEN_USER*)bTokenInfo)->User).Sid; 
	if(!IsValidSid(pReturnedUseSid)) 
	{
		dwFuncRetStatus = E_FAIL;
	}

	*pSidUser = new BYTE[GetLengthSid(pReturnedUseSid)];
 	if(!*pSidUser)
	{
		dwFuncRetStatus = ERROR_OUTOFMEMORY;
		goto Exit;
	}

	memcpy(*pSidUser, pReturnedUseSid, GetLengthSid(pReturnedUseSid));

Exit:
	if(hToken)
	{
		CloseHandle(hToken);
	}

	if(bTokenInfo)
	{
		delete bTokenInfo;
	}
	
	return dwFuncRetStatus;	
}

// ------------------------------------------
// This function was copied from SDK samples
// ------------------------------------------
/*
	This function obtain the textual representation
    of a binary Sid.  
  
    A standardized shorthand notation for SIDs makes it simpler to
    visualize their components:

    S-R-I-S-S...

    In the notation shown above,

    S identifies the series of digits as an SID,
    R is the revision level,
    I is the identifier-authority value,
    S is subauthority value(s).

    An SID could be written in this notation as follows:
    S-1-5-32-544

    In this example,
    the SID has a revision level of 1,
    an identifier-authority value of 5,
    first subauthority value of 32,
    second subauthority value of 544.
    (Note that the above Sid represents the local Administrators group)

    The GetTextualSid() function will convert a binary Sid to a textual
    string.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then the SID
    will be in the form:

    S-1-5-21-2127521184-1604012920-1887927527-19009
      ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      | | |      |          |          |        |
      +-+-+------+----------+----------+--------+--- Decimal

    Otherwise it will take the form:

    S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
      ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      |       |        |      |          |          |        |
      |   Hexidecimal  |      |          |          |        |
      +----------------+------+----------+----------+--------+--- Decimal

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended
    error information, call the Win32 API GetLastError().
*/


inline BOOL GetTextualSid( const PSID pSid,          // binary Sid
						   LPTSTR tstrTextualSid,    // buffer for Textual representaion of Sid
						   LPDWORD cchSidSize        // required/provided TextualSid buffersize
						   )
{
    PSID_IDENTIFIER_AUTHORITY pSia;
    DWORD dwSubAuthorities;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) 
	{
		return FALSE;
	}

   	SetLastError(0);
    
	// obtain SidIdentifierAuthority
	//
	pSia = GetSidIdentifierAuthority(pSid);

	if(GetLastError())
	{
		return FALSE;
	}

    // obtain sidsubauthority count
    //
	dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

	if(GetLastError())
	{
		return FALSE;
	}

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
	{
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(tstrTextualSid, TEXT("S-%lu-"), SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (pSia->Value[0] != 0) || (pSia->Value[1] != 0) )
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
							   TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
							   (USHORT)pSia->Value[0],
							   (USHORT)pSia->Value[1],
							   (USHORT)pSia->Value[2],
							   (USHORT)pSia->Value[3],
							   (USHORT)pSia->Value[4],
							   (USHORT)pSia->Value[5]);
    } 
	else
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
							   TEXT("%lu"),
							   (ULONG)(pSia->Value[5])       +
							   (ULONG)(pSia->Value[4] <<  8) +
							   (ULONG)(pSia->Value[3] << 16) +
							   (ULONG)(pSia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    //
    for(DWORD dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
	{
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy, TEXT("-%lu"),
							  *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}
#endif // #ifndef WIN__95

/*
	Function returns TRUE if the current runing OS is NT platform
*/
BOOL IsNTSystemVersion()
{
	OSVERSIONINFO osvi;

   	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (! GetVersionEx( &osvi)) 
	{
		 return FALSE;
	}

	switch (osvi.dwPlatformId)
	{
	case VER_PLATFORM_WIN32_NT:
	// NT platforms
		return TRUE;
		break;

	case VER_PLATFORM_WIN32_WINDOWS:
	// Win95, Win98
		return FALSE;
		break;
	}

	return FALSE;
}

#endif //_REG_HACK_UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dllmain.c ===
#include <windows.h>


BOOL WINAPI 
DllMain(
    HINSTANCE hDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

    FUNCTION:    DllMain
    
    INPUTS:      hDLL       - handle of DLL
                 dwReason   - indicates why DLL called
                 lpReserved - reserved
                 Note that the return value is used only when
                 dwReason = DLL_PROCESS_ATTACH.
                 Normally the function would return TRUE if DLL initial-
                 ization succeeded, or FALSE it it failed.

--*/

{
	UNREFERENCED_PARAMETER(hDLL);
	UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // DLL is attaching to the address space of the current process.
        //

      break;

    case DLL_THREAD_ATTACH:
        //
        // A new thread is being created in the current process.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        // A thread is exiting cleanly.
        //

        break;

    case DLL_PROCESS_DETACH:
        //
        // The calling process is detaching the DLL from its address space.
        //

		break;

    default:
        MessageBox(
			NULL,
			TEXT("Reached default in DLLmain"),
			TEXT("TiffTools.dll: DllMain failure:"),
			MB_OK
			);
        return FALSE;
    }//switch (dwReason)

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dummydecode.c ===
#include "..\..\Tiff\Src\Decode.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\test.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.h

Abstract:

    This file is the private header file for the
    TIFF test program. All source files in this
    program include this header only.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "tifflib.h"
#include "faxutil.h"
#include "tiff.h"


#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))


#pragma pack(1)

typedef struct _WINRGBQUAD {
    BYTE   rgbBlue;                 // Blue Intensity Value
    BYTE   rgbGreen;                // Green Intensity Value
    BYTE   rgbRed;                  // Red Intensity Value
    BYTE   rgbReserved;             // Reserved (should be 0)
} WINRGBQUAD, *PWINRGBQUAD;

typedef struct _BMPINFO {
    WORD   Type;                    //  File Type Identifier
    DWORD  FileSize;                //  Size of File
    WORD   Reserved1;               //  Reserved (should be 0)
    WORD   Reserved2;               //  Reserved (should be 0)
    DWORD  Offset;                  //  Offset to bitmap data
    DWORD  Size;                    //  Size of Remianing Header
    DWORD  Width;                   //  Width of Bitmap in Pixels
    DWORD  Height;                  //  Height of Bitmap in Pixels
    WORD   Planes;                  //  Number of Planes
    WORD   BitCount;                //  Bits Per Pixel
    DWORD  Compression;             //  Compression Scheme (0=none)
    DWORD  SizeImage;               //  Size of bitmap in bytes
    DWORD  XPelsPerMeter;           //  Horz. Resolution in Pixels/Meter
    DWORD  YPelsPerMeter;           //  Vert. Resolution in Pixels/Meter
    DWORD  ClrUsed;                 //  Number of Colors in Color Table
    DWORD  ClrImportant;            //  Number of Important Colors
} BMPINFO, *UNALIGNED PBMPINFO;

#pragma pack()

//
// prototypes
//
DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    );

DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    );

VOID
PostProcessTiffFile(
    LPTSTR TiffFile
    );


BOOL
TiffPreProcess(
   LPTSTR FileName,
   DWORD CompressionType
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\include\testruntimeerr.h ===
//
//  Run Time Exception Classes
//
#ifndef _TEST_RUN_TIME_ERR_H
#define _TEST_RUN_TIME_ERR_H

#include <windows.h>

//stl
#include <exception>
#include <stdexcept>
//#include <locale>
#include <sstream>

#include <tstring.h>

// Declarations
//
static const TCHAR* no_error_str = TEXT("could not construct error string");
#define THROW_TEST_RUN_TIME_WIN32(errorcode,details) throw Win32Err(errorcode,__LINE__,TEXT(__FILE__),details);



////////////////////////// base class for all test run time classes ////////////////////////
class TestRunTimeErr_Base : public std::runtime_error
{
public:
	TestRunTimeErr_Base(DWORD dwErrorcode,DWORD dwLine,const TCHAR* tstrModule,const TCHAR* tstrDetails):std::runtime_error("")
	{
     try
	 { 
        m_tstrModule =   tstrModule;
        m_dwLine = dwLine;
	    m_tstrDetails = tstrDetails;
	    m_dwErrorcode = dwErrorcode;
        if(m_tstrDetails == TEXT(""))
		{
         m_tstrDetails = TEXT("NONE");
		}
	  }
	  catch(...)
	  {

	  }	   
   	}
	// Was preferable using virtual what() of runtime_error class, but this one
	// returns char*
    virtual const TCHAR* description()const = 0;
	virtual const TCHAR* module()const{return m_tstrModule.c_str();}
	virtual const TCHAR* details()const{return m_tstrDetails.c_str();}
	virtual DWORD line()const{return m_dwLine;}
	virtual DWORD error()const{return m_dwErrorcode;}
   
private:
    tstring m_tstrModule;
	tstring m_tstrDetails;
	DWORD m_dwLine;
	DWORD m_dwErrorcode;
};


/////////////////////////////class for win32 exceptions /////////////////////////////////////////////
class Win32Err : public TestRunTimeErr_Base
{
public: 
	Win32Err(DWORD dwErrorcode,DWORD dwLine,const TCHAR* tstrModule,const TCHAR* tstrDetails)throw():
		TestRunTimeErr_Base(dwErrorcode,dwLine,tstrModule,tstrDetails)
	{
	  
    }

	virtual const TCHAR* description()const
	{
      try
      {
       	otstringstream otstrtmp;
        tstring tstrwin32errstr = SystemErrorDescription( error());
		otstrtmp << TEXT("Got win32 error - ") << error() << TEXT("(") << tstrwin32errstr 
				 << TEXT(")") << TEXT(" Line ") << line() << TEXT(", module ") << module()
				 << TEXT(".") << TEXT(" Details: ") << details() << TEXT(".");
		tstring tstrretstr = otstrtmp.str();
	    return  tstrretstr.c_str();
	  }
	  catch(...)
      {
        return no_error_str;
      }
    }
   
	static tstring Win32Err::SystemErrorDescription (DWORD dwErrorCode) 
	{
	   LCID locale =  GetUserDefaultLCID();
	   TCHAR* tstrErrorDescription;	
	   tstring  tstrReturnString;
	   bool fSuccess  = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
									   NULL,
									   dwErrorCode,
									   locale,
									   (LPTSTR)&tstrErrorDescription,
									   0,
									   NULL )!=0;


	  if(fSuccess == true)
	  {
		tstrReturnString = tstrErrorDescription;
	  } 
	  else
	  {
		 tstrReturnString = TEXT("No error description");
	  }

	  return tstrReturnString;
	}

};



#endif //#ifndef _TEST_RUN_TIME_ERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dummyencode.c ===
#include "..\..\Tiff\Src\Encode.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dummyfasttiff.c ===
#include "..\..\Tiff\Src\FastTiff.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\tiffcomp.c ===
#include "TiffComp.h"
/*
DWORD TiffCompare(LPTSTR szFile1, LPTSTR szFile2)
{

	return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dummytifflib.c ===
#include "..\..\Tiff\Src\TiffLib.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\dummyutil.c ===
#include "..\..\Tiff\Src\Util.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\tiffcomp.h ===
#ifndef __TIFF_COMP_F
#define __TIFF_COMP_F

#include <windows.h>



#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))


#pragma pack(1)

typedef struct _WINRGBQUAD {
    BYTE   rgbBlue;                 // Blue Intensity Value
    BYTE   rgbGreen;                // Green Intensity Value
    BYTE   rgbRed;                  // Red Intensity Value
    BYTE   rgbReserved;             // Reserved (should be 0)
} WINRGBQUAD, *PWINRGBQUAD;

typedef struct _BMPINFO {
    WORD   Type;                    //  File Type Identifier
    DWORD  FileSize;                //  Size of File
    WORD   Reserved1;               //  Reserved (should be 0)
    WORD   Reserved2;               //  Reserved (should be 0)
    DWORD  Offset;                  //  Offset to bitmap data
    DWORD  Size;                    //  Size of Remianing Header
    DWORD  Width;                   //  Width of Bitmap in Pixels
    DWORD  Height;                  //  Height of Bitmap in Pixels
    WORD   Planes;                  //  Number of Planes
    WORD   BitCount;                //  Bits Per Pixel
    DWORD  Compression;             //  Compression Scheme (0=none)
    DWORD  SizeImage;               //  Size of bitmap in bytes
    DWORD  XPelsPerMeter;           //  Horz. Resolution in Pixels/Meter
    DWORD  YPelsPerMeter;           //  Vert. Resolution in Pixels/Meter
    DWORD  ClrUsed;                 //  Number of Colors in Color Table
    DWORD  ClrImportant;            //  Number of Important Colors
} BMPINFO, *UNALIGNED PBMPINFO;

#pragma pack()

//
// prototypes
//
DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    );

DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    );

DWORD
TiffCompare(
    LPTSTR lpctstrFirstTiffFile,
    LPTSTR lpctstrSecondBmpFile
    );


VOID
PostProcessTiffFile(
    LPTSTR TiffFile
    );



#endif //__TIFF_COMP_F
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\tifftools.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    test.h

Abstract:

    This file is the private header file for the
    TIFF test program. All source files in this
    program include this header only.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "..\tiff\inc\tifflib.h"
#include "faxutil.h"

//
//shortcut for DLL exports
//
#define DLL_EXPORT __declspec(dllexport)



#define Align(p, x)  (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))


#pragma pack(1)

typedef struct _WINRGBQUAD {
    BYTE   rgbBlue;                 // Blue Intensity Value
    BYTE   rgbGreen;                // Green Intensity Value
    BYTE   rgbRed;                  // Red Intensity Value
    BYTE   rgbReserved;             // Reserved (should be 0)
} WINRGBQUAD, *PWINRGBQUAD;

typedef struct _BMPINFO {
    WORD   Type;                    //  File Type Identifier
    DWORD  FileSize;                //  Size of File
    WORD   Reserved1;               //  Reserved (should be 0)
    WORD   Reserved2;               //  Reserved (should be 0)
    DWORD  Offset;                  //  Offset to bitmap data
    DWORD  Size;                    //  Size of Remianing Header
    DWORD  Width;                   //  Width of Bitmap in Pixels
    DWORD  Height;                  //  Height of Bitmap in Pixels
    WORD   Planes;                  //  Number of Planes
    WORD   BitCount;                //  Bits Per Pixel
    DWORD  Compression;             //  Compression Scheme (0=none)
    DWORD  SizeImage;               //  Size of bitmap in bytes
    DWORD  XPelsPerMeter;           //  Horz. Resolution in Pixels/Meter
    DWORD  YPelsPerMeter;           //  Vert. Resolution in Pixels/Meter
    DWORD  ClrUsed;                 //  Number of Colors in Color Table
    DWORD  ClrImportant;            //  Number of Important Colors
} BMPINFO, *UNALIGNED PBMPINFO;

#pragma pack()

//
// prototypes
//
DWORD
ConvertBmpToTiff(
    LPTSTR BmpFile,
    LPTSTR TiffFile,
    DWORD CompressionType
    );

DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    );

DLL_EXPORT
int
__cdecl
TiffCompare(
    LPTSTR lpctstrFirstTiffFile,
    LPTSTR lpctstrSecondBmpFile,
    BOOL   fSkipFirstLineOfSecondFile
    );


VOID
PostProcessTiffFile(
    LPTSTR TiffFile
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\logelle.c ===
//
// this is an implementation of the log.h interface to support ELLE logging.
// you must implicitly link you project to your logger's lib.
// you may use this implementation as a reference for impementing other loggers
//


#pragma warning( disable:4201)
#include <windows.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include "log.h"


#ifdef UNICODE 
	#define NT // for elle 
#endif// UNICODE  

//
// include your logger header file here
//
#include "..\..\include\elle.h"


//***************************************************
//
// static function declarations
//
//***************************************************
static WORD _SevToElle(DWORD dwSeverity);



//***************************************************
//
// static variables to hold the state of the logger
//
//***************************************************

//
// ELLE's internals
//
//static LOGSYS s_LogSys;

//
// logging is disabled by default, and turned on by lgInitializeLogger()
//
static long s_lDisableLogging = TRUE;


//
// initialize your logger, or if it is an object, create an instance of it.
//
BOOL __cdecl lgInitializeLogger()
{
	s_lDisableLogging = FALSE;
	return EcInitElle();

}



//
// close your logger, or if it is an object, delete it.
//
BOOL __cdecl lgCloseLogger()
{
	s_lDisableLogging = TRUE;
	return EcDeInitElle();

}


BOOL __cdecl lgBeginSuite(LPCTSTR szSuite)
{
#ifdef UNICODE
	char MultiByteStr[1024];
	int nSizeOfMultiByteStr = sizeof(MultiByteStr);
	BOOL fDefaultCharUsed;
	int nRet;

	memset(MultiByteStr, 0, nSizeOfMultiByteStr);

	nRet = WideCharToMultiByte(  
		CP_ACP,         // ANSI code page
		0,         // performance and mapping flags
		szSuite, // address of wide-character string
		lstrlen(szSuite),       // number of characters in string
		MultiByteStr,  // address of buffer for new string
		nSizeOfMultiByteStr,      // size of buffer
		"*",  // address of default for unmappable characters
		&fDefaultCharUsed   // address of flag set when default char. used
		);
	//
	//BUGBUG: check return values
	//
	_ASSERTE(!fDefaultCharUsed);

	BeginSuite(MultiByteStr);
#else
	BeginSuite((LPSTR)szSuite);
#endif//UNICODE

	return TRUE;
							 
}

BOOL __cdecl lgEndSuite()
{
	EndSuite();
	return TRUE;
}

BOOL __cdecl lgBeginCase(const DWORD dwCase, LPCTSTR szCase)
{
#ifdef UNICODE
	BeginCaseW(dwCase, (LPTSTR)szCase);
#else
	BeginCase(dwCase, (LPTSTR)szCase);
#endif
	return TRUE;
}



BOOL __cdecl lgEndCase()
{
	EndCase();
	return TRUE;
}


//
// set the log level.
// 9 is most details, 0 is least.
// return value is not supported.
//
int __cdecl lgSetLogLevel(const int nLogLevel)
{
	SetFileLevel((WORD)nLogLevel);
	SetCommLevel((WORD)nLogLevel);
	SetViewportLevel((WORD)nLogLevel);
	SetDbgOutLevel((WORD)nLogLevel);

	return 0;
}


BOOL __cdecl lgDisableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 1L);
}

BOOL __cdecl lgEnableLogging()
{
	return InterlockedExchange(&s_lDisableLogging, 0L);
}

void __cdecl lgLogDetail(const DWORD dwSeverity, const DWORD dwLevel, LPCTSTR szFormat, ...)
{
	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#else
        LogDetailA(_SevToElle(dwSeverity) ,(WORD)dwLevel,(LPTSTR)msg);
#endif
		va_end(args);
    }
}

void __cdecl lgLogError(const DWORD dwSeverity, LPCTSTR szFormat, ...)
{
	UNREFERENCED_PARAMETER(dwSeverity);

	if (s_lDisableLogging) return;
	else
	{
		TCHAR msg[1024];
        va_list args;
	
        va_start(args, szFormat);
        _vstprintf(msg,szFormat,args);
#ifdef UNICODE
        LogDetailW(L_FAIL,0,(LPTSTR)msg);
#else
        LogDetailA(L_FAIL,0,(LPTSTR)msg);
#endif
		va_end(args);
    }

}

//
// if you can log to a remote machine, set it here.
// it is irrelevant for ELLE.
//
BOOL __cdecl lgSetLogServer(LPCTSTR szLogServer)
{
	UNREFERENCED_PARAMETER(szLogServer);
	return FALSE;
}



static WORD _SevToElle(DWORD dwSeverity)
{
	switch(dwSeverity)
	{
	case LOG_PASS: return (WORD)L_PASS;
	case LOG_X: return (WORD)L_X;
	case LOG_SEV_1:
	case LOG_SEV_2:
	case LOG_SEV_3:
	case LOG_SEV_4:
		return (WORD)L_FAIL;

	default:
		_ASSERTE(FALSE);

	}

	//
	// to remove the warning
	//
	return (WORD)L_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\vbtestit\main.c ===
#include "..\TiffTools\TiffTools.h"


// VBTESTIT

// this program is a re-write of TESTIT, intended to use only with a Visual BASIC shell command
// DO NOT USE - USE TESTIT instead
// it is used only within BVTCOM.VBP (module: tiffcompare.bas)


int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;
	FILE *fp;
    int cbDifferentPixels;
	int iRetVal = EOF;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

    if (4 != argc)
    {
        _tprintf(TEXT("Usage: %s <1st tiff> <2nd tiff> <bool: fSkipFirstLineOfSecondFile>\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 1\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent.tif c:\\recv.tif 0\n"), argv[0]);
        _tprintf(TEXT("Example: %s c:\\sent1.tif c:\\sent2.tif 0\n"), argv[0]);
        return -1;
    }

    cbDifferentPixels = TiffCompare(argv[1], argv[2], _ttoi(argv[3]));
	
	fp=fopen("testit.out","w");
	if (NULL == fp)
	{
		_tprintf(TEXT("fopen(testit.out,w) failed with ec=0x08%X\n"), GetLastError());
        return -1;
	}
	fprintf (fp,"%d",cbDifferentPixels);
	iRetVal = fclose(fp);
	if (EOF == iRetVal)
	{
		_tprintf(TEXT("fclose(testit.out) failed with ec=0x08%X\n"), GetLastError());
        return -1;
	}

	return cbDifferentPixels;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\tiff\tifftools\tiff2bmp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff2bmp.c

Abstract:

    This file contains support for converting a
    TIFF file to a Windows BMP file.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "TiffTools.h"
#include "tiff.h"
#include <crtdbg.h>
#pragma hdrstop




void PrintTheTiff(
    LPTSTR TiffFile
    ) 
{
    FAX_PRINT_INFO PrintInfo;
    FAX_CONTEXT_INFOW ContextInfo;
    LPTSTR FullPath = TEXT("c:\\temp\\thetiff.tif");
    DWORD TmpFaxJobId;
    BOOL Rslt;

    ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFOW) );

    PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFOW);
    PrintInfo.OutputFileName = FullPath;

    ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW);

    if (!FaxStartPrintJobW( NULL, &PrintInfo, &TmpFaxJobId, &ContextInfo )) {
        DeleteFile( FullPath );
        SetLastError( ERROR_INVALID_FUNCTION );
        return;
    }

    Rslt = PrintTiffFile( ContextInfo.hDC, TiffFile );

    EndDoc( ContextInfo.hDC );
    DeleteDC( ContextInfo.hDC );

}






DWORD
ConvertTiffToBmp(
    LPTSTR TiffFile,
    LPTSTR BmpFile
    )

/*++

Routine Description:

    Converts a TIFF file to a BMP file.

Arguments:

    TiffFile            - TIFF file name
    BmpFile             - BMP file name

Return Value:

    None.

--*/

{
    HANDLE hTiff = NULL;
    HANDLE hBmp = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    LPVOID fPtr = NULL;
    PBMPINFO BmpInfo = NULL;
    PWINRGBQUAD Palette = NULL;
    LPBYTE dPtr;
    LPBYTE sPtr;
    DWORD i,j;
    LPBYTE BmpData = NULL;
    TIFF_INFO TiffInfo;

	BOOL fSuccess = FALSE;

	DWORD dwRetval = ERROR_SUCCESS;//success

	SetLastError(ERROR_SUCCESS);

    hTiff = TiffOpen( TiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        _tprintf( TEXT("could not open tiff file\n") );
        goto out;
    }

    _tprintf( TEXT("ImageWidth:\t%d\n"),TiffInfo.ImageWidth);
    _tprintf( TEXT("ImageHeight:\t%d\n"),TiffInfo.ImageHeight);
    _tprintf( TEXT("PageCount:\t%d\n"),TiffInfo.PageCount);
    _tprintf( TEXT("Photometric:\t%d\n"),TiffInfo.PhotometricInterpretation);
    _tprintf( TEXT("ImageSize:\t%d\n"),TiffInfo.ImageSize);
    _tprintf( TEXT("Compression:\t%d\n"),TiffInfo.CompressionType);
    _tprintf( TEXT("FillOrder:\t%d\n"),TiffInfo.FillOrder);
    _tprintf( TEXT("YResolution:\t%d\n"),TiffInfo.YResolution);


    BmpData = VirtualAlloc(
        NULL,
        TiffInfo.ImageHeight * (TiffInfo.ImageWidth / 8),
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!BmpData) {
        _tprintf( TEXT("could not allocate memory for bmp data\n") );
        goto out;
    }

    if (!TiffRead( hTiff, BmpData,0 )) {
        _tprintf( TEXT("could not read tiff data\n") );
        TiffClose( hTiff );
        goto out;
    }

    hBmp = CreateFile(
        BmpFile,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hBmp == INVALID_HANDLE_VALUE) {
        _tprintf( TEXT("CreateFile(%s) failed with %d\n"), BmpFile, GetLastError() );
        return 0;
    }


    hMap = CreateFileMapping(
        hBmp,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        1024*1024*10,  // 10 meg
        NULL
        );
    if (!hMap) {
        return GetLastError();
    }

    fPtr = MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!fPtr) {
        return GetLastError();
    }

    BmpInfo = (PBMPINFO) fPtr;
    Palette = (PWINRGBQUAD) (BmpInfo + 1);

    BmpInfo->Type           =  0x4d42;
    BmpInfo->FileSize       =  sizeof(BMPINFO) + ((TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight);
    BmpInfo->Reserved1      =  0;
    BmpInfo->Reserved2      =  0;
    BmpInfo->Offset         =  sizeof(BMPINFO) + (sizeof(WINRGBQUAD) * 2);
    BmpInfo->Size           =  sizeof(BMPINFO) - FIELD_OFFSET(BMPINFO,Size);
    BmpInfo->Width          =  TiffInfo.ImageWidth;
    BmpInfo->Height         =  TiffInfo.ImageHeight;
    BmpInfo->Planes         =  1;
    BmpInfo->BitCount       =  1;
    BmpInfo->Compression    =  0;
    BmpInfo->SizeImage      =  (TiffInfo.ImageWidth / 8) * TiffInfo.ImageHeight;
    BmpInfo->XPelsPerMeter  =  0;
    BmpInfo->YPelsPerMeter  =  0;
    BmpInfo->ClrUsed        =  0;
    BmpInfo->ClrImportant   =  0;

	if (TiffInfo.PhotometricInterpretation) {
		//
		// minimum is black.
		//
		Palette[1].rgbBlue      = 0;
		Palette[1].rgbGreen     = 0;
		Palette[1].rgbRed       = 0;
		Palette[1].rgbReserved  = 0;

		Palette[0].rgbBlue      = 0xff;
		Palette[0].rgbGreen     = 0xff;
		Palette[0].rgbRed       = 0xff;
		Palette[0].rgbReserved  = 0;
	} else {
		//
		// minimum is white
		//
		Palette[0].rgbBlue      = 0;
		Palette[0].rgbGreen     = 0;
		Palette[0].rgbRed       = 0;
		Palette[0].rgbReserved  = 0;

		Palette[1].rgbBlue      = 0xff;
		Palette[1].rgbGreen     = 0xff;
		Palette[1].rgbRed       = 0xff;
		Palette[1].rgbReserved  = 0;
	}

    sPtr = (LPBYTE) (BmpData + ((TiffInfo.ImageHeight-1)*(TiffInfo.ImageWidth/8)));
    dPtr = (LPBYTE) ((LPBYTE)(Palette + 2));

    //
    // capture the data
    //
    for (i=0; i<TiffInfo.ImageHeight; i++) {

        CopyMemory( dPtr, sPtr, TiffInfo.ImageWidth/8 );

        for (j=0; j<(TiffInfo.ImageWidth/8); j++) {
            dPtr[j] ^= 0xff;
        }

        sPtr -= (TiffInfo.ImageWidth/8);
        dPtr += (TiffInfo.ImageWidth/8);

    }

	fSuccess = TRUE;

out:
    if (NULL != hTiff) TiffClose( hTiff );

    if (NULL != BmpData) 
	{
		if (!VirtualFree( BmpData, 0, MEM_RELEASE ))
		{
			_tprintf(TEXT("Internal error: ConvertTiffToBmp(): VirtualFree() failed with %d\n"), GetLastError());
			_ASSERTE(FALSE);
			fSuccess = FALSE;
		}
	}
	else _ASSERTE(NULL == hTiff);

    if (INVALID_HANDLE_VALUE != hBmp) CloseHandle( hBmp );
	else _ASSERTE(NULL == BmpData);

    if (NULL != hMap) CloseHandle( hMap );
	else _ASSERTE(INVALID_HANDLE_VALUE == hBmp);

    if (NULL != fPtr) UnmapViewOfFile( fPtr );
	else _ASSERTE(NULL == hMap);

    PrintTheTiff(TiffFile);

	//
	// function starts with SetLastError(ERROR_SUCCESS)
	//
	dwRetval = GetLastError();

	if (fSuccess && (ERROR_SUCCESS != dwRetval))
	{
		_tprintf(TEXT("Internal error: ConvertTiffToBmp(): (fSuccess && (ERROR_SUCCESS != dwRetval))\n"));
		_ASSERTE(FALSE);
		return ERROR_INVALID_PARAMETER;
	}

	//
	// BUGBUG: I return ERROR_INVALID_PARAMETER if I do not know the exact error
	//
	if (ERROR_SUCCESS == dwRetval) ERROR_INVALID_PARAMETER;

	return dwRetval;
}



void
PrintTiffInfo(LPCTSTR lpctstrFileName, TIFF_INFO *pti)
{
    _tprintf( TEXT("%s: TIFF_INFO:\n"), lpctstrFileName);
    _tprintf( TEXT("  ImageWidth:\t%d\n"), pti->ImageWidth);
    _tprintf( TEXT("  ImageHeight:\t%d\n"), pti->ImageHeight);
    _tprintf( TEXT("  PageCount:\t%d\n"), pti->PageCount);
    _tprintf( TEXT("  Photometric:\t%d\n"), pti->PhotometricInterpretation);
    _tprintf( TEXT("  ImageSize:\t%d\n"),pti->ImageSize);
    _tprintf( TEXT("  Compression:\t%d\n"), pti->CompressionType);
    _tprintf( TEXT("  FillOrder:\t%d\n"), pti->FillOrder);
    _tprintf( TEXT("  YResolution:\t%d\n"), pti->YResolution);
}

//
// this array will hold in each entry the number of bits that the entry has in its hex notation.
// e.g. s_nNumOfBitsInChar[0xf0] == 4
//
static int s_nNumOfBitsInChar[256];

//
// fills s_nNumOfBitsInChar[]
// algorithm:
// for each byte value, shift left and check if LS bit is 1.
//
static void PrepareBitcountLookup()
{
    static BOOL s_fLookupReady = FALSE;
    int iChar;

    if (s_fLookupReady) return;
    else s_fLookupReady = TRUE;

	for (iChar = 0; iChar < 256 ; iChar++)
	{
		int nChar = iChar;
		int nCount = 0;
        int iBit;

		for (iBit = 0; iBit < 8; iBit++)
		{
			if (0x1 == (nChar & 0x1))
			{
				nCount++;
			}

			nChar = nChar >> 1;
		}

		s_nNumOfBitsInChar[iChar] = nCount;
	}

	return;
}




DLL_EXPORT
int
__cdecl
TiffCompare(
    LPTSTR lpctstrFirstTiffFile,
    LPTSTR lpctstrSecondTiffFile,
    BOOL   fSkipFirstLineOfSecondFile
    )

/*++

Routine Description:

    comparees 2 tiff files.

Arguments:

    lpctstrFirstTiffFile
    lpctstrSecondTiffFile

Return Value:

    None.

Author:
	Micky Snir (MickyS) August 3, 98

--*/

{
    HANDLE hFirstTiff = NULL;
    HANDLE hSecondTiff = NULL;
	DWORD	dwFirstTiffImageWidth = 0;
	DWORD	dwFirstTiffImageHeight = 0;
	DWORD	dwSecondTiffImageWidth = 0;
	DWORD	dwSecondTiffImageHeight = 0;
	DWORD	dwFirstTiffLines = 0;
	DWORD	dwFirstTiffStripDataSize = 0;
	DWORD	dwSecondTiffLines = 0;
	DWORD	dwSecondTiffStripDataSize = 0;
/*
    HANDLE hFirstBmp = NULL;
    HANDLE hSecondBmp = NULL;
    HANDLE hFirstMap = NULL;
    HANDLE hSecondMap = NULL;
    LPVOID fFirstPtr = NULL;
    LPVOID fSecondPtr = NULL;
    PBMPINFO BmpFirstInfo = NULL;
    PBMPINFO BmpSecondInfo = NULL;
    PWINRGBQUAD Palette = NULL;
    LPBYTE dPtr = NULL;
    LPBYTE sPtr = NULL;
*/
    LPBYTE pbFirstBmpData = NULL;
    LPBYTE pbSecondBmpData = NULL;
    TIFF_INFO tiFirst;
    TIFF_INFO tiSecond;
	DWORD iPage;
    int cbBitErrors = 0;
	BOOL fHeightCmpFail = FALSE;
	BOOL fHeightCmpWithOffByOneFail = FALSE;

	BOOL fRetval = FALSE;


	//
	// open the 2 tiff files.
	//
    hFirstTiff = TiffOpen( lpctstrFirstTiffFile, &tiFirst, TRUE, FILLORDER_MSB2LSB );
    if (!hFirstTiff) 
	{
        _tprintf( TEXT("could not open tiff file %s\n") ,lpctstrFirstTiffFile);
        cbBitErrors = -1;
        goto out;
    }
    PrintTiffInfo(lpctstrFirstTiffFile, &tiFirst);

    hSecondTiff = TiffOpen( lpctstrSecondTiffFile, &tiSecond, TRUE, FILLORDER_MSB2LSB );
    if (!hSecondTiff) 
	{
        _tprintf( TEXT("could not open tiff file %s\n") ,lpctstrSecondTiffFile);
        cbBitErrors = -1;
        goto out;
    }
    PrintTiffInfo(lpctstrSecondTiffFile, &tiSecond);

	//
	// if PageCount, ImageWidth or ImageHeight are different: fail.
	//
	if (tiFirst.PageCount != tiSecond.PageCount)
	{
        _tprintf( 
			TEXT("tiFirst.PageCount(%d) != tiSecond.PageCount(%d)\n"),
			tiFirst.PageCount,
			tiSecond.PageCount
			);
        cbBitErrors = -1;
        goto out;
	}

	//
	// compare each page
	//
	_tprintf(
		TEXT("\nComparing pages: 1-%d"),
		tiFirst.PageCount
		);
	
	for (iPage = 1; iPage <= tiFirst.PageCount; iPage++)
	{
		//
		// initialize image height Comparison flags (to indicate comparisons have *not* failed)
		// 
		fHeightCmpFail = FALSE;
		fHeightCmpWithOffByOneFail = FALSE;

		//
		// seek to iPage on both files
		//
		if (!TiffSeekToPage(
				hFirstTiff,
				iPage,
				FILLORDER_MSB2LSB
				)
			)
		{
			_tprintf( 
				TEXT("TiffSeekToPage(hFirstTiff, %d, FILLORDER_MSB2LSB) failed with %d\n"),
				iPage,
				GetLastError()
				);
            cbBitErrors = -1;
			goto out;
		}

		if (!TiffSeekToPage(
				hSecondTiff,
				iPage,
				FILLORDER_MSB2LSB
				)
			)
		{
			_tprintf( 
				TEXT("TiffSeekToPage(hSecondTiff, %d, FILLORDER_MSB2LSB) failed with %d\n"),
				iPage,
				GetLastError()
				);
            cbBitErrors = -1;
			goto out;
		}

		//
		// get Width and Height of current page for 2 tiffs
		//
		if (!TiffGetCurrentPageData(
								hFirstTiff, 
								&dwFirstTiffLines, 
								&dwFirstTiffStripDataSize, 
								&dwFirstTiffImageWidth,
								&dwFirstTiffImageHeight
								)
			)
		{
			_tprintf( TEXT("could not get page data\n") );
			cbBitErrors = -1;
			goto out;
		}

		_ASSERTE(dwFirstTiffImageWidth);
		_ASSERTE(dwFirstTiffImageHeight);

		if (!TiffGetCurrentPageData(
								hSecondTiff, 
								&dwSecondTiffLines, 
								&dwSecondTiffStripDataSize, 
								&dwSecondTiffImageWidth,
								&dwSecondTiffImageHeight
								)
			)
		{
			_tprintf( TEXT("could not get page data\n") );
			cbBitErrors = -1;
			goto out;
		}
		
		_ASSERTE(dwSecondTiffImageWidth);
		_ASSERTE(dwSecondTiffImageHeight);
		
		//
		//Dump this new info to the console
		//
		_tprintf(
			TEXT("Comparing page:%d/%d\n"),
			iPage,
			tiFirst.PageCount
			);
		_tprintf(
			TEXT("   Tiff#1 (%s):\n\tLines=%d, StripDataSize=%d, ImageWidth=%d, ImageHeight=%d\n"),
			lpctstrFirstTiffFile,
			dwFirstTiffLines,
			dwFirstTiffStripDataSize,
			dwFirstTiffImageWidth,
			dwFirstTiffImageHeight
			);
		_tprintf(
			TEXT("   Tiff#2 (%s):\n\tLines=%d, StripDataSize=%d, ImageWidth=%d, ImageHeight=%d\n"),
			lpctstrSecondTiffFile,
			dwSecondTiffLines,
			dwSecondTiffStripDataSize,
			dwSecondTiffImageWidth,
			dwSecondTiffImageHeight
			);

		//
		// verify that both pages have same Width and Height
		//
		if (dwFirstTiffImageWidth != dwSecondTiffImageWidth)
		{
			_tprintf( 
				TEXT("dwFirstTiffImageWidth(%d) != dwSecondTiffImageWidth(%d)\n"),
				dwFirstTiffImageWidth,
				dwSecondTiffImageWidth
				);
			cbBitErrors = -1;
			goto out;
		}

		//
		// Image Height Compare
		// 
		if (dwFirstTiffImageHeight != dwSecondTiffImageHeight)
		{
			fHeightCmpFail = TRUE;
		}
		//
		// Image Height Compare (height is off by 1?) //workaround for bug
		//
		if (dwFirstTiffImageHeight != (dwSecondTiffImageHeight - 1))
		{
			fHeightCmpWithOffByOneFail = TRUE;
		}

		//
		// due to known bug we only fail if both height comparisons fail
		//
		// details on bug: when a cp is rendered the SentItems copy of the cp and the 
		// Inbox copy (the received file) differ in the first line of the data,
		// *but* the image heights are identical.
		// when a document (not a cp) is rendered the SentItems copy of the cp and the 
		// Inbox copy (the received file) differ in the first line of the data,
		// *and* the image heights differ by one.
		//
		// => we don't know if we want to compare height or height-1,
		//    so we only fail if both fail.
		//
		if ((TRUE == fHeightCmpWithOffByOneFail) && (TRUE == fHeightCmpFail))
		{
			_tprintf( 
				TEXT("ERR: both height comparisons have failed.\n")
				);
			cbBitErrors = -1;
			goto out;
		}


		//
		// de-allocate memory of previous 2 bmp datas
		//
		if (NULL != pbFirstBmpData)
		{
			if (!VirtualFree( pbFirstBmpData, 0, MEM_RELEASE ))
			{
				_ASSERTE(FALSE);
			}
		}
		if (NULL != pbSecondBmpData)
		{
			if (!VirtualFree( pbSecondBmpData, 0, MEM_RELEASE ))
			{
				_ASSERTE(FALSE);
			}
		}

		//
		// allocate memory for 2 bmp datas
		//
		pbFirstBmpData = VirtualAlloc(
			NULL,
			dwFirstTiffImageHeight * (dwFirstTiffImageWidth / 8),
			MEM_COMMIT,
			PAGE_READWRITE
			);
		if (!pbFirstBmpData) 
		{
			_tprintf( TEXT("could not allocate memory for bmp data\n") );
			cbBitErrors = -1;
			goto out;
		}

		pbSecondBmpData = VirtualAlloc(
			NULL,
			dwSecondTiffImageHeight * (dwSecondTiffImageWidth / 8),
			MEM_COMMIT,
			PAGE_READWRITE
			);
		if (!pbSecondBmpData) 
		{
			_tprintf( TEXT("could not allocate memory for bmp data\n") );
			cbBitErrors = -1;
			goto out;
		}
		
		//
		// read the iPage in each file
		//
		if (!TiffRead( hFirstTiff, pbFirstBmpData,0 )) 
		{
			_tprintf( TEXT("could not read tiff data\n") );
            cbBitErrors = -1;
			goto out;
		}

		if (!TiffRead( hSecondTiff, pbSecondBmpData,0 )) 
		{
			_tprintf( TEXT("could not read tiff data\n") );
            cbBitErrors = -1;
			goto out;
		}

        //
        // compare the bitmaps, while counting the non-matching pixels
        //
        PrepareBitcountLookup();

        if (fSkipFirstLineOfSecondFile)
        {
		    if (0 != memcmp(
				    pbFirstBmpData, 
				    pbSecondBmpData+(dwFirstTiffImageWidth/8), 
				    (dwFirstTiffImageHeight-1) * (dwFirstTiffImageWidth / 8)
				    )
			    )
		    {
                PBYTE pNextByteInFirstFile;
                PBYTE pNextByteInSecondFile;
	            for (	pNextByteInFirstFile = pbFirstBmpData, pNextByteInSecondFile = pbSecondBmpData+(dwFirstTiffImageWidth/8); 
			            pNextByteInFirstFile < pbFirstBmpData+(dwFirstTiffImageHeight-1) * (dwFirstTiffImageWidth / 8); 
			            pNextByteInFirstFile++, pNextByteInSecondFile++
		            )
	            {
		            *pNextByteInFirstFile = 
			            ((*pNextByteInFirstFile) ^ (*(pNextByteInSecondFile+1)));

		            cbBitErrors += s_nNumOfBitsInChar[*pNextByteInFirstFile];
	            }
			    _tprintf(
					TEXT("Page NOT identical, cbBitErrors=%d\n"),
					cbBitErrors
					);
			    //goto out;
		    }
            else
            {
    		    _tprintf(
					TEXT("Page is identical, cbBitErrors=%d\n"),
					cbBitErrors
					);
            }
        }
        else
        {
		    if (0 != memcmp(
				    pbFirstBmpData, 
				    pbSecondBmpData, 
				    dwFirstTiffImageHeight * (dwFirstTiffImageWidth / 8)
				    )
			    )
		    {
                PBYTE pNextByteInFirstFile;
                PBYTE pNextByteInSecondFile;
	            for (	pNextByteInFirstFile = pbFirstBmpData, pNextByteInSecondFile = pbSecondBmpData; 
			            pNextByteInFirstFile < pbFirstBmpData+(dwFirstTiffImageHeight) * (dwFirstTiffImageWidth / 8); 
			            pNextByteInFirstFile++, pNextByteInSecondFile++
		            )
	            {
		            *pNextByteInFirstFile = 
			            ((*pNextByteInFirstFile) ^ (*pNextByteInSecondFile));

		            cbBitErrors += s_nNumOfBitsInChar[*pNextByteInFirstFile];
	            }
			    _tprintf(
					TEXT("Page NOT identical, cbBitErrors=%d\n"),
					cbBitErrors
					);
			    //goto out;
		    }
            else
            {
    		    _tprintf(
					TEXT("Page is identical, cbBitErrors=%d\n"),
					cbBitErrors
					);
            }
        }
	}

	fRetval = TRUE;
	if (0 == cbBitErrors)
    {
        _tprintf( TEXT("Tiff files are identical\n") );
    }
    else
    {
        _tprintf(
			TEXT("Tiff files are DIFFERENT in %d bits\n"),
			cbBitErrors
			);
    }

out:
    if (NULL != hFirstTiff)
	{
		if (!TiffClose( hFirstTiff ))
		{
			_ASSERTE(FALSE);
		}
	}
    if (NULL != hSecondTiff)
	{
		if (!TiffClose( hSecondTiff ))
		{
			_ASSERTE(FALSE);
		}
	}
    if (NULL != pbFirstBmpData)
	{
		if (!VirtualFree( pbFirstBmpData, 0, MEM_RELEASE ))
		{
			_ASSERTE(FALSE);
		}
	}
    if (NULL != pbSecondBmpData)
	{
		if (!VirtualFree( pbSecondBmpData, 0, MEM_RELEASE ))
		{
			_ASSERTE(FALSE);
		}
	}

    return cbBitErrors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\dirtiffcmp.cpp ===
//
//
// Filename:	DirTiffCmp.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "DirTiffCmp.h"

BOOL DirToDirTiffCompare(
	LPTSTR	/* IN */	szDir1,
	LPTSTR	/* IN */	szDir2,
    BOOL    /* IN */    fSkipFirstLine,
	DWORD	/* IN */    dwExpectedNumberOfFiles // optional
	)
{
	BOOL fRetVal = FALSE;
	CFilenameVector* pMyDir1FileVec = NULL;
	CFilenameVector* pMyDir2FileVec = NULL;


	if (NULL == szDir1)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir1\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if (NULL == szDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==szDir2\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir1, &pMyDir1FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir1
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir1FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir1FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir1FileVec->size(),
            szDir1,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	if ( FALSE == GetTiffFilesOfDir(szDir2, &pMyDir2FileVec))
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: GetTiffFilesOfDir(%s) failed\n"),
			TEXT(__FILE__),
			__LINE__,
            szDir2
			);
		goto ExitFunc;
	}

	PrintVector(pMyDir2FileVec);

	if (dwExpectedNumberOfFiles < 0xFFFFFFFF && dwExpectedNumberOfFiles != pMyDir2FileVec->size())
	{
		// The caller passed expected number of files and it differs from actual number of files
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: Actual number of files (%ld) in %s differs from the expected (%ld)\n"),
			TEXT(__FILE__),
			__LINE__,
			pMyDir2FileVec->size(),
            szDir2,
			dwExpectedNumberOfFiles
			);
		goto ExitFunc;
	}

	::lgLogDetail(
		LOG_X,
        1,
		TEXT("FILE(%s) LINE(%d):\n DirToDirTiffCompare: comparing %s and %s with fSkipFirstLine=%d\n"),
		TEXT(__FILE__),
		__LINE__,
        szDir1,
        szDir2,
        fSkipFirstLine
		);

    fRetVal = VecToVecTiffCompare(pMyDir1FileVec, pMyDir2FileVec, fSkipFirstLine);

ExitFunc:
	FreeVector(pMyDir1FileVec);
	FreeVector(pMyDir2FileVec);
	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\dirtiffcmp.h ===
//
//
// Filename:	DirTiffCmp.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _DIR_TIFF_COMPARE_H__
#define _DIR_TIFF_COMPARE_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include "VecTiffCmp.h"
#include <log.h>


#ifdef __cplusplus
extern "C"
{
#endif

//
// func compares *.tif files in directory szDir1 to *.tif files in directory szDir2
// returns true iff for every *.tif file in szDir1 there exists a *.tif 
// file in szDir2 whose image is identical, and vice versa.
//
BOOL DirToDirTiffCompare(
	LPTSTR	/* IN */	szDir1,
	LPTSTR	/* IN */	szDir2,
    BOOL    /* IN */    fSkipFirstLine,
	DWORD	/* IN */    dwExpectedNumberOfFiles = 0xFFFFFFFF // optional
	);


#ifdef __cplusplus
}
#endif


#endif //_DIR_TIFF_COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\tiff.h ===
// Copyright (c) 1996-1998 Microsoft Corporation

// Module name:		LogElle.c
// Author:			Micky Snir (mickys)
// Date:			

#ifndef __TIFF_TOOLS_WRAPPER_H__
#define __TIFF_TOOLS_WRAPPER_H__

#ifdef __cplusplus
extern "C"
{
#endif
        
#include "..\tiff\tifftools\TiffTools.h"

#ifdef __cplusplus
}
#endif


#endif //__TIFF_TOOLS_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\filenamevec.h ===
//
//
// Filename:	FilenameVec.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _FILENAME_VEC_H__
#define _FILENAME_VEC_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <vector>

#include <log.h>

using namespace std ;

#ifdef __cplusplus
extern "C"
{
#endif


#define MAX_LOG_BUF 1024
#define MAX_PRINT_BUF (1024*16)
#define FILE_TYPE_TO_LOOK_FOR	TEXT("\\*.tif")

// CMsgHandlerClientVector
// an STL vector of pointers to CMsgHandlerClients
#ifdef _C_FILENAME_VECTOR_
#error "redefinition of _C_FILENAME_VECTOR_"
#else
#define _C_FILENAME_VECTOR_
typedef vector< LPTSTR > CFilenameVector;
#endif

//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	);

//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	);

// returns TRUE if pFileVec is empty, FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec);

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec);

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec);

// prints all strings in vector
void PrintVector(CFilenameVector* /* IN */ pFileVec);

// delete all files that vector holds names for
BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec);

#ifdef __cplusplus
}
#endif


#endif //_FILENAME_VEC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\vectiffcmp.h ===
//
//
// Filename:	VecTiffCmp.h
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#ifndef _VECTOR_TIFF_COMPARE_H__
#define _VECTOR_TIFF_COMPARE_H__


#include <windows.h>
#include <TCHAR.H>
#include <crtdbg.h>

#include <log.h>
//NOTE: order of includes matters!!
#include "FilenameVec.h"
#include "Tiff.h"


#ifdef __cplusplus
extern "C"
{
#endif

//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
	CFilenameVector*	/* IN */	pFileVec1,
	CFilenameVector*	/* IN */	pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
	);

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
	LPTSTR				/* IN */	szFile,
	CFilenameVector*	/* IN */	pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
	LPDWORD				/* OUT */	pdwIndex
	);

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
//
BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	);


#ifdef __cplusplus
}
#endif


#endif //_VECTOR_TIFF_COMPARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\main.cpp ===
//
//
// Filename:	main.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "DirTiffCmp.h"
#include <log.h>


#define PARAM_NUM 5
#define FALSE_TSTR TEXT("false")
#define TRUE_TSTR TEXT("true")


static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal);
static void PrintUsageInfo(void);


int __cdecl main(int argc, char* argvA[])
{
    LPTSTR *argv;

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
    argv = argvA;
#endif

	// arguments are dir names
	// we check that every file in dir1 has an identical file in dir2
	// and that both dirs have same number of files.

	int nRetVal = -1; //to indicate failure

	LPTSTR szDir1 = NULL;
	LPTSTR szDir2 = NULL;
	LPTSTR szExpectedResult = NULL;
    BOOL fExpectedResult = TRUE;
	LPTSTR szSkipFirstLine = NULL;
    BOOL fSkipFirstLine = FALSE;
    BOOL fCmpRetVal = FALSE;

	//
	// Init logger
	//
	if (!::lgInitializeLogger())
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgInitializeLogger failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto Exit;
	}

	//
	// Begin test suite (logger)
	//
	if(!::lgBeginSuite(TEXT("Verify Tiff Files Suite")))
	{
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgBeginSuite failed with GetLastError()=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto Exit;
	}

	::lgBeginCase(
		1,
		TEXT("Tiff Compare the Files in two directories\n")
		);

	//
	// check num of command line args
	//
	if (PARAM_NUM != argc)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n got argc=%d (should be %d)\n"),
			TEXT(__FILE__),
			__LINE__,
			argc,
			PARAM_NUM
			);
        PrintUsageInfo();
		goto Exit;
	}
	

	//
	// duplicate args
	//
	szDir1 = _tcsdup(argv[1]);
	if (NULL == szDir1)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
	szDir2 = _tcsdup(argv[2]);
	if (NULL == szDir2)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
    szSkipFirstLine = _tcsdup(argv[3]);
	if (NULL == szSkipFirstLine)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}
    szExpectedResult = _tcsdup(argv[4]);
	if (NULL == szExpectedResult)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _tcsdup failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto Exit;
	}

	// log command line params using elle logger
	::lgLogDetail(
		LOG_X,
		1,
		TEXT("FILE(%s) LINE(%d):\n Command line params:\n\tszDir1=%s\n\tszDir2=%s\n\tszSkipFirstLine=%s\n\tszExpectedResult=%s\n"),
		TEXT(__FILE__),
		__LINE__,
		szDir1,
		szDir2,
        szSkipFirstLine,
        szExpectedResult
		);

    if (FALSE == GetBoolFromStr(szExpectedResult, &fExpectedResult))
    {
        goto Exit;
    }

    if (FALSE == GetBoolFromStr(szSkipFirstLine, &fSkipFirstLine))
    {
        goto Exit;
    }


    fCmpRetVal = DirToDirTiffCompare(szDir1, szDir2, fSkipFirstLine);
	if (fExpectedResult == fCmpRetVal)
	{
		::lgLogDetail(
            LOG_X,
            1,
            TEXT("*** DirToDirTiffCompare returned as expected (%d) ***\n"),
            fExpectedResult
            );
	}
	else
	{
		::lgLogError(
            LOG_SEV_1,
            TEXT("*** DirToDirTiffCompare returned %d NOT as expected (%d) ***\n"),
            fCmpRetVal,
            fExpectedResult
            );
	}

    nRetVal = 0;

Exit:

	::lgEndCase();

    //
	// End test suite (logger)
	//
	if (!::lgEndSuite())
	{
		//
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		//
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgEndSuite returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		//fRetVal = FALSE;
	}

	//
	// Close the Logger
	//
	if (!::lgCloseLogger())
	{
		//this is not possible since API always returns TRUE
		//but to be on the safe side
		::_tprintf(TEXT("FILE:%s LINE:%d\nlgCloseLogger returned FALSE\n"),
			TEXT(__FILE__),
			__LINE__
			);
		//fRetVal = FALSE;
	}

	return(nRetVal);
}

static BOOL GetBoolFromStr(LPCTSTR /* IN */ szVal, BOOL* /* OUT */ pfVal)
{
    BOOL fRetVal = FALSE;
    BOOL fTmpVal = FALSE;

    _ASSERTE(NULL != szVal);
    _ASSERTE(NULL != pfVal);

    if ( 0 == _tcscmp(szVal, FALSE_TSTR) )
    {
        fTmpVal = FALSE;
    }
    else
    {
        if ( 0 == _tcscmp(szVal, TRUE_TSTR) )
        {
            fTmpVal = TRUE;
        }
        else
        {
		    ::lgLogError(
                LOG_SEV_1,
                TEXT("\n3rd param is invalid (%s)\nShould be '%s' or '%s'\n"),
                szVal,
                TRUE_TSTR,
                FALSE_TSTR
                );
            goto ExitFunc;
        }
    }

    (*pfVal) = fTmpVal;
    fRetVal = TRUE;

ExitFunc:
    return(fRetVal);
}


static void PrintUsageInfo(void)
{
    lgLogError(
        LOG_SEV_1,
        TEXT("VerifyTiffFiles Usage:\n\tVerifyTiffFiles.exe dir1 dir2 skip_first_line expected_result\n\tdir1 & dir2 are dirs to compare\n\tskip_first_line is true | false\n\texpected result is true | false\n")
        );
    _tprintf(TEXT("VerifyTiffFiles - compares tiff files of 2 directories\n"));
    _tprintf(TEXT("Usage:\n"));
    _tprintf(TEXT("\tVerifyTiffFiles.exe dir1 dir2 skip_first_line expected_result\n"));
    _tprintf(TEXT("\tdir1 & dir2      - directories to compare\n"));
    _tprintf(TEXT("\tskip_first_line  - 'true' | 'false'\n"));
    _tprintf(TEXT("\t                   whether or not to skip the 1st line of files in dir1\n"));
    _tprintf(TEXT("\texpected_result  - 'true' | 'false'\n"));
    _tprintf(TEXT("\t                   are we expecting the files to be identical ('true') or not ('false')\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\vectiffcmp.cpp ===
//
//
// Filename:	VecTiffCmp.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//


#include "VecTiffCmp.h"


//
// func compares *.tif files in pFileVec1 to *.tif files in pFileVec2
// returns true iff for every *.tif file in pFileVec1 there exists a *.tif 
// file in pFileVec2 whose image is identical, and vice versa.
//
BOOL VecToVecTiffCompare(
	CFilenameVector*	/* IN */	pFileVec1,
	CFilenameVector*	/* IN */	pFileVec2,
    BOOL                /* IN */    fSkipFirstLine
	)
{
	BOOL fRetVal = FALSE;
	UINT uVec1Size = 0;
	UINT uVec2Size = 0;
	int i = 0;
	LPTSTR szCurFile = NULL;
	DWORD dwIndex = -1;
	CFilenameVector* pTmpFileVec = NULL;

	//
	// check in params
	//
	_ASSERTE(NULL != pFileVec1);
	_ASSERTE(NULL != pFileVec2);

	// check sizes
	uVec1Size = pFileVec1->size();
	uVec2Size = pFileVec2->size();
	::lgLogDetail(
		LOG_X,
		9,
		TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size=%d uVec2Size=%d\n"),
		TEXT(__FILE__),
		__LINE__,
		uVec1Size,
		uVec2Size
		);

	if ((0 == uVec1Size)&&(0 == uVec2Size))
	{
		// 2 empty vecs do not qualify as having identical images
        ::lgLogDetail(
            LOG_X,
            1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size==uVec2Size==0\n"),
		    TEXT(__FILE__),
		    __LINE__
		    );
		goto ExitFunc;
	}

	if (uVec1Size != uVec2Size)
	{
		// if sizes are different than return false.
        ::lgLogDetail(
            LOG_X,
            1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: uVec1Size(%d)!=uVec2Size(%d)\n"),
		    TEXT(__FILE__),
		    __LINE__,
		    uVec1Size,
		    uVec2Size
		    );
		fRetVal = FALSE;
		goto ExitFunc;
	}

	//
	// make a copy of pFileVec2
	//
	// one level copy => create a vector (pTmpFileVec) with ptrs pointing at
	// pFileVec2 strings.
	//
	if (FALSE == FirstLevelDup(&pTmpFileVec,pFileVec2))
	{
        ::lgLogError(
            LOG_SEV_1,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: FirstLevelDup failed\n"),
		    TEXT(__FILE__),
		    __LINE__
            );
		goto ExitFunc;
	}

	//
	// compare every file in pFileVec1 to any file in pTmpFileVec (==pFileVec2)
	//
	for (i = 0; i < uVec1Size; i++)
	{
		szCurFile = (LPTSTR)(*pFileVec1)[i];
		_ASSERTE(NULL != szCurFile);
		// compare a specific file from pFileVec1 (szCurFile) to any file
		// in pTmpFileVec (==pFileVec2)
		if (FALSE == FileToVecTiffCompare(szCurFile, pTmpFileVec, fSkipFirstLine, &dwIndex))
		{
			// we could not find a file with the same image as szCurFile
			// in pTmpFileVec, so return FALSE
            ::lgLogDetail(
                LOG_X,
                4,
		        TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: no match for file %s (fSkipFirstLine=%d)\n"),
		        TEXT(__FILE__),
		        __LINE__,
                szCurFile,
                fSkipFirstLine
                );
			goto ExitFunc;
		}
		//
		// file with index dwIndex in pTmpFileVec has same image as szCurFile
		// => "remove" (actually NULL) pTmpFileVec->at(dwIndex)
		// this way, next time compare to (*pTmpFileVec)[dwIndex] will return FALSE
		//
		(*pTmpFileVec)[dwIndex] = NULL;
	}

	//
	//If we reach here then we finished the for loop and all went well
	//we should return TRUE
	//
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif files in pFileVec
// returns true iff there exists a *.tif file in pFileVec whose image is 
// identical to szFile image.
// sets pdwIndex to the index of the identical file in pFileVec.
//
BOOL FileToVecTiffCompare(
	LPTSTR				/* IN */	szFile,
	CFilenameVector*	/* IN */	pFileVec,
    BOOL                /* IN */    fSkipFirstLine,
	LPDWORD				/* OUT */	pdwIndex
	)
{
	BOOL fRetVal = FALSE;
	UINT uVecSize = 0;
	int i = 0;
	BOOL fFoundIdenticalImage = FALSE;

	//
	// check in params
	//
	_ASSERTE(NULL != pFileVec);
	_ASSERTE(NULL != szFile);
	_ASSERTE(NULL != pdwIndex);


	//
	uVecSize = pFileVec->size();
	if (0 == uVecSize)
	{
        ::lgLogDetail(
            LOG_X,
            4,
		    TEXT("FILE(%s) LINE(%d):\n FileToVecTiffCompare: pFileVec->size==0\n"),
		    TEXT(__FILE__),
		    __LINE__
            );
		goto ExitFunc;
	}

	for (i = 0; i < uVecSize; i++)
	{
		if (TRUE == FileToFileTiffCompare(szFile, (*pFileVec)[i], fSkipFirstLine))
		{
			(*pdwIndex) = i;
			fRetVal = TRUE;
			goto ExitFunc;
		}
	}

ExitFunc:
	return(fRetVal);
}

//
// func compares *.tif file szFile to *.tif file szFile2
// returns true iff szFile1 and szFile2 images are identical.
// NOTE: we do not consider 2 NULL filenames as 2 files with same NULL image
//       => if szFile1==szFile2==NULL we return FALSE.
//
BOOL FileToFileTiffCompare(
	LPTSTR				/* IN */	szFile1,
	LPTSTR				/* IN */	szFile2,
    BOOL                /* IN */    fSkipFirstLine
	)
{
	BOOL fRetVal = FALSE;
	LPTSTR szRetVal = TEXT("NOT identical");
    DWORD dwLogLevel = 9;

	if (NULL == szFile1)
	{
		goto ExitFunc;
	}

	if (NULL == szFile2)
	{
		goto ExitFunc;
	}

	if (0 == TiffCompare(szFile1, szFile2, fSkipFirstLine))
	{
		fRetVal = TRUE;
		szRetVal = TEXT("identical");
        dwLogLevel = 1;
	}

ExitFunc:
	::lgLogDetail(
		LOG_X,
		dwLogLevel,
		TEXT("FileToFileTiffCompare:\n File#1:%s\n File#1:%s\n With (fSkipFirstLine=%d)\n Are %s.\n"),
		szFile1, 
		szFile2, 
        fSkipFirstLine,
		szRetVal
		);
	return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxbvt\verifytifffiles\filenamevec.cpp ===
//
//
// Filename:	FilenameVec.cpp
// Author:		Sigalit Bar (sigalitb)
// Date:		3-Feb-99
//
//



#include "FilenameVec.h"

//
// func creats the CFilenameVector and adds all TIF files in szDir to it
//
BOOL GetTiffFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;

    fRetVal = GetFilesOfDir(szDir, TEXT("TIF"), ppMyDirFileVec);

	return(fRetVal);
}

//
// creates new vector and adds all files with extension szFileExtension in szDir to it
//
// Note: szDir must be without last '\' char (e.g. "C:\Dir1\Dir2", NOT "C:\Dir1\Dir2\")
//       szFileExtension must be the actual extension (e.g. "tif" or "*", NOT "*.tif" or "*.*")
BOOL GetFilesOfDir(
	LPCTSTR				/* IN */	szDir,
	LPCTSTR				/* IN */	szFileExtension,
	CFilenameVector**	/* OUT */	ppMyDirFileVec
	)
{
	BOOL fRetVal = FALSE;
	DWORD dwErr = 0;
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA FindFileData;
	LPTSTR szCurrentFullFilename = NULL;
	CFilenameVector* pTmpDirFileVec = NULL;
	DWORD dwLen = 0;

	_ASSERTE(NULL != ppMyDirFileVec);
	_ASSERTE(NULL != szFileExtension);
	_ASSERTE(NULL != szDir);


	//
	// compose string of filenames to look for
	//
	TCHAR szLookFor[MAX_PATH];

    if (0 >= ::_sntprintf(szLookFor, MAX_PATH, TEXT("%s\\*.%s"), szDir, szFileExtension))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	::lgLogDetail(
		LOG_X,
		9,
		TEXT("\n szLookFor=%s\n"),
		szLookFor
		);

	//
	// create an empty vector
	//
	pTmpDirFileVec = new(CFilenameVector);
	if (NULL == pTmpDirFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new(CFilenameVector) failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	//
	// find first file
	//
	hFindFile =  ::FindFirstFile(szLookFor, &FindFileData);
	dwErr = ::GetLastError();

	if ((INVALID_HANDLE_VALUE == hFindFile) && (ERROR_FILE_NOT_FOUND == dwErr))
	{
		//this is ok, we will return an empty vector
		::lgLogDetail(
			LOG_X,
			9,
			TEXT("no files found, returning empty vector\n")
			);
		(*ppMyDirFileVec) = pTmpDirFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	if (INVALID_HANDLE_VALUE == hFindFile)
	{
		// INVALID_HANDLE_VALUE and last err != ERROR_FILE_NOT_FOUND
		// => error
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n FindFirstFile returned INVALID_HANDLE_VALUE with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			dwErr
			);
		goto ExitFunc;
	}


	//
	// add found file name to vector
	//
	if(NULL == FindFileData.cFileName)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;// backslash+null
	szCurrentFullFilename = new TCHAR[dwLen];
	if (NULL == szCurrentFullFilename)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
		goto ExitFunc;
	}
	szCurrentFullFilename[dwLen-1] = TEXT('\0');

    if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
    {
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
    }

	pTmpDirFileVec->push_back(szCurrentFullFilename);
	szCurrentFullFilename = NULL;


	//
	// look for any other such files in dir
	//
	while (TRUE == FindNextFile(hFindFile, &FindFileData))
	{
		// found another file with extension szFileExtension in dir
		// so add it to vector
		if(NULL == FindFileData.cFileName)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n NULL==FindFileData.cFileName\n"),
				TEXT(__FILE__),
				__LINE__
				);
			goto ExitFunc;
		}
		dwLen = ::_tcslen(szDir) + ::_tcslen(FindFileData.cFileName) + 2;//backslash+null
		szCurrentFullFilename = new TCHAR[dwLen];
		if (NULL == szCurrentFullFilename)
		{
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
			goto ExitFunc;
		}
		szCurrentFullFilename[dwLen-1] = TEXT('\0');
        if (0 >= ::_sntprintf(szCurrentFullFilename, MAX_PATH, TEXT("%s\\%s"), szDir, FindFileData.cFileName))
        {
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\n _sntprintf failed\n"),
			    TEXT(__FILE__),
			    __LINE__
			    );
		    goto ExitFunc;
        }
		pTmpDirFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	} // 	while (TRUE == FindNextFile(hFindFile, &FindFileData))


	//no more files with extension szFileExtension in dir

	//
	// set out param
	//
	(*ppMyDirFileVec) = pTmpDirFileVec;
	fRetVal = TRUE;

ExitFunc:
	if (FALSE == fRetVal)
	{
		// free vec
		FreeVector(pTmpDirFileVec);
        delete(pTmpDirFileVec); 
	}
    if (INVALID_HANDLE_VALUE != hFindFile) 
    {
        if(!FindClose(hFindFile))
        {
			::lgLogError(
				LOG_SEV_1,
				TEXT("FILE(%s) LINE(%d):\n FindClose(hFindFile) failed with err=%d\n"),
				TEXT(__FILE__),
				__LINE__,
				::GetLastError()
				);
        }
    }
 

	return(fRetVal);
}


//
// func copies pSrcFileVec vector to (*ppDstFileVec) vector
// copy is 1st level, that is, ptrs to strings are copied but
// strings themselves are not duplicated.
//
BOOL FirstLevelDup(
	CFilenameVector**	/* OUT */	ppDstFileVec,
	CFilenameVector*	/* IN */	pSrcFileVec
	)
{
	BOOL fRetVal = FALSE;
	UINT uSrcVecSize = 0;
	CFilenameVector* pTmpFileVec = NULL;
	UINT i = 0;
	LPTSTR szCurrentFullFilename = NULL;

	_ASSERTE(NULL != ppDstFileVec);
	_ASSERTE(NULL != pSrcFileVec);

	// create empty Dst vec
	pTmpFileVec = new(CFilenameVector);
	if (NULL == pTmpFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n new failed with err=%d\n"),
			TEXT(__FILE__),
			__LINE__,
			::GetLastError()
			);
	}

	uSrcVecSize = pSrcFileVec->size();
	if (0 == uSrcVecSize)
	{
		(*ppDstFileVec) = pTmpFileVec;
		fRetVal = TRUE;
		goto ExitFunc;
	}

	for (i = 0; i < uSrcVecSize; i++)
	{
		szCurrentFullFilename = (LPTSTR)pSrcFileVec->at(i);
		pTmpFileVec->push_back(szCurrentFullFilename);
		szCurrentFullFilename = NULL;
	}

	(*ppDstFileVec) = pTmpFileVec;
	fRetVal = TRUE;

ExitFunc:
	return(fRetVal);
}

// returns TRUE if pFileVec is empty (size=0), FALSE otherwise
BOOL IsEmpty(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n IsEmpty called with pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return(FALSE);
	}

	if (0 == pFileVec->size())
	{
		return(TRUE);
	}

    return(FALSE);
}

// removes all string pointers from vector (==clears vector)
// does NOT free the pointers.
void ClearVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}
	pFileVec->clear();
}

// frees all strings in vector and clears vector
void FreeVector(CFilenameVector* /* IN OUT */ pFileVec)
{
	if (NULL == pFileVec)
	{
		return;
	}

	UINT uSize = pFileVec->size();
	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		delete[](LPTSTR)pFileVec->at(i);
        (LPTSTR)pFileVec->at(i) = NULL;
	}
}

void PrintVector(CFilenameVector* /* IN */ pFileVec)
{
	if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
		return;
	}

	UINT uSize = pFileVec->size();
	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("\n Vector is Empty\n")
			);
		return;
	}

	TCHAR szBuf[MAX_PRINT_BUF];
	szBuf[0] = NULL;
	szBuf[MAX_PRINT_BUF-1] = NULL;

	::_stprintf(szBuf,TEXT("\n Vector size = %d\n"),uSize);
	_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));

	UINT i = 0;
	for (i = 0; i < uSize; i++)
	{
		::_stprintf(szBuf,TEXT("%s\t filename(%d)=%s\n"),szBuf,i,pFileVec->at(i));
		_ASSERTE(MAX_PRINT_BUF > ::_tcslen(szBuf));
	}
    if (MAX_LOG_BUF > ::_tcslen(szBuf))
    {
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("%s"),
		    szBuf
		    );
    }
    else
    {
        ::_tprintf(TEXT("%s"),szBuf);
	    ::lgLogDetail(
		    LOG_X,
		    1,
		    TEXT("Vector too long, logged to console\n"),
		    szBuf
		    );
    }
}


BOOL DeleteVectorFiles(CFilenameVector* /* IN */ pFileVec)
{
    BOOL fRetVal = TRUE;
	UINT uSize = pFileVec->size();
	UINT i = 0;

    if (NULL == pFileVec)
	{
		::lgLogError(
			LOG_SEV_1,
			TEXT("FILE(%s) LINE(%d):\n pFileVec==NULL\n"),
			TEXT(__FILE__),
			__LINE__
			);
        fRetVal = FALSE;
		goto ExitFunc;
	}

	if (0 == uSize)
	{
		::lgLogDetail(
			LOG_X,
			1,
			TEXT("FILE(%s) LINE(%d):\nVector is Empty - no files to delete\n"),
			TEXT(__FILE__),
			__LINE__
			);
		goto ExitFunc;
	}

	for (i = 0; i < uSize; i++)
	{
        if (FALSE == ::DeleteFile(pFileVec->at(i)))
        {
            //TO DO: what about when the delete fails because the file does not exist
		    ::lgLogError(
			    LOG_SEV_1,
			    TEXT("FILE(%s) LINE(%d):\nDeleteFile(%s) failed with err=0x%8X\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i),
                ::GetLastError()
			    );
            fRetVal = FALSE;
        }
        else
        {
		    ::lgLogDetail(
			    LOG_X,
			    4,
			    TEXT("FILE(%s) LINE(%d):\ndeleted file %s\n"),
			    TEXT(__FILE__),
			    __LINE__,
                pFileVec->at(i)
			    );
        }
	}

ExitFunc:
    return(fRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cntritem.h ===
//--------------------------------------------------------------------------
// CNTRITEM.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CNTRITEM_H__
#define __CNTRITEM_H__


class CDrawDoc;
class CDrawView;

class CDrawItem : public COleClientItem
{
	DECLARE_SERIAL(CDrawItem)

// Constructors
public:
	CDrawItem(CDrawDoc* pContainer = NULL, CDrawOleObj* pDrawObj = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CDrawDoc* GetDocument()
		{ return (CDrawDoc*)COleClientItem::GetDocument(); }
	CDrawView* GetActiveView()
		{ return (CDrawView*)COleClientItem::GetActiveView(); }

	CDrawOleObj* m_pDrawObj;    // back pointer to OLE draw object

// Operations
	BOOL UpdateExtent();

// Implementation
public:
	~CDrawItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

protected:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};



#endif   //#ifndef __CNTRITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\awcpe.cpp ===
//--------------------------------------------------------------------------
// AWCPE.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      main module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include <tchar.h>
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include <shlobj.h>
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"
#include <dos.h>
#include <direct.h>
#include <cderr.h>
#include "faxreg.h"
#include "faxutil.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define ENFORCE_FILE_EXTENSION_ON_OPEN_FILE 0
#define SHOW_ALL_FILES_FILTER 1


#define BIGGERTHAN_RECT          1
#define NOTSETBY_RECT            0
#define SMALLERTHAN_RECT        -1





UINT NEAR WM_AWCPEACTIVATE = ::RegisterWindowMessage(TEXT("AWCPE_ACTIVATE"));

BYTE BASED_CODE _gheaderVer1[20]={0x41,0x57,0x43,0x50,0x45,0x2D,0x56,0x45,0x52,0x30,0x30,0x31,0x9C,0x87,0x00,0x00,0x00,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer2[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x32,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer3[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x33,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer4[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x34,0x9C,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5w[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};
BYTE BASED_CODE _gheaderVer5a[20]={0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x61,0x87,0x00,0x00,0x00};

static TCHAR szShellPrintFmt[] = _T("%s\\shell\\print\\command");
static TCHAR szShellOpenFmt[] = _T("%s\\shell\\open\\command");
static TCHAR szShellDdeexecFmt[] = _T("%s\\shell\\open\\ddeexec");
static TCHAR szStdOpenArg[] = _T(" \"%1\"");
static TCHAR szStdPrintArg[] = _T(" /P \"%1\"");
static TCHAR szDocIcon[] = TEXT("%s\\DefaultIcon");
static const TCHAR szDocIconArg[] = _T(",1");






CDrawApp NEAR theApp;


//-------------------------------------------------------------------------
CDrawApp::CDrawApp() : 
   m_iErrorCode(EXIT_SUCCESS),
   m_pFaxMap(NULL),
   m_pIawcpe(NULL),
   m_hMod(NULL),
   m_note(NULL),
   m_note_wasread(FALSE),
   m_note_wasclipped(FALSE),
   m_extrapage_count(0),
   m_more_note(FALSE),
   m_last_note_box(NULL),
   m_note_wrench(NULL),
   m_extra_notepage(NULL),
   m_bRTLUI(FALSE)
{}

//-------------------------------------------------------------------------
CDrawApp::~CDrawApp()
{

   if (m_pFaxMap)
      delete m_pFaxMap;

        if( m_note != NULL )
                delete m_note;

        if( m_note_wrench != NULL )
                delete m_note_wrench;

        if( m_extra_notepage != NULL )
                delete m_extra_notepage;
    //
    // Bug 39861 :  The app crashes AFTER the above code is executed!
    // (only if bogus paths are entered on command line, and mostly only in the UNICODE
    //  version!!)
    // Time to try quick and dirty workarounds!
}


//-------------------------------------------------------------------------
int CDrawApp::ExitInstance()
{
#ifndef _AFXCTL
        SaveStdProfileSettings();
#endif

   if (m_hSem)
      CloseHandle(m_hSem);

        //clean up code if we were rendering
        if ( m_dwSesID!=0 && m_pIawcpe )
                {
                TRACE(TEXT("AWCPE: Release() interface object \n"));
                m_pIawcpe->Release();

                m_pIawcpe=NULL;
                if( m_hMod )
                FreeLibrary( m_hMod );
                }

   TRACE(TEXT("AWCPE: Fax cover page editor exiting with error code: '%i'\n"),m_iErrorCode);

   return m_iErrorCode;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileOpen()
{
   //
   // If a document is open, query user for saving changes.
   //
   // This fixes part of the problem described in NT bug 53830.
   //
   CDrawDoc * pDoc = CDrawDoc::GetDoc();

#if 0

   // I really wish we could prompt for saving changes BEFORE we prompt for the file name.
   // But this MAY lead to double prompting.  If the user choses not to save on this prompt, then
   // there will be a second SAVE CHANGES prompt.

   if( pDoc && !pDoc->/*COleDocument::*/SaveModified()) return ; /// SaveModified now overridden!!
#endif

   CString newName;

   if (!DoPromptFileName(newName, AFX_IDS_OPENFILE,
     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, NULL))
        return;
   OpenDocumentFile(newName);
}


//-------------------------------------------------------------------------
CDocument* CDrawApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
#ifdef _DEBUG
   if (lpszFileName != NULL)
       TRACE1("AWCPE: opening document '%s'\n",lpszFileName);
   else
       TRACE(TEXT("AWCPE: opening new document\n"));
#endif

    BOOL OldFileVersion = TRUE ;
   _tcsupr((TCHAR *)lpszFileName);

   CString FileName = lpszFileName ;
   FileName.MakeUpper();
#if ENFORCE_FILE_EXTENSION_ON_OPEN_FILE
   CString Tail = FileName;
   if( Tail.Right(4) != FAX_COVER_PAGE_FILENAME_EXT && Tail.Right(4) != TEXT( ".CPE" )){
       FileName += FAX_COVER_PAGE_FILENAME_EXT;
   }
#endif

   if (*lpszFileName != 0) 
   {
      CFile file;
      if (!file.Open(FileName,CFile::modeRead)) 
      {
          if (m_dwSesID!=0) 
          {   
              //rendering // Not using this command line option! a-juliar
              TRACE1("AWCPE error:  unable to find file '%s'\n",(LPCTSTR)FileName);
              return NULL;
          }
          else 
          {
              CString sz;
              CString szFmt;
              sz.LoadString(IDS_MISSING_FILE);
              int iLength=sz.GetLength() + FileName.GetLength() + 2; //// ??????????????????
              wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
              szFmt.ReleaseBuffer();
              CPEMessageBox(MSG_ERROR_MISSINGFILE, szFmt, MB_OK | MB_ICONEXCLAMATION);
          }
          return NULL;
      }
      int i = sizeof(_gheaderVer1);
      BYTE* p = new BYTE[i];
      CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = TRUE ;
      file.Read(p,i);
      if (memcmp(_gheaderVer1,p,i)==0) {
              CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION1;
                  TRACE(TEXT("AWCPE info:  loading version 1 document\n"));
      }
      else if (memcmp(_gheaderVer2,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION2;
             TRACE(TEXT("AWCPE info:  loading version 2 document\n"));
      }
      else if (memcmp(_gheaderVer3,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION3;
             TRACE(TEXT("AWCPE info:  loading version 3 document\n"));
      }
      else if (memcmp(_gheaderVer4,p,i)==0) {
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION4;
             TRACE(TEXT("AWCPE info:  loading version 4 document\n"));
      }
      else if (memcmp(_gheaderVer5w,p,i)==0) 
      {
             CDrawDoc::GetDoc()->m_bDataFileUsesAnsi = FALSE ;
             CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
             TRACE(TEXT("AWCPE info:  loading version 5w document\n"));
             OldFileVersion = FALSE ;
      }
      else if (memcmp(_gheaderVer5a,p,i)==0){
          CDrawDoc::GetDoc()->m_iDocVer=CDrawDoc::VERSION5;
          TRACE(TEXT("AWCPE info:  loading version 5a document\n"));
      }
      else {
          CDrawDoc::GetDoc()->m_iDocVer=-1;
      }
      if (CDrawDoc::GetDoc()->m_iDocVer==-1) {
              if (m_dwSesID!=0) {
                  TRACE1(
                    "AWCPE error:  '%s' is not a valid version .COV file-cannot open\n",lpszFileName); // FILE EXTENSION
                    return NULL;
              }
              CString sz;
              CString szFmt;
              sz.LoadString(IDS_INVALID_FILE);
              int iLength=sz.GetLength()+ FileName.GetLength() + 2; //?????????????????????
              wsprintf(szFmt.GetBuffer(iLength), sz, (LPCTSTR)FileName);
              szFmt.ReleaseBuffer();
              CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
              return NULL;
      }
           if (p)
               delete [] p;
   }

   CDocument* pDoc =  CWinApp::OpenDocumentFile((LPCTSTR)FileName); // Calls Serialize()

   if( !pDoc ) return NULL ; /// This will help fix NT bug 53830 for the case when
                             /// CDrawApp::OpenDocumentFile is called by the FRAMEWORK,
                             /// byapssing CDrawApp::OnFileNew.  When the serialization
                             /// fails, pDoc is not NULL, and this is handled below.
                             /// This is not a perfect fix --- If the document being opened
                             /// came from the MRU list, it gets removed from the MRU list.

   if( pDoc && !( CDrawDoc::GetDoc()->m_bSerializeFailed )){
       CDrawDoc::GetDoc()->UpdateAllViews(NULL);
   }
   else {
       CString sz;
       CString szFmt;
       sz.LoadString(IDS_CORRUPT_FILE);
       int iLength=sz.GetLength() + FileName.GetLength() + 2;
       wsprintf(szFmt.GetBuffer(iLength), sz, lpszFileName);
       szFmt.ReleaseBuffer();
       CPEMessageBox(MSG_ERROR_INVFORMAT, szFmt, MB_OK | MB_ICONEXCLAMATION);
       OnFileNew();
       return NULL ;
   }
   if( pDoc && OldFileVersion ){
       pDoc->SetModifiedFlag(); /// Conversion to this file format is a change worth prompting to save.
   }
   return pDoc;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFileNew()
{
   CWinApp::OnFileNew();

   if (CDrawDoc::GetDoc()->m_wOrientation!=DMORIENT_PORTRAIT) {
       CDrawDoc::GetDoc()->m_wPaperSize = GetLocaleDefaultPaperSize();
       CDrawDoc::GetDoc()->m_wOrientation=DMORIENT_PORTRAIT;
       CDrawDoc::GetDoc()->m_wScale = 100;
       CDrawDoc::GetDoc()->ComputePageSize();
   }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::IsSecondInstance()
{
    m_hSem = CreateSemaphore(NULL,0,1,TEXT("AWCPE-Instance Semaphore"));
    if (m_hSem!=NULL && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(m_hSem);
        m_hSem=NULL;
        if (::SendMessage(HWND_TOPMOST,WM_AWCPEACTIVATE,0,0)==1L)
           return TRUE;  // 1st instance app responded;  close this instance
                else
           return FALSE; // 1st instance app didnt respond; may have crashed.  open this instance.
    }
    return FALSE;
}


void CDrawApp::filter_mru_list( void )
{
        int num_files;
        int i, j;
        TCHAR keystr[100];

        num_files = m_pRecentFileList->m_nSize;

        for( i=0; i<num_files; i++ ) {
                if( m_pRecentFileList->m_arrNames[i].IsEmpty() ) // i.e. == ""
                        break;

                if( GetFileAttributes( m_pRecentFileList->m_arrNames[i] ) == 0xffffffff ) {
                        for( j=i+1; j<num_files; j++ ) {
                                m_pRecentFileList->m_arrNames[j-1] =
                                        m_pRecentFileList->m_arrNames[j];
                        }

                        m_pRecentFileList->m_arrNames[j-1] = "";

                        i--; // back up so we start at first one that got schooted
                        }
                }

        if ( i < num_files ) {
                // have to clean up ini or they might come back next time
                for( ;i < num_files; i++ ) {
                        wsprintf( keystr, m_pRecentFileList->m_strEntryFormat, i+1 ); //???????????

                        // delete empty key
                        WriteProfileString( m_pRecentFileList->m_strSectionName,
                                                                keystr, NULL );
                        }

                // now have to write out modified list so that the right
                // keys are associated with the right names
                m_pRecentFileList->WriteList();
                }
}


//-------------------------------------------------------------------------
BOOL CDrawApp::InitInstance()
{
    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        m_bRTLUI = TRUE;
        if(!SetProcessDefaultLayout(LAYOUT_RTL))
        {
            TRACE1("AWCPE Error: SetProcessDefaultLayout failed: '%ld' \n", GetLastError());
        }
    }

    //
    // GetClientCpDir() creates Personal cover pages folder
    // if it is not exist
    // 
    TCHAR tszCovDir[MAX_PATH+1];
    GetClientCpDir(tszCovDir, ARR_SIZE(tszCovDir));


    SetErrorMode( SetErrorMode( 0 ) | SEM_NOALIGNMENTFAULTEXCEPT );

    ParseCmdLine();                     //1st thing done
    m_bUseDefaultDirectory = TRUE ;     // Used only the first time we open a file.
    SetRegistryKey( _T("Microsoft") );  //caused MFC to write app settings to registry

    AfxEnableWin40Compatibility();    //this app is intended for Windows 4.0 compatibility

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        CPEMessageBox(MSG_ERROR_OLEINIT_FAILED, NULL, MB_OK | MB_ICONSTOP,IDP_OLE_INIT_FAILED);
        return FALSE;
    }

    Enable3dControls();        // loads CTL3D32.DLL
    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    filter_mru_list();

    /*
        Register the application's document templates.  Document templates
        serve as the connection between documents, frame windows and views.

                CCpeDocTemplate is a derivation of CSingleDocTemplate used to
                override some default MFC behavior. See CCpeDocTemplate::MatchDocType
                below.
         */
    CCpeDocTemplate* pDocTemplate;
    pDocTemplate = new CCpeDocTemplate(
        IDR_AWCPETYPE,
        RUNTIME_CLASS(CDrawDoc),
        RUNTIME_CLASS(CMainFrame),
        RUNTIME_CLASS(CDrawView));
    pDocTemplate->SetContainerInfo(IDR_AWCPETYPE_CNTR_IP);
    AddDocTemplate(pDocTemplate);

    EnableShellOpen();
    RegistryEntries();

    if(m_bPrintHelpScreen){
        PrintHelpScreen();
        return FALSE;
    }
    InitFaxProperties();

    if (m_bCmdLinePrint) 
    {
       CmdLinePrint();
           return FALSE;
    }
    if (m_dwSesID!=0) 
    {
     ////  CmdLineRender();
           return FALSE;
    }
    CDocument * pDoc = NULL ;
    if (m_szFileName.IsEmpty())
       OnFileNew();
    else 
    {
       OnFileNew();   //m_pMainWnd needs to be initialized
       pDoc = OpenDocumentFile(m_szFileName);
    }
    if(!pDoc)
    {
        TCHAR tmpEnv[20];
        TCHAR DefaultDir[MAX_PATH];
        DWORD InstalledType = 0 ;
        HKEY hKey = NULL;
        DWORD dwKeyValueType ;
        DWORD dwsz = sizeof(DWORD)/sizeof(BYTE);
        DWORD dwSize = MAX_PATH;

        //
        // this gets set by fax control panel coverpage tab
        //
        if (GetEnvironmentVariable(TEXT("ClientCoverpage"),tmpEnv,sizeof(tmpEnv)/sizeof(TCHAR)) != 0 ) 
        {
            if(!GetClientCpDir(DefaultDir, sizeof(DefaultDir) / sizeof(DefaultDir[0])))
            {
                DefaultDir[0] = 0;
            }
        }   
        else 
        {
            
            //
            // Set default directory to
            //     server:      %SystemRoot%\system\spool\drivers\CoverPage
            //     workstation: %SystemRoot%\system32\spool\drivers\CoverPage
            //     client:      ...\My Documents\Fax\Peronal Coverpages
            //            
            if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                                REGKEY_FAX_SETUP,
                                                0,
                                                KEY_READ,
                                                &hKey)
                && ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                    REGVAL_FAXINSTALL_TYPE,
                                                    0,
                                                    &dwKeyValueType,
                                                    (LPBYTE)&InstalledType,
                                                    &dwsz)) 
            {
                //
                // set the default dir
                //
                
                if ((InstalledType & FAX_INSTALL_SERVER) || (InstalledType & FAX_INSTALL_WORKSTATION)) 
                {
                    ExpandEnvironmentStrings( DEFAULT_COVERPAGE_DIR , DefaultDir, MAX_PATH );
                } 
                else if (InstalledType & FAX_INSTALL_NETWORK_CLIENT) 
                {
                    if(!GetClientCpDir(DefaultDir, sizeof(DefaultDir) / sizeof(DefaultDir[0])))
                    {
                        DefaultDir[0] = 0;
                    }
                } 
                else 
                {
                    DefaultDir[0] = 0;
                }
            }        
        }

        //
        // this invokes a copy constructor that copies the data from the array
        //
        m_szDefaultDir = DefaultDir;            
                
        if (hKey) {
            RegCloseKey( hKey );
        }
        
    }

    OnIdle(0);  // updates buttons before showing the window

    if (m_pMainWnd) 
    {
       m_pMainWnd->DragAcceptFiles();
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(1,_T(""));
       ((CMainFrame*)m_pMainWnd)->m_wndStatusBar.SetPaneText(2,_T(""));
    }

    if (!m_pMainWnd->IsIconic()) 
    {
        CString sz = GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
        if ((sz==_T("YES")) && (!IsInConvertMode()))
        {
            //
            // supress the tool tips dialog in case the user ask to suppress it OR the 
            // application was launched to convert old cover pages CPE to COV.
            //
            CSplashTipsDlg m_SplashDlg (TRUE);
            m_SplashDlg.DoModal();
        }
    }

    InitRegistry();

    m_hMoveCursor = LoadCursor(IDC_MOVE);
    
    if (IsInConvertMode())
    {
        OnAppExit();
    }

    return TRUE;
}


//------------------------------------------------------------------------------------------------
void CDrawApp::RegistryEntries()
{
        CString PrintCmdLine;
        CString OpenCmdLine;
        CString DefaultIconCmdLine;
        CString szBuff;
    TCHAR szExe[_MAX_PATH];
    CString strFilterExt, strFileTypeId, strFileTypeName;

    RegisterShellFileTypes();

#if _MFC_VER >= 0x0400
//  ASSERT( !GetFirstDocTemplatePosition() );
#else
    ASSERT(!m_templateList.IsEmpty());  // must have some doc templates
#endif

    ::GetModuleFileName(AfxGetInstanceHandle(), szExe, _MAX_PATH);

        PrintCmdLine.
                Format( TEXT("%s%s"), szExe, szStdPrintArg );

        OpenCmdLine.
                Format( TEXT("%s%s"), szExe, szStdOpenArg  );

        DefaultIconCmdLine.
                Format( TEXT("%s%s"), szExe, szDocIconArg  );

#if _MFC_VER >= 0x0400
    POSITION pos = GetFirstDocTemplatePosition();
#else
    POSITION pos = m_templateList.GetHeadPosition();
#endif
    if (pos != NULL)    {       //only 1 document type
#if _MFC_VER >= 0x0400
           CDocTemplate* pTemplate =
                        (CDocTemplate*)GetNextDocTemplate( pos );
#else
           CDocTemplate* pTemplate =
                        (CDocTemplate*)m_templateList.GetNext(pos);
#endif
           if (pTemplate->GetDocString(strFileTypeId,
              CDocTemplate::regFileTypeId) && !strFileTypeId.IsEmpty()) {

                if (!pTemplate->GetDocString(strFileTypeName,
                      CDocTemplate::regFileTypeName))
                        strFileTypeName = strFileTypeId;    // use id name

                ASSERT(strFileTypeId.Find(' ') == -1);  // no spaces allowed

                szBuff.Format( szShellOpenFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)OpenCmdLine,
                                          OpenCmdLine.GetLength() );

                szBuff.Format( szShellPrintFmt, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)PrintCmdLine,
                                          PrintCmdLine.GetLength() );

                        szBuff.Format( szDocIcon, (LPCTSTR)strFileTypeId );
                ::RegSetValue(HKEY_CLASSES_ROOT,
                                          (LPCTSTR)szBuff,
                                          REG_SZ,
                                          (LPCTSTR)DefaultIconCmdLine,
                                          DefaultIconCmdLine.GetLength() );

            //delete the shell\open\ddeexec key to force second instance
                //Normally, this would be done by not calling EnableShellOpen(instead of removing the ddeexec key),
                //but there seems to be a bug in MFC or Win95 shell
                szBuff.Format( szShellDdeexecFmt, (LPCTSTR)strFileTypeId );
            ::RegDeleteKey(HKEY_CLASSES_ROOT, (LPCTSTR)szBuff);
           }
    }
}



//------------------------------------------------------------------------------------------------
void CDrawApp::InitRegistry()
{
        //set registry section
    HKEY hKey = NULL;
    DWORD dwsz;
    DWORD dwType;
    DWORD dwDisposition;
    const LPCTSTR szCmdLineExt=_T(" /SSESS_ID");
    HINSTANCE hInst = AfxGetInstanceHandle();

    TCHAR szExeName[_MAX_PATH + 10];

    if (!hInst)
    {
        //
        //  Failed to get Module instance
        //
        TRACE1("AWCPE Error: AfxGetInstanceHandle() failed: '%ld'.\n", GetLastError());
        return;
    }

    if ( 0 == ::GetModuleFileName(hInst, szExeName, _MAX_PATH))
    {
        //
        //  Failed to get Module File Name
        //
        TRACE1("AWCPE Error: GetModuleFileName() failed: '%ld'.\n", GetLastError());
        return;
    }

    _tcscat(szExeName,szCmdLineExt);

    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0, KEY_READ|KEY_WRITE, &hKey) == ERROR_SUCCESS) {
       if (::RegQueryValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, &dwType, NULL, &dwsz) == ERROR_SUCCESS) {
          if (dwsz==0) {
             if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, _tcsclen(szExeName)+1) != ERROR_SUCCESS){
                 TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
         }
          }
//        else {      //uncomment this for debugging
//           dwsz=_countof(sz);
//           if (::RegQueryValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, &dwType, (LPBYTE)sz, &dwsz) == ERROR_SUCCESS)
//              TRACE2("AWCPE Information: commandline key contains '%s' size %lu.\n", sz, dwsz);
//        }
       }
       else {
          if (::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ,(LPBYTE)szExeName, _tcsclen(szExeName)+1) != ERROR_SUCCESS) {
              TRACE1("AWCPE Warning: registration database update failed for key: '%s'.\n",CPE_COMMAND_LINE_KEY);
      }
       }
    }
    else 
    {
        DWORD dwRes;
        dwRes = ::RegCreateKeyEx(HKEY_CURRENT_USER, 
            CPE_SUPPORT_ROOT_KEY, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE, 
            KEY_READ | KEY_WRITE, 
            NULL, 
            &hKey, 
            &dwDisposition);

        if ( dwRes == ERROR_SUCCESS )
        {
            ::RegSetValueEx(hKey, CPE_COMMAND_LINE_KEY, 0, REG_SZ, (LPBYTE)szExeName, _tcsclen(szExeName)+1 ); ///????????????
            TRACE1("AWCPE Information: Created and added my key '%s' \n", szExeName);
        }
        else
        {
            TRACE1("AWCPE Error: RegCreateKeyEx failed: '%ld' \n", dwRes);
        }
    }
}


//-------------------------------------------------------------------
void CDrawApp::CmdLinePrint()
{
    try {
       if (!Print() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

        if (m_pMainWnd)
            m_pMainWnd->SendMessage(WM_CLOSE);
 }
//-------------------------------------------------------------------
void CDrawApp::PrintHelpScreen()
{
   CString message ;
   message.LoadString( IDS_HELP_SCREEN );
   AlignedAfxMessageBox( message );
}

//-------------------------------------------------------------------
///#if 0
void CDrawApp::CmdLineRender()
{
    try {
       if (! Render() )
          m_iErrorCode=EXIT_FAILURE;
    }
    catch(...) {
       TRACE(TEXT("AWCPE exception in command line print\n"));
       m_iErrorCode=EXIT_FAILURE;
        }

    if (m_pMainWnd)
           m_pMainWnd->SendMessage(WM_CLOSE);
 }
///#endif

//-------------------------------------------------------------------
BOOL CDrawApp::Print()
{
   m_nCmdShow = SW_MINIMIZE;
   OnFileNew();
   m_nCmdShow = SW_MINIMIZE;

   if (OpenDocumentFile(m_szFileName)==NULL) {
      TRACE1("AWCPE: unable to open file: '%s'\n",m_lpCmdLine);
      return FALSE;
   }

   ((CFrameWnd*)m_pMainWnd)->GetActiveView()->SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));
   return TRUE;
}



//-------------------------------------------------------------------
///#if 0
BOOL CDrawApp::Render()
{
    return FALSE ;

//
// Not sure what to do about the GetProcAddress call, so I have commented it out.
//
#if 0
    int i=1;
    TCHAR szTemp[_MAX_PATH];
    ULONG lLen=_MAX_PATH;
    LPTSTR szDLL=NULL;       //render DLL
    LPTSTR szfName=NULL;     //entry point name
    SCODE sc;
    DWORD lszDLL=_countof(szDLL);
    DWORD lszfName = _countof(szfName);
    LPVOID lpMsgBuf;
    DWORD dwType;
    BOOL bReturn=TRUE;
    HKEY hKey = NULL;
        UINT OldErrMode;
        CDocTemplate* pTemplate = NULL;
        CDrawDoc *pDoc;


    if (::RegOpenKeyEx(HKEY_CURRENT_USER, CPE_SUPPORT_ROOT_KEY, 0,KEY_READ, &hKey) != ERROR_SUCCESS) {
            TRACE1("AWCPE Critical: registration database openkey failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

//ALLOCATE SPACE FOR RENDER DLL AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, NULL, &lszDLL) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
        szDLL = new TCHAR[lszDLL+sizeof(TCHAR)];
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, NULL, &lszfName) != ERROR_SUCCESS) {
           TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
           return FALSE;
    }
    else
           szfName = new TCHAR[lszfName+sizeof(TCHAR)]; //????????????? was TCHAR.

//FETCH RENDER DLL NAME AND ENTRY POINT NAME
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_DLL_KEY, 0,&dwType, (LPBYTE)szDLL, &lszDLL) != ERROR_SUCCESS) {
            TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }
    if (::RegQueryValueEx(hKey, CPE_SUPPORT_FUNCTION_NAME_KEY, 0, &dwType, (LPBYTE)szfName, &lszfName) != ERROR_SUCCESS) { ///???????
        TRACE1("AWCPE.awcpe.render: RegQueryValue failed for key: '%s'.\n",CPE_SUPPORT_DLL_KEY);
            bReturn=FALSE;
                goto exit;
    }

    if (*szDLL==0 || *szfName==0) {
            TRACE(TEXT("AWCPE Warning: registration database fetch failed\n"));
            bReturn=FALSE;
                goto exit;
    }

//FETCH ENTRY POINT ADDRESS

    OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
    m_hMod = ::LoadLibrary(szDLL);
    if (m_hMod==NULL) {
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
          ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE3("AWCPE error: %s %s %s\n",lpMsgBuf, szDLL, szfName);
           bReturn=FALSE;
           goto exit;
    }
    ::SetErrorMode (OldErrMode);

    AWCPESUPPORTPROC pfn;
    if ( (pfn = (AWCPESUPPORTPROC) ::GetProcAddress(m_hMod, szfName))==NULL) {
            LPVOID lpMsgBuf;
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
           ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE1("AWCPE error: GetProcAddress returns %s\n",lpMsgBuf);
           bReturn=FALSE;
           goto exit;
    }

//FETCH WINDOWS OBJECT (USED TO FETCH FAX PROPERTIES)
    if ((sc=(*pfn)(m_dwSesID,&m_pIawcpe))!=S_OK) {
       LPVOID lpMsgBuf;
       ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
           ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
       TRACE1("AWCPE error: CPESupportEntry returns %8.8lx\n",sc);
           bReturn=FALSE;
           goto exit;
    }

        try
                {
                // set up innards for printing
                OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                         //   from showing

                if( (m_note_wrench = new CFaxProp( CRect( 0,0,0,0 ),
                                                                                   IDS_PROP_MS_NOTE ))
                        == NULL )
                        return( FALSE );

                // Read note so we can print it even if there are no note objects
                //      on cpe
                read_note();
                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


//LOOP THROUGH ALL RECIPIENTS
    do {

            sc = m_pIawcpe->GetProp(CPE_CONFIG_PRINT_DEVICE, &lLen, szTemp);
            if ( (sc != S_OK) || *szTemp==0) {
                   TRACE(TEXT("AWCPE.render() : GetProp for print device failed\n"));
                   bReturn=FALSE;
                   goto exit;
            }
            m_szRenderDevice=szTemp;

       sc = m_pIawcpe->GetProp(CPE_CONFIG_CPE_TEMPLATE, &lLen, szTemp);
       if ( (sc!=S_OK) || *szTemp==0) {
              TRACE(TEXT("AWCPE.render() : GetProp for template file failded\n"));
              bReturn=FALSE;
                  goto exit;
       }

       if ( !_tcschr(szTemp,(TCHAR)'\\') ) {      //prefix with extension if missing
              TCHAR szTemplate[_MAX_PATH];
              ::GetWindowsDirectory(szTemplate,MAX_PATH);
              _tcscat(szTemplate,TEXT("\\"));
              _tcscat(szTemplate,szTemp);
              _tcscpy(szTemp,szTemplate);
           }


       if( (pDoc = (CDrawDoc *)OpenDocumentFile(szTemp))==NULL) {
              bReturn=FALSE;
                  goto exit;
           }


           // move all "sent pages" prop obs to end of list so extra
           // pages calc can be done after all motes have printed.
           pDoc->schoot_faxprop_toend( IDS_PROP_MS_NOPG );

       TRACE1("AWCPE:  SendMessage to print recipient #%i\n",i);

        try
                {
        ((CFrameWnd*)m_pMainWnd)->GetActiveView()->
                SendMessage(WM_COMMAND,MAKEWPARAM(ID_FILE_PRINT,0));

           // close so next one will reopen again if same name
           OnFileNew(); // CMainFrame::ActivateFrame will prevent window
                                        //   from showing

                }
        catch( ... )
                {
                bReturn=FALSE;  // added 2/14/95 by v-randr
                goto exit;
                }


           i++;
    } while (m_pIawcpe->Finish(CPE_FINISH_PAGE)==CPE_NEXT_PAGE);


exit:
        if( !bReturn && (m_pIawcpe != NULL) )      // added 2/1/95 by v-randr
                m_pIawcpe->Finish( CPE_FINISH_ERROR ); // added 2/1/95 by v-randr

    if (szDLL)
       delete [] szDLL;
    if (szfName)
       delete [] szfName;

    return bReturn;
#endif
 }
///#endif




void CDrawApp::read_note( void )
        {
    SCODE sc;
    TCHAR note_filename[_MAX_PATH];
    ULONG lLen;
        CFile note_file;
        DWORD filelen, actuallen;

        if( (m_dwSesID == 0)||(m_pIawcpe == NULL) )
                return;

        if( m_note != NULL )
                {
                delete m_note;
                m_note = NULL;
                }

        m_note_wasread = FALSE;
        m_note_wasclipped = FALSE;

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, NULL );
        if( sc != S_OK )
        {
            /***CAN'T GET FILENAME LENGTH***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        if( lLen == 0 )
                return; // no note to read

        if( lLen > _MAX_PATH )
                {
                /***NAME TOO LONG***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }

        sc =
                m_pIawcpe->
                        GetProp( CPE_MESSAGE_BODY_FILENAME, &lLen, note_filename );
        if( sc != S_OK )
        {
            /***CAN'T GET FILENAME***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        // try to open the file
        if( !note_file.Open( (LPCTSTR)note_filename,
                                                  CFile::modeRead|CFile::shareDenyNone,
                                                  NULL ) )
        {
            /***CAN'T OPEN FILE***/
            /******NEED SOME KIND OF ERROR HERE*******/
            throw "read_note failed";
        }

        TRY
                filelen = note_file.GetLength();
        CATCH_ALL( e )
                {
                /***CAN'T GET FILE LENGTH***/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL


        m_note = new TCHAR[ filelen + sizeof (TCHAR) ];
        if( m_note == NULL )
                {
                /**CAN'T MAKE NOTE BUFFER**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw "read_note failed";
                }


        TRY
                actuallen = note_file.ReadHuge( m_note, filelen );

        CATCH_ALL( e )
                {
                /**CAN'T READ NOTE**/
                /******NEED SOME KIND OF ERROR HERE*******/
        throw;
                }
        END_CATCH_ALL

        *(m_note + actuallen) = _T('\0');
        reset_note();
        m_note_wasread = TRUE;


        note_file.Close();
        }




void CDrawApp::reset_note( void )
        {

        if( m_note != NULL )
                {
                m_note_wrench->SetText( CString( m_note ), NULL );
                m_more_note = TRUE;
                }
        else
                m_more_note = FALSE;

        }




int CDrawApp::clip_note( CDC *pdc,
                                                 LPTSTR *drawtext, LONG *numbytes,
                                                 BOOL   delete_usedtext,
                                                 LPRECT drawrect )
        /*
                Sets drawtext to the next page's worth of note text. Returns
                how many pages are left if delete_usedtext is TRUE. If FALSE,
                the page count includes the current page.
         */
        {
        TEXTMETRIC tm;
        LONG boxheight;
        LONG boxwidth;
        LONG numlines;
        int  total_lines;

        m_note_wasclipped = TRUE;
        *drawtext = NULL;
        *numbytes = 0;

        if( !more_note() )
                return( 0 );

        if( !pdc->GetTextMetrics( &tm ) )
                {
                m_more_note = FALSE;
                return( 0 );
                }

        boxheight = drawrect->bottom - drawrect->top;
        boxwidth = drawrect->right - drawrect->left;

        numlines = boxheight/tm.tmHeight;
        if( numlines <= 0 )
                return( 0 );

        m_note_wrench->m_pEdit->SetFont( pdc->GetCurrentFont(), FALSE );
        m_note_wrench->m_position = *drawrect;
        m_note_wrench->FitEditWnd( NULL, FALSE, pdc );

        total_lines = m_note_wrench->GetText( numlines, delete_usedtext );

        m_more_note = (total_lines > 0);

        *drawtext = m_note_wrench->GetRawText();
        *numbytes = lstrlen( *drawtext );

        // return number of pages left
        if( total_lines > 0 )
                return( (total_lines-1)/numlines + 1 );
        else
                return( 0 );

        }








TCHAR *CDrawApp::
        pos_to_strptr( TCHAR *src, long pos,
                                   TCHAR break_char,
                                   TCHAR **last_break, long *last_break_pos )
        /*
                Used for DBCS fiddling. Find str loc for char at pos.

                        pos == 0 -> 1st char,
                        pos == 1 -> 2st char,
                        etc.

                Returned ptr will point at char
                                                                           [pos]

                *last_break will point to last break_char found before
                char
                        [pos]

                If last_break is NULL it is ignored.

         */
        {
        TCHAR *last_break_ptr = NULL;
        long i;

        if( _tcsncmp(src,&break_char,1) == 0 )
                last_break_ptr = src;

        for( i=0; i<pos; i++ )
                {
                src = _tcsinc(src);
                if( _tcsncmp(src,TEXT("\0"),1) == 0 )
                        break;

                if( _tcsncmp(src,&break_char,1) == 0 )
                        {
                        last_break_ptr = src;
                        *last_break_pos = i;
                        }
                }

        if( last_break != NULL )
                *last_break = last_break_ptr;

        return( src );

        }




//-------------------------------------------------------------------
void CDrawApp::ParseCmdLine()
{
    BOOL bUseCommonCPDir = FALSE;   // Start in the common coverpages folder?
#ifdef _DEBUG
    if (m_lpCmdLine)
    {
       TRACE(TEXT("AWCPE:  command line: '%s'\n"),m_lpCmdLine);
    }
#endif

    m_bCmdLinePrint=FALSE;
    m_bConvertCpeToCov=FALSE;
    m_bPrintHelpScreen=FALSE;
    m_dwSesID=0;
    m_szDefaultDir=_T("");
    m_szFileName=_T("");

    TCHAR **argv ; /////////= __argv;    /////////????????????????????
    int iArgs ;    ///////////=__argc;   /////////????????????????????

#ifdef UNICODE
    argv = CommandLineToArgvW( GetCommandLine(), &iArgs );
#else
    argv = __argv;
    iArgs = __argc;
#endif

    if (m_lpCmdLine==NULL || *m_lpCmdLine==0 || !argv)
    {
        goto exit;
    }
    for (int i=1; i < iArgs; i++) 
    {
        _tcsupr(*(argv+i));
        if (_tcsstr(*(argv+i),TEXT("/P"))) 
        {
            m_bCmdLinePrint=TRUE;
            TRACE(TEXT("AWCPE:  command line printing mode set\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/?"))) 
        {
            //// TODO: Display help screen and quit.
            m_bPrintHelpScreen = TRUE ;
            TRACE(TEXT("AWCPE: help screen mode set\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/COMMON"))) 
        {
            bUseCommonCPDir = TRUE ;
            TRACE(TEXT("AWCPE: Common coverpages folder is requested\n"));
        }
        else if (_tcsstr(*(argv+i),TEXT("/W"))) 
        {
            TCHAR szDir[_MAX_PATH];
            ::GetWindowsDirectory(szDir,MAX_PATH);
            m_szDefaultDir=szDir;
            TRACE1("AWCPE:  default directory set to '%s'\n",m_szDefaultDir);
        }
        else if (_tcsstr(*(argv+i),TEXT("/CONVERT"))) 
        {
            //
            // Launch the cover page editor just to convert the cover page from CPE (w9x format, Version 4)
            // to COV latest version (Version 5)
            //
            m_bConvertCpeToCov = TRUE;
        }
        else 
        {
            m_szFileName = *(argv+i);
        }
    }
    if (m_szFileName.GetLength() > 0) 
    {
        TCHAR szDrive[_MAX_DRIVE];
        TCHAR szDir[_MAX_DIR];
        TCHAR szFName[_MAX_FNAME];
        TCHAR szExt[_MAX_EXT];
        _tsplitpath(m_szFileName,szDrive,szDir,szFName,szExt);
        if (_tcsclen(szDir)>0 && m_szDefaultDir.GetLength()<= 0)
        m_szDefaultDir=szDir;    ////// Wrong!!!!!!! a-juliar, 8-27-96
        m_szDefaultDir = szDrive ;
        m_szDefaultDir += szDir ;
    }

exit:
#ifdef UNICODE
    LocalFree( argv );
#endif

    TCHAR tszStartDir[MAX_PATH * 2];
    BOOL  bGotStartDir;

    if (bUseCommonCPDir)
    {
        bGotStartDir = GetServerCpDir (NULL, tszStartDir, ARR_SIZE(tszStartDir));
    }
    else
    {
        bGotStartDir = GetClientCpDir (tszStartDir, ARR_SIZE(tszStartDir));
    }
    if (bGotStartDir)
    {
        SetCurrentDirectory(tszStartDir);
    }
        

}


//-------------------------------------------------------------------------
//Add properties to dictionary
//  (1) CProp, param 1:  string table index of description
//  (2) CProp, param 2:  length of property, in characters
//  (3) CProp, param 3:  width of property, in lines
//  (4) CProp, param 4:  index to property value (obtained via transport(awcpesup.h))
//-------------------------------------------------------------------------
#if 0
void CDrawApp::InitFaxProperties()  // The default numbers here work fine in English.
{
   static CProp recipient_name(IDS_PROP_RP_NAME,35,1,IDS_CAPT_RP_NAME,CPE_RECIPIENT_NAME);
   static CProp recipient_fxno(IDS_PROP_RP_FXNO,35,1,IDS_CAPT_RP_FXNO,CPE_RECIPIENT_FAX_PHONE);
   static CProp recipient_comp(IDS_PROP_RP_COMP,35,1,IDS_CAPT_RP_COMP,CPE_RECIPIENT_COMPANY);
   static CProp recipient_addr(IDS_PROP_RP_ADDR,35,1,IDS_CAPT_RP_ADDR,CPE_RECIPIENT_STREET_ADDRESS);
   static CProp recipient_pobx(IDS_PROP_RP_POBX,20,1,IDS_CAPT_RP_POBX,CPE_RECIPIENT_POST_OFFICE_BOX);
   static CProp recipient_city(IDS_PROP_RP_CITY,30,1,IDS_CAPT_RP_CITY,CPE_RECIPIENT_LOCALITY);
   static CProp recipient_stat(IDS_PROP_RP_STAT,25,1,IDS_CAPT_RP_STAT,CPE_RECIPIENT_STATE_OR_PROVINCE);
   static CProp recipient_zipc(IDS_PROP_RP_ZIPC,25,1,IDS_CAPT_RP_ZIPC,CPE_RECIPIENT_POSTAL_CODE);
   static CProp recipient_ctry(IDS_PROP_RP_CTRY,25,1,IDS_CAPT_RP_CTRY,CPE_RECIPIENT_COUNTRY);
   static CProp recipient_titl(IDS_PROP_RP_TITL,20,1,IDS_CAPT_RP_TITL,CPE_RECIPIENT_TITLE);
   static CProp recipient_dept(IDS_PROP_RP_DEPT,35,1,IDS_CAPT_RP_DEPT,CPE_RECIPIENT_DEPARTMENT);
   static CProp recipient_offi(IDS_PROP_RP_OFFI,35,1,IDS_CAPT_RP_OFFI,CPE_RECIPIENT_OFFICE_LOCATION);
   static CProp recipient_htel(IDS_PROP_RP_HTEL,40,1,IDS_CAPT_RP_HTEL,CPE_RECIPIENT_HOME_PHONE);
   static CProp recipient_otel(IDS_PROP_RP_OTEL,40,1,IDS_CAPT_RP_OTEL,CPE_RECIPIENT_WORK_PHONE);
   static CProp recipient_tols(IDS_PROP_RP_TOLS,50,3,IDS_CAPT_RP_TOLS,CPE_RECIPIENT_TO_LIST);
   static CProp recipient_ccls(IDS_PROP_RP_CCLS,50,3,IDS_CAPT_RP_CCLS,CPE_RECIPIENT_CC_LIST);
   static CProp message_subj(IDS_PROP_MS_SUBJ,50,2,IDS_CAPT_MS_SUBJ,CPE_MESSAGE_SUBJECT);
   static CProp message_tsnt(IDS_PROP_MS_TSNT,35,1,IDS_CAPT_MS_TSNT,CPE_MESSAGE_SUBMISSION_TIME);
   static CProp message_nopg(IDS_PROP_MS_NOPG,15,1,IDS_CAPT_MS_NOPG,CPE_COUNT_PAGES);
   static CProp message_noat(IDS_PROP_MS_NOAT,23,1,IDS_CAPT_MS_NOAT,CPE_COUNT_ATTACHMENTS);
   static CProp message_bcod(IDS_PROP_MS_BCOD,30,1,IDS_CAPT_MS_BCOD,CPE_MESSAGE_BILLING_CODE);
   static CProp message_text(IDS_PROP_MS_TEXT,40,8,IDS_CAPT_MS_TEXT,CPE_MESSAGE_BILLING_CODE); //CPE constant needs updating
   static CProp message_note(IDS_PROP_MS_NOTE,90,12,IDS_CAPT_MS_NOTE,CPE_MESSAGE_NOTE);
   static CProp sender_name(IDS_PROP_SN_NAME,35,1,IDS_CAPT_SN_NAME,CPE_SENDER_NAME);
   static CProp sender_fxno(IDS_PROP_SN_FXNO,35,1,IDS_CAPT_SN_FXNO,CPE_SENDER_FAX_PHONE);
   static CProp sender_comp(IDS_PROP_SN_COMP,25,1,IDS_CAPT_SN_COMP,CPE_SENDER_COMPANY);
   static CProp sender_addr(IDS_PROP_SN_ADDR,35,6,IDS_CAPT_SN_ADDR,CPE_SENDER_ADDRESS);
   static CProp sender_titl(IDS_PROP_SN_TITL,20,1,IDS_CAPT_SN_TITL,CPE_SENDER_TITLE);
   static CProp sender_dept(IDS_PROP_SN_DEPT,35,1,IDS_CAPT_SN_DEPT,CPE_SENDER_DEPARTMENT);
   static CProp sender_offi(IDS_PROP_SN_OFFI,35,1,IDS_CAPT_SN_OFFI,CPE_SENDER_OFFICE_LOCATION);
   static CProp sender_htel(IDS_PROP_SN_HTEL,35,1,IDS_CAPT_SN_HTEL,CPE_SENDER_HOME_PHONE);
   static CProp sender_otel(IDS_PROP_SN_OTEL,35,1,IDS_CAPT_SN_OTEL,CPE_SENDER_WORK_PHONE);
   m_pFaxMap=new CFaxPropMap;
}
#else
void CDrawApp::InitFaxProperties()  // Make some numbers too small for test purposes.
{
   static CProp recipient_name(IDS_PROP_RP_NAME,15,1,IDS_CAPT_RP_NAME,CPE_RECIPIENT_NAME);
   static CProp recipient_fxno(IDS_PROP_RP_FXNO,15,1,IDS_CAPT_RP_FXNO,CPE_RECIPIENT_FAX_PHONE);
   static CProp recipient_comp(IDS_PROP_RP_COMP,5,1,IDS_CAPT_RP_COMP,CPE_RECIPIENT_COMPANY);
   static CProp recipient_addr(IDS_PROP_RP_ADDR,35,1,IDS_CAPT_RP_ADDR,CPE_RECIPIENT_STREET_ADDRESS);
   static CProp recipient_pobx(IDS_PROP_RP_POBX,20,1,IDS_CAPT_RP_POBX,CPE_RECIPIENT_POST_OFFICE_BOX);
   static CProp recipient_city(IDS_PROP_RP_CITY,5,1,IDS_CAPT_RP_CITY,CPE_RECIPIENT_LOCALITY);
   static CProp recipient_stat(IDS_PROP_RP_STAT,5,1,IDS_CAPT_RP_STAT,CPE_RECIPIENT_STATE_OR_PROVINCE);
   static CProp recipient_zipc(IDS_PROP_RP_ZIPC,5,1,IDS_CAPT_RP_ZIPC,CPE_RECIPIENT_POSTAL_CODE);
   static CProp recipient_ctry(IDS_PROP_RP_CTRY,5,1,IDS_CAPT_RP_CTRY,CPE_RECIPIENT_COUNTRY);
   static CProp recipient_titl(IDS_PROP_RP_TITL,20,1,IDS_CAPT_RP_TITL,CPE_RECIPIENT_TITLE);
   static CProp recipient_dept(IDS_PROP_RP_DEPT,5,1,IDS_CAPT_RP_DEPT,CPE_RECIPIENT_DEPARTMENT);
   static CProp recipient_offi(IDS_PROP_RP_OFFI,5,1,IDS_CAPT_RP_OFFI,CPE_RECIPIENT_OFFICE_LOCATION);
   static CProp recipient_htel(IDS_PROP_RP_HTEL,4,1,IDS_CAPT_RP_HTEL,CPE_RECIPIENT_HOME_PHONE);
   static CProp recipient_otel(IDS_PROP_RP_OTEL,4,1,IDS_CAPT_RP_OTEL,CPE_RECIPIENT_WORK_PHONE);
   static CProp recipient_tols(IDS_PROP_RP_TOLS,50,3,IDS_CAPT_RP_TOLS,CPE_RECIPIENT_TO_LIST);
   static CProp recipient_ccls(IDS_PROP_RP_CCLS,50,3,IDS_CAPT_RP_CCLS,CPE_RECIPIENT_CC_LIST);
   static CProp message_subj(IDS_PROP_MS_SUBJ,50,2,IDS_CAPT_MS_SUBJ,CPE_MESSAGE_SUBJECT);
   static CProp message_tsnt(IDS_PROP_MS_TSNT,35,1,IDS_CAPT_MS_TSNT,CPE_MESSAGE_SUBMISSION_TIME);
   static CProp message_nopg(IDS_PROP_MS_NOPG,5,1,IDS_CAPT_MS_NOPG,CPE_COUNT_PAGES);
   static CProp message_noat(IDS_PROP_MS_NOAT,23,1,IDS_CAPT_MS_NOAT,CPE_COUNT_ATTACHMENTS);
   static CProp message_bcod(IDS_PROP_MS_BCOD,30,1,IDS_CAPT_MS_BCOD,CPE_MESSAGE_BILLING_CODE);
   static CProp message_text(IDS_PROP_MS_TEXT,40,8,IDS_CAPT_MS_TEXT,CPE_MESSAGE_BILLING_CODE); //CPE constant needs updating
   static CProp message_note(IDS_PROP_MS_NOTE,90,12,IDS_CAPT_MS_NOTE,CPE_MESSAGE_NOTE);
   static CProp sender_name(IDS_PROP_SN_NAME,5,1,IDS_CAPT_SN_NAME,CPE_SENDER_NAME);
   static CProp sender_fxno(IDS_PROP_SN_FXNO,5,1,IDS_CAPT_SN_FXNO,CPE_SENDER_FAX_PHONE);
   static CProp sender_comp(IDS_PROP_SN_COMP,5,1,IDS_CAPT_SN_COMP,CPE_SENDER_COMPANY);
   static CProp sender_addr(IDS_PROP_SN_ADDR,35,6,IDS_CAPT_SN_ADDR,CPE_SENDER_ADDRESS);
   static CProp sender_titl(IDS_PROP_SN_TITL,5,1,IDS_CAPT_SN_TITL,CPE_SENDER_TITLE);
   static CProp sender_dept(IDS_PROP_SN_DEPT,5,1,IDS_CAPT_SN_DEPT,CPE_SENDER_DEPARTMENT);
   static CProp sender_offi(IDS_PROP_SN_OFFI,5,1,IDS_CAPT_SN_OFFI,CPE_SENDER_OFFICE_LOCATION);
   static CProp sender_htel(IDS_PROP_SN_HTEL,5,1,IDS_CAPT_SN_HTEL,CPE_SENDER_HOME_PHONE);
   static CProp sender_otel(IDS_PROP_SN_OTEL,5,1,IDS_CAPT_SN_OTEL,CPE_SENDER_WORK_PHONE);
   m_pFaxMap=new CFaxPropMap;
}
#endif


//-------------------------------------------------------------------------
BOOL CDrawApp::DoFilePageSetup(CMyPageSetupDialog& dlg)
{
   UpdatePrinterSelection(FALSE);

     dlg.m_psd.hDevMode = m_hDevMode;
     dlg.m_psd.hDevNames = m_hDevNames;

   if (dlg.DoModal() != IDOK)
      return FALSE;

   m_hDevMode=dlg.m_psd.hDevMode;
   m_hDevNames=dlg.m_psd.hDevNames;

   return TRUE;
}


//-------------------------------------------------------------------------
void CDrawApp::OnFilePageSetup()
{
   WORD old_orientation;
   WORD old_papersize;
   WORD old_scale;
   CDrawDoc *pdoc = CDrawDoc::GetDoc();

   CMyPageSetupDialog dlg;
   if (dlg.m_pPageSetupDlg) 
   {
      if (!DoFilePageSetup(dlg))
      {
         return;
      }
   }
   else
   {
      CWinApp::OnFilePrintSetup();                //call printsetup if no existing page setup
   }

   // save old ones so we can do a dirty check
   old_orientation = pdoc->m_wOrientation;
   old_papersize   = pdoc->m_wPaperSize;
   old_scale       = pdoc->m_wScale;

   // get (possibly) new values
   LPDEVMODE  lpDevMode = (m_hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(m_hDevMode) : NULL;
   if (lpDevMode)
   {
       pdoc->m_wOrientation =lpDevMode->dmOrientation;
       pdoc->m_wPaperSize   =lpDevMode->dmPaperSize;
/** DISABLE SCALEING - SEE 2868's BUG LOG **/
       if( FALSE )//lpDevMode->dmFields & DM_SCALE  )
       {
               // change scale only if printer supports it
           pdoc->m_wScale = lpDevMode->dmScale;
       }
       // dirty check
       if( (pdoc->m_wOrientation != old_orientation)||
           (pdoc->m_wPaperSize   != old_papersize)  ||
           (pdoc->m_wScale       != old_scale)
         )
       {
          pdoc->SetModifiedFlag();
       }
   }
   if (m_hDevMode != NULL)
   {
     ::GlobalUnlock(m_hDevMode);
   }
   pdoc->ComputePageSize();
}

//-------------------------------------------------------------------------
void CDrawApp::OnAppAbout()
{
        ::ShellAbout( AfxGetMainWnd()->m_hWnd, AfxGetAppName(),  TEXT(""), LoadIcon( IDR_AWCPETYPE ) );
}



//--------------------------------------------------------------------------------
static void AppendFilterSuffix(CString& filter, OPENFILENAME &ofn,
        CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
        ASSERT_VALID(pTemplate);
        ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

        CString strFilterExt, strFilterName;
        if (pTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt) &&
         !strFilterExt.IsEmpty() &&
         pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
         !strFilterName.IsEmpty())
        {
                // a file based document template - add to filter list
#ifndef _MAC
                ASSERT(strFilterExt[0] == '.');
#endif
                if (pstrDefaultExt != NULL)
                {
                        // set the default extension
#ifndef _MAC
                        *pstrDefaultExt = ((LPCTSTR)strFilterExt) + 1;  // skip the '.'
#else
                        *pstrDefaultExt = strFilterExt;
#endif
                        ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
                }

                // add to filter
                filter += strFilterName;
                ASSERT(!filter.IsEmpty());  // must have a file type name
                filter += (TCHAR)'\0';  // next string please
#ifndef _MAC
                filter += (TCHAR)'*';
#endif
                filter += strFilterExt;
                filter += (TCHAR)'\0';  // next string please
        }
}

//--------------------------------------------------------------------------------
BOOL CDrawApp::DoPromptFileName(
    CString& fileName,
    UINT nIDSTitle,
    DWORD lFlags,
    BOOL bOpenFileDialog,
    CDocTemplate* pTemplate,
    LPOFNHOOKPROC lpOFNHook /*= NULL*/
)
{
    OPENFILENAME ofn = {0};

    ofn.lStructSize = sizeof(ofn); // sizeof(OPENFILENAME_NT4);

    ofn.Flags = OFN_HIDEREADONLY       | 
                OFN_OVERWRITEPROMPT    |
                OFN_ENABLESIZING       |
                OFN_EXPLORER           |
                lFlags;
    ofn.hInstance = AfxGetResourceHandle();
    if (lpOFNHook)
    {
        ofn.Flags |= OFN_ENABLEHOOK;
        ofn.lpfnHook = lpOFNHook;
    }

    TCHAR tszCovDir[MAX_PATH+1];
    if(GetCurrentDirectory(MAX_PATH, tszCovDir))
    {
        ofn.lpstrInitialDir = tszCovDir;
    }
    else
    {
        TRACE(TEXT("GetCurrentDirectory failed"));

        if (m_szDefaultDir.GetLength()>0 && m_bUseDefaultDirectory)
        {   // Added to set initial directory
            ofn.lpstrInitialDir = m_szDefaultDir;
        }
    }

    //
    // Make sure all object are NOT selected.
    //
    CDrawView* pView = CDrawView::GetView();
    if (pView)
    {
        pView->Select(NULL, FALSE, TRUE);
    }

    CString strFilter;
    CString strDefault;

    if (pTemplate != NULL) 
    {
        ASSERT_VALID(pTemplate);
        AppendFilterSuffix(strFilter, ofn, pTemplate, &strDefault);
    }
    else  
    {
        // Do for all doc template
        POSITION pos = GetFirstDocTemplatePosition();
        while (pos != NULL)  
        {
            AppendFilterSuffix(
                strFilter,
                ofn,
                (CDocTemplate*)GetNextDocTemplate( pos ),
                NULL
                );
        }
    }

    if (bOpenFileDialog)
    {
        //
        // This is an open file dialog
        //

        //
        // Append the "*.cpe" filter -- Windows 95 Cover Page Files -- 9-20-96 a-juliar
        //
        CString Win95filter ;
        VERIFY( Win95filter.LoadString( IDS_OLD_FILE_FILTER ));
        strFilter += Win95filter ;
        strFilter += (TCHAR)'\0';   // next string please
        strFilter += _T("*.cpe");
        strFilter += (TCHAR)'\0';   // next string please
    }

    CString allFilter;
    VERIFY(allFilter.LoadString(AFX_IDS_ALLFILTER));

    strFilter += allFilter;
    strFilter += (TCHAR)'\0';    // next string please

    strFilter += _T("*.*");


    strFilter += (TCHAR)'\0';    // last string
    ofn.lpstrFilter = strFilter;

    ofn.lpstrDefExt = FAX_COVER_PAGE_EXT_LETTERS; // Fix bug 57706

    CString title;
    VERIFY(title.LoadString(nIDSTitle));
    ofn.lpstrTitle = title;

    TCHAR tszFileName[MAX_PATH+1] = {0};
    _tcscpy (tszFileName, fileName);
    ofn.lpstrFile = tszFileName;
    ofn.nMaxFile = (sizeof (tszFileName) / sizeof (tszFileName[0])) - 1;

    CWnd *pMainWnd = AfxGetMainWnd();
    ofn.hwndOwner = pMainWnd ? pMainWnd->m_hWnd : NULL;

    BOOL bRes;
    if (bOpenFileDialog)
    {
        bRes = ::GetOpenFileName(&ofn);
    }
    else
    {
        bRes = ::GetSaveFileName(&ofn);
    }

    m_bUseDefaultDirectory = FALSE ; //// After first time, use the CURRENT DIRECTORY instead.
    if (bRes)
    {
        fileName = tszFileName;
    }
    return bRes;
}   // CDrawApp::DoPromptFileName


//--------------------------------------------------------------------------------
WORD
CDrawApp::GetLocaleDefaultPaperSize(
    void
    ) const

/*++

Routine Description:

    Retrieves the current locale defualt paper size.

Arguments:

    NONE

Return Value:

    One of the following values:  1 = letter, 5 = legal, 9 = a4

--*/

{

// 
// LOCALE_IPAPERSIZE is defined in Winnls.h only if (WINVER >= 0x0500).
// At this point we do not want to split the binaries of NT4 and W2K, so we define LOCALE_IPAPERSIZE localy.
//
#define LOCALE_IPAPERSIZE             0x0000100A   // 1 = letter, 5 = legal, 8 = a3, 9 = a4


    TCHAR   tszMeasure[2] = TEXT("9"); // 2 is maximum size for the LOCALE_IPAPERSIZE
                                      // value as defined is MSDN.

    if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IPAPERSIZE, tszMeasure,2))
    {
        if (!_tcscmp(tszMeasure,TEXT("9")))
        {
            // A4
            return DMPAPER_A4;
        }

        if (!_tcscmp(tszMeasure,TEXT("5")))
        {
            // legal
            return DMPAPER_LEGAL;
        }
    }

    //
    // Defualt value is Letter.
    //
    return DMPAPER_LETTER;
}
//-------------------------------------------------------------------------




//Map for CS help system
DWORD cshelp_map[] =
{
    IDC_CB_DRAWBORDER,  IDC_CB_DRAWBORDER,
        IDC_LB_THICKNESS,       IDC_LB_THICKNESS,
        IDC_LB_LINECOLOR,       IDC_LB_LINECOLOR,
        IDC_RB_FILLTRANS,       IDC_RB_FILLTRANS,
        IDC_RB_FILLCOLOR,       IDC_RB_FILLCOLOR,
        IDC_LB_FILLCOLOR,       IDC_LB_FILLCOLOR,
        IDC_LB_TEXTCOLOR,       IDC_LB_TEXTCOLOR,
        IDC_GRP_FILLCOLOR,  IDC_COMM_GROUPBOX,
        IDC_ST_TEXTCOLOR,   IDC_COMM_STATIC,
        IDC_ST_THICKNESS,   IDC_COMM_STATIC,
        IDC_ST_COLOR,       IDC_COMM_STATIC,
    0,0
};




//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawApp, CWinApp)
   //{{AFX_MSG_MAP(CDrawApp)
   ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
   //}}AFX_MSG_MAP
   // Standard file based document commands
   ON_COMMAND(ID_FILE_NEW, OnFileNew)
   ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
   ON_COMMAND(ID_FILE_SAVE, CDrawDoc::OnFileSave)
   ON_COMMAND(ID_FILE_SAVE_AS, CDrawDoc::OnFileSaveAs)
   // Standard print setup command
   ON_COMMAND(ID_FILE_PAGE_SETUP, OnFilePageSetup)
   ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
/// Experimental entries --- a-juliar, 7-18-96
   ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpIndex )
//   ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing )
   ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex )
   ON_COMMAND(ID_HELP, CWinApp::OnHelp )
END_MESSAGE_MAP()






/*
        This override of MatchDocType forces MFC to reload a file that is
        already loaded and that has been modified. MFC will put up the
        standard "save changes?" dialog before reloading the file.

        This defeats MFC's default behavior of just doing nothing if you
        try to FileOpen a file that is already opened.

        This was done to fix bug 2628.
 */
#ifndef _MAC
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType( LPCTSTR lpszPathName,
                                  CDocument*& rpDocMatch )
#else
CDocTemplate::Confidence CCpeDocTemplate::
        MatchDocType(LPCTSTR lpszFileName, DWORD dwFileType,
                                 CDocument*& rpDocMatch)
#endif
        {
        CDocTemplate::Confidence congame;

        congame =
#ifndef _MAC
                CSingleDocTemplate::MatchDocType( lpszPathName, rpDocMatch );
#else
                CSingleDocTemplate::MatchDocType( lpszFileName, dwFileType,
                                                                                  rpDocMatch );
#endif


        if( congame == CDocTemplate::yesAlreadyOpen )
                {
                if( rpDocMatch->IsModified() )
                        {
                        // force a reload after "save changes?" dialog
                        congame = CDocTemplate::yesAttemptNative;
                        rpDocMatch = NULL;
                        }
                }

        return( congame );

        }/* CCpeDocTemplate::MatchDocType */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\renderer\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=faxrend
!ifndef NOUNICODE
TARGETPATH=$(FAXLIB)
!else
TARGETPATH=$(FAXLIB)\win95
!endif
TARGETTYPE=LIBRARY

UMTYPE=windows
USE_CRTDLL=1

INCLUDES=\
	..\;	\
    $(INCLUDES); \
    ..\..\inc;      \
    ..\..\src;

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
	..\..\util\unicode\$O\fautil.lib
!else
LINKLIBS_INT=\
	..\..\util\ansi\$O\fautil.lib

!endif

LINKLIBS=\
    $(LINKLIBS)\
    $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib \
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib

SOURCES=\
    ..\prtcovpg.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\renderer\prtcovpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prtcovpg.c

Abstract

    Three componants of the composite page description file:
      1)  A header describing the other two componants.
      2)  An embebbed meta file of the page description objects.
      3)  Text strings (or resource ID's of string data
          requiring substitution of user data passed in to the
          function).

    Routine parses componants of composite page description file as
    created by the Windows XP "FaxCover" application; renders the
    objects to the DC, if hdc is not NULL.

Author:

    Julia J. Robinson

Revision History:

    Julia J. Robinson 6-7-96
    Julia J. Robinson 9-20-96       Allow passing paper size and orientation.
    Sasha    Bessonov 10-28-99      Fixed initialization of view port for non printer devices

Environment:

    Windows XP


--*/

#include <windows.h>
#include <commdlg.h>
#include <winspool.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "faxutil.h"

#include "prtcovpg.h"
#include "resource.h"


#define INITIAL_SIZE_OF_STRING_BUFFER 64
#define NOTE_INDEX  22        // Index of "{Note}"  in the InsertionTitle array.

BYTE  UNICODE_Signature[20]= {0x46,0x41,0x58,0x43,0x4F,0x56,0x45,0x52,0x2D,0x56,0x45,0x52,0x30,0x30,0x35,0x77,0x87,0x00,0x00,0x00};


//
// Resource ID's corresponding to fields of USERDATA.
//

WORD InsertionTagResourceID[]=
{
    IDS_PROP_RP_NAME,                           // "{Recipient Name}"
    IDS_PROP_RP_FXNO,                           // "{Recipient Fax Number}"
    IDS_PROP_RP_COMP,                           // "{Recipient's Company}"
    IDS_PROP_RP_ADDR,                           // "{Recipient's Street Address}"
    IDS_PROP_RP_CITY,                           // "{Recipient's City}"
    IDS_PROP_RP_STAT,                           // "{Recipient's State}"
    IDS_PROP_RP_ZIPC,                           // "{Recipient's Zip Code}"
    IDS_PROP_RP_CTRY,                           // "{Recipient's Country}"
    IDS_PROP_RP_TITL,                           // "{Recipient's Title}"
    IDS_PROP_RP_DEPT,                           // "{Recipient's Department}"
    IDS_PROP_RP_OFFI,                           // "{Recipient's Office Location}"
    IDS_PROP_RP_HTEL,                           // "{Recipient's Home Telephone #}"
    IDS_PROP_RP_OTEL,                           // "{Recipient's Office Telephone #}"
    IDS_PROP_SN_NAME,                           // "{Sender Name}"
    IDS_PROP_SN_FXNO,                           // "{Sender Fax #}"
    IDS_PROP_SN_COMP,                           // "{Sender's Company}"
    IDS_PROP_SN_ADDR,                           // "{Sender's Address}"
    IDS_PROP_SN_TITL,                           // "{Sender's Title}"
    IDS_PROP_SN_DEPT,                           // "{Sender's Department}"
    IDS_PROP_SN_OFFI,                           // "{Sender's Office Location}"
    IDS_PROP_SN_HTEL,                           // "{Sender's Home Telephone #}"
    IDS_PROP_SN_OTEL,                           // "{Sender's Office Telephone #}"
    IDS_PROP_MS_NOTE,                           // "{Note}"
    IDS_PROP_MS_SUBJ,                           // "{Subject}"
    IDS_PROP_MS_TSNT,                           // "{Time Sent}"
    IDS_PROP_MS_NOPG,                           // "{# of Pages}"
    IDS_PROP_RP_TOLS,                           // "{To: List}"
    IDS_PROP_RP_CCLS                            // "{Cc: List}"
};

LPTSTR
ConvertStringToTString(LPCWSTR lpcwstrSource)
/*++
Routine Description:

	Converts string to T format
Arguments:
	
	lpcwstrSource - source

Return Value:

	Copied string or NULL

Comment:
	The function returns NULL if lpcwstrSource == NULL or conversion failed

--*/
{
	LPTSTR lptstrDestination;

	if (!lpcwstrSource)
		return NULL;

#ifdef	UNICODE
    lptstrDestination = StringDup( lpcwstrSource );
#else	// !UNICODE
	lptstrDestination = UnicodeStringToAnsiString( lpcwstrSource );
#endif	// UNICODE
	
	return lptstrDestination;
}

DWORD
CopyWLogFontToTLogFont(
			IN const LOGFONTW * plfSourceW,
			OUT      LOGFONT  * plfDest)
{
/*++
Routine Description:

    This fuction copies a LogFont structure from UNICODE format
	to T format.

Arguments:
	
	  plfSourceW - reference to input UNICODE LongFont structure
	  plfDest - reference to output LongFont structure

Return Value:

	WINAPI last error

--*/
#ifndef UNICODE
	int iCount;
#endif

    plfDest->lfHeight = plfSourceW->lfHeight ;
    plfDest->lfWidth = plfSourceW->lfWidth ;
    plfDest->lfEscapement = plfSourceW->lfEscapement ;
    plfDest->lfOrientation = plfSourceW->lfOrientation ;
    plfDest->lfWeight = plfSourceW->lfWeight ;
    plfDest->lfItalic = plfSourceW->lfItalic ;
    plfDest->lfUnderline = plfSourceW->lfUnderline ;
    plfDest->lfStrikeOut = plfSourceW->lfStrikeOut ;
    plfDest->lfCharSet = plfSourceW->lfCharSet ;
    plfDest->lfOutPrecision = plfSourceW->lfOutPrecision ;
    plfDest->lfClipPrecision = plfSourceW->lfClipPrecision ;
    plfDest->lfQuality = plfSourceW->lfQuality ;
    plfDest->lfPitchAndFamily = plfSourceW->lfPitchAndFamily ;

	SetLastError(0);
#ifdef UNICODE
	wcscpy( plfDest->lfFaceName,plfSourceW->lfFaceName);
#else
    iCount = WideCharToMultiByte(
				CP_ACP,
				0,
				plfSourceW->lfFaceName,
				-1,
				plfDest->lfFaceName,
				LF_FACESIZE,
				NULL,
				NULL
				);

	if (!iCount)
	{
		return GetLastError();
	}
#endif
	return ERROR_SUCCESS;
}


DWORD WINAPI
PrintCoverPage(
    HDC              hDC,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo
    )
/*++

    Renders the coverpage into a printer DC using the size of a printer page.
    Also returns information on the cover page. See param documentation.

    Arguments:

        hDC                   - Device context.  If NULL, we just read the file and set *pFlags


        pUserData              - pointer to a structure containing user data
                                  for text insertions.  May be NULL.

        lpctstrTemplateFileName     - Name of the file created by the page editor,
                                      containing the META file.

        pCovDocInfo           - pointer to structure contining information about the cover page file.
                                This includes

                                    pCovDocInfo->NoteRect

                                        - Coordinates of the "Note" insertion rectangle, returned
                                          in device coordinates.  This will be all 0 if hDC is NULL


                                    pCovDocInfo->Flags

                                        - Returns bitwise OR of the following (or more):

                                             COVFP_NOTE      if .cov file contains a Note field.

                                             COVFP_SUBJECT   if .cov file contains a Subject field.

                                             COVFP_NUMPAGES  if .cov file contains Num Pages field.

                                    pCovDocInfo->PaperSize

                                        - may use in DEVMODE as dmPaperSize

                                    pCovDocInfo->Orientation

                                        - may use in DEVMODE as dmOrientation

                                    pCovDocInfo->NoteFont

                                        - Logfont structure to be used in rendering the NOTE.
                                          This will be meaningless if hDC is NULL.
--*/
{
    
    
    RECT   ClientRect;

    DEBUG_FUNCTION_NAME(TEXT("PrintCoverPage"));

    Assert(lpctstrTemplateFileName);
    Assert(pUserData);
    
    

    memset(&ClientRect,0,sizeof(ClientRect));
    if (hDC)
    {

        DWORD                FullPrinterWidth;         // PHYSICALWIDTH
        DWORD                FullPrinterHeight;        // PHYSICALHEIGHT
        DWORD                PrinterUnitsX;            // PHYSICALWIDTH - (width of margins)
        DWORD                PrinterUnitsY;            // PHYSICALHEIGHT - (height of margins)

        FullPrinterWidth  = GetDeviceCaps( hDC, PHYSICALWIDTH );
        PrinterUnitsX     = FullPrinterWidth - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETX );
        FullPrinterHeight = GetDeviceCaps( hDC, PHYSICALHEIGHT );
        PrinterUnitsY     = FullPrinterHeight - 2 * GetDeviceCaps( hDC, PHYSICALOFFSETY );
       

        ClientRect.top    = GetDeviceCaps( hDC, PHYSICALOFFSETY );
        ClientRect.left   = GetDeviceCaps( hDC, PHYSICALOFFSETX );
        ClientRect.right  = ClientRect.left + FullPrinterWidth -1;
        ClientRect.bottom = ClientRect.top  + PrinterUnitsY - 1;    
    }
    
    return RenderCoverPage(
                hDC,
                &ClientRect,
                pUserData,
                lpctstrTemplateFileName,
                pCovDocInfo,
                FALSE
            );
}


DWORD WINAPI
RenderCoverPage(
    HDC              hDC,
	LPCRECT			 lpcRect,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo,
    BOOL             bPreview
    )

/*++

   Renders a coverpage into a rectangle in the provided dc. Also returns information on the
   cover page. See param documentation.

    Arguments:

        hDC                   - Device context.  If NULL, we just read the file and set *pFlags

        lpcRect                - pointer to a RECT that specifies the rectangle into which the 
                                 cover page template will be rendered.

        pUserData              - pointer to a structure containing user data
                                  for text insertions.  May be NULL.

        lpctstrTemplateFileName     - Name of the file created by the page editor,
                                      containing the META file.

        pCovDocInfo           - pointer to structure contining information about the cover page file.
                                This includes

                                    pCovDocInfo->NoteRect

                                        - Coordinates of the "Note" insertion rectangle, returned
                                          in device coordinates.  This will be all 0 if hDC is NULL


                                    pCovDocInfo->Flags

                                        - Returns bitwise OR of the following (or more):

                                             COVFP_NOTE      if .cov file contains a Note field.

                                             COVFP_SUBJECT   if .cov file contains a Subject field.

                                             COVFP_NUMPAGES  if .cov file contains Num Pages field.

                                    pCovDocInfo->PaperSize

                                        - may use in DEVMODE as dmPaperSize

                                    pCovDocInfo->Orientation

                                        - may use in DEVMODE as dmOrientation

                                    pCovDocInfo->NoteFont

                                        - Logfont structure to be used in rendering the NOTE.
                                          This will be meaningless if hDC is NULL.

        pPreview        - boolean flag that is TRUE if the function should render the text for
                            cover page preview in the wizard and is FALSE for all other cases
                            of normal full-size rendering.
--*/

{
    ENHMETAHEADER        MetaFileHeader;
    UINT                 HeaderSize;
    LPBYTE               pMetaFileBuffer = NULL;
    const BYTE           *pConstMetaFileBuffer;
    DWORD                rVal = ERROR_SUCCESS;
    INT                  TextBoxNbr;
    COLORREF             PreviousColor;
    HFONT                hThisFont = NULL;
    HGDIOBJ              hPreviousFont;
    DWORD                NbrBytesRead;
    RECT                 TextRect;
    RECT                 NoteRect;
    TEXTBOX              TextBox;                  // buffer for reading in a TEXTBOX
    HENHMETAFILE         MetaFileHandle = NULL;
    HANDLE               CompositeFileHandle = INVALID_HANDLE_VALUE;
    COMPOSITEFILEHEADER  CompositeFileHeader;

    INT                  HeightDrawn;              // return value of DrawText()
    INT                  ReadBufferSize;           // size of buffer for reading in strings.
    INT                  ThisBufSize;              // size buffer needed for current text string.
    LPWSTR               pStringReadIn = NULL;     // buffer for reading in strings.
    LPTSTR               pWhichTextToRender = NULL;// pStringReadIn v. ArrayOfData[i]
    LPTSTR               lptstrStringReadIn = NULL;// LPTSTR of pStringReadIn 
    LPTSTR               lptstrArrayOfData  = NULL;// ArrayOfData[i]
    INT                  i;                        // loop index
    LPTSTR *             ArrayOfData;              // uses pointers in UserData as ragged array.
    int                  CallersDCState = 0;       // returned by SaveDC
    int                  MyDCState = 0;            // returned by SaveDC
    DWORD                ThisBit;                  // Flag field for current index.
    DWORD                Flags;                    // Return these if pFlags != NULL.
    WORD                 MoreWords[3];             // Scale, PaperSize, and Orientation
    LOGFONT              NoteFont;                 // Logfont structure found in the NOTE box
    LOGFONT              FontDef;                  // Logfont structure 
    
    HRGN                 hRgn = NULL;

	SIZE orgExt;
	POINT orgOrigin;
	SIZE orgPortExt;

    DWORD dwReadingOrder = 0;

    DEBUG_FUNCTION_NAME(TEXT("RenderCoverPage"));
    __try {

        //
        // Initialize return values, handles, and pointers.
        //
        NoteRect.left = 0;
        NoteRect.right = 0;
        NoteRect.top = 0;
        NoteRect.bottom = 0;
        Flags = 0;
        hThisFont = NULL;
        CompositeFileHandle = INVALID_HANDLE_VALUE;
        MyDCState = 0;
        CallersDCState = 0;

        //
        // Initialize a Pointer so that
        //
        //       ArrayOfData[0] ===== pUserData->RecName ,
        //       ArrayOfData[1] ===== pUserData->RecFaxNumber ,
        //                   ... etc. ...

        if (pUserData){
            ArrayOfData = &pUserData->RecName;
        }

        ZeroMemory( &CompositeFileHeader, sizeof(COMPOSITEFILEHEADER) );
        ZeroMemory( &TextBox, sizeof(TEXTBOX) );

        //
        // Open the composite data file.
        //

        CompositeFileHandle = CreateFile(
            lpctstrTemplateFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (CompositeFileHandle == INVALID_HANDLE_VALUE) {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to open COV template file [%s] (ec: %ld)"),
                    lpctstrTemplateFileName,
                    rVal
                    );
            rVal = GetLastError();
            goto exit;
        }

        if(!ReadFile(CompositeFileHandle, 
                    &CompositeFileHeader, 
                    sizeof(CompositeFileHeader), 
                    &NbrBytesRead, 
                    NULL))
        {
            rVal = GetLastError();
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to read composite file header (ec: %ld)"),
                    rVal
                    );
            goto exit;
        }
            
        //
        // Check the 20-byte signature in the header to see if the file
        //     contains ANSI or UNICODE strings.
        //
        if ((sizeof(CompositeFileHeader) != NbrBytesRead) ||
            memcmp( UNICODE_Signature, CompositeFileHeader.Signature, 20 ))
        {
            rVal = ERROR_BAD_FORMAT;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CompositeFile signature mismatch (ec: %ld)"),
                    rVal
                    );
            goto exit;
        }

        //
        // Extract the embedded META file from the composite file and move
        // into meta file buffer
        //

        pMetaFileBuffer = (LPBYTE) malloc( CompositeFileHeader.EmfSize );
        if (!pMetaFileBuffer){
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocated metafile buffer (ec: %ld)"),
                    rVal
                    );
            goto exit;
        }

        if ((!ReadFile( 
                CompositeFileHandle, 
                pMetaFileBuffer, 
                CompositeFileHeader.EmfSize, 
                &NbrBytesRead, 
                NULL ) ||
                CompositeFileHeader.EmfSize != NbrBytesRead))
        {
            rVal = GetLastError();
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to read metafile (ec: %ld)"),
                    rVal
                    );
            goto exit;
        }

        if (hDC) {           // Rendering

            int CRComplexity;

            hRgn = CreateRectRgnIndirect( lpcRect);
            if (!hRgn)
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateRectRgnIndirect() failed (ec: %ld)"),
                    rVal
                    );
                goto exit;
            }
            CRComplexity = SelectClipRgn( hDC, hRgn );
            if (ERROR == CRComplexity)
            {
                rVal = ERROR_GEN_FAILURE;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SelectClipRgn() failed (reported region complexity: %ld)"),
                    CRComplexity
                    );
                goto exit;
            }
        
            //
            // Save Device Context state
            //

            CallersDCState = SaveDC( hDC );
            if (CallersDCState == 0) {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SaveDC() failed (ec: %ld)"),
                    rVal
                    );
                goto exit;
            }

         

            
            //
            // Set device context appropriately for rendering both text and metafile.
            //
            if (!CompositeFileHeader.EmfSize){
                //
                // No objects to render.
                //
                rVal = ERROR_NO_MORE_FILES;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("No objects to render in EMF file")
                    );
                goto exit;
            }

            pConstMetaFileBuffer = pMetaFileBuffer;

            //
            // Create an enhanced metafile, in memory, from the data in the buffer.
            //

            MetaFileHandle = SetEnhMetaFileBits(
                CompositeFileHeader.EmfSize,
                pConstMetaFileBuffer
                );
            if (!MetaFileHandle) {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetEnhMetaFileBits() failed (ec: %ld)"),
                    rVal);
                goto exit;
            }

            //
            // verify the metafile header.
            //

            HeaderSize = GetEnhMetaFileHeader(
                MetaFileHandle,
                sizeof(ENHMETAHEADER),
                &MetaFileHeader
                );
            if (!HeaderSize){
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetEnhMetaFileHeader() failed (ec: %ld)"),
                    rVal);
                goto exit;
            }

            //
            // Render the MetaFile
            //

            if (!PlayEnhMetaFile( hDC, MetaFileHandle, lpcRect )) {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PlayEnhMetaFile() failed (ec: %ld)"),
                    rVal);
                goto exit;
            }

            //
            // Set Device Context for rendering text.
            // Undo any changes that occurred when rendering the metafile.
            //

            RestoreDC( hDC, MyDCState );
            MyDCState = 0;

            if (CLR_INVALID == SetBkMode( hDC, TRANSPARENT)){
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetBkMode() failed (ec: %ld)"),
                    rVal);
                goto exit;
            }

        


		    //
		    // Set a mapping mode that will allow us to output the text boxes
		    // in the same scale as the metafile.
		    //
    	    if (!SetMapMode(hDC,MM_ANISOTROPIC))
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetMapMode() failed (ec: %ld)"),
                    rVal);
                goto exit;
            }
		    // 
		    // Set the logical coordinates to the total size (positve + negative) of the x and y axis
		    // which is the same as the size of the cover page.
		    //
		    if (!SetWindowExtEx(
                hDC,
                CompositeFileHeader.CoverPageSize.cx,
                -CompositeFileHeader.CoverPageSize.cy,
                &orgExt
                ))
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetWindowExtEx() failed (ec: %ld)"),
                    rVal);
                goto exit;
            };
		    //
		    // We map the logical space to a device space which is the size of the rectangle into 
            // which we played the meta file.
		    // 
		    if (!SetViewportExtEx(
                hDC,lpcRect->right - lpcRect->left,
                lpcRect->bottom - lpcRect->top,&orgPortExt
                ))
            
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetViewportExtEx() failed (ec: %ld)"),
                    rVal);
                goto exit;
            };
            
		    //
		    // We map logical point (0,0) to the middle of the device space.
		    //
		    if (!SetWindowOrgEx(
                hDC,
                -CompositeFileHeader.CoverPageSize.cx/2,
                CompositeFileHeader.CoverPageSize.cy/2,
                &orgOrigin))
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SetWindowOrgEx() failed (ec: %ld)"),
                    rVal);
                goto exit;
            };
            

		
        }
		//
        //  Initialize buffer for reading in strings.
        //

        ReadBufferSize = INITIAL_SIZE_OF_STRING_BUFFER;

        pStringReadIn = (LPWSTR) malloc( ReadBufferSize );
        if (!pStringReadIn) {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to allocate initial strings buffer (ec: %ld)"),
                    rVal);
            goto exit;
        }

        //
        // Read in Text Box objects from the composite file and print out the text.
        //

        for (TextBoxNbr=0; TextBoxNbr < (INT) CompositeFileHeader.NbrOfTextRecords; ++TextBoxNbr)
        {
            if ((!ReadFile( CompositeFileHandle, &TextBox, sizeof(TEXTBOX), &NbrBytesRead, NULL)) ||
                NbrBytesRead != sizeof(TEXTBOX))
            {
                rVal = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to read text box number %ld (ec: %ld)"),
                    TextBoxNbr,
                    rVal);
                goto exit;
            }

            //
            // Check buffer size, lock buffer, and
            // read in variable length string of text.
            //

            ThisBufSize = sizeof(WCHAR) * (TextBox.NumStringBytes + 1);
            if (ReadBufferSize < ThisBufSize) {
                pStringReadIn = realloc( pStringReadIn, ThisBufSize );
                if (!pStringReadIn) {
                    rVal = ERROR_NOT_ENOUGH_MEMORY;
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to realloc text box number %ld buffer. Requested size was %ld (ec: %ld)"),
                        TextBoxNbr,
                        ThisBufSize,
                        rVal);

                    goto exit;
                }
            }

            if ((!ReadFile( CompositeFileHandle, (void*)pStringReadIn, TextBox.NumStringBytes, &NbrBytesRead, NULL)) ||
                NbrBytesRead != TextBox.NumStringBytes)
            {
                rVal = GetLastError();
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to read text box number %ld content (ec: %ld)"),
                        TextBoxNbr,
                        rVal);
                goto exit;
            }

            pStringReadIn[TextBox.NumStringBytes / sizeof(WCHAR)] = 0;

			if (lptstrStringReadIn) {
				MemFree(lptstrStringReadIn);
				lptstrStringReadIn = NULL;
			}

            if (pStringReadIn && (!(lptstrStringReadIn = ConvertStringToTString(pStringReadIn))))
			{
				rVal = ERROR_NOT_ENOUGH_MEMORY;
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Failed to covert string to TString (ec: %ld)"),
                        rVal);
				goto exit;
			}

            if (hDC) 
            {
                //
                // Correct position of text box.
                //

                TextRect.top    = max( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
                TextRect.left   = min( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );
                TextRect.bottom = min( TextBox.PositionOfTextBox.top,  TextBox.PositionOfTextBox.bottom );
                TextRect.right  = max( TextBox.PositionOfTextBox.left, TextBox.PositionOfTextBox.right  );

            }

            if (TextBox.ResourceID) 
            {
                //
                // Text box contains a FAX PROPERTY field.
                // Find appropriate field of USERDATA for this resource ID.
                //

                for (i=0,ThisBit=1; i<NUM_INSERTION_TAGS; ++i,ThisBit<<=1) 
                {
                    if (TextBox.ResourceID == InsertionTagResourceID[i])
                    {
                        lptstrArrayOfData = pUserData ? ArrayOfData[i] : NULL;

                        //
                        // Set Flags bit to indicate this FAX PROPERTY field is present.
                        //
                        Flags |= ThisBit;
                        break;
                    }
                }

                if (TextBox.ResourceID == IDS_PROP_MS_NOTE && hDC) 
                {
                    //
                    // NOTE field found.  Return its rectangle in device coordinates.
                    // Return its LOGFONT with height adjusted for device coordinates.
                    //

                    NoteRect = TextRect;
                    LPtoDP( hDC, (POINT*)&NoteRect, 2 );
					if ((rVal = CopyWLogFontToTLogFont(&TextBox.FontDefinition,&NoteFont)) != ERROR_SUCCESS) 
					{
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CopyWLogFontToTLogFont() failed (ec: %ld)"),
                            rVal);
						goto exit;
					}
                    NoteFont.lfHeight = (LONG)MulDiv(
                        (int)NoteFont.lfHeight,
                        GetDeviceCaps( hDC, LOGPIXELSY ),
                        100
                        );
                }
            }

			pWhichTextToRender = (lptstrStringReadIn[0] != (TCHAR)'\0') ? lptstrStringReadIn : lptstrArrayOfData;

            if (hDC && pWhichTextToRender) 
            {
                //
                // Set text color and font for rendering text.
                //

                PreviousColor = SetTextColor( hDC, TextBox.TextColor );
                if (PreviousColor == CLR_INVALID){
                    rVal = GetLastError();

                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("SetTextColor() failed (ec: %ld)"),
                            rVal);

                    goto exit;
                }

				if ((rVal = CopyWLogFontToTLogFont(&TextBox.FontDefinition,&FontDef)) != ERROR_SUCCESS) 
				{
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CopyWLogFontToTLogFont() failed (ec: %ld)"),
                            rVal);
					goto exit;
				}

                if (bPreview)
                {
                    //
                    //  For CoverPage Preview, we want to get only TT font
                    //  That is able to draw a small letters.
                    //

                    //
                    //  Add OUT_TT_ONLY_PRECIS to force the TTF
                    //
                    FontDef.lfOutPrecision |= OUT_TT_ONLY_PRECIS;
                }

                hThisFont = CreateFontIndirect( &FontDef );
                if (!hThisFont) {
                    rVal = GetLastError();
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateFontIndirect() failed (ec: %ld)"),
                            rVal);
                    goto exit;
                }

                hPreviousFont = SelectObject( hDC, hThisFont );
                if (!hPreviousFont) {
                    rVal = GetLastError();

                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("SelectObject() failed (ec: %ld)"),
                            rVal);
                    goto exit;
                }

                if (bPreview)
                {
                    //
                    //  Now check that created font is real TTF
                    //

                    TEXTMETRIC          TextMetric;
                    HGDIOBJ             hPrevFont = NULL;

                    if (!GetTextMetrics(hDC, &TextMetric))
                    {
                        rVal = GetLastError();
                        DebugPrintEx(DEBUG_ERR, _T("GetTextMetrics() failed (ec: %ld)"), rVal);
                        goto exit;
                    }

                    if ( ! ( (TextMetric.tmPitchAndFamily & TMPF_TRUETYPE) > 0))
                    {
                        //
                        //  This is not TT font
                        //  In this case, the selected font cannot correct represent
                        //      the small letters in the CoverPage preview.
                        //  So, we hard-coded put the font to be Tahoma, which is TTF
                        //
                        _tcscpy(FontDef.lfFaceName, _T("Tahoma"));

                        //
                        //  Create new font
                        //
                        hThisFont = CreateFontIndirect( &FontDef );
                        if (!hThisFont) 
                        {
                            rVal = GetLastError();
                            DebugPrintEx(DEBUG_ERR, _T("CreateFontIndirect(2) failed (ec: %ld)"), rVal);
                            goto exit;
                        }

                        hPrevFont = SelectObject( hDC, hThisFont );
                        if (!hPrevFont) 
                        {
                            rVal = GetLastError();
                            DebugPrintEx(DEBUG_ERR, _T("SelectObject(2) failed (ec: %ld)"), rVal);
                            goto exit;
                        }

                        //
                        //  Delete previous font - the one that was created wrong
                        //
                        DeleteObject(hPrevFont);

                    }
                }

                dwReadingOrder = 0;
                if (TextBox.ResourceID && StrHasRTLChar(LOCALE_SYSTEM_DEFAULT, pWhichTextToRender))
                {
                    dwReadingOrder = DT_RTLREADING;
                }

                //
                // Render the text.
                //				
                HeightDrawn = DrawText(hDC,
                                       pWhichTextToRender,
                                       -1,
                                       &TextRect,
                                       DT_NOPREFIX | DT_WORDBREAK | TextBox.TextAlignment | dwReadingOrder);
                if (!HeightDrawn) 
                {
                    rVal = GetLastError();
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("DrawText() failed for textbox #%ld with content [%s] (ec: %ld)"),
                            TextBoxNbr,
                            pWhichTextToRender,
                            rVal);

                    goto exit;
                }


                //
                //  Restore previous font and release the handle to the selected font
                //

                SelectObject( hDC, (HFONT)hPreviousFont );
                SetTextColor( hDC, PreviousColor );
                DeleteObject( hThisFont );
                hThisFont = NULL;
            }

        }                                           // Ends loop over all textboxes.

        //
        // Read on to get Orientation and PaperSize
        //


        if ((!ReadFile( CompositeFileHandle, MoreWords, 3*sizeof(WORD), &NbrBytesRead, NULL )) ||
            NbrBytesRead != 3 * sizeof(WORD))
        {
            rVal = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to read Orientation and PaperSize (ec: %ld)"),
                rVal);
            goto exit;
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        rVal = GetExceptionCode();

        DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Exception occured. (ec: %ld)"),
                    rVal);
    }


exit:

    if (MetaFileHandle)
    {
        DeleteEnhMetaFile( MetaFileHandle );
    }

	if (lptstrStringReadIn) 
    {
		MemFree(lptstrStringReadIn);
	}

    if (hThisFont) 
    {
        DeleteObject( hThisFont );
    }

    if (pStringReadIn) {
        free( pStringReadIn );
    }

    if (pMetaFileBuffer) 
    {
        free( pMetaFileBuffer );
    }

    if (CompositeFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( CompositeFileHandle );
    }

    if( MyDCState )
    {
        RestoreDC( hDC, MyDCState );
    }

    if( CallersDCState )
    {
        RestoreDC( hDC, CallersDCState );
    }

    if (rVal == 0 && pCovDocInfo != NULL) 
    {
        pCovDocInfo->Flags = Flags;
        pCovDocInfo->NoteRect = NoteRect;
        pCovDocInfo->PaperSize = (short) MoreWords[1];
        pCovDocInfo->Orientation = (short) MoreWords[2];
        pCovDocInfo->NoteFont = NoteFont;
    }

    if (hRgn)
    {
        DeleteObject(hRgn);
    }

    return rVal;
}


DWORD
PrintCoverPageToFile(
    LPTSTR lptstrCoverPage,
    LPTSTR lptstrTargetFile,
    LPTSTR lptstrPrinterName,
    short sCPOrientation,
	short sCPYResolution,
    PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Ronen Barenboim 25-March-2000

Routine Description:

    Renders a cover page template into a TIFF file by printing it into file using the specified printer.

Arguments:

    [IN] lptstrCoverPage - Full path to the cover page template file.
    [IN] lptstrTargetFile - Full path to the file in which the TIFF will be stores.
                       The function will create this file.

    [IN] lptstrPrinterName - The name of the printer to which the cover page will be printed
                        in order to generate the TIFF file.

    [IN] sCPOrientation - The cover page orientation.

	[IN] sCPYResolution - coverpage Y resolution. 0 for the printer default

    [IN] pCPFields        - Points to a cover page information structure. Its fields will be used to
                       replace the cov template fields.

Return Value:

    ERROR_SUCCESS on success. A Win32 error code on failure.

--*/

{
    COVDOCINFO  covDocInfo;
    DOCINFO DocInfo;
    HDC hDC = NULL;
    INT JobId = 0;
    BOOL bRet = FALSE;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL bEndPage = FALSE;
    LONG lSize;
    HANDLE hPrinter = NULL;
    PDEVMODE pDevMode = NULL;
    DEBUG_FUNCTION_NAME(TEXT("PrintCoverPageToFile"));


    Assert(lptstrPrinterName);
    Assert(lptstrTargetFile);
    Assert(pCPFields);
    Assert(lptstrCoverPage);
    Assert (sCPOrientation == DMORIENT_LANDSCAPE || sCPOrientation == DMORIENT_PORTRAIT);
	Assert (sCPYResolution == 0 || sCPYResolution == 98 || sCPYResolution == 196);

    //
    // open the printer for normal access (this should always work)
    //
    if (!OpenPrinter( lptstrPrinterName, &hPrinter, NULL ))
    {
        dwRet = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("OpenPrinter failed. Printer Name = %s , ec = %ld"),
			lptstrPrinterName,
			dwRet);  
		goto exit;
    }

    //
    // Get the default devmode
    //
    lSize = DocumentProperties( NULL, hPrinter, NULL, NULL, NULL, 0 );
    if (lSize <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("DocumentProperties failed. ec = %ld"),
			dwRet);
        goto exit;
    }

    //
    // allocate memory for the DEVMODE
    //
    pDevMode = (PDEVMODE) MemAlloc( lSize );
    if (!pDevMode)
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("Cant allocate DEVMODE."));
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // get the default document properties
    //
    if (DocumentProperties( NULL, hPrinter, NULL, pDevMode, NULL, DM_OUT_BUFFER ) != IDOK)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("DocumentProperties failed. ec = %ld"),
			dwRet);
        goto exit;
    }
    
    //
    // Set the correct orientation
    //
	pDevMode->dmOrientation = sCPOrientation;

	//
    // Set the correct reolution
    //
    if (0 != sCPYResolution)
    {
        //
        // Set the coverpage resolution to the same value as the body tiff file
        //
        pDevMode->dmYResolution = sCPYResolution;
    }


    //
    // Create the device context
    //
    hDC = CreateDC( NULL, lptstrPrinterName, NULL, pDevMode);
    if (!hDC)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("CreateDC on printer %s failed (ec: %ld)"),
			lptstrPrinterName,
			dwRet);
        goto exit;
    }

    //
    // Set the document information
    //
    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = TEXT("");
    DocInfo.lpszOutput = lptstrTargetFile;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    //
    // Start the print job
    //
    JobId = StartDoc( hDC, &DocInfo );
    if (JobId <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("StartDoc failed (ec: %ld)"),
			dwRet);
        goto exit;
    }

    if (StartPage(hDC) <= 0)
    {
        dwRet = GetLastError();
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("StartPage failed (ec: %ld)"),
			dwRet);
        goto exit;
    }
    bEndPage = TRUE;

    //
    // Do the actual rendering work.
    //
    dwRet = PrintCoverPage(
        hDC,
        pCPFields,
        lptstrCoverPage,
        &covDocInfo);

    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(
			DEBUG_ERR,
			TEXT("PringCoverPage failed (ec: %ld). COV file: %s Target file: %s"),
			dwRet,
			lptstrCoverPage,
			lptstrTargetFile);
    }

exit:
    if (JobId)
    {
        if (TRUE == bEndPage)
        {
            if (EndPage(hDC) <= 0)
            {
                dwRet = GetLastError();
                DebugPrintEx(
					DEBUG_ERR,
					TEXT("EndPage failed - %d"),
					dwRet);
            }
        }

        if (EndDoc(hDC) <= 0)
        {
            dwRet = GetLastError();
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("EndDoc failed - %d"),
				dwRet);
        }
    }

    if (hDC)
    {
        BOOL bRet;

        bRet = DeleteDC( hDC );
        if (!bRet)
        {
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("DeleteDc failed - %d"),
				GetLastError());
        }

        Assert(bRet);
    }

    if (hPrinter)
    {
        if (!ClosePrinter (hPrinter))
        {
            DebugPrintEx(
				DEBUG_ERR,
				TEXT("ClosePrinter failed - %d"),
				GetLastError());
        }
    }

    MemFree (pDevMode);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpeedt.h ===
//--------------------------------------------------------------------------
// cpeedt.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEEDT_H__
#define __CPEEDT_H__

class CDrawObj;
class CDrawView;
class CDrawText;


class CTextEdit : public CEdit
{

public:
    CTextEdit();
    CTextEdit(CDrawObj*);

protected:
    CDrawObj* m_pDrawObj;
    DECLARE_SERIAL(CTextEdit);
    CDrawText* m_pTextBoxForUndo ;

#ifdef _DEBUG
    void AssertValid();
#endif
    virtual void Serialize(CArchive& ar);

    //{{AFX_MSG(CTextEdit)
    //}}AFX_MSG
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnChar(UINT, UINT, UINT);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);

    DECLARE_MESSAGE_MAP()
};



#endif   //#ifndef __CPEEDT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cntritem.cpp ===
//============================================================================
// cntritem.h : interface of the CDrawItem class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      OLE draw item for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//============================================================================

#include "stdafx.h"
#include "awcpe.h"
#include "cpedoc.h"
#include "cpeobj.h"
#include "cpevw.h"
#include "cntritem.h"
#include "dialogs.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDrawItem implementation

IMPLEMENT_SERIAL(CDrawItem, COleClientItem, 0)

CDrawItem::CDrawItem(CDrawDoc* pContainer, CDrawOleObj* pDrawObj)
	: COleClientItem(pContainer)
{
	m_pDrawObj = pDrawObj;
}


CDrawItem::~CDrawItem()
{
	// TODO: add cleanup code here
}

void CDrawItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	switch(nCode)
	{
	case OLE_CHANGED_STATE:
	case OLE_CHANGED_ASPECT:
		m_pDrawObj->Invalidate();
		break;
	case OLE_CHANGED:
		UpdateExtent(); // extent may have changed
		m_pDrawObj->Invalidate();
		break;
	}
}


BOOL CDrawItem::DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg)
{
	ASSERT_VALID(this);
	if (pView != NULL)
		ASSERT_VALID(pView);
	if (lpMsg != NULL)
		ASSERT(AfxIsValidAddress(lpMsg, sizeof(MSG), FALSE));

    try
    {
		Activate(nVerb, pView, lpMsg);
	}
    catch(COleException* e)
    {
	    if (e->m_sc==OLE_E_STATIC) 
        {
            CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_OLE_STATIC_OBJECT);
        }
		else if (!ReportError(e->m_sc))
        {
		    AlignedAfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
        }

        e->Delete();
		return FALSE;
	}
    catch(CException* e)
    {
		// otherwise, show generic error
		AlignedAfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH);
        e->Delete();
		return FALSE;
	}
    catch(...)
    {
        return FALSE;
    }

	return TRUE;
}



BOOL CDrawItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	CRect rect = rectPos;
	pView->ClientToDoc(rect);

	if (rect != m_pDrawObj->m_position)
	{
		// invalidate old rectangle
		m_pDrawObj->Invalidate();

		// update to new rectangle
		m_pDrawObj->m_position = rect;
		GetExtent(&m_pDrawObj->m_extent);

		// and invalidate new rectangle
		m_pDrawObj->Invalidate();

		// mark document as dirty
		GetDocument()->SetModifiedFlag();
	}
	return COleClientItem::OnChangeItemPosition(rectPos);
}

void CDrawItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// update to extent of item if m_position is not initialized
	if (m_pDrawObj->m_position.IsRectEmpty())
		UpdateExtent();

	// copy m_position, which is in document coordinates
	CDrawView* pView = GetActiveView();
	ASSERT_VALID(pView);
	rPosition = m_pDrawObj->m_position;
	pView->DocToClient(rPosition);
}

void CDrawItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Note: this sets up the m_pDocument pointer returned from
	//  CDrawItem::GetDocument, therefore it is a good idea
	//  to call the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CDrawItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

BOOL CDrawItem::UpdateExtent()
{
	CDC	  dc;
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	if( dc.CreateCompatibleDC( NULL ) )
		{
		dc.SetMapMode( MM_TEXT );
		dc.HIMETRICtoLP( &size ); // convert to screen space
		dc.DeleteDC();
		}

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - size.cy;
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left + size.cx;
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top - size.cy;
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}

#ifdef FUBAR
BOOL CDrawItem::UpdateExtent()
{
	CSize size;
	if (!GetExtent(&size) || size == m_pDrawObj->m_extent)
		return FALSE;       // blank

	// if new object (i.e. m_extent is empty) setup position
	if (m_pDrawObj->m_extent == CSize(0, 0))
	{
		m_pDrawObj->m_position.right =
			m_pDrawObj->m_position.left + MulDiv(size.cx, 10, 254);
		m_pDrawObj->m_position.bottom =
			m_pDrawObj->m_position.top - MulDiv(size.cy, 10, 254);
	}
	// else data changed so scale up rect as well
	else if (!IsInPlaceActive() && size != m_pDrawObj->m_extent)
	{
		m_pDrawObj->m_position.right = 
			m_pDrawObj->m_position.left +
			MulDiv(m_pDrawObj->m_position.Width(), size.cx, m_pDrawObj->m_extent.cx);
		m_pDrawObj->m_position.bottom = 
			m_pDrawObj->m_position.top +
			MulDiv(m_pDrawObj->m_position.Height(), size.cy, m_pDrawObj->m_extent.cy);
	}

	m_pDrawObj->m_extent = size;
	m_pDrawObj->Invalidate();   // redraw to the new size/position
	return TRUE;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDrawItem diagnostics

#ifdef _DEBUG
void CDrawItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CDrawItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpedoc.cpp ===
//--------------------------------------------------------------------------
// CPEDOC.CPP
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      document module for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "faxreg.h"
#include "resource.h"
#include "faxutil.h"
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CDrawDoc, COleDocument)


//--------------------------------------------------------------------------
CDrawDoc::CDrawDoc():m_bSerializeFailed(FALSE)
{

    m_wScale = 100;                                 //default to full size
    m_wPaperSize = ((CDrawApp*)(AfxGetApp()))->GetLocaleDefaultPaperSize();    //default to papersize of letter
    m_wOrientation=DMORIENT_PORTRAIT;               //default to portrait mode
    m_nMapMode = MM_ANISOTROPIC;
    m_paperColor = COLOR_WHITE;
    ComputePageSize();

}

//--------------------------------------------------------------------------
CDrawDoc::~CDrawDoc()
{
}

//--------------------------------------------------------------------------
BOOL CDrawDoc::OnNewDocument()
{
    if (!COleDocument::OnNewDocument())
        return FALSE;

    UpdateAllViews(NULL);

    return TRUE;
}


//-----------------------------------------------------------------------------
CDrawDoc* CDrawDoc::GetDoc()
{
    CFrameWnd* pFrame = (CFrameWnd*) (AfxGetApp()->m_pMainWnd);
    return (CDrawDoc*) pFrame->GetActiveDocument();
}


//--------------------------------------------------------------------------
void CDrawDoc::Serialize(CArchive& ar)
{
    m_bSerializeFailed = FALSE ;
    if (ar.IsStoring()) 
    {

     //
     // Windows XP Fax Cover Page Editor puts all information
     // needed for rendering up front.
     //

     try 
     {
         StoreInformationForPrinting( ar ); // Includes the signature, _gheaderVer5
     }

     catch(CException* e )
     {
        SetModifiedFlag( FALSE ) ;
        m_bSerializeFailed = TRUE ;
        e->Delete();
     }
     catch(...)
     {
     }
     //
     // Now serialize as in Windows 95 Cover Page Editor.
     //

     ///////////////   ar.Write( _gheaderVer4, 20 );

        ar << m_wScale;
        ar << m_wPaperSize;
        ar << m_wOrientation;
        ar << m_paperColor;
        m_objects.Serialize(ar);
    }
    else 
    {
        try 
        {
                // set defaults for any unread params
            m_wScale = 100;
            m_wPaperSize = ((CDrawApp*)(AfxGetApp()))->GetLocaleDefaultPaperSize();
            m_wOrientation=DMORIENT_PORTRAIT;

            if (m_iDocVer==VERSION2) {
                ar.GetFile()->Seek(sizeof(_gheaderVer2),CFile::begin);
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION3) {
                ar.GetFile()->Seek(sizeof(_gheaderVer3),CFile::begin);
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
                else if (m_iDocVer==VERSION4) {
                ar.GetFile()->Seek(sizeof(_gheaderVer4),CFile::begin);
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else if (m_iDocVer==VERSION5) {
                SeekPastInformationForPrinting( ar ) ;
                ar >> m_wScale;
                ar >> m_wPaperSize;
                ar >> m_wOrientation;
            }
            else {
                ar.GetFile()->SeekToBegin();
            }

/** DISABLE SCALEING - SEE 2868's BUG LOG **/
            m_wScale = 100;
/*******************************************/

            ComputePageSize();

            ar >> m_paperColor;
            m_objects.Serialize(ar);
        }
        catch(CException* e )
        {
            SetModifiedFlag( FALSE ) ;
            m_bSerializeFailed = TRUE ;
            ////THROW_LAST() ;       //// No!  I don't like the framework's message box!
            e->Delete();
        }
        catch(...)
        {
        }

/**********************NOTE- BUG FIX FOR 3133**********************/
// can't call COleDocument::Serialize because COleDrawObj has
// already saved its client item. Also, items associated with
// undo objects will get saved if COleDocument::Serialize is called
// and will cause the file to mysteriously grow 'n grow...
//    COleDocument::Serialize(ar);
/******************************************************************/
        if( m_bDataFileUsesAnsi )
        {
            SetModifiedFlag();            // Conversion to UNICODE is a modification worth prompting to save!
            m_bDataFileUsesAnsi = FALSE ; // When using CLIPBOARD, assume LOGFONTW structures.
        }
    }
}

DWORD
CopyTLogFontToWLogFont(
        IN  const LOGFONT & lfSource,
        OUT LOGFONTW & lfDestW
        )
{
/*++

Routine Description:

    This fuction copies a LogFont structure from T format
    to UNICODE format.

Arguments:
    
      lfSource - reference to input LongFont structure
      lfDestW - reference to output UNICODE LongFont structure

Return Value:

    WINAPI last error
--*/
    lfDestW.lfHeight = lfSource.lfHeight ;
    lfDestW.lfWidth = lfSource.lfWidth ;
    lfDestW.lfEscapement = lfSource.lfEscapement ;
    lfDestW.lfOrientation = lfSource.lfOrientation ;
    lfDestW.lfWeight = lfSource.lfWeight ;
    lfDestW.lfItalic = lfSource.lfItalic ;
    lfDestW.lfUnderline = lfSource.lfUnderline ;
    lfDestW.lfStrikeOut = lfSource.lfStrikeOut ;
    lfDestW.lfCharSet = lfSource.lfCharSet ;
    lfDestW.lfOutPrecision = lfSource.lfOutPrecision ;
    lfDestW.lfClipPrecision = lfSource.lfClipPrecision ;
    lfDestW.lfQuality = lfSource.lfQuality ;
    lfDestW.lfPitchAndFamily = lfSource.lfPitchAndFamily ;

    SetLastError(0);
#ifdef UNICODE
    wcscpy( lfDestW.lfFaceName,lfSource.lfFaceName);
#else
    int iCount;
    iCount = MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                lfSource.lfFaceName,
                LF_FACESIZE,
                lfDestW.lfFaceName,
                LF_FACESIZE
            );

    if (!iCount)
    {
        TRACE( TEXT("Failed to covert string to UNICODE"));
        return GetLastError();
    }
#endif
    return ERROR_SUCCESS;
}


void CDrawDoc::StoreInformationForPrinting( CArchive& ar )
{
//
// Create an Enhanced MetaFile followed by text box information,
// to store, for rendering by a WINAPI function PrtCoverPage.
//
// Author  Julia J. Robinson
//
// March 29, 1996
//
   COMPOSITEFILEHEADER CompositeFileHeader ;
   memcpy( &CompositeFileHeader.Signature, _gheaderVer5w, 20 );

   CompositeFileHeader.CoverPageSize = m_size ;
   CompositeFileHeader.EmfSize = 0 ;
   CompositeFileHeader.NbrOfTextRecords = 0 ;
   //
   // Get the default printer to use as a reference device for the metafile.
   //
   LPTSTR  pDriver ;
   LPTSTR  pDevice ;
   LPTSTR  pOutput ;
   TCHAR  PrinterName[MAX_PATH];
   CDC ReferenceDC ;
   CDC *pScreenDC ;
   POSITION vpos = GetFirstViewPosition();
   CDrawView* pView = (CDrawView*)GetNextView(vpos);
   pScreenDC = pView->GetWindowDC();
   BOOL PrinterFound = FALSE ;
   GetProfileString( TEXT("Windows"), TEXT("device"), TEXT(",,,"), PrinterName, MAX_PATH ) ;
   if(( pDevice = _tcstok( PrinterName, TEXT(","))) &&
      ( pDriver = _tcstok( NULL, TEXT(", "))) &&
      ( pOutput = _tcstok( NULL, TEXT(", ")))) {

      PrinterFound = ReferenceDC.CreateDC( pDriver, pDevice, pOutput, NULL ) ;
   }

   //
   //  Make sure m_size agrees with current default printer settings.
   //

   ComputePageSize() ;

   //
   // Create an enhanced metafile in a buffer in memory, containing all of the graphics.
   //

   CRect Rect( 0,
               0,
               MulDiv( m_size.cx, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ),
               MulDiv( m_size.cy, LE_TO_HM_NUMERATOR, LE_TO_HM_DENOMINATOR ));
   CMetaFileDC mDC ;

   //
   //  If no default printer exists, use the screen as reference device.
   //

   INT hdc = mDC.CreateEnhanced( !PrinterFound ? pScreenDC : &ReferenceDC,
                                 NULL,
                                 LPCRECT(Rect),
                                 NULL ) ;
   if( !hdc ){
       TRACE( TEXT("Failed to create the enhanced metafile"));
   }
#if 0
   //
   // The MM_ANISOTROPIC matches well as long as the laser printer or fax printer is the
   // reference device, but mismatches miserably when the screen is the reference device.
   //
   mDC.SetMapMode( MM_ANISOTROPIC );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   mDC.SetViewportExt( !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSX)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSX ),
                       !PrinterFound ? pScreenDC->GetDeviceCaps(LOGPIXELSY)
                                     : ReferenceDC.GetDeviceCaps( LOGPIXELSY ));
   mDC.SetWindowExt(100,-100);
   mDC.SetViewportOrg( 0, 0 );
#endif
   mDC.SetMapMode( MM_LOENGLISH );
   mDC.SetWindowOrg( -m_size.cx/2, m_size.cy/2 ) ;
   pView->ReleaseDC( pScreenDC );
   //
   //  Iterate the list of objects, drawing everything but text objects to the metafile.
   //  Count text boxes as we go.
   //  Consider each serializeable class separately, just to be safe!!!
   //
   if( ! m_objects.IsEmpty()){
      //CDrawView* pView = GetNextView();
      POSITION vpos = GetFirstViewPosition();
      CDrawView * pView = (CDrawView*) GetNextView( vpos ) ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ) {
         CObject* pCurrentObject = m_objects.GetNext(pos) ;
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pCurrentObject ){
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pCurrentObject->GetRuntimeClass()))
         {
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){

             ++CompositeFileHeader.NbrOfTextRecords ; // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){

             ++CompositeFileHeader.NbrOfTextRecords ;  // text and font info will go in AFTER the metafile.
             CDrawRect* pThisObj = (CDrawRect*) pCurrentObject ;
             pThisObj->CDrawRect::Draw( &mDC, pView ); // draw border and fill
         }
         else {
             CDrawObj* pThisObj = (CDrawObj*) pCurrentObject ;
             pThisObj->Draw( &mDC, pView );
         }
      }
   }
   /////////CDrawView::m_IsRecording = FALSE;                // re-enable the scroll bar
   LPBYTE MBuffer ;
   HENHMETAFILE hEMF = mDC.CloseEnhanced();
   if( !hEMF )
   {
   }
   CompositeFileHeader.EmfSize = GetEnhMetaFileBits( hEMF, NULL, NULL ) ;
   if(!CompositeFileHeader.EmfSize)
   {
   }
   ar.Write( &CompositeFileHeader, sizeof(CompositeFileHeader));
   HGLOBAL hglobal ;
   if(( CompositeFileHeader.EmfSize ) &&
      ( hglobal = GlobalAlloc( GMEM_MOVEABLE, CompositeFileHeader.EmfSize )) &&
      ( MBuffer = (LPBYTE)GlobalLock(hglobal)) &&
      ( GetEnhMetaFileBits( hEMF, CompositeFileHeader.EmfSize, MBuffer ))) 
   {
      ar.Write( MBuffer, CompositeFileHeader.EmfSize ) ;
      GlobalUnlock( hglobal ) ;
      GlobalFree( hglobal );
   }
   //
   // Reiterate the m_objects list and write the text boxes to the file
   //
   if( !m_objects.IsEmpty()){
      TEXTBOXW TextBoxW ;
      POSITION pos = m_objects.GetHeadPosition() ;
      while( pos != NULL ){
         CObject* pObj = m_objects.GetNext(pos) ;
         //
         //  For each CDrawText and CFaxProp object,
         //  put a TEXTBOXW and string in the file.
         //
         CRuntimeClass* pWhatClass = NULL ;
         if( NULL == pObj ){
            //
            // Perfectly OK to store a NULL CObject pointer in a list.
            // Don't do anything!!
            //
         }
         else if( NULL == ( pWhatClass = pObj->GetRuntimeClass())){
            //
            // Corrupted memory or programmer error!!!  The serializable object
            // ought to have a runtime class!
            //
         }
         else if( pWhatClass == RUNTIME_CLASS( CDrawText )){
              DWORD Length = 0;
              LPCTSTR lptstrText = NULL;
              LPWSTR lpwstrUnicodeText = NULL;
              CDrawText* pThisObj = (CDrawText*) pObj ;
            
              if (CopyTLogFontToWLogFont(pThisObj->m_logfont,TextBoxW.FontDefinition) != ERROR_SUCCESS)
              {
                  AfxThrowMemoryException() ;
              }

              TextBoxW.ResourceID = 0 ;
              TextBoxW.TextColor = pThisObj->m_crTextColor ;
              TextBoxW.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBoxW.PositionOfTextBox = (RECT) pThisObj->m_position ;
              CString textString =  pThisObj->GetEditTextString();
              lptstrText = (LPCTSTR)textString;
#ifndef _UNICODE
              lpwstrUnicodeText = AnsiStringToUnicodeString(lptstrText);
              if (!lpwstrUnicodeText)
              {
                    AfxThrowMemoryException();
              }
#else
              lpwstrUnicodeText = (LPWSTR) lptstrText;
#endif          
              Length = wcslen(lpwstrUnicodeText) * sizeof(WCHAR);
              TextBoxW.NumStringBytes = Length;
              ar.Write( &TextBoxW, sizeof(TEXTBOXW));
              ar.Write( lpwstrUnicodeText, Length);
#ifndef _UNICODE
              MemFree(lpwstrUnicodeText);
#endif
         }
         else if ( pWhatClass == RUNTIME_CLASS( CFaxProp )){
              CFaxProp* pThisObj = (CFaxProp*) pObj ;

              if (CopyTLogFontToWLogFont(pThisObj->m_logfont,TextBoxW.FontDefinition) != ERROR_SUCCESS)
              {
                  AfxThrowMemoryException() ;
              }

              TextBoxW.TextColor = pThisObj->m_crTextColor ;
              TextBoxW.TextAlignment = pThisObj->GetTextAlignment() ;
              TextBoxW.PositionOfTextBox = (RECT) pThisObj->m_position ;
              TextBoxW.ResourceID = pThisObj->GetResourceId();
              TextBoxW.NumStringBytes = 0 ;
              ar.Write( &TextBoxW, sizeof(TEXTBOXW));
         }
         else { // This won't happen.
         }
       }
   }
}

void CDrawDoc::SeekPastInformationForPrinting( CArchive& ar )
{
  //
  // Start over from beginning of file and read in the file header.
  //
  ar.GetFile()->SeekToBegin();
  COMPOSITEFILEHEADER CompositeFileHeader;
  UINT BytesRead = ar.Read( &CompositeFileHeader, sizeof(COMPOSITEFILEHEADER));
  if(BytesRead != sizeof(COMPOSITEFILEHEADER)){
      //
      // Any exception will do.  The CATCH_ALL in CDrawDoc::Serialize() is the target.
      //
      AfxThrowMemoryException() ;
  }
  void * pBuffer ;
  HLOCAL hMem;

  //
  // Seek past the metafile.  It is only for printing with
  // the WINAPI function PrtCoverPage.
  //

  if( CompositeFileHeader.EmfSize ){
          hMem = LocalAlloc( LMEM_MOVEABLE, CompositeFileHeader.EmfSize );
          if( NULL == hMem ){
              LocalFree( hMem );
              AfxThrowMemoryException() ; // See above.  Any exception will do.
          }
          pBuffer = LocalLock( hMem );
          if( NULL == pBuffer ){
              AfxThrowMemoryException();
          }
          if( CompositeFileHeader.EmfSize != ar.Read( pBuffer, CompositeFileHeader.EmfSize )){
              LocalUnlock( pBuffer );
              LocalFree( hMem );
              AfxThrowMemoryException() ;
          }
          LocalUnlock( pBuffer );
          LocalFree( hMem );
  }

  //
  // Skip over the text boxes.  These are used only by PrtCoverPage.
  // Each text box is followed by a variable length string.
  //

  UINT SizeOfTextBox = sizeof(TEXTBOXW) ;
  for( DWORD Index = 0 ; Index < CompositeFileHeader.NbrOfTextRecords ; ++Index ){
       TEXTBOXW TextBoxW ;
       if( sizeof(TEXTBOXW) != ( BytesRead = ar.Read( &TextBoxW, sizeof(TEXTBOXW)))){
           AfxThrowMemoryException();
       }
       if( TextBoxW.NumStringBytes ){
           hMem = LocalAlloc( LMEM_MOVEABLE, TextBoxW.NumStringBytes );
           if( NULL == hMem ){
               AfxThrowMemoryException() ;
           }
           pBuffer = LocalLock( hMem );
           if( NULL == pBuffer ){
               LocalFree( hMem ) ;
               AfxThrowMemoryException() ;
           }
           if( TextBoxW.NumStringBytes != ar.Read( pBuffer, TextBoxW.NumStringBytes )){
               LocalUnlock( pBuffer );
               LocalFree( hMem );
               AfxThrowMemoryException();
           }
           LocalUnlock( pBuffer );
           LocalFree( hMem );
       }
  }
}


//--------------------------------------------------------------------------
void CDrawDoc::Draw(CDC* pDC, CDrawView* pView, CRect rcClip)
{
    POSITION pos = m_objects.GetHeadPosition();
    if( !pDC->IsPrinting() )
    { 
        // NOT PRINTING
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            if( pObj->Intersects( rcClip, TRUE ))
            {
                pObj->Draw(pDC, pView);
                if ( pView->IsSelected(pObj))
                {
                    pObj->DrawTracker(pDC, CDrawObj::selected);
                }
            }
        }
    }
    else 
    { 
        // PRINTING
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
            pObj->Draw(pDC, pView);
        }
    }
}


//--------------------------------------------------------------------------
void CDrawDoc::Add(CDrawObj* pObj,BOOL bUndo /*=TRUE*/)
{
    CDrawView *pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

#if 0
    if (bUndo)
        pView->AddToUndo(new CAddUndo(pObj));
#endif

    if (bUndo){
        pView->SaveStateForUndo();
    }
        m_objects.AddTail(pObj);
        pObj->m_pDocument = this;
        SetModifiedFlag();
}


//--------------------------------------------------------------------------
void CDrawDoc::DeleteContents()
{
    Remove();

    CDrawView* pView = CDrawView::GetView();
    if (pView){
        pView->DisableUndo();
    }
    CDrawView::FreeObjectsMemory( & m_previousStateForUndo );
    m_previousStateForUndo.RemoveAll();
}


//--------------------------------------------------------------------------
void CDrawDoc::Remove(CDrawObj* pObj /*=NULL*/)
{
    CDrawView* pView = CDrawView::GetView();

    if (pObj==NULL) 
    {                    //remove all document objects
        if (pView) 
        {
            if (pView->m_pObjInEdit) 
            {                //first destroy edit window
                pView->m_pObjInEdit->m_pEdit->DestroyWindow();
                pView->m_pObjInEdit=NULL;
            }
        }
        POSITION pos = m_objects.GetHeadPosition();
        while (pos != NULL) 
        {
            CDrawObj* pobj = (CDrawObj*)m_objects.GetNext(pos);
            if (!pobj)
            {
                break;
            }
            if (pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) 
            {
                COleClientItem* pItem=((CDrawOleObj*)pobj)->m_pClientItem;
                if (pItem)  
                { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    RemoveItem(pItem);
                    pItem->InternalRelease();
                }
            }
            delete pobj;         //delete object
        }
        m_objects.RemoveAll();
        if (pView)
        {
            pView->m_selection.RemoveAll();     //remove pointers from selection list
        }
    }
    else 
    {
        if (pView) 
        {
            if (pObj==pView->m_pObjInEdit) 
            {
                pView->m_pObjInEdit->m_pEdit->DestroyWindow();
                pView->m_pObjInEdit=NULL;
            }
        }
        POSITION pos = m_objects.Find(pObj);
        if (pos != NULL) 
        {
            m_objects.RemoveAt(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)) ) 
            {
                COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                if (pItem)  
                { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem);
                    pItem->InternalRelease();
                }
            }
            if (pView)
            {
                pView->Remove(pObj);
            }
            delete pObj;
        }
    }
}   // CDrawDoc::Remove

//--------------------------------------------------------------------------
CDrawObj* CDrawDoc::ObjectAt(const CPoint& point)
{
        CRect rc;
    rc.top=point.y+2;
        rc.bottom=point.y-2;
        rc.left=point.x-2;
        rc.right=point.x+2;

        POSITION pos = m_objects.GetTailPosition();
        while (pos != NULL) {
                CDrawObj* pObj = (CDrawObj*)m_objects.GetPrev(pos);
        if (pObj->Intersects(rc))
                            return pObj;
        }

        return NULL;
}


//--------------------------------------------------------------------------
void CDrawDoc::ComputePageSize()
{
    CSize new_size;
        BOOL do_default = FALSE;

    CPrintDialog dlg(FALSE);
    if (AfxGetApp()->GetPrinterDeviceDefaults(&dlg.m_pd)) 
    {
        LPDEVMODE  lpDevMode = (dlg.m_pd.hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(dlg.m_pd.hDevMode) : NULL;

#ifdef _DEBUG
        if (m_wOrientation==DMORIENT_PORTRAIT)
        {
            TRACE( TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to portrait \n"));
        }
        else
        {
            TRACE(TEXT("AWCPE:  CDrawDoc::ComputePageSize() orientation to landscape \n"));
        }
#endif
        if (lpDevMode)
        {
            lpDevMode->dmPaperSize=m_wPaperSize;     // version 3 param
            lpDevMode->dmOrientation=m_wOrientation; // version 2 param

            // use doc scale only if printer supports scaleing
            if( lpDevMode->dmFields & DM_SCALE )
            {
                lpDevMode->dmScale   = m_wScale;
            }
            else
            {
                lpDevMode->dmScale   = 100;
            }

        }
        if (dlg.m_pd.hDevMode != NULL)
        {
            ::GlobalUnlock(dlg.m_pd.hDevMode);
        }

        CDC dc;
        HDC hDC= dlg.CreatePrinterDC();

        // don't fail if no printer, just use defaults
        if( hDC != NULL )
        {
            dc.Attach(hDC);

            // Get the size of the page in loenglish
            new_size.cx=MulDiv(dc.GetDeviceCaps(HORZSIZE),1000,254);
            new_size.cy=MulDiv(dc.GetDeviceCaps(VERTSIZE),1000,254);
        }
        else
        {
            do_default = TRUE;
        }
    }
    else
    {
        do_default = TRUE;
    }


    if( do_default )
    {
        // couldn't get at printer goo, just make a guess
        if (m_wOrientation==DMORIENT_PORTRAIT)
        {
            new_size.cx=850;   // 8.5 inches
            new_size.cy=1100;  // 11 inches
        }
        else
        {
            new_size.cx=1100;  // 11 inches
            new_size.cy=850;   // 8.5 inches
        }
    }


    if (new_size != m_size)  
    {
        m_size = new_size;
        POSITION pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            ((CDrawView*)GetNextView(pos))->SetPageSize(m_size);
        }
    }
}   // CDrawDoc::ComputePageSize




//--------------------------------------------------------------------------
void CDrawDoc::OnViewPaperColor()
{
        CColorDialog dlg;
        if (dlg.DoModal() != IDOK)
                return;

        m_paperColor = dlg.GetColor();
        SetModifiedFlag();
        UpdateAllViews(NULL);
}

UINT_PTR 
CALLBACK 
OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
/*++

Routine name : OFNHookProc

Routine description:

    Callback function that is used with the 
    Explorer-style Open and Save As dialog boxes.
    Refer MSDN for more info.

--*/
{
    UINT_PTR nRes = 0;

    if(WM_NOTIFY == uiMsg)
    {
        LPOFNOTIFY pOfNotify = (LPOFNOTIFY)lParam;
        if(CDN_FILEOK == pOfNotify->hdr.code)
        {
            if(_tcslen(pOfNotify->lpOFN->lpstrFile) > (MAX_PATH-10))
            {
                AlignedAfxMessageBox(IDS_SAVE_AS_TOO_LONG, MB_OK | MB_ICONEXCLAMATION);
                SetWindowLong(hdlg, DWLP_MSGRESULT, 1);
                nRes = 1;
            }
        }
    }
    return nRes;
}


//--------------------------------------------------------------------------
BOOL CDrawDoc::DoSave(LPCTSTR lpszPathName, BOOL bReplace)
{
    if (!IsOkToClose())                  //added to check for existence of fax properties
    {
        return FALSE;
    }

    CString newName = lpszPathName;
    if (newName.IsEmpty())  /// SAVE AS rather than SAVE
    {
        CDocTemplate* pTemplate = GetDocTemplate();
        ASSERT(pTemplate != NULL);
        newName = m_strPathName;
        if (bReplace && newName.IsEmpty()) 
        {
             newName = m_strTitle;

             // append the default suffix if there is one
             CString strExt;
             if (pTemplate->GetDocString(strExt, CDocTemplate::filterExt) && !strExt.IsEmpty())
             {
                 ASSERT(strExt[0] == TEXT('.'));
                 newName += strExt;
             }
         }
         CString UpperNewName = newName ;
         UpperNewName.MakeUpper();
         if( UpperNewName.Right(4) == TEXT(".CPE"))
         {
             int Length = newName.GetLength() - 4 ;   /// Get rid of the ".CPE"
             newName = newName.Left( Length );
             newName += FAX_COVER_PAGE_FILENAME_EXT;   ////// Suggest the ".COV" extension.
         }
         if ( !((CDrawApp*)AfxGetApp())->IsInConvertMode() )
         {
             if (!((CDrawApp*)AfxGetApp())->DoPromptFileName(
                 newName,
                 bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
                 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                 FALSE,
                 pTemplate,
                 OFNHookProc))
             {
                 return FALSE;       // don't even attempt to save
             }
         }
         else
         {  
            //
            // The cover page application is in mode to convert CPE's to COV's.
            //
            TCHAR tszClientDir[2*MAX_PATH] = {0};
            //
            // save the coverted CPE file into CSIDL_PERSONAL\Fax\Personal Coverpages
            //
            if (GetClientCpDir (tszClientDir, ARR_SIZE(tszClientDir)))
            {
                CFile _newFile;
                _newFile.SetFilePath(newName);
                newName=_newFile.GetFileName();
                CString newPath = tszClientDir;
                newName = newPath + newName;
            }
         }
    }

    //
    // If called by SaveModified () on exiting, and the NewName happens to be the name of a
    // read only file, we would get a popup "Access to %1 denied" and exit without further
    // chance to save.  We avoid that scenario by checking the attributes and doing the popup
    // ourselves.  a-juliar, 9-26-96
    //

    DWORD newFileAttributes = GetFileAttributes( (LPCTSTR)newName );

    if ( (0xFFFFFFFF != newFileAttributes) &&
        ((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // the file exists in the personal cover page folder. don't transfer it.
        // this is a speced limitation of this feature.
        //
        return TRUE;
    }


    if ( 0xFFFFFFFF != newFileAttributes &&
        ((FILE_ATTRIBUTE_READONLY & newFileAttributes ) ||
        (FILE_ATTRIBUTE_DIRECTORY & newFileAttributes )))
    {
        CString ThisMess ;
        AfxFormatString1( ThisMess, AFX_IDP_FILE_ACCESS_DENIED, newName );
        AlignedAfxMessageBox( ThisMess );
        return FALSE ;    // Don't exit without saving.
    }
    

    BeginWaitCursor();
    if (!OnSaveDocument(newName))
    {
        if (lpszPathName == NULL)
        {
        // be sure to delete the file
            try
            {
                CFile::Remove(newName);
            }
            catch(CException* e )
            {
                TRACE0("Warning: failed to delete file after failed SaveAs.\n");
                e->Delete();
            }
            catch(...)
            {
            }
        }
        EndWaitCursor();
        return FALSE;
    }

    // reset the title and change the document name
    if (bReplace)
    {
        SetPathName(newName);
    }
    EndWaitCursor();
    return TRUE;        // success
}
//--------------------------------------------------------------------------
void CDrawDoc::CloneObjectsForUndo()
{
    POSITION pos = m_objects.GetHeadPosition();
    while( pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
        CDrawObj* pClone = pObj->Clone( NULL );
        m_previousStateForUndo.AddTail( pClone );
    }
}
//--------------------------------------------------------------------------
void CDrawDoc::SwapListsForUndo()
{
    INT_PTR iPreviousCount = m_previousStateForUndo.GetCount();
    m_previousStateForUndo.AddTail( & m_objects );
    m_objects.RemoveAll();
    for( int index = 0 ; index < iPreviousCount ; ++ index ){
         CObject * pObj = m_previousStateForUndo.RemoveHead();
         m_objects.AddTail( pObj );
    }
}
//---------------------------------------------------------------------------
BOOL CDrawDoc::IsOkToClose()
{
    CDrawApp* pApp = (CDrawApp*)AfxGetApp();
    BOOL bFaxObj=FALSE;

    if ( !(pApp->m_bCmdLinePrint || pApp->m_dwSesID!=0) ) {
       POSITION pos = m_objects.GetHeadPosition();
       while (pos != NULL) {
          CDrawObj* pObj = (CDrawObj*)m_objects.GetNext(pos);
          if (pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ) {
                 bFaxObj=TRUE;
             break;
                  }
           }
       if (!bFaxObj)
           if (CPEMessageBox(MSG_INFO_NOFAXPROP, NULL, MB_YESNO, IDS_INFO_NOFAXPROP)==IDNO)
             return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------
void CDrawDoc::SetPathName( LPCTSTR lpszPathName, BOOL bAddToMRU )
{
        COleDocument::SetPathName( lpszPathName, bAddToMRU );

#if !defined( _NT ) && !defined( WIN32S )
        SHFILEINFO sfi;

        if( GetFileAttributes( lpszPathName ) != 0xffffffff ) {
                if( SHGetFileInfo( lpszPathName, 0, &sfi, sizeof( sfi ), SHGFI_DISPLAYNAME ) )  {
                        SetTitle( sfi.szDisplayName );
                }
        }
#endif
}

//---------------------------------------------------------------------------

void CDrawDoc::OnFileSave()
{
  // This override was added to "enforce" the .COV file extension when saving.  a-juliar, 9-19-96
    CString FileName = m_strPathName ;
    FileName.MakeUpper();
    if( FileName.Right(4) == TEXT( ".CPE" )){
        OnFileSaveAs();
    }
    else {
        CDocument::OnFileSave();
    }
}
//---------------------------------------------------------------------------
void CDrawDoc::OnFileSaveAs()
{
    CDocument::OnFileSaveAs() ;
}
//---------------------------------------------------------------------------
void CDrawDoc::OnUpdateFileSave(CCmdUI* pCmdUI)
{
   pCmdUI->Enable(TRUE);
}



#ifdef _DEBUG
void CDrawDoc::AssertValid() const
{
        COleDocument::AssertValid();
}

void CDrawDoc::Dump(CDumpContext& dc) const
{
        COleDocument::Dump(dc);
}
#endif //_DEBUG


BOOL CDrawDoc::SaveModified()
{
    //
    // Overridden to enforce the ".COV" file extension. 9-26-96, a-juliar
    //
    // Copied from COleDocument::SaveModified
    // determine if necessary to discard changes
    if (::InSendMessage())
    {
        POSITION pos = GetStartPosition();
        COleClientItem* pItem;
        while ((pItem = GetNextClientItem(pos)) != NULL)
        {
            ASSERT(pItem->m_lpObject != NULL);
            SCODE sc = pItem->m_lpObject->IsUpToDate();
            if (sc != OLE_E_NOTRUNNING && FAILED(sc))
            {
                //
                // inside inter-app SendMessage limits the user's choices
                //
                CString name = m_strPathName;
                if (name.IsEmpty())
                {
                    VERIFY(name.LoadString(AFX_IDS_UNTITLED));
                }

                CString prompt;
                AfxFormatString1(prompt, AFX_IDP_ASK_TO_DISCARD, name);
                return AlignedAfxMessageBox(prompt, MB_OKCANCEL|MB_DEFBUTTON2, AFX_IDP_ASK_TO_DISCARD) == IDOK;
            }
        }
    }
    //
    // sometimes items change without a notification, so we have to
    // update the document's modified flag before calling CDocument::SaveModified.
    //
    UpdateModifiedFlag();

    if (!IsModified())
    {
        return TRUE;        // ok to continue
    }
    //
    // Get name/title of document
    //
    CString name;
    if (m_strPathName.IsEmpty())
    {
        // Get name based on caption
        name = m_strTitle;
        if (name.IsEmpty())
        {
            VERIFY(name.LoadString(AFX_IDS_UNTITLED));
        }
    }
    else
    {
        // Get name based on file title of path name
        name = m_strPathName;
    }

    int iMessageBoxRes = IDYES;
    if (!((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        CString prompt;
        AfxFormatString1(prompt, AFX_IDP_ASK_TO_SAVE, name);
        iMessageBoxRes = AlignedAfxMessageBox(prompt, MB_YESNOCANCEL, AFX_IDP_ASK_TO_SAVE);
    }
    switch (iMessageBoxRes)
    {
        case IDCANCEL:
            return FALSE;       // don't continue

        case IDYES:
            {
                //
                // Enforce the ".COV" extension.
                //
                CString FileName = m_strPathName ;
                FileName.MakeUpper();
                if ( FileName.Right(4) != FAX_COVER_PAGE_FILENAME_EXT)
                {
                    return DoSave(NULL) ;
                }
                else 
                {
                    return DoFileSave();
                }
                break;
            }
        case IDNO:
            // If not saving changes, revert the document
            break;

        default:
            ASSERT(FALSE);
            break;
        }
    return TRUE;    // keep going
}   // CDrawDoc::SaveModified


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawDoc, COleDocument)
   //{{AFX_MSG_MAP(CDrawDoc)
        ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_NOTE, OnUpdateMapiMsgNote)
        //}}AFX_MSG_MAP
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
   ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
   ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, COleDocument::OnUpdateObjectVerbMenu)
   ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
   ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
   ON_COMMAND(ID_FILE_SAVE, OnFileSave)
   ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
END_MESSAGE_MAP()




void CDrawDoc::OnUpdateMapiMsgNote(CCmdUI* pCmdUI)
        {
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
                                {
                                // only allow one note, don't let user make any more
                                pCmdUI->Enable( FALSE );
                                return;
                                }
                        }
        }

        // No notes, let user make one
        pCmdUI->Enable( TRUE );

        }



void CDrawDoc::
        schoot_faxprop_toend( WORD res_id )
        /*
                Moves all CFaxProps objects in m_objects that are of
                type res_id to the end of the list.

                Can throw a CMemoryException
         */
        {
        CObList temp_obs;
        CDrawObj *pObj;
        CFaxProp *pfaxprop;
    POSITION pos, cur_pos;

    pos = m_objects.GetHeadPosition();
    while (pos != NULL)
        {
                cur_pos = pos;
        pObj = (CDrawObj*)m_objects.GetNext(pos);
                if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
                        {
                        pfaxprop = (CFaxProp *)pObj;
                        if( pfaxprop->GetResourceId() == res_id )
                                {
                                // move prop to temporary list
                                temp_obs.AddTail( pObj );

                                // remove from original list
                                m_objects.RemoveAt( cur_pos );
                                }
                        }
        }

        // put all found objects at end of original list
        m_objects.AddTail( &temp_obs );

        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\awcpe.h ===
//--------------------------------------------------------------------------
// AWCPE.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
//--------------------------------------------------------------------------
#ifndef __AWCPE_H__
#define __AWCPE_H__

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "awcpesup.h"
#include <stdio.h>
#include <faxreg.h>

/*****************TEMPORARY*********************/
#define CPE_MESSAGE_NOTE        CPE_RECIPIENT_NAME
/***********************************************/



//
// Look in the registry under HKEY_LOCAL_MACHINE for the following DWORD key.  Hidden fields
//    will be enabled if their corresponding bit is set.
//
//[RB] #define EFC_COVER_PAGE_FIELDS (TEXT("Software\\Microsoft\\Fax\\Setup\\EFC_CoverPageFields")) //[RB] Not used
#define COVFP_REC_COMPANY                0x00000004
#define COVFP_REC_STREET_ADDRESS         0x00000008
#define COVFP_REC_CITY                   0x00000010
#define COVFP_REC_STATE                  0x00000020
#define COVFP_REC_ZIP_CODE               0x00000040
#define COVFP_REC_COUNTRY                0x00000080
#define COVFP_REC_TITLE                  0x00000100
#define COVFP_REC_DEPARTMENT             0x00000200
#define COVFP_REC_OFFICE_LOCATION        0x00000400
#define COVFP_REC_HOME_PHONE             0x00000800
#define COVFP_REC_OFFICE_PHONE           0x00001000
#define COVFP_TO_LIST                    0x04000000
#define COVFP_CC_LIST                    0x08000000

#define _countof(array) (sizeof(array)/sizeof(array[0]))
#define GENERALSECTION _T("General")
#define TIPSECTION _T("Tips Section")
#define TIPENTRY _T("ShowTips")
#define MSGDRAWPOLY _T("Show polygon end dialog")

extern DWORD cshelp_map[];

extern BYTE BASED_CODE _gheaderVer1[20];
extern BYTE BASED_CODE _gheaderVer2[20];
extern BYTE BASED_CODE _gheaderVer3[20];
extern BYTE BASED_CODE _gheaderVer4[20];
extern BYTE BASED_CODE _gheaderVer5w[20];
extern BYTE BASED_CODE _gheaderVer5a[20];

class CMyPageSetupDialog;
class CFaxPropMap;
class CFaxProp;





/*
        CCpeDocTemplate is a derivation of CSingleDocTemplate used to
        override some default MFC behavior. See CCpeDocTemplate::MatchDocType
        in AWCPE.CPP
 */
class CCpeDocTemplate : public CSingleDocTemplate
        {
public:
        CCpeDocTemplate( UINT nIDResource, CRuntimeClass* pDocClass,
                                     CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass):
                CSingleDocTemplate( nIDResource, pDocClass,     pFrameClass, pViewClass )
                {;}



#ifndef _MAC
        virtual Confidence MatchDocType(LPCTSTR lpszPathName,
                                        CDocument*& rpDocMatch);
#else
        virtual Confidence MatchDocType(LPCTSTR lpszFileName,
                                        DWORD dwFileType, CDocument*& rpDocMatch);
#endif

        };








class CDrawApp : public CWinApp
{
public:
   HCURSOR m_hMoveCursor;
   BOOL m_bCmdLinePrint;
   LPAWCPESUPPORT m_pIawcpe;
   CString m_szRenderDevice;
   CString m_szRenderName;
   CFaxPropMap* m_pFaxMap;
   DWORD m_dwSesID;

/***CHANGES FOR M8 bug 2988***/
   LOGFONT m_last_logfont;
/*****************************/


// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
   LOGFONT m_default_logfont;
////////////////////////////////

   void filter_mru_list();
   BOOL DoPromptFileName(CString&, UINT, DWORD, BOOL, CDocTemplate*, LPOFNHOOKPROC lpOFNHook = NULL);
   CDrawApp();
   ~CDrawApp();

   // stuff for putting message notes on cover page
   TCHAR *m_note;
   BOOL m_note_wasread;
   BOOL m_note_wasclipped;
   BOOL m_extrapage_count;
   BOOL m_more_note;
   CFaxProp *m_last_note_box;
   CFaxProp *m_note_wrench;
   CFaxProp *m_extra_notepage;
   CDC      *m_pdc;     // easier to put it here instead of passing
                                        // it all over the place.

   void read_note( void );
   int  clip_note( CDC *pdc,
                   LPTSTR *drawtext, LONG *numbytes,
                   BOOL   delete_usedtext,
                   LPRECT drawrect );

   BOOL IsRTLUI() { return m_bRTLUI;}
   BOOL IsInConvertMode() {return m_bConvertCpeToCov;}

   void reset_note( void );

   WORD GetLocaleDefaultPaperSize( void ) const;

   LPTSTR GetHtmlHelpFile() { return FAX_COVERPAGE_HELP_FILE; }
   BOOL more_note( void ) {return( m_more_note );}
private:

   TCHAR *pos_to_strptr( TCHAR *src, long pos,
                                                 TCHAR break_char,
                                                 TCHAR **last_break, long *last_break_pos );
   BOOL m_bUseDefaultDirectory ;

protected:
   HMODULE m_hMod;
   int m_iErrorCode;
   HANDLE m_hSem;
   CString m_szDefaultDir;
   CString m_szFileName;
   BOOL m_bPrintHelpScreen;

   BOOL m_bRTLUI;
   BOOL m_bConvertCpeToCov;

   void InitRegistry();
   BOOL DoFilePageSetup(CMyPageSetupDialog& dlg);
   void RegistryEntries();
   virtual BOOL InitInstance();
   virtual int ExitInstance();
   void InitFaxProperties();
   BOOL IsSecondInstance();
   void CmdLinePrint();
   void PrintHelpScreen();
   void CmdLineRender();
   BOOL Render();
   BOOL Print();
   void ParseCmdLine();
   void OnFileOpen();
   void OnFileNew();
   afx_msg void OnFilePageSetup();
   CDocument* OpenDocumentFile(LPCTSTR lpszFileName);

        //{{AFX_MSG(CDrawApp)
        afx_msg void OnAppAbout();
                // NOTE - the ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};


class CSEHexception
{
   private:
     UINT m_nCode;
   public:
     CSEHexception() {};
     CSEHexception(UINT uCode) : m_nCode(uCode) {};
     ~CSEHexception() {};
     unsigned int GetNumber() {return m_nCode;};
};






extern CDrawApp NEAR theApp;


#endif //#ifndef __AWCPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpetool.h ===
//--------------------------------------------------------------------------
// CPETOOL.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPETOOL_H__
#define __CPETOOL_H__


#include "cpeobj.h"


class CDrawView;

enum DrawShape
{
	select,
	line,
	rect,
	text,
	faxprop,
	roundRect,
	ellipse,
	poly
};

class CDrawTool
{
// Constructors
public:
	CDrawTool(DrawShape nDrawShape);

// Overridables
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT) {};
	virtual void OnCancel();

// Attributes
	DrawShape m_drawShape;

	static CDrawTool* FindTool(DrawShape drawShape);
	static CPtrList c_tools;
	static CPoint c_down;
	static UINT c_nDownFlags;
	static CPoint c_last;
	static DrawShape c_drawShape;
    BOOL m_bMoveCurSet;
};

class CSelectTool : public CDrawTool
{
public:
   BOOL m_bClicktoMove;
   BOOL m_bSnapped;
   CPoint m_snappoint;

	CSelectTool();

	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnArrowKey(CDrawView* pView, UINT, UINT, UINT);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
protected:
#ifdef GRID
   void CheckSnapSelObj(CDrawView*);
   int NearestGridPoint(CDrawView*, CPoint&,CPoint&);
#endif
   void AdjustSelObj(CDrawView*, int, int);
};

class CRectTool : public CDrawTool
{
// Constructors
public:
	CRectTool(DrawShape drawShape);

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
};

class CPolyTool : public CDrawTool
{
// Constructors
public:
	CPolyTool();

// Implementation
	virtual void OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point);
	virtual void OnCancel();

	CDrawPoly* m_pDrawObj;
};

////////////////////////////////////////////////////////////////////////////

#endif // __CPETOOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpedoc.h ===
//--------------------------------------------------------------------------
// CPEDOC.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEDOC_H__
#define __CPEDOC_H__

#define MILIMETERS_TO_HIMETRIC 100        // Conversion factor
#define LE_TO_HM_NUMERATOR   2540         // LOENGLISH to HIMETRIC conversion
#define LE_TO_HM_DENOMINATOR 100
class CDrawView;
class CDrawObj;

class CDrawDoc : public COleDocument
{
public:
    enum {VERSION1,VERSION2,VERSION3,VERSION4, VERSION5};
    int m_iDocVer;
    WORD m_wOrientation;
    WORD m_wPaperSize;
    WORD m_wScale;
    BOOL m_bSerializeFailed ;
    BOOL m_bDataFileUsesAnsi ;

    CObList m_objects;
    CObList  m_previousStateForUndo ;

    virtual ~CDrawDoc();
    static CDrawDoc* GetDoc();
    CObList* GetObjects() { return &m_objects; }
    BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    const CSize& GetSize() const { return m_size; }
    void ComputePageSize();
    int GetMapMode() const { return m_nMapMode; }
    COLORREF GetPaperColor() const { return m_paperColor; }
    CDrawObj* ObjectAt(const CPoint& point);
    void Draw(CDC* pDC, CDrawView* pView, CRect rcClip);
    void Add(CDrawObj* pObj,BOOL bUndo=TRUE);
    void Remove(CDrawObj* pObj=NULL);
    virtual void Serialize(CArchive& ar);   // overridden for document i/o
    BOOL IsOkToClose();
    void schoot_faxprop_toend( WORD res_id );

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
        CSize m_size;
        int m_nMapMode;
        COLORREF m_paperColor;

        virtual BOOL OnNewDocument();
        void DeleteContents();
        CDrawDoc();
        virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
        void OnUpdateFileSave(CCmdUI* pCmdUI);
public:
        void OnFileSave();
        void OnFileSaveAs();
        void CloneObjectsForUndo();
        void SwapListsForUndo();
        virtual BOOL SaveModified(); // return TRUE if ok to continue // override to enforce ".COV" extension
protected:
        void StoreInformationForPrinting( CArchive& ar );
        void SeekPastInformationForPrinting( CArchive& ar );
        DECLARE_DYNCREATE(CDrawDoc)

        //{{AFX_MSG(CDrawDoc)
        afx_msg void OnViewPaperColor();
        afx_msg void OnUpdateMapiMsgNote(CCmdUI* pCmdUI);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//
// Structure of the composite file header.
// These will be used in the Windows API function  PrtCoverPage
//
typedef struct tagCOMPOSITEFILEHEADER {
  BYTE      Signature[20];
  DWORD     EmfSize;
  DWORD     NbrOfTextRecords;
  SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;
//
// Structure of the text box entries in the composite file.  For printing purposes only.
//

typedef struct tagTextBoxW{
  RECT           PositionOfTextBox;
  COLORREF       TextColor;
  UINT           TextAlignment;
  LOGFONTW       FontDefinition;
  WORD           ResourceID ;        // Identifies a FAX PROPERTY.
  DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOXW;

#endif //#ifndef __CPEDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\awcpesup.h ===
/*
 *  AWCPESUP . H
 *
 *      Microsoft AtWork Fax for Windows
 *      Copyright (C) 1993-1994, Microsoft Corporation
 *
 *      Information in this document is subject to change without notice and does
 *      not represent a commitment on the part of Microsoft Corporation.
 */

/*
 * Constants
 */


// Recipient properties
#define CPE_RECIPIENT_NAME              (0x80000001)
#define CPE_RECIPIENT_TITLE             (0x80000002)
#define CPE_RECIPIENT_DEPARTMENT        (0x80000003)
#define CPE_RECIPIENT_OFFICE_LOCATION   (0x80000004)
#define CPE_RECIPIENT_COMPANY           (0x80000005)
#define CPE_RECIPIENT_STREET_ADDRESS    (0x80000006)
#define CPE_RECIPIENT_POST_OFFICE_BOX   (0x80000007)
#define CPE_RECIPIENT_LOCALITY                  (0x80000008)
#define CPE_RECIPIENT_STATE_OR_PROVINCE (0x80000009)
#define CPE_RECIPIENT_POSTAL_CODE               (0x80000010)
#define CPE_RECIPIENT_COUNTRY                   (0x80000011)
#define CPE_RECIPIENT_HOME_PHONE        (0x80000012)
#define CPE_RECIPIENT_WORK_PHONE        (0x80000013)
#define CPE_RECIPIENT_FAX_PHONE         (0x80000014)

// Sender properties
#define CPE_SENDER_NAME                 (0x08000001)
#define CPE_SENDER_TITLE                (0x08000002)
#define CPE_SENDER_DEPARTMENT           (0x08000003)
#define CPE_SENDER_OFFICE_LOCATION      (0x08000004)
#define CPE_SENDER_COMPANY              (0x08000005)
#define CPE_SENDER_ADDRESS              (0x08000006)
#define CPE_SENDER_HOME_PHONE           (0x08000007)
#define CPE_SENDER_WORK_PHONE           (0x08000008)
#define CPE_SENDER_FAX_PHONE            (0x08000009)
#define CPE_RECIPIENT_TO_LIST           (0x0800000A)
#define CPE_RECIPIENT_CC_LIST           (0x0800000B)

// Message related properties
#define CPE_MESSAGE_SUBJECT             (0x00800001)
#define CPE_MESSAGE_SUBMISSION_TIME     (0x00800002)
#define CPE_MESSAGE_BILLING_CODE        (0x00800003)

// Miscellanous message properties
#define CPE_MISC_ATTACHMENT_NAME_LIST   (0x00800004)// ; delimeted list of attachment names
#define CPE_MISC_USER_DEFINED           (0x00800005)// lpvBuf contains LPSPropValue

// Count type properties
#define CPE_COUNT_RECIPIENTS            (0x00800006)// Total count of recipients
#define CPE_COUNT_ATTACHMENTS           (0x00800007)// Total number of attachments
#define CPE_COUNT_PAGES                 (0x00800008)// total number of pages

// Derived property so CPE can get at PR_BODY data
// using the tempfile copy of PR_BODY
#define CPE_MESSAGE_BODY_FILENAME               (0x00800009)// Temp filename for PR_BODY text

// Configuration properties
#define CPE_CONFIG_CPE_TEMPLATE         (0x00080004)
#define CPE_CONFIG_PRINT_DEVICE         (0x00080005)// The device to print to

// Finish modes
#define CPE_FINISH_PAGE                 (0x00008001) //This is used when the
                                                                                                  //CPE finishes a page with out an error
#define CPE_FINISH_ERROR                (0x00008002) // This is used when the
                                                                                                          //CPE encounters an error.
                                                                                                          //This causes the process to end and
                                                                                                          //no further processing should take place

// Finish return values
#define CPE_NEXT_PAGE                   (0x00000001)
#define CPE_DONE                        (0x80000001)
#define CPE_ERROR                       (0x80000002)


//Version info
#define AWCPESUPPORT_VERSION                    (0x00010000)

/*
 * CPESupport Interface
 */
typedef ULONG FAR *LPULONG;

#undef INTERFACE
#define INTERFACE IAWCPESupport

DECLARE_INTERFACE_(IAWCPESupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

        // *** ICPESupport methods ***
        STDMETHOD(GetVersion) (THIS_ LPULONG lpulVer) PURE;
        /* This function is used for version checking,
           it is currently not implemented */

        STDMETHOD(GetProp) (THIS_ ULONG ulProp, LPULONG lpulBufSize, LPVOID lpvBuf) PURE;
        /* This function is used to retrieve properties for the Cover Page.
                ulProp is one of the property constants above.
                lpulBufSize is a pointer to the size of the buffer pointed to by lpvBuf.
                lpvBuf is a buffer where the property value is returned.  If this value is NULL,
                the size needed to hold the property is returned in lpulBufSize.
        */

        STDMETHOD(SetProp) (THIS_ ULONG ulProp, LPVOID lpvBuf) PURE;
        /* This function is used to set properties On the message.
                ulProp is one of the property constants above.
                lpvBuf is the buffer where the property value is.
        */

        STDMETHOD(GetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to retrieve the count of certain attributes, such
           as thee number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is where the count value is returned.
        */

        STDMETHOD(SetCount) (THIS_ ULONG ulCntProp, LPULONG lpulCount) PURE;
        /* This function is used to set the count of certain attributes, such
           as the number of recipients.
           ulCntProp is one of the Count properties listed above.
           lpulCount is the count value.
        */

        STDMETHOD(Finish) (THIS_ ULONG ulMode) PURE;
        /* This function get called when the CPE finishes a page or encounters an error.
           The CPE passes one of the finish codes from above to the function to signal
           which case is finishing, either the page or the CPE encountered an error.
           ulMode is one of the pre defined modes.

           The function can return three modes other than normal errors:
                        CPE_NEXT_PAGE   Finish returns this to signal the CPE to start printing
                                                        the next page.

                        CPE_DONE                Finish returns this to signal the CPE that all of the
                                                        Cover pages ahve been printed.

                        CPE_ERROR               Finish returns this to signal that an error ocurred in
                                                        the transport subsystem.  The CPE should exit with out UI
                                                        and without calling finish again.

        */
};
typedef IAWCPESupport FAR * LPAWCPESUPPORT;

// Service Entry definition
extern "C" {
typedef LONG (WINAPI *AWCPESUPPORTPROC)(DWORD dwSesID, LPAWCPESUPPORT FAR* lppCPESup);
}
typedef AWCPESUPPORTPROC FAR* LPAWCPESUPPORTPROC;



/*
 * GUIDs
 */
DEFINE_GUID(IID_IAWCPESupport, 0xd1ac6c20,0x91d4,0x101b,0xae,0xcc,0x00,0x00,0x0b,0x69,0x1f,0x18);

/*
 * Registry key locations
 */


//
// ISSUE: Please see EdgeBug #12681

// This is the root level key where the CPE specific sub keys are stored
#define CPE_SUPPORT_ROOT_KEY    (TEXT("Software\\Microsoft\\At Work Fax\\Transport Service Provider"))

// This is the location where the CPE puts the command line to used when calling it to print
// cover pages at send time.  The format is total at the CPE's discretion.  The transport will
// look for the string "SESS_ID" and replace it with the current session id.  The session ID is
// a DWORD.
#define CPE_COMMAND_LINE_KEY (TEXT("Cover Page Editor"))

// This key contains the DLL name that the CPE loads to get the Support Object
#define CPE_SUPPORT_DLL_KEY (TEXT("CPE Support DLL"))

//This is the key that holds the name of the function in the Support DLL that is the actual "Service Entry"
#define CPE_SUPPORT_FUNCTION_NAME_KEY (TEXT("CPE Support Function Name"))

// END IDENTICAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpeedt.cpp ===
//---------------------------------------------------------------------------
// cpeedt.cpp - implementation for edit object
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains edit class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

IMPLEMENT_SERIAL(CTextEdit, CEdit, 0)



//---------------------------------------------------------------------------
CTextEdit::CTextEdit()
{
    m_pDrawObj=NULL;

}


//---------------------------------------------------------------------------
void CTextEdit::Serialize(CArchive& ar)
{
    CString szEditText;
    CEdit::Serialize(ar);
    if (ar.IsStoring()) {
       GetWindowText(szEditText);
       ar << szEditText;
    }
    else {
       ar >> szEditText;
       SetWindowText(szEditText);
    }
}



//---------------------------------------------------------------------------
CTextEdit::CTextEdit(CDrawObj* pDrawObj) : m_pDrawObj(pDrawObj)
{
    CDrawView * pView = CDrawView::GetView();
    m_pTextBoxForUndo = pView ? pView->m_pObjInEdit : NULL ;
}


//---------------------------------------------------------------------------
void CTextEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    CDrawView *pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

    if (nChar == VK_TAB)
    {
        pView->OnChar(nChar,nRepCnt,nFlags);
    }
    else{
        CEdit::OnChar(nChar,nRepCnt,nFlags);
    }
#if 0
    if ( m_pTextBoxForUndo )
    {
         m_pTextBoxForUndo->m_bUndoAlignment = FALSE ;
         m_pTextBoxForUndo->m_bUndoFont = FALSE ;
         m_pTextBoxForUndo->m_bUndoTextChange = TRUE ;
    }
#endif
    if ( pView && pView->m_pObjInEdit )
    {
        pView->m_pObjInEdit->m_bUndoAlignment = FALSE ;
        pView->m_pObjInEdit->m_bUndoFont = FALSE ;
        pView->m_pObjInEdit->m_bUndoTextChange = TRUE ;
    }
}


//---------------------------------------------------------------------------
BOOL CTextEdit::PreTranslateMessage(MSG* pMsg)
{
   return CEdit::PreTranslateMessage(pMsg);
}


//---------------------------------------------------------------------------
BOOL CTextEdit::OnEraseBkgnd(CDC* pDC)
{
   return CEdit::OnEraseBkgnd(pDC);
}


//---------------------------------------------------------------------------
void CTextEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
    CDrawView* pView = CDrawView::GetView();
    if (!pView)
    {
        return;
    }

    if (pView->m_bFontChg) 
    {
        pView->OnSelchangeFontSize();
        pView->OnSelchangeFontName();
        pView->m_bFontChg=FALSE;
    }

    CEdit::OnLButtonDown(nFlags, point);
}

//---------------------------------------------------------------------------
void CTextEdit::OnSetFocus(CWnd* pOldWnd)
{
   CEdit::OnSetFocus(pOldWnd);
}



//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CTextEdit, CEdit)
    //{{AFX_MSG_MAP(CTextEdit)
    //}}AFX_MSG_MAP
    ON_WM_CHAR()
    ON_WM_LBUTTONDOWN()
    ON_WM_ERASEBKGND()
    ON_WM_SETFOCUS()
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpetool.cpp ===
//============================================================================
// cpetool.cpp - implementation for drawing tools
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains tool classes for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/7/95       Added check for empty list in CSelectTool::OnLButtonUp to
//                              avoid GPF (bug 2422).
//--------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <math.h>

#define TOOL  0x8000

CPtrList CDrawTool::c_tools;

static CSelectTool selectTool;
static CRectTool lineTool(line);
static CRectTool textTool(text);
static CRectTool faxpropTool(faxprop);
static CRectTool rectTool(rect);
static CRectTool roundRectTool(roundRect);
static CRectTool ellipseTool(ellipse);
static CPolyTool polyTool;

CPoint CDrawTool::c_down;
UINT CDrawTool::c_nDownFlags;
CPoint CDrawTool::c_last;
DrawShape CDrawTool::c_drawShape = select;

CDrawTool::CDrawTool(DrawShape drawShape)
{
   m_drawShape = drawShape;
   c_tools.AddTail(this);
   m_bMoveCurSet=FALSE;
}

CDrawTool* CDrawTool::FindTool(DrawShape drawShape)
{
   POSITION pos = c_tools.GetHeadPosition();
   while (pos != NULL) {
        CDrawTool* pTool = (CDrawTool*)c_tools.GetNext(pos);
        if (pTool->m_drawShape == drawShape)
                return pTool;
   }

   return NULL;
}

void CDrawTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = pView->GetDocument()->GetInPlaceActiveItem(pView);
   if (pActiveItem != NULL) {
        pActiveItem->Close();
        ASSERT(pView->GetDocument()->GetInPlaceActiveItem(pView) == NULL);
   }

   pView->SetCapture();
   TRACE(TEXT("AWCPE: mouse capture set\n"));
   c_nDownFlags = nFlags;

   //TRACE( "c_down =%d,%d\n", c_down.x, c_down.y );
   c_down = point;

   c_last = point;
}

void CDrawTool::OnLButtonDblClk(CDrawView* , UINT , const CPoint& )
{
}

void CDrawTool::OnLButtonUp(CDrawView* pView, UINT , const CPoint& point)
{
   ReleaseCapture();
   TRACE(TEXT("AWCPE: mouse capture released\n"));

   if (point == c_down) {
      c_drawShape = select;
   }
}

void CDrawTool::OnMouseMove(CDrawView* , UINT , const CPoint& point)
{
   c_last = point;
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));
   m_bMoveCurSet=FALSE;
}

void CDrawTool::OnCancel()
{
   c_drawShape = select;
}

////////////////////////////////////////////////////////////////////////////
// CResizeTool

enum SelectMode
{
   none,
   netSelect,
   move,
   size
};

SelectMode selectMode = none;
int nDragHandle;

CPoint lastPoint;

CSelectTool::CSelectTool()
        : CDrawTool(select)
{
    m_bClicktoMove=FALSE;
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnArrowKey(CDrawView* pView, UINT nChar, UINT nRepCnt, UINT nFlags)
{
   TRACE(TEXT("CSelectTool::OnArrowKey\n"));

   CPoint delta;
   if (nRepCnt>1)
      nRepCnt*=5;

   if (nChar == VK_LEFT) {
      delta.x=-1*((int)nRepCnt);
      delta.y=0;
   }
   if (nChar == VK_RIGHT) {
      delta.x=nRepCnt;
      delta.y=0;
   }
   if (nChar == VK_UP) {
      delta.x=0;
      delta.y=nRepCnt;
   }
   if (nChar == VK_DOWN) {
      delta.x=0;
      delta.y=-1*((int)nRepCnt);
   }

   POSITION pos = pView->m_selection.GetHeadPosition();
   CDrawDoc* pDoc = CDrawDoc::GetDoc();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   CRect position;
   CDrawObj* pObj=NULL;
   while (pos != NULL)
   {
      pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
      position = pObj->m_position + delta;
      int r = (position.right > position.left) ? position.right : position.left;
      int l = (position.right > position.left) ? position.left : position.right;
      int t = (position.top > position.bottom) ? position.top : position.bottom;
      int b = (position.top > position.bottom) ? position.bottom : position.top;

      if (l > rect.left && r < rect.right && t < rect.top && b > rect.bottom )
         pObj->MoveTo(position, pView);
   }

   if(pObj)
   {
        CRect rc = pObj->m_position;
        pView->DocToClient(rc);
        pView->SetCaretPos(rc.CenterPoint());
   }
}


//---------------------------------------------------------------------------------------
void CSelectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    CPoint local = point;
    pView->ClientToDoc(local);


    CDrawObj* pObj;
    selectMode = none;

    // Check for resizing (only allowed on single selections)
    if (pView->m_selection.GetCount() == 1)
    {
        pObj = (CDrawObj*)pView->m_selection.GetHead();
        nDragHandle = pObj->HitTest(local, pView, TRUE);
        if (nDragHandle != 0)
        {
            selectMode = size;
        }
    }

    // See if the click was on an object, select and start move if so
    if (selectMode == none)
    {

       pObj = pView->GetDocument()->ObjectAt(local);

       if (pObj != NULL)
       {
            selectMode = move;

            if (pView->IsSelected(pObj))        //check to activate edit window for edit object
            {
                if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
                   if (((CDrawText*)pObj)->HitTestEdit(pView,local))
                      if (((CDrawText*)pObj)->ShowEditWnd(pView))
                         return;
            }

            if( (nFlags & MK_SHIFT)&&(nFlags & MK_CONTROL) )
            {
                // Shft+Ctrl+Click clones the selection...
                pView->CloneSelection();
            }
            else
            {
                if (!pView->IsSelected(pObj) || ((nFlags & MK_CONTROL) != 0) )
                {
                    if ( (nFlags & MK_CONTROL) == 0)
                    {
                          pView->Select(NULL);
                    }
                    pView->Select(pObj, (nFlags & MK_CONTROL) != 0);
                    pView->UpdateStatusBar();
                    pView->UpdateStyleBar();
                }
                if (!pView->IsSelected(pObj))
                {
                    selectMode=none;
                }
           }
        }
    }

    if (selectMode==move || selectMode==size)
    {
        m_bClicktoMove=TRUE;
    }

        // Click on background, start a net-selection
    if (selectMode == none)
    {

        if ((nFlags & MK_CONTROL) == 0)
             pView->Select(NULL);

        selectMode = netSelect;

        CClientDC dc(pView);
        CRect rect(point.x, point.y, point.x, point.y);
        rect.NormalizeRect();
        dc.DrawFocusRect(rect);
    }

    lastPoint = local;

    CDrawTool::OnLButtonDown(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if ((nFlags & MK_SHIFT) != 0) {
        // Shift+DblClk deselects object...
        CPoint local = point;
        pView->ClientToDoc(local);
        CDrawObj* pObj = pView->GetDocument()->ObjectAt(local);
        if (pObj != NULL)
                pView->Deselect(pObj);
   }
   else {
        // "Normal" DblClk, or OLE server...
        if (pView->m_selection.GetCount() == 1)
                ((CDrawObj*)pView->m_selection.GetHead())->OnDblClk(pView);
   }

   CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}


//---------------------------------------------------------------------------------
void CSelectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   m_bClicktoMove=FALSE;

   if (pView->GetCapture() == pView) {
        if (selectMode == netSelect) {
            CClientDC dc(pView);
            CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
            rect.NormalizeRect();
            dc.DrawFocusRect(rect);

            pView->SelectWithinRect(rect, TRUE);
        }
        else if (selectMode != none) {
                 pView->GetDocument()->UpdateAllViews(pView);
        }
   }

#ifdef GRID
   if (pView->m_bSnapToGrid && (selectMode==move || selectMode==size))
      CheckSnapSelObj(pView);
#endif


   if( (selectMode==size) &&                                       // if we're sizing AND
           (!pView->m_selection.IsEmpty()) )// something got picked
                {                                                                                  // then do pObj
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetHead();
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->SnapToFont();
                }

   }


   CDrawTool::OnLButtonUp(pView, nFlags, point);
}


#ifdef GRID
//---------------------------------------------------------------------------------
void CSelectTool::CheckSnapSelObj(CDrawView* pView)
{
   CRect r(0,0,0,0);
   CRect temp;
   int iOffsetX=0;
   int iOffsetY=0;

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
     CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
     temp = pObj->m_position;
     temp.NormalizeRect();
     r |= temp;
   }
   if (r.TopLeft().y < r.BottomRight().y) {
       int temp = r.TopLeft().y;
       r.TopLeft().y=r.BottomRight().y;
           r.BottomRight().y=temp;
   }

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

     //first check Top and left
   for (int y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.TopLeft().y > (y-8) && r.TopLeft().y < (y+8)) {
         iOffsetY=y-r.TopLeft().y;
         break;
      }

   for (int x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.TopLeft().x < (x+8) && r.TopLeft().x > (x-8)) {
         iOffsetX=x-r.TopLeft().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0) {
      AdjustSelObj(pView,iOffsetX,iOffsetY);
      return;
   }

   iOffsetX=iOffsetY=0;

     //if top and left dont need snapping, check right and bottom
   for (y = rect.top-pView->m_iGridSize; y > rect.bottom; y -= pView->m_iGridSize)  //Top of object
      if (r.BottomRight().y > (y-8) && r.BottomRight().y < (y+8)) {
         iOffsetY=y-r.BottomRight().y;
         break;
      }

   for (x = rect.left + pView->m_iGridSize; x < rect.right; x += pView->m_iGridSize)  //Left of object
      if (r.BottomRight().x < (x+8) && r.BottomRight().x > (x-8)) {
         iOffsetX=x-r.BottomRight().x;
         break;
      }

   if (iOffsetX !=0 || iOffsetY != 0)
      AdjustSelObj(pView,iOffsetX,iOffsetY);
}
#endif


//---------------------------------------------------------------------------------
void CSelectTool::AdjustSelObj(CDrawView* pView, int iOffsetX, int iOffsetY)
{
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);
        CRect position = pObj->m_position;
        position.OffsetRect(iOffsetX,iOffsetY);
        pObj->MoveTo(position, pView);
   }
}


#ifdef GRID
//---------------------------------------------------------------------------------
int CSelectTool::NearestGridPoint(CDrawView* pView, CPoint& local,CPoint& ngp)
{
   CSize delta;
   CPoint upL,upR,loL,loR;
   int iDistance;
   int iHold;

   CDrawDoc* pDoc = pView->GetDocument();
   CRect rect;
   rect.left = -pDoc->GetSize().cx / 2;
   rect.top = pDoc->GetSize().cy / 2;
   rect.right = rect.left + pDoc->GetSize().cx;
   rect.bottom = rect.top - pDoc->GetSize().cy;

   for (int y = rect.top-20; y > rect.bottom; y -= 20)   //find y bound
      if (local.y > y) {
         upL.y=y+20;
         upR.y=y+20;
         loL.y=y;
         loR.y=y;
         break;
      }
   for (int x = rect.left + 20; x < rect.right; x += 20)  //find x bound
      if (local.x < x) {
         upL.x=x-20;
         loL.x=x-20;
         upR.x=x;
         loR.x=x;
         break;
      }

   delta=(CSize)(local - upR);   //get distance to upR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   iHold=iDistance;
   ngp=upR;

   delta=(CSize)(local - loR);   //get distance to loR point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loR;
   }
   delta=(CSize)(local - upL);   //get distance to upL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=upL;
   }
   delta=(CSize)(local - loL);   //get distance to loL point
   iDistance = (int)sqrt(pow(delta.cx,2)+pow(delta.cy,2));
   if (iDistance<iHold) {
      iHold=iDistance;
      ngp=loL;
   }

   return iHold;
}
#endif



//---------------------------------------------------------------------------------
void CSelectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   if (pView->GetCapture() != pView) {   //if not in capture, set cursor
      CDrawObj* pObj;
      CPoint local=point;
      pView->ClientToDoc(local);

      if (c_drawShape == select && pView->m_selection.GetCount() == 1) {
               //check for handle cursor change
          pObj = (CDrawObj*)pView->m_selection.GetHead();
          int nHandle = pObj->HitTest(local, pView, TRUE);
          if (nHandle != 0) {
             SetCursor(pObj->GetHandleCursor(nHandle));
             return; // bypass CDrawTool
          }
      }
               //check for move cursor change
      if (c_drawShape == select) {
              pObj=pView->GetDocument()->ObjectAt(local);
          if (pObj != NULL) {
             if (pView->m_selection.GetCount() == 1 && pView->IsSelected(pObj) &&
                    pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) ) {
                if ( !((CDrawText*)pObj)->HitTestEdit(pView,local) ) {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
             else {
                if ( pView->IsSelected(pObj)) {
                   SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                   m_bMoveCurSet=TRUE;
                   return; // bypass CDrawTool
                }
             }
          }
      }

      if (c_drawShape == select)
         CDrawTool::OnMouseMove(pView, nFlags, point);

      return;
   }

   // move or resize, add to undo collection

    if (m_bClicktoMove && pView->m_selection.GetCount() > 0) {

        pView->SaveStateForUndo();
        m_bClicktoMove=FALSE;
   }


   if (selectMode == netSelect) {     //do net selection drawing
      CClientDC dc(pView);
      CRect rect(c_down.x, c_down.y, c_last.x, c_last.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);
      rect.SetRect(c_down.x, c_down.y, point.x, point.y);
      rect.NormalizeRect();
      dc.DrawFocusRect(rect);

      CDrawTool::OnMouseMove(pView, nFlags, point);
      return;
   }

   CPoint local = point;
   pView->ClientToDoc(local);
   CPoint delta;
   delta = (CPoint)(local - lastPoint);

   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
      CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

      CRect position = pObj->m_position;

      if (selectMode == move) {
        position += delta;
        pObj->MoveTo(position, pView);
      }
      else
      if (nDragHandle != 0) {

                UINT iShift=0;

//              if (pObj->IsKindOf(RUNTIME_CLASS(CDrawLine))) {
//              }

        if (nFlags & MK_SHIFT)
                   iShift |= SHIFT_DRAW;

            if (nFlags & TOOL)
                   iShift |= SHIFT_TOOL;

        pObj->MoveHandleTo(nDragHandle, local, pView, iShift);
      }
   }

   lastPoint = local;

   c_last = point;
   if (selectMode == size && c_drawShape == select) {
      SetCursor(((CDrawObj*)pView->m_selection.GetHead())->GetHandleCursor(nDragHandle));
      return; // bypass CDrawTool
   }
   else   //set cursor if in move mode
      if (selectMode == move && c_drawShape == select) {
             if (!m_bMoveCurSet) {
            SetCursor( ((CDrawApp*)AfxGetApp())->m_hMoveCursor );
                        m_bMoveCurSet=TRUE;
                 }
         return; // bypass CDrawTool
      }

   if (c_drawShape == select)
        CDrawTool::OnMouseMove(pView, nFlags, point);
}

////////////////////////////////////////////////////////////////////////////
CRectTool::CRectTool(DrawShape drawShape)
        : CDrawTool(drawShape)
{
}

void CRectTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDown(pView, nFlags, point);

     CPoint local = point;
     pView->ClientToDoc(local);

     CDrawObj* pObj;

     switch (m_drawShape) {
     default:
        ASSERT(FALSE); // unsuported shape!

     case rect:
        pObj = new CDrawRect(CRect(local, CSize(0, 0)));
        break;

     case text:
        pObj = new CDrawText(CRect(local, CSize(0, 0)));
        break;

//     case faxprop:
//        pObj = new CFaxProp(CRect(local, CSize(0, 0)));
//      break;

     case roundRect:
        pObj = new CDrawRoundRect(CRect(local, CSize(0, 0)));
        break;

     case ellipse:
        pObj = new CDrawEllipse(CRect(local, CSize(0, 0)));
        break;

     case line:
        pObj = new CDrawLine(CRect(local, CSize(0, 0)));
        break;
     }

     pView->GetDocument()->Add(pObj);

     pView->Select(NULL);
     pView->Select(pObj);
         pView->UpdateStatusBar();
         pView->UpdateStyleBar();

     selectMode = size;
     nDragHandle = 1;
     lastPoint = local;
}

void CRectTool::OnLButtonDblClk(CDrawView* pView, UINT nFlags, const CPoint& point)
{
     CDrawTool::OnLButtonDblClk(pView, nFlags, point);
}

void CRectTool::OnLButtonUp(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   BOOL bObj=TRUE;
   CDrawObj* pObj;

   if (point == c_down) {
        // Don't create empty objects...
        pObj = (CDrawObj*)pView->m_selection.GetTail();
        pView->GetDocument()->Remove(pObj);
//      delete pObj;
        selectTool.OnLButtonDown(pView, nFlags, point); // try a select!
        bObj=FALSE;
   }

   selectTool.OnLButtonUp(pView, nFlags, point);

   if (bObj) {
      if (m_drawShape==text) {
         pObj = (CDrawObj*) pView->m_selection.GetTail();
         if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->ShowEditWnd(pView);
            pView->Select(NULL, FALSE, FALSE);
         }
      }
   }
}

void CRectTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   //TRACE( "point =%d,%d\n", point.x, point.y );
   SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
   selectTool.OnMouseMove(pView, nFlags | TOOL, point);
}


////////////////////////////////////////////////////////////////////////////
// CPolyTool

CPolyTool::CPolyTool()
        : CDrawTool(poly)
{
   m_pDrawObj = NULL;
}

void CPolyTool::OnLButtonDown(CDrawView* pView, UINT nFlags, const CPoint& point)
{
   CDrawTool::OnLButtonDown(pView, nFlags, point);

   CPoint local = point;
   pView->ClientToDoc(local);

   if (m_pDrawObj == NULL) {
          pView->SetCapture();

          m_pDrawObj = new CDrawPoly(CRect(local, CSize(0, 0)));
          pView->GetDocument()->Add(m_pDrawObj);
          pView->Select(NULL);
          pView->Select(m_pDrawObj);
      m_pDrawObj->AddPoint(local, pView);
   }
   else if (local == m_pDrawObj->m_points[0]) {
        // Stop when the first point is repeated...
        ReleaseCapture();
        m_pDrawObj->m_nPoints -= 1;
        if (m_pDrawObj->m_nPoints < 2) {
                delete m_pDrawObj;
        }
        else {
                m_pDrawObj->Invalidate();
        }
        m_pDrawObj = NULL;
        c_drawShape = select;
        return;
   }

   local.x += 1; // adjacent points can't be the same!
   m_pDrawObj->AddPoint(local, pView);

   selectMode = size;
   nDragHandle = m_pDrawObj->GetHandleCount();
   lastPoint = local;
}

void CPolyTool::OnLButtonUp(CDrawView* , UINT , const CPoint& )
{
   // Don't release capture yet!
}

void CPolyTool::OnMouseMove(CDrawView* pView, UINT nFlags, const CPoint& point)
{
    if (m_pDrawObj != NULL && (nFlags & MK_LBUTTON) != 0) {
       CPoint local = point;
       pView->ClientToDoc(local);
       m_pDrawObj->AddPoint(local);
       nDragHandle = m_pDrawObj->GetHandleCount();
       lastPoint = local;
       c_last = point;
       SetCursor(AfxGetApp()->LoadCursor(IDC_PENCIL));
    }
    else {
       SetCursor(AfxGetApp()->LoadStandardCursor(IDC_CROSS));
       selectTool.OnMouseMove(pView, nFlags, point);
    }
}

void CPolyTool::OnLButtonDblClk(CDrawView* pView, UINT , const CPoint& )
{
    ReleaseCapture();

    int nPoints = m_pDrawObj->m_nPoints;
    if (nPoints > 2 &&
        (m_pDrawObj->m_points[nPoints - 1] == m_pDrawObj->m_points[nPoints - 2] ||
        m_pDrawObj->m_points[nPoints - 1].x - 1 == m_pDrawObj->m_points[nPoints - 2].x &&
        m_pDrawObj->m_points[nPoints - 1].y == m_pDrawObj->m_points[nPoints - 2].y)) {
        // Nuke the last point if it's the same as the next to last...
        m_pDrawObj->m_nPoints -= 1;
        m_pDrawObj->Invalidate();
    }

    m_pDrawObj = NULL;
    c_drawShape = select;

    //
    // As part of the re-design for fixing bug # 39665,
    // put the "Ready" message back on the status bar.
    // Fix by a-juliar, 05-24-96
    //

    CString sz ;
    sz.LoadString( AFX_IDS_IDLEMESSAGE );
    CMainFrame* pFrame = (CMainFrame*) AfxGetApp()->m_pMainWnd;
    CStatusBar* pStatus = &pFrame->m_wndStatusBar;
    pStatus->SetPaneText( 0, sz );
}

void CPolyTool::OnCancel()
{
    CDrawTool::OnCancel();

    m_pDrawObj = NULL;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpevw.h ===
//--------------------------------------------------------------------------
// cpevw.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEVW_H__
#define __CPEVW_H__


// Hints for UpdateAllViews/OnUpdate
#define HINT_UPDATE_WINDOW      0
#define HINT_UPDATE_DRAWOBJ     1
#define HINT_UPDATE_SELECTION   2
#define HINT_DELETE_SELECTION   3
#define HINT_UPDATE_OLE_ITEMS   4


class CDrawObj;
class CDrawText;
class CDrawApp;
class CDrawDoc;
class CMainFrame;

typedef enum {GRID_SMALL=10,GRID_MEDIUM=20,GRID_LARGE=50} eGridSize;     //grid sizes, in LU

class CSortedObList : public CObList
{
public:
   CSortedObList() {};
   CSortedObList& operator=(CObList&);
   void SortToLeft();
   void SortToBottom();
private:
   void swap(INT_PTR i, INT_PTR j);
};


class CDrawView : public CScrollView
{
public:
    BOOL m_bShiftSignal;
    BOOL m_bKU;
    CPen m_penDot;
    CPen m_penSolid;
    BOOL m_bFontChg;
    BOOL m_bHighContrast;
    CDrawText* m_pObjInEdit;

protected:
    BOOL m_bCanUndo ;
public:
    BOOL CanUndo() { return m_bCanUndo ; }
    void DisableUndo(){ m_bCanUndo = FALSE ; }
    void SaveStateForUndo();
    static void FreeObjectsMemory( CObList * pObList );

    CMainFrame* GetFrame() {return ((CMainFrame*)AfxGetMainWnd());}
    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
    static CDrawView* GetView();
    CDrawDoc* GetDocument() { return (CDrawDoc*)m_pDocument; }
    void SetPageSize(CSize size);
    CRect GetInitialPosition();
    void DoPrepareDC(CDC* pDC);
    void TrackObjectMenu(CPoint&);
    void TrackViewMenu(CPoint&);
    void NormalizeObjs();

    void DocToClient(CRect& rect, CDC* pDC=NULL);
    void DocToClient(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CPoint& point, CDC* pDC=NULL);
    void ClientToDoc(CRect& rect, CDC* pDC=NULL);

    void Select(CDrawObj* pObj, BOOL bShift = FALSE, BOOL bCheckEdit=TRUE);
    void SelectWithinRect(CRect rect, BOOL bAdd = FALSE);
    void Deselect(CDrawObj* pObj);
    void CloneSelection();
    void CreateFaxProp(WORD wResourceid);
    void CreateFaxText();
    void FindLocation(CRect& objrect);
    void UpdateActiveItem();
    void Remove(CDrawObj* pObj);
    void PasteNative(COleDataObject& dataObject);
    void PasteEmbedded(COleDataObject& dataObject);

    BOOL IsHighContrast();

    virtual ~CDrawView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    void UpdateStatusBar();
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    void DrawGrid(CDC* pDC);

    static CLIPFORMAT m_cfDraw; // custom clipboard format

    CObList m_selection;
    BOOL m_bGridLines;
    BOOL m_bActive; // is the view active?

protected:
    CDrawView();
    BOOL m_bBold;
    BOOL m_bItalic;
    BOOL m_bUnderline;
    DWORD m_dwEfcFields ;

    DECLARE_DYNCREATE(CDrawView)
    virtual void OnInitialUpdate(); // called first time after construct
    int GetPointSize(CDrawText&);
    CSize ComputeScrollSize(CSize size) ;
    void CheckStyleBar(BOOL, BOOL, BOOL, BOOL, BOOL, BOOL);
    void NormalizeRect(CRect& rc);
    void UpdateStyleBar(CObList* pObList=NULL,CDrawText* p=NULL);

        // Printing support

    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

        // OLE Container support
public:
    afx_msg void OnChar(UINT, UINT, UINT);
    virtual BOOL IsSelected(const CObject* pDocItem) const;
    afx_msg void OnSelchangeFontName();
    afx_msg void OnSelchangeFontSize();

    void OnSelChangeFontName(CObList* pObList=NULL,CDrawText* p=NULL);
    void OnSelChangeFontSize(CObList* pObList=NULL,CDrawText* p=NULL);

    void make_extranote( CDC *pdc );
    //void make_extranote_and_count_pages( BOOL do_transform );

// Generated message map functions
protected:
    void ChgTextAlignment(LONG lstyle);

    //{{AFX_MSG(CDrawView)

    afx_msg void OnSysColorChange();
    afx_msg void OnInsertObject();
    afx_msg void OnCancelEdit();
    afx_msg void OnContextMenu(CWnd *, CPoint point);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg void OnFilePrintPreview();
    afx_msg void OnEditChange();
    afx_msg void OnMAPIRecipName();
    afx_msg void OnMAPIRecipFaxNum();
    afx_msg void OnMAPIRecipCompany();
    afx_msg void OnMAPIRecipAddress();
    afx_msg void OnMAPIRecipCity();
    afx_msg void OnMAPIRecipState();
    afx_msg void OnMAPIRecipPOBox();
    afx_msg void OnMAPIRecipZipCode();
    afx_msg void OnMAPIRecipCountry();
    afx_msg void OnMAPIRecipTitle();
    afx_msg void OnMAPIRecipDept();
    afx_msg void OnMAPIRecipOfficeLoc();
    afx_msg void OnMAPIRecipHMTeleNum();
    afx_msg void OnMAPIRecipOFTeleNum();
    afx_msg void OnMAPIRecipToList();
    afx_msg void OnMAPIRecipCCList();
    afx_msg void OnMAPISenderName();
    afx_msg void OnMAPISenderFaxNum();
    afx_msg void OnMAPISenderCompany();
    afx_msg void OnMAPISenderAddress();
    afx_msg void OnMAPISenderTitle();
    afx_msg void OnMAPISenderDept();
    afx_msg void OnMAPISenderOfficeLoc();
    afx_msg void OnMAPISenderHMTeleNum();
    afx_msg void OnMAPISenderOFTeleNum();
    afx_msg void OnMAPIMsgSubject();
    afx_msg void OnMAPIMsgTimeSent();
    afx_msg void OnMAPIMsgNumPages();
    afx_msg void OnMAPIMsgAttach();
    afx_msg void OnMAPIMsgBillCode();
    afx_msg void OnMAPIMsgFaxText();
    afx_msg void OnFont();
    afx_msg void OnDrawSelect();
    afx_msg void OnDrawRoundRect();
    afx_msg void OnDrawRect();
    afx_msg void OnDrawText();
    afx_msg void OnDrawLine();
    afx_msg void OnDrawEllipse();
    afx_msg void OnEditChangeFont();
    afx_msg void OnSelEndOKFontSize();
    afx_msg void OnStyleBold();
    afx_msg void OnStyleItalic();
    afx_msg void OnStyleUnderline();
    afx_msg void OnStyleLeft();
    afx_msg void OnStyleCentered();
    afx_msg void OnStyleRight();
    afx_msg void OnUpdatePosStatusBar(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawEllipse(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawLine(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawRoundRect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDrawSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSingleSelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoreThanOne(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMove(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFaxText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign(CCmdUI* pCmdUI);
    afx_msg void OnUpdateAlign3(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditClear();
    afx_msg void OnEditUndo();
    afx_msg void OnUpdateAnySelect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnDrawPolygon();
    afx_msg void OnUpdateDrawPolygon(CCmdUI* pCmdUI);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnAlignLeft();
    afx_msg void OnAlignRight();
    afx_msg void OnAlignTop();
    afx_msg void OnAlignBottom();
    afx_msg void OnAlignHorzCenter();
    afx_msg void OnAlignVertCenter();
    afx_msg void OnSpaceAcross();
    afx_msg void OnSpaceDown();
    afx_msg void OnCenterWidth();
    afx_msg void OnCenterHeight();
    afx_msg void OnViewGridLines();
    afx_msg void OnUpdateViewGridLines(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFont(CCmdUI* pCmdUI);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnObjectMoveBack();
    afx_msg void OnObjectMoveForward();
    afx_msg void OnObjectMoveToBack();
    afx_msg void OnObjectMoveToFront();
    afx_msg void OnViewPaperColor();
    afx_msg void OnDrawBitmap();
    afx_msg void OnUpdateDrawBitmap(CCmdUI* pCmdUI);
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnEditCut();
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnFilePrint();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnViewShowObjects();
    afx_msg void OnUpdateViewShowObjects(CCmdUI* pCmdUI);
    afx_msg void OnEditProperties();
    afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
    afx_msg void OnDestroy();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnMapiMsgNote();
    afx_msg void OnUpdateToList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateCcList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCompany(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecAddress(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCity(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecState(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecZipCode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecCountry(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecTitle(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecDept(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficeLoc(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecHomePhone(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRecOfficePhone(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


#endif //#ifndef __CPEVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\faxprop.cpp ===
//---------------------------------------------------------------------------
// faxprop.cpp -
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains dictionary for fax properties for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 3/8/95       Added stuff for handling notes on cpe
// 3/21/95      Added stuff for updating pages-sent property with notes
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#define PROP_LENGTH_ADJUSTMENT 7  // 4 wasn't enough.  Needed because some characters are wider than average.

CMapWordToPtr CFaxPropMap::m_PropMap;


CProp::CProp(
    WORD wR_PROP,
    WORD wPropDefLen,
    WORD wPropDefLines,
    WORD wR_CAPT,
    ULONG lPropIndex
    ) : m_lPropIndex(lPropIndex)
{
    m_wR_PROP=wR_PROP;
    m_szPropName.LoadString(wR_PROP);
    m_wR_CAPT=wR_CAPT;
    m_szCaption.LoadString(wR_CAPT);
    //
    // m_wPropDefLen must exceed # of chars in m_szPropName in ALL LANGUAGES. a-juliar, 9-10-96
    //
    int StringLength = max( 0, m_szPropName.GetLength() + PROP_LENGTH_ADJUSTMENT ) ;
    m_wPropDefLen = max( (WORD)StringLength, wPropDefLen ) ;
    m_wPropDefLines=wPropDefLines;

    CFaxPropMap::m_PropMap[m_wR_PROP]=this;
}


//----------------------------------------------------------------------------
void CFaxPropMap::GetCaption(WORD propid, CString& szCaption)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetCaption:  property not found\n"));
      return;
   }

   szCaption = ((CProp*)pProp)->m_szCaption;
}


//----------------------------------------------------------------------------
//used to retrieve either a value or the property name
//----------------------------------------------------------------------------
void CFaxPropMap::GetPropString(WORD propid, CString& szPropValue)
{
   SCODE sc;
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      szPropValue = _T("");
      TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property id not found in table\n"));
      return;
   }

   CProp* pCProp=(CProp*)pProp;
   if (pCProp==NULL) {
       TRACE(TEXT("AWCPE.FAXPROP.GetPropString:  property key not found in dictionary\n"));
       szPropValue=_T("");
       return;
   }

   if ( (theApp.m_dwSesID!=0) && theApp.m_pIawcpe ) {
       ULONG temp= pCProp->m_wPropDefLines*pCProp->m_wPropDefLen + 1;
           ULONG lLen=0;
           WORD wtemp;

        if( propid == IDS_PROP_MS_NOTE )
                        {
                        szPropValue = _T("");
                        get_message_note();
                        return;
                        }

       if (propid!=IDS_PROP_MS_NOPG) {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, NULL);    //get length of property
          if (sc != S_OK) {
             TRACE(TEXT("AWCPE: GetPropString--unable to fetch length; GetProp != S_OK(%lx); prop:'%#8x'"),sc,pCProp->m_lPropIndex);
             TRACE1("; caption: '%s'",pCProp->m_szCaption);
                 TRACE1("; defaulting to length: '%i'\n",temp);
                 lLen=temp;
              }
          else
             if (lLen<=0 || lLen>10*temp) {
                    TRACE1("AWCPE: GetPropString--unreasonable length from GetProp(), prop: '%#8x'",pCProp->m_lPropIndex);
                TRACE1("; caption: '%s'",pCProp->m_szCaption);
                TRACE1("; fetched: '%i'",lLen);
                    TRACE1("; defaulting to length: '%i'\n",temp);
                    lLen=temp;
                 }
           }
       else {
              lLen=10;
           }

       LPTSTR BASED_CODE szTemp = ::new TCHAR[lLen];

       if( propid == IDS_PROP_MS_NOPG )
                {
                // IDS_PROP_MS_NOPG does not count the coverpage
                sc = theApp.m_pIawcpe->
                                GetProp(pCProp->m_lPropIndex, &lLen, (void*)&wtemp);

                wtemp += 1; // count the cover page
                wsprintf(szTemp,TEXT("%i"), wtemp );
                }
           else
        {
          sc = theApp.m_pIawcpe->GetProp(pCProp->m_lPropIndex, &lLen, szTemp);
                }

       if (sc !=S_OK) {    //failed to get property from transport interface
          szPropValue = _T("");
              TRACE1("AWCPE: GetPropString--unable to fetch value (prop:'%#8x')",pCProp->m_lPropIndex);
          TRACE(TEXT("; GetProp != S_OK; defaulting to blank property\n"));
       }
           else {
           szPropValue = szTemp;
           TRACE1("AWCPE: (%i",propid);
           TRACE1(",%#8x)\t",pCProp->m_lPropIndex);
           TRACE1("caption: '%s'\t",pCProp->m_szCaption);
               TRACE1("value: '%s'\n",szPropValue);
           }

           if (szTemp!=NULL)
              ::delete [] szTemp;
   }
   else {
       szPropValue = pCProp->m_szPropName;
   }

}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLines(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetNumLines:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLines;
}


//----------------------------------------------------------------------------
WORD CFaxPropMap::GetPropDefLength(WORD propid)
{
   void* pProp;

   if (!m_PropMap.Lookup(propid,pProp)) {
      TRACE(TEXT("AWCPE.FAXPROP.GetPropLength:  property not found\n"));
      return 0;
   }

   return ((CProp*)pProp)->m_wPropDefLen;
}




//----------------------------------------------------------------------------
void  CFaxPropMap::get_message_note( void )
        {

        if( !theApp.m_note_wasread )
                theApp.read_note();


        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpeobj.cpp ===
///============================================================================
// cpeobj.cpp - implementation for drawing objects
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description: 	 Contains drawing objects for cover page editor
// Original author:  Steve Burkett
// Date written:	 6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/14/95		Added check for too thin rects in CDrawLine::MoveHandleTo
// 3/8			Added stuff for handling notes on cpe
// 3/10 		commented out rect.bottom+=2 in CDrawText::SnapToFont
// 3/22 		Fixed char set bug for editboxes
//
//============================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "richedit.h"
#include <windows.h>
#include <windowsx.h>
#include <math.h>

IMPLEMENT_SERIAL(CDrawObj, CObject, 0)
IMPLEMENT_SERIAL(CDrawRect, CDrawObj, 0)
IMPLEMENT_SERIAL(CFaxText, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawText, CDrawRect, 0)
IMPLEMENT_SERIAL(CFaxProp, CDrawText, 0)
IMPLEMENT_SERIAL(CDrawLine, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawRoundRect, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawEllipse, CDrawRect, 0)
IMPLEMENT_SERIAL(CDrawPoly, CDrawObj, 0)
IMPLEMENT_SERIAL(CDrawOleObj, CDrawObj, 0)


// prototype
DWORD CopyTLogFontToWLogFont(IN const LOGFONT & lfSource,OUT LOGFONTW & lfDestW);

//
// Window style translation
//
DWORD DTStyleToESStyle(DWORD dwDTStyle);
DWORD DTStyleToEXStyle(DWORD dwDTStyle);

DWORD
CopyWLogFontToTLogFont(
			IN const LOGFONTW & lfSourceW,
			OUT 	 LOGFONT & lfDest)
{
/*++
Routine Description:

	This fuction copies a LogFont structure from UNICODE format
	to T format.

Arguments:
	
	  lfSourceW - reference to input UNICODE LongFont structure
	  lfDest - reference to output LongFont structure

Return Value:

	WINAPI last error

--*/

	lfDest.lfHeight = lfSourceW.lfHeight ;
	lfDest.lfWidth = lfSourceW.lfWidth ;
	lfDest.lfEscapement = lfSourceW.lfEscapement ;
	lfDest.lfOrientation = lfSourceW.lfOrientation ;
	lfDest.lfWeight = lfSourceW.lfWeight ;
	lfDest.lfItalic = lfSourceW.lfItalic ;
	lfDest.lfUnderline = lfSourceW.lfUnderline ;
	lfDest.lfStrikeOut = lfSourceW.lfStrikeOut ;
	lfDest.lfCharSet = lfSourceW.lfCharSet ;
	lfDest.lfOutPrecision = lfSourceW.lfOutPrecision ;
	lfDest.lfClipPrecision = lfSourceW.lfClipPrecision ;
	lfDest.lfQuality = lfSourceW.lfQuality ;
	lfDest.lfPitchAndFamily = lfSourceW.lfPitchAndFamily ;

	SetLastError(0);
#ifdef UNICODE
	wcscpy( lfDest.lfFaceName,lfSourceW.lfFaceName);
#else
	int iCount;
	iCount = WideCharToMultiByte(
				CP_ACP,
				0,
				lfSourceW.lfFaceName,
				-1,
				lfDest.lfFaceName,
				LF_FACESIZE,
				NULL,
				NULL
				);

	if (!iCount)
	{
		TRACE( TEXT("Failed to covert string to ANSI"));
		return GetLastError();
	}
#endif
	return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------
BOOL CALLBACK 
get_fontdata( 
	ENUMLOGFONT* lpnlf,
	NEWTEXTMETRIC* lpntm,
	int iFontType,
	LPARAM lpData 
)
/*
		Gets charset and other data for font lpnlf
 */
{
	CDrawText *pdt = (CDrawText *)lpData;

	pdt->m_logfont.lfCharSet = lpnlf->elfLogFont.lfCharSet;

	return( FALSE );
}


//---------------------------------------------------------------------------
CDrawObj::CDrawObj()
{
	Initilaize();
}

//---------------------------------------------------------------------------
CDrawObj::~CDrawObj()
{
}

//---------------------------------------------------------------------------


CDrawObj::CDrawObj(const CRect& position)
{
	Initilaize(position);	 
}


//---------------------------------------------------------------------------
void CDrawObj::Initilaize(const CRect& position)
{
	m_position = position;
	m_pDocument = NULL;

	m_bPen = TRUE;
	m_logpen.lopnStyle = PS_INSIDEFRAME;

	m_lLinePointSize=1;  //default to 1

	CClientDC dc(NULL);

	m_logpen.lopnWidth.x = (long) m_lLinePointSize*100/72;	//convert to LU
	m_logpen.lopnWidth.y = (long) m_lLinePointSize*100/72;	//convert to LU

	m_logpen.lopnColor = COLOR_BLACK; 

	m_bBrush = FALSE;
	m_logbrush.lbStyle = BS_SOLID;
	m_logbrush.lbColor = COLOR_WHITE; 
	m_logbrush.lbHatch = HS_HORIZONTAL;
}


//---------------------------------------------------------------------------
void CDrawObj::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);
	if (ar.IsStoring()) 
	{
		ar << m_position;
		ar << (WORD)m_bPen;
		ar.Write(&m_logpen, sizeof(LOGPEN));
		ar << (WORD)m_bBrush;
		ar.Write(&m_logbrush, sizeof(LOGBRUSH));
		ar << m_lLinePointSize;
	}
	else   
	{
		// get the document back pointer from the archive
		m_pDocument = (CDrawDoc*)ar.m_pDocument;
		ASSERT_VALID(m_pDocument);
		ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CDrawDoc)));

		WORD wTemp;
		ar >> m_position;
		ar >> wTemp; 
		m_bPen = (BOOL)wTemp;
		if( sizeof(LOGPEN) != ar.Read(&m_logpen,sizeof(LOGPEN)))
		{
			 AfxThrowMemoryException() ; // Any exception will do.
		}
		ar >> wTemp; 
		m_bBrush = (BOOL)wTemp;
		if( sizeof(LOGBRUSH) != ar.Read(&m_logbrush, sizeof(LOGBRUSH)))
		{
			 AfxThrowMemoryException(); // Aiming for the CATCH_ALL block in CDrawDoc::Serialize
		}
		ar >> m_lLinePointSize;
	}
}


//---------------------------------------------------------------------------
void CDrawObj::Draw(CDC*, CDrawView* )
{
}


//---------------------------------------------------------------------------
CDrawObj& CDrawObj::operator=(const CDrawObj& rdo)
{
   if (this==&rdo)
	  return *this;   //return if assigning to self

//	 (CObject&)*this=rdo;  //assign cobject part

   m_bPen = rdo.m_bPen;
   m_logpen = rdo.m_logpen;
   m_bBrush = rdo.m_bBrush;
   m_logbrush = rdo.m_logbrush;
   m_lLinePointSize=rdo.m_lLinePointSize;
   m_pDocument=rdo.m_pDocument;

   return *this;
}


//---------------------------------------------------------------------------
void CDrawObj::DrawTracker(CDC* pDC, TrackerState state)
{
	ASSERT_VALID(this);

	switch (state) 
	{
	  case normal:
		break;

	  case selected:
	  case active: 
	  {
		 int nHandleCount = GetHandleCount();
		 for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) 
		 {
			CPoint handle = GetHandle(nHandle);
			pDC->PatBlt(handle.x - 3, handle.y - 3, 7, 7, DSTINVERT);
		 }
	  }
	  break;
	}
}

//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveTo(const CRect& position, CDrawView* pView)
{
	ASSERT_VALID(this);

	if (position == m_position)
		return;

	Invalidate();
	m_position = position;
	Invalidate();

	m_pDocument->SetModifiedFlag();

	pView->UpdateStatusBar();
}


//---------------------------------------------------------------------------
// Note: if bSelected, hit-codes start at one for the top-left
// and increment clockwise, 0 means no hit.
// If !bSelected, 0 = no hit, 1 = hit (anywhere)
// point is in logical coordinates
//---------------------------------------------------------------------------
int CDrawObj::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
	ASSERT_VALID(this);
	ASSERT(pView != NULL);

	if (bSelected) {
		int nHandleCount = GetHandleCount();
		for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
			// GetHandleRect returns in logical coords
			CRect rc = GetHandleRect(nHandle,pView);
			if (point.x >= rc.left && point.x < rc.right &&
				point.y <= rc.top && point.y > rc.bottom)
				return nHandle;
		}
	}
	else  {
	   if (point.x >= m_position.left && point.x < m_position.right &&
			 point.y <= m_position.top && point.y > m_position.bottom)
		  return 1;
	}
	return 0;
}


//---------------------------------------------------------------------------
BOOL CDrawObj::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);

	CRect fixed = m_position;
	fixed.NormalizeRect();
	CRect rectT = rect;
	rectT.NormalizeRect();
	return !(rectT & fixed).IsRectEmpty();
}


//---------------------------------------------------------------------------
BOOL CDrawObj::ContainedIn(const CRect& rect)
{
	ASSERT_VALID(this);

	CRect fixed = m_position;
	fixed.NormalizeRect();
	CRect rectT = rect;
	rectT.NormalizeRect();

		// prevent rects that are too skinny or short
		if( fixed.left == fixed.right )
				fixed.right = fixed.left+1;

		if( fixed.top == fixed.bottom )
				fixed.bottom = fixed.top+1;

	return ((rectT | fixed)==rectT);
}


//---------------------------------------------------------------------------
int CDrawObj::GetHandleCount()
{
	ASSERT_VALID(this);
	return 8;
}


//---------------------------------------------------------------------------
// returns logical coords of center of handle
//---------------------------------------------------------------------------
CPoint CDrawObj::GetHandle(int nHandle)
{
	ASSERT_VALID(this);
	int x, y, xCenter, yCenter;

	// this gets the center regardless of left/right and top/bottom ordering
	xCenter = m_position.left + m_position.Width() / 2;
	yCenter = m_position.top + m_position.Height() / 2;

	switch (nHandle)
	{
	default:
		ASSERT(FALSE);

	case 1:
		x = m_position.left;
		y = m_position.top;
		break;

	case 2:
		x = xCenter;
		y = m_position.top;
		break;

	case 3:
		x = m_position.right;
		y = m_position.top;
		break;

	case 4:
		x = m_position.right;
		y = yCenter;
		break;

	case 5:
		x = m_position.right;
		y = m_position.bottom;
		break;

	case 6:
		x = xCenter;
		y = m_position.bottom;
		break;

	case 7:
		x = m_position.left;
		y = m_position.bottom;
		break;

	case 8:
		x = m_position.left;
		y = yCenter;
		break;
	}

	return CPoint(x, y);
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawObj::GetHandleRect(int nHandleID, CDrawView* pView)
{
	ASSERT_VALID(this);
	ASSERT(pView != NULL);

	CRect rect;
	// get the center of the handle in logical coords
	CPoint point = GetHandle(nHandleID);
	// convert to client/device coords
	pView->DocToClient(point);
	// return CRect of handle in device coords
	rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
	pView->ClientToDoc(rect);

	return rect;
}


//---------------------------------------------------------------------------
HCURSOR CDrawObj::GetHandleCursor(int nHandle)
{
	ASSERT_VALID(this);

	LPCTSTR id;
	switch (nHandle) {
	default:
		ASSERT(FALSE);

	case 1:
	case 5:
		id = IDC_SIZENWSE;
		break;

	case 2:
	case 6:
		id = IDC_SIZENS;
		break;

	case 3:
	case 7:
		id = IDC_SIZENESW;
		break;

	case 4:
	case 8:
		id = IDC_SIZEWE;
		break;
	}

	return AfxGetApp()->LoadStandardCursor(id);
}


//---------------------------------------------------------------------------
// point must be in logical
//---------------------------------------------------------------------------
void CDrawObj::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
	ASSERT_VALID(this);

	CRect position = m_position;
	switch (nHandle)
	{
	default:
		ASSERT(FALSE);

	case 1:
		position.left = point.x;
		position.top = point.y;
		break;

	case 2:
		position.top = point.y;
		break;

	case 3:
		position.right = point.x;
		position.top = point.y;
		break;

	case 4:
		position.right = point.x;
		break;

	case 5:
		position.right = point.x;
		position.bottom = point.y;
		break;

	case 6:
		position.bottom = point.y;
		break;

	case 7:
		position.left = point.x;
		position.bottom = point.y;
		break;

	case 8:
		position.left = point.x;
		break;
	}

	MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
	  TRACE(TEXT("AWCPE: CDrawObj::Invalidate, missing View pointer\n"));
	  return;
   }

   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) {
		rect.left -= 4;
		rect.top -= 5;
		rect.right += 5;
		rect.bottom += 4;
   }

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawObj::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawObj* pClone = new CDrawObj(m_position);

	ASSERT_VALID(pClone);

	*pClone=*this;

	if (pDoc != NULL)
		pDoc->Add(pClone);

	return pClone;
}


//---------------------------------------------------------------------------
void CDrawObj::OnDblClk(CDrawView* )
{
}


#ifdef _DEBUG
void CDrawObj::AssertValid()
{
   ASSERT(m_position.left <= m_position.right);
   ASSERT(m_position.bottom <= m_position.top);
}
#endif


//*********************************************************************
// CDrawRect
//*********************************************************************

//---------------------------------------------------------------------------
CDrawRect::CDrawRect()
{
}


//---------------------------------------------------------------------------
CDrawRect::~CDrawRect()
{
}

//---------------------------------------------------------------------------
CDrawRect::CDrawRect(const CRect& position)
		: CDrawObj(position)
{
}


//----------------------------------------------------------------------
void CDrawRect::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawObj::Serialize(ar);
	if (ar.IsStoring()) {
	}
	else {
	}
}

#define XinBOUNDS		   \
   ((position.right > position.left) \
				 ? point.x > position.left && point.x < position.right \
		 : point.x > position.right && point.x < position.left)

#define YinBOUNDS		   \
   ((position.top > position.bottom) \
				 ? point.y > position.bottom && point.y < position.top \
		 : point.y > position.top && point.y < position.bottom)



//---------------------------------------------------------------------------
void CDrawRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
	CRect position = m_position;

	switch (nHandle) {
	case 1:
		if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
		   if (uiShiftDraw & SHIFT_TOOL) {	 //DRAW SQUARE
						  if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
						  }
						  else {
				 position.left = point.x;
				 position.top =  (position.top > position.bottom) ? position.bottom + abs(position.right - position.left)
							: position.bottom - abs(position.right - position.left);
				 if (!YinBOUNDS) {
					position.top =	point.y;
								position.left = (position.left < position.right) ? position.right - abs(position.top - position.bottom)
								  : position.right + abs(position.top - position.bottom) ;
								 }
						  }
			   }
		   else {	  //KEEP ASPECT RATIO SIMILAR
						  if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
						  }
						  else {
							 UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
							 UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
							 UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
				 position.left = point.x;
							 iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
							 position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
								 : position.bottom - (iW*iAspect)/100;
							 if (!YinBOUNDS) {
				   position.top =  point.y;
							   iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
							   position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
								   : position.right + ((iAspect>0)?(iH*100)/iAspect:0);
				 }
						  }
		   }
			}
				else {	  //NORMAL DRAWING
				position.left = point.x;
				position.top = point.y;
				}
		break;

	case 2:
		position.top = point.y;
		break;

	case 3:
		if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
				   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
				   }
				   else {
					  UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
					  UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
					  UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
					  if (XinBOUNDS) {
				position.top =	point.y;
						iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
						position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
							: position.left - ((iAspect>0)?(iH*100)/iAspect:0);
			  }
			  else {
				position.right = point.x;
						iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
						position.top = (position.bottom < position.top) ? position.bottom + (iW*iAspect)/100
							: position.bottom - (iW*iAspect)/100;
					  }
				   }
			}
				else {	  //NORMAL DRAWING
				position.right = point.x;
				position.top = point.y;
				}
		break;

	case 4:
		position.right = point.x;
		break;

	case 5:
		if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
				   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
				   }
				   else {
					  UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
					  UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
					  UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
			  position.right = point.x;
					  iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
					  position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
						  : position.top + (iW*iAspect)/100;
					  if (!YinBOUNDS) {
				position.bottom =  point.y;
						iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
						position.right = (position.left < position.right) ? position.left + ((iAspect>0)?(iH*100)/iAspect:0)
							: position.left - ((iAspect>0)?(iH*100)/iAspect:0);
			  }
				   }
			}
				else {	  //NORMAL DRAWING
				position.right = point.x;
				position.bottom = point.y;
				}
		break;

	case 6:
		position.bottom = point.y;
		break;

	case 7:
		if (uiShiftDraw & SHIFT_DRAW) {   //DRAW PERFECT RECT
				   if ( ((point.x == position.left) && YinBOUNDS) || ((point.y == position.top) && XinBOUNDS) ) {
				   }
				   else {
					  UINT iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
					  UINT iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
					  UINT iAspect =  (iW > 0) ? (int)(100.0*((iH/(float)iW)+0.005)) : 100;
			  position.left = point.x;
					  iW = (position.right > position.left) ? position.right - position.left : position.left - position.right;
					  position.bottom = (position.bottom < position.top) ? position.top - (iW*iAspect)/100
						  : position.top + (iW*iAspect)/100;
					  if (!YinBOUNDS) {
				position.bottom =  point.y;
						iH = (position.top > position.bottom) ? position.top - position.bottom : position.bottom - position.top;
						position.left = (position.left < position.right) ? position.right - ((iAspect>0)?(iH*100)/iAspect:0)
							: position.right + ((iAspect>0)?(iH*100)/iAspect:0);
			  }
				   }
			}
				else {	  //NORMAL DRAWING
				position.left = point.x;
				position.bottom = point.y;
				}
		break;

	case 8:
		position.left = point.x;
		break;

	default:
		ASSERT(FALSE);
	}

	MoveTo(position, pView);
}


//---------------------------------------------------------------------------
void CDrawRect::Draw(CDC* pDC,CDrawView* pView)
{
	ASSERT_VALID(this);

	CBrush* pOldBrush;
	CPen*	pOldPen;
	CBrush	brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&logBrush))
	{
		return;
	}

	CPen pen;
	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
	   pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
	   pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	CRect rect = m_position;

	pDC->Rectangle(rect);

	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);

	CRect rectT = rect;
	rectT.NormalizeRect();

	CRect fixed = m_position;
	fixed.NormalizeRect();
	if ((rectT & fixed).IsRectEmpty())
		return FALSE;

	return TRUE;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRect::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawRect* pClone = new CDrawRect(m_position);

	*pClone=*this;

	ASSERT_VALID(pClone);

	if (pDoc != NULL)
		pDoc->Add(pClone);

	ASSERT_VALID(pClone);
	return pClone;
}


//*********************************************************************
// CFaxText
//*********************************************************************

//---------------------------------------------------------------------------
CFaxText::CFaxText()
{
   Initialize();
}

//---------------------------------------------------------------------------
CFaxText::CFaxText(const CRect& position)
		: CDrawRect(position)
{
   Initialize();
}


//----------------------------------------------------------------------
void CFaxText::Initialize()
{
   m_bPrintRTF=TRUE;
   m_hRTFWnd=NULL;
   m_hLib=NULL;
   m_wResourceid=IDS_PROP_MS_TEXT;
}

//---------------------------------------------------------------------------
CFaxText::~CFaxText()
{
   EndRTF();
}

//----------------------------------------------------------------------
void CFaxText::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawRect::Serialize(ar);
	if (ar.IsStoring()) {
	}
	else {
		if (GetApp()->m_dwSesID!=0) {	 //rendering
				   InitRTF();
				   StreamInRTF();
				   CheckForFit();
		}
	}
}


//---------------------------------------------------------------------------
void CFaxText::InitRTF()
{
	LPVOID lpMsgBuf;

	m_hLib = LoadLibrary(TEXT("RICHED32.DLL"));

	if (!m_hLib) {
		::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
				 ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
		TRACE1("AWCPE error: %s (error loading RICHED32.DLL)\n",lpMsgBuf);
				return;
	}

	CDrawView *pView = CDrawView::GetView();
	if (!pView)
	{
		TRACE(_T("AWCPE error: CDrawView::GetView() returns NULL\n"));
		return;
	}

	m_hRTFWnd = CreateWindow(TEXT("RICHEDIT"),TEXT(""),WS_CHILD | ES_MULTILINE, 0, 0, 0, 0, pView->m_hWnd,
		(HMENU)0, AfxGetInstanceHandle(),NULL);

		if (!m_hRTFWnd) {
		::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
				 ::GetLastError(), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),(LPTSTR) &lpMsgBuf, 0, NULL );
		TRACE1("AWCPE error: %s (error in CreateWindow for RICHEDIT)\n",lpMsgBuf);
		return;
		}
}


//---------------------------------------------------------------------------
void CFaxText::EndRTF()
{
	if (m_hRTFWnd) {
			::DestroyWindow(m_hRTFWnd);
				m_hRTFWnd=NULL;
		}

	if (m_hLib) {
		::FreeLibrary(m_hLib);
				m_hLib=NULL;
		}
}


//-------------------------------------------------------------------------------------------------------
DWORD CALLBACK CFaxText::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
	dwCookie=0;
		pbBuff=0;
		cb=0;
	pcb=0;

//	get a iStream from transport
//	read from storage.

		return 0;
}


//---------------------------------------------------------------------------
void CFaxText::StreamInRTF()
{
   if (m_hRTFWnd==NULL)
	  return;

	EDITSTREAM es;
		es.dwCookie=0;	 //pIStream pointer here
	es.dwError=0;
	es.pfnCallback= EditStreamCallBack;
	::SendMessage(m_hRTFWnd, EM_STREAMIN, SF_RTF, (LPARAM)&es);
}

//---------------------------------------------------------------------------
void CFaxText::RectToTwip(CRect& rc,CDC& dc)
{
   int iX=dc.GetDeviceCaps(LOGPIXELSX);
   int iY=dc.GetDeviceCaps(LOGPIXELSY);
   rc.left=(rc.left*1440)/iX;
   rc.right=(rc.right*1440)/iX;
   rc.top=(rc.top*1440)/iY;
   rc.bottom=(rc.bottom*1440)/iX;
}

//---------------------------------------------------------------------------
void CFaxText::CheckForFit()
{
   if (m_hRTFWnd==NULL)
	  return;

   CDrawView* pView=CDrawView::GetView();

   FORMATRANGE fr;
   CClientDC dc(pView);
   fr.hdc=fr.hdcTarget=dc.GetSafeHdc();
   CRect rc=m_position;
   pView->DocToClient(rc,&dc);
   RectToTwip(rc,dc);
   fr.rc=fr.rcPage=rc;
   fr.chrg.cpMin=0;
   fr.chrg.cpMax=-1;

   LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);
   LRESULT lTextLength = ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);

   if (m_bPrintRTF = (lTextToPrint <= lTextLength)) {
	   //notify transport going to print RTF
   }
   else {
	   //notify transport not going to print RTF
   }

   ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);		//clean up.
}



//---------------------------------------------------------------------------
void CFaxText::Draw(CDC* pDC,CDrawView* pView)
{
	if ( (GetApp()->m_dwSesID!=0) && (!(m_hRTFWnd!=NULL && m_bPrintRTF)) )
	{
		return;
	}

	ASSERT_VALID(this);

	CBrush* pOldBrush;
	CPen*	pOldPen;
	CBrush	brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&logBrush))
	{
		return;
	}

	CPen pen;
	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
	   pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
	   pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	CRect rect = m_position;

	pDC->Rectangle(rect);

	int wx = MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
	int wy = MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
	int x = -wx-1;
	int y = -wy-1;

	pView->DocToClient(rect,pDC);
	rect.InflateRect(x,y);
	pView->ClientToDoc(rect,pDC);

	if (GetApp()->m_dwSesID != 0) 
	{
	   //rendering
	   FORMATRANGE fr;
	   CRect rc=m_position;
	   pView->DocToClient(rc,pDC);
	   RectToTwip(rc,*pDC);
	   fr.rc=fr.rcPage=rc;
	   fr.chrg.cpMin=0;
	   fr.chrg.cpMax=-1;

	   LRESULT lTextLength	= ::SendMessage(m_hRTFWnd, WM_GETTEXTLENGTH, 0, 0L);
	   LRESULT lTextToPrint = ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, TRUE, (LPARAM)&fr);
	   if (lTextLength != lTextToPrint)
	   {
			TRACE(TEXT("AWCPE: error, printed text range != total text length\n"));
	   }

	   ::SendMessage(m_hRTFWnd, EM_FORMATRANGE, FALSE, NULL);	//clean up.
	}
	else 
	{
	   pDC->SetBkMode(TRANSPARENT);
	   pDC->DrawText(_T("{Fax Text}"), 
					 10, 
					 rect, 
					 theApp.IsRTLUI() ? DT_RIGHT | DT_RTLREADING : DT_LEFT);
	}

	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}
}


//---------------------------------------------------------------------------
CDrawObj* CFaxText::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CFaxText* pClone = new CFaxText(m_position);

	*pClone=*this;

	ASSERT_VALID(pClone);

	if (pDoc != NULL)
		pDoc->Add(pClone);

	ASSERT_VALID(pClone);
	return pClone;
}


//*********************************************************************
// CDrawText
//*********************************************************************

//---------------------------------------------------------------------------
CDrawText::CDrawText()
{
	Initialize();
}


//---------------------------------------------------------------------------
CDrawText::CDrawText(const CRect& position)
		: CDrawRect(position)
{
	Initialize();
}


//---------------------------------------------------------------------------
void CDrawText::Initialize()
{
	m_pEdit = NULL;
	m_lStyle = theApp.IsRTLUI() ? DT_RIGHT | DT_RTLREADING : DT_LEFT;
	InitEditWnd();
	m_brush=NULL;
	m_crTextColor= COLOR_BLACK; 
	m_bUndoAlignment = FALSE ;
	m_bUndoTextChange = FALSE ;
	m_bUndoFont = FALSE ;
	m_bPen=FALSE;
	m_logbrush.lbColor = COLOR_WHITE; 
	NewBrush();  //brush is created, for WM_CTLCOLOR processing

	m_logfont = theApp.m_last_logfont;

	m_pFont = new CFont;
	m_pFont->CreateFontIndirect(&m_logfont);

	if (m_pEdit)
	{
		m_pEdit->SetFont(m_pFont);
	}
}

//-----------------------------------------------------------------------------
void CDrawText::OnEditUndo()
{
	if( !m_pEdit )
	{
		return;
	}
	if( m_bUndoAlignment )
	{
		ToggleAlignmentForUndo();
		return;
	}
	if( m_bUndoFont )
	{
		ToggleFontForUndo();
		return;
	}
	//
	// Let the edit control handle Undo
	//
	m_pEdit->SendMessage(WM_UNDO,0,0L);
}

//------------------------------------------------------------------------------
BOOL CDrawText::CanUndo()
{
	return m_bUndoFont || m_bUndoAlignment || m_pEdit && m_pEdit->CanUndo() ;
}

//------------------------------------------------------------------------------
void CDrawText::ToggleFontForUndo()
{
	LOGFONT temp ;
	memcpy( &temp, &m_logfont, sizeof(LOGFONT)) ;
	memcpy( &m_logfont, &m_previousLogfontForUndo, sizeof(LOGFONT)) ;
	memcpy( &m_previousLogfontForUndo, &temp, sizeof(LOGFONT)) ;
	ChgLogfont( m_logfont );
}
//------------------------------------------------------------------------------
void CDrawText::ToggleAlignmentForUndo()
{
	CDrawView * pView = CDrawView::GetView();

	if (!pView || !m_pEdit)
	{
		return;
	}

	//
	// We can't call ChgAlignment because it sets the state for the UNDO.
	//

	LONG lStyle = m_previousAlignmentForUndo;
	m_previousAlignmentForUndo = m_lStyle;
	m_lStyle = lStyle;


	m_pEdit->ModifyStyle(ES_CENTER | ES_RIGHT, 
						 DTStyleToESStyle(lStyle),
						 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

	m_pEdit->ModifyStyleEx(WS_EX_RIGHT | WS_EX_RTLREADING, 
						   DTStyleToEXStyle(lStyle), 
						   SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);


	pView->UpdateStyleBar();
}

//---------------------------------------------------------------------------
CDrawText::~CDrawText()
{
	if (m_pEdit) 
	{
	   m_pEdit->DestroyWindow();
	   delete m_pEdit;
	}
	if (m_brush)
	   VERIFY(::DeleteObject(m_brush));

	if (m_pFont)
	   delete m_pFont;
}


//---------------------------------------------------------------------------
CDrawText& CDrawText::operator=(const CDrawText& rdo)
{
   if (this==&rdo)
	  return *this;   //return if assigning to self

   CDrawRect::operator = (rdo);  //assign cdrawrect part

   m_crTextColor = rdo.m_crTextColor;
   m_szEditText  = rdo.m_szEditText;
   m_lStyle 	 = rdo.m_lStyle;

   memcpy(&m_logfont, &rdo.m_logfont, sizeof(m_logfont));
   LOGFONT lf;
   ChgLogfont(lf,FALSE);

   if (m_pEdit) 
   {
	  CString szEditText;
	  if (rdo.m_pEdit) 
	  {
		 rdo.m_pEdit->GetWindowText(szEditText);
		 m_pEdit->SetWindowText(szEditText);
	  }
   }
   return *this;
}


//---------------------------------------------------------------------
void CDrawText::ChgAlignment(
	CDrawView* pView, 
	LONG lStyle // DrawText alignment format
)
{
	if (!m_pEdit) 
	{
	   TRACE(TEXT("AWCPE.CPEOBJ.CHGALIGNMENT: invalid CEdit pointer\n"));
	   return;
	}
//
// Save the state for Undoing.
//
	m_bUndoTextChange = FALSE;
	m_bUndoAlignment = TRUE;
	m_bUndoFont = FALSE;
	m_previousAlignmentForUndo = m_lStyle ;

	m_lStyle = lStyle;
	if(m_pEdit->GetExStyle() & WS_EX_RTLREADING)
	{
		m_lStyle |= DT_RTLREADING;
	}

	m_pEdit->ModifyStyle(ES_CENTER | ES_RIGHT, 
						 DTStyleToESStyle(lStyle),
						 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

	m_pEdit->ModifyStyleEx(WS_EX_RIGHT, 
						   DTStyleToEXStyle(lStyle), 
						   SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);

	pView->UpdateStyleBar();
}


//---------------------------------------------------------------------
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
	  TRACE(TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
	  return;
   }

   CClientDC dc(pView);
   pView->OnPrepareDC(&dc,NULL);
   dc.SelectObject(m_pEdit->GetFont());

   Invalidate(); // clear size rect droppings
   SnapToFont_onthefly( pView, &dc, m_position );

   FitEditWnd(NULL);
   Invalidate(); // draw new stuff

   pView->UpdateStatusBar();
}



#ifdef FUBAR // keep this around awhile for reference
void CDrawText::SnapToFont()
{
   CDrawView* pView = CDrawView::GetView();
   if (m_pEdit==NULL || pView==NULL) {
	  TRACE( TEXT("CDrawText::SnapToFont-missing m_pEdit or view pointer\n"));
	  return;
   }

   TEXTMETRIC tm;
   CClientDC dc(pView);

   pView->OnPrepareDC(&dc,NULL);
   int x = MulDiv(m_logpen.lopnWidth.x, dc.GetDeviceCaps(LOGPIXELSX), 100)+1;
   int y = MulDiv(m_logpen.lopnWidth.y, dc.GetDeviceCaps(LOGPIXELSY), 100)+1;


   CRect rect = m_position;
   pView->DocToClient(rect,&dc);
   rect.InflateRect(-x,-y);
   pView->ClientToDoc(rect,&dc);

   dc.SelectObject(m_pEdit->GetFont());
//	 CString sz;
//	 GetLongestString(sz);
//	 CSize cs = dc.GetTextExtent(sz,sz.GetLength());
   CSize cs;

   dc.GetTextMetrics(&tm);
   cs.cy=tm.tmHeight + tm.tmExternalLeading;

   int iOHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;

   int iLines= (cs.cy>0)?(int)((iOHeight/(float)cs.cy)*100):0;
//	 int iLines= (cs.cy>0)?iOHeight/cs.cy:0;

   iLines=(iLines+50)/100;
   if (iLines<1)
	  iLines=1;

   int iH=iLines*cs.cy+1;
//	 int iH=iLines*cs.cy;

   if (rect.bottom < rect.top)
	  rect.bottom = rect.top-iH;
   else
	  rect.top = rect.bottom-iH;

   int iNHeight =  (rect.bottom < rect.top) ? rect.top - rect.bottom : rect.bottom - rect.top;
   if (iOHeight > iNHeight)
	  Invalidate();

//	TRACE??("before border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   pView->DocToClient(rect,&dc);
   rect.InflateRect(x,y);
   rect.bottom+=2;
   pView->ClientToDoc(rect,&dc);

//	TRACE("after border inflating: RectH(%i),border x,y(%i,%i),cs.cy(%i), iLines(%i), iH(%i)\n",rect.top-rect.bottom,x,y,cs.cy,iLines,iH);

   m_position=rect;
   Invalidate();

   FitEditWnd(NULL);

   pView->UpdateStatusBar();
}
#endif


//---------------------------------------------------------------------
void CDrawText::
		SnapToFont_onthefly( CDrawView *pView, CDC *fly_dc,
												 CRect &fly_rect, CFont *dpFont )
   /*
				If dpFont is not NULL it is selected into fly_dc after
				switching to MM_TEXT mode.
		*/
   {
   TEXTMETRIC tm;
   LONG temp;

   if( pView == NULL )
				return;

   int x =
				MulDiv( m_logpen.lopnWidth.x,
								fly_dc->GetDeviceCaps(LOGPIXELSX),
								100)+1;
   int y =
				MulDiv( m_logpen.lopnWidth.y,
								fly_dc->GetDeviceCaps(LOGPIXELSY),
								100)+1;

   // normalize rect first
   if( fly_rect.top < fly_rect.bottom )
				{
				temp = fly_rect.top;
				fly_rect.top = fly_rect.bottom;
				fly_rect.bottom = temp;
				}

   if( fly_rect.right < fly_rect.left )
				{
				temp = fly_rect.right;
				fly_rect.right = fly_rect.left;
				fly_rect.left = temp;
				}

   // save original spot so we can avoid rect jiggle due
   // to unavoidable integer roundoff error below
   RECT save_rect = fly_rect;

   pView->DocToClient(fly_rect,fly_dc);
   fly_rect.InflateRect(-x,-y);

   CPoint pW1=fly_dc->GetWindowOrg();
   CPoint pW2=pW1;
   pView->DocToClient(pW2,fly_dc);
   CPoint pV=fly_dc->GetViewportOrg();

   // do snapping in MM_TEXT to get rect exactly right
   fly_dc->SetMapMode(MM_TEXT);
   fly_dc->SetWindowOrg(pW2);
   fly_dc->SetViewportOrg(pV);

   CSize cs;

   if( dpFont != NULL )
				fly_dc->SelectObject( dpFont );

   fly_dc->GetTextMetrics(&tm);
   cs.cy=tm.tmHeight;// + tm.tmExternalLeading;

   int iLines= (cs.cy>0)
										?(fly_rect.bottom - fly_rect.top - 1 + cs.cy/2)/cs.cy
										:0;
   if (iLines<1)
	  iLines=1;

   // snap height to a whole text line
   fly_rect.bottom = fly_rect.top + iLines*cs.cy + 1;

   // back to MM_ANISOTROPHIC
   fly_dc->SetMapMode(MM_ANISOTROPIC);
   fly_dc->SetWindowOrg(pW1);
   fly_dc->SetViewportOrg(pV);
   fly_dc->SetViewportExt(fly_dc->GetDeviceCaps(LOGPIXELSX),
												  fly_dc->GetDeviceCaps(LOGPIXELSY));
   fly_dc->SetWindowExt(100, -100);

   fly_rect.InflateRect(x,y);
   pView->ClientToDoc(fly_rect,fly_dc); // back to the future

   // integer round off error from above may cause rect to
   // jiggle a bit, so slap it back where it is supposed to be.
   int new_height = fly_rect.top - fly_rect.bottom;
   fly_rect = save_rect;
   fly_rect.bottom = fly_rect.top - new_height;

   }


//---------------------------------------------------------------------
void CDrawText::ChgLogfont(LOGFONT& lf, BOOL bResize /*=TRUE*/)
{
	CDrawView* pView = CDrawView::GetView();
	if (m_pEdit==NULL || pView==NULL) {
		TRACE(TEXT("CDrawText::ChgLogfont--missing m_pEdit or view pointer\n"));
		return;
	}


	CClientDC dc(pView);
	CRect rect;
	CString sz;
	CSize oldcs,newcs;

	if (m_pFont){
	   delete m_pFont;
	}
	m_pFont = new CFont;

	// get charset for font (-> m_pEdit->m_logfont)

	::EnumFontFamilies(
		dc.GetSafeHdc(),
		m_logfont.lfFaceName,
		(FONTENUMPROC)get_fontdata,
		LPARAM(this)
		);

	if (!m_pFont->CreateFontIndirect(&m_logfont)){
		 TRACE(TEXT("CPEOBJ.ChgLogFont(): Unable to create font\n"));
	}
	theApp.m_last_logfont = m_logfont;

	if (m_pEdit){
		m_pEdit->SetFont(m_pFont);
	}

	SnapToFont(); // changing box size irratates Justin. Just snap for now

	Invalidate();
	pView->UpdateStatusBar();

	pView->UpdateStyleBar();
	CDrawDoc::GetDoc()->SetModifiedFlag();
}


//----------------------------------------------------------------------
void CDrawText::GetLongestString(CString& szLong)
{
   int linecount = (int)m_pEdit->SendMessage(EM_GETLINECOUNT,0,0L);

   if (linecount <= 0)
	  return;

   TCHAR* sz;
   CString szHold;
   CString szTemp;
   int iSaveLen=0;
   WORD num;
   for (int i=0;i<linecount;i++) 
   {
	   int linelength = (int)m_pEdit->SendMessage(EM_LINELENGTH,(WPARAM)m_pEdit->SendMessage(EM_LINEINDEX,(WPARAM)i,0L),0L);
	   if (linelength>0) 
	   {
		  sz=new TCHAR[linelength+sizeof(TCHAR)];
		  *(LPWORD)sz=linelength+(int)sizeof(TCHAR);
		  num = (WORD)m_pEdit->SendMessage(EM_GETLINE,(WPARAM)i,(LPARAM)(LPCSTR) sz);
		  sz[num]=(TCHAR)'\0';
		  szTemp=sz;
		  int j = szTemp.GetLength();
		  if ( j > iSaveLen) 
		  {
			 szHold=sz;
			 iSaveLen=j;
		  }
		  delete [] sz;
	   }
   }
   szLong=szHold;
}

//----------------------------------------------------------------------
void CDrawText::InitEditWnd()
{
	if (m_pEdit)
	{
	   return;
	}

	m_pEdit = new CTextEdit;

	RECT rect = {0};
	m_pEdit->CreateEx(DTStyleToEXStyle(m_lStyle), 
					  TEXT("EDIT"), 
					  NULL, 
					  WS_CHILD | ES_NOHIDESEL | ES_MULTILINE | DTStyleToESStyle(m_lStyle), 
					  rect, 
					  CDrawView::GetView(), 
					  ID_TEXT);
}

//----------------------------------------------------------------------
void CDrawText::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawRect::Serialize(ar);
	LOGFONT lf;
	if (ar.IsStoring()) 
	{
		LOGFONTW	lfTmpFont;

		if (CopyTLogFontToWLogFont(m_logfont,lfTmpFont) != ERROR_SUCCESS)
		{
			  AfxThrowMemoryException() ; // Any exception will do.
										  //CATCH_ALL in CDrawDoc::Serialize is the target.
		}
		ar.Write(&lfTmpFont, sizeof(LOGFONTW));
		if (m_pEdit) 
		{	 //make sure that m_szEditText has window text
		   FitEditWnd(NULL);
		}
		ar << m_lStyle;
		ar << m_szEditText;
		ar << m_crTextColor;
	}
	else 
	{  
		LOGFONTW LogFontW;
		LOGFONTA LogFontA;

		//
		//	Reading in from a file
		//
		if( CDrawDoc::GetDoc()->m_bDataFileUsesAnsi )
		{
			//
			// Read in a LOGFONTA and convert it to a LOGFONT.
			//
			if( sizeof(LOGFONTA) != ar.Read( &LogFontA, sizeof(LOGFONTA)))
			{
				AfxThrowMemoryException() ; // Any exception will do.
											//CATCH_ALL in CDrawDoc::Serialize is the target.
			}
			memcpy( &m_logfont, &LogFontA, sizeof(LOGFONTA)) ;
#ifdef UNICODE
			if( 0 == MultiByteToWideChar( CP_ACP,
										  MB_PRECOMPOSED,
										  LogFontA.lfFaceName,
										  LF_FACESIZE,
										  m_logfont.lfFaceName,
										  LF_FACESIZE))
			{
				AfxThrowMemoryException() ;
			}
#endif
		}
		else
		{
			if(sizeof(LOGFONTW) != ar.Read(&LogFontW,sizeof(LOGFONTW)))
			{
				AfxThrowMemoryException() ; // Any exception will do.
			}
			else
			{
				if (CopyWLogFontToTLogFont(LogFontW, m_logfont) != ERROR_SUCCESS)
				{
					  AfxThrowMemoryException() ; // Any exception will do.
												  //CATCH_ALL in CDrawDoc::Serialize is the target.
				}
			}
		}	 
		ar >> m_lStyle;
		ar >> m_szEditText;
		ar >> m_crTextColor;

		// Fix for 3405. Overide saved charset (codepage) with current
		//								 system charset. theApp.m_last_logfont is set
		//								 initially in CMainFrame::CreateStyleBar when
		//								 the CPE initializes so it is gaurenteed to be
		//								 valid by the time it gets here.
		m_logfont.lfCharSet = theApp.m_last_logfont.lfCharSet;

		ChgLogfont(lf,FALSE);
	}

	if (m_pEdit)
	{
	   m_pEdit->Serialize(ar);
	}
	if (!ar.IsStoring())
	{
		SnapToFont();
		NewBrush(); 		/// Bug fix! unraided.	a-juliar 8-27-76
							/// The text boxes were not being drawn with proper
							/// background color when they had the input focus.
							/// This bug was present in Windows 95 version.
	}
}



//---------------------------------------------------------------------------
int CDrawText::GetText( int numlines, BOOL delete_text )
		/*
				Returns number of ACTUAL remaining lines in editbox
		 */
		{
		int linecount;
		int linelength;
		TCHAR* sz;
		WORD num;
		int i;
		int buflen;
		int zapline_char;
		int getline_char;


		m_szEditText=_T("");


		// see if there is any text
		linecount = m_pEdit->GetLineCount();
		if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
				return( 0 );


		if( numlines > 0 )
		{
			if( numlines < linecount )
			{
				 linecount = numlines;
			}
		}


		for( i=0;i<linecount;i++ )
		{
			getline_char = m_pEdit->LineIndex( i );
			linelength = m_pEdit->LineLength( getline_char );
			if (linelength>0)
			{
				buflen = 2*linelength;
				sz=new TCHAR[buflen+sizeof(TCHAR)];
				num = (WORD)m_pEdit->GetLine( i, sz, buflen );
				sz[num]=(TCHAR)'\0';
				m_szEditText+=sz;

				delete [] sz;
			}

			if( i<linecount )
				m_szEditText+=(TCHAR) '\n';
		}


		if( delete_text )
		{
				zapline_char = m_pEdit->LineIndex( linecount-1 );
				m_pEdit->SetSel( 0,
								 zapline_char +
								 m_pEdit->LineLength( zapline_char ),
								 TRUE );

				m_pEdit->Clear();
		}

		// see if there is still any text
		linecount = m_pEdit->GetLineCount();
		if( (linecount == 1)&&(m_pEdit->LineLength( 0 ) == 0) )
				return( 0 );
		else
				return( linecount );

}




//---------------------------------------------------------------------------
void CDrawText::SetText(CString& szText, CDrawView* pView)
{
   if (!m_pEdit)
	  return;

   m_pEdit->SetWindowText(szText);

   FitEditWnd(pView);
}


//---------------------------------------------------------------------------
void CDrawText::OnDblClk(CDrawView* pView)
{
   ShowEditWnd(pView, TRUE);
}

//--------------------------------------------------------------------------------------------------
void CDrawText::NewBrush()
{
	if (m_brush)
	{
	   ::DeleteObject(m_brush);
	}

	LOGBRUSH logBrush = m_logbrush;

	logBrush.lbColor = GetDisplayColor(logBrush.lbColor);

	m_brush = ::CreateBrushIndirect(&logBrush);
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::HitTestEdit(CDrawView* pView,CPoint& lpoint)
{
	if (pView->m_selection.GetCount()!=1)
	  return FALSE;

	CRect cr = m_position;
	cr.NormalizeRect();

	CRect pointrc(lpoint, CSize(1, 1));
	CRect objrc = m_position;
	objrc.NormalizeRect();
	objrc.InflateRect(-5,-5);
	return !(pointrc & objrc).IsRectEmpty();
}


//---------------------------------------------------------------------------------------------------
BOOL CDrawText::ShowEditWnd(CDrawView* pView, BOOL Initialize)
{
	FitEditWnd(pView);
	pView->m_pObjInEdit = this;
	if( Initialize )
	{
		m_bUndoFont = FALSE ;
		m_bUndoAlignment = FALSE ;
		m_bUndoTextChange = FALSE ;
	}
	m_pEdit->ShowWindow(SW_NORMAL);
	m_pEdit->SetFocus();

	pView->Select(NULL, FALSE, FALSE);
	return TRUE;
}


//---------------------------------------------------------------------------
void CDrawText::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
	if (!pView->m_pObjInEdit)
	{
	   return;
	}

	if( CanUndo() && SaveUndoState )
	{
	   OnEditUndo();				// Revert to Text Box's previous state.
	   pView->SaveStateForUndo();	// Gives the View a record of the Text Box's last change.
	   OnEditUndo();				// Return to "present state".
	   m_bUndoFont = FALSE ;
	   m_bUndoTextChange = FALSE ;
	   m_bUndoAlignment = FALSE ;	// Now the View should handle Undo.
	}

	pView->m_pObjInEdit=NULL;

	GetText();

	//
	// save reading direction
	//
	if(m_pEdit->GetExStyle() & WS_EX_RTLREADING)
	{
		m_lStyle |= DT_RTLREADING;
	}
	else
	{
		m_lStyle &= ~DT_RTLREADING;
	}


	m_pEdit->ShowWindow(SW_HIDE);
}


//---------------------------------------------------------------------------
CFont* CDrawText::GetFont()
{
	return m_pFont;
}


//---------------------------------------------------------------------------
void CDrawText::Draw(CDC* pDC,CDrawView* pView)
{
	CPoint p;

	CFont*	pNewFont = NULL;
	CFont*	pOldFont=NULL;
	CBrush* pOldBrush=NULL;
	CPen*	pOldPen=NULL;

	CBrush brush;
	CPen pen;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	//ALLOCATE GDI OBJECTS
	if (m_bBrush) 
	{
	   if (!brush.CreateBrushIndirect(&logBrush))
	   {
		   return;
	   }
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen) 
	{
	   if (!pen.CreatePenIndirect(&logPen))
	   {
		  return;
	   }
	   pOldPen = pDC->SelectObject(&pen);
	}
	else 
	{  
		//if no bPen & printing, use NULL pen
	   if (pDC->IsPrinting()) 
	   {
		  pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	   }
	   else 
	   {   
		  //default pen -- dashdot, gray border
		  m_savepenstyle = m_logpen.lopnStyle;

		  m_logpen.lopnStyle = PS_DOT;

		  m_savepencolor = m_logpen.lopnColor;
		  m_logpen.lopnColor = COLOR_LTGRAY;
		  m_logpen.lopnWidth.x = 1;
		  m_logpen.lopnWidth.y = 1;
		  pen.CreatePenIndirect(&m_logpen);
		  pOldPen = pDC->SelectObject(&pen);
	   }
	}


	CRect rect = m_position;

	CFont* pFont = NULL;
	if (pDC->IsPrinting()) 
	{	
	   //scale font to printer size
	   LOGFONT logFont;
	   memcpy(&logFont, &m_logfont, sizeof(m_logfont));
	   pFont = new CFont;
	   logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
	   pFont->CreateFontIndirect(&logFont);
	   pOldFont= pDC->SelectObject(pFont);

	   SnapToFont_onthefly( pView, pDC, rect );
	}
	else 
	{
	   pOldFont= pDC->SelectObject(m_pEdit->GetFont());
	}

	pDC->Rectangle(rect);

	if (pView->m_pObjInEdit != this && m_szEditText.GetLength()>0) 
	{

	   int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
	   int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
	   int x = -wx-1;
	   int y = -wy-1;

	   pView->DocToClient(rect,pDC);
	   CPoint pW1=pDC->GetWindowOrg();
	   CPoint pW2=pW1;
	   pView->DocToClient(pW2,pDC);
	   CPoint pV=pDC->GetViewportOrg();
	   rect.InflateRect(x,y);
	   pDC->SetMapMode(MM_TEXT); //switch to MM_TEXT
	   pDC->SetWindowOrg(pW2);
	   pDC->SetViewportOrg(pV);
	   pDC->SetTextColor(GetDisplayColor(m_crTextColor));
	   pDC->SetBkMode(TRANSPARENT);

	   pDC->DrawText(m_szEditText,
					 m_szEditText.GetLength(),
					 rect,
					 m_lStyle | DT_NOPREFIX );

	   pDC->SetMapMode(MM_ANISOTROPIC);   //switch back to MM_ANISOTROPHIC
	   pDC->SetWindowOrg(pW1);
	   pDC->SetViewportOrg(pV);
	   pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
	   pDC->SetWindowExt(100, -100);
	}

	   //CLEANUP GDI OBJECTS
	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}

	if (!m_bPen) 
	{
	   m_logpen.lopnColor=m_savepencolor;
	   m_logpen.lopnStyle=m_savepenstyle;
	}

	if (pOldFont)
	{
	   pDC->SelectObject(pOldFont);
	}

	if (pFont)
	{
	   delete pFont;
	}

	if (pNewFont)
	{
	   delete pNewFont;
	}
}


//---------------------------------------------------------------------------
void CDrawText::FitEditWnd(CDrawView* pView, BOOL call_gettext, CDC *pdc )
{
   CClientDC dc(NULL);
   CRect rect = m_position;

   if( pdc == NULL )
   {
	   if (pView==NULL)
	   {
			pView=CDrawView::GetView();
	   }

	   pView->DocToClient(rect);

	   if( pdc == NULL )
	   {
			pdc = &dc;
	   }


	   int iX = pdc->GetDeviceCaps(LOGPIXELSX);
	   int iY = pdc->GetDeviceCaps(LOGPIXELSY);
	   int wx=MulDiv(m_logpen.lopnWidth.x, iX, 100);
	   int wy=MulDiv(m_logpen.lopnWidth.y, iY, 100);
	   int x = -wx-1;
	   int y = -wy-1;
	   rect.InflateRect(x,y);
   }

   m_pEdit->MoveWindow(&rect);

   m_pEdit->GetClientRect(&rect);		  //set formatting rectangle to client area
   m_pEdit->SetRect(&rect);

   if( call_gettext )
   {
		GetText();
   }
}


//---------------------------------------------------------------------------
void CDrawText::MoveTo(const CRect& position, CDrawView* pView)
{
   CDrawRect::MoveTo(position, pView);
}

//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawText::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
	ASSERT_VALID(this);

	CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);

	FitEditWnd(pView);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawText::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);
	CString copy_text;

	CDrawText* pClone = new CDrawText(m_position);

	ASSERT_VALID(pClone);

	*pClone=*this; // copy geometry, style, etc., in one swoop

	// have to stuff in a few other things
	pClone->m_pEdit = NULL; // don't point to old one
	pClone->InitEditWnd();

	// make a new one
	pClone->m_brush = ::CreateBrushIndirect( &pClone->m_logbrush );

	// ditto
	if( (pClone->m_pFont = new CFont) != NULL )
	{
		pClone->m_pFont->CreateFontIndirect( &pClone->m_logfont );
		pClone->m_pEdit->SetFont( pClone->m_pFont, FALSE );
	}

		// copy text
		m_pEdit->GetWindowText( copy_text );
		pClone->m_pEdit->SetWindowText( copy_text );

		// and position
		pClone->m_position = m_position;


		// shoe it in
		pClone->FitEditWnd( NULL );

	if (pDoc != NULL)
		pDoc->Add(pClone);

	return pClone;
}





//*********************************************************************
// CFaxProp
//*********************************************************************

//---------------------------------------------------------------------------
CFaxProp::CFaxProp()
{
}


//---------------------------------------------------------------------------
CFaxProp::CFaxProp(const CRect& position,WORD wResourceid)
		: CDrawText(position)
{
	m_wResourceid=wResourceid;
}


//---------------------------------------------------------------------------
CFaxProp::~CFaxProp()
{
// F I X  for 3647 /////////////
//
// Zap m_last_note_box at note destroy time so we don't have
// a dangling pointer.
//
				if( m_wResourceid == IDS_PROP_MS_NOTE )
						theApp.m_last_note_box = NULL;
////////////////////////////////
}


//----------------------------------------------------------------------
void CFaxProp::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawText::Serialize(ar);

	if (ar.IsStoring()) 
	{
		ar << (WORD)m_wResourceid;
	}
	else 
	{
		ar >> m_wResourceid;
		if (GetApp()->m_dwSesID != 0) 
		{	 //rendering
		   GetApp()->m_pFaxMap->GetPropString(m_wResourceid,m_szEditText);
		   m_pEdit->SetWindowText(m_szEditText);
		   FitEditWnd(CDrawView::GetView());

// F I X  for 3647 /////////////
//
// set m_last_note_box at note creation time instead of at
// draw time.
//
			if( m_wResourceid == IDS_PROP_MS_NOTE )
			{
				theApp.m_last_note_box = this;
			}
////////////////////////////////
		}
	}
}


//---------------------------------------------------------------------------------------------------
BOOL CFaxProp::ShowEditWnd(CDrawView* pView, BOOL Initialize )
{
	return FALSE;	 //fax property object doesnt support editing
}


//---------------------------------------------------------------------------
void CFaxProp::HideEditWnd(CDrawView* pView, BOOL SaveUndoState )
{
	return;    //never shown, never hidden
}



//---------------------------------------------------------------------------
CFaxProp& CFaxProp::operator=(const CFaxProp& rdo)
{
   if (this==&rdo)
	  return *this;   //return if assigning to self

   CDrawText::operator=(rdo);  //assign cdrawrect part

   m_wResourceid = rdo.m_wResourceid;

   return *this;
}


//---------------------------------------------------------------------------
void CFaxProp::Draw(CDC* pDC,CDrawView* pView)
{
	ASSERT_VALID(this);

	LPTSTR draw_str;
	UINT   draw_style;
	CFont* pOldFont=NULL;
	CBrush* pOldBrush=NULL;
	CPen* pOldPen=NULL;
	CBrush brush;
	CPen pen;
	long draw_strlen;
	CRect note_rect;
	int num_pages;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	//ALLOCATE GDI OBJECTS
	if (m_bBrush) 
	{
	   if (!brush.CreateBrushIndirect(&logBrush))
	   {
		   return;
	   }
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen) 
	{
	   if (!pen.CreatePenIndirect(&logPen))
	   {
		  return;
	   }
	   pOldPen = pDC->SelectObject(&pen);
	}
	else 
	{  
		//if no bPen & printing, use NULL pen
	   if (pDC->IsPrinting()) 
	   {
		  pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	   }
	   else 
	   {   
		   //default pen -- dashdot, gray border
		  m_savepenstyle = m_logpen.lopnStyle;

		  m_logpen.lopnStyle = PS_DOT;

		  m_savepencolor = m_logpen.lopnColor;
		  m_logpen.lopnColor = COLOR_LTGRAY;
		  m_logpen.lopnWidth.x = 1;
		  m_logpen.lopnWidth.y = 1;
		  pen.CreatePenIndirect(&m_logpen);
		  pOldPen = pDC->SelectObject(&pen);
	   }
	}

	CRect rect = m_position;

	CFont* pFont = NULL;
	if (pDC->IsPrinting()) 
	{	
	   //scale font to printer size
	   LOGFONT logFont;
	   memcpy(&logFont, &m_logfont, sizeof(m_logfont));
	   pFont = new CFont;
	   logFont.lfHeight = MulDiv(m_logfont.lfHeight, pDC->GetDeviceCaps(LOGPIXELSY), 100);
	   pFont->CreateFontIndirect(&logFont);
	   pOldFont= pDC->SelectObject(pFont);

	   SnapToFont_onthefly( pView, pDC, rect );
	}
	else 
	{
	   pOldFont= pDC->SelectObject(m_pEdit->GetFont());
	}

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it below for why)
//
	if( !((theApp.m_extra_notepage == this)&&
		 (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
	{
		pDC->Rectangle( rect );
	}
////////////////////////////////

	if((m_szEditText.GetLength() > 0) || (m_wResourceid == IDS_PROP_MS_NOTE)) 
	{
	   int wx=MulDiv(m_logpen.lopnWidth.x, pDC->GetDeviceCaps(LOGPIXELSX), 100);
	   int wy=MulDiv(m_logpen.lopnWidth.y, pDC->GetDeviceCaps(LOGPIXELSY), 100);
	   int x = -wx-1;
	   int y = -wy-1;
	   pView->DocToClient(rect,pDC);
	   CPoint pW1=pDC->GetWindowOrg();
	   CPoint pW2=pW1;
	   pView->DocToClient(pW2,pDC);
	   CPoint pV=pDC->GetViewportOrg();
	   rect.InflateRect(x,y);

		if( (m_wResourceid == IDS_PROP_MS_NOPG)&&
			  theApp.m_note_wasread &&
			 (theApp.m_extrapage_count < 0)&&
			 (theApp.m_extra_notepage != NULL) )
		{
			note_rect = theApp.m_extra_notepage->m_position;
			pView->DocToClient( note_rect,pDC );
			note_rect.InflateRect(x,y);
		}

		pDC->SetMapMode(MM_TEXT);  //switch to MM_TEXT
		pDC->SetWindowOrg(pW2);
		pDC->SetViewportOrg(pV);
		pDC->SetTextColor(GetDisplayColor(m_crTextColor));
		pDC->SetBkMode(TRANSPARENT);

		draw_style = m_lStyle | DT_NOPREFIX;

				// stuff for notes
		if((m_wResourceid == IDS_PROP_MS_NOTE) && theApp.m_note_wasread)
		{
			theApp.clip_note( pDC, &draw_str, &draw_strlen, TRUE, rect );

// F I X  for 3647 /////////////
//
// Don't set m_last_note_box here! Set it in CFaxProp::Serialize
//
//						theApp.m_last_note_box = this;
		}
		else if((m_wResourceid == IDS_PROP_MS_NOPG) && theApp.m_note_wasread)
		{
			if((theApp.m_extrapage_count < 0) && (theApp.m_extra_notepage != NULL))
			{

// F I X  for 3647 /////////////
//
// PROBLEM: Wrong dc attributes are in place at this point to
//						properly calculate pages left. Must temporarialy switch
//						to extra note's attributes by recursively calling
//						Draw for the extra note with its id temporarialy set to
//						a page-no object so that it will calculate the correct
//						pages left and NOT draw anything in the process.
//
				if( theApp.m_extra_notepage == this )
				{
					// We are in the second level of recursion
					// here. This is extra notepage disguised as a
					// page-no object. Calculate pages left.
					theApp.m_extrapage_count = theApp.clip_note( pDC, &draw_str, &draw_strlen,
																 FALSE, note_rect );
				}
				else
				{
					// We are in the first level of recursion here.
					// Make extra note look like a page-no object.
					theApp.m_extra_notepage->m_wResourceid = IDS_PROP_MS_NOPG;
					theApp.m_extra_notepage->m_szEditText  = m_szEditText;

					// switch back to MM_ANISOTROPHIC so mapping will be
					// correct for Draw call
					pDC->SetMapMode(MM_ANISOTROPIC);
					pDC->SetWindowOrg(pW1);
					pDC->SetViewportOrg(pV);
					pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
					pDC->SetWindowExt(100, -100);

					// recursively call Draw to force calc of re,aomomgpages
					// left using correct font, etc.
					theApp.m_extra_notepage->Draw( pDC, pView );

					// restore mapping mode so page-no will draw correctly
					pDC->SetMapMode(MM_TEXT);
					pDC->SetWindowOrg(pW2);
					pDC->SetViewportOrg(pV);
					pDC->SetTextColor(GetDisplayColor(m_crTextColor));
					pDC->SetBkMode(TRANSPARENT);

					// restore extra note's true identity
					theApp.m_extra_notepage->m_wResourceid = IDS_PROP_MS_NOTE;
				}
			}

			// If this isn't extra notepage in disguise then
			// do normal page-no thing
			if( theApp.m_extra_notepage != this )
			{
				num_pages = _ttoi( (LPCTSTR)m_szEditText );
				num_pages += theApp.m_extrapage_count;
				m_szEditText.Format( TEXT("%i"), num_pages );
				draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
				draw_strlen = lstrlen( draw_str );
			}
////////////////////////////////
		}				 
		else //end of stuff for notes
		{
			draw_str = (LPTSTR)(LPCTSTR)m_szEditText;
			draw_strlen = lstrlen( draw_str );
		}

// F I X  for 3647 /////////////
//
// Don't draw anything if this is an extra notepage disguised as
// a page-no object.
//
// (see the code with clip_note in it above for why)
//
		if( !((theApp.m_extra_notepage == this)&&
			  (theApp.m_extra_notepage->m_wResourceid == IDS_PROP_MS_NOPG)) )
		{
			pDC->DrawText( draw_str, draw_strlen, rect, draw_style);
		}
////////////////////////////////

	   pDC->SetMapMode(MM_ANISOTROPIC); 				 //switch back to MM_ANISOTROPHIC
	   pDC->SetWindowOrg(pW1);
	   pDC->SetViewportOrg(pV);
	   pDC->SetViewportExt(pDC->GetDeviceCaps(LOGPIXELSX),pDC->GetDeviceCaps(LOGPIXELSY));
	   pDC->SetWindowExt(100, -100);
	}

	//CLEANUP GDI OBJECTS
	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}
	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}

	if (!m_bPen) 
	{
	   m_logpen.lopnColor=m_savepencolor;
	   m_logpen.lopnStyle=m_savepenstyle;
	}

	if (pOldFont)
	{
	   pDC->SelectObject(pOldFont);
	}

	if (pFont)
	{
	   delete pFont;
	}
}



//---------------------------------------------------------------------------
CDrawObj* CFaxProp::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CFaxProp* pClone = new CFaxProp(m_position,m_wResourceid);

	ASSERT_VALID(pClone);

	*pClone=*this;
	CString szCaption;
	szCaption.LoadString( m_wResourceid );
	pClone->SetText( szCaption, CDrawView::GetView() );
	if (pDoc != NULL){
		pDoc->Add(pClone);
	}
	ASSERT_VALID(pClone);
	return pClone;
}





//*********************************************************************
// CDrawLine
//*********************************************************************


//---------------------------------------------------------------------------
CDrawLine::CDrawLine()
{
}


//---------------------------------------------------------------------------
CDrawLine::~CDrawLine()
{
}

//---------------------------------------------------------------------------
CDrawLine::CDrawLine(const CRect& position)
		: CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawLine::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawRect::Serialize(ar);
}


//----------------------------------------------------------------------
void CDrawLine::NegAdjustLineForPen(CRect& rect)
{
	if (rect.top > rect.bottom) {
	   rect.top += m_logpen.lopnWidth.y / 2;
	   rect.bottom -= (m_logpen.lopnWidth.y + 1) / 2;
	}
	else {
	   rect.top -= (m_logpen.lopnWidth.y + 1) / 2;
	   rect.bottom += m_logpen.lopnWidth.y / 2;
	}

	if (rect.left > rect.right) {
	   rect.left += m_logpen.lopnWidth.x / 2;
	   rect.right -= (m_logpen.lopnWidth.x + 1) / 2;
	}
	else {
	   rect.left -= (m_logpen.lopnWidth.x + 1) / 2;
	   rect.right += m_logpen.lopnWidth.x / 2;
	}
}


//----------------------------------------------------------------------
void CDrawLine::AdjustLineForPen(CRect& rect)
{

		// added by v-randr 2/15/95
		if( (rect.left == rect.right)&&(rect.top == rect.bottom) )
				return;

	if (rect.top > rect.bottom) {
	   rect.top -= m_logpen.lopnWidth.y / 2;
	   rect.bottom += (m_logpen.lopnWidth.y + 1) / 2;
	}
	else {
	   rect.top += (m_logpen.lopnWidth.y + 1) / 2;
	   rect.bottom -= m_logpen.lopnWidth.y / 2;
	}

	if (rect.left > rect.right) {
	   rect.left -= m_logpen.lopnWidth.x / 2;
	   rect.right += (m_logpen.lopnWidth.x + 1) / 2;
	}
	else {
	   rect.left += (m_logpen.lopnWidth.x + 1) / 2;
	   rect.right -= m_logpen.lopnWidth.x / 2;
	}
}


//---------------------------------------------------------------------------
void CDrawLine::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
	  TRACE(TEXT("AWCPE: CDrawLine::Invalidate, missing View pointer\n"));
	  return;
   }

   CRect rect = m_position;

   if (rect.top > rect.bottom) {
	  rect.top += m_logpen.lopnWidth.y;
	  rect.bottom -= m_logpen.lopnWidth.y;
   }
   else {
	  rect.top -= m_logpen.lopnWidth.y;
	  rect.bottom += m_logpen.lopnWidth.y;
   }

   if (rect.left > rect.right) {
	  rect.left += m_logpen.lopnWidth.x;
	  rect.right -= m_logpen.lopnWidth.x;
   }
   else {
	  rect.left -= m_logpen.lopnWidth.x;
	  rect.right += m_logpen.lopnWidth.x;
   }

   pView->DocToClient(rect);

   if (pView->IsSelected(this)) {
		rect.left -= 4;
		rect.top -= 5;
		rect.right += 5;
		rect.bottom += 4;
   }

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
void CDrawLine::Draw(CDC* pDC,CDrawView* pView)
{
	ASSERT_VALID(this);

	CBrush* pOldBrush;
	CPen*	pOldPen;
	CBrush	brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&logBrush))
	{
		return;
	}

	CPen pen;
	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
	   pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
	   pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	CRect rect = m_position;

	AdjustLineForPen(rect);

	pDC->MoveTo( rect.TopLeft() );
	pDC->LineTo( rect.BottomRight() );

	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}
}



//---------------------------------------------------------------------------
int CDrawLine::GetHandleCount()
{
	ASSERT_VALID(this);

	return 2;
}


//---------------------------------------------------------------------------
// returns center of handle in logical coordinates
//---------------------------------------------------------------------------
CPoint CDrawLine::GetHandle(int nHandle)
{
	ASSERT_VALID(this);

	if (nHandle == 2)
	   nHandle = 5;

	return CDrawRect::GetHandle(nHandle);
}


//---------------------------------------------------------------------------
HCURSOR CDrawLine::GetHandleCursor(int nHandle)
{
	ASSERT_VALID(this);

	if (nHandle == 2)
		nHandle = 5;

	return CDrawRect::GetHandleCursor(nHandle);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawLine::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawLine* pClone = new CDrawLine(m_position);

	*pClone=*this;

	ASSERT_VALID(pClone);

	if (pDoc != NULL)
		pDoc->Add(pClone);

	ASSERT_VALID(pClone);
	return pClone;
}

// rearranged by v-randr 2/15/95
#define PI (3.14159)
#define ONESIXTH_PI   (PI/6)
#define ONETHIRD_PI   (PI/3)
#define ONEHALF_PI	  (PI/2)
#define ONEFORTH_PI   (PI/4)
#define THREEFORTH_PI (PI*3/4)
#define TWOTHIRD_PI   (PI*2/3)
#define FIVESIXTH_PI  (PI*5/6)


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawLine::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,  UINT uiShiftDraw /*=0*/)
{
	ASSERT_VALID(this);

	CRect position = m_position;

	if (nHandle == 2)
		nHandle = 5;

	switch (nHandle) {
	case 1:
		if (uiShiftDraw & SHIFT_DRAW) {
		   if (uiShiftDraw & SHIFT_TOOL) {
			   BOOL bNegR=FALSE;
						   double radian = atan2((double)(point.y-position.bottom),(double)(point.x-position.right));
						   if (radian < 0) {
							  radian *= -1;
								  bNegR=TRUE;
						   }
						   if (radian >= 0 && radian < ONESIXTH_PI) {
				   position.left = point.x;
				   position.top = (long) (tan(0.0f) * (point.x - position.right) + position.bottom ) - 1;
						   }
						   else
						   if (radian >= ONESIXTH_PI && radian < ONETHIRD_PI) {
							   if (radian >= ONESIXTH_PI && radian < ONEFORTH_PI) {
					  position.left = point.x;
					  position.top = (long) (tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI)) * (point.x - position.right) + position.bottom );
								   }
								   else {
					  position.top = point.y;
					  position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEFORTH_PI:ONEFORTH_PI))  + position.right );
								   }
						   }
						   else
						   if (radian >= ONETHIRD_PI && radian < TWOTHIRD_PI) {
				   position.top = point.y;
				   position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-ONEHALF_PI:ONEHALF_PI))  + position.right);
						   }
						   else
						   if (radian >= TWOTHIRD_PI && radian < FIVESIXTH_PI) {
							   if (radian >= TWOTHIRD_PI && radian < THREEFORTH_PI) {
					  position.top = point.y;
					  position.left = (long) ( (point.y - position.bottom) / tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI))  + position.right );
								   }
								   else {
					  position.left = point.x;
					  position.top = (long) (tan(((bNegR)?-THREEFORTH_PI:THREEFORTH_PI)) * (point.x - position.right) + position.bottom );
								   }
						   }
						   else
						   if (radian >= FIVESIXTH_PI && radian < PI) {
				   position.left = point.x;
				   position.top = (long) (tan(PI) * (point.x - position.right) + position.bottom -1);
						   }

						// make sure rect isn't too skinny, added 2/14/95 by v-randr
						if( CDrawTool::c_down != point )
								{
								if( (position.left == position.right)&&
										(position.top != position.bottom) )
										position.left = position.right-1;
								}

			   }
				   else {
						   BOOL bNegR=FALSE;
						   double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
						   if (radianTL < 0) {
							  radianTL *= -1;
								  bNegR=TRUE;
						   }

			   if (pView->m_bShiftSignal ) {
							   TRACE(TEXT("shift signaled--slope is being calculated\n"));
						   if (position.left - position.right != 0) {
								  float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
									  if (temp>0)
										 temp += (float)0.005;
									  else
										 temp -= (float)0.005;
									  temp *= 100;
					 m_iSlope = (int)temp;
				  }
							  m_iB = (position.bottom*100 - m_iSlope*position.right);
								  pView->m_bShiftSignal=FALSE;
						   }

						   if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) {
							   position.left = point.x;
								   int temp = position.left* m_iSlope + m_iB;
								   if (temp>0)
									  temp += 50;
								   else
									  temp -= 50;
							   position.top = temp/100;
						   }
						   else {
							  position.top = point.y;
								  if (m_iSlope != 0) {
								  float temp = (position.top*100 - m_iB) / (float)m_iSlope;
									  if (temp>0)
										temp += (float).5;
									  else
										temp -= (float).5;
								  position.left = (long) temp;
								  }
						   }
//			   TRACE("slope(%i), yint(%i)\n",m_iSlope, m_iB);
				   }
		}
				else {
		   CDrawRect::MoveHandleTo(nHandle, point, pView);
				   return;
				}
		break;
	case 5:
		if (uiShiftDraw & SHIFT_DRAW) {
						   BOOL bNegR=FALSE;
						   double radianTL = atan2((double)(position.top-position.bottom),(double)(position.left-position.right));
						   if (radianTL < 0) {
							  radianTL *= -1;
								  bNegR=TRUE;
						   }

			   if (pView->m_bShiftSignal ) {
							   TRACE(TEXT("shift signaled--slope is being calculated\n"));
						   if (position.left - position.right != 0) {
								  float temp = (position.top - position.bottom)  / (float) (position.left - position.right);
									  if (temp>0)
										 temp += (float)0.005;
									  else
										 temp -= (float)0.005;
									  temp *= 100;
					 m_iSlope = (int)temp;
				  }
							  m_iB = (position.bottom*100 - m_iSlope*position.right);
								  pView->m_bShiftSignal=FALSE;
						   }

						   if ( (radianTL >= 0 && radianTL < ONEFORTH_PI) || (radianTL >= THREEFORTH_PI && radianTL < PI)) {
							   position.right = point.x;
								   int temp = position.right* m_iSlope + m_iB;
								   if (temp>0)
									  temp += 50;
								   else
									  temp -= 50;
							   position.bottom = temp/100;
						   }
						   else {
							  position.bottom = point.y;
								  if (m_iSlope != 0) {
								  float temp = (position.bottom*100 - m_iB) / (float)m_iSlope;
									  if (temp>0)
										temp += (float).5;
									  else
										temp -= (float).5;
								  position.right = (long) temp;
								  }
						   }
			}
				else {
		   CDrawRect::MoveHandleTo(nHandle, point, pView);
				   return;
				}
		break;

	default:
		CDrawRect::MoveHandleTo(nHandle, point, pView);
		return;
		}

	MoveTo(position, pView);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawLine::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);

		CRect rectT = rect;
		rectT.NormalizeRect();

	if (bShortCut) {
		CRect fixed = m_position;
		fixed.NormalizeRect();
		return (!(rectT & fixed).IsRectEmpty() );
	}

		CDrawView* pView=CDrawView::GetView();
	CClientDC dc(pView);

	dc.BeginPath();
		Draw(&dc,pView);   //draw into GDI path
		dc.EndPath();

	CPen pen;
		LOGPEN lp=m_logpen;
	pen.CreatePenIndirect(&lp);
	CPen* oldpen= dc.SelectObject(&pen);
	dc.WidenPath();
	dc.SelectObject(oldpen);

	HRGN hRegion = NULL;
	BOOL bRes = FALSE;

	hRegion = ::PathToRegion(dc.GetSafeHdc());
	if (hRegion)
	{
		bRes = ::RectInRegion(hRegion,rectT);
		::DeleteObject(hRegion);
	}
	return bRes;
}



//*********************************************************************
// CDrawRoundRect
//*********************************************************************


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::~CDrawRoundRect()
{
}


//----------------------------------------------------------------------
CDrawRoundRect::CDrawRoundRect(const CRect& position)
		: CDrawRect(position)
{
	m_roundness.x = 16;
	m_roundness.y = 16;
}


//----------------------------------------------------------------------
void CDrawRoundRect::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CDrawRect::Serialize(ar);
	if (ar.IsStoring())
	{
		ar << m_roundness;
	}
	else
	{
		ar >> m_roundness;
	}
}



//----------------------------------------------------------------------
void CDrawRoundRect::Draw(CDC* pDC,CDrawView* pView)
{
	ASSERT_VALID(this);

	CBrush* pOldBrush;
	CPen*	pOldPen;
	CBrush	brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&logBrush))
	{
		return;
	}

	CPen pen;

	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
	   pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
	   pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	pDC->RoundRect(m_position, m_roundness);

	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}
}



//----------------------------------------------------------------------
// returns center of handle in logical coordinates
CPoint CDrawRoundRect::GetHandle(int nHandle)
{
	ASSERT_VALID(this);

	if (nHandle == 9) {
		CRect rect = m_position;
		rect.NormalizeRect();
		CPoint point = rect.BottomRight();
		point.x -= m_roundness.x / 2;
		point.y -= m_roundness.y / 2;
		return point;
	}

	return CDrawRect::GetHandle(nHandle);
}

//----------------------------------------------------------------------
HCURSOR CDrawRoundRect::GetHandleCursor(int nHandle)
{
	ASSERT_VALID(this);

	if (nHandle == 9)
		return AfxGetApp()->LoadStandardCursor(IDC_SIZE);

	return CDrawRect::GetHandleCursor(nHandle);
}


//----------------------------------------------------------------------
void CDrawRoundRect::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView,	UINT uiShiftDraw /*=0*/)
{
	ASSERT_VALID(this);

	if (nHandle == 9) {
		CRect rect = m_position;
		rect.NormalizeRect();
		if (point.x > rect.right - 1)
				point.x = rect.right - 1;
		else if (point.x < rect.left + rect.Width() / 2)
				point.x = rect.left + rect.Width() / 2;
		if (point.y > rect.bottom - 1)
				point.y = rect.bottom - 1;
		else if (point.y < rect.top + rect.Height() / 2)
				point.y = rect.top + rect.Height() / 2;
		m_roundness.x = 2 * (rect.right - point.x);
		m_roundness.y = 2 * (rect.bottom - point.y);
		m_pDocument->SetModifiedFlag();
		Invalidate();
		return;
	}

	CDrawRect::MoveHandleTo(nHandle, point, pView, uiShiftDraw);
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawRoundRect::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);

	CRect rectT = rect;
	rectT.NormalizeRect();

	CRect fixed = m_position;
	fixed.NormalizeRect();

	if( bShortCut ){
		return !(fixed & rectT).IsRectEmpty();
	}

	if ((rectT & fixed).IsRectEmpty())
		return FALSE;

	CRgn rgn;
	rgn.CreateRoundRectRgn(fixed.left, fixed.top, fixed.right, fixed.bottom,
		m_roundness.x, m_roundness.y);

	return rgn.RectInRegion(fixed);
}


//---------------------------------------------------------------------------
CDrawRoundRect& CDrawRoundRect::operator=(const CDrawRoundRect& rdo)
{
   if (this==&rdo)
	  return *this;   //return if assigning to self

   CDrawRect::operator=(rdo);  //assign cdrawrect part

   m_roundness = rdo.m_roundness;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawRoundRect::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawRoundRect* pClone = new CDrawRoundRect(m_position);

	ASSERT_VALID(pClone);

	*pClone=*this;

	if (pDoc != NULL)
		pDoc->Add(pClone);

	ASSERT_VALID(pClone);
	return pClone;
}


//*********************************************************************
// CDrawEllipse
//*********************************************************************

//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse()
{
}

//----------------------------------------------------------------------
CDrawEllipse::~CDrawEllipse()
{
}


//----------------------------------------------------------------------
CDrawEllipse::CDrawEllipse(const CRect& position)
		: CDrawRect(position)
{
}


//----------------------------------------------------------------------
void CDrawEllipse::Serialize(CArchive& ar)
{
	CDrawRect::Serialize(ar);
}


//---------------------------------------------------------------------------
CDrawObj* CDrawEllipse::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawEllipse* pClone = new CDrawEllipse(m_position);

	ASSERT_VALID(pClone);

	*pClone=*this;

	if (pDoc != NULL)
		pDoc->Add(pClone);

	ASSERT_VALID(pClone);
	return pClone;
}


//----------------------------------------------------------------------
void CDrawEllipse::Draw(CDC* pDC,CDrawView* pView)
{
	ASSERT_VALID(this);
	CBrush* pOldBrush;
	CPen* pOldPen;
	CBrush brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&logBrush))
	{
		return;
	}

	CPen pen;
	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
	   pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
	   pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	pDC->Ellipse(m_position);

	if (pOldBrush)
	{
	   pDC->SelectObject(pOldBrush);
	}

	if (pOldPen)
	{
	   pDC->SelectObject(pOldPen);
	}
}


//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawEllipse::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);

	CRect rectT = rect;
	rectT.NormalizeRect();

	CRect fixed = m_position;
	fixed.NormalizeRect();
		CRgn rgn;
	if( bShortCut ){
		return !(fixed & rectT).IsRectEmpty();
	}
	if ((rectT & fixed).IsRectEmpty())
		return FALSE;

	rgn.CreateEllipticRgnIndirect(fixed);

	return rgn.RectInRegion(fixed);
}




//--------------------------------------------------------------------------
// CDrawPoly
//--------------------------------------------------------------------------

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly()
{
	m_points = NULL;
	m_nPoints = 0;
	m_nAllocPoints = 0;
}

//---------------------------------------------------------------------------
CDrawPoly::CDrawPoly(const CRect& position)
		: CDrawObj(position)
{
	m_points = NULL;
	m_nPoints = 0;
	m_nAllocPoints = 0;
	m_bPen = TRUE;
	m_bBrush = FALSE;
}

//---------------------------------------------------------------------------
CDrawPoly::~CDrawPoly()
{
	if (m_points != NULL)
	   delete m_points;
}


//---------------------------------------------------------------------------
void CDrawPoly::Serialize( CArchive& ar )
{
	int i;
	CDrawObj::Serialize( ar );
	if( ar.IsStoring() ) {
		ar << (WORD) m_nPoints;
		ar << (WORD) m_nAllocPoints;
		for (i = 0;i< m_nPoints; i++)
				ar << m_points[i];
	}
	else  {
		WORD wTemp;
		ar >> wTemp; m_nPoints = wTemp;
		ar >> wTemp; m_nAllocPoints = wTemp;
		m_points = NewPoints(m_nAllocPoints);
		for (i = 0;i < m_nPoints; i++)
				ar >> m_points[i];
	}
}

//---------------------------------------------------------------------------
void CDrawPoly::Draw(CDC* pDC,CDrawView*)
{
	ASSERT_VALID(this);

	CBrush brush;

	LOGBRUSH logBrush = m_logbrush;
	LOGPEN	 logPen   = m_logpen;

	if( !pDC->IsPrinting() )
	{
		logBrush.lbColor = GetDisplayColor(logBrush.lbColor);
		logPen.lopnColor = GetDisplayColor(logPen.lopnColor);
	}

	if (!brush.CreateBrushIndirect(&m_logbrush))
	{
		return;
	}

	CPen pen;
	if (!pen.CreatePenIndirect(&logPen))
	{
		return;
	}

	CBrush* pOldBrush;
	CPen* pOldPen;

	if (m_bBrush)
	{
	   pOldBrush = pDC->SelectObject(&brush);
	}
	else
	{
	   pOldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);
	}

	if (m_bPen)
	{
		pOldPen = pDC->SelectObject(&pen);
	}
	else
	{
		pOldPen = (CPen*)pDC->SelectStockObject(NULL_PEN);
	}

	pDC->Polygon(m_points, m_nPoints);

	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);
}


//---------------------------------------------------------------------------
// position must be in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveTo(const CRect& position, CDrawView* pView)
{
	ASSERT_VALID(this);
	if (position == m_position)
		return;

	Invalidate();

	for (int i = 0; i < m_nPoints; i += 1)	{
		m_points[i].x += position.left - m_position.left;
		m_points[i].y += position.top - m_position.top;
	}

	m_position = position;

		Invalidate();

	m_pDocument->SetModifiedFlag();
}


//---------------------------------------------------------------------------
int CDrawPoly::GetHandleCount()
{
	return m_nPoints;
}


//---------------------------------------------------------------------------
CPoint CDrawPoly::GetHandle(int nHandle)
{
	ASSERT_VALID(this);

	ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
	return m_points[nHandle - 1];
}


//---------------------------------------------------------------------------
// return rectange of handle in logical coords
//---------------------------------------------------------------------------
CRect CDrawPoly::GetHandleRect(int nHandleID, CDrawView* pView)
{
	ASSERT_VALID(this);
	ASSERT(pView != NULL);

	CRect rect;
	// get the center of the handle in logical coords
	CPoint point = GetHandle(nHandleID);
	// convert to client/device coords
	pView->DocToClient(point);
	// return CRect of handle in device coords
	rect.SetRect(point.x-3, point.y-3, point.x+3, point.y+3);
	pView->ClientToDoc(rect);

	return rect;
}



//---------------------------------------------------------------------------
int CDrawPoly::HitTest(CPoint point, CDrawView* pView, BOOL bSelected)
{
	ASSERT_VALID(this);
	ASSERT(pView != NULL);

	if (bSelected) {
		int nHandleCount = GetHandleCount();
		for (int nHandle = 1; nHandle <= nHandleCount; nHandle += 1) {
			// GetHandleRect returns in logical coords
			CRect rc = GetHandleRect(nHandle,pView);
			if (point.x >= rc.left && point.x < rc.right &&
				point.y <= rc.top && point.y > rc.bottom)
				return nHandle;
		}
	}
	else  {
	   if (point.x >= m_position.left && point.x < m_position.right &&
			 point.y <= m_position.top && point.y > m_position.bottom)
		  return 1;
	}
	return 0;
}




//---------------------------------------------------------------------------
HCURSOR CDrawPoly::GetHandleCursor(int nHandle )
{
	CPoint p1;
	LPCTSTR id;
	CPoint p2;

	if (nHandle==1)
	  p1 = m_points[m_nPoints - 1];
		else
	  p1 = m_points[nHandle - 2];

	if (nHandle==m_nPoints)
	  p2 = m_points[0];
		else
	  p2 = m_points[nHandle];

	float m =  ((p2.x-p1.x)!=0) ? (p2.y-p1.y) / ((float)(p2.x-p1.x)) : 9999;

	if (m>=3 || m<=-3)
	   id = IDC_SIZEWE;
		else
	   if (m>.3)
		  id = IDC_SIZENWSE;
	   else
			  if (m<-.3)
			 id = IDC_SIZENESW;
			  else
			 id = IDC_SIZENS;

//	  TRACE("CDrawPoly::GetHandleCursor, handle: %i, P1(%i,%i), P2(%i,%i), slope: %3.2f\n",nHandle,p1.x,p1.y,p2.x,p2.y,m);

	return AfxGetApp()->LoadStandardCursor(id);
//	  return AfxGetApp()->LoadStandardCursor(IDC_ARROW);
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::MoveHandleTo(int nHandle, CPoint point, CDrawView* pView, UINT uiShiftDraw /*=0*/)
{
	ASSERT_VALID(this);
	ASSERT(nHandle >= 1 && nHandle <= m_nPoints);
	if (m_points[nHandle - 1] == point)
		return;

	m_points[nHandle - 1] = point;
	RecalcBounds(pView);

	Invalidate();
	m_pDocument->SetModifiedFlag();
}

//---------------------------------------------------------------------------
// rect must be in logical coordinates
//---------------------------------------------------------------------------
BOOL CDrawPoly::Intersects(const CRect& rect, BOOL bShortCut /*=FALSE*/)
{
	ASSERT_VALID(this);
	CRgn rgn;
	if( bShortCut ){
		return TRUE ; // Called by CDrawDoc::Draw().  Skip the test and just Draw().
	}
	rgn.CreatePolygonRgn(m_points, m_nPoints, ALTERNATE);
	return rgn.RectInRegion(rect);
}


//---------------------------------------------------------------------------
CDrawPoly& CDrawPoly::operator=(const CDrawPoly& rdo)
{
   if (this==&rdo)
	  return *this;   //return if assigning to self

   CDrawObj::operator=(rdo);  //assign cobject part

   m_points = NewPoints(rdo.m_nAllocPoints);
   memcpy(m_points, rdo.m_points, sizeof(CPoint) * rdo.m_nPoints);
   m_nAllocPoints = rdo.m_nAllocPoints;
   m_nPoints = rdo.m_nPoints;

   return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawPoly::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	CDrawPoly* pClone = new CDrawPoly(m_position);

	ASSERT_VALID(pClone);

	TRY
	{
		*pClone=*this;
		if (pDoc != NULL)
		{
			pDoc->Add(pClone);
		}
		ASSERT_VALID(pClone);
	}
	CATCH_ALL(e)
	{
		//
		// Catch memory faults on operator=
		// Free memory and continue with throwing the exception
		//
		delete (pClone);
		pClone = NULL;
		THROW_LAST();
	}
	END_CATCH_ALL
	return pClone;
}


//---------------------------------------------------------------------------
// point is in logical coordinates
//---------------------------------------------------------------------------
void CDrawPoly::AddPoint(const CPoint& point, CDrawView* pView)
{
	ASSERT_VALID(this);
	if (m_nPoints == m_nAllocPoints) {
		CPoint* newPoints = NewPoints(m_nAllocPoints + 10);
		if (m_points != NULL) {
			 memcpy(newPoints, m_points, sizeof(CPoint) * m_nAllocPoints);
			 delete m_points;
		}
		m_points = newPoints;
		m_nAllocPoints += 10;
	}

	if (m_nPoints == 0 || m_points[m_nPoints - 1] != point) {
		m_points[m_nPoints++] = point;
		if (!RecalcBounds(pView)) {
			Invalidate();
		}
		m_pDocument->SetModifiedFlag();
	}
}


//---------------------------------------------------------------------------
CPoint* CDrawPoly::NewPoints(int nPoints)
{
	return (CPoint*)new BYTE[nPoints * sizeof(CPoint)];
}


//---------------------------------------------------------------------------
BOOL CDrawPoly::RecalcBounds(CDrawView* pView)
{
	ASSERT_VALID(this);

	if (m_nPoints == 0)
		return FALSE;

	CRect bounds(m_points[0], CSize(0, 0));
	for (int i = 1; i < m_nPoints; ++i) {
		if (m_points[i].x < bounds.left)
				bounds.left = m_points[i].x;
		if (m_points[i].x > bounds.right)
				bounds.right = m_points[i].x;
		if (m_points[i].y < bounds.top)
				bounds.top = m_points[i].y;
		if (m_points[i].y > bounds.bottom)
				bounds.bottom = m_points[i].y;
	}

	if (bounds == m_position)
		return FALSE;

	Invalidate();

	m_position = bounds;

	Invalidate();

	return TRUE;
}


BOOL CDrawOleObj::c_bShowItems = FALSE;


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj() : m_extent(0,0)
{
	m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
CDrawOleObj::CDrawOleObj(const CRect& position)
		: CDrawObj(position), m_extent(0,0)
{
	m_pClientItem = NULL;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Serialize( CArchive& ar )
{
	ASSERT_VALID(this);

	CDrawObj::Serialize(ar);

	if (ar.IsStoring()) {
		ar << m_extent;
		ar << m_pClientItem;
	}
	else  {
		ar >> m_extent;
		ar >> m_pClientItem;
		m_pClientItem->m_pDrawObj = this;
	}
}


//---------------------------------------------------------------------------
CDrawOleObj& CDrawOleObj::operator=(const CDrawOleObj& rdo)
{
	CDrawItem* pItem = NULL;

	if (this==&rdo)
	{
		return *this;	//return if assigning to self
	}

	CDrawObj::operator=(rdo);  //assign cdrawobj part

	pItem = new CDrawItem(m_pDocument, this);
	ASSERT_VALID(pItem);
	TRY  
	{
		if (!pItem->CreateCloneFrom(rdo.m_pClientItem))
		{
			AfxThrowMemoryException();
		}
		m_pClientItem = pItem;
	}
	CATCH_ALL(e) 
	{
		pItem->Delete();
		delete pItem;
		m_pClientItem = NULL;
		THROW_LAST();
	}
	END_CATCH_ALL
	return *this;
}


//---------------------------------------------------------------------------
CDrawObj* CDrawOleObj::Clone(CDrawDoc* pDoc)
{
	ASSERT_VALID(this);

	AfxGetApp()->BeginWaitCursor();

	CDrawOleObj* pClone=NULL;

	TRY 
	{
		pClone = new CDrawOleObj(m_position);
		ASSERT_VALID(pClone);
		*pClone=*this;
		if (pDoc != NULL)
		{
		   pDoc->Add(pClone);
		}
	}
	CATCH_ALL(e) 
	{
		delete pClone;
		AfxGetApp()->EndWaitCursor();
		THROW_LAST();
	}
	END_CATCH_ALL

	AfxGetApp()->EndWaitCursor();

	return pClone;
}


//---------------------------------------------------------------------------
void CDrawOleObj::Draw(CDC* pDC,CDrawView*)
{
	ASSERT_VALID(this);

	CDrawItem* pItem = m_pClientItem;
	if (pItem != NULL) 
	{
		pItem->Draw(pDC, m_position, DVASPECT_CONTENT);

		if (!pDC->IsPrinting()) 
		{
			// use a CRectTracker to draw the standard effects
			CRectTracker tracker;
			tracker.m_rect = m_position;
			pDC->LPtoDP(tracker.m_rect);

			if (c_bShowItems) 
			{
				// put correct border depending on item type
				if (pItem->GetType() == OT_LINK)
				{
					tracker.m_nStyle |= CRectTracker::dottedLine;
				}
				else
				{
					tracker.m_nStyle |= CRectTracker::solidLine;
				}
		  }

		  // put hatching over the item if it is currently open
		  if (pItem->GetItemState() == COleClientItem::openState ||
			  pItem->GetItemState() == COleClientItem::activeUIState) 
		  {
			 tracker.m_nStyle |= CRectTracker::hatchInside;
		  }
		  tracker.Draw(pDC);
		}
	}
}


//---------------------------------------------------------------------------
void CDrawOleObj::Invalidate()
{
   CDrawView* pView=CDrawView::GetView();
   if (pView==NULL) {
	  TRACE(TEXT("AWCPE: CDrawOleObj::Invalidate, missing View pointer\n"));
	  return;
   }
   CRect rect = m_position;
   pView->DocToClient(rect);
   if (pView->IsSelected(this)) {
		rect.left -= 4;
		rect.top -= 5;
		rect.right += 5;
		rect.bottom += 4;
   }
   rect.InflateRect(1, 1); // handles CDrawOleObj objects

   pView->InvalidateRect(rect, FALSE);
}


//---------------------------------------------------------------------------
void CDrawOleObj::OnDblClk(CDrawView* pView)
{
	AfxGetApp()->BeginWaitCursor();
	m_pClientItem->DoVerb(
		GetKeyState(VK_CONTROL) < 0 ? OLEIVERB_OPEN : OLEIVERB_PRIMARY,
		pView);
	AfxGetApp()->EndWaitCursor();

}


//---------------------------------------------------------------------------
// position is in logical
//---------------------------------------------------------------------------
void CDrawOleObj::MoveTo(const CRect& position, CDrawView* pView)
{
	ASSERT_VALID(this);

	if (position == m_position)
		return;

	// call base class to update position
	CDrawObj::MoveTo(position, pView);

	// update position of in-place editing session on position change
	if (m_pClientItem->IsInPlaceActive())
		m_pClientItem->SetItemRects();
}

//----------------------------------------------------------------------------------------------

CMoveContext::CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg) : m_rc(rc), m_pObj(pObj)
{
	m_points=NULL;

		if ( pObj->IsKindOf(RUNTIME_CLASS(CDrawPoly)) && bPointChg) {
			 CDrawPoly* pPoly = (CDrawPoly*)pObj;
		 m_points = pPoly->NewPoints(pPoly->m_nAllocPoints);
		 memcpy(m_points, pPoly->m_points, sizeof(CPoint) * pPoly->m_nPoints);
	}
}

DWORD
DTStyleToESStyle(DWORD dwDTStyle)
/*
	Translate DrawText() alignment style to Edit Styles
*/
{
	DWORD dwESStyle = 0;

	ASSERT(((dwDTStyle & DT_RIGHT) && (dwDTStyle & DT_CENTER)) == FALSE);

	if(dwDTStyle & DT_RIGHT)
	{
		dwESStyle = ES_RIGHT;
	}
	else if(dwDTStyle & DT_CENTER)
	{
		dwESStyle = ES_CENTER;
	}
	else
	{
		dwESStyle = ES_LEFT;
	}

	return dwESStyle;
}

DWORD
DTStyleToEXStyle(DWORD dwDTStyle)
/*
	Translate DrawText() alignment and direction style to Extended Window Styles
*/
{
	DWORD dwEXStyle = 0;

	//
	// Translate the alignment
	//
	if(dwDTStyle & DT_RIGHT)
	{
		dwEXStyle = WS_EX_RIGHT;
	}
	else
	{
		dwEXStyle = WS_EX_LEFT;
	}

	//
	// Translate the reading direction
	//
	if(dwDTStyle & DT_RTLREADING)
	{
		dwEXStyle |= WS_EX_RTLREADING;
	}
	else
	{
		dwEXStyle |= WS_EX_LTRREADING;
	}

	return dwEXStyle;
}

COLORREF 
GetDisplayColor(
	COLORREF color
)
/*
	Translate the actual color to the dysplay color.

	Black and White are auto colors and translated to the COLOR_WINDOWTEXT and COLOR_WINDOW.
	The rest of the colors are user defined and does not changed.
*/
{
	if(COLOR_WHITE == color)
	{
		return GetSysColor(COLOR_WINDOW);
	}
	else if(COLOR_BLACK == color)
	{
		return GetSysColor(COLOR_WINDOWTEXT);
	}
	else
	{
		return color;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\faxprop.h ===
//=============================================================================
// FAXPROP.h
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=============================================================================
#ifndef __FAXPROP_H__
#define __FAXPROP_H__


//--------------------------------------------------------------------------
class CProp
{
public:
   WORD m_wR_CAPT;
   WORD m_wR_PROP;
   CString m_szPropName;
   CString m_szCaption;
   WORD m_wPropDefLen;
   WORD m_wPropDefLines;
   ULONG m_lPropIndex;
   CProp(WORD wR_PROP, WORD wPropDefLen, WORD wPropDefLines,WORD wR_CAPT,
     ULONG lPropIndex);
};

/*
class CFaxPropMap;

class CFaxPropMapIterator
{
   CFaxPropMapIterator(CFaxPropMap& faxmap);
private:
   CFaxPropMap* currentlink;
   CFaxPropMap* prevlink
   CFaxPropMap& theMap;
}
*/


//--------------------------------------------------------------------------
class CFaxPropMap
{
public:
   static CMapWordToPtr m_PropMap;

//   CFaxProp();
//   void GetPropValue(WORD propid, CString& szPropValue);
   void GetCaption(WORD propid, CString& szCaption);
//   void GetPropName(WORD propid, CString& szPropName);
   void GetPropString(WORD propid, CString& szPropName);
   WORD GetPropDefLines(WORD propid);
   WORD GetPropDefLength(WORD propid);

protected:
//   friend class CFaxPropMapIterator;
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
	void get_message_note( void );
};



#endif   //#ifndef __FAXPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpevw.cpp ===
//===========================================================================
// CPEVW.cpp : implementation of the CDrawView class
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main view class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modifed by Rand Renfroe (v-randr)
// 2/15/95      Disabled removing offpage objects in CDrawView::SetPageSize
// 2/21         Changed OnSpaceAcross,Down to use floating point
// 3/2          Added throw to EndDoc in render
// 3/9          Added msg-on-cpe stuff
//
//===========================================================================
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"

#include <dos.h>
#include <direct.h>
#include <afxpriv.h>
#include <math.h>
#include <winspool.h>
#include <faxreg.h>
#include <dlgprnt2.cpp>
#include <faxutil.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CENTER_WHITE_AREA  1 // tonyle wants the white area centered with half the gray on each side.
#define CENTERING_FUDGE_FACTOR 22 // Number of logical units we are consistently off-center by.
#define USING_PAPER_COLOR 0

const int G_ISPACING = 10;     //in LU (MM_LOENGLISH)

//
// private clipboard format (list of Draw objects).
// These could contain LOGFONTA or LOGFONTW structures a-juliar 9-6-96.
//

#ifdef UNICODE
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object W"));
#else
CLIPFORMAT CDrawView::m_cfDraw =
        (CLIPFORMAT)::RegisterClipboardFormat(TEXT("AWCPE Draw Object A"));
#endif

IMPLEMENT_DYNCREATE(CDrawView, CScrollView)

//--------------------------------------------------------------------------
CDrawView::CDrawView()
{
    m_bHighContrast = IsHighContrast();
//
//  Set m_dwEfcFields to the DWORD value of a registry key if it exists.
//
    HKEY hKey ;
    DWORD dwType ;
    m_dwEfcFields = 0 ;
    DWORD dwRegKeyVal ;
    DWORD dwsz = sizeof(DWORD)/sizeof(BYTE);
    hKey=0;

    if ( ERROR_SUCCESS == ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                          REGKEY_FAX_SETUP,
                                          0,
                                          KEY_READ,
                                          &hKey)) 
    {
        if ( ERROR_SUCCESS == ::RegQueryValueEx(hKey,
                                                TEXT("EFC_CoverPageFields"),
                                                0,
                                                &dwType,
                                                (LPBYTE)&dwRegKeyVal,
                                                &dwsz)) 
        {
            if ( REG_DWORD == dwType )
            {
                        m_dwEfcFields = dwRegKeyVal ;
            }         
        }
   }


   m_bGridLines= FALSE;
#ifdef GRID
   m_bSnapToGrid=FALSE;
#endif

#ifdef GRID
   m_iGridSize=GRID_LARGE;
   m_hbitmap.LoadBitmap(ID_GRIDDOT);
   m_hbitmap.GetObject(sizeof(BITMAP),(LPSTR)&m_bm);
#endif
   m_penSolid.CreatePen(PS_SOLID, 1, COLOR_LTBLUE);
   m_penDot.CreatePen(PS_DOT, 1, COLOR_LTBLUE);

   m_pObjInEdit=NULL;
   m_bFontChg=FALSE;
   m_bKU=TRUE;
   m_bCanUndo = FALSE ;
   if (hKey) {
       RegCloseKey(hKey);
   }
}


//--------------------------------------------------------------------------
CDrawView::~CDrawView()
{
}

//--------------------------------------------------------------------------
BOOL CDrawView::PreCreateWindow(CREATESTRUCT& cs)
{
    ASSERT(cs.style & WS_CHILD);
    if (cs.lpszClass == NULL)
    {
        cs.lpszClass = AfxRegisterWndClass(CS_DBLCLKS);
    }

    CScrollView::PreCreateWindow(cs);

    return TRUE;
}


//--------------------------------------------------------------------------
CDrawView* CDrawView::GetView()
{
    try {
    
    CFrameWnd* pFrame = (CFrameWnd*) AfxGetMainWnd();

    if (!pFrame)
       return NULL;

    CView* pView = pFrame->GetActiveView();
    if (!pView)
       return NULL;

    if (!pView->IsKindOf(RUNTIME_CLASS(CDrawView)))
       return NULL;

    return (CDrawView*) pView;

    } catch(...) {
        ;
    }

    return NULL;

}


//------------------------------------------------------------
void CDrawView::OnUpdate(CView* , LPARAM lHint, CObject* pHint)
{
   switch (lHint)
   {
   case HINT_UPDATE_WINDOW:    // redraw entire window
        Invalidate(FALSE);
        break;

   case HINT_UPDATE_DRAWOBJ:   // a single object has changed
        ((CDrawObj*)pHint)->Invalidate();
        break;

   case HINT_UPDATE_SELECTION: // an entire selection has changed
        {
            CObList* pList = pHint != NULL ? (CObList*)pHint : &m_selection;
            POSITION pos = pList->GetHeadPosition();
            while (pos != NULL)
            {
                ((CDrawObj*)pList->GetNext(pos))->Invalidate();
            }
        }
        break;

   case HINT_DELETE_SELECTION: // an entire selection has been removed
        if (pHint != &m_selection)
        {
            CObList* pList = (CObList*)pHint;
            POSITION pos = pList->GetHeadPosition();
            while (pos != NULL)     
            {
                CDrawObj* pObj = (CDrawObj*)pList->GetNext(pos);
                pObj->Invalidate();
                Remove(pObj);   // remove it from this view's selection
            }
        }
        break;

   case HINT_UPDATE_OLE_ITEMS:
        {
            CDrawDoc* pDoc = GetDocument();
            POSITION pos = pDoc->GetObjects()->GetHeadPosition();
            while (pos != NULL)
            {
                CDrawObj* pObj = (CDrawObj*)pDoc->GetObjects()->GetNext(pos);
                if (pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
                {
                    pObj->Invalidate();
                }
            }
        }
        break;

   default:
        ASSERT(FALSE);
        break;
   }

}


//--------------------------------------------------------------------------
void CDrawView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
   pDC->SetWindowOrg(0,0);
   CScrollView::OnPrepareDC(pDC, pInfo);
   DoPrepareDC(pDC);
}

//--------------------------------------------------------------------------
// This method created to resolve bug w/ MFC caused by /SUBSYSTEM:Windows,4.0
//--------------------------------------------------------------------------
void CDrawView::DoPrepareDC(CDC* pDC)
{
   CSize extents;

   if (pDC==NULL)
      return;



   // mapping mode is MM_ANISOTROPIC
   // these extents setup a mode similar to MM_LOENGLISH
   // MM_LOENGLISH is in .01 physical inches
   // these extents provide .01 logical inches

   extents.cx = pDC->GetDeviceCaps(LOGPIXELSX);
   extents.cy = pDC->GetDeviceCaps(LOGPIXELSY);

   pDC->SetMapMode(MM_ANISOTROPIC);
   pDC->SetViewportExt( extents );

   pDC->SetWindowExt(100, -100);


   // set the origin of the coordinate system to the center of the page
   CPoint ptOrg;
#if CENTER_WHITE_AREA
   ptOrg.x = GetTotalSize().cx / 2 + CENTERING_FUDGE_FACTOR ;
#else
   ptOrg.x = GetDocument()->GetSize().cx / 2 ;
#endif
   ptOrg.y = GetDocument()->GetSize().cy / 2;

   // ptOrg is in logical coordinates

   pDC->OffsetWindowOrg(-ptOrg.x,ptOrg.y);

}



//--------------------------------------------------------------------------
BOOL CDrawView::OnScrollBy(CSize sizeScroll, BOOL bDoScroll)
{
   // do the scroll
   if (!CScrollView::OnScrollBy(sizeScroll, bDoScroll))
        return FALSE;

   // update the position of any in-place active item
   if (bDoScroll)
   {
        UpdateActiveItem();
        UpdateWindow();
   }
   return TRUE;
}


//--------------------------------------------------------------------------
HBRUSH CDrawView::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
    HBRUSH b = CScrollView::OnCtlColor(pDC, pWnd, nCtlColor);

    if (nCtlColor == CTLCOLOR_EDIT) 
    {
        if (m_pObjInEdit) 
        {
            m_pObjInEdit->NewBrush();

            pDC->SetTextColor(GetDisplayColor(m_pObjInEdit->m_crTextColor));
            pDC->SetBkColor(GetDisplayColor(m_pObjInEdit->m_logbrush.lbColor));
            return m_pObjInEdit->GetBrush();            
        }
    }

    return b;
}


//--------------------------------------------------------------------------
void CDrawView::OnDraw(CDC* pDC)
{
    //
    // Revised 8-22-96 by a-juliar to fix NT Bug 43431.
    //
    CDC dc;

    CDC* pDrawDC = pDC;

    CBitmap bitmap;
    CBitmap* pOldBitmap;

    CRect clipbox;

    pDC->GetClipBox(clipbox);

#define GIVE_MFC_NORMALIZE_RECT_A_TRY   0
#if GIVE_MFC_NORMALIZE_RECT_A_TRY
    clipbox.NormalizeRect();
#else
    if( clipbox.bottom > clipbox.top )
    {
        int temp = clipbox.bottom ;
        clipbox.bottom = clipbox.top ;
        clipbox.top = temp ;
    }
    if( clipbox.left > clipbox.right )
    {
        int temp = clipbox.left ;
        clipbox.left = clipbox.right ;
        clipbox.right = temp ;
    }
#endif
    clipbox.top    += 1;
    clipbox.left   -= 1;
    clipbox.right  += 1;
    clipbox.bottom -= 1;
    CRect rect = clipbox ;
    DocToClient(rect);        // Now "rect" is in device coordinates and "clipbox" is in logical coordinates.

    CDrawDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    if(!pDC->IsPrinting()) 
    {
        // draw to offscreen bitmap for fast looking repaints
        if( dc.CreateCompatibleDC(pDC) )
        {
            if (bitmap.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height())) 
            {
                OnPrepareDC(&dc,NULL);
                pDrawDC = &dc;

                // offset origin more because bitmap is just piece of the whole drawing

                dc.OffsetViewportOrg(-rect.left, -rect.top);
                pOldBitmap = dc.SelectObject(&bitmap);
                dc.SetBrushOrg(rect.left % 8, rect.top % 8);

                // might as well clip to the same rectangle

                dc.IntersectClipRect(clipbox);
            }
        }
    }
    else
    {
        //
        // Printing. Must undo the correction for centering done in DoPrepareDC();
        //
        pDrawDC->OffsetWindowOrg( ( GetTotalSize().cx - pDoc->GetSize().cx )/ 2 + CENTERING_FUDGE_FACTOR, 0 ) ;
    }
    if (!pDC->IsPrinting())
    {
        //
        // Paint the whole thing Light Gray first.  The white part will be done in DrawGrid().
        //
        HBRUSH oldbrush = (HBRUSH)::SelectObject(pDrawDC->m_hDC,(HBRUSH)::GetStockObject(LTGRAY_BRUSH) );
        
        pDrawDC->PatBlt( clipbox.left, clipbox.top, clipbox.Width(), clipbox.Height(), PATCOPY);

        ::SelectObject(pDrawDC->m_hDC,oldbrush);

        DrawGrid( pDrawDC );
    }
    else
    {
        // Printing.
        // Paint the whole thing white.  Paper color feature isn't supported.
        //
        pDrawDC->FillSolidRect(clipbox, COLOR_WHITE);

    }


    if (!pDoc->m_bSerializeFailed)
    {
        //
        // Serializaion succeeded - draw the document
        //
        pDoc->Draw(pDrawDC, this, clipbox);
    }
    if (pDrawDC != pDC) 
    {
        pDC->SetViewportOrg(0, 0);
        pDC->SetWindowOrg(0,0);
        pDC->SetMapMode(MM_TEXT);
        dc.SetViewportOrg(0, 0);
        dc.SetWindowOrg(0,0);
        dc.SetMapMode(MM_TEXT);
        pDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(),
                        &dc, 0, 0, SRCCOPY);
        dc.SelectObject(pOldBitmap);
    }
}


//--------------------------------------------------------------------------
void CDrawView::Remove(CDrawObj* pObj)
{
   POSITION pos = m_selection.Find(pObj);
   if (pos != NULL)
          m_selection.RemoveAt(pos);

}


//--------------------------------------------------------------------------
void CDrawView::PasteNative(COleDataObject& dataObject)
{
   // get file refering to clipboard data
   CFile* pFile = dataObject.GetFileData(m_cfDraw);
   if (pFile == NULL)
        return;

   // connect the file to the archive
   CArchive ar(pFile, CArchive::load);
   TRY
   {
        ar.m_pDocument = GetDocument(); // set back-pointer in archive

        // read the selection
        m_selection.Serialize(ar);
   }
   CATCH_ALL(e)
   {
        ar.Close();
        delete pFile;
        THROW_LAST();
   }
   END_CATCH_ALL

   ar.Close();
   delete pFile;
}


//--------------------------------------------------------------------------
void CDrawView::PasteEmbedded(COleDataObject& dataObject)
{
   BeginWaitCursor();

   // paste embedded
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);
   CDrawItem* pItem;
   TRY 
   {
        pItem = new CDrawItem(GetDocument(), pObj);
   }
   CATCH_ALL(e)
   {
        delete pObj;
        THROW_LAST();
   }
   END_CATCH_ALL

   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   TRY {
        if (!pItem->CreateFromData(&dataObject) &&
                !pItem->CreateStaticFromData(&dataObject)) {
                AfxThrowMemoryException();      // any exception will do
        }

        // add the object to the document
        GetDocument()->Add(pObj);
        m_selection.AddTail(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();
   }
   CATCH_ALL(e) {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::DrawGrid(CDC* pDC )
{
    //
    // Revised by a-juliar 8-22-96 to fix NT bug 43431.
    // Called by CDrawView::OnDraw(), which will draw the gray background.
    // Thus we do not need the client rect or clip box here at all.
    // The white background for the printable portion of the document will be drawn here.
    //
   CDrawDoc* pDoc = GetDocument();

   CRect rect;    // White area containing the printable portion of our document.

   int RectWidth  = pDoc->GetSize().cx ;
   int RectHeight = pDoc->GetSize().cy ;
   rect.left = - RectWidth / 2;
   rect.top = RectHeight / 2;
   rect.right = rect.left + RectWidth ;
   rect.bottom = rect.top - RectHeight ;

    //
    //  Draw background.
    //
    HBRUSH oldbrush = (HBRUSH)::SelectObject(pDC->m_hDC, ::GetSysColorBrush(COLOR_WINDOW));
    pDC->PatBlt(rect.left, rect.top, RectWidth, -RectHeight, PATCOPY);

    //
    // draw shadow
    //
    ::SelectObject(pDC->m_hDC, ::GetSysColorBrush(COLOR_3DDKSHADOW));
    pDC->PatBlt(rect.right,rect.top-5, 5, -RectHeight, PATCOPY );
    pDC->PatBlt(rect.left+5,rect.bottom, RectWidth, -5, PATCOPY );

    ::SelectObject(pDC->m_hDC,oldbrush);

    // Outlines

    pDC->MoveTo(rect.right, rect.top);
    pDC->LineTo(rect.right, rect.bottom);
    pDC->LineTo(rect.left, rect.bottom);
    pDC->LineTo(rect.left, rect.top);

    //
    // If "Grid lines" is checked on the view menu, draw the grid lines.
    //

    if (m_bGridLines) 
    {
        CPen* pOldPen = pDC->SelectObject(&m_penDot);
        for (int x = 100; x < rect.right; x += 100) {      // +x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (x = -100; x > rect.left; x -= 100) {      // -x
            pDC->MoveTo(x, rect.top);
            pDC->LineTo(x, rect.bottom);
        }
        for (int y = 100; y < rect.top; y += 100) {        // +y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }
        for (y = -100; y > rect.bottom; y -= 100) {        // -y
            pDC->MoveTo(rect.left, y);
            pDC->LineTo(rect.right, y);
        }

        pDC->SelectObject(&m_penSolid);
        //Center lines
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.right, 0);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(0, rect.bottom);

        pDC->SelectObject(pOldPen);
    }
}
// -------------------------------------------------------------------------
CSize CDrawView::ComputeScrollSize( CSize size )
{
    //
    //  Compute the scroll sizes.  The width needs to accommodate a grayed area on the margins of
    //  the document, at least 1.25 times the width of the document, and at least as wide as the
    //  client area of the window when it is maximized.  a-juliar 6-24-96
    //

    CClientDC dc(NULL);
    size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
   // size.cx = MulDiv((int)(size.cx * 1.10), dc.GetDeviceCaps(LOGPIXELSX), 100 ); // deliberate gray area
    size.cx = MulDiv( size.cx+16, dc.GetDeviceCaps(LOGPIXELSX), 100 ) ; // No unnecessary gray area.
#if CENTER_WHITE_AREA

    //
    //  Find out how wide the view is when maximized. Make scroll width at least this wide.
    //
#if 0
    long lScreenWidth = dc.GetDeviceCaps( HORZRES ) ;
    NONCLIENTMETRICS ncm ;
    BOOL rval = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    int iScrollBarAndBorderWidth = ncm.iBorderWidth + ncm.iScrollWidth ;
    long lMaxWidth = lScreenWidth - iScrollBarAndBorderWidth ;
    size.cx = rval ? max( lMaxWidth, size.cx ) : max( lScreenWidth, size.cx ) ;
#endif

    size.cx = max( size.cx,
                   GetSystemMetrics( SM_CXMAXIMIZED )
                      - GetSystemMetrics( SM_CXVSCROLL )
                           - 2 * GetSystemMetrics( SM_CXBORDER ));

#endif

    return size ;
}

//--------------------------------------------------------------------------
void CDrawView::OnInitialUpdate()
{
#if 0
   CSize size = GetDocument()->GetSize();
   CClientDC dc(NULL);
   size.cx = MulDiv(size.cx+(int)(size.cx*.25), dc.GetDeviceCaps(LOGPIXELSX), 100);
   size.cy = MulDiv(size.cy+8, dc.GetDeviceCaps(LOGPIXELSY), 100);
#endif
   CSize size = ComputeScrollSize( GetDocument()->GetSize() );
   SetScrollSizes(MM_TEXT, size);

   m_selection.RemoveAll();
#if CENTER_WHITE_AREA
   POINT ptStartingPosition ;
   ptStartingPosition.y = 0 ;
   CRect rect ;
   GetClientRect( &rect );
   ptStartingPosition.x = ( size.cx - rect.right ) / 2 ;
   ScrollToPosition( ptStartingPosition );
#endif

    //
    // The view should have LTR layout
    //
    if(theApp.IsRTLUI())
    {
        ModifyStyleEx(WS_EX_LAYOUTRTL | WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_RIGHTSCROLLBAR,
                      WS_EX_LEFT | WS_EX_LTRREADING | WS_EX_LEFTSCROLLBAR,
                      SWP_NOSIZE | SWP_NOMOVE  | SWP_NOZORDER);
    }
}


//--------------------------------------------------------------------------
void CDrawView::SetPageSize(CSize size)
{
   size = ComputeScrollSize(size);
   SetScrollSizes(MM_TEXT, size);
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_WINDOW, NULL);
}


//--------------------------------------------------------------------------
BOOL CDrawView::OnPreparePrinting(CPrintInfo* pInfo)
{
    if (pInfo->m_pPD)
    {
        delete pInfo->m_pPD;
    }

    if (IsWinXPOS())
    {   
        //
        // Use new look of printer selection dialog
        //
        pInfo->m_pPD = new C_PrintDialogEx (FALSE,
                                            PD_ALLPAGES                  | 
                                            PD_USEDEVMODECOPIES          |
                                            PD_NOPAGENUMS                |
                                            PD_NOSELECTION               |
                                            PD_RETURNDC);         
    }
    else
    {
        //
        // Use legacy printer selection dialog
        //
        pInfo->m_pPD = new CMyPrintDlg(FALSE, PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOSELECTION);
    }
    if (m_pObjInEdit)     //if there's an object in edit, remove it
    {
        m_pObjInEdit->HideEditWnd(this);
    }

    if (pInfo && GetApp()->m_bCmdLinePrint)
    {
        pInfo->m_bPreview=TRUE;
    }
    if (pInfo->m_bPreview) 
    {
        pInfo->SetMinPage(1);
        pInfo->SetMaxPage(1);
    }
    return DoPreparePrinting(pInfo);
}   // CDrawView::OnPreparePrinting


//--------------------------------------------------------------------------
void CDrawView::OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo)
{
   CScrollView::OnBeginPrinting(pDC,pInfo);

//   GetDocument()->ComputePageSize();
}

//--------------------------------------------------------------------------
void CDrawView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}


//--------------------------------------------------------------------------
BOOL CDrawView::IsSelected(const CObject* pDocItem) const
{
   CDrawObj* pDrawObj = (CDrawObj*)pDocItem;
   if (pDocItem->IsKindOf(RUNTIME_CLASS(CDrawItem)))
        pDrawObj = ((CDrawItem*)pDocItem)->m_pDrawObj;
   return m_selection.Find(pDrawObj) != NULL;
}


//--------------------------------------------------------------------------
void CDrawView::OnInsertObject()
{
   // Invoke the standard Insert Object dialog box to obtain information
   //  for new CDrawItem object.
   CMyOleInsertDialog dlg;       //// To get Context Sensitive Help, we define our own class. a-juliar
   if (dlg.DoModal() != IDOK)
        return;

   BeginWaitCursor();

   // First create the C++ object
   CDrawOleObj* pObj = new CDrawOleObj(GetInitialPosition());
   ASSERT_VALID(pObj);

   CDrawItem* pItem;
   TRY 
   {
       pItem = new CDrawItem(GetDocument(), pObj);
   }
   CATCH_ALL(e)
   {
        delete pObj;
        THROW_LAST();
   }
   END_CATCH_ALL
  
   ASSERT_VALID(pItem);
   pObj->m_pClientItem = pItem;

   // Now create the OLE object/item
   TRY
   {
        if (!dlg.CreateItem(pObj->m_pClientItem)) {
                AfxThrowMemoryException();
        }

        // add the object to the document
        GetDocument()->Add(pObj);

        // try to get initial presentation data
        pItem->UpdateLink();
        pItem->UpdateExtent();

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
                pItem->DoVerb(OLEIVERB_SHOW, this);

        GetDocument()->UpdateAllViews( NULL );
   }
   CATCH_ALL(e)
   {
        // clean up item
        pItem->Delete();
        pObj->m_pClientItem = NULL;
        GetDocument()->Remove(pObj);
        delete pObj;

        CPEMessageBox(MSG_ERROR_OLE_FAILED_TO_CREATE, NULL, MB_OK,IDP_FAILED_TO_CREATE);
   }
   END_CATCH_ALL

   EndWaitCursor();
}

//--------------------------------------------------------------------------
// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.
//--------------------------------------------------------------------------
void CDrawView::OnCancelEdit()
{
   // deactivate any in-place active item on this view!
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL) {
        // if we found one, deactivate it
        pActiveItem->Close();
   }
   ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);

   // escape also brings us back into select mode
   ReleaseCapture();

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
        pTool->OnCancel();

   CDrawTool::c_drawShape = select;
}


//--------------------------------------------------------------------------
void CDrawView::OnSetFocus(CWnd* pOldWnd)
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // need to set focus to this item if it is in the same view
        CWnd* pWnd = pActiveItem->GetInPlaceWindow();
        if (pWnd != NULL) {
                pWnd->SetFocus();
                return;
        }
    }

    CreateSolidCaret(10,10);

    CScrollView::OnSetFocus(pOldWnd);
}

void 
CDrawView::OnKillFocus(CWnd* pNewWnd)
{
    ::DestroyCaret();
    CScrollView::OnSetFocus(pNewWnd);
}

//--------------------------------------------------------------------------
CRect CDrawView::GetInitialPosition()
{
    CRect rect(10, 10, 10, 10);
    ClientToDoc(rect);
    return rect;
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CPoint& point, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(&point);
      return;
   }

   pDC->DPtoLP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::ClientToDoc(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.DPtoLP(rect);
      ASSERT(rect.left <= rect.right);
      ASSERT(rect.bottom <= rect.top);
      return;
   }

   pDC->DPtoLP(rect);
   ASSERT(rect.left <= rect.right);
   ASSERT(rect.bottom <= rect.top);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CPoint& point, CDC* pDC)
{
    if (pDC==NULL) 
    {
        CClientDC dc(this);
        OnPrepareDC(&dc,NULL);
        dc.LPtoDP(&point);
        return;
    }
    pDC->LPtoDP(&point);
}


//--------------------------------------------------------------------------
void CDrawView::DocToClient(CRect& rect, CDC* pDC)
{
   if (pDC==NULL) {
      CClientDC dc(this);
      OnPrepareDC(&dc,NULL);
      dc.LPtoDP(rect);
      rect.NormalizeRect();
          return;
   }

   pDC->LPtoDP(rect);
   rect.NormalizeRect();
}


//--------------------------------------------------------------------------
void CDrawView::CheckStyleBar(BOOL bUnderline, BOOL bBold, BOOL bItalic,
   BOOL bLeft, BOOL bCenter, BOOL bRight)
{
    UINT id, style;
    int i;
    int image;

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bUnderline)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bBold)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bItalic)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bLeft)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bCenter)
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (bRight) {
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style | TBBS_CHECKED, image);
    }
    else
       GetFrame()->m_StyleBar.SetButtonInfo(i, id, style & ~TBBS_CHECKED, image);

}


//--------------------------------------------------------------------------
// * Updates style bar based on font characterics of selected object(s)
// * Called whenever a drawing object is selected or deselected
//--------------------------------------------------------------------------
void CDrawView::UpdateStyleBar(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
   CString sz;
   CString cFace;
   LONG    style;
   TCHAR   cSize[5];

   CComboBox& cboxSize = GetFrame()->m_StyleBar.m_cboxFontSize;
   CComboBox& cboxName = GetFrame()->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob = pObList;
   else
      pob = &m_selection;

   CDrawText* pText;
   if (p)
      pText = p;
   else
      pText = m_pObjInEdit;

   if (pText) 
   {
      if (!pText->m_pEdit)
      {
         return;
      }

      cFace = pText->m_logfont.lfFaceName;
      cboxName.GetWindowText(sz);
      if (sz != cFace)
      {
            cboxName.SetWindowText(cFace);
      }

      _itot(GetPointSize(*pText),cSize,10); //POINT SIZE
      cboxSize.GetWindowText(sz);
      if (sz!=cSize)
      {
            cboxSize.SetWindowText(cSize);
      }

      LONG style = pText->m_pEdit->GetStyle();
      CheckStyleBar(pText->m_logfont.lfUnderline,                    //underline
                    pText->m_logfont.lfWeight==FW_BOLD,              //bold
                    pText->m_logfont.lfItalic,                       //italic
                    (!((style & ES_CENTER) || (style & ES_RIGHT))),  //left
                    style & ES_CENTER,                               //center
                    style & ES_RIGHT);                               //right
      return;
   }

   BOOL bText=FALSE;
   BOOL bFontFace=TRUE;
   BOOL bPointSize=TRUE;
   BOOL bUnderline=TRUE;
   BOOL bBold=TRUE;
   BOOL bItalic=TRUE;
   BOOL bLeft=TRUE;
   BOOL bCenter=TRUE;
   BOOL bRight=TRUE;
   CString szSaveFace;
   WORD wSaveSize=0;
   CDrawText* pTxt;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) 
   {
     CDrawObj* pObj = (CDrawObj*)pob->GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
         pTxt=(CDrawText*)pObj;
         if (pTxt->m_pEdit)
         {
            bText=TRUE;
         }
         else
         {
             continue;
         }

        if ( (wSaveSize != 0) && (GetPointSize(*pTxt) != wSaveSize) ) //font size
           bPointSize=FALSE;

        cFace=pTxt->m_logfont.lfFaceName;

        if ( (szSaveFace.GetLength() > 0) && (cFace != szSaveFace) )
           bFontFace=FALSE;

        if (!pTxt->m_logfont.lfUnderline)     //underline
           bUnderline=FALSE;

        if (pTxt->m_logfont.lfWeight!=FW_BOLD) //bold
           bBold=FALSE;

        if (!pTxt->m_logfont.lfItalic)         //italic
           bItalic=FALSE;

        style=::GetWindowLong(((CDrawText*)pObj)->m_pEdit->m_hWnd, GWL_STYLE);
        if ( ((style & ES_CENTER) || (style & ES_RIGHT)) )  //left style
           bLeft=FALSE;

        if (!(style & ES_CENTER))  //center style
           bCenter=FALSE;

        if ( !(style & ES_RIGHT) )  //right style
           bRight=FALSE;

        szSaveFace=cFace;
        wSaveSize=(WORD)GetPointSize(*pTxt);
     }
   }

   if (!bText) //no object in edit, nor any text object
      return;

   cboxName.GetWindowText(sz);
   if (bFontFace) {
      if (sz!=szSaveFace)
         cboxName.SetWindowText(cFace);
   }
   else
      cboxName.SetWindowText(TEXT(""));

   cboxSize.GetWindowText(sz);
   if (bPointSize) {
      _itot(wSaveSize,cSize,10);
      if (cSize!=sz)
         cboxSize.SetWindowText(cSize);
   }
   else
      cboxSize.SetWindowText(TEXT(""));

   CheckStyleBar(bUnderline, bBold, bItalic, bLeft, bCenter, bRight);
}


//--------------------------------------------------------------------------
void CDrawView::Select(CDrawObj* pObj, BOOL bShift /*=FALSE*/, BOOL bCheckEdit /*=TRUE*/)
{
    if (bCheckEdit && m_pObjInEdit)     //if there's an object in edit, remove it
       m_pObjInEdit->HideEditWnd(this);

    if (pObj==NULL) 
    {
        OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
        m_selection.RemoveAll();
        return;
    }

    if (bShift) 
    {
        if (IsSelected(pObj)) 
        {
            Deselect(pObj);
            return;
        }
    }

    if (!IsSelected(pObj)) 
    {
        m_selection.AddTail(pObj);
        pObj->Invalidate();

        CRect rc = pObj->m_position;
        DocToClient(rc);
        SetCaretPos(rc.CenterPoint());
    }
}


//--------------------------------------------------------------------------
// rect is in device coordinates
//--------------------------------------------------------------------------
void CDrawView::SelectWithinRect(CRect rect, BOOL bAdd)
{
    if (!bAdd)
            Select(NULL);

    ClientToDoc(rect);

    CObList* pObList = GetDocument()->GetObjects();
    POSITION posObj = pObList->GetHeadPosition();
    CDrawObj* pObj;
    while (posObj != NULL) 
    {
        pObj = (CDrawObj*)pObList->GetNext(posObj);
        if (pObj->ContainedIn(rect))
                Select(pObj);
    }

    UpdateStatusBar();
    UpdateStyleBar();
}


//--------------------------------------------------------------------------
void CDrawView::Deselect(CDrawObj* pObj)
{
    POSITION pos = m_selection.Find(pObj);
    if (pos != NULL) 
    {
        pObj->Invalidate();
        m_selection.RemoveAt(pos);
    }
    UpdateStatusBar();
    UpdateStyleBar();
}

//--------------------------------------------------------------------------
void CDrawView::CloneSelection()
{
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);

        BOOL bThisIsANote = FALSE ;
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) ){
            CFaxProp * pfaxprop = (CFaxProp *)pObj;
            if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){
                 bThisIsANote = TRUE ;
            }
        }
        if (!bThisIsANote){
           pObj->Clone(pObj->m_pDocument);
        }
                // copies object and adds it to the document
    }
}


//--------------------------------------------------------------------------
void CDrawView::UpdateActiveItem()
{
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL &&
        pActiveItem->GetItemState() == COleClientItem::activeUIState) {
        // this will update the item rectangles by calling
        //  OnGetPosRect & OnGetClipRect.
        pActiveItem->SetItemRects();
    }
}

//--------------------------------------------------------------------------
// CDrawView message handlers
//--------------------------------------------------------------------------
void CDrawView::OnLButtonDown(UINT nFlags, CPoint point)
{
   CObList oblist;
   if (m_bFontChg) {
      POSITION pos = m_selection.GetHeadPosition();
      while (pos != NULL)
          oblist.AddHead(m_selection.GetNext(pos));
   }

   CDrawText* p = m_pObjInEdit;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   if (pTool != NULL)
       pTool->OnLButtonDown(this, nFlags, point);

   if (m_bFontChg) {
      OnSelChangeFontSize(&oblist,p);
      OnSelChangeFontName(&oblist,p);
      m_bFontChg=FALSE;
   }
}



//--------------------------------------------------------------------------
void CDrawView::OnContextMenu(CWnd *pWnd, CPoint pt)
{
    if (GetCapture() == this) 
    {
        TRACE(TEXT("AWCPE:  CDrawView::OnContextMenu, cannot invoke properties when in LButtondown capture\n"));
        return;
    }


    if (pt.x == -1 && pt.y == -1)
    {
        //
        // Keyboard (VK_APP or Shift + F10)
        // Pop the context menu near the mouse cursor
        //
        pt = (CPoint) GetMessagePos();
    }

    CDrawObj* pObj;

    ScreenToClient(&pt);
    CPoint local = pt;
    ClientToDoc(local);

    pObj = GetDocument()->ObjectAt(local);

    if (pObj == NULL) 
    {
        TrackViewMenu(pt);
        return;
    }
    if(!IsSelected(pObj))
    {
        while(!m_selection.IsEmpty())
        {
            CDrawObj* AnObj = (CDrawObj*) m_selection.GetHead() ;
            AnObj->Invalidate();
            m_selection.RemoveHead();
        }
        m_selection.AddHead( pObj );
        pObj->Invalidate();
    }
    TrackObjectMenu(pt);
}

//---------------------------------------------------------------------------------
void CDrawView::TrackObjectMenu(CPoint& pt)
{
   BOOL bTextObj=FALSE;
   BOOL bOLEObj=FALSE;

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL && !(bTextObj && bOLEObj) ) {
     CDrawObj* pobj = (CDrawObj*) m_selection.GetNext(pos);
     if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawText)) )
        bTextObj=TRUE;
     else
        if ( pobj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
           bOLEObj=TRUE;
   }

   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_CUT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_CUT, temp);
   temp.LoadString(IDS_MENU_COPY);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_COPY, temp);
   temp.LoadString(IDS_MENU_PASTE);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PASTE, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);
   if (bOLEObj) {
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OLE_VERB_FIRST, _TEXT("<<OLE VERBS GO HERE>>"));
      mainmenu.AppendMenu(MF_SEPARATOR);
   }
   CMenu textmenu;
   if (bTextObj) {
      temp.LoadString(IDS_MENU_FONT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_FONT, temp);

      textmenu.CreatePopupMenu();
      temp.LoadString(IDS_MENU_ALIGNLEFT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_LEFT, temp);
      temp.LoadString(IDS_MENU_ALIGNCENTER);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_CENTERED, temp);
      temp.LoadString(IDS_MENU_ALIGNRIGHT);
      textmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_STYLE_RIGHT, temp);

      temp.LoadString(IDS_MENU_ALIGNTEXT);
      mainmenu.AppendMenu(MF_STRING | MF_ENABLED | MF_POPUP,
                          (UINT_PTR)textmenu.GetSafeHmenu(),
              temp);

      mainmenu.AppendMenu(MF_SEPARATOR);
   }

   temp.LoadString(IDS_MENU_PROPERTIES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_PROPERTIES, temp);
   mainmenu.AppendMenu(MF_SEPARATOR);

   temp.LoadString(IDS_MENU_MOVETOFRONT);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOFRONT, temp);
   temp.LoadString(IDS_MENU_SENDTOBACK);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_OBJECT_MOVETOBACK, temp);

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
   if (bTextObj)
      textmenu.Detach();
}


//--------------------------------------------------------------------------
void CDrawView::TrackViewMenu(CPoint& pt)
{
   CMenu mainmenu;
   mainmenu.CreatePopupMenu();
   CString temp;
   temp.LoadString(IDS_MENU_VIEWSTYLEBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STYLEBAR, temp);
   temp.LoadString(IDS_MENU_VIEWDRAWINGBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_DRAWBAR, temp);
   temp.LoadString(IDS_MENU_VIEWSTATUSBAR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_STATUS_BAR, temp);
   temp.LoadString(IDS_MENU_VIEWGRIDLINES);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRIDLINES, temp);

#ifdef GRID
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_GRID, _TEXT("Grid Lines"));
   mainmenu.AppendMenu(MF_SEPARATOR);
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_GRID_SETTINGS, _TEXT("Grid Settings..."));
   mainmenu.AppendMenu(MF_STRING | MF_ENABLED, ID_SNAP_TO_GRID, _TEXT("Snap to &Grid"));
#endif

   ClientToScreen(&pt);
   mainmenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
}



//--------------------------------------------------------------------------
void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonUp(this, nFlags, point);

    if (CDrawTool::c_drawShape != poly) {
       CDrawTool::c_drawShape = select;
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnMouseMove(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnMouseMove(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
    if (pTool != NULL)
        pTool->OnLButtonDblClk(this, nFlags, point);
}


//--------------------------------------------------------------------------
void CDrawView::OnDestroy()
{
    CScrollView::OnDestroy();

    // deactivate the inplace active item on this view
    COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
    if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
    {
        pActiveItem->Deactivate();
        ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
    }
}


//--------------------------------------------------------------------------
// *_*_*_   RECIPIENT WM_COMMAND METHODS
//--------------------------------------------------------------------------
void CDrawView::CreateFaxProp(WORD wResID)
{
   CDrawText* pTextObj;
   CFaxProp*  pFaxPropObj;

   CString szCaption;
   CString szPropName;

   BeginWaitCursor();

   if (GetApp() && GetApp()->m_pFaxMap) 
   {
      GetApp()->m_pFaxMap->GetCaption(wResID,    szCaption);
      GetApp()->m_pFaxMap->GetPropString(wResID, szPropName);
   }

//FETCH CLIENT AREA MEASUREMENTS
   CRect rcClient;   //client area
   GetClientRect(&rcClient);
   ClientToDoc(rcClient);
   NormalizeRect(rcClient);

   CPoint pt = rcClient.TopLeft();
   int iHalfWidth  = (rcClient.right - rcClient.left)/2;
   int iHalfHeight = (rcClient.top   - rcClient.bottom)/2;

//SET FAX PROPERTY
   pFaxPropObj = new CFaxProp(CRect(0,0,0,0), wResID);
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX), dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectObject(pFaxPropObj->GetFont());

   TEXTMETRIC tm;
   dc.GetTextMetrics(&tm);

   int iPropWidth  = GetApp()->m_pFaxMap->GetPropDefLength(wResID) * tm.tmAveCharWidth;
   int iPropHeight = GetApp()->m_pFaxMap->GetPropDefLines (wResID) * (tm.tmHeight + 3*tm.tmInternalLeading);

//SET CAPTION SIZE
   TRY 
   {
       pTextObj = new CDrawText(CRect(0,0,0,0));
   }
   CATCH_ALL(e)
   {
        delete pFaxPropObj;
        THROW_LAST();
   }
   END_CATCH_ALL

   dc.SelectObject(pTextObj->GetFont());

   CSize sizeCaption = dc.GetTextExtent(szCaption, szCaption.GetLength()+1);
   sizeCaption.cx += 10;
   sizeCaption.cy += 3 * tm.tmInternalLeading;

//SET SIZES AND LOCATION OF BINDING RECT
   int iRcWidth  = iPropWidth + sizeCaption.cx + G_ISPACING;
   int iRcHeight = max(iPropHeight, sizeCaption.cy);

   pt.x = (pt.x + iHalfWidth)  - (long)(0.5 * iRcWidth);
   pt.y = (pt.y - iHalfHeight) + (long)(0.5 * iRcHeight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect rcObj(pt.x, pt.y, pt.x + iRcWidth, pt.y - iRcHeight);
   FindLocation(rcObj);

//SET CAPTION AND FAX PROPERTY
   if(theApp.IsRTLUI())
   {
        //
        // For RTL UI the caption should be on the right side of the property
        //
        pFaxPropObj->m_position.SetRect( rcObj.left, rcObj.top, rcObj.left + iPropWidth, rcObj.top - iPropHeight);      

        rcObj.left += iPropWidth + G_ISPACING;
        pTextObj->m_position.SetRect(rcObj.left, rcObj.top, rcObj.left + sizeCaption.cx, rcObj.top - sizeCaption.cy);
   }
   else
   {
        pTextObj->m_position.SetRect(rcObj.left, rcObj.top, rcObj.left + sizeCaption.cx, rcObj.top - sizeCaption.cy);
        rcObj.left += sizeCaption.cx + G_ISPACING;

        //set property object text
        pFaxPropObj->m_position.SetRect( rcObj.left, rcObj.top, rcObj.left + iPropWidth, rcObj.top - iPropHeight);      
   }

//Snap to current font for fine tuning
   pTextObj->SnapToFont();
   pFaxPropObj->SnapToFont();

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   pTextObj->SetText(szCaption, this);
   pFaxPropObj->SetText(szPropName, this);
   GetDocument()->Add(pTextObj);
   GetDocument()->Add(pFaxPropObj);
   Select(NULL);
   Select(pTextObj);
   Select(pFaxPropObj);

   UpdateStatusBar();
   UpdateStyleBar();

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::CreateFaxText()
{
   CFaxText* pFaxText;

   BeginWaitCursor();

//FETCH CLIENT AREA MEASUREMENTS
   CRect clientrect;   //client area
   TEXTMETRIC tm;
   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;
   CPoint cp = clientrect.TopLeft();

//SET FAX PROPERTY
   pFaxText = new CFaxText(CRect(0,0,0,0));
   CClientDC dc(this);
   dc.SetMapMode(MM_ANISOTROPIC);
   dc.SetViewportExt(dc.GetDeviceCaps(LOGPIXELSX),dc.GetDeviceCaps(LOGPIXELSY));
   dc.SetWindowExt(100, -100);
   dc.SelectStockObject(SYSTEM_FONT);
   dc.GetTextMetrics(&tm);
   int faxpropWidth = GetApp()->m_pFaxMap->GetPropDefLength(IDS_PROP_MS_TEXT)
           * tm.tmAveCharWidth;
   int faxpropHeight = GetApp()->m_pFaxMap->GetPropDefLines(IDS_PROP_MS_TEXT)
           * (tm.tmHeight+3*tm.tmInternalLeading);

//SET SIZES AND LOCATION OF BINDING RECT
   cp.x = (cp.x+ihalfwidth)-(long)(.5*faxpropWidth);
   cp.y = (cp.y-ihalfheight)+(long)(.5*faxpropHeight);

//FIND EMPTY LOCATION NEAREST CENTER OF CLIENT AREA
   CRect objrect(cp.x,cp.y,cp.x+faxpropWidth,cp.y-faxpropHeight);
   FindLocation(objrect);

//SET CAPTION AND FAX PROPERTY
   pFaxText->m_position.SetRect( objrect.left,objrect.top, objrect.bottom, objrect.right);

//SET TEXT, ADD TO CONTAINER, AND SELECT CAPTION AND FAX PROPERTY
   GetDocument()->Add(pFaxText);
   Select(NULL);
   Select(pFaxText);

   EndWaitCursor();
}


//--------------------------------------------------------------------------
void CDrawView::FindLocation(CRect& objrect)
{
   CObList* pObList = GetDocument()->GetObjects();
   POSITION posObj;
   CRect rcMove=objrect;
   double angle=0;
   CPoint p;
   int r=5;
   BOOL bFoundPlace;
   CRect clientrect;
   CPoint ptCR;

   GetClientRect(&clientrect);
   ClientToDoc(clientrect);
   NormalizeRect(clientrect);
   int ihalfwidth=(clientrect.right-clientrect.left)/2;
   int ihalfheight=(clientrect.top-clientrect.bottom)/2;

   ptCR.x=clientrect.left+ihalfwidth;
   ptCR.y=clientrect.top-ihalfheight;
   int iobjwidth = objrect.right-objrect.left;
   int iobjheight = objrect.top-objrect.bottom;
   int iLongestR=max(ihalfheight,ihalfwidth);

   BOOL bCont=TRUE;
//   CClientDC dc(this);                 //testing
//   OnPrepareDC(&dc,NULL);              //testing

   if (iobjwidth>ihalfwidth*2 || iobjheight>ihalfheight*2 ) {      //object is larger than client area

//       rcMove.top=ptCR.y;
//       rcMove.left=ptCR.x;

       rcMove.top=ptCR.y + iobjheight/2;
       rcMove.left=ptCR.x - iobjwidth/2;

       if( rcMove.top > clientrect.top )
                rcMove.top=clientrect.top;

       if( rcMove.left < clientrect.left )
                rcMove.left=clientrect.left;

           rcMove.right=rcMove.left+iobjwidth;
           rcMove.bottom=rcMove.top-iobjheight;
   }
   else {
      while (bCont) {
        bFoundPlace=TRUE;
            posObj = pObList->GetHeadPosition();
            while (posObj != NULL) {
                CDrawObj* pObj = (CDrawObj*)pObList->GetNext(posObj);
                if (pObj->Intersects(rcMove,TRUE)) {
                   bFoundPlace=FALSE;
                       break;
                    }
        }

            if (bFoundPlace)
              break;

        while(1) {
                p.x= (int)(r * cos(angle));
                p.y= (int)(r * sin(angle));
                if (angle<355)
                       angle += 10;
                else {
                       if (r<iLongestR) {
                          r+= 15;
                          angle=0;
                            }
                        else {
                                p.x=p.y=0;
                                bCont=FALSE;
                                break;
                            }
             }

                 if ( ((ptCR.x+p.x-.5*iobjwidth) > clientrect.left) &&
                    ((ptCR.x+p.x+.5*iobjwidth) < clientrect.right) &&
                        ((ptCR.y+p.y-.5*iobjheight) > clientrect.bottom) &&
                        ((ptCR.y+p.y+.5*iobjheight) < clientrect.top) )
                      break;
            }

        rcMove = objrect + p;

//      dc.Rectangle(rcMove);   //testing
      }
   }
   objrect=rcMove;
}



//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipName()
{
   CreateFaxProp(IDS_PROP_RP_NAME);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipFaxNum()
{
   CreateFaxProp(IDS_PROP_RP_FXNO);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCompany()
{
   CreateFaxProp(IDS_PROP_RP_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipAddress()
{
   CreateFaxProp(IDS_PROP_RP_ADDR);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCity()
{
   CreateFaxProp(IDS_PROP_RP_CITY);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipState()
{
   CreateFaxProp(IDS_PROP_RP_STAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipPOBox()
{
   CreateFaxProp(IDS_PROP_RP_POBX);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipZipCode()
{
   CreateFaxProp(IDS_PROP_RP_ZIPC);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCountry()
{
   CreateFaxProp(IDS_PROP_RP_CTRY);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipTitle()
{
   CreateFaxProp(IDS_PROP_RP_TITL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipDept()
{
   CreateFaxProp(IDS_PROP_RP_DEPT);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOfficeLoc()
{
   CreateFaxProp(IDS_PROP_RP_OFFI);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipHMTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_HTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipOFTeleNum()
{
   CreateFaxProp(IDS_PROP_RP_OTEL);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipToList()
{
   CreateFaxProp(IDS_PROP_RP_TOLS);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIRecipCCList()
{
   CreateFaxProp(IDS_PROP_RP_CCLS);
}

//--------------------------------------------------------------------------
// *_*_*_   SENDER WM_COMMAND METHODS
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderName()
{
    CreateFaxProp(IDS_PROP_SN_NAME);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderFaxNum()
{
   CreateFaxProp(IDS_PROP_SN_FXNO);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderCompany()
{
   CreateFaxProp(IDS_PROP_SN_COMP);
}


//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderAddress()
{
   CreateFaxProp(IDS_PROP_SN_ADDR);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderTitle()
{
   CreateFaxProp(IDS_PROP_SN_TITL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderDept()
{
   CreateFaxProp(IDS_PROP_SN_DEPT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOfficeLoc()
{
   CreateFaxProp(IDS_PROP_SN_OFFI);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderHMTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_HTEL);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPISenderOFTeleNum()
{
   CreateFaxProp(IDS_PROP_SN_OTEL);
}

// *_*_*_   MESSAGE WM_COMMAND METHODS

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgSubject()
{
   CreateFaxProp(IDS_PROP_MS_SUBJ);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgTimeSent()
{
   CreateFaxProp(IDS_PROP_MS_TSNT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgNumPages()
{
   CreateFaxProp(IDS_PROP_MS_NOPG);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgAttach()
{
   CreateFaxProp(IDS_PROP_MS_NOAT);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgBillCode()
{
   CreateFaxProp(IDS_PROP_MS_BCOD);
}

//--------------------------------------------------------------------------
void CDrawView::OnMAPIMsgFaxText()
{
   CreateFaxText();
}

//--------------------------------------------------------------------------
void CDrawView::OnMapiMsgNote()
{
   CreateFaxProp(IDS_PROP_MS_NOTE);
}

//--------------------------------------------------------------------------
void CDrawView::OnDrawSelect()
{
    CDrawTool::c_drawShape = select;
}

void CDrawView::OnDrawRoundRect()
{
    CDrawTool::c_drawShape = roundRect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawRect()
{
    CDrawTool::c_drawShape = rect;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawText()
{
    CDrawTool::c_drawShape = text;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawLine()
{
    CDrawTool::c_drawShape = line;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawEllipse()
{
    CDrawTool::c_drawShape = ellipse;
}

//----------------------------------------------------------------------------
void CDrawView::OnDrawPolygon()
{
    //The Window's 95 way: Bring up a dialog box with directions the FIRST TIME ONLY!!! How unconventional!
    //
    // Fix for BUG 39665 by a-juliar, 05-24-96.  We have modified the resource string
    // for IDS_INFO_DRAWPOLY to give the same directions that Word 6.0 gives.  But I
    // really dislike the dialog box that appeared only the first time you ran the app.
    // PUT THE DIRECTIONS ON THE STATUS BAR where they belong!
    //

    CString sz ;
    sz.LoadString( IDS_INFO_DRAWPOLY );
    GetFrame()->m_wndStatusBar.SetPaneText(0,sz);
    CDrawTool::c_drawShape = poly;
}


//----------------------------------------------------------------------------
void CDrawView::OnSelEndOKFontSize()
{
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontName(CObList* pObList/*=NULL*/, CDrawText* p /*=NULL*/)
{
   CString szName;
   CComboBox& cbox=GetFrame()->m_StyleBar.m_cboxFontName;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,szName);
   else
       cbox.GetWindowText(szName);

   LOGFONT lf;
   if (pText) {   //change object in edit
       lstrcpy(pText->m_logfont.lfFaceName,szName);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;

   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
         CDrawText* pTextObj=(CDrawText*)pObj;
             lstrcpy(pTextObj->m_logfont.lfFaceName,szName);
         lf.lfWeight=pTextObj->m_logfont.lfWeight;
         lf.lfItalic=pTextObj->m_logfont.lfItalic;
             pTextObj->ChgLogfont(lf);
      }
   }
   ::SetFocus(m_hWnd);
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontName()
{
   OnSelChangeFontName();
}

//----------------------------------------------------------------------------
void CDrawView::OnSelchangeFontSize()
{
   OnSelChangeFontSize();
}


//----------------------------------------------------------------------------
void CDrawView::OnEditChangeFont()
{
   m_bFontChg=TRUE;
}

//----------------------------------------------------------------------------
void CDrawView::OnSelChangeFontSize(CObList* pObList/*=NULL*/,CDrawText* p /*=NULL*/)
{
   CString sz;
   CComboBox& cbox=GetFrame()->m_StyleBar.m_cboxFontSize;

   CObList* pob;
   if (pObList)
      pob=pObList;
   else
      pob=&m_selection;

   CDrawText* pText;
   if (p)
      pText=p;
   else
      pText=m_pObjInEdit;

   int iSel = cbox.GetCurSel();
   if ( iSel != CB_ERR)
       cbox.GetLBText(iSel,sz);
   else
       cbox.GetWindowText(sz);
   WORD wPointSize = (WORD)_ttoi(sz);

   if (wPointSize <= 0 || wPointSize > 5000) {
      UpdateStyleBar(pob,pText);
      return;
   }

   CClientDC dc(NULL);

   LOGFONT lf;
   if (pText) {   //change object in edit
       if (GetPointSize(*pText)==wPointSize)
              return;
       pText->m_logfont.lfHeight=  -MulDiv(wPointSize,100,72);
       lf.lfWeight=pText->m_logfont.lfWeight;
       lf.lfItalic=pText->m_logfont.lfItalic;
       pText->m_logfont.lfWidth=0;
       pText->ChgLogfont(lf);
       pText->m_pEdit->SetFocus();
       return;
   }

   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = pob->GetHeadPosition();
   while (pos != NULL) {
      pObj=(CDrawObj*) pob->GetNext(pos);
      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
             CDrawText* pTextObj=(CDrawText*)pObj;
             if (GetPointSize(*pTextObj)!=wPointSize) {
            lf.lfWeight=pTextObj->m_logfont.lfWeight;
            lf.lfItalic=pTextObj->m_logfont.lfItalic;
            pTextObj->m_logfont.lfHeight= -MulDiv(wPointSize,100,72);
                pTextObj->m_logfont.lfWidth=0;
                pTextObj->ChgLogfont(lf);
                pTextObj->FitEditWnd(this);
             }
      }
   }
   ::SetFocus(m_hWnd);
}


//----------------------------------------------------------------------------
void CDrawView::OnFont()
{
    LOGFONT lf ;
    UINT id, style;
    int i;
    int image;
    CString sz;
    CClientDC dc(NULL);

    memset(&lf,0,sizeof(LOGFONT)) ;

    GetFrame()->m_StyleBar.m_cboxFontName.GetWindowText(sz);
    if (sz.GetLength()>0){
        lstrcpy( lf.lfFaceName, sz);
    }
    GetFrame()->m_StyleBar.m_cboxFontSize.GetWindowText(sz);
    if (sz.GetLength()>0) {
        WORD wPointSize = (WORD)_ttoi(sz);
        lf.lfHeight = -( (wPointSize * dc.GetDeviceCaps(LOGPIXELSY))/72 );
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfWeight = FW_BOLD;
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfItalic = TRUE ;
    }
    i = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
    GetFrame()->m_StyleBar.GetButtonInfo(i, id, style, image);
    if (style & TBBS_CHECKED){
        lf.lfUnderline = TRUE ;
    }

    CMyFontDialog dlgFont(
        (LPLOGFONT)&lf,
        CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS | CF_NOVERTFONTS,
        NULL,
        this
        ) ;
    LOGFONT dlf;

    if (dlgFont.DoModal()==IDOK) {

        //
        // steveke wants the font change Undoable.
        // We are going to assume that THE FONT HAS CHANGED.
        // If it hasn't, UNDO will do nothing.
        //

        if (m_pObjInEdit) {   //change object in edit

            m_pObjInEdit->m_bUndoFont = TRUE ;
            m_pObjInEdit->m_bUndoAlignment = FALSE ;
            m_pObjInEdit->m_bUndoTextChange = FALSE ;
            memcpy (
                & m_pObjInEdit->m_previousLogfontForUndo,
                & m_pObjInEdit->m_logfont,
                sizeof(LOGFONT)
                );
            memset(&m_pObjInEdit->m_logfont,0,sizeof(LOGFONT)) ;

            lstrcpy(m_pObjInEdit->m_logfont.lfFaceName,dlgFont.GetFaceName()) ;

            m_pObjInEdit->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);

            dlf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
            dlf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;

            m_pObjInEdit->m_logfont.lfWeight=dlgFont.GetWeight();
            m_pObjInEdit->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
            m_pObjInEdit->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;

            m_pObjInEdit->ChgLogfont(dlf);

            m_pObjInEdit->m_pEdit->SetFocus();
            return;
        }

        SaveStateForUndo();

        CDrawObj* pObj;
        CDrawText* pTextObj;
        POSITION pos = m_selection.GetHeadPosition();
        while (pos != NULL) 
        {
            pObj=(CDrawObj*)m_selection.GetNext(pos);
            if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
            {
                pTextObj=(CDrawText*)pObj;
                memset(&pTextObj->m_logfont,0,sizeof(LOGFONT)) ;
                lstrcpy(pTextObj->m_logfont.lfFaceName,dlgFont.GetFaceName()) ;
                pTextObj->m_logfont.lfHeight=-MulDiv(dlgFont.GetSize()/10,100,72);
                dlf.lfWeight=pTextObj->m_logfont.lfWeight;
                dlf.lfItalic=pTextObj->m_logfont.lfItalic;
                pTextObj->m_logfont.lfWeight=dlgFont.GetWeight();
                pTextObj->m_logfont.lfItalic=dlgFont.IsItalic() != FALSE;
                pTextObj->m_logfont.lfUnderline=dlgFont.IsUnderline() != FALSE;
                pTextObj->ChgLogfont(dlf);
            }
        }
    }

}



//----------------------------------------------------------------------------
void CDrawView::OnStyleBold()
{
   LOGFONT lf;
   UINT nID, nStyle;
   int iImage;
   LONG lWeight;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   if (nStyle&TBBS_CHECKED)   /////// BUG FIX!  by a-juliar
      lWeight=FW_BOLD;
   else
      lWeight=FW_REGULAR;


   if (m_pObjInEdit) {   //change object in edit
       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;


       lf.lfWeight=m_pObjInEdit->m_logfont.lfWeight;
       lf.lfItalic=m_pObjInEdit->m_logfont.lfItalic;
       m_pObjInEdit->m_logfont.lfWeight=lWeight;
       m_pObjInEdit->ChgLogfont(lf, FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) 
   {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
        lf.lfWeight=((CDrawText*)pObj)->m_logfont.lfWeight;
        lf.lfItalic=((CDrawText*)pObj)->m_logfont.lfItalic;
        ((CDrawText*)pObj)->m_logfont.lfWeight=lWeight;
        ((CDrawText*)pObj)->ChgLogfont(lf, FALSE);

     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::OnStyleItalic()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bItalic;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   ///////bItalic = !(nStyle & TBBS_CHECKED);   /// BUG FIX! This is backwards!!!  a-juliar
   bItalic = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfItalic=bItalic != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfItalic=bItalic != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}


//----------------------------------------------------------------------------
void CDrawView::OnStyleUnderline()
{
   UINT nID, nStyle;
   int iImage;
   BOOL bUnderline;
   int index;

   index = GetFrame()->m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   GetFrame()->m_StyleBar.GetButtonInfo(index, nID, nStyle, iImage);
   bUnderline = (nStyle & TBBS_CHECKED) ? 1 : 0 ;
   LOGFONT lf;
   if (m_pObjInEdit) {   //change object in edit

       //
       // Save old font for Undoing
       //
       memcpy(
           & m_pObjInEdit->m_previousLogfontForUndo,
           & m_pObjInEdit->m_logfont,
           sizeof(LOGFONT)
           );
       m_pObjInEdit->m_bUndoFont = TRUE ;
       m_pObjInEdit->m_bUndoTextChange = FALSE ;
       m_pObjInEdit->m_bUndoAlignment = FALSE ;

       m_pObjInEdit->m_logfont.lfUnderline=bUnderline != FALSE;
       m_pObjInEdit->ChgLogfont(lf,FALSE);
       return;
   }
   SaveStateForUndo();
   CDrawObj* pObj;   //if no objectinedit, iterate thru all selected objects
   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) {
     pObj=(CDrawObj*)m_selection.GetNext(pos);
     if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) {
            ((CDrawText*)pObj)->m_logfont.lfUnderline=bUnderline != FALSE;
            ((CDrawText*)pObj)->ChgLogfont(lf,FALSE);
     }
   }
}



//----------------------------------------------------------------------------
void CDrawView::ChgTextAlignment(LONG lstyle)
{
    if (m_pObjInEdit) 
    {
        m_pObjInEdit->ChgAlignment(this, lstyle);
        m_pObjInEdit->m_pEdit->ShowWindow(SW_NORMAL);
        m_pObjInEdit->Invalidate();
        GetDocument()->SetModifiedFlag();          //set document dirty
        return;
    }
    SaveStateForUndo();
    CDrawObj* pObj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) 
    {
        pObj=(CDrawObj*)m_selection.GetNext(pos);
        if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
        {
            ((CDrawText*)pObj)->ChgAlignment(this, lstyle);
            GetDocument()->SetModifiedFlag();         //set document dirty
            pObj->Invalidate();
        }
   }
}


void CDrawView::OnStyleLeft()
{
   ChgTextAlignment(DT_LEFT);
}


void CDrawView::OnStyleCentered()
{
   ChgTextAlignment(DT_CENTER);
}


void CDrawView::OnStyleRight()
{
   ChgTextAlignment(DT_RIGHT);
}

#ifdef GRID
void CDrawView::OnSnapToGrid()
{
    m_bSnapToGrid=!m_bSnapToGrid;
}
#endif

#ifdef GRID
void CDrawView::OnGridSettings()
{
   CGridSettingsDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   if (dlg.m_bRBSmall)
      m_iGridSize=GRID_SMALL;
   else
      if (dlg.m_bRBMedium)
         m_iGridSize=GRID_MEDIUM;
      else
         m_iGridSize=GRID_LARGE;

   m_bGrid=dlg.m_bCBViewGrid;
   m_bSnapToGrid=dlg.m_bCBSnapToGrid;

   Invalidate(FALSE);

   m_pDocument->SetModifiedFlag();
}
#endif


//--------------------------------------------------------------------------
void CDrawView::NormalizeObjs()
{
    CDrawObj* pobj;
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       NormalizeRect(pobj->m_position);
    }
}


//--------------------------------------------------------------------------
void CDrawView::NormalizeRect(CRect& rc)
{
        int nTemp;
        if (rc.left > rc.right) {
                nTemp = rc.left;
                rc.left = rc.right;
                rc.right = nTemp;
        }
        if (rc.top < rc.bottom) {
                nTemp = rc.top;
                rc.top = rc.bottom;
                rc.bottom = nTemp;
        }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignLeft()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ileftmost = GetDocument()->GetSize().cx / 2;

        NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left < ileftmost)
           ileftmost=pobj->m_position.left;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.left != ileftmost) {
          rc = pobj->m_position;
          rc.right = ileftmost + (pobj->m_position.right - pobj->m_position.left);
          rc.left = ileftmost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignRight()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int irightmost = GetDocument()->GetSize().cx / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) 
    {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right > irightmost)
           irightmost=pobj->m_position.right;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) 
    {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.right != irightmost) 
       {
          rc = pobj->m_position;
          rc.left = irightmost - (pobj->m_position.right - pobj->m_position.left);
          rc.right = irightmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignTop()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int itopmost = GetDocument()->GetSize().cy / -2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top > itopmost)
           itopmost=pobj->m_position.top;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.top != itopmost) {
          rc = pobj->m_position;
          rc.bottom = itopmost - (pobj->m_position.top - pobj->m_position.bottom);
          rc.top = itopmost;
          pobj->MoveTo(rc, this);
       }
    }
}

//--------------------------------------------------------------------------
void CDrawView::OnAlignBottom()
{
    CDrawDoc* pDoc = GetDocument();

    CDrawObj* pobj;
    int ibottommost = GetDocument()->GetSize().cy / 2;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom < ibottommost)
           ibottommost=pobj->m_position.bottom;
    }

    pos = m_selection.GetHeadPosition();
    CRect rc;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       if (pobj->m_position.bottom != ibottommost) {
          rc = pobj->m_position;
          rc.top = ibottommost + (pobj->m_position.top - pobj->m_position.bottom);
          rc.bottom = ibottommost;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignHorzCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveY;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.top - ((pobj->m_position.top - pobj->m_position.bottom) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveY = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.bottom += iMoveY;
          rc.top += iMoveY;
          pobj->MoveTo(rc, this);
       }
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnAlignVertCenter()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    POSITION pos = m_selection.GetHeadPosition();
    int iMiddle;
    if (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
    }
    else
       return;

    CRect rc;
    int iTempMiddle, iMoveX;

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       iTempMiddle = pobj->m_position.right - ((pobj->m_position.right - pobj->m_position.left) / 2);
       if (iTempMiddle != iMiddle) {
          iMoveX = iMiddle - iTempMiddle;
          rc = pobj->m_position;
          rc.left += iMoveX;
          rc.right += iMoveX;
          pobj->MoveTo(rc, this);
       }
    }
}

//-------------------------------------------------------------------------------
CSortedObList& CSortedObList::operator=(CObList& list)
{
    POSITION pos = list.GetHeadPosition();
    while (pos != NULL)
       AddHead(list.GetNext(pos));
    return *this;
}


//-------------------------------------------------------------------------------
inline void CSortedObList::swap(INT_PTR i, INT_PTR j)
{
    CObject* temp;
    temp = GetAt(FindIndex(i));
    SetAt(FindIndex(i),GetAt(FindIndex(j)));
    SetAt(FindIndex(j),temp);
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToLeft()
{
   CDrawObj* pi,*pi1;

   for (INT_PTR top=GetCount()-1;top>0;top--) {   //simple bubble sort
      for (INT_PTR i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.left < pi->m_position.left )
            swap(i+1,i);
                 else
            if (pi1->m_position.left == pi->m_position.left &&
                  pi1->m_position.right < pi->m_position.right )
               swap(i+1,i);
     }
   }
}


//-------------------------------------------------------------------------------
void CSortedObList::SortToBottom()
{
   CDrawObj* pi,*pi1;

   for (INT_PTR top=GetCount()-1;top>0;top--) {   //simple bubble sort
      for (INT_PTR i=0;i<top;i++) {
         pi=(CDrawObj*) GetAt(FindIndex(i));
         pi1=(CDrawObj*) GetAt(FindIndex(i+1));
         if (pi1->m_position.bottom < pi->m_position.bottom )
            swap(i+1,i);
                 else
            if (pi1->m_position.bottom == pi->m_position.bottom &&
                  pi1->m_position.top < pi->m_position.top )
               swap(i+1,i);
     }
   }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;
    CDrawObj *pi1;
    CRect rc;
    int iObjLength=0;
    double iSpace=0;
        double drop_loc;
        long ob_width;
    CSortedObList sol;


    NormalizeObjs();

    SaveStateForUndo();

    INT_PTR iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjLength)) / (iCount-1);
                drop_loc = ((double)rcL.right) + iSpace;
                }
    else
        {           //evenly space middles
                drop_loc = ((double)(rcL.left + rcL.right))/2;
        iSpace = (((double)(rcR.left + rcR.right))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_width = rc.right-rc.left;
                if (iObjLength < iSpan)
                        {
                        rc.left = (long)(drop_loc + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += (ob_width + iSpace);
                        }
       else
                {
                        rc.left = (long)(drop_loc - ob_width/2 + 0.5);
                        rc.right = rc.left + ob_width;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;
    int iObjHeight=0;
    double iSpace=0;
        double drop_loc;
        long ob_height;
    CSortedObList sol;
    CRect rc;
    CDrawObj *pi1;


    NormalizeObjs();

    SaveStateForUndo();

    INT_PTR iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
                {
        iSpace = ((double)(iSpan-iObjHeight)) / (iCount-1);
                drop_loc = ((double)rcB.top) + iSpace;
                }
    else
        {                      //evenly space middles
                drop_loc = ((double)(rcB.bottom + rcB.top))/2;
        iSpace = (((double)(rcT.bottom + rcT.top))/2 - drop_loc) /
                                (iCount-1);
                drop_loc += iSpace;
                }


    for (int i=1;i<iCount-1;i++)
        {
                pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
                rc = pi1->m_position;
                ob_height = rc.top - rc.bottom;

                if (iObjHeight < iSpan)
                        {
                        rc.bottom = (long)(drop_loc + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += (ob_height + iSpace);
                        }
                else
                        {
                        rc.bottom = (long)(drop_loc - ob_height/2 + 0.5);
                        rc.top = rc.bottom + ob_height;
                        drop_loc += iSpace;
                        }

                pi1->MoveTo(rc, this);
        }
}


#ifdef FUBAR
void CDrawView::OnSpaceAcross()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjLength=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToLeft();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjLength += (pobj->m_position.right - pobj->m_position.left);
    }

    CRect& rcR = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcL = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcR.right - rcL.left;

    if (iObjLength < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjLength) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcR.left + (rcR.right-rcR.left)/2)
                  - (rcL.left + (rcL.right-rcL.left)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjLength < iSpan) {
          rc.left = pi->m_position.right + iSpace;
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       else {
          int middleL = pi->m_position.left + ((pi->m_position.right-pi->m_position.left)/2);
          rc.left = (middleL+iSpace)-((pi1->m_position.right-pi1->m_position.left)/2);
          rc.right = rc.left + (pi1->m_position.right-pi1->m_position.left);
       }
       pi1->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnSpaceDown()
{
    CDrawObj* pobj;

    NormalizeObjs();

    SaveStateForUndo();

    int iCount = m_selection.GetCount();
    if (iCount <=2)
       return;

    int iObjHeight=0;
    int iSpace=0;

    CSortedObList sol;
    sol=m_selection;
    sol.SortToBottom();

    POSITION pos = sol.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)sol.GetNext(pos);
       iObjHeight += (pobj->m_position.top - pobj->m_position.bottom);
    }

    CRect& rcT = ((CDrawObj*) sol.GetAt( sol.FindIndex(iCount-1) ))->m_position;
    CRect& rcB = ((CDrawObj*) sol.GetAt( sol.FindIndex(0) ))->m_position;
    int iSpan= rcT.top - rcB.bottom;

    if (iObjHeight < iSpan)     //between spaces are even
       iSpace = (iSpan-iObjHeight) / (iCount-1);
    else                       //evenly space middles
       iSpace = ((rcT.bottom + (rcT.top-rcT.bottom)/2)
                  - (rcB.bottom + (rcB.top-rcB.bottom)/2)) / (iCount-1);

    CRect rc;
    CDrawObj* pi,*pi1;
    for (int i=0;i<iCount-2;i++) {
       pi=(CDrawObj*) sol.GetAt(sol.FindIndex(i));
       pi1=(CDrawObj*) sol.GetAt(sol.FindIndex(i+1));
       rc = pi1->m_position;
       if (iObjHeight < iSpan) {
          rc.bottom = pi->m_position.top + iSpace;
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       else {
          int middleL = pi->m_position.bottom + ((pi->m_position.top-pi->m_position.bottom)/2);
          rc.bottom = (middleL+iSpace)-((pi1->m_position.top-pi1->m_position.bottom)/2);
          rc.top = rc.bottom + (pi1->m_position.top-pi1->m_position.bottom);
       }
       pi1->MoveTo(rc, this);
    }
}
#endif


//--------------------------------------------------------------------------
void CDrawView::OnCenterWidth()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;
    }

    int iSpace = rc.left + ((rc.right - rc.left) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.left += -iSpace;
       rc.right += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


//--------------------------------------------------------------------------
void CDrawView::OnCenterHeight()
{
    if (m_selection.GetCount() < 1)
            return;

    SaveStateForUndo();

    CRect rc(0,0,0,0);

    POSITION pos = m_selection.GetHeadPosition();
    CDrawObj* pobj;
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
           pobj->m_position.NormalizeRect();
       rc |= pobj->m_position;   //requires Y increase downward
    }

    NormalizeRect(rc);
    NormalizeObjs();

    int iSpace = rc.bottom + ((rc.top - rc.bottom) /2);

    pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       pobj = (CDrawObj*)m_selection.GetNext(pos);
       rc = pobj->m_position;
       rc.bottom += -iSpace;
       rc.top += -iSpace;
       pobj->MoveTo(rc, this);
    }
}


void CDrawView::OnUpdateDrawEllipse(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == ellipse);
}


void CDrawView::OnUpdateDrawLine(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == line);
}

void CDrawView::OnUpdateDrawRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == rect);
}

void CDrawView::OnUpdateDrawText(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == text);
}

void CDrawView::OnUpdateDrawRoundRect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == roundRect);
}

void CDrawView::OnUpdateDrawSelect(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == select);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdatePosStatusBar(CCmdUI* pCmdUI)
{
    pCmdUI->Enable();
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateFaxText(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(FALSE);
}


//---------------------------------------------------------------------------
void CDrawView::OnUpdateSingleSelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() == 1);
}

void CDrawView::OnUpdateMoreThanOne(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 1);
}


void CDrawView::OnUpdateMove(CCmdUI* pCmdUI)
{
#if 0
   pCmdUI->Enable(m_selection.GetCount() == 1
         && GetDocument()->GetObjects()->GetCount()>1);
#endif

   //
   // BUG FIX for 33738, by a-juliar, 5-20-96
   //

      INT_PTR Count = m_selection.GetCount() ;
      pCmdUI->Enable( Count > 0
             && GetDocument()->GetObjects()->GetCount() > Count ) ;
}


#ifdef GRID
void CDrawView::OnUpdateSnapToGrid(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(m_bSnapToGrid);
}
#endif

void CDrawView::OnUpdateAlign(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() > 1);
}

void CDrawView::OnUpdateAlign3(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_selection.GetCount() >= 3);
}


#ifdef GRID
void CDrawView::OnUpdateGridSettings(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(1);
}
#endif


//-------------------------------------------------------------------------------
void CDrawView::OnEditSelectAll()
{
    CObList* pObList = GetDocument()->GetObjects();
    POSITION pos = pObList->GetHeadPosition();
    while (pos != NULL)
        Select((CDrawObj*)pObList->GetNext(pos));

    UpdateStatusBar();
    UpdateStyleBar();
}

//-------------------------------------------------------------------------------
void CDrawView::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetDocument()->GetObjects()->GetCount() != 0);
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditUndo()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit && m_pObjInEdit->CanUndo()){
        m_pObjInEdit->OnEditUndo() ;
        return ;
    }
    if(m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        m_pObjInEdit->HideEditWnd( this, FALSE );
    }
    m_selection.RemoveAll();
    GetDocument()->SwapListsForUndo();
    InvalidateRect( NULL );
  ///  GetDocument()->UpdateAllViews();
}

//-------------------------------------------------------------------------------
void CDrawView::OnEditClear()
{
    if (m_selection.GetCount() > 0){
       SaveStateForUndo();
    }
    // update all the views before the selection goes away
    GetDocument()->UpdateAllViews(NULL, HINT_DELETE_SELECTION, &m_selection);
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);

    // now remove the selection from the document
    POSITION pos = m_selection.GetHeadPosition();
    while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
           GetDocument()->Remove(pObj);
       GetDocument()->SetModifiedFlag();          //set document dirty
    }
    m_selection.RemoveAll();

    SetCursor(AfxGetApp()->LoadStandardCursor(IDC_ARROW));

    UpdateStatusBar();
}


//----------------------------------------------------------------------------------
void CDrawView::UpdateStatusBar()
{
    CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();
    if (!pFrame)
       return;

    if (CDrawView::GetView()->m_selection.GetCount()!=1) {
       pFrame->m_wndStatusBar.SetPaneText(1,_T(""));
       pFrame->m_wndStatusBar.SetPaneText(2,_T(""));
       return;
        }

    POSITION pos = m_selection.GetHeadPosition();
    if (pos==NULL)
           return;

    CDrawObj* pObj=(CDrawObj*)m_selection.GetNext(pos);

    CRect rc = pObj->m_position;
        CSize cs=CDrawDoc::GetDoc()->GetSize();

    CDrawView::GetView()->NormalizeRect(rc);
    rc.left+= cs.cx/2;
    rc.right+= cs.cx/2;
    rc.top = cs.cy/2-rc.top;
    rc.bottom = cs.cy/2 - rc.bottom;

    TCHAR szT1[] = _T(" %i,%i");
    TCHAR szT2[] = _T(" %ix%i");
    TCHAR sz[50];
    wsprintf(sz,szT1,rc.left,rc.top);
    pFrame->m_wndStatusBar.SetPaneText(1,sz);
    wsprintf(sz,szT2,rc.right-rc.left,rc.bottom-rc.top);
    pFrame->m_wndStatusBar.SetPaneText(2,sz);
}

void CDrawView::SaveStateForUndo()
{
    m_bCanUndo = TRUE ;
    CDrawDoc * pDoc = GetDocument() ;
    CObList * pPrevious = &pDoc->m_previousStateForUndo ;
    FreeObjectsMemory( pPrevious );
    pPrevious->RemoveAll();
    pDoc->CloneObjectsForUndo();
}

void CDrawView::FreeObjectsMemory( CObList * pObList )
{
    POSITION pos = pObList->GetHeadPosition();
    while( pos != NULL ){
        CObject * pObj = pObList->GetNext( pos ) ;
        CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
        if( pWhatClass == RUNTIME_CLASS( CDrawOleObj )){
            COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
            if (pItem)  { //remove client item from document
                pItem->Release(OLECLOSE_NOSAVE);
                pItem->InternalRelease();
            }
            delete pObj ;
        }
        else {
            delete pObj ;
        }
    }
}

void CDrawView::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( m_bCanUndo );
}

void CDrawView::OnUpdateAnySelect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!m_selection.IsEmpty());
}

void CDrawView::OnUpdateDrawPolygon(CCmdUI* pCmdUI)
{
    pCmdUI->SetRadio(CDrawTool::c_drawShape == poly);
}

void CDrawView::OnSize(UINT nType, int cx, int cy)
{
    CScrollView::OnSize(nType, cx, cy);
    UpdateActiveItem();
}

void CDrawView::OnViewGridLines()
{
    m_bGridLines = !m_bGridLines;
    Invalidate(FALSE);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewGridLines(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bGridLines);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateFont(CCmdUI* pCmdUI)
{
   if (m_pObjInEdit) 
   {
      pCmdUI->Enable(TRUE);
      return;
   }

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL)
   {
     if (((CDrawObj*)m_selection.GetNext(pos))->IsKindOf(RUNTIME_CLASS(CDrawText))) 
     {
        pCmdUI->Enable(TRUE);
        return;
     }
   }

   pCmdUI->Enable(FALSE);
}


//--------------------------------------------------------------------------
int CDrawView::GetPointSize(CDrawText& TextObj)
{
   return abs(MulDiv(TextObj.m_logfont.lfHeight,72,100));

/*
   TEXTMETRIC tm;
   CClientDC dc(TextObj.m_pEdit);
   dc.SelectObject(TextObj.m_pEdit->GetFont());
   dc.GetTextMetrics(&tm);
   int pointsize = MulDiv( (tm.tmHeight-tm.tmInternalLeading),72,dc.GetDeviceCaps(LOGPIXELSY) );
   return pointsize;
*/
}


BOOL CDrawView::OnEraseBkgnd(CDC* pDC)
{
    return TRUE;
}


void CDrawView::OnObjectMoveBack()
{
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList* pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetHeadPosition()) {
          POSITION posPrev = pos;
          pObjects->GetPrev(posPrev);
          pObjects->RemoveAt(pos);
          pObjects->InsertBefore(posPrev, pObj);
      pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveForward()
{
   CDrawDoc* pDoc = GetDocument();
   CDrawObj* pObj = (CDrawObj*)m_selection.GetHead();
   CObList* pObjects = pDoc->GetObjects();
   POSITION pos = pObjects->Find(pObj);
   ASSERT(pos != NULL);
   if (pos != pObjects->GetTailPosition()) {
          POSITION posNext = pos;
          pObjects->GetNext(posNext);
          pObjects->RemoveAt(pos);
          pObjects->InsertAfter(posNext, pObj);
          pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToBack()
{
   SaveStateForUndo();
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   POSITION s_pos = m_selection.GetTailPosition();
   while( s_pos != NULL ){
       CDrawObj* pObj = (CDrawObj*)m_selection.GetPrev( s_pos ) ;
       POSITION o_pos = pObjects->Find(pObj);
       ASSERT(o_pos != NULL);
       pObjects->RemoveAt(o_pos);
       pObjects->AddHead(pObj);
       pObj->Invalidate();
   }
   pDoc->SetModifiedFlag();
}

void CDrawView::OnObjectMoveToFront()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        return;
    }

    SaveStateForUndo();

    CDrawDoc* pDoc = GetDocument();
    CObList* pObjects = pDoc->GetObjects();
    POSITION s_pos = m_selection.GetHeadPosition();
    while( s_pos != NULL ){
        CDrawObj* pObj = (CDrawObj*)m_selection.GetNext( s_pos ) ;
        POSITION o_pos = pObjects->Find(pObj);
        ASSERT(o_pos != NULL);
        pObjects->RemoveAt(o_pos);
        pObjects->AddTail(pObj);
        pObj->Invalidate();
    }
    pDoc->SetModifiedFlag();
}


void CDrawView::OnEditCopy()
{
   ASSERT_VALID(this);
   ASSERT(m_cfDraw != NULL);

   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_COPY,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   // Create a shared file and associate a CArchive with it
   CSharedFile file;
   CArchive ar(&file, CArchive::store);

   // Serialize selected objects to the archive
   m_selection.Serialize(ar);
   ar.Close();

   COleDataSource* pDataSource = NULL;

   CDrawOleObj* pDrawOle = (CDrawOleObj*)m_selection.GetHead();
   TRY {
        pDataSource = new COleDataSource;
        // put on local format instead of or in addation to
        pDataSource->CacheGlobalData(m_cfDraw, file.Detach());

        // if only one item and it is a COleClientItem then also
        // paste in that format
        if (m_selection.GetCount() == 1 &&
                pDrawOle->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
        {
                pDrawOle->m_pClientItem->GetClipboardData(pDataSource, FALSE);
        }
        pDataSource->SetClipboard();
   }
   CATCH_ALL(e)
   {
        delete pDataSource;
        THROW_LAST();
   }
   END_CATCH_ALL
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCopy(CCmdUI* pCmdUI)
{
    // WRONG! don't enable COPY just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit){
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        if( nStartChar < nEndChar ){
            pCmdUI->Enable( TRUE );
            return;
        }
    }
    pCmdUI->Enable(!m_selection.IsEmpty());

}


//--------------------------------------------------------------------------
void CDrawView::OnEditCut()
{
   if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
       m_pObjInEdit->m_pEdit->SendMessage(WM_CUT,0,0L);
       m_pObjInEdit->m_bUndoAlignment = FALSE ;
       m_pObjInEdit->m_bUndoFont = FALSE ;
       m_pObjInEdit->m_bUndoTextChange = TRUE ;
       return;
   }

   OnEditCopy();
   OnEditClear();
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditCut(CCmdUI* pCmdUI)
{
    // WRONG! don't enable CUT just because an edit control has input focus! Must have
    // selected text with non-zero length. a-juliar, 9-5-96
    // pCmdUI->Enable(!m_selection.IsEmpty() || (m_pObjInEdit && m_pObjInEdit->m_pEdit));

    if(m_pObjInEdit && m_pObjInEdit->m_pEdit){
        int nStartChar, nEndChar ;
        m_pObjInEdit->m_pEdit->GetSel( nStartChar, nEndChar );
        if( nStartChar < nEndChar ){
            pCmdUI->Enable( TRUE );
            return;
        }
    }
    pCmdUI->Enable(!m_selection.IsEmpty());
}


//--------------------------------------------------------------------------

void CDrawView::OnEditPaste()
{
    if (m_pObjInEdit && m_pObjInEdit->m_pEdit) { //handle by edit control
        m_pObjInEdit->m_pEdit->SendMessage(WM_PASTE,0,0L);
        m_pObjInEdit->m_bUndoAlignment = FALSE ;
        m_pObjInEdit->m_bUndoFont = FALSE ;
        m_pObjInEdit->m_bUndoTextChange = TRUE ;
        return;
    }

    COleDataObject dataObject;
    dataObject.AttachClipboard();

    // invalidate current selection since it will be deselected
    OnUpdate(NULL, HINT_UPDATE_SELECTION, NULL);
    m_selection.RemoveAll();
    if (dataObject.IsDataAvailable(m_cfDraw)) {
        PasteNative(dataObject);
        //
        // Adjust position of all items in m_selection and add them to the document
        //
        POSITION pos = m_selection.GetHeadPosition();

        while (pos != NULL) {
            CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos) ;
            CRect rect = pObj->m_position;
            rect.top-=10;
            rect.bottom-=10;
            rect.left+=10;
            rect.right+=10;
            pObj->MoveTo( rect, this );
            GetDocument()->Add(pObj);
        }
        OnEditCopy();   /// Fix for bug 44896. Position adjustments above now are in clipboard.
                        /// so that next paste will be offset just a little bit more. 6-19-96
    }
    else {
        PasteEmbedded(dataObject);
    }

    GetDocument()->SetModifiedFlag();

    // invalidate new pasted stuff
    GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_SELECTION, &m_selection);
}

//--------------------------------------------------------------------------
void CDrawView::OnUpdateEditPaste(CCmdUI* pCmdUI)
{
    // Revised by a-juliar, 9-18-96.  Don't allow pastiing a second note rect into the document.

    if (m_pObjInEdit && m_pObjInEdit->m_pEdit ){
        pCmdUI->Enable( ::IsClipboardFormatAvailable(CF_TEXT)); // a-juliar, 9-5-96
        return ;
    }

    //
    // determine if private or standard OLE formats are on the clipboard
    //

    COleDataObject dataObject;
    BOOL bAvailable ;
    BOOL bEnable = dataObject.AttachClipboard() &&
        ((bAvailable = dataObject.IsDataAvailable(m_cfDraw)) ||
        COleClientItem::CanCreateFromData(&dataObject));

    // enable command based on availability
    if( !bEnable ) {
        pCmdUI->Enable(FALSE);
        return ;
    }
    if( !bAvailable ) { // Clipboard has a standard OLE format on it.
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // Enable PASTE unless both of the following hold:
    // 1. Document already has a NOTE field
    // 2. Clipboard has a note field.
    //
    BOOL bDocAlreadyHasNoteRect = FALSE ;
    POSITION pos;
    CFaxProp* pfaxprop ;
    pos = GetDocument()->m_objects.GetHeadPosition();
    while (pos != NULL)
    {
        CDrawObj* pObj = (CDrawObj*) GetDocument()->m_objects.GetNext(pos);
        if( pObj->IsKindOf(RUNTIME_CLASS(CFaxProp)) )
        {
            pfaxprop = (CFaxProp *)pObj;
            if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE )
            {
                 bDocAlreadyHasNoteRect = TRUE ;
            }
        }
    }
    if( !bDocAlreadyHasNoteRect )
    {
        pCmdUI->Enable(TRUE);
        return ;
    }
    //
    // See if there is a NOTE on the clipboard
    //

    CObList ClipboardList ;
    TRY{
        CFile* pFile = dataObject.GetFileData(m_cfDraw);
        if (pFile == NULL){
            pCmdUI->Enable(FALSE);
            return;
        }
        CArchive ar(pFile, CArchive::load);
        ar.m_pDocument = GetDocument(); // set back-pointer in archive
        ClipboardList.Serialize(ar);
        ar.Close();
        delete pFile;
        //
        // Traverse the list ClipboardList to look for NOTE and free memory.
        //
        POSITION pos = ClipboardList.GetHeadPosition();
        while( pos != NULL ){
            CObject * pObj = ClipboardList.GetNext( pos ) ;
            CRuntimeClass* pWhatClass = pObj->GetRuntimeClass() ;
            if( pWhatClass == RUNTIME_CLASS( CFaxProp )){
                pfaxprop = (CFaxProp *)pObj;
                if( pfaxprop->GetResourceId() == IDS_PROP_MS_NOTE ){

                         bEnable = FALSE ;
                }
                delete pObj ;
            }
            else if( pWhatClass == RUNTIME_CLASS( CDrawOleObj )){
                COleClientItem* pItem=((CDrawOleObj*)pObj)->m_pClientItem;
                if (pItem)  { //remove client item from document
                    pItem->Release(OLECLOSE_NOSAVE);
                    ////GetDocument->RemoveItem(((CDrawOleObj*)pObj)->m_pClientItem); ///
                    pItem->InternalRelease();
                }
                delete pObj ;
            }
            else {
                delete pObj ;
            }
        }
        ClipboardList.RemoveAll();
    }
    CATCH_ALL(e)
    {
        pCmdUI->Enable( FALSE );
        return ;
    }
    END_CATCH_ALL
    pCmdUI->Enable(bEnable);
}


//--------------------------------------------------------------------------
void CDrawView::OnFilePrint()
{
   m_selection.RemoveAll();
   if ( ((CDrawApp*)AfxGetApp())->m_dwSesID!=0) {
   ///////   Render();
          return;
   }


   CScrollView::OnFilePrint();

   //GetDocument()->ComputePageSize();
}


//--------------------------------------------------------------------------
#if 0
void CDrawView::Render()
{
   CString strTemp;
   CDrawDoc *pdoc = GetDocument();
   HANDLE hprt;
   LONG   dev_size;
   DEVMODE *dev_buf = NULL;

   // setup the printing DC
   TRACE(TEXT("AWCPE:  CPEVW.CPP.Render() called\n"));

   if( !OpenPrinter( (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice, &hprt, NULL ) )
          {
      TRACE(TEXT("CPEVW.Render: unable to open printer\n"));
      throw "render failed";
          }


   dev_size =
                DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                NULL,
                                                    NULL,
                                                    0 );

        dev_buf = (DEVMODE *)new BYTE[ dev_size ];

        if( (dev_size == 0)||(dev_buf == NULL) )
          {
          ClosePrinter( hprt );
      TRACE(TEXT("CPEVW.Render: unable to make dev_buf\n"));
      throw "render failed";
          }


        DocumentProperties( this->GetSafeHwnd(),
                                                hprt,
                                                (LPTSTR)(LPCTSTR)GetApp()->m_szRenderDevice,
                                                dev_buf,
                                            NULL,
                                            DM_OUT_BUFFER );

        ClosePrinter( hprt );


    dev_buf->dmPaperSize   = pdoc->m_wPaperSize;
    dev_buf->dmOrientation = pdoc->m_wOrientation;

        // use doc scale only if printer supports scaling
        if( dev_buf->dmFields & DM_SCALE        )
        dev_buf->dmScale   = pdoc->m_wScale;
        else
        dev_buf->dmScale   = 100;


   CDC dcPrint;
   if( dcPrint.CreateDC(_T("winspool"),GetApp()->m_szRenderDevice,NULL,
                (void *)dev_buf )==0)
        {
                delete [] dev_buf;

      TRACE(TEXT("CPEVW.Render: unable to create a printer DC\n"));
      throw "render failed";
        }



        delete [] dev_buf;

        // reset note position
        theApp.reset_note();


   dcPrint.m_bPrinting=TRUE;

   DOCINFO docInfo;
   memset(&docInfo, 0, sizeof(DOCINFO));
   docInfo.cbSize = sizeof(DOCINFO);
   docInfo.lpszDocName = GetDocument()->GetTitle();
   docInfo.lpszOutput = NULL;

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartDoc() called\n"));
   if (dcPrint.StartDoc(&docInfo) == SP_ERROR) {
      TRACE(TEXT("CPEVW.Render: unable to StartDoc\n"));
      throw "render failed";
   }

   OnPrepareDC(&dcPrint,NULL);

   TRACE(TEXT("AWCPE:  CPEVW.CPP.StartPage() called\n"));
   if (dcPrint.StartPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
      throw "render failed";
   }


   // set up for note pages
   //
   // NOTE TO RAND:
   //   The extra note must be created BEFORE OnPrint so that
   //   any page-no objects can properly guess how many pages
   //   are left after the note object has consumed some of the
   //   note text. page-no objects are sorted to be after note
   //   objects in the objects list so they will be drawn after
   //   the note object has drawn. Setting of theApp.m_last_note_box
   //   has been done before this point so that the extranote
   //   will be created with the proper font, etc (bug fix for
   //   3647).
   //
   if( theApp.m_note_wasread )
                make_extranote( &dcPrint );

   OnPrint(&dcPrint, NULL);



   // get rid of surprise dialogs
   pdoc->SetModifiedFlag( FALSE );

   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndPage() called\n"));
   if (dcPrint.EndPage() < 0) {
      TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
      throw "render failed";
   }


        // see if we need extra note pages
        if( theApp.m_note_wasread )
                {
                if( theApp.m_extra_notepage != NULL )
                        {
                        // print page sized chunks untill note is consumed
                        while( theApp.more_note() )
                                {
                                if( dcPrint.StartPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to StartPage\n"));
                                        throw "render failed";
                                        }

                                theApp.m_extra_notepage->Draw( &dcPrint, this );

                                if( dcPrint.EndPage() < 0 )
                                        {
                                        TRACE(TEXT("CPEVW.Render: unable to EndPage\n"));
                                        throw "render failed";
                                        }
                                }

                        delete theApp.m_extra_notepage;
                        theApp.m_extra_notepage = NULL;
                        }

                // get rid of surprise dialogs
                pdoc->SetModifiedFlag( FALSE );
                }


   TRACE(TEXT("AWCPE:  CPEVW.CPP.EndDoc() called\n"));
   if( dcPrint.EndDoc() < 0 )
          {
      TRACE(TEXT("CPEVW.Render: unable to EndDoc\n"));
      throw "render failed";
      }
/*
   if (pDMOut)
      delete [] (BYTE*) pDMOut;
 */
}
#endif





void CDrawView::make_extranote( CDC *pdc )
        {
        CRect note_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect physical_margins;
        CRect note_margins;

        physical_margins.left = pdc->GetDeviceCaps( PHYSICALOFFSETX );
        physical_margins.top = pdc->GetDeviceCaps( PHYSICALOFFSETY );
        physical_margins.right =
                pdc->GetDeviceCaps( PHYSICALWIDTH ) -
                        (physical_margins.left + pdc->GetDeviceCaps( HORZRES ));
        physical_margins.bottom =
                pdc->GetDeviceCaps( PHYSICALHEIGHT ) -
                        (physical_margins.top + pdc->GetDeviceCaps( VERTRES ));


        note_margins.left   = -physical_margins.left;
        note_margins.top    = -physical_margins.top;
        note_margins.right  =
                pdc->GetDeviceCaps( HORZRES ) + physical_margins.right;
        note_margins.bottom =
                pdc->GetDeviceCaps( VERTRES ) + physical_margins.bottom;

        ClientToDoc( note_margins, pdc );


        note_rect.left =
                note_rect.top = 0;
        note_rect.right  = pdc->GetDeviceCaps( HORZRES );
        note_rect.bottom = pdc->GetDeviceCaps( VERTRES );

        ClientToDoc( note_rect, pdc );


        note_margins.left   += 125;     // 1.25"
        note_margins.top    -= 100;     // 1.00"
        note_margins.right  -= 125; // 1.25"
        note_margins.bottom += 100; // 1.00"

        if( note_margins.left > note_rect.left )
                note_rect.left = note_margins.left;

        if( note_margins.top < note_rect.top )
                note_rect.top = note_margins.top;

        if( note_margins.right < note_rect.right )
                note_rect.right = note_margins.right;

        if( note_margins.bottom > note_rect.bottom )
                note_rect.bottom = note_margins.bottom;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;


// F I X  for 3647 /////////////
//
//FIX FOR 3647 reenables the following 'if' (by commenting out the FALSE)
        if( /*FALSE*/ theApp.m_last_note_box != NULL )
////////////////////////////////
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = note_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( note_rect, IDS_PROP_MS_NOTE );

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
        theApp.m_extra_notepage->m_logfont = theApp.m_default_logfont;
        theApp.m_extra_notepage->
                ChgLogfont( theApp.m_extra_notepage->m_logfont );
////////////////////////////////
                }
        }





#ifdef FUBAR
void CDrawView::make_extranote( CDC *pdc )
        {
        CSize doc_size;
        CRect doc_rect;
        CDrawDoc *pdoc = GetDocument();
        CRect note_size;


        if( theApp.m_extra_notepage != NULL )
                delete theApp.m_extra_notepage;

        theApp.m_extrapage_count = -1; // forces a recalc in CFaxprop::Draw
        theApp.m_extra_notepage = NULL;

        doc_size = pdoc->GetSize();

        // shrink by 6% to allow for transform round off
        // and printer edge
        //
        // This is probably a bug. I'll look at it later. The
        // vieworigin seems to be off a little and the printed
        // page is clipped without this kludge
        //
        doc_size.cx     = (doc_size.cx * 94)/100;
        doc_size.cy     = (doc_size.cy * 94)/100;

        // make page sized rect
        doc_rect.left   = -doc_size.cx/2;
        doc_rect.top    =  doc_size.cy/2;
        doc_rect.right  =  doc_rect.left + doc_size.cx;
        doc_rect.bottom =  doc_rect.top - doc_size.cy;


        if( theApp.m_last_note_box != NULL )
                {
                // make a temp faxprop out of the last note prop so
                // extra pages will have same attrs (line drawn around box,
                // font, etc.)
                theApp.m_extra_notepage =
                        (CFaxProp *)theApp.m_last_note_box->Clone( NULL );

                theApp.m_extra_notepage->m_position = doc_rect;
                }
        else
                {
                // Weren't any note objects, make a default one
                theApp.m_extra_notepage =
                        new CFaxProp( doc_rect, IDS_PROP_MS_NOTE );
                }
        }
#endif





//--------------------------------------------------------------------------
void CDrawView::OnViewShowObjects()
{
   CDrawOleObj::c_bShowItems = !CDrawOleObj::c_bShowItems;
   GetDocument()->UpdateAllViews(NULL, HINT_UPDATE_OLE_ITEMS, NULL);
}


//--------------------------------------------------------------------------
void CDrawView::OnUpdateViewShowObjects(CCmdUI* pCmdUI)
{
   pCmdUI->SetCheck(CDrawOleObj::c_bShowItems);
}


//-------------------------------------------------------------------------
void CDrawView::OnEditProperties()
{
   if (m_selection.GetCount() < 1 || CDrawTool::c_drawShape != select)
      return;

   CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
   ASSERT(pTool != NULL);

   CObjPropDlg dlg(this);

   if (dlg.DoModal() != IDOK)
       return;

   SaveStateForUndo();  // Assume a change has been made, and make it undoable.

   CString szColorBlack;
   szColorBlack.LoadString(ID_COLOR_BLACK);
   CString szColorWhite;
   szColorWhite.LoadString(ID_COLOR_WHITE);
   CString szColorLTGRAY;
   szColorLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szColorMDGRAY;
   szColorMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szColorDKGRAY;
   szColorDKGRAY.LoadString(ID_COLOR_DKGRAY);

   COLORREF crFillColor;
   if (dlg.m_szFillColor==szColorBlack)
        crFillColor=COLOR_BLACK;
   else if (dlg.m_szFillColor==szColorWhite)
        crFillColor=COLOR_WHITE;
   else if (dlg.m_szFillColor==szColorLTGRAY)
        crFillColor=COLOR_LTGRAY;
   else if (dlg.m_szFillColor==szColorMDGRAY)
        crFillColor=COLOR_MDGRAY;
   else if (dlg.m_szFillColor==szColorDKGRAY)
         crFillColor=COLOR_DKGRAY;
   else
         crFillColor=COLOR_WHITE;

   if(!dlg.m_bRBFillColor)
   {
       //
       // Use white auto color for transparent background
       //
       crFillColor = COLOR_WHITE;
   }

   COLORREF crLineColor;
   if (dlg.m_szLineColor==szColorBlack)
      crLineColor=COLOR_BLACK;
   else if (dlg.m_szLineColor==szColorWhite)
         crLineColor=COLOR_WHITE;
   else if (dlg.m_szLineColor==szColorLTGRAY)
         crLineColor=COLOR_LTGRAY;
   else if (dlg.m_szLineColor==szColorMDGRAY)
         crLineColor=COLOR_MDGRAY;
   else if (dlg.m_szLineColor==szColorDKGRAY)
         crLineColor=COLOR_DKGRAY;
   else
         crLineColor=COLOR_BLACK;

   COLORREF crTextColor;
   if (dlg.m_szTextColor==szColorBlack)
      crTextColor=COLOR_BLACK;
   else if (dlg.m_szTextColor==szColorWhite)
        crTextColor=COLOR_WHITE;
   else if (dlg.m_szTextColor==szColorLTGRAY)
        crTextColor=COLOR_LTGRAY;
   else if (dlg.m_szTextColor==szColorMDGRAY)
        crTextColor=COLOR_MDGRAY;
   else if (dlg.m_szTextColor==szColorDKGRAY)
        crTextColor=COLOR_DKGRAY;
   else
        crTextColor=COLOR_BLACK;

   long lPointSize = _ttol(dlg.m_szThickness);   //integrity check for line thickness

   if (lPointSize < 0)
   {
      lPointSize=1;
   }
   else if (lPointSize==0) 
   {
        dlg.m_bCBDrawBorder=FALSE;
        lPointSize=1;
   }
   else if (lPointSize>72)
   {
        lPointSize=72;
   }

   POSITION pos = m_selection.GetHeadPosition();
   while (pos != NULL) 
   {
      CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
      pObj->Invalidate();
      pObj->m_bPen=dlg.m_bCBDrawBorder;
      pObj->m_bBrush=dlg.m_bRBFillColor;
      
      long nPS=lPointSize*100/72;
      pObj->m_lLinePointSize=lPointSize;

      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawLine)))      
      {
         //this correct line m_position for chgs in thickness
         CDrawLine* pLineObj = (CDrawLine*)pObj;
         CRect rc = pLineObj->m_position;
         pLineObj->AdjustLineForPen(rc);
         pLineObj->m_logpen.lopnWidth.y=pLineObj->m_logpen.lopnWidth.x=nPS;
         pLineObj->NegAdjustLineForPen(rc);
         pLineObj->m_position=rc;
      }
      else
      {
         pObj->m_logpen.lopnWidth.y=pObj->m_logpen.lopnWidth.x=nPS;
      }
      
      pObj->m_logpen.lopnColor = crLineColor;
      pObj->m_logbrush.lbColor = crFillColor;

      if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText))) 
      {
          CDrawText* pText = (CDrawText*)pObj;
          pText->m_crTextColor = crTextColor;
          pText->FitEditWnd(this);
          pText->NewBrush();
      }

      pObj->Invalidate();
   }

   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
   CDrawDoc* pDoc = GetDocument();
   CObList* pObjects = pDoc->GetObjects();
   if (!pObjects) 
   {
      CScrollView::OnChar(nChar,nRepCnt,nFlags);
      return;
   }

   POSITION pos;
   CDrawObj* pObj;

   if (nChar == VK_TAB && 
      (m_selection.GetCount()==1 || m_pObjInEdit) &&
       pObjects->GetCount() > 1 ) 
   {
      if (m_pObjInEdit)
             pos = pObjects->Find(m_pObjInEdit);
      else 
      {
            pObj = (CDrawObj*)m_selection.GetHead();
            pos = pObjects->Find(pObj);
      }

      BOOL bShift = ::GetKeyState(VK_SHIFT) & 0x8000;

      if (bShift)
            pObjects->GetPrev(pos);
      else
            pObjects->GetNext(pos);

      if (pos==NULL)
             if (bShift)
               pObj=(CDrawObj*)pObjects->GetTail();
             else
               pObj=(CDrawObj*)pObjects->GetHead();
      else
             pObj=(CDrawObj*)pObjects->GetAt(pos);

      Select(NULL);
      Select(pObj);
      UpdateStatusBar();
      UpdateStyleBar();
      pDoc->SetModifiedFlag();
   }
   else if (m_pObjInEdit && pObjects->GetCount()==1) 
   {
         CDrawObj* p = m_pObjInEdit;
         Select(NULL);
         Select(m_pObjInEdit);
         UpdateStatusBar();
         UpdateStyleBar();
   }
   else
   {
     CScrollView::OnChar(nChar,nRepCnt,nFlags);
   }
}


void CDrawView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch (nChar) 
    {
    case VK_LEFT:
    case VK_RIGHT:
    case VK_UP:
    case VK_DOWN:
       if (m_selection.GetCount() >=1 &&  m_pObjInEdit==NULL) 
       {
          CDrawTool* pTool = CDrawTool::FindTool(CDrawTool::c_drawShape);
          if (pTool != NULL)
             pTool->OnArrowKey(this, nChar, nRepCnt, nFlags);
       }
       break;

    case VK_SHIFT:
        if (m_bKU) 
        {
            m_bShiftSignal=TRUE;
            m_bKU=FALSE;
        }
        break;
    }

    CScrollView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CDrawView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
        switch (nChar) {
                case VK_SHIFT:
                    m_bKU=TRUE;
                        break;
        }

    CScrollView::OnKeyUp(nChar, nRepCnt, nFlags);
}

BOOL
CDrawView::IsHighContrast()
{
    HIGHCONTRAST highContrast = {0};
    highContrast.cbSize = sizeof(highContrast);

    if(!SystemParametersInfo(SPI_GETHIGHCONTRAST, 0, (PVOID)&highContrast, 0))
    {
        TRACE(TEXT("SystemParametersInfo failed: %d"), ::GetLastError());
        return FALSE;
    }

    return ((highContrast.dwFlags & HCF_HIGHCONTRASTON) == HCF_HIGHCONTRASTON);
}

void 
CDrawView::OnSysColorChange()
{
    return CScrollView::OnSysColorChange();    
}

//-------------------------------------------------------------------------
void CDrawView::OnEditChange()
{
   m_pDocument->SetModifiedFlag();
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
   BOOL bEnable = m_selection.GetCount() >= 1 && CDrawTool::c_drawShape == select;
   if (bEnable) 
   {
        bEnable=FALSE;
        POSITION pos = m_selection.GetHeadPosition();
        while (pos != NULL) 
        {
            CDrawObj* pObj = (CDrawObj*)m_selection.GetNext(pos);
            if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj))) 
            {
                bEnable=TRUE;
                break;
            }
        }
   }

   pCmdUI->Enable(bEnable);
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateToList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_TO_LIST ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnUpdateCcList(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_CC_LIST ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCompany(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COMPANY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecAddress(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STREET_ADDRESS ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCity(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_CITY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecState(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_STATE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecZipCode(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_ZIP_CODE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecCountry(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_COUNTRY ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecTitle(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_TITLE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecDept(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_DEPARTMENT ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficeLoc(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_LOCATION ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecHomePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_HOME_PHONE ) ? TRUE : FALSE );
}
//-------------------------------------------------------------------------
void CDrawView::OnUpdateRecOfficePhone(CCmdUI* pCmdUI)
{
    pCmdUI->Enable((  m_dwEfcFields & COVFP_REC_OFFICE_PHONE ) ? TRUE : FALSE );
}

//-------------------------------------------------------------------------
void CDrawView::OnFilePrintPreview()
{
   CScrollView::OnFilePrintPreview();
}


/////////////////////////////////////////////////////////////////////////////
// CDrawView diagnostics

#ifdef _DEBUG
void CDrawView::AssertValid() const
{
        CScrollView::AssertValid();
}

void CDrawView::Dump(CDumpContext& dc) const
{
        CScrollView::Dump(dc);
}
#endif //_DEBUG





//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CDrawView, CScrollView)
   //{{AFX_MSG_MAP(CDrawView)
   ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
   ON_COMMAND(ID_CANCEL_EDIT, OnCancelEdit)
   ON_WM_SYSCOLORCHANGE()
   ON_WM_CONTEXTMENU()
   ON_WM_LBUTTONDOWN()
   ON_WM_KEYDOWN()
   ON_WM_KEYUP()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_LBUTTONDBLCLK()
   ON_WM_SETFOCUS()
   ON_WM_KILLFOCUS()
   ON_EN_CHANGE(ID_TEXT, OnEditChange)
   ON_COMMAND(ID_MAPI_RECIP_NAME,       OnMAPIRecipName)
   ON_COMMAND(ID_MAPI_RECIP_FAXNUM,     OnMAPIRecipFaxNum)
   ON_COMMAND(ID_MAPI_RECIP_COMPANY,    OnMAPIRecipCompany)
   ON_COMMAND(ID_MAPI_RECIP_ADDRESS,    OnMAPIRecipAddress)
   ON_COMMAND(ID_MAPI_RECIP_CITY,       OnMAPIRecipCity)
   ON_COMMAND(ID_MAPI_RECIP_STATE,      OnMAPIRecipState)
   ON_COMMAND(ID_MAPI_RECIP_POBOX,      OnMAPIRecipPOBox)
   ON_COMMAND(ID_MAPI_RECIP_ZIPCODE,    OnMAPIRecipZipCode)
   ON_COMMAND(ID_MAPI_RECIP_COUNTRY,    OnMAPIRecipCountry)
   ON_COMMAND(ID_MAPI_RECIP_TITLE,      OnMAPIRecipTitle)
   ON_COMMAND(ID_MAPI_RECIP_DEPT,       OnMAPIRecipDept)
   ON_COMMAND(ID_MAPI_RECIP_OFFICELOC,  OnMAPIRecipOfficeLoc)
   ON_COMMAND(ID_MAPI_RECIP_HMTELENUM,  OnMAPIRecipHMTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_OFTELENUM,  OnMAPIRecipOFTeleNum)
   ON_COMMAND(ID_MAPI_RECIP_TOLIST,     OnMAPIRecipToList)
   ON_COMMAND(ID_MAPI_RECIP_CCLIST,     OnMAPIRecipCCList)
   ON_COMMAND(ID_MAPI_SENDER_NAME,      OnMAPISenderName)
   ON_COMMAND(ID_MAPI_SENDER_FAXNUM,    OnMAPISenderFaxNum)
   ON_COMMAND(ID_MAPI_SENDER_COMPANY,   OnMAPISenderCompany)
   ON_COMMAND(ID_MAPI_SENDER_ADDRESS,   OnMAPISenderAddress)
   ON_COMMAND(ID_MAPI_SENDER_TITLE,     OnMAPISenderTitle)
   ON_COMMAND(ID_MAPI_SENDER_DEPT,      OnMAPISenderDept)
   ON_COMMAND(ID_MAPI_SENDER_OFFICELOC, OnMAPISenderOfficeLoc)
   ON_COMMAND(ID_MAPI_SENDER_HMTELENUM, OnMAPISenderHMTeleNum)
   ON_COMMAND(ID_MAPI_SENDER_OFTELENUM, OnMAPISenderOFTeleNum)
   ON_COMMAND(ID_MAPI_MSG_SUBJECT,      OnMAPIMsgSubject)
   ON_COMMAND(ID_MAPI_MSG_TIMESENT,     OnMAPIMsgTimeSent)
   ON_COMMAND(ID_MAPI_MSG_NUMPAGES,     OnMAPIMsgNumPages)
   ON_COMMAND(ID_MAPI_MSG_ATTACH,       OnMAPIMsgAttach)
   ON_COMMAND(ID_MAPI_MSG_BILLCODE,     OnMAPIMsgBillCode)
   ON_COMMAND(ID_MAPI_MSG_FAXTEXT,      OnMAPIMsgFaxText)
   ON_COMMAND(ID_FONT,              OnFont)
   ON_COMMAND(ID_DRAW_SELECT,       OnDrawSelect)
   ON_COMMAND(ID_DRAW_ROUNDRECT,    OnDrawRoundRect)
   ON_COMMAND(ID_DRAW_RECT,         OnDrawRect)
   ON_COMMAND(ID_DRAW_TEXT,         OnDrawText)
   ON_COMMAND(ID_DRAW_LINE,         OnDrawLine)
   ON_COMMAND(ID_DRAW_ELLIPSE,      OnDrawEllipse)
   ON_CBN_EDITCHANGE(ID_FONT_NAME,  OnEditChangeFont)
   ON_CBN_SELENDOK(ID_FONT_SIZE,    OnSelEndOKFontSize)
   ON_COMMAND(ID_STYLE_BOLD,        OnStyleBold)
   ON_COMMAND(ID_STYLE_ITALIC,      OnStyleItalic)
   ON_COMMAND(ID_STYLE_UNDERLINE,   OnStyleUnderline)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS1,  OnUpdatePosStatusBar)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ELLIPSE,    OnUpdateDrawEllipse)
   ON_UPDATE_COMMAND_UI(ID_DRAW_LINE,       OnUpdateDrawLine)
   ON_UPDATE_COMMAND_UI(ID_DRAW_RECT,       OnUpdateDrawRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_TEXT,       OnUpdateDrawText)
   ON_UPDATE_COMMAND_UI(ID_DRAW_ROUNDRECT,  OnUpdateDrawRoundRect)
   ON_UPDATE_COMMAND_UI(ID_DRAW_SELECT,     OnUpdateDrawSelect)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERWIDTH,  OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEBACK,     OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_MAPI_MSG_FAXTEXT,    OnUpdateFaxText)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNLEFT,    OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEACROSS,  OnUpdateAlign3)
   ON_COMMAND(ID_EDIT_SELECT_ALL,               OnEditSelectAll)
   ON_COMMAND(ID_EDIT_CLEAR,    OnEditClear)
   ON_COMMAND(ID_EDIT_UNDO,     OnEditUndo)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR,      OnUpdateAnySelect)
   ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO,       OnUpdateEditUndo)
   ON_COMMAND(ID_DRAW_POLYGON,              OnDrawPolygon)
   ON_UPDATE_COMMAND_UI(ID_DRAW_POLYGON,    OnUpdateDrawPolygon)
   ON_WM_SIZE()
   ON_COMMAND(ID_LAYOUT_ALIGNLEFT,      OnAlignLeft)
   ON_COMMAND(ID_LAYOUT_ALIGNRIGHT,     OnAlignRight)
   ON_COMMAND(ID_LAYOUT_ALIGNTOP,       OnAlignTop)
   ON_COMMAND(ID_LAYOUT_ALIGNBOTTOM,    OnAlignBottom)
   ON_COMMAND(ID_LAYOUT_ALIGNHORZCENTER, OnAlignHorzCenter)
   ON_COMMAND(ID_LAYOUT_ALIGNVERTCENTER, OnAlignVertCenter)
   ON_COMMAND(ID_LAYOUT_SPACEACROSS,    OnSpaceAcross)
   ON_COMMAND(ID_LAYOUT_SPACEDOWN,      OnSpaceDown)
   ON_COMMAND(ID_LAYOUT_CENTERWIDTH,    OnCenterWidth)
   ON_COMMAND(ID_LAYOUT_CENTERHEIGHT,   OnCenterHeight)
   ON_COMMAND(ID_VIEW_GRIDLINES,        OnViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_VIEW_GRIDLINES,  OnUpdateViewGridLines)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME,       OnUpdateFont)
   ON_WM_ERASEBKGND()
   ON_COMMAND(ID_OBJECT_MOVEBACK,       OnObjectMoveBack)
   ON_COMMAND(ID_OBJECT_MOVEFORWARD,    OnObjectMoveForward)
   ON_COMMAND(ID_OBJECT_MOVETOBACK,     OnObjectMoveToBack)
   ON_COMMAND(ID_OBJECT_MOVETOFRONT,    OnObjectMoveToFront)
   ON_COMMAND(ID_EDIT_COPY,             OnEditCopy)
   ON_UPDATE_COMMAND_UI(ID_EDIT_COPY,   OnUpdateEditCopy)
   ON_COMMAND(ID_EDIT_CUT,              OnEditCut)
   ON_UPDATE_COMMAND_UI(ID_EDIT_CUT,    OnUpdateEditCut)
   ON_COMMAND(ID_EDIT_PASTE,            OnEditPaste)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE,  OnUpdateEditPaste)
   ON_COMMAND(ID_VIEW_SHOWOBJECTS,      OnViewShowObjects)
   ON_UPDATE_COMMAND_UI(ID_VIEW_SHOWOBJECTS, OnUpdateViewShowObjects)
   ON_COMMAND(ID_EDIT_PROPERTIES,       OnEditProperties)
   ON_UPDATE_COMMAND_UI(ID_EDIT_PROPERTIES, OnUpdateEditProperties)
   ON_WM_DESTROY()
   ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
   ON_CBN_EDITCHANGE(ID_FONT_SIZE,          OnEditChangeFont)
   ON_CBN_SELCHANGE(ID_FONT_NAME,           OnSelchangeFontName)
   ON_CBN_SELCHANGE(ID_FONT_SIZE,           OnSelchangeFontSize)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE,           OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVEFORWARD,  OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOBACK,   OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_OBJECT_MOVETOFRONT,  OnUpdateMove)
   ON_UPDATE_COMMAND_UI(ID_FONT_NAME,       OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT_SIZE,       OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_BOLD,      OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_ITALIC,    OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_UNDERLINE, OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_LEFT,      OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_CENTERED,  OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_STYLE_RIGHT,     OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_FONT,            OnUpdateFont)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNRIGHT,       OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNTOP,         OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNBOTTOM,      OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNHORZCENTER,  OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_ALIGNVERTCENTER,  OnUpdateAlign)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_SPACEDOWN,        OnUpdateAlign3)
   ON_UPDATE_COMMAND_UI(ID_LAYOUT_CENTERHEIGHT,     OnUpdateMoreThanOne)
   ON_UPDATE_COMMAND_UI(ID_INDICATOR_POS2,          OnUpdatePosStatusBar)
//
// Enable or disable menu for fax property fields depending on a registry key.   a-juliar
//
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TOLIST,     OnUpdateToList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CCLIST,     OnUpdateCcList)
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COMPANY ,   OnUpdateRecCompany )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ADDRESS ,   OnUpdateRecAddress )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_CITY ,      OnUpdateRecCity )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_STATE ,     OnUpdateRecState )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_ZIPCODE ,   OnUpdateRecZipCode )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_COUNTRY ,   OnUpdateRecCountry )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_TITLE ,     OnUpdateRecTitle )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_DEPT ,      OnUpdateRecDept )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFFICELOC , OnUpdateRecOfficeLoc )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_HMTELENUM , OnUpdateRecHomePhone )
   ON_UPDATE_COMMAND_UI(ID_MAPI_RECIP_OFTELENUM , OnUpdateRecOfficePhone )
   ON_WM_CHAR()
   ON_COMMAND(ID_STYLE_LEFT,        OnStyleLeft)
   ON_COMMAND(ID_STYLE_CENTERED,    OnStyleCentered)  
   ON_COMMAND(ID_STYLE_RIGHT,       OnStyleRight)
   ON_COMMAND(ID_MAPI_MSG_NOTE,     OnMapiMsgNote)
   //}}AFX_MSG_MAP
   // Standard printing commands
#ifdef GRID
   ON_UPDATE_COMMAND_UI(ID_SNAP_TO_GRID, OnUpdateSnapToGrid)
   ON_UPDATE_COMMAND_UI(ID_GRID_SETTINGS, OnUpdateGridSettings)
   ON_COMMAND(ID_SNAP_TO_GRID, OnSnapToGrid)
   ON_COMMAND(ID_GRID_SETTINGS, OnGridSettings)
   ON_COMMAND(ID_VIEW_GRID, OnViewGrid)
#endif
   ON_WM_CTLCOLOR()
   ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
   ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\ntonly.h ===
#include <string.h>

#define _mbsncmp(x,y,z)      strncmp((LPSTR)x,(LPSTR)y,z)
#define _mbsstr(x,y)         (unsigned char*)strstr((LPSTR)x,(LPSTR)y)
#define _mbstok(x,y)         strtok((LPSTR)x,(LPSTR)y)
#define _mbscmp(x,y)         strcmp((LPSTR)x,(LPSTR)y)
#define _mbslen(x)           strlen((LPSTR)x)
#define _mbscpy(x,y)         strcpy((LPSTR)x,(LPSTR)y)
#define _mbsupr(x)           strupr((LPSTR)x)
#define _mbscat(x,y)         strcat((LPSTR)x,(LPSTR)y)
#define _mbschr(x,y)         strchr((LPSTR)x,y)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\cpeobj.h ===
//--------------------------------------------------------------------------
// CPEOBJ.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __CPEOBJ_H__
#define __CPEOBJ_H__

#define SHIFT_DRAW      0x0001
#define SHIFT_TOOL      0x0002

class CTextEdit;
class CMainFrame;
class CDrawView;
class CDrawDoc;

  //Colors used in CPE drawing program
#define COLOR_WHITE   RGB(255, 255, 255)
#define COLOR_LTBLUE  RGB(166, 202, 240)
#define COLOR_LTGRAY  RGB(192, 192, 192)
#define COLOR_MDGRAY  RGB(160, 160, 154)
#define COLOR_DKGRAY  RGB(128, 128, 128)
#define COLOR_BLACK   RGB(0, 0, 0)
//-------------------------------------------------------------------------
// CDrawObj - base class for all 'drawable objects'
//-------------------------------------------------------------------------
class CDrawObj : public CObject
{
private:
        void Initilaize(const CRect& rect=CRect(0, 0, 0, 0));

protected:
        DECLARE_SERIAL(CDrawObj);
        CDrawObj();

public:
        BOOL m_bPen;
        BOOL m_bBrush;

        CDrawObj(const CRect& position);

        CRect m_position;
        CDrawDoc* m_pDocument;

        CDrawObj& operator=(const CDrawObj& rdo);

        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        CRect GetHandleRect(int nHandleID, CDrawView* pView);

        virtual HCURSOR GetHandleCursor(int nHandle);

        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        enum TrackerState { normal, selected, active };
        virtual void DrawTracker(CDC* pDC, TrackerState state);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual BOOL ContainedIn(const CRect& rect);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual void OnDblClk(CDrawView* pView);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Invalidate();

// Implementation
public:
        virtual ~CDrawObj();
        virtual void Serialize(CArchive& ar);
        LOGBRUSH m_logbrush;
        LOGPEN   m_logpen;
        LONG     m_lLinePointSize;

#ifdef _DEBUG
        void AssertValid();
#endif

        // implementation data
protected:
   CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}
};




//---------------------------------------------------------------------
class CDrawRect : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawRect);
        CDrawRect();
        ~CDrawRect();

public:
        CDrawRect(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);

protected:

        friend class CRectTool;
};


//---------------------------------------------------------------------
class CFaxText : public CDrawRect
{
protected:
    DECLARE_SERIAL(CFaxText);
    BOOL m_bPrintRTF;
    HINSTANCE m_hLib;
    HWND m_hRTFWnd;
    CFaxText();
    ~CFaxText();
    static DWORD CALLBACK AFX_EXPORT EditStreamCallBack(DWORD_PTR dwCookie,LPBYTE pbBuff, LONG cb, LONG *pcb);
    void RectToTwip(CRect& rc,CDC& dc);
    void CheckForFit();

public:
    WORD m_wResourceid;
    CFaxText(const CRect& position);
    void EndRTF();
    void InitRTF();
    void Initialize();
    void StreamInRTF();

    virtual void Serialize(CArchive& ar);
    virtual void Draw(CDC* pDC,CDrawView*);
    virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:

    friend class CRectTool;
};


//---------------------------------------------------------------------
class CDrawText : public CDrawRect
{
public:
   CTextEdit* m_pEdit;
   HBRUSH   m_brush;
   LOGFONT  m_logfont;
   COLORREF m_crTextColor;

   CDrawText(const CRect& position);
   CDrawText& operator=(const CDrawText& rdo);

   virtual void Serialize(CArchive& ar);
   virtual void Draw(CDC* pDC,CDrawView*);
   virtual BOOL HitTestEdit(CDrawView* pView,CPoint& point);
   virtual void ChgAlignment(CDrawView*, LONG);
   virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
   virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
   virtual CDrawObj* Clone(CDrawDoc* pDoc);
   CFont* GetFont();
   void ChgLogfont(LOGFONT& lf, BOOL bResize=TRUE);

   void ToggleFontForUndo();
   void ToggleAlignmentForUndo();
   LOGFONT m_previousLogfontForUndo;
   LONG m_previousAlignmentForUndo ;
   BOOL CanUndo();
   void OnEditUndo();
   BOOL m_bUndoFont ;          // LOGFONT was last change, and edit control is active.
   BOOL m_bUndoAlignment ;     // ALIGNMENT was last change, and edit control is active.
   BOOL m_bUndoTextChange ;

   void SnapToFont();
   virtual BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize=TRUE);
   virtual void HideEditWnd(CDrawView* pView, BOOL SaveUndoState=TRUE);
   void SetText(CString& szText, CDrawView* pView);
   void NewBrush();
   virtual void OnDblClk(CDrawView* pView);
   HBRUSH GetBrush() {return m_brush;};
   void SnapToFont_onthefly(
       CDrawView *pView,
       CDC *fly_dc,
       CRect &fly_rect,
       CFont *dpFont=NULL
       );
   int GetText( int numlines = -1, BOOL delete_text = FALSE );

   LPTSTR GetRawText( void ) {return (LPTSTR)(LPCTSTR)m_szEditText; }
   CString GetEditTextString(){ return m_szEditText; }
   LONG GetTextAlignment(){ return m_lStyle; }
protected:
   CFont* m_pOldFont;  // font used to save font in DC
   CFont* m_pFont;     // font used for edit control
   LONG   m_lStyle;    // DrawText() format 
   COLORREF m_savepencolor;
   UINT m_savepenstyle;
   CString m_szEditText;
   DECLARE_SERIAL(CDrawText);
   CDrawText();
   ~CDrawText();
   void FitEditWnd( CDrawView*, BOOL call_gettext=TRUE, CDC *pdc=NULL );
   void InitEditWnd();
   void Initialize();
   void GetLongestString(CString& szLong);

   friend class CRectTool;
};



//---------------------------------------------------------------------
class CFaxProp : public CDrawText
{
protected:
        DECLARE_SERIAL(CFaxProp);
        CFaxProp();
        ~CFaxProp();

public:
        CFaxProp(const CRect& position,WORD wResourceid);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void Draw(CDC* pDC,CDrawView*);
   CFaxProp& operator=(const CFaxProp& rdo);
   BOOL ShowEditWnd(CDrawView* pView, BOOL Initialize = TRUE );
   void HideEditWnd(CDrawView* pView, BOOL SaveUndoState = TRUE );

   WORD GetResourceId( void )
                {return( m_wResourceid );}

protected:
   WORD m_wResourceid;
        friend class CRectTool;
};






//---------------------------------------------------------------------
class CDrawLine : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawLine);
        CDrawLine();
        ~CDrawLine();

public:
        CDrawLine(const CRect& position);

        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual int GetHandleCount();
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual void Invalidate();
        void AdjustLineForPen(CRect& rc);
        void NegAdjustLineForPen(CRect& rc);

protected:
    int m_iSlope;
    int m_iB;

        friend class CRectTool;
};




//---------------------------------------------------------------------
class CDrawEllipse : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawEllipse);
        CDrawEllipse();
        ~CDrawEllipse();

public:
        CDrawEllipse(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual CDrawObj* Clone(CDrawDoc* pDoc = NULL);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);

protected:

        friend class CRectTool;
};



//---------------------------------------------------------------------
class CDrawRoundRect : public CDrawRect
{
protected:
        DECLARE_SERIAL(CDrawRoundRect);
        CDrawRoundRect();
        ~CDrawRoundRect();

public:
        CDrawRoundRect(const CRect& position);
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
  ////////      virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
   CDrawRoundRect& operator=(const CDrawRoundRect& rdo);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

protected:
        CPoint m_roundness; // for roundRect corners

        friend class CRectTool;
};





//---------------------------------------------------------------------
class CDrawPoly;

class CDrawPoly : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawPoly);
        CDrawPoly();

public:
        CDrawPoly(const CRect& position);

   CDrawPoly& operator=(const CDrawPoly& rdo);
        void AddPoint(const CPoint& point, CDrawView* pView = NULL);
        BOOL RecalcBounds(CDrawView* pView = NULL);

// Implementation
public:
        CRect GetHandleRect(int nHandleID, CDrawView* pView);
        virtual int HitTest(CPoint point, CDrawView* pView, BOOL bSelected);
        virtual ~CDrawPoly();
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 ///////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
        virtual void MoveTo(const CRect& position, CDrawView* pView = NULL);
        virtual int GetHandleCount();
        virtual CPoint GetHandle(int nHandle);
        virtual HCURSOR GetHandleCursor(int nHandle);
        virtual void MoveHandleTo(int nHandle, CPoint point, CDrawView* pView = NULL, UINT uiShiftDraw=0);
        virtual BOOL Intersects(const CRect& rect, BOOL bShortCut=FALSE);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);

        // static helper for creating arrays of points
        static CPoint* NewPoints(int nPoints);

//protected:
        int m_nPoints;
        int m_nAllocPoints;
        CPoint* m_points;
        CDrawPoly* m_pDrawObj;

//      friend class CPolyTool;
};


//---------------------------------------------------------------------
class CDrawItem;    // COleClientItem derived class

class CDrawOleObj : public CDrawObj
{
protected:
        DECLARE_SERIAL(CDrawOleObj);
        CDrawOleObj();

public:
        CDrawOleObj(const CRect& position);

// Implementation
public:
        virtual void Serialize(CArchive& ar);
        virtual void Draw(CDC* pDC,CDrawView*);
 //////////////       virtual void DrawToEnhancedMetafile(CMetaFileDC* pMDC );
   CDrawOleObj& operator=(const CDrawOleObj& rdo);
        virtual CDrawObj* Clone(CDrawDoc* pDoc);
        virtual void OnDblClk(CDrawView* pView);
        virtual void MoveTo(const CRect& positon, CDrawView* pView = NULL);
        virtual void Invalidate();

        static BOOL c_bShowItems;

        CDrawItem* m_pClientItem;
        CSize m_extent; // current extent is tracked separate from scaled position
};

//---------------------------------------------------------------------
class CMoveContext: public CObject {
   CMoveContext(RECT& rc, CDrawObj* pObj, BOOL bPointChg);
   RECT m_rc;
   CDrawObj* m_pObj;
   CPoint* m_points;
};

COLORREF GetDisplayColor(COLORREF color);

#endif // __CPEOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\dialogs.h ===
//=========================================================================
// DIALOGS.H
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//=========================================================================
//
// Modified by a-juliar to fix NT bug 49528.
//
#ifndef __DIALOGS_H__
#define __DIALOGS_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

//------------------------------------------------------------------------
// CPE error message codes
//
// 001 - 299 information
// 300 - 499 error
// >= 500    critical
//------------------------------------------------------------------------
#define MSG_INFO_DRAWPOLY              001
#define MSG_INFO_NOFAXPROP             002
#define MSG_ERROR_INVFORMAT            300
#define MSG_ERROR_OLEINIT_FAILED       301
#define MSG_ERROR_OLE_FAILED_TO_CREATE 302
#define MSG_ERROR_MISSINGFILE          303
#define MSG_ERROR_NOPAGESETUPDLL       304
#define MSG_ERROR_NOPAGESETUP          305

int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType=MB_OK, int msgid=-1);
int AlignedAfxMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 );
int AlignedAfxMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT) -1 );


class CDrawView;

//---------------------------------------------------------------------------
// CObjPropDlg dialog
//---------------------------------------------------------------------------
class CObjPropDlg : public CDialog
{
public:
   BOOL m_bCBDrawBorder;
   BOOL m_bRBFillColor;
   BOOL m_bRBFillTrans;
   CString m_szThickness;
   CString m_szLineColor;
   CString m_szFillColor;
   CString m_szTextColor;
   CObjPropDlg(CWnd* pParent = NULL); // standard constructor

    //{{AFX_DATA(CObjPropDlg)
    enum { IDD = IDD_OBJ_PROP};
    //}}AFX_DATA

protected:
   CDrawView* m_pView;

    afx_msg void OnSelChangeFillColor();
    BOOL OnInitDialog();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    CButton& GetRBFillColor() { return *(CButton*)GetDlgItem(IDC_RB_FILLCOLOR); }
    CButton& GetRBFillTrans() { return *(CButton*)GetDlgItem(IDC_RB_FILLTRANS); }
    CComboBox& GetLBThickness() { return *(CComboBox*)GetDlgItem(IDC_LB_THICKNESS); }
    CComboBox& GetLBLineColor() { return *(CComboBox*)GetDlgItem(IDC_LB_LINECOLOR); }
    CComboBox& GetLBFillColor() { return *(CComboBox*)GetDlgItem(IDC_LB_FILLCOLOR); }
    CWnd& GetGRPFillColor() { return *(CWnd*)GetDlgItem(IDC_GRP_FILLCOLOR); }
    CComboBox& GetLBTextColor() { return *(CComboBox*)GetDlgItem(IDC_LB_TEXTCOLOR); }
    CWnd& GetSTTextColor() { return *(CWnd*)GetDlgItem(IDC_ST_TEXTCOLOR); }

    //{{AFX_MSG(CObjPropDlg)
            // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG

    virtual void OnOK();

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

    afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
 
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

   DECLARE_MESSAGE_MAP()
};





//---------------------------------------------------------------------------
// CGridSettingsDlg dialog
//---------------------------------------------------------------------------
class CGridSettingsDlg : public CDialog
{
public:
        CGridSettingsDlg(CWnd* pParent = NULL); // standard constructor
   BOOL m_bRBSmall, m_bRBMedium, m_bRBLarge;
   BOOL m_bCBViewGrid, m_bCBSnapToGrid;

        //{{AFX_DATA(CGridSettingsDlg)
        enum { IDD = IDD_GRID_SETTINGS};
        //}}AFX_DATA

protected:
   CDrawView* m_pView;

   BOOL OnInitDialog();

        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

        CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

        //{{AFX_MSG(CGridSettingsDlg)
                // NOTE: the ClassWizard will add member functions here
        //}}AFX_MSG

        afx_msg LRESULT OnWM_HELP( WPARAM wParam, LPARAM lParam );
///#ifdef ENABLE_HELP
        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CBigIcon : public CButton
{
public:
        void SizeToContent();

protected:
        virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

        //{{AFX_MSG(CBigIcon)
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};



//--------------------------------------------------------------
class CSplashTipsDlg : public CDialog
{
public:
    CFont m_tips_font;
    CFont m_tipstitle_font;
    int m_iCurrentTip;
    CSplashTipsDlg(BOOL bRandomTip = FALSE, CWnd* pParent = NULL);
    BOOL OnInitDialog();

    //{{AFX_DATA(CSplashTipsDlg)
    enum { IDD = IDD_SPLASHTIPS };
    //}}AFX_DATA

protected:

    BOOL m_bRandomTip;

    CButton* GetNextTip() {return (CButton*) GetDlgItem(IDC_B_NEXTTIP);};
    CButton* GetPrevTip() {return (CButton*) GetDlgItem(IDC_B_PREVTIP);};
    CButton* GetShowTips() {return (CButton*) GetDlgItem(IDC_CK_SHOWTIPS);};
    CEdit* GetTitle() {return (CEdit*) GetDlgItem(IDC_STA_TITLE);};
    CEdit* GetTips() {return (CEdit*) GetDlgItem(IDC_STA_TIP);};

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
    afx_msg void OnNextTip();
    afx_msg void OnPrevTip();
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnOK();

    //{{AFX_MSG(CSplashTipsDlg)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

//--------------------------------------------------------------------------------------
class CMyCommonDialog : public CCommonDialog
{
public:
        CMyCommonDialog( CWnd* pParentWnd );

protected:
        //{{AFX_MSG(CMyCommonDialog)        //////// I typed this, not the app wizard! a-juliar
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG

        DECLARE_MESSAGE_MAP()
};

class CMyOleInsertDialog : public COleInsertDialog
{
public:
    CMyOleInsertDialog( DWORD dwFlags = IOF_SELECTCREATENEW, CWnd* pParentWnd = NULL );

protected:
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

    DECLARE_MESSAGE_MAP()
};


typedef BOOL (APIENTRY *PPSD)(PAGESETUPDLG*);

class CMyPageSetupDialog : public CMyCommonDialog
{
public:
        CMyPageSetupDialog(CWnd* pParentWnd = NULL);
        ~CMyPageSetupDialog();
        PAGESETUPDLG m_psd;
        PPSD m_pPageSetupDlg;
        HINSTANCE m_hLib;

        virtual INT_PTR DoModal();
};

//--------------------------------------------------------------------------------------

class CMyPrintDlg : public CPrintDialog
{
        DECLARE_DYNAMIC(CMyPrintDlg)

public:
        CMyPrintDlg(BOOL bPrintSetupOnly,
                // TRUE for Print Setup, FALSE for Print Dialog
                DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
                        | PD_HIDEPRINTTOFILE | PD_NOSELECTION,
                CWnd* pParentWnd = NULL);

protected:
        //{{AFX_MSG(CMyPrintDlg)
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

//---------------------------------------------------------------------------------------
class CMyFontDialog : public CFontDialog
{
public:
    CMyFontDialog(LPLOGFONT lplfInitial = NULL,
                  DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
                  CDC* pdcPrinter = NULL,
                  CWnd* pParentWnd = NULL);
protected:
    afx_msg BOOL OnHelpInfo( HELPINFO* pHelpInfo);
    DECLARE_MESSAGE_MAP()
};

extern const DWORD aHelpIDs[] ;       /// Defined in dialogs.cpp
extern const DWORD aOleDlgHelpIDs[] ; /// Defined in dialogs.cpp
#endif // #ifndef __DIALOGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\mainfrm.cpp ===
//--------------------------------------------------------------------------
// MAINFRM.CPP
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains main frame class for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
//--------------------------------------------------------------------------
#include "stdafx.h"
#ifndef NT_BUILD
#include <mbstring.h>
#endif

#include <htmlhelp.h>
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include "afxpriv.h"
#include "faxutil.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

   //constants for font name & size
const int INDEX_FONTNAME = 10 ;
const int INDEX_FONTSIZE = 12 ;
const int NAME_WIDTH  = 170 ;
const int NAME_HEIGHT = 140 ;
const int SIZE_WIDTH  = 60 ;
const int SIZE_HEIGHT = 140 ;

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

extern UINT NEAR WM_AWCPEACTIVATE;

WORD nFontSizes[] = { 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72, 0 };

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE stylebar[] =
{
    // same order as in the bitmap 'stylebar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR,
    ID_STYLE_BOLD,
    ID_STYLE_ITALIC,
    ID_STYLE_UNDERLINE,
        ID_SEPARATOR,
    ID_STYLE_LEFT,
    ID_STYLE_CENTERED,
    ID_STYLE_RIGHT,
};


static UINT BASED_CODE drawtools[] =
{
    // same order as in the bitmap 'drawtools.bmp'
    ID_DRAW_SELECT,
    ID_DRAW_TEXT,
    ID_DRAW_LINE,
    ID_DRAW_RECT,
    ID_DRAW_ROUNDRECT,
    ID_DRAW_POLYGON,
    ID_DRAW_ELLIPSE,
        ID_SEPARATOR,
    ID_OBJECT_MOVETOFRONT,
    ID_OBJECT_MOVETOBACK,
        ID_SEPARATOR,
    ID_LAYOUT_SPACEACROSS,
    ID_LAYOUT_SPACEDOWN,
        ID_SEPARATOR,
    ID_LAYOUT_ALIGNLEFT,
    ID_LAYOUT_ALIGNRIGHT,
    ID_LAYOUT_ALIGNTOP,
    ID_LAYOUT_ALIGNBOTTOM,
#ifdef GRID
    ID_SNAP_TO_GRID,
#endif

};


static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,
    ID_INDICATOR_POS1,                          //id for object coordinates
    ID_INDICATOR_POS2,                          //id for object coordinates
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


//--------------------------------------------------------------------------
CMainFrame::CMainFrame()
{
        m_toolbar_icon = theApp.LoadIcon( IDI_TBARICON );
}


//--------------------------------------------------------------------------
CMainFrame::~CMainFrame()
{
}



//--------------------------------------------------------------------------
BOOL CALLBACK
        EnumFamProc( ENUMLOGFONT* lpnlf,NEWTEXTMETRIC* lpntm,int iFontType,
                        LPARAM lpData)
        {
        if( lpnlf == NULL )
                return FALSE;

        CComboBox* pCBox = (CComboBox*)lpData;

        if( pCBox )
                {
                if( _tcsncmp((lpnlf->elfLogFont.lfFaceName),
                                           TEXT("@"), 1 )
                        == 0 )
                        {
                        /*
                                This is a "vertical" font. Nobody wants to show these,
                                so filter them out and keep going.
                         */
                        return( TRUE );
                        }

                if( pCBox->
                                FindStringExact(0,(LPCTSTR)(lpnlf->elfLogFont.lfFaceName))
                                ==CB_ERR )
/***CHANGES FOR M8 bug 2988***/
                        {
                        pCBox->AddString( (LPCTSTR)(lpnlf->elfLogFont.lfFaceName) );

                        // look for fonts that matches system charset and keep
                        // first one in sort order
                        if( theApp.m_last_logfont.lfCharSet
                                        == lpnlf->elfLogFont.lfCharSet )
                                {
                                if( _tcscmp((lpnlf->elfLogFont.lfFaceName),
                                                      (theApp.m_last_logfont.lfFaceName) )
                                        < 0 )
                                        {
                                        // found it, copy the whole thing
                                        theApp.m_last_logfont = lpnlf->elfLogFont;
                                        }
                                }
                        }
/*****************************/
                }

        return TRUE ;

        }



//--------------------------------------------------------------------------
BOOL CMainFrame::CreateStyleBar()
{
   if (!m_StyleBar.Create(this,WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE,IDW_STYLEBAR) ||
       !m_StyleBar.LoadBitmap(theApp.IsRTLUI() ? IDR_STYLEBAR_RTL : IDR_STYLEBAR) ||
       !m_StyleBar.SetButtons(stylebar, sizeof(stylebar)/sizeof(UINT))) 
   {
        TRACE(TEXT("AWCPE.MAINFRM.CREATESTYLEBAR: Failed to create stylebar\n"));
        return FALSE;
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_STYLE);
   m_StyleBar.SetWindowText(sz);

   CRect rect;
   int cyFit;
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME, ID_FONT_NAME, TBBS_SEPARATOR, NAME_WIDTH );
   m_StyleBar.SetButtonInfo(INDEX_FONTNAME+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTNAME, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + NAME_WIDTH;
   rect.bottom = rect.top + NAME_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontName.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN|CBS_SORT,
        rect, &m_StyleBar, ID_FONT_NAME))  {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;      // fail to create
   }

   // Create font size combo box on toolbar
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE, ID_FONT_SIZE, TBBS_SEPARATOR, SIZE_WIDTH);
   m_StyleBar.SetButtonInfo(INDEX_FONTSIZE+1, ID_SEPARATOR, TBBS_SEPARATOR, 12 );
   m_StyleBar.GetItemRect(INDEX_FONTSIZE, &rect);
   cyFit = rect.Height();
   rect.right = rect.left + SIZE_WIDTH;
   rect.bottom = rect.top + SIZE_HEIGHT;       // drop height

   if (!m_StyleBar.m_cboxFontSize.Create(
        WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWN,
        rect, &m_StyleBar, ID_FONT_SIZE)) {
        TRACE(TEXT("Failed to create combobox inside toolbar\n"));
        return FALSE ;
   }

/***CHANGES FOR M8 bug 2988***/
   // Fill font name combobox
//   CClientDC dc(NULL);
//   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   CString strDefaultFont;
//   strDefaultFont.LoadString(IDS_DEFAULT_FONT);
   LOGFONT system_logfont;
   CFont   system_font;

   system_font.Attach( ::GetStockObject(SYSTEM_FONT) );
   system_font.GetObject( sizeof (LOGFONT), (LPVOID)&system_logfont );
   theApp.m_last_logfont = system_logfont;

   // Fill font name combobox and find default font
   CClientDC dc(NULL);
   ::EnumFontFamilies(dc.GetSafeHdc(),(LPCTSTR)NULL,(FONTENUMPROC)EnumFamProc,LPARAM(&m_StyleBar.m_cboxFontName));

   // enum changed theApp.m_last_logfont to first font that had same
   // charset as system font. Use face name for default

   theApp.m_last_logfont = system_logfont ;

   strDefaultFont = theApp.m_last_logfont.lfFaceName;

   // Wouldn't it be better to use the font mentioned in the resource file?
   //    5-30-95 a-juliar

   strDefaultFont.LoadString( IDS_DEFAULT_FONT );

   memset(&(theApp.m_last_logfont),0,sizeof(LOGFONT)) ;
   theApp.m_last_logfont.lfHeight = -17;   //LU
   theApp.m_last_logfont.lfWeight = 200; // non-bold font weight
   theApp.m_last_logfont.lfCharSet = DEFAULT_CHARSET;
   theApp.m_last_logfont.lfOutPrecision = OUT_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
   theApp.m_last_logfont.lfQuality = DEFAULT_QUALITY;
   theApp.m_last_logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
////   strDefaultFont.LockBuffer();
   _tcsncpy(theApp.m_last_logfont.lfFaceName,strDefaultFont.GetBuffer(0),LF_FACESIZE);
   strDefaultFont.ReleaseBuffer();


/*****************************/


   CString strDefaultBoxFont;
   strDefaultBoxFont.LoadString(IDS_DEFAULT_BOXFONT);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(strDefaultFont);   //load font sizes for default font.



   ////////////////////////////////////////////////////////
   // FIX FOR 3718
   //
   // DBCS funny buisness font code for name and size comboboxes
   // removed and replaced with the following four lines. These
   // comboboxes are set to use the same font as menus do. This
   // automatically takes care of all localization headaches (knock
   // on wood...).
   //
   m_StyleBar.m_font.Attach(::GetStockObject(DEFAULT_GUI_FONT));
   m_StyleBar.m_cboxFontName.SetFont(&m_StyleBar.m_font);
   m_StyleBar.m_cboxFontSize.SetFont(&m_StyleBar.m_font);
/***NEEDED FOR M8 bug 2988***/
   m_StyleBar.m_cboxFontName.SelectString(-1,strDefaultFont);
   ////////////////////////////////////////////////////////




/***CHANGES FOR M8 bug 2988***/
//   m_StyleBar.m_cboxFontSize.SetCurSel(2);
/********the blow is since M8*****/
        int initial_fontsize_index;
        CString size_str;
        int font_size;

        if( (initial_fontsize_index =
                        m_StyleBar.m_cboxFontSize.FindStringExact( -1, TEXT("10") ))
                == CB_ERR )
                initial_fontsize_index = 2;

        m_StyleBar.m_cboxFontSize.SetCurSel( initial_fontsize_index );

        m_StyleBar.m_cboxFontSize.GetWindowText( size_str );
    font_size = _ttoi( size_str );
        if( font_size <= 0 || font_size > 5000 )
                font_size = 10;

        theApp.m_last_logfont.lfHeight = -MulDiv(font_size,100,72);
        theApp.m_last_logfont.lfWidth = 0;
/*****************************/

// F I X  for 3647 /////////////
//
// font to use for notes if there are no note boxes on cpe
//
    theApp.m_default_logfont = theApp.m_last_logfont;
////////////////////////////////


   #if _MFC_VER >= 0x0300
      m_StyleBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_StyleBar);
      m_StyleBar.SetBarStyle(m_StyleBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   UINT id, style;
   int image;
   int idx = m_StyleBar.CommandToIndex(ID_STYLE_RIGHT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_LEFT);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_CENTERED);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_BOLD);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_ITALIC);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);
   idx = m_StyleBar.CommandToIndex(ID_STYLE_UNDERLINE);
   m_StyleBar.GetButtonInfo(idx, id, style, image);
   m_StyleBar.SetButtonInfo(idx, id, TBBS_CHECKBOX, image);

   return TRUE ;
}


BOOL CMainFrame::CreateDrawToolBar()
{
   if (!m_DrawBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_HIDE_INPLACE,IDW_DRAWBAR) ||
       !m_DrawBar.LoadBitmap(theApp.IsRTLUI() ? IDR_DRAWTOOL_RTL : IDR_DRAWTOOL) ||
       !m_DrawBar.SetButtons(drawtools, sizeof(drawtools)/sizeof(UINT))) 
   {
        TRACE(TEXT("Failed to create toolbar\n"));
        return -1;      // fail to create
   }

   CString sz;
   sz.LoadString(ID_TOOLBAR_DRAWING);
   m_DrawBar.SetWindowText(sz);

   #if _MFC_VER >= 0x0300
      m_DrawBar.EnableDocking(CBRS_ALIGN_ANY);
      EnableDocking(CBRS_ALIGN_ANY);
      DockControlBar(&m_DrawBar);
      m_DrawBar.SetBarStyle(m_DrawBar.GetBarStyle()
          | CBRS_TOOLTIPS | CBRS_FLYBY);
   #endif

   return TRUE;
}


void CMainFrame::OnUpdateControlStyleBarMenu(CCmdUI* pCmdUI)
{
    pCmdUI->m_nID= IDW_STYLEBAR;
    CFrameWnd::OnUpdateControlBarMenu(pCmdUI);
}

void CMainFrame::OnUpdateControlDrawBarMenu(CCmdUI* pCmdUI)
{
    pCmdUI->m_nID= IDW_DRAWBAR;
    CFrameWnd::OnUpdateControlBarMenu(pCmdUI);
}

//-----------------------------------------------------------------------------------
BOOL CMainFrame::OnStyleBarCheck(UINT nID)
{
    return CFrameWnd::OnBarCheck(IDW_STYLEBAR);
}


//-----------------------------------------------------------------------------------
BOOL CMainFrame::OnDrawBarCheck(UINT nID)
{
    return CFrameWnd::OnBarCheck(IDW_DRAWBAR);
}



//-----------------------------------------------------------------------------------
LRESULT CMainFrame::OnAWCPEActivate(WPARAM wParam, LPARAM lParam)
{
   SetForegroundWindow();
   if (IsIconic())
       ShowWindow(SW_NORMAL);
   return 1L;
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontName()
{
}


//----------------------------------------------------------------------------
void CMainFrame::OnDropDownFontSize()
{
   CString szFontName;

   CString sz;
   m_StyleBar.m_cboxFontSize.GetWindowText(sz);

   int iSel = m_StyleBar.m_cboxFontName.GetCurSel();
   if ( iSel != CB_ERR)
       m_StyleBar.m_cboxFontName.GetLBText(iSel,szFontName);
   else
       m_StyleBar.m_cboxFontName.GetWindowText(szFontName);

   m_StyleBar.m_cboxFontSize.EnumFontSizes(szFontName);
   if (sz.GetLength()>0)
       m_StyleBar.m_cboxFontSize.SetWindowText(sz);
}


//-----------------------------------------------------------------------------------
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (((CDrawApp*)AfxGetApp())->IsInConvertMode())
    {
        WINDOWPLACEMENT pl;
        pl.length = sizeof(pl);
        GetWindowPlacement(&pl);
        pl.showCmd = SW_SHOWMINIMIZED | SW_HIDE;
        SetWindowPlacement(&pl);
    }
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }
    if (!CreateStyleBar())
    {    
        return -1;
    }
    if (!CreateDrawToolBar())
    {
        return -1;
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,sizeof(indicators)/sizeof(UINT)))  
    {
        TRACE(TEXT("Failed to create status bar\n"));
        return -1;      // fail to create
    }
    //
    // Set toolbar (small) icon
    //
    SendMessage( WM_SETICON, (WPARAM)TRUE, (LPARAM)m_toolbar_icon );
    return 0;
}   // CMainFrame::OnCreate

//----------------------------------------------------------------------------------------------
void CMainFrame::OnShowTips()
{
   CSplashTipsDlg m_SplashDlg;
    m_SplashDlg.DoModal();
}


//----------------------------------------------------------------------------------------------
BOOL CMainFrame::PreTranslateMessage(MSG* pMsg)
{
   BOOL bReturn;

   CDrawView *pView = CDrawView::GetView();
   if (!pView)
   {
       return FALSE;
   }

   if (pView && (pView->m_pObjInEdit))
   {
       bReturn = FALSE;
   }
   else
   {
       bReturn = CFrameWnd::PreTranslateMessage(pMsg);
   }

   return bReturn;
}


///////////#ifdef ENABLE_HELP  ///// Just Do It!
//----------------------------------------------------------------------------------------------
//LRESULT CMainFrame::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
//{
//    ::WinHelp( (HWND)wParam,  AfxGetApp()->m_pszHelpFilePath,  HELP_CONTEXTMENU,
//               (DWORD)(LPSTR)cshelp_map );
//
//        return( 0 );
//}
//////////////#endif


//----------------------------------------------------------------------------------------------
LRESULT CMainFrame::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{   
    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM))
    {
        return 0;
    }

    SetLastError(0);
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return 0;
}
 
//----------------------------------------------------------------------------------------------
void CMainFrame::OnHelp()
{
    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM))
    {
        return;
    }

    SetLastError(0);
    ::HtmlHelp( m_hWnd,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }
}

void 
CMainFrame::OnUpdateHelp(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsFaxComponentInstalled(FAX_COMPONENT_HELP_CPE_CHM));
}

//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenu(CMenu* pPopupMenu)
{
   m_mainmenu = ::GetMenu(m_hWnd);
   CFrameWnd::OnInitMenu(pPopupMenu);
}

//----------------------------------------------------------------------------------------------
// This is mostly code lifted from MFC's WINFRM.CPP.  It's to enable the app to display text for
// POPUPs.
//----------------------------------------------------------------------------------------------
void CMainFrame::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hmenu)
{
        // set the tracking state (update on idle)
        if (nFlags == 0xFFFF) {
                // cancel menu operation (go back to idle now)
                CFrameWnd* pFrameWnd = GetTopLevelFrame();
                ASSERT_VALID(pFrameWnd);
                if (!pFrameWnd->m_bHelpMode)
                        m_nIDTracking = AFX_IDS_IDLEMESSAGE;
                else
                        m_nIDTracking = AFX_IDS_HELPMODEMESSAGE;
                SendMessage(WM_SETMESSAGESTRING, (WPARAM)m_nIDTracking);
                ASSERT(m_nIDTracking == m_nIDLastMessage);

                // update right away
                CWnd* pWnd = GetMessageBar();
                if (pWnd != NULL)
                        pWnd->UpdateWindow();
        }
        else
        if ( nFlags & (MF_SEPARATOR|MF_MENUBREAK|MF_MENUBARBREAK))      {
                m_nIDTracking = 0;
        }
        else
        if (nFlags & (MF_POPUP)) {    //added this to track POPUPs
        if (hmenu==m_mainmenu) {
               m_iTop=nItemID;
                   m_iSecond=-1;
            }
            else
               m_iSecond=nItemID;

        PopupText();
        }
        else
        if (nItemID >= 0xF000 && nItemID < 0xF1F0) { // max of 31 SC_s
                // special strings table entries for system commands
                m_nIDTracking = ID_COMMAND_FROM_SC(nItemID);
                ASSERT(m_nIDTracking >= AFX_IDS_SCFIRST &&
                        m_nIDTracking < AFX_IDS_SCFIRST + 31);
        }
        else
        if (nItemID >= AFX_IDM_FIRST_MDICHILD)  {
                // all MDI Child windows map to the same help id
                m_nIDTracking = AFX_IDS_MDICHILD;
        }
        else {
                // track on idle
                m_nIDTracking = nItemID;
        }

        // when running in-place, it is necessary to cause a message to
        //  be pumped through the queue.
        if (m_nIDTracking != m_nIDLastMessage && GetParent() != NULL) {
                PostMessage(WM_KICKIDLE);
        }
}


//----------------------------------------------------------------------------------------------
void CMainFrame::OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu)
{
   CFrameWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
}


//----------------------------------------------------------------------------------------------
void CMainFrame::PopupText()
{
   if (m_iTop<0 || m_iTop > 10 || m_iSecond > 10 || m_iSecond < -1)
      return;

   CString sz;

   if (m_iTop==0) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FILE_MENU);
   }
   else
   if (m_iTop==1) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_EDIT_MENU);
   }
   else
   if (m_iTop==2) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_VIEW_MENU);
   }
   else
   if (m_iTop==3) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_INSERT_MENU);
      else
      if (m_iSecond==0)
         sz.LoadString(IDP_RECIPIENT);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_SENDER);
      else
      if (m_iSecond==2)
         sz.LoadString(IDP_MESSAGE);
   }
   else
   if (m_iTop==4) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_FORMAT_MENU);
      else
      if (m_iSecond==1)
         sz.LoadString(IDP_ALIGN_TEXT);
   }
   else
   if (m_iTop==5) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_LAYOUT_MENU);
      else
      if (m_iSecond==3)
         sz.LoadString(IDP_ALIGN_OBJECTS);
      else
      if (m_iSecond==4)
         sz.LoadString(IDP_SPACE_EVEN);
      else
      if (m_iSecond==5)
         sz.LoadString(IDP_CENTER_PAGE);
   }
   else
   if (m_iTop==6) {
      if (m_iSecond==-1)
         sz.LoadString(IDP_HELP_MENU);
   }

   m_wndStatusBar.SetPaneText(0,sz);
}

#ifdef _DEBUG
//----------------------------------------------------------------------------------------------
void CMainFrame::AssertValid() const
{
        CFrameWnd::AssertValid();
}



//----------------------------------------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
{
        CFrameWnd::Dump(dc);
}

#endif //_DEBUG




BOOL CMainFrame::OnQueryOpen( void )
        {

    return( !(theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0)) );

        }



void CMainFrame::ActivateFrame( int nCmdShow )
        {

    if( theApp.m_bCmdLinePrint || (theApp.m_dwSesID!=0) )
                {
                //::MessageBeep( 0xffffffff );
                ShowWindow( SW_HIDE );
                }
        else
                CFrameWnd::ActivateFrame( nCmdShow );

        }




//--------------------------------------------------------------------------------------------
BOOL CStyleBar::PreTranslateMessage(MSG* pMsg)
{
         if (!( (pMsg->message == WM_KEYDOWN) && ((pMsg->wParam == VK_RETURN)||(pMsg->wParam == VK_ESCAPE)) ))
                return CToolBar::PreTranslateMessage(pMsg);

     CDrawView* pView = CDrawView::GetView();
         if (pView==NULL)
                return CToolBar::PreTranslateMessage(pMsg);

     if (pMsg->wParam == VK_ESCAPE) {
        pView->m_bFontChg=FALSE;
        pView->UpdateStyleBar();
        if (pView->m_pObjInEdit)
           pView->m_pObjInEdit->m_pEdit->SetFocus();
                else
           pView->SetFocus();
                return CToolBar::PreTranslateMessage(pMsg);
         }

         HWND hwndFontNameEdit=::GetDlgItem(m_cboxFontName.m_hWnd,1001);
         if (pMsg->hwnd == hwndFontNameEdit) {
                  pView->OnSelchangeFontName();
         }
         else {
       HWND hwndFontSizeEdit=::GetDlgItem(m_cboxFontSize.m_hWnd,1001);
       if (pMsg->hwnd == hwndFontSizeEdit)
          pView->OnSelchangeFontSize();
         }

     return CToolBar::PreTranslateMessage(pMsg);
}


//--------------------------------------------------------------------------
void CSizeComboBox::EnumFontSizes(CString& szFontName)
{
   CClientDC dc(NULL);
   m_nLogVert=dc.GetDeviceCaps(LOGPIXELSY);

   ResetContent();

   ::EnumFontFamilies(dc.GetSafeHdc(), szFontName, (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}


//--------------------------------------------------------------------------
void CSizeComboBox::InsertSize(int nSize)
{
    ASSERT(nSize > 0);

    TCHAR buf[10];
    wsprintf(buf,TEXT("%d"),nSize);

    if (FindStringExact(-1,buf) == CB_ERR)  {
            AddString(buf);
    }
}

//-------------------------------------------------------------------
BOOL CALLBACK CSizeComboBox::EnumSizeCallBack(LOGFONT FAR*, LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
   CSizeComboBox* pThis = (CSizeComboBox*)lpv;
   TCHAR buf[10];                                //????????????????????????????????
   if ( (FontType & TRUETYPE_FONTTYPE) ||
        !( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) ) ) {

        if (pThis->GetCount() != 0)
           pThis->ResetContent();

        for (int i = 0; nFontSizes[i]!=0; i++) {
            wsprintf(buf,TEXT("%d"),nFontSizes[i]);      //????????????????????Not changed. J.R.
                pThis->AddString(buf);
        }
            return FALSE;
   }

   int pointsize = MulDiv( (lpntm->tmHeight - lpntm->tmInternalLeading),72,pThis->m_nLogVert);
   pThis->InsertSize(pointsize);
   return TRUE;
}


//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
   //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
   ON_WM_CREATE()
   ON_UPDATE_COMMAND_UI(ID_VIEW_STYLEBAR, OnUpdateControlStyleBarMenu)
   ON_COMMAND_EX(ID_VIEW_STYLEBAR, OnStyleBarCheck)
   ON_UPDATE_COMMAND_UI(ID_VIEW_DRAWBAR, OnUpdateControlDrawBarMenu)
   ON_COMMAND_EX(ID_VIEW_DRAWBAR, OnDrawBarCheck)
   //}}AFX_MSG_MAP
   ON_COMMAND(ID_SHOW_TIPS, OnShowTips)
   ON_CBN_DROPDOWN(ID_FONT_NAME, OnDropDownFontName)
   ON_CBN_DROPDOWN(ID_FONT_SIZE, OnDropDownFontSize)
   ON_WM_INITMENUPOPUP()
   ON_WM_MENUSELECT()
   ON_WM_INITMENU()

   ON_COMMAND(ID_DEFAULT_HELP, OnHelp)    /// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)     /// added by a-juliar, 6-18-96
   ON_REGISTERED_MESSAGE(WM_AWCPEACTIVATE, OnAWCPEActivate)
   ON_WM_QUERYOPEN()
// These next three lines were commented out in the code I inherited.  Let's try them!
// a-juliar, 6-18-96
   ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
   ON_COMMAND(ID_HELP, OnHelp)
   ON_COMMAND(ID_CONTEXT_HELP, OnContextHelp)

/////////#ifdef ENABLE_HELP  ///////
////        ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////////#endif

   ON_COMMAND(ID_HELP_INDEX, OnHelp)
   ON_MESSAGE( WM_HELP, OnWM_HELP )
   ON_UPDATE_COMMAND_UI(ID_HELP_INDEX, OnUpdateHelp)

END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\dialogs.cpp ===
//----------------------------------------------------------------------
// dialogs.cpp : implementation file
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// Description:      Contains misc. dialogs for cover page editor
// Original author:  Steve Burkett
// Date written:     6/94
//
// Modification:     a-juliar modified it to fix NT bug 49528  8/2/96
//----------------------------------------------------------------------
#include "stdafx.h"
#include "cpedoc.h"
#include "cpevw.h"
#include "awcpe.h"
#include "cpeedt.h"
#include "cpeobj.h"
#include "cntritem.h"
#include "cpetool.h"
#include "mainfrm.h"
#include "dialogs.h"
#include "faxprop.h"
#include "resource.h"
#include <htmlhelp.h>
#include <time.h>
#include <faxutil.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

WORD wStandardLineSizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};

#define TOTAL_TIPS 11

//
// Help IDs for IDD_INSERTOBJECT (1000)
//
#define HIDC_IO_CREATENEW                       0x3E80834
#define HIDC_IO_CREATEFROMFILE                  0x3E80835
#define HIDC_IO_LINKFILE                        0x3E80836
#define HIDC_IO_OBJECTTYPELIST                  0x3E80837
#define HIDC_IO_DISPLAYASICON                   0x3E80838
#define HIDC_IO_CHANGEICON                      0x3E80839
#define HIDC_IO_FILE                            0x3E8083A
#define HIDC_IO_FILEDISPLAY                     0x3E8083B
#define HIDC_IO_RESULTIMAGE                     0x3E8083C
#define HIDC_IO_RESULTTEXT                      0x3E8083D
#define HIDC_IO_ICONDISPLAY                     0x3E8083E
#define HIDC_IO_FILETYPE                        0x3E80841
#define HIDC_IO_INSERTCONTROL                   0x3E80842
#define HIDC_IO_ADDCONTROL                      0x3E80843
#define HIDC_IO_CONTROLTYPELIST                 0x3E80844

const DWORD aOleDlgHelpIDs[]={
        IDC_IO_CREATENEW,       HIDC_IO_CREATENEW,
        IDC_IO_CREATEFROMFILE,  HIDC_IO_CREATEFROMFILE,
        IDC_IO_LINKFILE,        HIDC_IO_LINKFILE,
        IDC_IO_OBJECTTYPELIST,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_DISPLAYASICON,   HIDC_IO_DISPLAYASICON,
        IDC_IO_CHANGEICON,      HIDC_IO_CHANGEICON,
        IDC_IO_FILE,            HIDC_IO_FILE,
        IDC_IO_FILEDISPLAY,     HIDC_IO_FILEDISPLAY,
        IDC_IO_RESULTIMAGE,     HIDC_IO_RESULTIMAGE,
        IDC_IO_RESULTTEXT,      HIDC_IO_RESULTTEXT,
        IDC_IO_ICONDISPLAY,     HIDC_IO_ICONDISPLAY,
        IDC_IO_FILETYPE,        HIDC_IO_FILETYPE,
        IDC_IO_INSERTCONTROL,   HIDC_IO_INSERTCONTROL,
        IDC_IO_ADDCONTROL,      HIDC_IO_ADDCONTROL,
        IDC_IO_CONTROLTYPELIST, HIDC_IO_CONTROLTYPELIST,
        IDC_IO_OBJECTTYPETEXT,  HIDC_IO_OBJECTTYPELIST,
        IDC_IO_FILETEXT,        HIDC_IO_FILE,
        0,                      0
};

//------------------------------------------------------------------------
// CObjPropDlg dialog
//------------------------------------------------------------------------
CObjPropDlg::CObjPropDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CObjPropDlg::IDD, pParent)
{
}

//----------------------------------------------------------------------------
void CObjPropDlg::OnSelChangeFillColor()
{
    GetRBFillColor().SetCheck(1);
    GetRBFillTrans().SetCheck(0);
}

void CObjPropDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CObjPropDlg)
    DDX_Check(pDX, IDC_CB_DRAWBORDER, m_bCBDrawBorder);
    DDX_Check(pDX, IDC_RB_FILLCOLOR, m_bRBFillColor);
    DDX_Check(pDX, IDC_RB_FILLTRANS, m_bRBFillTrans);
    DDX_CBString(pDX, IDC_LB_THICKNESS, m_szThickness);
    DDX_CBString(pDX, IDC_LB_LINECOLOR, m_szLineColor);
    DDX_CBString(pDX, IDC_LB_FILLCOLOR, m_szFillColor);
    DDX_CBString(pDX, IDC_LB_TEXTCOLOR, m_szTextColor);
    // DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
        //}}AFX_DATA_MAP
}



LRESULT 
CObjPropDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{
    DWORD dwRes = ERROR_SUCCESS;

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        TRACE1("CPE: WinHelpContextPopup failed with %d\n", dwRes);
    }

    return 0;
}

void
CObjPropDlg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        TRACE1("CPE: WinHelpContextPopup failed with %d\n", dwRes);
    }
}


//------------------------------------------------------------------------
BOOL CObjPropDlg::OnInitDialog()
{
   TCHAR szPointSize[4] = {0};
   CComboBox& lbThickness = GetLBThickness();
   for ( int i = 0; i < ARR_SIZE(wStandardLineSizes) ; ++i) 
   {
       _sntprintf(szPointSize, ARR_SIZE(szPointSize)-1, TEXT("%d"), wStandardLineSizes[i]);
      lbThickness.AddString(szPointSize);
   }
   lbThickness.LimitText(2);

   CString szBLACK;
   szBLACK.LoadString(ID_COLOR_BLACK);
   CString szWHITE;
   szWHITE.LoadString(ID_COLOR_WHITE);
   CString szLTGRAY;
   szLTGRAY.LoadString(ID_COLOR_LTGRAY);
   CString szMDGRAY;
   szMDGRAY.LoadString(ID_COLOR_MDGRAY);
   CString szDKGRAY;
   szDKGRAY.LoadString(ID_COLOR_DKGRAY);

   GetLBLineColor().AddString(szBLACK);
   GetLBLineColor().AddString(szWHITE);
   GetLBLineColor().AddString(szLTGRAY);
   GetLBLineColor().AddString(szMDGRAY);
   GetLBLineColor().AddString(szDKGRAY);

   GetLBFillColor().AddString(szBLACK);
   GetLBFillColor().AddString(szWHITE);
   GetLBFillColor().AddString(szLTGRAY);
   GetLBFillColor().AddString(szMDGRAY);
   GetLBFillColor().AddString(szDKGRAY);

   GetLBTextColor().AddString(szBLACK);
   GetLBTextColor().AddString(szWHITE);
   GetLBTextColor().AddString(szLTGRAY);
   GetLBTextColor().AddString(szMDGRAY);
   GetLBTextColor().AddString(szDKGRAY);

   BOOL bFillObj=FALSE;
   BOOL bTextColor=TRUE;
   BOOL bFillColor=TRUE;
   BOOL bFillTrans=TRUE;
   BOOL bFillRGB=TRUE;
   BOOL bLineRGB=TRUE;
   BOOL bTextRGB=TRUE;
   BOOL bPen=TRUE;
   BOOL bPenThickness=TRUE;
   BOOL bBorder=TRUE;
   BOOL bTextObj=FALSE;
   BOOL bAllOleObjs=TRUE;
   int iSaveLinePointSize=0;
   COLORREF crSaveFillRGB=0;
   COLORREF crSaveLineRGB=0;
   COLORREF crSaveTextRGB=0;

   CDrawView* pView = CDrawView::GetView();
   if (!pView) {
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
      return FALSE;
   }

      //iterate thru selected objects for object properties
   POSITION pos = pView->m_selection.GetHeadPosition();
   while (pos != NULL) {
       CDrawObj* pObj = (CDrawObj*)pView->m_selection.GetNext(pos);

       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          bTextObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawLine)))
          bFillObj=TRUE;

       if (!pObj->IsKindOf(RUNTIME_CLASS(CDrawOleObj)))
          bAllOleObjs=FALSE;

       if (iSaveLinePointSize !=0 && iSaveLinePointSize != pObj->m_lLinePointSize)
         bPenThickness=FALSE;
       if (crSaveFillRGB !=0 && crSaveFillRGB != pObj->m_logbrush.lbColor)
         bFillRGB=FALSE;
       if (crSaveLineRGB !=0 && crSaveLineRGB != pObj->m_logpen.lopnColor)
         bLineRGB=FALSE;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)) &&
           crSaveTextRGB !=0 && crSaveTextRGB != ((CDrawText*)pObj)->m_crTextColor)
         bTextRGB=FALSE;

       if (!pObj->m_bBrush)
          bFillColor=FALSE;
       if (pObj->m_bBrush)
          bFillTrans=FALSE;
       if (!pObj->m_bPen)
          bPen=FALSE;

       iSaveLinePointSize=pObj->m_lLinePointSize;
       crSaveFillRGB=pObj->m_logbrush.lbColor;
       crSaveLineRGB=pObj->m_logpen.lopnColor;
       if (pObj->IsKindOf(RUNTIME_CLASS(CDrawText)))
          crSaveTextRGB=((CDrawText*)pObj)->m_crTextColor;
   }


    //load default point size
   if (bPenThickness) {
      _itot (iSaveLinePointSize, szPointSize, 10);
      m_szThickness=szPointSize;
   }
   else
      m_szThickness="";    //indeterminate state

   CString sz;
   if (bFillRGB) {  //Fill color listbox
      if (crSaveFillRGB==COLOR_BLACK)
         m_szFillColor=szBLACK;
      else
      if (crSaveFillRGB==COLOR_WHITE)
         m_szFillColor=szWHITE;
      else
      if (crSaveFillRGB==COLOR_LTGRAY)
         m_szFillColor=szLTGRAY;
      else
      if (crSaveFillRGB==COLOR_MDGRAY)
         m_szFillColor=szMDGRAY;
      else
      if (crSaveFillRGB==COLOR_DKGRAY)
         m_szFillColor=szDKGRAY;
      else
         m_szFillColor=szWHITE;
   }
   else
      m_szFillColor="";

   if (bLineRGB) { //Line color listbox
      if (crSaveLineRGB==COLOR_BLACK)
         m_szLineColor=szBLACK;
      else
      if (crSaveLineRGB==COLOR_WHITE)
         m_szLineColor=szWHITE;
      else
      if (crSaveLineRGB==COLOR_LTGRAY)
         m_szLineColor=szLTGRAY;
      else
      if (crSaveLineRGB==COLOR_MDGRAY)
         m_szLineColor=szMDGRAY;
      else
      if (crSaveLineRGB==COLOR_DKGRAY)
         m_szLineColor=szDKGRAY;
      else
         m_szLineColor=szBLACK;
   }
   else
      m_szLineColor="";

   if (bTextRGB) {
      if (crSaveTextRGB==COLOR_BLACK)
         m_szTextColor=szBLACK;
      else
      if (crSaveTextRGB==COLOR_WHITE)
         m_szTextColor=szWHITE;
      else
      if (crSaveTextRGB==COLOR_LTGRAY)
         m_szTextColor=szLTGRAY;
      else
      if (crSaveTextRGB==COLOR_MDGRAY)
         m_szTextColor=szMDGRAY;
      else
      if (crSaveTextRGB==COLOR_DKGRAY)
         m_szTextColor=szDKGRAY;
      else
         m_szTextColor=szBLACK;
   }
   else
      m_szTextColor="";

   m_bCBDrawBorder=bPen;
   m_bRBFillColor=bFillColor;
   m_bRBFillTrans=bFillTrans;

   if (!bFillObj) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   if (!bTextObj) {
     GetLBTextColor().EnableWindow(FALSE);
     GetSTTextColor().EnableWindow(FALSE);
   }

   if (bAllOleObjs) {
     GetLBFillColor().EnableWindow(FALSE);
     GetGRPFillColor().EnableWindow(FALSE);
     GetRBFillColor().EnableWindow(FALSE);
     GetRBFillTrans().EnableWindow(FALSE);
   }

   CDialog::OnInitDialog();

   ModifyStyleEx(0, WS_EX_CONTEXTHELP);  /////// puts "?" button in the dialog box.

   return TRUE;
}


//------------------------------------------------------------------------
void CObjPropDlg::OnOK()
{
    BOOL bTrans;
    int  nThickness = (int)GetDlgItemInt(IDC_LB_THICKNESS, &bTrans);

    if (!bTrans || nThickness < 0 || nThickness > wStandardLineSizes[ARR_SIZE(wStandardLineSizes)-1]) 
    {
        CPEMessageBox(0,NULL,MB_OK | MB_ICONSTOP,IDP_INVALID_THICKNESS);
        GetLBThickness().SetFocus();
        return;
    }

    CDialog::OnOK();
}




#ifdef GRID
//------------------------------------------------------------------------
// CGridSettingsDlg dialog
//------------------------------------------------------------------------
CGridSettingsDlg::CGridSettingsDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CGridSettingsDlg::IDD, pParent)
{
   CDrawView* pView = CDrawView::GetView();
   if (pView) {
      m_bRBSmall=(pView->m_iGridSize==GRID_SMALL);
      m_bRBMedium=(pView->m_iGridSize==GRID_MEDIUM);
      m_bRBLarge=(pView->m_iGridSize==GRID_LARGE);
      m_bCBViewGrid=pView->m_bGrid;
      m_bCBSnapToGrid=pView->m_bSnapToGrid;
   }
   else
      TRACE(TEXT("DIALOGS.CGRidSettingsDlg-view missing\n"));
}


void CGridSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGridSettingsDlg)
    DDX_Check(pDX, IDC_RB_SMALL, m_bRBSmall);
    DDX_Check(pDX, IDC_RB_MEDIUM, m_bRBMedium);
    DDX_Check(pDX, IDC_RB_LARGE, m_bRBLarge);
    DDX_Check(pDX, IDC_CB_VIEWGRID, m_bCBViewGrid);
    DDX_Check(pDX, IDC_CB_SNAPTOGRID, m_bCBSnapToGrid);
        //}}AFX_DATA_MAP
}

//------------------------------------------------------------------------
BOOL CGridSettingsDlg::OnInitDialog()
{
   return CDialog::OnInitDialog();
}
#endif

LRESULT CGridSettingsDlg::OnWM_HELP( WPARAM wParam, LPARAM lParam )
{
    SetLastError(0);
    ::HtmlHelp( (HWND)(((LPHELPINFO)lParam)->hItemHandle),
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return 0;
}


///////#ifdef ENABLE_HELP
LRESULT CGridSettingsDlg::OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam )
{
    SetLastError(0);

    ::HtmlHelp( (HWND)wParam,
                GetApp()->GetHtmlHelpFile(),
                HH_DISPLAY_TOPIC, 0L);
    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return( 0 );
}
//////////#endif




//-----------------------------------------------------------------------
int CPEMessageBox(int errorcode, LPCTSTR sz, UINT nType, int msgid)
{
   if (sz==NULL && msgid==-1)
      return 0;

   CString lpszCaption;
   CString lpszText;
   CString temp;

   lpszCaption.LoadString(IDS_MESSAGE);

   if (sz==NULL)
       lpszText.LoadString(msgid);
   else
       lpszText = sz;
   
   if (((CDrawApp*)AfxGetApp())->IsInConvertMode() )
   {
       //
       // we don't want to show pop up's in case of coversion of CPE's to COV's
       //
       return IDOK;
   }
   return ::AlignedMessageBox(CWnd::GetFocus()->GetSafeHwnd(), lpszText, lpszCaption, nType);
}

int 
AlignedAfxMessageBox( 
    LPCTSTR lpszText, 
    UINT    nType, 
    UINT    nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    if (((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // we don't want to show pop up's in case of coversion of CPE's to COV's
        //
        return IDOK;
    }
    return AfxMessageBox(lpszText, nType, nIDHelp);
}

int 
AlignedAfxMessageBox( 
    UINT nIDPrompt, 
    UINT nType, 
    UINT nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }
    
    if ( ((CDrawApp*)AfxGetApp())->IsInConvertMode() )
    {
        //
        // we don't want to show pop up's in case of coversion of CPE's to COV's
        //
        return IDOK;
    }

    return AfxMessageBox(nIDPrompt, nType, nIDHelp);
}




//--------------------------------------------------------------------------
//  SPLASH TIPS DIALOG
//--------------------------------------------------------------------------
CSplashTipsDlg::CSplashTipsDlg(BOOL bRandomTip, CWnd* pWnd /*=NULL*/)
   : CDialog(CSplashTipsDlg::IDD),
   m_bRandomTip(bRandomTip)
{
        //{{AFX_DATA_INIT(CSplashTipsDlg)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}



//--------------------------------------------------------------------------
void CSplashTipsDlg::OnPrevTip()
{
    if (m_iCurrentTip>1)
       m_iCurrentTip--;
    else
       m_iCurrentTip=TOTAL_TIPS;

    CString sz;
    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
void CSplashTipsDlg::OnNextTip()
{
    if (m_iCurrentTip<TOTAL_TIPS)
       m_iCurrentTip++;
    else
       m_iCurrentTip=1;

    CString sz;
    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);
}


//--------------------------------------------------------------------------
HBRUSH CSplashTipsDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
        int dlg_id;

        dlg_id = pWnd->GetDlgCtrlID();

#ifndef WIN32S
        if( dlg_id != IDC_CK_SHOWTIPS )
                {
                if( (nCtlColor == CTLCOLOR_STATIC)||(dlg_id == IDC_TIPWINDOW) )
                        {
                        pDC->SetTextColor( GetSysColor( COLOR_INFOTEXT ) );
                        pDC->SetBkMode( TRANSPARENT );
                return( (HBRUSH)::GetSysColorBrush( COLOR_INFOBK ) );
                        }
                }
#endif

        return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

//--------------------------------------------------------------------------
void CSplashTipsDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CSplashTipsDlg)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}

void CSplashTipsDlg::OnOK()
{
        AfxGetApp()->WriteProfileString(TIPSECTION,TIPENTRY,(GetShowTips()->GetCheck()==1 ? _T("YES"):_T("NO") ));

    CDialog::OnOK();
}

//--------------------------------------------------------------------------
BOOL 
CSplashTipsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    CenterWindow();
    CString sz;

    sz.LoadString(IDS_DIDYOUKNOW);
    GetTitle()->SetWindowText(sz);

    m_iCurrentTip=1;
    if(m_bRandomTip)
    {
        srand((unsigned)time( NULL ));
        m_iCurrentTip = rand() % TOTAL_TIPS;
    }

    sz.LoadString(IDS_TIP_BASE + m_iCurrentTip);
    GetTips()->SetWindowText(sz);

    GetPrevTip()->EnableWindow(m_iCurrentTip != 1);
    GetNextTip()->EnableWindow(m_iCurrentTip != TOTAL_TIPS);

    sz = AfxGetApp()->GetProfileString(TIPSECTION,TIPENTRY,_T("YES"));
    GetShowTips()->SetCheck(sz==_T("YES"));

    // set fonts for tips window
    LOGFONT lf;
    (GetTitle()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_BOLD;
    m_tipstitle_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TITLE)->SetFont(&m_tipstitle_font);

    (GetTips()->GetFont())->GetObject(sizeof(LOGFONT),&lf);
    lf.lfWeight = FW_NORMAL;
    m_tips_font.CreateFontIndirect(&lf);
    GetDlgItem(IDC_STA_TIP)->SetFont(&m_tips_font);

    return TRUE;
}


#define CY_SHADOW   4
#define CX_SHADOW   4

//--------------------------------------------------------------------------
void CBigIcon::SizeToContent()
{
   // get system icon size
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   // a big icon should be twice the size of an icon + shadows
        SetWindowPos(NULL, 0, 0, cxIcon*2 + CX_SHADOW + 4, cyIcon*2 + CY_SHADOW + 4,
                SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
}


//--------------------------------------------------------------------------
void CBigIcon::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
   CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
   ASSERT(pDC != NULL);

   CRect rect;
   GetClientRect(rect);
   int cxClient = rect.Width();
   int cyClient = rect.Height();

   // load icon
   HICON hicon = AfxGetApp()->LoadIcon(IDR_AWCPETYPE);
   if (hicon == NULL)
        return;

   // draw icon into off-screen bitmap
   int cxIcon = ::GetSystemMetrics(SM_CXICON);
   int cyIcon = ::GetSystemMetrics(SM_CYICON);

   CBitmap bitmap;
   if (!bitmap.CreateCompatibleBitmap(pDC, cxIcon, cyIcon))
        return;
   CDC dcMem;
   if (!dcMem.CreateCompatibleDC(pDC))
        return;
   CBitmap* pBitmapOld = dcMem.SelectObject(&bitmap);
   if (pBitmapOld == NULL)
        return;

   // blt the bits already on the window onto the off-screen bitmap
   dcMem.StretchBlt(0, 0, cxIcon, cyIcon, pDC,
        2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4, SRCCOPY);

   // draw the icon on the background
   dcMem.DrawIcon(0, 0, hicon);

   // draw border around icon
   CPen pen;
   pen.CreateStockObject(BLACK_PEN);
   CPen* pPenOld = pDC->SelectObject(&pen);
   pDC->Rectangle(0, 0, cxClient-CX_SHADOW, cyClient-CY_SHADOW);
   if (pPenOld)
        pDC->SelectObject(pPenOld);

   // draw shadows around icon
   CBrush br;
   br.CreateStockObject(DKGRAY_BRUSH);
   rect.SetRect(cxClient-CX_SHADOW, CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);
   rect.SetRect(CX_SHADOW, cyClient-CY_SHADOW, cxClient, cyClient);
   pDC->FillRect(rect, &br);

   // draw the icon contents
   pDC->StretchBlt(2, 2, cxClient-CX_SHADOW-4, cyClient-CY_SHADOW-4,
        &dcMem, 0, 0, cxIcon, cyIcon, SRCCOPY);
}


//--------------------------------------------------------------------------
BOOL CBigIcon::OnEraseBkgnd(CDC*)
{
   return TRUE;
}



//--------------------------------------------------------------------------
CMyPageSetupDialog::CMyPageSetupDialog(CWnd* pParentWnd) : CMyCommonDialog(pParentWnd)
{

    m_hLib=NULL;
    m_pPageSetupDlg=NULL;
        memset(&m_psd, 0, sizeof(m_psd));
        m_psd.lStructSize = sizeof(PAGESETUPDLG);
        m_psd.Flags |= PSD_DISABLEMARGINS;
        m_psd.hInstance = AfxGetInstanceHandle();


    UINT OldErrMode = ::SetErrorMode (SEM_FAILCRITICALERRORS);
        m_hLib = ::LoadLibrary(TEXT("comdlg32.dll"));
    if (m_hLib!=NULL) {
#ifdef UNICODE
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgW");
#else
        m_pPageSetupDlg = (PPSD)GetProcAddress(m_hLib, "PageSetupDlgA");
#endif
        if (m_pPageSetupDlg==NULL)
           CPEMessageBox(MSG_ERROR_NOPAGESETUP, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUP);
        }
        else
        CPEMessageBox(MSG_ERROR_NOPAGESETUPDLL, NULL, MB_OK | MB_ICONEXCLAMATION, IDS_NOPAGESETUPDLL);
    ::SetErrorMode (OldErrMode);
}







//--------------------------------------------------------------------------
CMyPageSetupDialog::~CMyPageSetupDialog()
{
    if (m_hLib)
       ::FreeLibrary(m_hLib);
}

//--------------------------------------------------------------------------
INT_PTR CMyPageSetupDialog::DoModal()
{
        ASSERT_VALID(this);
        ASSERT(m_pPageSetupDlg != NULL);

        m_psd.hwndOwner = PreModal();
        INT_PTR nResult = m_pPageSetupDlg(&m_psd);
        PostModal();


        return nResult;
}


//---------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CMyPrintDlg, CPrintDialog)

//---------------------------------------------------------------------------
CMyPrintDlg::CMyPrintDlg(BOOL bPrintSetupOnly, DWORD dwFlags, CWnd* pParentWnd) :
        CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
}

//---------------------------------------------------------------------------

BOOL CMyPrintDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
        return (Default() != 0);
}

//---------------------------------------------------------------------------

CMyCommonDialog::CMyCommonDialog( CWnd* pParentWnd ) :
       CCommonDialog( pParentWnd )
{
}

BOOL CMyCommonDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (Default() != 0);
}

//----------------------------------------------------------------------------
CMyFontDialog::CMyFontDialog( LPLOGFONT lplfInitial,
                              DWORD dwFlags,
                              CDC* pdcPrinter,
                              CWnd * pParentWnd) :
                 CFontDialog( lplfInitial, dwFlags, pdcPrinter, pParentWnd )
{
}
//----------------------------------------------------------------------------
CMyFontDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    return (Default() != 0);
}
//----------------------------------------------------------------------------
CMyOleInsertDialog::CMyOleInsertDialog(DWORD dwFlags, CWnd* pParentWnd ) :
        COleInsertDialog( dwFlags, pParentWnd )
{
}

//---------------------------------------------------------------------------
CMyOleInsertDialog::OnHelpInfo(HELPINFO* pHelpInfo)
{
    //// return Default();   /// Worked in the other dialog boxes, but here it just
                             /// flashed the item we want temporarily and then threw
                             /// the faxcover help contents up.  BAD!!

    ::WinHelp( (HWND)(pHelpInfo->hItemHandle),
                        TEXT("mfcuix.hlp"),
                        HELP_WM_HELP,
                        (ULONG_PTR)(LPSTR)aOleDlgHelpIDs ) ;

    return 0;


}
//---------------------------------------------------------------------------

//-------------------------------------------------------------------------
// *_*_*_*_   M E S S A G E    M A P S     *_*_*_*_
//-------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(CObjPropDlg, CDialog)
   //{{AFX_MSG_MAP(CObjPropDlg)
   ON_LBN_SELCHANGE(IDC_LB_FILLCOLOR, OnSelChangeFillColor)
   ON_MESSAGE( WM_HELP, OnWM_HELP )
   ON_WM_CONTEXTMENU()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef GRID
BEGIN_MESSAGE_MAP(CGridSettingsDlg, CDialog)
    //{{AFX_MSG_MAP(CGridSettingsDlg)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
   ON_MESSAGE( WM_HELP, OnWM_HELP )
/////#ifdef ENABLE_HELP
   ON_MESSAGE( WM_CONTEXTMENU, OnWM_CONTEXTMENU )
/////#endif
END_MESSAGE_MAP()
#endif

BEGIN_MESSAGE_MAP(CSplashTipsDlg, CDialog)
   //{{AFX_MSG_MAP(CSplashTipsDlg)
   ON_WM_CTLCOLOR()
   ON_BN_CLICKED(IDC_B_NEXTTIP, OnNextTip)
   ON_BN_CLICKED(IDC_B_PREVTIP, OnPrevTip)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CBigIcon, CButton)
        //{{AFX_MSG_MAP(CBigIcon)
        ON_WM_DRAWITEM()
        ON_WM_ERASEBKGND()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_MESSAGE_MAP(CMyPrintDlg, CPrintDialog)
        //{{AFX_MSG_MAP(CMyPrintDlg)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyCommonDialog, CCommonDialog)
        //{{AFX_MSG_MAP(CMyCommonDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyOleInsertDialog, COleInsertDialog)
        //{{AFX_MSG_MAP(CMyOleInsertDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CMyFontDialog, CFontDialog)
        //{{AFX_MSG_MAP(CMyFontDialog)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\mainfrm.h ===
//---------------------------------------------------------------------------
// MAINFRM.H
//
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//--------------------------------------------------------------------------
#ifndef __MAINFRM_H__
#define __MAINFRM_H__

///#ifndef ENABLE_HELP
///#define ENABLE_HELP
///#endif

class CSizeComboBox : public CComboBox
{
        int m_nLogVert;
public:
        void EnumFontSizes(CString& szFontName);
        static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf,
                LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
        void InsertSize(int nSize);
};



class CStyleBar : public CToolBar
{
public:
        CComboBox       m_cboxFontName;
        CSizeComboBox   m_cboxFontSize;
        CFont       m_font;
protected:
        virtual BOOL PreTranslateMessage(MSG* pMsg);
};

class CDrawApp;

class CMainFrame : public CFrameWnd
{
        DECLARE_DYNCREATE(CMainFrame)
public:
    CStyleBar   m_StyleBar;
        CToolBar    m_DrawBar;
        CStatusBar  m_wndStatusBar;

        CMainFrame();
        virtual ~CMainFrame();
        virtual void ActivateFrame( int nCmdShow = - 1 );

    CDrawApp* GetApp() {return ((CDrawApp*)AfxGetApp());}

#ifdef _DEBUG
        virtual void AssertValid() const;
        virtual void Dump(CDumpContext& dc) const;
#endif

protected:
   HMENU m_mainmenu;
   int m_iTop;
   int m_iSecond;
   HICON m_toolbar_icon;

   BOOL CreateDrawToolBar();
   BOOL CreateStyleBar();

   afx_msg void OnMenuSelect(UINT, UINT, HMENU);
   afx_msg void OnInitMenu(CMenu* pPopupMenu);
   afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
   afx_msg void OnUpdateControlStyleBarMenu(CCmdUI* pCmdUI);
   afx_msg void OnUpdateControlDrawBarMenu(CCmdUI* pCmdUI);
   afx_msg BOOL OnStyleBarCheck(UINT nID);
   afx_msg BOOL OnDrawBarCheck(UINT nID);
   afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
   afx_msg void OnShowTips();
   afx_msg void OnDropDownFontName();
   afx_msg void OnDropDownFontSize();
   afx_msg void OnUpdateHelp(CCmdUI* pCmdUI);
   virtual BOOL PreTranslateMessage(MSG* pMsg);

   void PopupText();
   void EnumFontSizes(CString& szFontName);

        //{{AFX_MSG(CMainFrame)
   afx_msg LRESULT OnAWCPEActivate(WPARAM wParam, LPARAM lParam);
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        //}}AFX_MSG
///#ifdef ENABLE_HELP ////
///        afx_msg LRESULT OnWM_CONTEXTMENU( WPARAM wParam, LPARAM lParam );
///#endif
        afx_msg void OnHelp();
        afx_msg LRESULT OnWM_HELP(WPARAM wParam, LPARAM lParam);
        afx_msg BOOL OnQueryOpen( void );

   DECLARE_MESSAGE_MAP()
};



#endif // #ifndef __MAINFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF

!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXCOVER)
TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows
C_DEFINES=$(C_DEFINES) /D_NT_SUR_ /DNO_STRICT /DWIN4 /DNT4 /DNT_BUILD

NOMFCPDB=1
USE_NATIVE_EH=1

TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib    \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\oleaut32.lib    \
  $(BASEDIR)\public\sdk\lib\*\comctl32.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\htmlhelp.lib

SOURCES=\
  ..\awcpe.cpp      \
  ..\cntritem.cpp   \
  ..\cpedoc.cpp     \
  ..\cpeedt.cpp     \
  ..\cpeobj.cpp     \
  ..\cpetool.cpp    \
  ..\cpevw.cpp      \
  ..\dialogs.cpp    \
  ..\faxprop.cpp    \
  ..\mainfrm.cpp    \
  ..\awcpe.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE 2.0 support
#include <afxodlgs.h>       // MFC OLE 2.0 dialog support
#include <oledlg.h>         // MFC OLE dialog support
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxcover\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by awcpe.rc
//
#define IDR_AWCPETYPE                   2
#define IDR_AWCPEDOC                    3
#define IDR_AWCPETYPE_CNTR_IP           6
#define IDR_STYLEBAR                    10
#define IDR_DRAWTOOL                    11
#define ID_GRIDDOT                      12
#define IDR_STYLEBAR_RTL                14
#define IDR_DRAWTOOL_RTL                15
#define IDW_STYLEBAR                    20
#define ID_VIEW_STYLEBAR                20
#define ID_TEXT                         20
#define IDW_DRAWBAR                     21
#define ID_VIEW_DRAWBAR                 21
#define ID_VIEW_GRIDLINES               22
#define IDC_B_PREVTIP                   80
#define IDC_B_NEXTTIP                   81
#define IDD_SPLASHTIPS                  99
#define IDD_ABOUTBOX                    100
#define IDP_BUSY                        100
#define IDD_OBJ_PROP                    101
#define IDP_OLE_INIT_FAILED             101
#define IDD_GRID_SETTINGS               102
#define IDP_FAILED_TO_CREATE            102
#define IDC_WEIGHT                      102
#define IDC_PENCIL                      102
#define IDC_NOFILL                      103
#define ID_CANCEL_EDIT                  104
#define ID_SNAP_TO_GRID                 105
#define IDI_TBARICON                    108
#define IDC_MOVE                        109
#define IDC_CB_VIEWGRID                 113
#define IDC_CB_SNAPTOGRID               114
#define IDC_RB_SMALL                    115
#define IDC_RB_MEDIUM                   116
#define IDC_RB_LARGE                    117
#define IDC_ST_TEXTCOLOR                118
#define IDC_GRP_FILLCOLOR               119
#define IDC_PHYSICAL_MEM                120
#define IDC_DISK_SPACE                  121
#define IDC_BIGICON                     122
#define IDC_STA_TIP                     123
#define IDC_CK_SHOWTIPS                 124
#define IDC_STA_BITMAP                  127
#define IDC_STA_TITLE                   129
#define IDC_ICO_TIPS                    130
#define IDC_ST_THICKNESS                131
#define IDC_TIPWINDOW                   131
#define IDC_ST_COLOR                    132
#define IDS_HELP_SCREEN                 135
#define IDI_TIPS                        140
#define ID_VIEW_GRID                    150
#define ID_OBJECT_LINECOLOR             201
#define ID_OBJECT_FILLCOLOR             202
#define ID_OBJECT_MOVETOFRONT           203
#define ID_OBJECT_MOVETOBACK            204
#define ID_OBJECT_MOVEFORWARD           205
#define ID_OBJECT_MOVEBACK              206
#define ID_LAYOUT_ALIGNLEFT             208
#define ID_LAYOUT_ALIGNRIGHT            209
#define ID_LAYOUT_ALIGNTOP              210
#define ID_LAYOUT_ALIGNBOTTOM           211
#define ID_LAYOUT_ALIGNHORZCENTER       212
#define ID_LAYOUT_ALIGNVERTCENTER       213
#define ID_LAYOUT_SPACEACROSS           214
#define ID_LAYOUT_SPACEDOWN             215
#define ID_LAYOUT_CENTERWIDTH           216
#define ID_LAYOUT_CENTERHEIGHT          217
#define ID_VIEW_PAPERCOLOR              301
#define ID_VIEW_SHOWOBJECTS             302
#define ID_EDIT_PROPERTIES              400
#define ID_DRAW_SELECT                  501
#define ID_DRAW_TEXT                    502
#define ID_DRAW_LINE                    503
#define ID_DRAW_RECT                    504
#define ID_DRAW_ROUNDRECT               505
#define ID_DRAW_POLYGON                 506
#define ID_DRAW_ELLIPSE                 507
#define ID_STYLE_BOLD                   600
#define ID_STYLE_ITALIC                 601
#define ID_STYLE_UNDERLINE              602
#define ID_STYLE_LEFT                   603
#define ID_STYLE_CENTERED               604
#define ID_STYLE_RIGHT                  605
#define ID_FONT_NAME                    650
#define ID_FONT_SIZE                    651
#define ID_FONT                         700
#define ID_ALIGN_LEFT                   701
#define ID_ALIGN_CENTER                 702
#define ID_ALIGN_RIGHT                  703
#define ID_SHOW_TIPS                    750
#define IDC_COMM_STATIC                 998
#define IDC_COMM_GROUPBOX               999
#define ID_MAPI_RECIP_NAME              1001
#define ID_MAPI_RECIP_FAXNUM            1002
#define ID_MAPI_RECIP_COMPANY           1003
#define ID_MAPI_RECIP_ADDRESS           1004
#define ID_MAPI_RECIP_TITLE             1005
#define ID_MAPI_RECIP_DEPT              1006
#define ID_MAPI_RECIP_OFFICELOC         1007
#define ID_MAPI_RECIP_HMTELENUM         1008
#define ID_MAPI_RECIP_OFTELENUM         1009
#define ID_MAPI_RECIP_TOLIST            1010
#define ID_MAPI_RECIP_CCLIST            1011
#define ID_MAPI_SENDER_NAME             1012
#define ID_MAPI_SENDER_FAXNUM           1013
#define ID_MAPI_SENDER_COMPANY          1014
#define ID_MAPI_SENDER_ADDRESS          1015
#define ID_MAPI_SENDER_TITLE            1016
#define ID_MAPI_SENDER_DEPT             1017
#define ID_MAPI_SENDER_OFFICELOC        1018
#define ID_MAPI_SENDER_HMTELENUM        1019
#define ID_MAPI_SENDER_OFTELENUM        1020
#define ID_MAPI_MSG_SUBJECT             1021
#define ID_MAPI_MSG_TIMESENT            1022
#define ID_MAPI_MSG_NUMPAGES            1023
#define ID_MAPI_MSG_ATTACH              1024
#define ID_MAPI_MSG_BILLCODE            1025
#define ID_MAPI_MSG_FAXTEXT             1026
#define ID_MAPI_RECIP_CITY              1027
#define ID_MAPI_RECIP_STATE             1028
#define ID_MAPI_RECIP_ZIPCODE           1029
#define ID_MAPI_RECIP_COUNTRY           1030
#define ID_MAPI_RECIP_POBOX             1031
#define ID_MAPI_MSG_NOTE                1032
#define IDS_OLD_FILE_FILTER             1033
#define ID_TOOLBAR_STYLE                1100
#define ID_TOOLBAR_DRAWING              1101
#define IDS_PROP_RP_NAME                2001
#define IDS_CAPT_RP_NAME                2002
#define IDS_PROP_RP_FXNO                2003
#define IDS_CAPT_RP_FXNO                2004
#define IDS_PROP_RP_COMP                2005
#define IDS_CAPT_RP_COMP                2006
#define IDS_PROP_RP_ADDR                2007
#define IDS_CAPT_RP_ADDR                2008
#define IDS_PROP_RP_TITL                2009
#define IDS_CAPT_RP_TITL                2010
#define IDS_PROP_RP_DEPT                2011
#define IDS_CAPT_RP_DEPT                2012
#define IDS_PROP_RP_OFFI                2013
#define IDS_CAPT_RP_OFFI                2014
#define IDS_PROP_RP_HTEL                2015
#define IDS_CAPT_RP_HTEL                2016
#define IDS_PROP_RP_OTEL                2017
#define IDS_CAPT_RP_OTEL                2018
#define IDS_PROP_RP_TOLS                2019
#define IDS_CAPT_RP_TOLS                2020
#define IDS_PROP_RP_CCLS                2021
#define IDS_CAPT_RP_CCLS                2022
#define IDS_PROP_SN_NAME                2023
#define IDS_CAPT_SN_NAME                2024
#define IDS_PROP_SN_FXNO                2025
#define IDS_CAPT_SN_FXNO                2026
#define IDS_PROP_SN_COMP                2027
#define IDS_CAPT_SN_COMP                2028
#define IDS_PROP_SN_ADDR                2029
#define IDS_CAPT_SN_ADDR                2030
#define IDS_PROP_SN_TITL                2031
#define IDS_CAPT_SN_TITL                2032
#define IDS_PROP_SN_DEPT                2033
#define IDS_CAPT_SN_DEPT                2034
#define IDS_PROP_SN_OFFI                2035
#define IDS_CAPT_SN_OFFI                2036
#define IDS_PROP_SN_HTEL                2037
#define IDS_CAPT_SN_HTEL                2038
#define IDS_PROP_SN_OTEL                2039
#define IDS_CAPT_SN_OTEL                2040
#define IDS_PROP_MS_SUBJ                2041
#define IDS_CAPT_MS_SUBJ                2042
#define IDS_PROP_MS_TSNT                2043
#define IDS_CAPT_MS_TSNT                2044
#define IDS_PROP_MS_NOPG                2045
#define IDS_CAPT_MS_NOPG                2046
#define IDS_PROP_MS_NOAT                2047
#define IDS_CAPT_MS_NOAT                2048
#define IDS_PROP_MS_BCOD                2049
#define IDS_CAPT_MS_BCOD                2050
#define IDS_PROP_MS_TEXT                2051
#define IDS_CAPT_MS_TEXT                2052
#define IDS_PROP_RP_CITY                2053
#define IDS_CAPT_RP_CITY                2054
#define IDS_PROP_RP_STAT                2055
#define IDS_CAPT_RP_STAT                2056
#define IDS_PROP_RP_ZIPC                2057
#define IDS_CAPT_RP_ZIPC                2058
#define IDS_PROP_RP_CTRY                2059
#define IDS_CAPT_RP_CTRY                2060
#define IDS_PROP_RP_POBX                2061
#define IDS_CAPT_RP_POBX                2062
#define IDS_PROP_MS_NOTE                2063
#define IDS_CAPT_MS_NOTE                2064
#define IDP_FILE_MENU                   2100
#define IDP_EDIT_MENU                   2101
#define IDP_VIEW_MENU                   2102
#define IDP_INSERT_MENU                 2103
#define IDP_FORMAT_MENU                 2104
#define IDP_LAYOUT_MENU                 2105
#define IDP_HELP_MENU                   2106
#define IDP_SPACE_EVEN                  2107
#define IDP_CENTER_PAGE                 2108
#define IDP_ALIGN_TEXT                  2109
#define IDP_RECIPIENT                   2110
#define IDP_SENDER                      2111
#define IDP_MESSAGE                     2112
#define IDP_ALIGN_OBJECTS               2113
#define IDP_INVALID_THICKNESS           2115
#define IDP_OLE_STATIC_OBJECT           2116
#define IDS_DISK_SPACE_UNAVAIL          2200
#define IDS_DISK_SPACE                  2209
#define IDS_MATH_COPR_NOTPRESENT        2210
#define IDS_MATH_COPR_PRESENT           2211
#define IDS_PHYSICAL_MEM                2212
#define IDS_INVALID_FILE                2213
#define IDS_CORRUPT_FILE                2214
#define IDS_MAWF_NAME                   2300
#define IDS_AWF_NAME                    2301
#define IDS_APP_NAME                    2302
#define IDS_INFORMATION_MESSAGE         2303
#define IDS_WARNING_MESSAGE             2304
#define IDS_CRITICAL_MESSAGE            2305
#define IDS_MODULE_NAME                 2309
#define MAWF_E_GENERIC                  2310
#define IDS_IDNUM                       2311
#define IDS_MESSAGE                     2312
#define IDS_MENU_CUT                    2400
#define IDS_MENU_COPY                   2401
#define IDS_MENU_PASTE                  2402
#define IDS_MENU_FONT                   2403
#define IDS_MENU_ALIGNTEXT              2404
#define IDS_MENU_ALIGNLEFT              2405
#define IDS_MENU_ALIGNCENTER            2406
#define IDS_MENU_ALIGNRIGHT             2407
#define IDS_MENU_PROPERTIES             2408
#define IDS_MENU_MOVETOFRONT            2409
#define IDS_MENU_SENDTOBACK             2410
#define IDS_MENU_VIEWSTYLEBAR           2411
#define IDS_MENU_VIEWDRAWINGBAR         2412
#define IDS_MENU_VIEWSTATUSBAR          2413
#define IDS_MENU_VIEWGRIDLINES          2414
#define IDS_TIP_BASE                    2500
#define IDS_TIP1                        2501
#define IDS_TIP2                        2502
#define IDS_TIP3                        2503
#define IDS_TIP4                        2504
#define IDS_TIP5                        2505
#define IDS_TIP6                        2506
#define IDS_TIP7                        2507
#define IDS_TIP8                        2508
#define IDS_TIP9                        2509
#define IDS_TIP10                       2510
#define IDS_TIP11                       2511
#define IDS_TIP12                       2512
#define IDS_TIP13                       2513
#define IDS_TIP14                       2514
#define IDS_TIP15                       2515
#define IDS_TIP16                       2516
#define IDS_TIP17                       2517
#define IDS_TIP18                       2518
#define IDS_TIP19                       2519
#define IDS_MISSING_FILE                2520
#define IDS_NOPAGESETUP                 2521
#define IDS_NOPAGESETUPDLL              2522
#define IDS_FRIENDLY_TYPE_NAME          2523
#define IDS_DIDYOUKNOW                  2999
#define IDS_INFO_NOFAXPROP              3000
#define ID_COLOR_BLACK                  3006
#define ID_COLOR_WHITE                  3007
#define ID_COLOR_LTGRAY                 3008
#define ID_COLOR_DKGRAY                 3009
#define ID_COLOR_MDGRAY                 3010
#define ID_INDICATOR_POS1               3011
#define IDS_NOMOREUNDO                  3012
#define IDS_INFO_DRAWPOLY               3013
#define ID_INDICATOR_POS2               3014
#define IDC_CB_DRAWBORDER               4000
#define IDS_DEFAULT_FONT                4000
#define IDC_LB_THICKNESS                4001
#define IDS_DEFAULT_BOXFONT             4001
#define IDC_LB_LINECOLOR                4002
#define IDC_RB_FILLTRANS                4004
#define IDC_RB_FILLCOLOR                4005
#define IDC_TXTLB_FILLCOLOR             4006
#define IDC_LB_FILLCOLOR                4007
#define IDC_LB_TEXTCOLOR                4008
#define ID_MAPI_MSG_BODY                32790
#define IDS_SAVE_AS_TOO_LONG            32791
#define IDS_CP_FILTER_FORMAT            32792
#define IDS_ERR_NO_HTML_HELP            32793

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         32791
#define _APS_NEXT_CONTROL_VALUE         132
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxverify.inc ===
BINPLACE_OVERRIDE_FLAGS=
C_DEFINES=$(C_DEFINES) -DBUILD_PRODUCT=$(BUILD_PRODUCT)

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG -DFAX_HEAP_DEBUG
!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
MSC_OPTIMIZATION=-Od
!endif
!endif

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS=$(FAXROOT)\util\unicode\$O\faxutil.lib
!else
C_DEFINES=$(C_DEFINES) -D_MBCS
LINKLIBS=$(FAXROOT)\util\ansii\$O\faxutil.lib
!endif

C_DEFINES=$(C_DEFINES) -DTAPI_CURRENT_VERSION=0x00020000 -DNT5BETA2

FAXLIB=$(FAXROOT)\lib
FAXVERIFIERROOT=$(FAXROOT)\faxverify

INCLUDES=$(FAXROOT)\inc;$(FAXROOT)\build

MSC_WARNING_LEVEL=/W3 /WX
LINKER_FLAGS=-IGNORE:4006,4088,4104

COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h -FI$(FAXROOT)\inc\warning.h

!if $(PPC)
COMPILER_WARNINGS=$(COMPILER_WARNINGS) /W3 /WX
!endif

#
# force the build lab's checked
# build machines to have full symbolic
# debug info
#
!if "$(NTDEBUG)" == "cvp"
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -Z
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
!endif

#
# make us completely self contained
#
COFFBASE_TXT_FILE=$(FAXROOT)\NT_coffbase.txt
BINPLACE_PLACEFILE=$(FAXVERIFIERROOT)\NT_placefil.txt


#
# Figure out where to place the images
#

!ifndef OVERRIDE_DEFAULT_BINPLACE
_NTTREE=$(_NTTREE)\Test\FaxVerifier
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\macros.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.h

Abstract:

  This module contains the global macros

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _MACROS_H
#define _MACROS_H

HINSTANCE  g_hInstance = NULL;   // g_hInstance is the handle to the instance
HANDLE     hProcessHeap = NULL;  // hProcessHeap is a handle to the process heap

// MemInitializeMacro is a macro to get the handle to the process heap
#define MemInitializeMacro() (hProcessHeap = GetProcessHeap())

// MemAllocMacro is a macro to allocate dwBytes bytes of memory from the process heap
#define MemAllocMacro(dwBytes) (HeapAlloc(hProcessHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, dwBytes))

// MemFreeMacro is a macro to free a memory block allocated from the process heap
#define MemFreeMacro(lpMem) (HeapFree(hProcessHeap, 0, lpMem))

// MAX_STRINGLEN is the text length limit of a character string resource
#define MAX_STRINGLEN  255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\ntlog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  ntlog.h

Abstract:

  This module contains the necessary ntlog definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _NTLOG_H
#define _NTLOG_H

#define TLS_INFO       0x00002000L  // Log at information level
#define TLS_SEV2       0x00000004L  // Log at severity 2 level
#define TLS_WARN       0x00000010L  // Log at warn level
#define TLS_PASS       0x00000020L  // Log at pass level
#define TLS_TEST       0x00000100L  // Log at test level
#define TLS_VARIATION  0x00000200L  // Log at variation level
#define TLS_REFRESH    0x00010000L  // Create new log file

#define TL_TEST        TLS_TEST     , TEXT(__FILE__), (int)__LINE__
#define TL_VARIATION   TLS_VARIATION, TEXT(__FILE__), (int)__LINE__

typedef HANDLE (APIENTRY *PTLCREATELOG) (LPCWSTR, DWORD);
typedef BOOL (APIENTRY *PTLDESTROYLOG) (HANDLE);
typedef BOOL (APIENTRY *PTLADDPARTICIPANT) (HANDLE, DWORD, int);
typedef BOOL (APIENTRY *PTLREMOVEPARTICIPANT) (HANDLE);
typedef BOOL FAR (cdecl *PTLLOG) (HANDLE, DWORD, LPCWSTR, int, LPCWSTR, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\resource.h ===
#define FONTNAME                           "MS Shell Dlg"
#define FONTSIZE                           8

#define IDD_SETUP                          101

#define IDR_MENU                           201
#define IDM_SEND                           202
#define IDM_RECEIVE                        203
#define IDM_HELP                           204

#define IDC_SEND_NUMBER                    1001
#define IDC_SEND_NUMBER_STATIC             1002
#define IDC_RECEIVE_NUMBER                 1003
#define IDC_RECEIVE_NUMBER_STATIC          1004
#define IDC_RAS_ENABLED_BUTTON             1005
#define IDC_RAS_USER_NAME_STATIC           1006
#define IDC_RAS_USER_NAME                  1007
#define IDC_RAS_PASSWORD_STATIC            1008
#define IDC_RAS_PASSWORD                   1009
#define IDC_RAS_DOMAIN_STATIC              1010
#define IDC_RAS_DOMAIN                     1011
#define IDC_NUM_PASSED                     1012
#define IDC_NUM_FAILED                     1013
#define IDC_NUM_TOTAL                      1014
#define IDC_STATUS_LIST                    1015
#define IDC_START_BUTTON                   1016
#define IDC_STOP_BUTTON                    1017
#define IDC_EXIT_BUTTON                    1018

#define IDS_FAX_MONITOR_NOT_INSTALLED      2001
#define IDS_FAX_PORT_NOT_INSTALLED         2002
#define IDS_FAX_DRIVER_NOT_INSTALLED       2003
#define IDS_FAX_PRINTER_NOT_INSTALLED      2004
#define IDS_COM_NOT_INITIALIZED            2005
#define IDS_FAXCOM_NOT_INSTALLED           2006
#define IDS_FAXADMIN_NOT_INSTALLED         2007
#define IDS_ROUTEEXT_NOT_INSTALLED         2008
#define IDS_FAX_SVC_NOT_INSTALLED          2009
#define IDS_FAX_SVC_NOT_STOPPED            2010
#define IDS_FAX_RCV_NOT_INITIALIZED        2011
#define IDS_FAX_CONNECT_FAILED             2012
#define IDS_FAX_ENUM_PORTS_FAILED          2013
#define IDS_FAX_PORTS_NOT_INSTALLED        2014
#define IDS_FAX_SET_PORT_FAILED            2015
#define IDS_FAX_RESTORE_PORT_FAILED        2016
#define IDS_OPEN_FAXDEVICES_REGKEY_FAILED  2017
#define IDS_FIXMODEMCLASS_DATA             2018
#define IDS_FAX_GET_CONFIG_FAILED          2019
#define IDS_FAX_SET_CONFIG_FAILED          2020
#define IDS_FAX_RESTORE_CONFIG_FAILED      2021
#define IDS_FAX_EVENT_QUEUE_FAILED         2022
#define IDS_EVENT_LABEL                    2023
#define IDS_PORT_LABEL                     2024
#define IDS_ASCII_SEND_NUMBER              2025
#define IDS_ASCII_RECEIVE_NUMBER           2026
#define IDS_MISSING_INFO                   2027
#define IDS_NO_SEND_NUMBER                 2028
#define IDS_NO_RECEIVE_NUMBER              2029
#define IDS_NO_RAS_USER_NAME               2030
#define IDS_NO_RAS_DOMAIN                  2031
#define IDS_STATUS_ITERATION_STARTED       2032
#define IDS_STATUS_ITERATION_STOPPED       2033
#define IDS_STATUS_ITERATION_PASSED        2034
#define IDS_STATUS_ITERATION_FAILED        2035
#define IDS_STATUS_TEST_PASSED             2036
#define IDS_STATUS_TEST_FAILED             2037
#define IDS_STATUS_TIMEOUT_ENDED           2038
#define IDS_STATUS_RAS_STARTING            2039
#define IDS_STATUS_RAS_STOPPING            2040
#define IDS_STATUS_RAS_FAILED              2041
#define IDS_STATUS_RAS_LINESPEED           2042
#define IDS_STATUS_RAS_PASSED              2043
#define IDS_STATUS_RAS_SPEED_SUSPECT       2044
#define IDS_STATUS_FAX_STARTING            2045
#define IDS_STATUS_FAX_STOPPING            2046
#define IDS_STATUS_FAX_SEND_PASSED         2047
#define IDS_STATUS_FAX_SEND_FAILED         2048
#define IDS_STATUS_FAX_WAITING             2049
#define IDS_STATUS_FAX_RECEIVED            2050
#define IDS_STATUS_FAX_ID                  2051
#define IDS_STATUS_FAX_INVALID             2052
#define IDS_STATUS_FAX_VERIFYING           2053
#define IDS_TIFF_VALID_TIFF                2054
#define IDS_TIFF_INVALID_TIFF              2055
#define IDS_TIFF_INVALID_IMAGEWIDTH        2056
#define IDS_TIFF_INVALID_IMAGELENGTH       2057
#define IDS_TIFF_INVALID_COMPRESSION       2058
#define IDS_TIFF_INVALID_PHOTOMETRIC       2059
#define IDS_TIFF_INVALID_XRESOLUTION       2060
#define IDS_TIFF_INVALID_YRESOLUTION       2061
#define IDS_TIFF_INVALID_SOFTWARE          2062
#define IDS_TIFF_INVALID_PAGES             2063
#define IDS_STATUS_RAS_DIALING             2064
#define IDS_STATUS_RAS_AUTHENTICATING      2065
#define IDS_STATUS_RAS_CONNECTED           2066
#define IDS_STATUS_FAX_INITIALIZING        2067
#define IDS_STATUS_FAX_DIALING             2068
#define IDS_STATUS_FAX_NO_DIAL_TONE_ABORT  2069
#define IDS_STATUS_FAX_NO_DIAL_TONE_RETRY  2070
#define IDS_STATUS_FAX_BUSY_ABORT          2071
#define IDS_STATUS_FAX_BUSY_RETRY          2072
#define IDS_STATUS_FAX_NO_ANSWER_ABORT     2073
#define IDS_STATUS_FAX_NO_ANSWER_RETRY     2074
#define IDS_STATUS_FAX_RINGING             2075
#define IDS_STATUS_FAX_ANSWERED            2076
#define IDS_STATUS_FAX_NOT_FAX_CALL        2077
#define IDS_STATUS_FAX_SENDING             2078
#define IDS_STATUS_FAX_RECEIVING           2079
#define IDS_STATUS_FAX_FATAL_ERROR_ABORT   2080
#define IDS_STATUS_FAX_FATAL_ERROR_RETRY   2081
#define IDS_STATUS_FAX_FATAL_ERROR         2082
#define IDS_STATUS_FAX_ABORTING            2083
#define IDS_STATUS_FAX_COMPLETED           2084
#define IDS_STATUS_FAX_IDLE                2085
#define IDS_STATUS_FAXSVC_ENDED            2086
#define IDS_STATUS_DEVICE_POWERED_OFF      2087
#define IDS_STATUS_DEVICE_POWERED_ON       2088
#define IDS_STATUS_PORTS_NOT_AVAILABLE     2089
#define IDS_STATUS_UNEXPECTED_STATE        2090
#define IDS_NUM_PASSED                     2091
#define IDS_NUM_FAILED                     2092
#define IDS_NUM_TOTAL                      2093
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxrcv\faxrcv.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxrcv.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _FAXRCV_H
#define _FAXRCV_H

// FAXRCV_EXT_REGKEY is the FaxRcv Extension Registry key
#define FAXRCV_EXT_REGKEY            L"SOFTWARE\\Microsoft\\Fax\\Routing Extensions\\FaxRcv Routing Extension"
// BENABLE_EXT_REGVAL is the FaxRcv Extension bEnable Registry value
#define BENABLE_EXT_REGVAL           L"bEnable"
// BENABLE_EXT_REGDATA is the FaxRcv Extension bEnable Registry data
#define BENABLE_EXT_REGDATA          0
// FRIENDLYNAME_EXT_REGVAL is the FaxRcv Extension FriendlyName Registry value
#define FRIENDLYNAME_EXT_REGVAL      L"FriendlyName"
// FRIENDLYNAME_EXT_REGDATA is the FaxRcv Extension FriendlyName Registry data
#define FRIENDLYNAME_EXT_REGDATA     L"FaxRcv Routing Extension"
// IMAGENAME_EXT_REGVAL is the FaxRcv Extension ImageName Registry value
#define IMAGENAME_EXT_REGVAL         L"ImageName"



//IMAGENAME_EXT_REGDATA is the FaxRcv Extension ImageName Registry data
#define IMAGENAME_EXT_REGDATA        L"%SystemRoot%\\system32\\faxrcv.dll"

// ROUTINGMETHODS_REGKEY is the FaxRcv Routing Methods Registry key
#define ROUTINGMETHODS_REGKEY        L"Routing Methods"
// FAXRCV_METHOD_REGKEY is the FaxRcv Method Registry key
#define FAXRCV_METHOD_REGKEY         L"FaxRcv"
// FRIENDLYNAME_METHOD_REGVAL is the FaxRcv Method FriendlyName Registry value
#define FRIENDLYNAME_METHOD_REGVAL   L"FriendlyName"
// FRIENDLYNAME_METHOD_REGDATA is the FaxRcv Method FriendlyName Registry data
#define FRIENDLYNAME_METHOD_REGDATA  L"FaxRcv"
// FUNCTIONNAME_METHOD_REGVAL is the FaxRcv Method FunctionName Registry value
#define FUNCTIONNAME_METHOD_REGVAL   L"Function Name"
// FUNCTIONNAME_METHOD_REGDATA is the FaxRcv Method FunctionName Registry data
#define FUNCTIONNAME_METHOD_REGDATA  L"FaxRcv"
// GUID_METHOD_REGVAL is the FaxRcv Method Guid Registry value
#define GUID_METHOD_REGVAL           L"Guid"
// GUID_METHOD_REGDATA is the FaxRcv Method Guid Registry data
#define GUID_METHOD_REGDATA          L"{5800F650-B6B7-11D0-8CDB-00C04FB6BCE9}"
// PRIORITY_METHOD_REGVAL is the FaxRcv Method Priority Registry value
#define PRIORITY_METHOD_REGVAL       L"Priority"
// PRIORITY_METHOD_REGDATA is the FaxRcv Method Priority Registry data
#define PRIORITY_METHOD_REGDATA      5

// FAXRCV_EVENT is the name of the FaxRcv named event
#define FAXRCV_EVENT  L"FaxRcvEvent"
// FAXRCV_MUTEXT is the name of the FaxRcv named mutex
#define FAXRCV_MUTEX  L"FaxRcvMutex"
// FAXRCV_MAP is the name of the FaxRcv named memory map
#define FAXRCV_MAP    L"FaxRcvMap"

HANDLE  g_hFaxRcvEvent = NULL;  // g_hFaxRcvEvent is the handle to the FaxRcv named event
HANDLE  g_hFaxRcvMutex = NULL;  // g_hFaxRcvMutex is the handle to the FaxRcv named mutex

HANDLE  g_hFaxRcvMap = NULL;    // g_hFaxRcvMap is the handle to the FaxRcv memory map
LPBYTE  g_pFaxRcvView = NULL;   // g_pFaxRcvView is the pointer to the FaxRcv memory map view

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\faxvrfy.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxvrfy.c

Abstract:

  This module verifies the minimal functionality of the Windows XP Fax Service.

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#include <windows.h>
#include <stdlib.h>
#include <commctrl.h>
#include <shellapi.h>
#include <winfax.h>
#include <Shlwapi.h>

#include "faxrcv.h"
#include "faxvrfy.h"
#include "macros.h"
#include "macros.c"

#include "resource.h"

#include "startup.c"
#include "util.c"
#include "events.c"
#include "sndthrd.c"

// fnDialogProcSetup is the Setup Dialog Procedure
LRESULT CALLBACK fnDialogProcSetup (HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

VOID
fnUsageInfo(
    HWND  hWnd
)
/*++

Routine Description:

  Displays the usage info

Return Value:

  None

--*/
{
    // szHelpFile is the name of the help file
    WCHAR  szHelpFile[MAX_PATH];

    GetCurrentDirectory(sizeof(szHelpFile) / sizeof(WCHAR), szHelpFile);
    lstrcat(szHelpFile, L"\\");
    lstrcat(szHelpFile, FAXVRFY_HLP);

    WinHelp(hWnd, szHelpFile, HELP_FINDER, 0);
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    WNDCLASSEX          wndclass;
    MSG                 msg;

    // hMutex is the handle to the mutex
    HANDLE              hMutex;

    // argvW are the command line parameters
    LPWSTR              *argvW;
    // argc is the count of command line parameters
    INT                 argc;
    INT                 iIndex;

    // pFaxPortsConfigLocal is a pointer to the Fax Ports Configuration
    PFAX_PORT_INFO      pFaxPortsConfigLocal;
    // pFaxSvcConfigLocal is a pointer to the fax service configuration
    PFAX_CONFIGURATION  pFaxSvcConfigLocal;
    // hFaxPortHandle is the handle to a port
    HANDLE              hFaxPortHandle;
    DWORD               dwIndex;
    UINT                uRslt;

    // hFaxDevicesKey is the handle to the fax devices registry key
    HKEY                hFaxDevicesKey;
    // hFaxPortKey is the handle to the fax port registry key
    HKEY                hFaxPortKey;
    // szFaxPortKey is the name of the fax port registry key
    TCHAR               szFaxPortKey[15];
    // szFixModemClass is the modem class of the fax port
    LPWSTR              szFixModemClass;
    DWORD               cb;

	DWORD dwRes = 0;

    // szText is a text string
    WCHAR               szText[MAX_STRINGLEN + 2];

	//dwUserDevice is the deviceID the user chose to test
	DWORD dwUserDevice = 0;

	//bFoundDevice will be used to determine if the user specifd device exists in the system
	BOOL bFoundDevice = FALSE;
	
	// szIniFile is the ini file name
    WCHAR szIniFile[_MAX_PATH + 1];

	// szUserDeviceName is the device name the user chose to test
    WCHAR szUserDeviceName[_MAX_PATH + 1];


    // Set g_hInstance
    g_hInstance = hInstance;

    // Initialize the wndclass
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = fnDialogProcSetup;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = DLGWINDOWEXTRA;
    wndclass.hInstance = g_hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_WINLOGO);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_INACTIVEBORDER + 1);
    wndclass.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
    wndclass.lpszClassName = FAXVRFY_NAME;
    wndclass.hIconSm = LoadIcon(NULL, IDI_WINLOGO);

    // See if FaxVrfy is already running
    hMutex = CreateMutex(NULL, FALSE, FAXVRFY_NAME);
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        while (TRUE) {
            // Wait for access to the mutex
            WaitForSingleObject(hMutex, INFINITE);

            // Find the window
            g_hWndDlg = FindWindow(FAXVRFY_NAME, NULL);
            if (g_hWndDlg) {
                // Switch to that window
                ShowWindow(g_hWndDlg, SW_RESTORE);
                SetForegroundWindow(g_hWndDlg);
                // Release access to the mutex
                ReleaseMutex(hMutex);
                return 0;
            }

            // Release access to the mutex
            ReleaseMutex(hMutex);

            // See if FaxVrfy is still running
            CloseHandle(hMutex);
			hMutex = NULL;
            hMutex = CreateMutex(NULL, FALSE, FAXVRFY_NAME);
            if (GetLastError() == ERROR_SUCCESS) {
                break;
            }
        }
    }

    // Initialize the local mem
    MemInitializeMacro();

    // Set the default caption
    SetDefaultCaptionMacro(FAXVRFY_NAME);

    // Initialize the common controls
    InitCommonControls();

    argvW = CommandLineToArgvW(GetCommandLine(), &argc);
    for (iIndex = 0; iIndex < argc; iIndex++)
	{
        if ((!lstrcmpi(FAXVRFY_CMD_HELP_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_2, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_3, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_HELP_4, argvW[iIndex]))) {
            fnUsageInfo(NULL);
            return 0;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_BVT_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_BVT_2, argvW[iIndex]))) {
            g_bBVT = TRUE;
            g_bGo = FALSE;
            g_bNoCheck = FALSE;
            g_bRasAvailable = FALSE;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_SEND_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_SEND_2, argvW[iIndex]))) {
            g_bSend = TRUE;
        }
        else if ((!lstrcmpi(FAXVRFY_CMD_RECEIVE_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_RECEIVE_2, argvW[iIndex]))) {
            g_bSend = FALSE;
        }
        else if ((!g_bBVT) && ((!lstrcmpi(FAXVRFY_CMD_GO_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_GO_2, argvW[iIndex])))) {
            g_bGo = TRUE;
        }
        else if ((!g_bBVT) && ((!lstrcmpi(FAXVRFY_CMD_NO_CHECK_1, argvW[iIndex])) || (!lstrcmpi(FAXVRFY_CMD_NO_CHECK_2, argvW[iIndex])))) {
            g_bNoCheck = TRUE;
        }
		//
		//Check if user supplied a Device to use for faxing
		//
		else if (((!StrCmpNI(FAXVRFY_CMD_USE_DEVICE_1, argvW[iIndex],FAXVRFY_CMD_USE_DEVICE_SIZEOF)) || (!StrCmpNI(FAXVRFY_CMD_USE_DEVICE_2, argvW[iIndex],FAXVRFY_CMD_USE_DEVICE_SIZEOF))))
		{
            wcscpy(szUserDeviceName,argvW[iIndex]+FAXVRFY_CMD_USE_DEVICE_SIZEOF);

			//
			//Remove the "" if user specfied them
			//
			StrTrim(szUserDeviceName,L"\"");
		}
		
		
    }

    MemFreeMacro(argvW);

    // Initialize NTLog
    g_bNTLogAvailable = fnInitializeNTLog();

    // Start the log file
    fnStartLogFile();

    // Verify fax service is installed
    if (!fnIsFaxSvcInstalled())
	{
        if (!g_bBVT)
		{
            MessageBoxMacro(NULL, IDS_FAX_SVC_NOT_INSTALLED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_SVC_NOT_INSTALLED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable)
		{
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }
		goto ExitLevel0;
    }

    // Initialize FaxRcv
    uRslt = fnInitializeFaxRcv();
    if (uRslt) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, uRslt, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, uRslt, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel0;
    }

    if (!g_bBVT) {
        g_bRasAvailable = fnInitializeRas();
    }

    // Create the Start event
    g_hStartEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Stop event
    g_hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Exit event
    g_hExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Fax event
    g_hFaxEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the RAS Passed event
    g_hRasPassedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the RAS Failed event
    g_hRasFailedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Send Passed event
    g_hSendPassedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    // Create the Send Failed event
    g_hSendFailedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Connect to the Fax Service
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_CONNECT_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_CONNECT_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel1;
    }

    // Get the Fax Ports Configuration
    if (!FaxEnumPorts(g_hFaxSvcHandle, &g_pFaxPortsConfig, &g_dwNumPorts)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_ENUM_PORTS_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_ENUM_PORTS_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel2;
    }

    if (!g_dwNumPorts) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_PORTS_NOT_INSTALLED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_PORTS_NOT_INSTALLED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel3;
    }
    g_dwNumAvailPorts = g_dwNumPorts;

    // Get the Fax Ports Configuration
    if (!FaxEnumPorts(g_hFaxSvcHandle, &pFaxPortsConfigLocal, &g_dwNumPorts)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_ENUM_PORTS_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_ENUM_PORTS_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel3;
    }

    //
	// Disable all devices for faxing (first run of the enum)
	//
    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++)
	{
		g_pFaxPortsConfig[dwIndex].Flags = 0;

        if (!FaxOpenPort(g_hFaxSvcHandle, g_pFaxPortsConfig[dwIndex].DeviceId, PORT_OPEN_MODIFY, &hFaxPortHandle)) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, pFaxPortsConfigLocal[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            // Free the Fax Ports Configuration
            FaxFreeBuffer(pFaxPortsConfigLocal);
			pFaxPortsConfigLocal = NULL;
            goto ExitLevel4;
        }

        if (!FaxSetPort(hFaxPortHandle, (PFAX_PORT_INFO) &g_pFaxPortsConfig[dwIndex])) {
            FaxClose(hFaxPortHandle);
			hFaxPortHandle = NULL;
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, pFaxPortsConfigLocal[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            // Free the Fax Ports Configuration
            FaxFreeBuffer(pFaxPortsConfigLocal);
            pFaxPortsConfigLocal = NULL;
			goto ExitLevel4;
        }

        FaxClose(hFaxPortHandle);
		hFaxPortHandle = NULL;
    }


	//
	// Now we need to enable a device for faxing (due to PRO / PER limitation, we can only enable 1 device
	//
	if (1 == g_dwNumPorts)
	{
		//
		//we only have 1 device so this will be the device for testing
		//
		dwUserDevice=0;
	}
	else
	{
		//
		//we have more than 1 device, which should we choose?
		//Did the user supply a device name in the INI file?
		//

		//
		//Find user device in INI file
		//
		dwRes = GetCurrentDirectory(sizeof(szIniFile) / sizeof(WCHAR), szIniFile);
		if (0 == dwRes)
		{
			DebugMacro(L"GetCurrentDirectory failed with: %d\n", GetLastError());
			LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            // Free the Fax Ports Configuration
            FaxFreeBuffer(pFaxPortsConfigLocal);
            pFaxPortsConfigLocal = NULL;
			goto ExitLevel4;
		}

        lstrcat(szIniFile, L"\\");
        lstrcat(szIniFile, FAXVRFY_INI);

        //
		//Find out if user specifed a device to use
		//
		if (0 == lstrcmp(szUserDeviceName,L""))
		{
			//
			//No device was select
			//The test will select the first device by default
			//
			dwUserDevice=0;
		}
		else
		{
			//
			//Search if the device is found in the system
			//
			for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++)
			{
				if (0 == lstrcmp(szUserDeviceName,g_pFaxPortsConfig[dwIndex].DeviceName))
				{
					dwUserDevice= dwIndex;
					bFoundDevice=TRUE;
					break;
				}
			}
			if (FALSE == bFoundDevice)
			{
				//
				//User supplied device isn't found in the system, exit the test
				//
				if (!g_bBVT)
				{
					MessageBoxMacro(NULL, IDS_FAX_PORTS_NOT_INSTALLED, MB_ICONERROR, szUserDeviceName);
				}
				g_bTestFailed = TRUE;

				LoadString(g_hInstance, IDS_FAX_PORTS_NOT_INSTALLED, szText, MAX_STRINGLEN);
				lstrcat(szText, L"\r\n");
				fnWriteLogFile(TRUE, szText, szUserDeviceName);
				if (g_bNTLogAvailable) {
					g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, szUserDeviceName);
				}

				// Free the Fax Ports Configuration
				FaxFreeBuffer(pFaxPortsConfigLocal);
				pFaxPortsConfigLocal = NULL;
				goto ExitLevel4;
			}
		}
	}

	g_pFaxPortsConfig[dwUserDevice].Flags = FPF_RECEIVE | FPF_SEND;

    if (!FaxOpenPort(g_hFaxSvcHandle, g_pFaxPortsConfig[dwUserDevice].DeviceId, PORT_OPEN_MODIFY, &hFaxPortHandle)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwIndex].DeviceName);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
        lstrcat(szText, L"\r\n");
        fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwUserDevice].DeviceName);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwUserDevice].DeviceName);
        }

        // Free the Fax Ports Configuration
        FaxFreeBuffer(pFaxPortsConfigLocal);
        pFaxPortsConfigLocal = NULL;
		goto ExitLevel4;
    }

    if (!FaxSetPort(hFaxPortHandle, (PFAX_PORT_INFO) &g_pFaxPortsConfig[dwUserDevice]))
	{
        FaxClose(hFaxPortHandle);
		hFaxPortHandle = NULL;
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_SET_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwUserDevice].DeviceName);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_SET_PORT_FAILED, szText, MAX_STRINGLEN);
        lstrcat(szText, L"\r\n");
        fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwUserDevice].DeviceName);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwUserDevice].DeviceName);
        }

        // Free the Fax Ports Configuration
        FaxFreeBuffer(pFaxPortsConfigLocal);
        pFaxPortsConfigLocal = NULL;
		goto ExitLevel4;
    }

    FaxClose(hFaxPortHandle);
	hFaxPortHandle = NULL;


    // Free the Fax Ports Configuration
    FaxFreeBuffer(pFaxPortsConfigLocal);
	pFaxPortsConfigLocal = NULL;

    // Get the modem fax class
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXDEVICES_REGKEY, 0, KEY_ALL_ACCESS, &hFaxDevicesKey)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_OPEN_FAXDEVICES_REGKEY_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_OPEN_FAXDEVICES_REGKEY_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }
        goto ExitLevel4;
    }

    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++) {
        // Initialize the string representation of the DeviceId
        ZeroMemory(szFaxPortKey, sizeof(szFaxPortKey));
        // Set the string representation of the DeviceId
        wsprintf(szFaxPortKey, L"%08u", g_pFaxPortsConfig[dwIndex].DeviceId);
        lstrcat(szFaxPortKey, MODEM_REGKEY);

        szFixModemClass = NULL;
        if (!RegOpenKeyEx(hFaxDevicesKey, szFaxPortKey, 0, KEY_ALL_ACCESS, &hFaxPortKey)) {
            if (!RegQueryValueEx(hFaxPortKey, FIXMODEMCLASS_REGVALUE, NULL, NULL, NULL, &cb)) {
                if (cb) {
                    szFixModemClass = (LPWSTR)MemAllocMacro(cb);
                    if (RegQueryValueEx(hFaxPortKey, FIXMODEMCLASS_REGVALUE, NULL, NULL, (PBYTE) szFixModemClass, &cb)) {
                        MemFreeMacro(szFixModemClass);
                        szFixModemClass = NULL;
                    }
                    else if (!lstrcmp(L"", szFixModemClass)) {
                        MemFreeMacro(szFixModemClass);
                        szFixModemClass = NULL;
                    }
                }
            }

            RegCloseKey(hFaxPortKey);
			hFaxPortKey = NULL;
        }

        if (!szFixModemClass) {
            szFixModemClass = (LPWSTR)MemAllocMacro(2 * sizeof(WCHAR));
            lstrcpy(szFixModemClass, L"1");
        }

        LoadString(g_hInstance, IDS_FIXMODEMCLASS_DATA, szText, MAX_STRINGLEN);
        lstrcat(szText, L"\r\n");
        fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName, szFixModemClass);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName, szFixModemClass);
        }

        MemFreeMacro(szFixModemClass);
    }

    RegCloseKey(hFaxDevicesKey);
	hFaxDevicesKey = NULL;
    fnWriteLogFile(FALSE, L"\r\n");
    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
    }

    // Get the Fax Service Configuration
    if (!FaxGetConfiguration(g_hFaxSvcHandle, &g_pFaxSvcConfig)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_GET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_GET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel4;
    }

    // Get the Fax Service Configuration
    if (!FaxGetConfiguration(g_hFaxSvcHandle, &pFaxSvcConfigLocal)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_GET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_GET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel5;
    }

    // Set the Fax Service Configuration
    pFaxSvcConfigLocal->Retries = FAXSVC_RETRIES;
    pFaxSvcConfigLocal->RetryDelay = FAXSVC_RETRYDELAY;
    pFaxSvcConfigLocal->UseDeviceTsid = FALSE;
    if (!FaxSetConfiguration(g_hFaxSvcHandle, pFaxSvcConfigLocal)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_SET_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_SET_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        // Free the Fax Service Configuration
        FaxFreeBuffer(pFaxSvcConfigLocal);
        pFaxSvcConfigLocal = NULL;
		goto ExitLevel5;
    }

    // Free the Fax Service Configuration
    FaxFreeBuffer(pFaxSvcConfigLocal);
	pFaxSvcConfigLocal = NULL;

    // Create the completion port
    g_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
    // Initialize the Fax Event Queue
    if (!FaxInitializeEventQueue(g_hFaxSvcHandle, g_hCompletionPort, 0, NULL, 0)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_EVENT_QUEUE_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_EVENT_QUEUE_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }

        goto ExitLevel6;
    }

    // Create the Fax Event Queue thread
    CreateThread(NULL, 0, fnFaxEventQueueProc, NULL, 0, NULL);

    // Create the Send thread
    CreateThread(NULL, 0, fnSendProc, NULL, 0, NULL);

    if (g_bBVT) {
        wndclass.lpszMenuName = NULL;
    }

    RegisterClassEx(&wndclass);

    // Create the Setup Dialog
    g_hWndDlg = CreateDialog(g_hInstance, MAKEINTRESOURCE(IDD_SETUP), NULL, NULL);
    SendMessage(g_hWndDlg, UM_FAXVRFY_INITIALIZE, 0, 0);

    ShowWindow(g_hWndDlg, iCmdShow);
    UpdateWindow(g_hWndDlg);

    if ((g_bBVT) || (g_bGo)) {
        PostMessage(GetDlgItem(g_hWndDlg, IDC_START_BUTTON), BM_CLICK, 0, 0);
    }

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!IsDialogMessage(g_hWndDlg, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

ExitLevel6:
    if (g_hCompletionPort)
	{
        CloseHandle(g_hCompletionPort);
		g_hCompletionPort = NULL;
    }

    // Restore the Fax Service Configuration
    if (!FaxSetConfiguration(g_hFaxSvcHandle, g_pFaxSvcConfig)) {
        if (!g_bBVT) {
            MessageBoxMacro(NULL, IDS_FAX_RESTORE_CONFIG_FAILED, MB_ICONERROR);
        }
        g_bTestFailed = TRUE;

        LoadString(g_hInstance, IDS_FAX_RESTORE_CONFIG_FAILED, szText, MAX_STRINGLEN);
        fnWriteLogFile(TRUE, L"%s\r\n", szText);
        if (g_bNTLogAvailable) {
            g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, L"%s\r\n", szText);
        }
    }

ExitLevel5:
    // Free the Fax Service Configuration
    FaxFreeBuffer(g_pFaxSvcConfig);
	g_pFaxSvcConfig = NULL;

ExitLevel4:
    // Restore the Fax Ports Configuration
    for (dwIndex = 0; dwIndex < g_dwNumPorts; dwIndex++) {
        if (!FaxOpenPort(g_hFaxSvcHandle, g_pFaxPortsConfig[dwIndex].DeviceId, PORT_OPEN_MODIFY, &hFaxPortHandle)) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_RESTORE_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_RESTORE_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }

            continue;
        }

		//
		//Disable the receive and the send so this test will not disturb other HCT tests (NDIS, etc).
		//
		g_pFaxPortsConfig[dwIndex].Flags = 0;
        if (!FaxSetPort(hFaxPortHandle, &g_pFaxPortsConfig[dwIndex])) {
            if (!g_bBVT) {
                MessageBoxMacro(NULL, IDS_FAX_RESTORE_PORT_FAILED, MB_ICONERROR, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
            g_bTestFailed = TRUE;

            LoadString(g_hInstance, IDS_FAX_RESTORE_PORT_FAILED, szText, MAX_STRINGLEN);
            lstrcat(szText, L"\r\n");
            fnWriteLogFile(TRUE, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_SEV2 | TL_TEST, szText, g_pFaxPortsConfig[dwIndex].DeviceName);
            }
        }

        FaxClose(hFaxPortHandle);
		hFaxPortHandle = NULL;
    }

ExitLevel3:
    // Free the Fax Ports Configuration
    FaxFreeBuffer(g_pFaxPortsConfig);
	g_pFaxPortsConfig = NULL;

ExitLevel2:
    // Disconnect from the Fax Service
    FaxClose(g_hFaxSvcHandle);
	g_hFaxSvcHandle = NULL;

ExitLevel1:
    CloseHandle(g_hSendFailedEvent);
	g_hSendFailedEvent = NULL;
    
	CloseHandle(g_hSendPassedEvent);
	g_hSendPassedEvent = NULL;
    
	CloseHandle(g_hRasFailedEvent);
	g_hRasFailedEvent = NULL;
	
	CloseHandle(g_hRasPassedEvent);
	g_hRasPassedEvent = NULL;
    
	CloseHandle(g_hFaxEvent);
	g_hFaxEvent = NULL;

    CloseHandle(g_hExitEvent);
	g_hExitEvent = NULL;
    
	CloseHandle(g_hStopEvent);
	g_hStopEvent = NULL;
    
	CloseHandle(g_hStartEvent);
	g_hStartEvent = NULL;

    if (g_bRasAvailable)
	{
        FreeLibrary(g_RasApi.hInstance);
		g_RasApi.hInstance = NULL;
    }

ExitLevel0:
    fnWriteLogFile(FALSE, L"\r\n");
    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
    }

    if ((g_bTestFailed) || (g_dwNumTotal)) {
        if (g_dwNumTotal) {
            // Log the results
            LoadString(g_hInstance, IDS_NUM_PASSED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumPassed);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumPassed);
            }

            LoadString(g_hInstance, IDS_NUM_FAILED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumFailed);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumFailed);
            }

            LoadString(g_hInstance, IDS_NUM_TOTAL, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, szText, g_dwNumTotal);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, szText, g_dwNumTotal);
            }
        }

        if ((g_bTestFailed) || (g_dwNumFailed)) {
            fnWriteLogFile(FALSE, L"\r\n");
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
            }

            LoadString(g_hInstance, IDS_STATUS_TEST_FAILED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, L"%s\r\n", szText);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"%s\r\n", szText);
            }
        }
        else {
            fnWriteLogFile(FALSE, L"\r\n");
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"\r\n");
            }

            LoadString(g_hInstance, IDS_STATUS_TEST_PASSED, szText, MAX_STRINGLEN);
            fnWriteLogFile(FALSE, L"%s\r\n", szText);
            if (g_bNTLogAvailable) {
                g_NTLogApi.ptlLog(g_hLogFile, TLS_INFO | TL_TEST, L"%s\r\n", szText);
            }
        }
    }

    // Close the log file
    fnCloseLogFile();

    CloseHandle(hMutex);
	hMutex = NULL;

    return 0;
}

LRESULT CALLBACK fnDialogProcSetup (HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    // hWndStatusList is the handle to the Status List
    static HWND   hWndStatusList;
    // rcClient is the WindowRect of the Status List
    RECT          rcClient;
    // lvc specifies the attributes of a particular column of the Status List
    LV_COLUMN     lvc;
    // lvi specifies the attributes of a particular item of the Status List
    LV_ITEM       lvi;

    // szText is a text string
    WCHAR         szText[MAX_STRINGLEN + 1];
    // szFormatString is the format of the text string
    WCHAR         szFormatString[MAX_STRINGLEN + 1];
    // szRasError is the Ras error string
    WCHAR         szRasError[MAX_STRINGLEN + 1];

    // dwResourceId is the resource id
    DWORD         dwResourceId;
    // szDeviceName is the device name
    LPWSTR        szDeviceName;

    // szIniFile is the ini file name
    static WCHAR  szIniFile[_MAX_PATH + 1];

    // szMissingInfo is the missing info
    WCHAR         szMissingInfo[MAX_STRINGLEN + 1];
    // szMissingInfoError is the missing info error message
    WCHAR         szMissingInfoError[(MAX_STRINGLEN * 5) + 1];

    DWORD         dwStyle;
    DWORD         dwLevel;

    switch (iMsg) {
        case WM_CREATE:
            // Get the Rect of the Setup Dialog
            GetWindowRect(hWnd, &rcClient);
            if (!g_bBVT) {
                // Increase the bottom of the Setup Dialog Rect by the height of the menu
                rcClient.bottom += GetSystemMetrics(SM_CYMENU);
            }
            // Resize the Setup Dialog
            SetWindowPos(hWnd, NULL, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, SWP_NOMOVE | SWP_NOZORDER);
            break;

        case UM_FAXVRFY_INITIALIZE:
            CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | g_bSend ? MF_CHECKED : MF_UNCHECKED);
            CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | g_bSend ? MF_UNCHECKED : MF_CHECKED);

            // Limit the text length of edit controls
            SendMessage(GetDlgItem(hWnd, IDC_SEND_NUMBER), EM_SETLIMITTEXT, PHONE_NUM_LEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), EM_SETLIMITTEXT, PHONE_NUM_LEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_USER_NAME), EM_SETLIMITTEXT, UNLEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_PASSWORD), EM_SETLIMITTEXT, PWLEN, 0);
            SendMessage(GetDlgItem(hWnd, IDC_RAS_DOMAIN), EM_SETLIMITTEXT, DNLEN, 0);

            // Get the handle to the Status List
            hWndStatusList = GetDlgItem(hWnd, IDC_STATUS_LIST);
            // Get the Rect of the Status List
            GetWindowRect(hWndStatusList, &rcClient);

            // Set common attributes for each column
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;

            // Event Column
            // Load the Event Column text
            LoadString(g_hInstance, IDS_EVENT_LABEL, szText, MAX_STRINGLEN);
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 2 / 5 of the width of the Status List, allowing for the width of the borders and scroll bar
            lvc.cx = ((rcClient.right - rcClient.left - 4 * GetSystemMetrics(SM_CXBORDER) - GetSystemMetrics(SM_CXVSCROLL)) * 2) / 5;
            // Indicate this is the first column
            lvc.iSubItem = 0;
            // Insert column into Status List
            ListView_InsertColumn(hWndStatusList, 0, &lvc);

            // Port Column
            // Load the Port Column text
            LoadString(g_hInstance, IDS_PORT_LABEL, szText, MAX_STRINGLEN);
            // Set the column text
            lvc.pszText = szText;
            // Set the width of the column to be about 3 / 5 of the width of the Status List, allowing for the width of the borders and scroll bar
            lvc.cx = (lvc.cx * 3) / 2;
            // Indicate this is the second column
            lvc.iSubItem = 1;
            // Insert column into Status List
            ListView_InsertColumn(hWndStatusList, 1, &lvc);

            // Disable the Stop Button
            EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);

            // Get the current directory
            GetCurrentDirectory(sizeof(szIniFile) / sizeof(WCHAR), szIniFile);
            // Set the ini file name
            lstrcat(szIniFile, L"\\");
            lstrcat(szIniFile, FAXVRFY_INI);

            // Get the strings from the ini file
            GetPrivateProfileString(L"Fax", L"SendNumber", L"", g_szSndNumber, sizeof(g_szSndNumber), szIniFile);
            if (fnIsStringASCII(g_szSndNumber)) {
                SetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber);
            }
            else {
                ZeroMemory(g_szSndNumber, sizeof(g_szSndNumber));
            }
            GetPrivateProfileString(L"Fax", L"ReceiveNumber", L"", g_szRcvNumber, sizeof(g_szRcvNumber), szIniFile);
            if (fnIsStringASCII(g_szRcvNumber)) {
                SetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber);
            }
            else {
                ZeroMemory(g_szRcvNumber, sizeof(g_szRcvNumber));
            }

            if (g_bRasAvailable) {
                if (GetPrivateProfileInt(L"RAS", L"Enabled", 0, szIniFile)) {
                    // Click the Fax Send check button
                    SendMessage(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), BM_CLICK, 0, 0);
                }
            }
            GetPrivateProfileString(L"RAS", L"UserName", L"", g_szRasUserName, sizeof(g_szRasUserName), szIniFile);
            SetDlgItemText(hWnd, IDC_RAS_USER_NAME, g_szRasUserName);
            ZeroMemory(g_szRasPassword, sizeof(g_szRasPassword));
            GetPrivateProfileString(L"RAS", L"Domain", L"", g_szRasDomain, sizeof(g_szRasDomain), szIniFile);
            SetDlgItemText(hWnd, IDC_RAS_DOMAIN, g_szRasDomain);

            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            return 0;

        case UM_FAXVRFY_RESET:
            // Enable or disable the Fax specific controls
            EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER_STATIC), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER_STATIC), (!wParam && g_bSend) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), (!wParam && g_bSend) ? TRUE : FALSE);

            // Enable the RAS specific controls
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), (!wParam && g_bSend && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);
            EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), (!wParam && g_bSend && g_bRasEnabled && g_bRasAvailable) ? TRUE : FALSE);

            if (wParam) {
                // Disable the Start Button
                EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), FALSE);
                // Disable the Stop Button
                EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);
                // Enable the Exit Button
                EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), TRUE);

                // Disable the Option Menu
                EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_GRAYED);

                // Set the focus to the Exit button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_EXIT_BUTTON), MAKELONG(TRUE, 0));
            }
            else {
                // Enable the Start Button
                EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), TRUE);
                // Disable the Stop Button
                EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), FALSE);
                // Enable the Exit Button
                EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), TRUE);

                // Enable the Option Menu
                EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_ENABLED);
                EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_ENABLED);

                // Set the focus to the Start button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_START_BUTTON), MAKELONG(TRUE, 0));
            }
            return 0;

        case UM_TIMEOUT_ENDED:
        case UM_FAXSVC_ENDED:
            g_bTestFailed = TRUE;

            if (iMsg == UM_TIMEOUT_ENDED) {
                // Update the status
                SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_TIMEOUT_ENDED, 0);
            }
            else if (iMsg == UM_FAXSVC_ENDED) {
                // Post a completion packet to a completion port to exit the Fax Event Queue thread
                fnPostExitToCompletionPort(g_hCompletionPort);
                // Update the status
                SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_FAXSVC_ENDED, 0);
            }

            if ((!IsWindowEnabled(GetDlgItem(hWnd, IDC_START_BUTTON))) && (g_bSend)) {
                // Update the status
                SendMessage(hWnd, UM_ITERATION_FAILED, 0, 0);
            }

            SendMessage(hWnd, UM_FAXVRFY_RESET, 1, 0);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_ITERATION_STOPPED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_STOPPED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            return 0;

        case UM_ITERATION_PASSED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_PASSED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            // Update the iterations
            g_dwNumPassed++;
            g_dwNumTotal++;
            SetDlgItemInt(hWnd, IDC_NUM_PASSED, g_dwNumPassed, FALSE);
            SetDlgItemInt(hWnd, IDC_NUM_TOTAL, g_dwNumTotal, FALSE);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_ITERATION_FAILED:
            // Update the status
            SendMessage(hWnd, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_FAILED, 0);
            SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);

            // Update the iterations
            g_dwNumFailed++;
            g_dwNumTotal++;
            SetDlgItemInt(hWnd, IDC_NUM_FAILED, g_dwNumFailed, FALSE);
            SetDlgItemInt(hWnd, IDC_NUM_TOTAL, g_dwNumTotal, FALSE);

            if (g_bBVT) {
                SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
            }

            return 0;

        case UM_UPDATE_STATUS:
            dwStyle = TLS_INFO;
            dwLevel = TLS_VARIATION;

            // Get the resource id
            dwResourceId = (DWORD) wParam;

            // Load the event text
            LoadString(g_hInstance, dwResourceId, szFormatString, MAX_STRINGLEN);

            // Set the event text
            lstrcpy(szText, szFormatString);
            szDeviceName = NULL;

            switch (wParam) {
                case IDS_STATUS_ITERATION_PASSED:
                    dwStyle = TLS_PASS;
                    break;

                case IDS_STATUS_ITERATION_FAILED:
                    dwStyle = TLS_SEV2;
                    break;

                case IDS_STATUS_TEST_PASSED:
                    dwStyle = TLS_PASS;
                    dwLevel = TL_TEST;
                    break;

                case IDS_STATUS_RAS_FAILED:
                case IDS_STATUS_TIMEOUT_ENDED:
                case IDS_STATUS_FAX_SEND_FAILED:
                case IDS_STATUS_FAX_INVALID:
                case IDS_TIFF_INVALID_TIFF:
                case IDS_TIFF_INVALID_IMAGEWIDTH:
                case IDS_TIFF_INVALID_IMAGELENGTH:
                case IDS_TIFF_INVALID_COMPRESSION:
                case IDS_TIFF_INVALID_PHOTOMETRIC:
                case IDS_TIFF_INVALID_XRESOLUTION:
                case IDS_TIFF_INVALID_YRESOLUTION:
                case IDS_TIFF_INVALID_SOFTWARE:
                case IDS_TIFF_INVALID_PAGES:
                case IDS_STATUS_FAX_NO_DIAL_TONE_ABORT:
                case IDS_STATUS_FAX_BUSY_ABORT:
                case IDS_STATUS_FAX_NO_ANSWER_ABORT:
                case IDS_STATUS_FAX_FATAL_ERROR_ABORT:
                    dwStyle = TLS_SEV2;
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    dwStyle = TLS_SEV2;
                    dwLevel = TL_TEST;
                    break;

                case IDS_STATUS_RAS_SPEED_SUSPECT:
                case IDS_STATUS_FAX_NO_DIAL_TONE_RETRY:
                case IDS_STATUS_FAX_BUSY_RETRY:
                case IDS_STATUS_FAX_NO_ANSWER_RETRY:
                case IDS_STATUS_FAX_FATAL_ERROR_RETRY:
                case IDS_STATUS_FAX_FATAL_ERROR:
                case IDS_STATUS_FAX_ABORTING:
                    dwStyle = TLS_WARN;
                    break;

                case IDS_STATUS_DEVICE_POWERED_OFF:
                case IDS_STATUS_DEVICE_POWERED_ON:
                case IDS_STATUS_PORTS_NOT_AVAILABLE:
                case IDS_STATUS_UNEXPECTED_STATE:
                    dwStyle = TLS_WARN;
                    dwLevel = TL_TEST;
                    break;
            }

            switch (wParam) {
                case IDS_TIFF_INVALID_PAGES:
                    // Set the event text
                    wsprintf(szText, szFormatString, (DWORD) lParam, g_bBVT ? FAXBVT_PAGES : FAXWHQL_PAGES);
                    break;

                case IDS_STATUS_RAS_STARTING:
                case IDS_STATUS_FAX_STARTING:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);
                    break;

                case IDS_STATUS_RAS_LINESPEED:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PRAS_INFO) lParam)->dwBps);

                    // Find the device name
                    szDeviceName = ((PRAS_INFO) lParam)->szDeviceName;
                    break;

                case IDS_STATUS_RAS_SPEED_SUSPECT:
                    // Set the exent text
                    wsprintf(szText, szFormatString, (DWORD) lParam);
                    break;

                case IDS_STATUS_RAS_FAILED:
                    // Initialize szRasError
                    ZeroMemory(szRasError, sizeof(szRasError));
                    if (lParam) {
                        g_RasApi.RasGetErrorString((DWORD) lParam, szRasError, sizeof(szRasError) / sizeof(WCHAR));
                    }

                    // Set the event text
                    wsprintf(szText, szFormatString, szRasError);
                    break;

                case IDS_STATUS_FAX_DIALING:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PFAX_DIALING_INFO) lParam)->dwAttempt);

                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, ((PFAX_DIALING_INFO) lParam)->dwDeviceId, &szDeviceName);
                    break;

                case IDS_STATUS_FAX_RECEIVED:
                    // Set the event text
                    wsprintf(szText, szFormatString, ((PFAX_RECEIVE_INFO) lParam)->szCopyTiffName);

                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, ((PFAX_RECEIVE_INFO) lParam)->dwDeviceId, &szDeviceName);

                    break;

                case IDS_STATUS_FAX_ID:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);

                    break;

                case IDS_STATUS_FAX_VERIFYING:
                    // Set the event text
                    wsprintf(szText, szFormatString, (LPWSTR) lParam);
                    break;

                default:
                    // Find the device name
                    fnFindDeviceName(g_pFaxPortsConfig, g_dwNumPorts, (DWORD) lParam, &szDeviceName);
                    break;
            }

            // Indicate only pszText is valid
            lvi.mask = LVIF_TEXT;

            // Set the Event text
            lvi.pszText = szText;
            // Set the item number
            lvi.iItem = ListView_GetItemCount(hWndStatusList);
            // Indicate this is the first column
            lvi.iSubItem = 0;
            // Insert item into Status List
            ListView_InsertItem(hWndStatusList, &lvi);

            // Set the Port text
            lvi.pszText = szDeviceName;
            // Indicate this is the second column
            lvi.iSubItem = 1;
            // Set item in Status List
            ListView_SetItem(hWndStatusList, &lvi);

            if (szDeviceName) {
                DebugMacro(L"%s: %s\n", szDeviceName, szText);
            }
            else {
                DebugMacro(L"%s\n", szText);
            }

            if (szDeviceName) {
                fnWriteLogFile(TRUE, L"%s: %s\r\n", szDeviceName, szText);
            }
            else {
                fnWriteLogFile(TRUE, L"%s\r\n", szText);
            }

            if (g_bNTLogAvailable) {
                if (szDeviceName) {
                    switch (dwLevel) {
                        case TLS_TEST:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_TEST, L"%s: %s\r\n", szDeviceName, szText);
                            break;

                        case TLS_VARIATION:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_VARIATION, L"%s: %s\r\n", szDeviceName, szText);
                            break;
                    }
                }
                else {
                    switch (dwLevel) {
                        case TLS_TEST:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_TEST, L"%s\r\n", szText);
                            break;

                        case TLS_VARIATION:
                            g_NTLogApi.ptlLog(g_hLogFile, dwStyle | TL_VARIATION, L"%s\r\n", szText);
                            break;
                    }
                }
            }

            // Scroll the Status List
            ListView_EnsureVisible(hWndStatusList, lvi.iItem, FALSE);
            return 0;

        case WM_SETFOCUS:
            // Verify correct control has the focus
            if ((!IsWindowEnabled(GetDlgItem(hWnd, IDC_STOP_BUTTON))) && (SendMessage(GetDlgItem(hWnd, IDC_STOP_BUTTON), WM_GETDLGCODE, 0, 0) & DLGC_DEFPUSHBUTTON)) {
                // Set the focus to the start button
                SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_START_BUTTON), MAKELONG(TRUE, 0));
            }

            break;

        case WM_CLOSE:
            if (IsWindowEnabled(GetDlgItem(hWnd, IDC_EXIT_BUTTON))) {
                // Signal the Exit event
                SetEvent(g_hExitEvent);
                // Post a completion packet to a completion port to exit the Fax Event Queue thread
                fnPostExitToCompletionPort(g_hCompletionPort);
                // Close the application
                DestroyWindow(hWnd);
                PostQuitMessage(0);
            }
            return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDM_SEND:
                    if (!g_bSend) {
                        g_bSend = TRUE;
                        CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_CHECKED);
                        CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_UNCHECKED);
                        SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);
                    }
                    return 0;

                case IDM_RECEIVE:
                    if (g_bSend) {
                        g_bSend = FALSE;
                        CheckMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_UNCHECKED);
                        CheckMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_CHECKED);
                        SendMessage(hWnd, UM_FAXVRFY_RESET, 0, 0);
                    }
                    return 0;

                case IDM_HELP:
                    fnUsageInfo(hWnd);
                    return 0;

                case IDC_SEND_NUMBER:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        if (!fnIsEditControlASCII(hWnd, IDC_SEND_NUMBER, PHONE_NUM_LEN + 1)) {
                            // Load the error text
                            LoadString(g_hInstance, IDS_ASCII_SEND_NUMBER, szText, MAX_STRINGLEN);
                            // Display the pop-up
                            MessageBox(hWnd, szText, FAXVRFY_NAME, MB_OK | MB_ICONERROR);

                            SetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber);
                        }

                        GetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber, PHONE_NUM_LEN + 1);
                    }
                    return 0;

                case IDC_RECEIVE_NUMBER:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        if (!fnIsEditControlASCII(hWnd, IDC_RECEIVE_NUMBER, PHONE_NUM_LEN + 1)) {
                            // Load the error text
                            LoadString(g_hInstance, IDS_ASCII_RECEIVE_NUMBER, szText, MAX_STRINGLEN);
                            // Display the pop-up
                            MessageBox(hWnd, szText, FAXVRFY_NAME, MB_OK | MB_ICONERROR);

                            SetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber);
                        }

                        GetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber, PHONE_NUM_LEN + 1);
                    }
                    return 0;

                case IDC_RAS_ENABLED_BUTTON:
                    // RAS Enabled Check Box was clicked
                    g_bRasEnabled = IsDlgButtonChecked(hWnd, IDC_RAS_ENABLED_BUTTON);
                    // Enable or disable the RAS specific controls
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), g_bRasEnabled ? TRUE : FALSE);
                    EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), g_bRasEnabled ? TRUE : FALSE);
                    return 0;

                case IDC_START_BUTTON:
                    if (g_bSend) {
                        // Initialize szMissingInfoError
                        ZeroMemory(szMissingInfoError, sizeof(szMissingInfoError));

                        // Get send phone number
                        GetDlgItemText(hWnd, IDC_SEND_NUMBER, g_szSndNumber, PHONE_NUM_LEN + 1);
                        // Get receive phone number
                        GetDlgItemText(hWnd, IDC_RECEIVE_NUMBER, g_szRcvNumber, PHONE_NUM_LEN + 1);

                        // See if RAS is enabled
                        g_bRasEnabled = IsDlgButtonChecked(hWnd, IDC_RAS_ENABLED_BUTTON);
                        // Get RAS user name
                        GetDlgItemText(hWnd, IDC_RAS_USER_NAME, g_szRasUserName, UNLEN + 1);
                        // Get RAS password
                        GetDlgItemText(hWnd, IDC_RAS_PASSWORD, g_szRasPassword, PWLEN + 1);
                        // Get RAS domain
                        GetDlgItemText(hWnd, IDC_RAS_DOMAIN, g_szRasDomain, DNLEN + 1);

                        if (!lstrlen(g_szSndNumber)) {
                            // There is no send phone number
                            LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                            LoadString(g_hInstance, IDS_NO_SEND_NUMBER, szMissingInfo, MAX_STRINGLEN);
                            lstrcat(szMissingInfoError, szMissingInfo);
                        }

                        if (!lstrlen(g_szRcvNumber)) {
                            // There is no receive phone number
                            if (lstrlen(szMissingInfoError)) {
                                lstrcat(szMissingInfoError, L"\n");
                            }
                            else {
                                LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                            }
                            LoadString(g_hInstance, IDS_NO_RECEIVE_NUMBER, szMissingInfo, MAX_STRINGLEN);
                            lstrcat(szMissingInfoError, szMissingInfo);
                        }

                        if (g_bRasEnabled) {
                            if (!lstrlen(g_szRasUserName)) {
                                // There is no RAS user name
                                if (lstrlen(szMissingInfoError)) {
                                    lstrcat(szMissingInfoError, L"\n");
                                }
                                else {
                                    LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                                }
                                LoadString(g_hInstance, IDS_NO_RAS_USER_NAME, szMissingInfo, MAX_STRINGLEN);
                                lstrcat(szMissingInfoError, szMissingInfo);
                            }

                            if (!lstrlen(g_szRasDomain)) {
                                // There is no RAS domain
                                if (lstrlen(szMissingInfoError)) {
                                    lstrcat(szMissingInfoError, L"\n");
                                }
                                else {
                                    LoadString(g_hInstance, IDS_MISSING_INFO, szMissingInfoError, MAX_STRINGLEN);
                                }
                                LoadString(g_hInstance, IDS_NO_RAS_DOMAIN, szMissingInfo, MAX_STRINGLEN);
                                lstrcat(szMissingInfoError, szMissingInfo);
                            }
                        }

                        if (lstrlen(szMissingInfoError)) {
                            // Display the missing info error pop-up
                            MessageBox(hWnd, szMissingInfoError, FAXVRFY_NAME, MB_OK | MB_ICONERROR);
                            return 0;
                        }

                        // Disable the Fax specific controls
                        EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_SEND_NUMBER), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RECEIVE_NUMBER_STATIC), FALSE);

                        // Disable the RAS specific controls
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_ENABLED_BUTTON), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_USER_NAME), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_PASSWORD), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN_STATIC), FALSE);
                        EnableWindow(GetDlgItem(hWnd, IDC_RAS_DOMAIN), FALSE);

                        // Set the strings to the ini file
                        WritePrivateProfileString(L"Fax", L"SendNumber", g_szSndNumber, szIniFile);
                        WritePrivateProfileString(L"Fax", L"ReceiveNumber", g_szRcvNumber, szIniFile);
                        WritePrivateProfileString(L"RAS", L"Enabled", g_bRasEnabled ? L"1" : L"0", szIniFile);
                        WritePrivateProfileString(L"RAS", L"UserName", g_szRasUserName, szIniFile);
                        WritePrivateProfileString(L"RAS", L"Domain", g_szRasDomain, szIniFile);
                    }

                    // Disable the Option Menu
                    EnableMenuItem(GetMenu(hWnd), IDM_SEND, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem(GetMenu(hWnd), IDM_RECEIVE, MF_BYCOMMAND | MF_GRAYED);

                    // Disable the Start Button
                    EnableWindow(GetDlgItem(hWnd, IDC_START_BUTTON), FALSE);
                    // Enable the Stop Button
                    EnableWindow(GetDlgItem(hWnd, IDC_STOP_BUTTON), TRUE);
                    // Disable the Exit Button
                    EnableWindow(GetDlgItem(hWnd, IDC_EXIT_BUTTON), FALSE);

                    // Set the focus to the Stop button
                    SendMessage(hWnd, WM_NEXTDLGCTL, (WPARAM) GetDlgItem(hWnd, IDC_STOP_BUTTON), MAKELONG(TRUE, 0));

                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_ITERATION_STARTED, 0);

                    // Signal the Start event
                    SetEvent(g_hStartEvent);
                    return 0;

                case IDC_STOP_BUTTON:
                    // Signal the Stop event
                    SetEvent(g_hStopEvent);
                    return 0;

                case IDC_EXIT_BUTTON:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    return 0;
            }
    }

    return DefDlgProc(hWnd, iMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxrcv\faxrcv.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxrcv.c

Abstract:

  Window NT Fax Routing Extension.  This routing method signals a named event.

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#include <windows.h>
#include <stdlib.h>
#include <winfax.h>
#include <faxroute.h>

#include "faxrcv.h"

PFAXROUTEGETFILE  g_pFaxRouteGetFile;  // g_pFaxRouteGetFile is the pointer to callback to get file from fax file list

DWORD
DllEntry(
    HINSTANCE  hInstance,
    DWORD      dwReason,
    LPVOID     pContext
)
/*++

Routine Description:

  DLL entry point

Arguments:

  hInstance - handle to the module
  dwReason - indicates the reason for being called
  pContext - context

Return Value:

  TRUE on success

--*/
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            if (!g_hFaxRcvEvent) {
                // Create FaxRcv named event
                g_hFaxRcvEvent = CreateEvent(NULL, FALSE, FALSE, FAXRCV_EVENT);
            }

            if (!g_hFaxRcvMutex) {
                // Create FaxRcv named mutex
                g_hFaxRcvMutex = CreateMutex(NULL, FALSE, FAXRCV_MUTEX);
            }

            break;

        case DLL_PROCESS_DETACH:
            if (g_hFaxRcvMutex) {
                // Wait for access to the FaxRcv named mutex
                WaitForSingleObject(g_hFaxRcvMutex, INFINITE);

                // Reset FaxRcv named event
                ResetEvent(g_hFaxRcvEvent);

                // Close FaxRcv named event
                CloseHandle(g_hFaxRcvEvent);
                g_hFaxRcvEvent = NULL;

                if (g_pFaxRcvView) {
                    // Delete szCopyTiffFile
                    DeleteFile((LPWSTR) g_pFaxRcvView);
                    // Close FaxRcv memory map view
                    UnmapViewOfFile(g_pFaxRcvView);
                    g_pFaxRcvView = NULL;
                }

                if (g_hFaxRcvMap) {
                    // Close FaxRcv memory map
                    CloseHandle(g_hFaxRcvMap);
                    g_hFaxRcvMap = NULL;
                }

                // Release access to the FaxRcv named mutex
                ReleaseMutex(g_hFaxRcvMutex);

                // Close FaxRcv named mutex
                CloseHandle(g_hFaxRcvMutex);
                g_hFaxRcvMutex = NULL;
            }

            break;
    }

    return TRUE;
}

BOOL WINAPI
FaxRouteInitialize(
    HANDLE                       hHeap,
    PFAX_ROUTE_CALLBACKROUTINES  pFaxRouteCallbackRoutines
)
/*++

Routine Description:

  Initializes the routing extension

Arguments:

  hHeap - handle to the heap
  pFaxRouteCallbackRoutins - pointer to fax routing callback routines

Return Value:

  TRUE on success

--*/
{
    // Set g_pFaxRouteGetFile
    g_pFaxRouteGetFile = pFaxRouteCallbackRoutines->FaxRouteGetFile;

    return TRUE;
}

BOOL WINAPI
FaxRouteGetRoutingInfo(
    LPCWSTR  RoutingGuid,
    DWORD    dwDeviceId,
    LPBYTE   RoutingInfo,
    LPDWORD  pdwRoutingInfoSize
)
/*++

Routine Description:

  Gets the routing info for a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  RoutingInfo - pointer to the routing info
  pdwRoutingInfoSize - pointer to the size of the routing info

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteSetRoutingInfo(
    LPCWSTR     RoutingGuid,
    DWORD       dwDeviceId,
    BYTE const  *RoutingInfo,
    DWORD       dwRoutingInfoSize
)
/*++

Routine Description:

  Sets the routing info for a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  RoutingInfo - pointer to the routing info
  dwRoutingInfoSize - size of the routing info

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteDeviceEnable(
    LPCWSTR  RoutingGuid,
    DWORD    dwDeviceId,
    LONG     bEnable
)
/*++

Routine Description:

  Enables a routing method

Arguments:

  RoutingGuid - pointer to the GUID of the routing method
  dwDeviceId - port id
  bEnable - indicates whether the routing method is enabled or disabled

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    DWORD  dwDeviceId,
    BOOL   bNewDevice
)
/*++

Routine Description:

  Handles a device change

Arguments:

  dwDeviceId - port id
  bNewDevice - indicates whether the device is new

Return Value:

  TRUE on success

--*/
{
    return TRUE;
}

BOOL WINAPI
FaxRcv(
    PFAX_ROUTE  pFaxRoute,
    PVOID       *FailureData,
    LPDWORD     pdwFailureDataSize
)
/*++

Routine Description:

  Routing method.  This routing method signals a named event.

Arguments:

  pFaxRoute - pointer to the fax routing structure
  FailureData - pointer to the failure data
  pdwFailureDataSize - size of the failure data

Return Value:

  TRUE on success

--*/
{
    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY      hFaxRcvExtKey;
    // bEnable indicates whether the Routing method is enabled
    BOOL      bEnable;

    // szTiffFile is the name of the received fax
    WCHAR     szTiffFile[_MAX_PATH];
    // szCopyTiffFile is the name of the copy of the received fax
    WCHAR     szCopyTiffFile[_MAX_PATH];

    // szDrive is the drive of the received fax
    WCHAR     szDrive[_MAX_DRIVE];
    // szDir is the dir of the received fax
    WCHAR     szDir[_MAX_DIR];
    // szFile is the name of the received fax
    WCHAR     szFile[_MAX_FNAME];
    // szExt is the extension of the received fax
    WCHAR     szExt[_MAX_EXT];

    UINT_PTR  upOffset;
    DWORD     cb;

    // Wait for access to the FaxRcv named mutex
    WaitForSingleObject(g_hFaxRcvMutex, INFINITE);

    // Open the FaxRcv Extension Registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRcvExtKey) != ERROR_SUCCESS) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Set cb
    cb = sizeof(BOOL);
    // Query the FaxRcv Extension bEnable Registry value
    if (RegQueryValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, NULL, NULL, (LPBYTE) &bEnable, &cb) != ERROR_SUCCESS) {
        // Close the FaxRcv Extension Registry key
        RegCloseKey(hFaxRcvExtKey);
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);

    if (!bEnable) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return TRUE;
    }

    // Set cb
    cb = sizeof(szTiffFile);
    // Initialize szTiffFile
    ZeroMemory(szTiffFile, cb);

    // Get the file
    if (!g_pFaxRouteGetFile(pFaxRoute->JobId, 1, szTiffFile, &cb)) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(g_hFaxRcvMutex);
        return FALSE;
    }

    // Initialize szDrive
    ZeroMemory(szDrive, sizeof(szDrive));
    // Initialize szDir
    ZeroMemory(szDir, sizeof(szDir));
    // Initialize szFile
    ZeroMemory(szFile, sizeof(szFile));
    // Initialize szExt
    ZeroMemory(szExt, sizeof(szExt));

    _wsplitpath(szTiffFile, szDrive, szDir, szFile, szExt);

    // Initialize szCopyTiffFile
    ZeroMemory(szCopyTiffFile, sizeof(szCopyTiffFile));
    // Set szCopyTiffFile
    wsprintf(szCopyTiffFile, L"%s%s%s%s%s", szDrive, szDir, L"Copy of ", szFile, szExt);

    // Copy szTiffFile to szCopyTiffFile
    CopyFile(szTiffFile, szCopyTiffFile, FALSE);

    // Determine the memory required by FaxRcv memory map
    cb = (lstrlen(szCopyTiffFile) + 1) * sizeof(WCHAR);
    cb += (lstrlen(pFaxRoute->Tsid) + 1) * sizeof(WCHAR);
    cb += sizeof(DWORD);

    if (g_pFaxRcvView) {
        // Delete szCopyTiffFile
        DeleteFile((LPWSTR) g_pFaxRcvView);
        // Close FaxRcv memory map view
        UnmapViewOfFile(g_pFaxRcvView);
    }
    if (g_hFaxRcvMap) {
        // Close FaxRcv memory map
        CloseHandle(g_hFaxRcvMap);
    }

    // Create FaxRcv memory map
    g_hFaxRcvMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, cb, FAXRCV_MAP);
    // Create FaxRcv memory map view
    g_pFaxRcvView = (LPBYTE) MapViewOfFile(g_hFaxRcvMap, FILE_MAP_WRITE, 0, 0, 0);

    // Set upOffset
    upOffset = 0;

    // Set szCopyTiffFile
    lstrcpy((LPWSTR) ((UINT_PTR) g_pFaxRcvView + upOffset), szCopyTiffFile);
    upOffset += (lstrlen(szCopyTiffFile) + 1) * sizeof(WCHAR);

    // Set Tsid
    lstrcpy((LPWSTR) ((UINT_PTR) g_pFaxRcvView + upOffset), pFaxRoute->Tsid);
    upOffset += (lstrlen(pFaxRoute->Tsid) + 1) * sizeof(WCHAR);

    // Set DeviceId
    CopyMemory((LPDWORD) ((UINT_PTR) g_pFaxRcvView + upOffset), &pFaxRoute->DeviceId, sizeof(DWORD));

    // Signal FaxRcv named event
    SetEvent(g_hFaxRcvEvent);

    // Release access to the FaxRcv named mutex
    ReleaseMutex(g_hFaxRcvMutex);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\events.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  events.c

Abstract:

  This module:
    1) Determines if the port is valid
    2) Post a completion packet to a completion port.  This packet indicates for the Fax Event Queue thread to exit.
    3) Thread to handle the Fax Event Queue logic

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _EVENTS_C
#define _EVENTS_C

BOOL
fnIsPortValid(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumPorts,
    DWORD           dwDeviceId
)
/*++

Routine Description:

  Determines if the port is valid

Arguments:

  pFaxPortsConfig - pointer to the ports configuration
  dwNumFaxPorts - number of ports
  dwDeviceId - port id

Return Value:

  TRUE on success

--*/
{
    // dwIndex is a counter to enumerate each port
    DWORD  dwIndex;

    for (dwIndex = 0; dwIndex < dwNumPorts; dwIndex++) {
        // Search, by priority, each port for the appropriate port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
fnPostExitToCompletionPort(
    HANDLE  hCompletionPort
)
/*++

Routine Description:

  Post a completion packet to a completion port.  This packet indicates for the Fax Event Queue thread to exit.

Arguments:

  hCompletionPort - handle to the completion port

Return Value:

  None

--*/
{
    PFAX_EVENT  pFaxEvent;

    pFaxEvent = (PFAX_EVENT)LocalAlloc(LPTR, sizeof(FAX_EVENT));
    pFaxEvent->EventId = -1;

    PostQueuedCompletionStatus(hCompletionPort, sizeof(FAX_EVENT), 0, (LPOVERLAPPED) pFaxEvent);
}

DWORD WINAPI fnFaxEventQueueProc (LPVOID lpv)
/*++

Routine Description:

  Thread to handle the Fax Event Queue logic

Return Value:

  DWORD - exit code

--*/
{
    // pFaxEvent is a pointer to the port event
    PFAX_EVENT        pFaxEvent;
    DWORD             dwBytes;
    ULONG_PTR          upCompletionKey;

    // FaxDialingInfo is the fax dialing info
    FAX_DIALING_INFO  FaxDialingInfo;

    // bFaxPassed indicates a fax passed
    BOOL              bFaxPassed = FALSE;
    // bFaxFailed indicates a fax failed
    BOOL              bFaxFailed = FALSE;
    // dwDeviceId is the port id
    DWORD             dwDeviceId = 0;

    while (GetQueuedCompletionStatus(g_hCompletionPort, &dwBytes, &upCompletionKey, (LPOVERLAPPED *) &pFaxEvent, INFINITE)) {

        if (pFaxEvent->EventId == -1) {
            // g_hExitEvent was signaled, so thread should exit
            LocalFree(pFaxEvent);
			pFaxEvent = NULL;
            break;
        }

        if (pFaxEvent->EventId == FEI_FAXSVC_ENDED) {
            // Signal the g_hFaxEvent
            SetEvent(g_hFaxEvent);

            // Free the packet
            LocalFree(pFaxEvent);
			pFaxEvent = NULL;
            break;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_OFF) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_DEVICE_POWERED_OFF, pFaxEvent->DeviceId);

            // Free the packet
            LocalFree(pFaxEvent);
			pFaxEvent= NULL;

            // Decrement g_dwNumAvailPorts
            g_dwNumAvailPorts--;
            if (!g_dwNumAvailPorts) {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_PORTS_NOT_AVAILABLE, 0);
            }
            continue;
        }

        if (pFaxEvent->EventId == FEI_MODEM_POWERED_ON) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_DEVICE_POWERED_ON, pFaxEvent->DeviceId);

            // Free the packet
            LocalFree(pFaxEvent);
			pFaxEvent = NULL;

            // Increment g_dwNumAvailPorts
            g_dwNumAvailPorts++;
            continue;
        }

        // Verify the port is valid
        if (!fnIsPortValid(g_pFaxPortsConfig, g_dwNumPorts, pFaxEvent->DeviceId)) {
            // Free the packet
            LocalFree(pFaxEvent);
			pFaxEvent = NULL;
            continue;
        }

        if ((pFaxEvent->EventId == FEI_IDLE) && (g_bFaxSndInProgress) && (pFaxEvent->DeviceId == dwDeviceId) && ((bFaxPassed) || (bFaxFailed))) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
            if (bFaxPassed) {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SEND_PASSED, pFaxEvent->DeviceId);
                // Signal the Send Passed event
                SetEvent(g_hSendPassedEvent);
            }
            else {
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SEND_FAILED, pFaxEvent->DeviceId);
                // Signal the Send Failed event
                SetEvent(g_hSendFailedEvent);
            }
            dwDeviceId = 0;
            bFaxPassed = FALSE;
            bFaxFailed = FALSE;
            continue;
        }

        if ((pFaxEvent->EventId == FEI_IDLE) && (g_bFaxSndInProgress)) {
            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
        }

        if ((pFaxEvent->JobId == g_dwFaxId) && (g_bFaxSndInProgress)) {
            switch (pFaxEvent->EventId) {
                case FEI_INITIALIZING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INITIALIZING, pFaxEvent->DeviceId);
                    break;

                case FEI_DIALING:
                    g_dwAttempt++;
                    // Set FaxDialingInfo
                    FaxDialingInfo.dwAttempt = g_dwAttempt;
                    FaxDialingInfo.dwDeviceId = pFaxEvent->DeviceId;
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_DIALING, (LPARAM) &FaxDialingInfo);
                    dwDeviceId = pFaxEvent->DeviceId;
                    break;

                case FEI_NO_DIAL_TONE:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_DIAL_TONE_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_DIAL_TONE_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_BUSY:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_BUSY_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_BUSY_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_NO_ANSWER:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_ANSWER_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NO_ANSWER_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_SENDING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_SENDING, pFaxEvent->DeviceId);
                    break;

                case FEI_FATAL_ERROR:
                    if (g_dwAttempt < (FAXSVC_RETRIES + 1)) {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR_RETRY, pFaxEvent->DeviceId);
                    }
                    else {
                        // Update the status
                        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR_ABORT, pFaxEvent->DeviceId);
                        bFaxFailed = TRUE;
                    }
                    break;

                case FEI_ABORTING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ABORTING, pFaxEvent->DeviceId);
                    bFaxFailed = TRUE;
                    break;

                case FEI_COMPLETED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_COMPLETED, pFaxEvent->DeviceId);
                    bFaxPassed = TRUE;
                    break;

                default:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_UNEXPECTED_STATE, pFaxEvent->DeviceId);
                    bFaxFailed = TRUE;
                    break;
            }
        }

        if (g_bFaxRcvInProgress) {
            switch (pFaxEvent->EventId) {
                case FEI_INITIALIZING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INITIALIZING, pFaxEvent->DeviceId);
                    break;

                case FEI_RINGING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RINGING, pFaxEvent->DeviceId);
                    break;

                case FEI_ANSWERED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ANSWERED, pFaxEvent->DeviceId);
                    break;

                case FEI_NOT_FAX_CALL:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_NOT_FAX_CALL, pFaxEvent->DeviceId);
                    break;

                case FEI_RECEIVING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RECEIVING, pFaxEvent->DeviceId);
                    break;

                case FEI_FATAL_ERROR:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_FATAL_ERROR, pFaxEvent->DeviceId);
                    break;

                case FEI_ABORTING:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ABORTING, pFaxEvent->DeviceId);
                    break;

                case FEI_COMPLETED:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_COMPLETED, pFaxEvent->DeviceId);
                    break;

                case FEI_IDLE:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_IDLE, pFaxEvent->DeviceId);
                    break;

                default:
                    // Update the status
                    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_UNEXPECTED_STATE, pFaxEvent->DeviceId);
                    break;
            }
        }

        // Free the packet
        LocalFree(pFaxEvent);
		pFaxEvent = NULL;
    }

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\macros.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  macros.c

Abstract:

  This module contains the global macros

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _MACROS_C
#define _MACROS_C

#include <stdio.h>

// szDefaultCaption is the default caption
LPWSTR  szDefaultCaption = NULL;

VOID
SetDefaultCaptionMacro(
    LPWSTR  szCaption
)
/*++

Routine Description:

  Sets the default caption

Arguments:

  szCaption - default caption

Return Value:

  None

--*/
{
    DWORD  cb;

    if (szCaption) {
        // Determine the memory required by szDefaultCaption
        cb = (lstrlen(szCaption) + 1) * sizeof(WCHAR);

        // Allocate the memory for szDefaultCaption
        szDefaultCaption = (LPWSTR)MemAllocMacro(cb);

        // Set szDefaultCaption
        lstrcpy(szDefaultCaption, szCaption);
    }
}

VOID
DebugMacro(
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Displays a string in the debugger

Arguments:

  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list     varg_ptr;
    SYSTEMTIME  SystemTime;
    // szDebugBuffer is the debug string
    WCHAR       szDebugBuffer[1024];
    DWORD       cb;

    // Initialize the buffer
    ZeroMemory(szDebugBuffer, sizeof(szDebugBuffer));

    // Get the current time
    GetLocalTime(&SystemTime);
    if (szDefaultCaption) {
        wsprintf(szDebugBuffer, L"%s - %02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", szDefaultCaption, SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    }
    else {
        wsprintf(szDebugBuffer, L"%02d.%02d.%04d@%02d:%02d:%02d.%03d:\n", SystemTime.wMonth, SystemTime.wDay, SystemTime.wYear, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond, SystemTime.wMilliseconds);
    }
    cb = lstrlen(szDebugBuffer);

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(&szDebugBuffer[cb], sizeof(szDebugBuffer) - cb, szFormatString, varg_ptr);
    OutputDebugString(szDebugBuffer);
}

VOID
MessageBoxMacro(
    HWND  hWndParent,
    UINT  uID,
    UINT  uType,
    ...
)
/*++

Routine Description:

  Displays a pop-up

Arguments:

  hWndParent - handle of parent window
  uID - id of resource string
  uType - type of message box

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szFormatString is the string determined from the id of the resource string, used as format control
    WCHAR    szFormatString[MAX_STRINGLEN];
    // szTest is the string displayed in the pop-up
    WCHAR    szText[MAX_STRINGLEN * 2];

    // Initialize the buffers
    ZeroMemory(szFormatString, sizeof(szFormatString));
    ZeroMemory(szText, sizeof(szText));

    // Load the resource string
    LoadString(g_hInstance, uID, szFormatString, MAX_STRINGLEN);

    va_start(varg_ptr, uType);
    _vsnwprintf(szText, MAX_STRINGLEN * 2, szFormatString, varg_ptr);
    DebugMacro(L"%s\n", szText);
    // Display the pop-up
    MessageBox(hWndParent, szText, szDefaultCaption, MB_OK | uType);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\faxvrfy.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  faxvrfy.h

Abstract:

  This module contains the global definitions

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _FAXVRFY_H
#define _FAXVRFY_H

#include "ntlog.h"
#include <ras.h>

// FAXVRFY_NAME is the name of the FaxVrfy application
#define FAXVRFY_NAME            L"FaxVrfy"

// FAXVRFY_HLP is the name of the FaxVrfy help file
#define FAXVRFY_HLP             L"faxvrfy.hlp"

// FAXRCV_DLL is the name of the FaxRcv dll
#define FAXRCV_DLL              L"faxrcv.dll"

// FAXVRFY_LOG is the name of the FaxVrfy log file
#define FAXVRFY_LOG             L"faxvrfy.log"
// FAXVRFY_TXT is the name of the FaxVrfy text file
#define FAXVRFY_TXT             L"faxvrfy.txt"

// FAXVRFY_INI is the name of the FaxVrfy ini
#define FAXVRFY_INI             L"faxvrfy.ini"

// FAXBVT_TIF is the name of the tif file for the BVT test
#define FAXBVT_TIF              L"faxbvt.tif"
// FAXWHQL_TIF is the name of the tif file for the WHQL test
#define FAXWHQL_TIF             L"faxwhql.tif"

// FAXVRFY_CMD_HELP is the help command line parameter
#define FAXVRFY_CMD_HELP_1      L"/?"
#define FAXVRFY_CMD_HELP_2      L"/h"
#define FAXVRFY_CMD_HELP_3      L"-?"
#define FAXVRFY_CMD_HELP_4      L"-h"
// FAXVRFY_CMD_BVT is the BVT command line parameter
#define FAXVRFY_CMD_BVT_1       L"/bvt"
#define FAXVRFY_CMD_BVT_2       L"-bvt"
// FAXVRFY_CMD_SEND is the send command line parameter
#define FAXVRFY_CMD_SEND_1      L"/s"
#define FAXVRFY_CMD_SEND_2      L"-s"
// FAXVRFY_CMD_RECEIVE is the receive command line parameter
#define FAXVRFY_CMD_RECEIVE_1   L"/r"
#define FAXVRFY_CMD_RECEIVE_2   L"-r"
// FAXVRFY_CMD_GO is the go command line parameter
#define FAXVRFY_CMD_GO_1        L"/g"
#define FAXVRFY_CMD_GO_2        L"-g"
// FAXVRFY_CMD_NO_CHECK is the no check command line parameter
#define FAXVRFY_CMD_NO_CHECK_1  L"/x"
#define FAXVRFY_CMD_NO_CHECK_2  L"-x"
// FAXVRFY_CMD_USE_DEVICE is the option to supply which device to use for faxing
#define FAXVRFY_CMD_USE_DEVICE_1		L"/modem="
#define FAXVRFY_CMD_USE_DEVICE_2		L"-modem="
#define FAXVRFY_CMD_USE_DEVICE_SIZEOF	7


// ENCODE_CHAR_LEN is the text length limit of the encoding character.
#define ENCODE_CHAR_LEN         1
// CONTROL_CHAR_LEN is the text length limit of the control characters.
#define CONTROL_CHAR_LEN        2
// PHONE_NUM_LEN is the text length limit of phone number edit controls.  The length of 17 corresponds to the TSID limit for the fax service (20) minus 3 characters for encoding
#define PHONE_NUM_LEN           17

// TX_CONTROL_CHARS are the control characters when sending
#define TX_CONTROL_CHARS        L"TX"
// RX_CONTROL_CHARS are the control characters when receiving
#define RX_CONTROL_CHARS        L"RX"

// FAXSVC_RETRIES is the number of retries
#define FAXSVC_RETRIES          2
// FAXSVC_RETRYDELAY is the retry delay
#define FAXSVC_RETRYDELAY       3

// FAXBVT_PAGES is the number of pages in the BVT fax
#define FAXBVT_PAGES            1
// FAXWHQL_PAGES is the number of pages in the WHQL fax
#define FAXWHQL_PAGES           5
// FAXBVT_NUM_FAXES is the number of faxes to send for BVT
#define FAXBVT_NUM_FAXES        1
// FAXWHQL_NUM_FAXES is the number of faxes to send for WHQL
#define FAXWHQL_NUM_FAXES       2

// UM_FAXVRFY_INITIALIZE is the message to initialize the application window
#define UM_FAXVRFY_INITIALIZE   (WM_USER + 1)
// UM_FAXVRFY_UPDATE is the message to update the test
#define UM_FAXVRFY_UPDATE       (WM_USER + 2)
// UM_FAXVRFY_RESET is the message to reset the test
#define UM_FAXVRFY_RESET        (WM_USER + 3)
// UM_TIMEOUT_ENDED is the message to indicate the timeout ended
#define UM_TIMEOUT_ENDED        (WM_USER + 4)
// UM_FAXSVC_ENDED is the message to indicate the fax service stopped
#define UM_FAXSVC_ENDED         (WM_USER + 5)
// UM_ITERATION_STOPPED is the message to indicate the iteration stopped
#define UM_ITERATION_STOPPED    (WM_USER + 6)
// UM_ITERATION_PASSED is the message to indicate the iteration passed
#define UM_ITERATION_PASSED     (WM_USER + 7)
// UM_ITERATION_FAILED is the message to indicate the iteration failed
#define UM_ITERATION_FAILED     (WM_USER + 8)

// UM_UPDATE_STATUS is a message to update the Status List
#define UM_UPDATE_STATUS        (WM_USER + 11)

HWND                g_hWndDlg;                          // g_hWndDlg is the handle to the Setup Dialog

HANDLE              g_hLogFile = NULL;                  // g_hLogFile is the handle to the log file
HANDLE              g_hTxtFile = INVALID_HANDLE_VALUE;  // g_hLogFile is the handle to the text file

BOOL                g_bBVT = FALSE;                     // g_bBVT indicates BVT command line parameter
BOOL                g_bSend = FALSE;                    // g_bSend indicates send command line parameter
BOOL                g_bGo = FALSE;                      // g_bGo indicates go command line parameter
BOOL                g_bNoCheck = FALSE;                 // g_bNoCheck indicates no check command line parameter

HANDLE              g_hStartEvent;                      // g_hStartEvent is the handle to the Start event
HANDLE              g_hStopEvent;                       // g_hStopEvent is the handle to the Stop event
HANDLE              g_hFaxEvent;                        // g_hFaxEvent is the handle to the event to indicate the Fax Service stopped
HANDLE              g_hExitEvent;                       // g_hExitEvent is the handle to the Exit event

HANDLE              g_hRasPassedEvent;                  // g_hRasPassedEvent is the handle to the RAS Passed event
HANDLE              g_hRasFailedEvent;                  // g_hRasFailedEvent is the handle to the RAS Failed event
HANDLE              g_hSendPassedEvent;                 // g_hSendPassedEvent is the handle to the Send Passed event
HANDLE              g_hSendFailedEvent;                 // g_hSendFailedEvent is the handle to the Send Failed event

HANDLE              g_hFaxSvcHandle;                    // g_hFaxSvcHandle is the handle to the Fax Service
PFAX_PORT_INFO      g_pFaxPortsConfig;                  // g_pFaxPorts is the pointer to the Fax Ports Configuration
DWORD               g_dwNumPorts;                       // g_dwNumPorts is the number of Ports
DWORD               g_dwNumAvailPorts;                  // g_dwNumAvailPorts is the number of Available Ports
PFAX_CONFIGURATION  g_pFaxSvcConfig;                    // g_pFaxConfig is the pointer to the Fax Service Configuration

BOOL                g_bFaxSndInProgress = FALSE;        // g_bFaxSndInProgress indicates if a fax send is in progress
DWORD               g_dwFaxId = 0;                      // g_dwFaxId is the fax job id of the fax
DWORD               g_dwAttempt = 0;                    // g_dwAttempt is the attempt number of the fax
BOOL                g_bFaxRcvInProgress = FALSE;        // g_bFaxRcvInProgress indicates if a fax receive is in progress

HANDLE              g_hCompletionPort;                  // g_hCompletionPort is the handle to the completion port

BOOL                g_bTestFailed = FALSE;              // g_bTestFailed indicates the test failed
DWORD               g_dwNumPassed = 0;                  // g_dwNumPassed is the number of passed iterations
DWORD               g_dwNumFailed = 0;                  // g_dwNumFailed is the number of failed iterations
DWORD               g_dwNumTotal = 0;                   // g_dwNumTotal is the number of total iterations

WCHAR               g_szSndNumber[PHONE_NUM_LEN + 1];   // g_szSndNumber is the send phone number
WCHAR               g_szRcvNumber[PHONE_NUM_LEN + 1];   // g_szRcvNumber is the receive phone number
WCHAR               g_szRasUserName[UNLEN + 1];         // g_szRasUserName is the RAS user name
WCHAR               g_szRasPassword[PWLEN + 1];         // g_szRasPassword is the RAS password
WCHAR               g_szRasDomain[DNLEN + 1];           // g_szRasDomain is the RAS domain

BOOL                g_bNTLogAvailable = FALSE;          // g_bNTLogAvailable indicates if NTLog is available

BOOL                g_bRasAvailable = FALSE;            // g_bRasAvailable indicates if RAS is available
BOOL                g_bRasEnabled = FALSE;              // g_bRasEnables indicates if RAS is enabled

#define FAXDEVICES_REGKEY       L"Software\\Microsoft\\Fax\\Devices"
#define MODEM_REGKEY            L"\\Modem"
#define FIXMODEMCLASS_REGVALUE  L"FixModemClass"

// FAX_DIALING_INFO is a structure that is the fax dialing info
typedef struct _FAX_DIALING_INFO {
    DWORD  dwAttempt;        // Attempt number
    DWORD  dwDeviceId;       // Device id
} FAX_DIALING_INFO, *PFAX_DIALING_INFO;

// FAX_RECEIVE_INFO is a structure that is the fax receive info
typedef struct _FAX_RECEIVE_INFO {
    LPWSTR  szCopyTiffName;  // Attempt number
    DWORD   dwDeviceId;      // Device id
} FAX_RECEIVE_INFO, *PFAX_RECEIVE_INFO;

// NTLOG_DLL is the name of the dll that contains all of the NTLOG API's
#define NTLOG_DLL  L"ntlog.dll"

// NTLOG_API is a structure that points to the NTLOG API's
typedef struct _NTLOG_API {
    HINSTANCE             hInstance;             // Handle to the instance of the dll
    PTLCREATELOG          ptlCreateLog;          // tlCreateLog
    PTLDESTROYLOG         ptlDestroyLog;         // tlDestroyLog
    PTLADDPARTICIPANT     ptlAddParticipant;     // tlAddParticipant
    PTLREMOVEPARTICIPANT  ptlRemoveParticipant;  // tlRemoveParticipant
    PTLLOG                ptlLog;                // tlLog
} NTLOG_API, *PNTLOG_API;

// g_NTLogApi is the global NTLOG_API object
NTLOG_API  g_NTLogApi;

// RASAPI32_DLL is the name of the dll that contains all of the RAS API's
#define RASAPI32_DLL  L"\\rasapi32.dll"

typedef DWORD (APIENTRY *PRASDIALW)		(LPRASDIALEXTENSIONS, LPCWSTR, LPRASDIALPARAMSW, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *PRASDIALA)		(LPRASDIALEXTENSIONS, LPCSTR, LPRASDIALPARAMSA, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *PRASGETERRORSTRINGW)		(UINT, LPWSTR, DWORD);
typedef DWORD (APIENTRY *PRASGETERRORSTRINGA)		(UINT, LPSTR, DWORD);
typedef DWORD (APIENTRY *PRASHANGUPW)		(HRASCONN);
typedef DWORD (APIENTRY *PRASHANGUPA)		(HRASCONN);
typedef DWORD (APIENTRY *PRASGETCONNECTSTATUSW)		(HRASCONN, LPRASCONNSTATUSW);
typedef DWORD (APIENTRY *PRASGETCONNECTSTATUSA)		(HRASCONN, LPRASCONNSTATUSA);
typedef DWORD (APIENTRY *PRASGETCONNECTIONSTATISTICS)		(HRASCONN ,RAS_STATS*);

#ifdef UNICODE
#define	PRASDIAL				PRASDIALW
#define	PRASGETERRORSTRING		PRASGETERRORSTRINGW
#define	PRASHANGUP				PRASHANGUPW
#define	PRASGETCONNECTSTATUS	PRASGETCONNECTSTATUSW
#else
#define	PRASDIAL				PRASDIALA
#define	PRASGETERRORSTRING		PRASGETERRORSTRINGA
#define	PRASHANGUP				PRASHANGUPA
#define	PRASGETCONNECTSTATUS	PRASGETCONNECTSTATUSA
#endif

// RAS_API is a structure that points to the RAS API's
typedef struct _RAS_API {
    HINSTANCE					hInstance;                   // Handle to the instance of the dll
    PRASDIAL					RasDial;                     // RasDial
    PRASGETERRORSTRING			RasGetErrorString;           // RasGetErrorString
    PRASGETCONNECTSTATUS		RasGetConnectStatus;         // RasGetConnectStatus
    PRASGETCONNECTIONSTATISTICS	RasGetConnectionStatistics;  // RasGetConnectionStatistics
    PRASHANGUP					RasHangUp;                   // RasHangUp
} RAS_API, *PRAS_API;

// g_RasApi is the global RAS_API object
RAS_API  g_RasApi;

// RAS_INFO is a structure that is the RAS connection info
typedef struct _RAS_INFO {
    DWORD   dwBps;         // Connection speed
    LPWSTR  szDeviceName;  // Device name
} RAS_INFO, *PRAS_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\sndthrd.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  sndthrd.c

Abstract:

  This module:
    1) Verifies a tiff
    2) Enables or disables the FaxRcv Routing Extension
    3) Callback function for the change of state during the RAS connection process
    4) Sends a RAS call
    5) Sends a fax
    6) Receives a fax
    7) Thread to handle the Send logic

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _SNDTHRD_C
#define _SNDTHRD_C

#include <tifflib.h>
#include <tifflibp.h>


#define SUSPECT_RAS_SPEED    28800

#define IMAGEWIDTH_REF       1728
#define IMAGELENGTH_200_REF  2200
#define IMAGELENGTH_100_REF  1100
#define SOFTWARE_REF         "Windows NT Fax Server"

UINT
fnVerifyTiff(
    LPWSTR   szTiffFile,
    LPDWORD  pdwPages
)
/*++

Routine Description:

  Verifies a tiff

Arguments:

  szTiffFile - tiff file name
  pdwPages - pointer to the number of pages

Return Value:

  TRUE on success

--*/
{
    HANDLE               hTiffFile;
    TIFF_INFO            TiffInfo;
    PTIFF_INSTANCE_DATA  pTiffInstanceData;
    DWORD                IFDOffset;
    WORD                 wNumDirEntries;
    PTIFF_TAG            pTiffTag;
    WORD                 wIndex;

    DWORD                ImageLengthRef;

    DWORD                ImageWidth;
    DWORD                ImageLength;
    DWORD                Compression;
    DWORD                Photometric;
    DWORD                XResolution;
    DWORD                YResolution;
    LPSTR                SoftwareBuffer;
    LPSTR                Software;

    UINT                 uFlags;

    uFlags = ERROR_SUCCESS;
    *pdwPages = 0;

    // Open the tiff file
    hTiffFile = TiffOpen(szTiffFile, &TiffInfo, TRUE, FILLORDER_MSB2LSB);
    if (hTiffFile == NULL)
	{
        TiffClose(hTiffFile);
		hTiffFile = NULL;
        return IDS_TIFF_INVALID_TIFF;
    }

    pTiffInstanceData = (PTIFF_INSTANCE_DATA) hTiffFile;
    // Get the next IFD offset
    IFDOffset = pTiffInstanceData->TiffHdr.IFDOffset;

    while (IFDOffset) {

        // Increment the number of pages
        (*pdwPages)++;

        // Get the number of tags in this IFD
        wNumDirEntries = (WORD) *(LPWORD) (pTiffInstanceData->fPtr + IFDOffset);

        // Set the tag pointer
        pTiffTag = (PTIFF_TAG) (pTiffInstanceData->fPtr +IFDOffset + sizeof(WORD));

        // Get the tiff tags
        ImageWidth = -1;
        ImageLength = -1;
        Compression = -1;
        Photometric = -1;
        XResolution = -1;
        YResolution = -1;
        Software = NULL;

        for (wIndex = 0; wIndex < wNumDirEntries; wIndex++) {
            switch (pTiffTag[wIndex].TagId) {
                case TIFFTAG_IMAGEWIDTH:
                    ImageWidth = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_IMAGELENGTH:
                    ImageLength = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_COMPRESSION:
                    Compression = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_PHOTOMETRIC:
                    Photometric = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_XRESOLUTION:
                    XResolution = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_YRESOLUTION:
                    YResolution = GetTagData(pTiffInstanceData->fPtr, 0, &pTiffTag[wIndex]);
                    break;

                case TIFFTAG_SOFTWARE:
                    SoftwareBuffer = (LPSTR) (DWORD UNALIGNED *) (pTiffInstanceData->fPtr + pTiffTag[wIndex].DataOffset);
                    Software = (LPSTR)MemAllocMacro((lstrlenA(SOFTWARE_REF) + 1) * sizeof(CHAR));
                    lstrcpynA(Software, SoftwareBuffer, (lstrlenA(SOFTWARE_REF) + 1));
                    break;
            }
        }

        if ((ImageWidth < (IMAGEWIDTH_REF - (IMAGEWIDTH_REF * .1))) || (ImageWidth > (IMAGEWIDTH_REF + (IMAGEWIDTH_REF * .1)))) {
            uFlags = IDS_TIFF_INVALID_IMAGEWIDTH;
            goto InvalidFax;
        }

        if (YResolution == 196) {
            ImageLengthRef = IMAGELENGTH_200_REF;
        }
        else if (YResolution == 98) {
            ImageLengthRef = IMAGELENGTH_100_REF;
        }
        else {
            uFlags = IDS_TIFF_INVALID_YRESOLUTION;
            goto InvalidFax;
        }
        if ((ImageLength < (ImageLengthRef - (ImageLengthRef * .1))) || (ImageLength > (ImageLengthRef + (ImageLengthRef * .1)))) {
            uFlags = IDS_TIFF_INVALID_IMAGELENGTH;
            goto InvalidFax;
        }

        if (Compression != 4) {
            uFlags = IDS_TIFF_INVALID_COMPRESSION;
            goto InvalidFax;
        }

        if (Photometric != 0) {
            uFlags = IDS_TIFF_INVALID_PHOTOMETRIC;
            goto InvalidFax;
        }

        if (XResolution != 204) {
            uFlags = IDS_TIFF_INVALID_XRESOLUTION;
            goto InvalidFax;
        }

        if ((YResolution != 196) && (YResolution != 98)) {
            uFlags = IDS_TIFF_INVALID_YRESOLUTION;
            goto InvalidFax;
        }

        if (lstrcmpA(SOFTWARE_REF, Software)) {
            uFlags = IDS_TIFF_INVALID_SOFTWARE;
            goto InvalidFax;
        }

        MemFreeMacro(Software);

        // Get the next IFD offset
        IFDOffset = (DWORD) *(DWORD UNALIGNED *) (pTiffInstanceData->fPtr + (wNumDirEntries * sizeof(TIFF_TAG)) + IFDOffset + sizeof(WORD));
    }

    TiffClose(hTiffFile);
	hTiffFile = NULL;
    return ERROR_SUCCESS;

InvalidFax:
    if (Software) {
        MemFreeMacro(Software);
    }

    TiffClose(hTiffFile);
	hTiffFile = NULL;
    return uFlags;
}

VOID
fnEnableFaxRcv(
    BOOL  bEnable
)
/*++

Routine Description:

  Enables or disables the FaxRcv Routing Extension

Arguments:

  bEnable - indicates whether to enable or disable the FaxRcv Routing Extension
            TRUE enables the FaxRcv Routing Extension
            FALSE enables the FaxRcv Routing Extension

Return Value:

  None

--*/
{
    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY  hFaxRcvExtKey;

    // Open the FaxRcv Extension Registry key
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, KEY_ALL_ACCESS, &hFaxRcvExtKey) != ERROR_SUCCESS) {
        return;
    }

    // Set the FaxRcv Extension bEnable Registry value
    if (RegSetValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, 0, REG_DWORD, (LPBYTE) &bEnable, sizeof(BOOL)) != ERROR_SUCCESS) {
        // Close the FaxRcv Extension Registry key
        RegCloseKey(hFaxRcvExtKey);
		hFaxRcvExtKey = NULL;
        return;
    }

    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);
	hFaxRcvExtKey = NULL;
}

VOID WINAPI
fnRasDialCallback(
    UINT          uMsg,
    RASCONNSTATE  RasConnState,
    DWORD         dwError
)
/*++

Routine Description:

  Callback function for the change of state during the RAS connection process

Arguments:

  uMsg - type of event
  RasConnState - state
  dwError - error

Return Value:

  None

--*/
{
    static BOOL    bError = FALSE;

    if ((dwError) && (!bError)) {
        bError = TRUE;
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_FAILED, dwError);
        SetEvent(g_hRasFailedEvent);
    }
    else if (RasConnState == RASCS_OpenPort) {
        bError = FALSE;
    }
    else if (RasConnState == RASCS_ConnectDevice) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_DIALING, 0);
    }
    else if (RasConnState == RASCS_Authenticate) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_AUTHENTICATING, 0);
    }
    else if (RasConnState == RASCS_Connected) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_CONNECTED, 0);
        SetEvent(g_hRasPassedEvent);
    }

    return;
}

UINT
fnSendRas(
    LPHANDLE  phFaxStopRasPassFailEvents
)
/*++

Routine Description:

  Sends a RAS call

Arguments:

  phFaxStopSendPassFailEvents - pointer to the g_hFaxEvent, g_hStopEvent, g_hRasPassedEvent and g_hRasFailedEvent

Return Value:

  UINT - resource id

--*/
{
    DWORD  dwRslt;
    UINT   uRslt;

    // RasDialParams is the RAS dial params
    RASDIALPARAMS  RasDialParams;
    // hRasConn is the handle to the RAS connection
    HRASCONN       hRasConn;
    // RasConnStatus is the RAS connection status
    RASCONNSTATUS  RasConnStatus;
    // RasStats are the RAS connection statistics
    RAS_STATS      RasStats;
    // RasInfo is the RAS connection info
    RAS_INFO       RasInfo;

    // Initialize RasDialParams
    ZeroMemory(&RasDialParams, sizeof(RASDIALPARAMS));

    // Set RasDialParams
    RasDialParams.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(RasDialParams.szPhoneNumber, g_szSndNumber);
    lstrcpy(RasDialParams.szUserName, g_szRasUserName);
    lstrcpy(RasDialParams.szPassword, g_szRasPassword);
    lstrcpy(RasDialParams.szDomain, g_szRasDomain);

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STARTING, (LPARAM) g_szSndNumber);

    // Start the RAS session
    ResetEvent(g_hRasPassedEvent);
    ResetEvent(g_hRasFailedEvent);
    g_RasApi.RasDial(NULL, NULL, &RasDialParams, 0, fnRasDialCallback, &hRasConn);

    // Wait for Fax, Stop, RAS Passed or RAS Failed event
    dwRslt = WaitForMultipleObjects(4, phFaxStopRasPassFailEvents, FALSE, INFINITE);

    switch (dwRslt) {
        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_RAS_PASSED;
            break;

        case (WAIT_OBJECT_0 + 3):
            uRslt = IDS_STATUS_RAS_FAILED;
            break;
    }

    if (uRslt != IDS_STATUS_RAS_PASSED) {
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STOPPING, 0);
        // Stop the RAS session
        g_RasApi.RasHangUp(hRasConn);
        if (uRslt != IDS_STATUS_RAS_FAILED) {
            WaitForSingleObject(g_hRasFailedEvent, INFINITE);
        }

        return uRslt;
    }

    // Initialize RasConnStatus
    ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));
    // Set RasConnStatus
    RasConnStatus.dwSize = sizeof(RASCONNSTATUS);
    // Get the RAS connection status
    g_RasApi.RasGetConnectStatus(hRasConn, &RasConnStatus);

    // Initialize RasStats
    ZeroMemory(&RasStats, sizeof(RAS_STATS));
    // Set RasStats
    RasStats.dwSize = sizeof(RAS_STATS);
    // Get the connection statistics
    g_RasApi.RasGetConnectionStatistics(hRasConn, &RasStats);

    // Set the line speed
    RasInfo.dwBps = RasStats.dwBps;
    // Set the port name
    RasInfo.szDeviceName = RasConnStatus.szDeviceName;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_LINESPEED, (LPARAM) &RasInfo);

    if (RasStats.dwBps < SUSPECT_RAS_SPEED) {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_SPEED_SUSPECT, SUSPECT_RAS_SPEED);
    }
    else {
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_PASSED, 0);
    }

    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_RAS_STOPPING, 0);

    // Stop the RAS session
    g_RasApi.RasHangUp(hRasConn);

    return IDS_STATUS_RAS_PASSED;
}

UINT
fnSendFax(
    FAX_JOB_PARAM  FaxJobParams,
    LPWSTR         szDocumentName,
    LPHANDLE       phFaxStopSendPassFailEvents,
    DWORD          dwSendTimeout
)
/*++

Routine Description:

  Sends a fax

Arguments:

  FaxJobParams - fax job parameters
  szDocumentName - name of document to send
  phFaxStopSendPassFailEvents - pointer to the g_hFaxEvent, g_hStopEvent, g_hSendPassedEvent and g_hSendFailedEvent
  dwSendTimeout - send timeout interval

Return Value:

  UINT - resource id

--*/
{
    DWORD  dwRslt;
    UINT   uRslt;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_STARTING, (LPARAM) FaxJobParams.RecipientNumber);

    if (!g_bNoCheck) {
        // Update the status
        SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ID, (LPARAM) FaxJobParams.Tsid);
    }

    // Send a fax
    if (!FaxSendDocument(g_hFaxSvcHandle, szDocumentName, &FaxJobParams, NULL, &g_dwFaxId)) {
        return IDS_STATUS_FAX_SEND_FAILED;
    }

    g_bFaxSndInProgress = TRUE;
    g_dwAttempt = 0;

    // Wait for Fax, Stop, Send Passed or Send Failed event
    dwRslt = WaitForMultipleObjects(4, phFaxStopSendPassFailEvents, FALSE, dwSendTimeout);

    g_bFaxSndInProgress = FALSE;

    switch (dwRslt) {
        case WAIT_TIMEOUT:
            uRslt = IDS_STATUS_TIMEOUT_ENDED;
            break;

        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_FAX_SEND_PASSED;
            break;

        case (WAIT_OBJECT_0 + 3):
            uRslt = IDS_STATUS_FAX_SEND_FAILED;
            break;
    }

    if (uRslt != IDS_STATUS_FAX_SEND_PASSED) {
        if (uRslt == IDS_STATUS_ITERATION_STOPPED) {
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_STOPPING, 0);
        }

        FaxAbort(g_hFaxSvcHandle, g_dwFaxId);

        return uRslt;
    }

    return IDS_STATUS_FAX_SEND_PASSED;
}

UINT
fnReceiveFax(
    LPHANDLE  phFaxStopRcvEvents,
    DWORD     dwReceiveTimeout,
    LPWSTR    szTsid,
    DWORD     dwTsidSize,
    LPWSTR    szCopyTiffFile,
    DWORD     dwCopyTiffFileSize,
    LPWSTR    szCopyTiffName,
    DWORD     dwCopyTiffNameSize
)
/*++

Routine Description:

  Receives a fax

Arguments:

  phFaxStopRcvEvents - pointer to the g_hFaxEvent, g_hStopEvent and hFaxRcvEvent
  dwReceiveTimeout - receive timeout interval
  szTsid - TSID of the received fax
  dwTsidSize - size of szTsid buffer, in bytes
  szCopyTiffFile - name of the copy of the received fax
  dwCopyTiffFileSize - size of szCopyTiffFile buffer, in bytes
  szCopyTiffName - name of the copy of the received fax
  dwCopyTiffNameSize - size of szCopyTiffName buffer, in bytes

Return Value:

  UINT - resource id

--*/
{
    // hFaxRcvEvent is the handle to the FaxRcv named event
    HANDLE            hFaxRcvEvent;
    // hFaxRcvMutex is the handle to the FaxRcv named mutex
    HANDLE            hFaxRcvMutex;

    // hFaxRcvMap is the handle to the FaxRcv memory map
    HANDLE            hFaxRcvMap;
    // pFaxRcvView is the pointer to the FaxRcv memory map view
    LPBYTE            pFaxRcvView;

    // szTiffFile is the name of the received fax
    LPWSTR            szTiffFile;
    // szFile is the name of the received fax
    WCHAR             szFile[_MAX_FNAME];
    // szExt is the extension of the received fax
    WCHAR             szExt[_MAX_EXT];

    // FaxReceiveInfo is the fax receive info
    FAX_RECEIVE_INFO  FaxReceiveInfo;

    DWORD             dwRslt;
    UINT              uRslt;
    UINT_PTR          upOffset;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_WAITING, 0);

    // Open FaxRcv named event
    hFaxRcvEvent = OpenEvent(SYNCHRONIZE, FALSE, FAXRCV_EVENT);
    // Open FaxRcv named mutex
    hFaxRcvMutex = OpenMutex(SYNCHRONIZE, FALSE, FAXRCV_MUTEX);

    if ((!hFaxRcvEvent) || (!hFaxRcvMutex)) {
        if (hFaxRcvEvent)
		{
            CloseHandle(hFaxRcvEvent);
			hFaxRcvEvent = NULL;
        }
        if (hFaxRcvMutex)
		{
            CloseHandle(hFaxRcvMutex);
			hFaxRcvMutex = NULL;
        }

        return IDS_STATUS_FAXSVC_ENDED;
    }

    // Update phFaxStopRcvEvents
    // hFaxRcvEvent
    phFaxStopRcvEvents[2] = hFaxRcvEvent;

    // Wait for FaxRcv named mutex
    WaitForSingleObject(hFaxRcvMutex, INFINITE);
    // Enable the FaxRcv Routing Extension
    fnEnableFaxRcv(TRUE);
    // Release access to the FaxRcv named mutex
    ReleaseMutex(hFaxRcvMutex);

    g_bFaxRcvInProgress = TRUE;

    // Wait for Fax, Stop or FaxRcv named event
    dwRslt = WaitForMultipleObjects(3, phFaxStopRcvEvents, FALSE, dwReceiveTimeout);

    g_bFaxRcvInProgress = FALSE;

    // Wait for FaxRcv named mutex
    WaitForSingleObject(hFaxRcvMutex, INFINITE);
    // Disable the FaxRcv Routing Extension
    fnEnableFaxRcv(FALSE);

    switch (dwRslt) {
        case WAIT_TIMEOUT:
            uRslt = IDS_STATUS_TIMEOUT_ENDED;
            break;

        case WAIT_OBJECT_0:
            uRslt = IDS_STATUS_FAXSVC_ENDED;
            break;

        case (WAIT_OBJECT_0 + 1):
            uRslt = IDS_STATUS_ITERATION_STOPPED;
            break;

        case (WAIT_OBJECT_0 + 2):
            uRslt = IDS_STATUS_FAX_RECEIVED;
            break;

    }

    if (uRslt != IDS_STATUS_FAX_RECEIVED) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(hFaxRcvMutex);

        CloseHandle(hFaxRcvEvent);
		hFaxRcvEvent = NULL;
        
		CloseHandle(hFaxRcvMutex);
		hFaxRcvMutex = NULL;

        return uRslt;
    }

    // Open FaxRcv memory map
    hFaxRcvMap = OpenFileMapping(FILE_MAP_READ, FALSE, FAXRCV_MAP);
    if (!hFaxRcvMap) {
        // Release access to the FaxRcv named mutex
        ReleaseMutex(hFaxRcvMutex);

        CloseHandle(hFaxRcvEvent);
		hFaxRcvEvent = NULL;

        CloseHandle(hFaxRcvMutex);
		hFaxRcvMutex = NULL;

        return IDS_STATUS_FAXSVC_ENDED;
    }

    // Create FaxRcv memory map view
    pFaxRcvView = (LPBYTE) MapViewOfFile(hFaxRcvMap, FILE_MAP_READ, 0, 0, 0);

    // Set upOffset
    upOffset = 0;

    // Set szTiffFile
    szTiffFile = (LPWSTR)MemAllocMacro((lstrlen((LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset)) + 1) * sizeof(WCHAR));
    lstrcpy(szTiffFile, (LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset));
    upOffset += (lstrlen(szTiffFile) + 1) * sizeof(WCHAR);

    // Initialize szTsid
    ZeroMemory(szTsid, dwTsidSize);
    // Set szTsid
    lstrcpy(szTsid, (LPWSTR) ((UINT_PTR) pFaxRcvView + upOffset));
    upOffset += (lstrlen(szTsid) + 1) * sizeof(WCHAR);

    // Set FaxReceiveInfo.dwDeviceId
    FaxReceiveInfo.dwDeviceId = (DWORD) *(LPDWORD) ((UINT_PTR) pFaxRcvView + upOffset);

    // Close FaxRcv memory map view
    UnmapViewOfFile(pFaxRcvView);
    // Close FaxRcv memory map
    CloseHandle(hFaxRcvMap);
	hFaxRcvMap = NULL;

    _wsplitpath(szTiffFile, NULL, NULL, szFile, szExt);

    // Initialize szCopyTiffFile
    ZeroMemory(szCopyTiffFile, dwCopyTiffFileSize * sizeof(WCHAR));
    // Set szCopyTiffFile
    GetCurrentDirectory(dwCopyTiffFileSize, szCopyTiffFile);
    lstrcat(szCopyTiffFile, L"\\");
    lstrcat(szCopyTiffFile, (LPWSTR) ((UINT_PTR) szFile + lstrlen(L"Copy of ") * sizeof(WCHAR)));
    lstrcat(szCopyTiffFile, szExt);

    // Initialize szCopyTiffName
    ZeroMemory(szCopyTiffName, dwCopyTiffNameSize);
    // Set szCopyTiffName
    lstrcpy(szCopyTiffName, (LPWSTR) ((UINT_PTR) szFile + lstrlen(L"Copy of ") * sizeof(WCHAR)));
    lstrcat(szCopyTiffName, szExt);

    // Set FaxReceiveInfo.szCopyTiffName
    FaxReceiveInfo.szCopyTiffName = szCopyTiffName;

    // Copy szTiffFile to szCopyTiffFile
    CopyFile(szTiffFile, szCopyTiffFile, FALSE);

    // Delete the received fax
    DeleteFile(szTiffFile);

    // Free szTiffFile
    MemFreeMacro(szTiffFile);

    // Release access to the FaxRcv named mutex
    ReleaseMutex(hFaxRcvMutex);

    CloseHandle(hFaxRcvEvent);
	hFaxRcvEvent = NULL;

    CloseHandle(hFaxRcvMutex);
	hFaxRcvMutex = NULL;

    // Update the status
    SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_RECEIVED, (LPARAM) &FaxReceiveInfo);

    return IDS_STATUS_FAX_RECEIVED;
}

DWORD WINAPI fnSendProc (LPVOID lpv)
/*++

Routine Description:

  Thread to handle the Send logic

Return Value:

  DWORD - exit code

--*/
{
    // hFaxExitStartEvents is a pointer to the g_hFaxEvent, g_hExitEvent and g_hStartEvent
    HANDLE         hFaxExitStartEvents[3];
    // hFaxStopRasPassFailEvents is a pointer to the g_hFaxEvent, g_hStopEvent, g_hRasPassedEvent and g_hRasFailedEvent
    HANDLE         hFaxStopRasPassFailEvents[4];
    // hFaxStopSendPassFailEvents is a pointer to the g_hFaxEvent, g_hStopEvent, g_hSendPassedEvent and g_hSendFailedEvent
    HANDLE         hFaxStopSendPassFailEvents[4];
    // hFaxStopRcvEvents is a pointer to the g_hFaxEvent, g_hStopEvent and g_hFaxRcvEvent
    HANDLE         hFaxStopRcvEvents[3];

    // dwSendTimeout is the send timeout interval
    DWORD          dwSendTimeout;
    // dwReceiveTimeout is the receive timeout interval
    DWORD          dwReceiveTimeout;

    // szOriginalTiffFile is the name of the original tiff file
    LPWSTR         szOriginalTiffFile;
    // dwNumFaxesToSend is the number of faxes to be sent
    DWORD          dwNumFaxesToSend;
    // dwNumFaxesRemaining is the number of faxes remaining to be sent
    DWORD          dwNumFaxesRemaining;

    // FaxJobParams is the fax job params
    FAX_JOB_PARAM  FaxJobParams;

    // szCopyTiffFile is the name of the copy of the received fax
    WCHAR          szCopyTiffFile[_MAX_PATH];
    // szCopyTiffName is the name of the copy of the received fax
    WCHAR          szCopyTiffName[_MAX_FNAME + _MAX_EXT];
    // szReceivedTsid is the received TSID
    WCHAR          szReceivedTsid[ENCODE_CHAR_LEN + CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1];
    // szEncodedTsid is the encoded TSID
    WCHAR          szEncodedTsid[ENCODE_CHAR_LEN + CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1];
    // szDecodedTsid is the decoded TSID
    WCHAR          szDecodedTsid[PHONE_NUM_LEN + 1];

    DWORD          dwPages;
    DWORD          dwRslt;
    UINT           uRslt;

    // Set hFaxExitStartEvents
    // g_hFaxEvent
    hFaxExitStartEvents[0] = g_hFaxEvent;
    // g_hExitEvent
    hFaxExitStartEvents[1] = g_hExitEvent;
    // g_hStartEvent
    hFaxExitStartEvents[2] = g_hStartEvent;

    // Set hFaxStopRasPassFailEvents
    // g_hFaxEvent
    hFaxStopRasPassFailEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopRasPassFailEvents[1] = g_hStopEvent;
    // g_hPassEvent
    hFaxStopRasPassFailEvents[2] = g_hRasPassedEvent;
    // g_hFailEvent
    hFaxStopRasPassFailEvents[3] = g_hRasFailedEvent;

    // Set hFaxStopSendPassFailEvents
    // g_hFaxEvent
    hFaxStopSendPassFailEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopSendPassFailEvents[1] = g_hStopEvent;
    // g_hSendPassedEvent
    hFaxStopSendPassFailEvents[2] = g_hSendPassedEvent;
    // g_hSendFailedEvent
    hFaxStopSendPassFailEvents[3] = g_hSendFailedEvent;

    // Set hFaxStopRcvEvents
    // g_hFaxEvent
    hFaxStopRcvEvents[0] = g_hFaxEvent;
    // g_hStopEvent
    hFaxStopRcvEvents[1] = g_hStopEvent;

    if (g_bBVT) {
        dwSendTimeout = FAXSVC_RETRIES * ((FAXSVC_RETRIES + 1) * FAXSVC_RETRYDELAY) * 60000;
        dwReceiveTimeout = dwSendTimeout * 2;

        szOriginalTiffFile = FAXBVT_TIF;

        dwNumFaxesToSend = FAXBVT_NUM_FAXES;
        dwNumFaxesRemaining = dwNumFaxesToSend;
    }
    else {
        dwSendTimeout = INFINITE;
        dwReceiveTimeout = INFINITE;

        szOriginalTiffFile = FAXWHQL_TIF;

        dwNumFaxesToSend = FAXWHQL_NUM_FAXES;
        dwNumFaxesRemaining = dwNumFaxesToSend;
    }

    while (TRUE) {
        // Wait for Fax, Exit, or Start event
        dwRslt = WaitForMultipleObjects(3, hFaxExitStartEvents, FALSE, INFINITE);

        if (dwRslt == WAIT_OBJECT_0) {
            SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
            continue;
        }
        else if (dwRslt == (WAIT_OBJECT_0 + 1)) {
            return 0;
        }

        if (g_bSend) {
            if (g_bRasEnabled) {
                // Send a RAS call
                uRslt = fnSendRas(hFaxStopRasPassFailEvents);

                if (uRslt != IDS_STATUS_RAS_PASSED) {
                    switch (uRslt) {
                        case IDS_STATUS_TIMEOUT_ENDED:
                            SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                            break;

                        case IDS_STATUS_FAXSVC_ENDED:
                            SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                            break;

                        case IDS_STATUS_ITERATION_STOPPED:
                            SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                            break;

                        case IDS_STATUS_RAS_FAILED:
                            SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                            break;

                    }

                    dwNumFaxesRemaining = dwNumFaxesToSend;

                    continue;
                }
            }

            // Encode the TSID
            if (!g_bNoCheck) {
                fnEncodeTsid(g_szRcvNumber, TX_CONTROL_CHARS, szEncodedTsid);
            }
            else {
                lstrcpy(szEncodedTsid, g_szSndNumber);
            }

            // Initialize FaxJobParams
            ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

            // Set FaxJobParams
            FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
            FaxJobParams.RecipientNumber = g_szSndNumber;
            FaxJobParams.RecipientName = g_szSndNumber;
            FaxJobParams.Tsid = szEncodedTsid;
            FaxJobParams.ScheduleAction = JSA_NOW;

            // Send a fax
            uRslt = fnSendFax(FaxJobParams, szOriginalTiffFile, hFaxStopSendPassFailEvents, dwSendTimeout);

            if (uRslt != IDS_STATUS_FAX_SEND_PASSED) {
                switch (uRslt) {
                    case IDS_STATUS_TIMEOUT_ENDED:
                        SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                        break;

                    case IDS_STATUS_FAXSVC_ENDED:
                        SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                        break;

                    case IDS_STATUS_ITERATION_STOPPED:
                        SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                        break;

                    case IDS_STATUS_FAX_SEND_FAILED:
                        SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                        break;

                }

                dwNumFaxesRemaining = dwNumFaxesToSend;

                continue;
            }
        }

        // Receive a fax
        uRslt = fnReceiveFax(hFaxStopRcvEvents, dwReceiveTimeout, szReceivedTsid, sizeof(szReceivedTsid) / sizeof(WCHAR), szCopyTiffFile, sizeof(szCopyTiffFile) / sizeof(WCHAR), szCopyTiffName, sizeof(szCopyTiffName) / sizeof(WCHAR));

        if (uRslt != IDS_STATUS_FAX_RECEIVED) {
            switch (uRslt) {
                case IDS_STATUS_TIMEOUT_ENDED:
                    SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                    break;

                case IDS_STATUS_ITERATION_STOPPED:
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    break;

            }

            if (g_bSend) {
                if (uRslt != IDS_STATUS_ITERATION_STOPPED) {
                    // This iteration failed
                    SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                }
                // Reset the number of faxes remaining to be sent
                dwNumFaxesRemaining = dwNumFaxesToSend;
            }

            continue;
        }

        if (!g_bNoCheck) {
            if (!fnDecodeTsid(szReceivedTsid, g_bSend ? RX_CONTROL_CHARS : TX_CONTROL_CHARS, szDecodedTsid)) {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_INVALID, 0);

                if (g_bSend) {
                    // This iteration failed
                    SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
                    // Reset the number of faxes remaining to be sent
                    dwNumFaxesRemaining = dwNumFaxesToSend;
                }
                else {
                    // Set the g_hStartEvent to start another cycle to receive a fax
                    SetEvent(g_hStartEvent);
                }

                continue;
            }

            // Update the status
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_ID, (LPARAM) szReceivedTsid);
            SendMessage(g_hWndDlg, UM_UPDATE_STATUS, IDS_STATUS_FAX_VERIFYING, (LPARAM) szCopyTiffName);

            // Verify the tiff
            uRslt = fnVerifyTiff(szCopyTiffFile, &dwPages);

            if ((uRslt == ERROR_SUCCESS) && (((g_bBVT) && (dwPages == FAXBVT_PAGES)) || ((!g_bBVT) && (dwPages == FAXWHQL_PAGES)))) {
                // Fax is valid
                uRslt = IDS_TIFF_VALID_TIFF;
            }
            else if (uRslt == ERROR_SUCCESS) {
                // Each page is valid, but missing pages
                uRslt = IDS_TIFF_INVALID_PAGES;
            }

            if (uRslt == IDS_TIFF_INVALID_PAGES) {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, uRslt, dwPages);
            }
            else {
                // Update the status
                SendMessage(g_hWndDlg, UM_UPDATE_STATUS, uRslt, 0);
            }

        }
        else {
            lstrcpy(szDecodedTsid, szReceivedTsid);
            uRslt = IDS_TIFF_VALID_TIFF;
        }

        if ((g_bSend) && (uRslt == IDS_TIFF_VALID_TIFF)) {
            // Decrement the number of faxes remaining to be sent
            dwNumFaxesRemaining--;

            if (dwNumFaxesRemaining == 0) {
                // All faxes have been sent, so this iteration passed
                SendMessage(g_hWndDlg, UM_ITERATION_PASSED, 0, 0);
                // Reset the number of faxes remaining to be sent
                dwNumFaxesRemaining = dwNumFaxesToSend;
            }
            else {
                // There are faxes remaining to be sent, so set the g_hStartEvent to start another cycle to send a fax
                SetEvent(g_hStartEvent);
            }

            continue;
        }
        else if (g_bSend) {
            // This iteration failed
            SendMessage(g_hWndDlg, UM_ITERATION_FAILED, 0, 0);
            // Reset the number of faxes remaining to be sent
            dwNumFaxesRemaining = dwNumFaxesToSend;

            continue;
        }
        else if (uRslt != IDS_TIFF_VALID_TIFF) {
            // Set the g_hStartEvent to start another cycle to receive a fax
            SetEvent(g_hStartEvent);

            continue;
        }

        if (!g_bSend) {
            // Encode the TSID
            if (!g_bNoCheck) {
                fnEncodeTsid(szDecodedTsid, RX_CONTROL_CHARS, szEncodedTsid);
            }
            else {
                lstrcpy(szEncodedTsid, szDecodedTsid);
            }

            // Initialize FaxJobParams
            ZeroMemory(&FaxJobParams, sizeof(FAX_JOB_PARAM));

            // Set FaxJobParams
            FaxJobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
            FaxJobParams.RecipientNumber = szDecodedTsid;
            FaxJobParams.RecipientName = szDecodedTsid;
            FaxJobParams.Tsid = szEncodedTsid;
            FaxJobParams.ScheduleAction = JSA_NOW;

            // Send a fax
            uRslt = fnSendFax(FaxJobParams, szCopyTiffFile, hFaxStopSendPassFailEvents, dwSendTimeout);

            switch (uRslt) {
                case IDS_STATUS_TIMEOUT_ENDED:
                    SendMessage(g_hWndDlg, UM_TIMEOUT_ENDED, 0, 0);
                    break;

                case IDS_STATUS_FAXSVC_ENDED:
                    SendMessage(g_hWndDlg, UM_FAXSVC_ENDED, 0, 0);
                    break;

                case IDS_STATUS_ITERATION_STOPPED:
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    break;

                case IDS_STATUS_FAX_SEND_PASSED:
                case IDS_STATUS_FAX_SEND_FAILED:
                    break;

            }

            if ((uRslt == IDS_STATUS_FAX_SEND_PASSED) || (uRslt == IDS_STATUS_FAX_SEND_FAILED)) {
                if (g_bBVT) {
                    SendMessage(g_hWndDlg, UM_ITERATION_STOPPED, 0, 0);
                    SendMessage(GetDlgItem(g_hWndDlg, IDC_EXIT_BUTTON), BM_CLICK, 0, 0);
                }
                else {
                    // Set the g_hStartEvent to start another cycle to wait for a fax
                    SetEvent(g_hStartEvent);
                }
            }

            continue;

        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\efsputil.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    efsputil.h

--*/

#ifndef _EFSPUTIL_H_
#define _EFSPUTIL_H_

typedef struct tag_FSPI_BRAND_INFO
{
    DWORD   dwSizeOfStruct;
    LPWSTR  lptstrSenderTsid;
    LPWSTR  lptstrRecipientPhoneNumber;
    LPWSTR  lptstrSenderCompany;
    SYSTEMTIME tmDateTime;
} FSPI_BRAND_INFO;

typedef const FSPI_BRAND_INFO * LPCFSPI_BRAND_INFO;
typedef FSPI_BRAND_INFO * LPFSPI_BRAND_INFO;


#ifdef __cplusplus
extern "C" {
#endif


HRESULT
WINAPI
FaxBrandDocument(
    LPCTSTR lpctstrFile,
    LPCFSPI_BRAND_INFO lpcBrandInfo
);

HRESULT
WINAPI
FaxRenderCoverPage(
  LPCTSTR lpctstrTargetFile,
  LPCFSPI_COVERPAGE_INFO lpCoverPageInfo,
  LPCFSPI_PERSONAL_PROFILE lpRecipientProfile,
  LPCFSPI_PERSONAL_PROFILE lpSenderProfile,
  SYSTEMTIME tmSentTime,
  LPCTSTR lpctstrBodyTiff
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\critsec.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CritSec.h

Abstract:

    This file provides declaration of the service
    Critical Section wrapper class.

Author:

    Oded Sacher (OdedS)  Nov, 2000

Revision History:

--*/

#ifndef _FAX_CRIT_SEC_H
#define _FAX_CRIT_SEC_H

#include "faxutil.h"


/************************************
*                                   *
*         CFaxCriticalSection        *
*                                   *
************************************/
class CFaxCriticalSection
{
public:
    CFaxCriticalSection () : m_bInit(FALSE) {}
    ~CFaxCriticalSection ()
    {
        SafeDelete();
        return;
    }

    BOOL Initialize ();
#if (_WIN32_WINNT >= 0x0403)
    BOOL InitializeAndSpinCount (DWORD dwSpinCount = (DWORD)0x10000000);
#endif
    VOID SafeDelete ();


#if DBG
    LONG LockCount() const
    {
        return m_CritSec.LockCount;
    }


    HANDLE OwningThread() const
    {
        return m_CritSec.OwningThread;
    }
#endif //#if DBG


    LPCRITICAL_SECTION operator & ()
    {
        return &m_CritSec;
    }


private:
    CRITICAL_SECTION m_CritSec;
    BOOL             m_bInit;
};  // CFaxCriticalSection

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\dapi.h ===
/*******************************************************************
 *
 * Copyright (c) Microsoft Corp. 1986-1996. All Rights Reserved.
 *
 *
 *    DESCRIPTION:   This header file defines the functions, structures,
 *                   and macros used to access the Microsoft Exchange
 *                   APIs for modifying entries in the Exchange 4.0 DIT.
 *                   These APIs permit a calling process to create, 
 *                   modify, or delete DIT objects by specifying the
 *                   name of a CSV text file containing attributes 
 *                   for objects to import into ( or to modify) 
 *                   the DIT.  See the Directory Access Functions
 *                   section of the Exchange Developer's Kit for 
 *                   more detailed description of this interface.
 *                   
 *                   Calling programs must link with DAPI.LIB.
 *                   
 *                   Error and warning codes are defined in DAPIMSG.H
 *
 *
 *******************************************************************/

/** include files **/
#ifndef _WINDOWS_
#include <windows.h>
#endif

/** local definitions **/

#ifndef  _DAPI_INCLUDED_
#define  _DAPI_INCLUDED_

#ifdef __cplusplus
extern "C"
{
#endif

// Import / Export APIs check for the presence of this signature in 
// the dwDAPISignature field in the import parameter blocks.
// This signature will be incremented each time one of the parameter
// blocks is changed so that header synchronization problems can be 
// detected.
#define  DAPI_SIGNATURE                   0x46414400


// Combinable flags used to control the API functions.

   // The following flags control filtering of DAPI events
   // The default action is DAPI_EVENT_ALL
#define DAPI_EVENT_MASK                   0x00000007  /* bit-field containing event-filtering requested 
                                                         if none of these bits are set, DAPI_EVENT_ALL is assumed */
#define DAPI_EVENT_MIN                    0x00000001  /* No warning or error logging.
                                                         Log start and stop messages */
#define DAPI_EVENT_SOME                   0x00000002  /* Start, Stop, and Error messages will be logged. */
#define DAPI_EVENT_ALL                    0x00000004  /* Start, Stop, Error, and Warning messages
                                                         will be logged. */
                                                         
   // The following flags control schema read and use of the schema
#define DAPI_FORCE_SCHEMA_LOAD            0x00000010  /* Unload previously loaded schema
                                                         and read schema again.
                                                         Default action is to re-use
                                                         previously loaded schema if read
                                                         from the same messaging domain */
#define DAPI_RAW_MODE                     0x00000020  /* Import / Export in "Raw" mode.  Import
                                                         lines are taken literally.  No
                                                         attributes will be inherited, 
                                                         constructed, etc.  Aliases for 
                                                         attribute and class names will
                                                         not be recognized. */
                                                         
#define DAPI_OVERRIDE_CONTAINER           0x00000040  /* Container specified in the parameter block
                                                         overrides the contents of the container column.
                                                         Default behaviour is for the value specified
                                                         in the Obj-Container column to override
                                                         that specified in the parameter block */
                                                 
#define DAPI_IMPORT_NO_ERR_FILE           0x00000080  /* Do not create Error File -- BatchImport only */
#define DAPI_IMPORT_WRITE_THROUGH         0x00400000  /* Commit write operations immediately */

// Flags defined for "Batch" operations only -- ignored by DAPIRead, DAPIWrite
#define DAPI_YES_TO_ALL                   0x00000100  /* Force "yes" response on any
                                                         user-prompt UI 
                                                         (i.e., continue w/o proxy addresses, etc.) */

#define DAPI_SUPPRESS_PROGRESS            0x00000200  /* Suppress progress thermometer on batch operations.
                                                         Default is to display progress */
#define DAPI_SUPPRESS_COMPLETION          0x00000400  /* Suppress completion notification message box on batch operations */
                                                         
#define DAPI_SUPPRESS_ARCHIVES            0x00000800  /* Suppress creation of "archive" copies
                                                         of output files -- BatchImport and BatchExport only*/
                                                         


// Flags defined for BatchExport
#define DAPI_EXPORT_MAILBOX               0x00001000  /* Export Mailbox recipients */
#define DAPI_EXPORT_CUSTOM                0x00002000  /* Export remote address recipients */
#define DAPI_EXPORT_DIST_LIST             0x00004000  /* Export Distribution Lists */
#define DAPI_EXPORT_RECIPIENTS       (DAPI_EXPORT_MAILBOX | DAPI_EXPORT_CUSTOM | DAPI_EXPORT_DIST_LIST)
                                                      /* Export all recipient objects */

#define DAPI_EXPORT_ALL_CLASSES           0x00008000  /* If this flag is set, all objects meeting other restrictions
                                                         (i.e., USN level, container scope, etc.) will be exported,
                                                         regardless of class */

#define DAPI_EXPORT_HIDDEN                0x00010000  /* Include Hidden objects in export.
                                                                      Default is no export if Hide-From-Address-Book */
#define DAPI_EXPORT_SUBTREE               0x00020000  /* Traverse the Directory Information Tree hierarchy,
                                                         exporting objects that meet the export restrictions */
#define DAPI_EXPORT_BASEPOINT_ONLY        0x00040000  /* Export only the requested attributes from
                                                         the named BasePoint object.  All other 
                                                         export restrictions are ignored (class flags, 
                                                         rgpszClasses, pszServerName). 
                                                         This flag implies DAPI_SUPPRESS_PROGRESS
                                                         and DAPI_SUPPRESS_COMPLETION */

// Flags defined only for BatchImport
#define DAPI_OVERRIDE_SYNCH_STATE         0x00080000  /* Override server's synchronization status,
                                                         normally checked on BatchImport.
                                                         NOTE:  This flag should normally NOT be set.
                                                                The normal behaviour is to prevent BatchImport
                                                                operations from possible conflict with directory
                                                                synchronization */


// Flags defined only for DAPIRead                                                         
#define  DAPI_READ_DEFINED_ATTRIBUTES     0x00100000  /* return all attributes that are set
                                                         for the current object. 
                                                         This flag is ignored if pAttributes is specified. */

#define  DAPI_READ_ALL_ATTRIBUTES         0x00200000  /* return all attributes that are defined
                                                         for the class of the current object. 
                                                         This flag is ignored if pAttributes is specified. */


 // The following flags control NT Security management
#define DAPI_RESTRICT_ACCESS              0x01000000  /* Apply NT Security Descriptor to 
                                                         created objects */
#define DAPI_CREATE_NT_ACCOUNT            0x02000000  /* Create NT accounts 
                                                         (valid only in Create/Modify mode) */
#define DAPI_CREATE_RANDOM_PASSWORD       0x04000000  /* Generate random passwords for
                                                         created NT accounts.  Ignored if DAPI_CREATE_NT_ACCOUNT
                                                         is not set */
                                                         
#define DAPI_DELETE_NT_ACCOUNT            0x08000000  /* Delete ASSOC-NT-ACCOUNT when
                                                         deleting mailbox */
// Flags defined only for DAPIWrite
#define DAPI_MODIFY_REPLACE_PROPERTIES    0x00800000  /* Append values to multi-value attributes when modifying */

#define  DAPI_WRITE_UPDATE                0x10000000  /* Modify if object exists, create if it doesn't.
                                                         NOTE:  This is the default mode */
#define  DAPI_WRITE_CREATE                0x20000000  /* Create object -- fail if object exists */
#define  DAPI_WRITE_MODIFY                0x30000000  /* Modify object -- fail if object does not exist */
#define  DAPI_WRITE_DELETE                0x40000000  /* Delete object */
#define  DAPI_WRITE_MODE_MASK             0x70000000



// Callback flags
#define  DAPI_CALLBACK_CHAIN              0x00000001  /* If set in dwFlags field of the ERROR_CALLBACK
                                                         and the CALLBACKPROGRESS structures, the default
                                                         handler will be invoked after calling out to the 
                                                         caller-supplied handler function, unless the user
                                                         function returns FALSE, indicating cancel.
                                                         NOTE:  This flag is not defined for the EXPORT_CALLBACK
                                                                structure.
                                                         NOTE:  This flag should not be set in the dwFlags
                                                                field of the main parameter block */


// default delimiter values used when parsing the import file

#define DAPI_DEFAULT_DELIMA   ','
#define DAPI_DEFAULT_QUOTEA   '"'
#define DAPI_DEFAULT_MV_SEPA  '%'
#define DAPI_DEFAULT_DELIMW   L','
#define DAPI_DEFAULT_QUOTEW   L'"'
#define DAPI_DEFAULT_MV_SEPW  L'%'


#define DAPI_CTRL_FILE_PTRA   '='
#define DAPI_CTRL_FILE_PTRW   L'='
#define DAPI_CTRL_META_CHARA  '~'
#define DAPI_CTRL_META_CHARW  L'~'
#define pszSubstServerA       "~SERVER"
#define pszSubstServerW       L"~SERVER"
#define cchSubstServer        ((sizeof (pszSubstServerA) / sizeof(CHAR)) - 1)
#define pszDeleteKeyA         "~DEL"
#define pszDeleteKeyW         L"~DEL"
#define cchDeleteKey          ((sizeof (pszDeleteKeyA) / sizeof(CHAR)) - 1)

#define DAPI_UNICODE_FILE     ((UINT)-1)

#ifdef UNICODE

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMW
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEW
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPW
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRW
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARW
#define pszSubstServer        pszSubstServerW
#define pszDeleteKey          pszDeleteKeyW

#else

#define DAPI_DEFAULT_DELIM    DAPI_DEFAULT_DELIMA
#define DAPI_DEFAULT_QUOTE    DAPI_DEFAULT_QUOTEA
#define DAPI_DEFAULT_MV_SEP   DAPI_DEFAULT_MV_SEPA
#define DAPI_CTRL_FILE_PTR    DAPI_CTRL_FILE_PTRA
#define DAPI_CTRL_META_CHAR   DAPI_CTRL_META_CHARA
#define pszSubstServer        pszSubstServerA
#define pszDeleteKey          pszDeleteKeyA

#endif


/*******************************************************************************
* Batch Operation Progress Callback Function Definitions
* Pointers to functions of these types are provided by the caller via the 
* CALLBACKPROGRESS structure in the Batch function parameter block
*               
********************************************************************************
*               
*  procedure :  PDAPI_FInitProgress
*               
*    purpose :  Initialize progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FResetProgress
*               
*    purpose :  Re-initialize progress handler (possibly reset progress bar)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               nMac          Maximum Anticipated Calls.  If non-zero, this indicates
*                             the number of progress events anticipated.
*                             If zero, the number of items to process is unknown,
*                             so the number of calls to UpdateProgress is indeterminate.
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not re-initialize progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FEndProgress
*               
*    purpose :  Terminate progress handler (possibly progress display dialog)
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Could not terminate progress handler, cancel session.
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgress
*               
*    purpose :  Completed processing item.  Called to indicate time to increment
*               progress display.
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************
*               
*  procedure :  PDAPI_FUpdateProgressText
*               
*    purpose :  Replace progress text area with provided text string
*               
* parameters :  lpvAppDefined value provided in the progress callback structure
*               
*    returns :  TRUE    Indicates that all is well
*               FALSE   Cancel session (i.e., cancel button pressed).
*               
********************************************************************************/
typedef BOOL (PASCAL * PDAPI_FInitProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FEndProgress)
                          (LPVOID lpvAppDefined);
typedef BOOL (PASCAL * PDAPI_FResetProgress)
                          (LPVOID lpvAppDefined, INT nMac);
typedef BOOL (PASCAL * PDAPI_FUpdateProgressText)
                          (LPVOID lpvAppDefined, LPTSTR pszText);
            
typedef struct CallBackProgressEntryPoints
{
   DWORD                      dwFlags;
   LPVOID                     lpvAppDefined;
   PDAPI_FInitProgress        pfnInitProgress;
   PDAPI_FUpdateProgress      pfnUpdateProgress;
   PDAPI_FEndProgress         pfnEndProgress;
   PDAPI_FResetProgress       pfnResetProgress;
   PDAPI_FUpdateProgressText  pfnUpdateProgressText;
} CALLBACKPROGRESS, *PCALLBACKPROGRESS;



// Values specified in the ulEvalTag field of the 
//    DAPI_ENTRY and EXPORT_CALLBACK structures
//    
typedef enum _DAPI_EVAL
{
   VALUE_ARRAY = 0,           // Each attribute has an entry in the array
                              //    Text strings and object names exported as text
                              //    Numerical values exported as numbers
                              //    Binary data exported as binary string
   TEXT_VALUE_ARRAY,          // Each attribute has an entry in the array
                              //    All values converted to text representation
   TEXT_LINE                  // first item in the rgEntryValues array
                              //    is a delimited text line
} DAPI_EVAL, *PDAPI_EVAL;

typedef enum _EXP_TYPE_TAG
{
   EXPORT_HEADER = 0,         // export item contains column headers
   EXPORT_ENTRY               // export item contains attribute values
} EXP_TYPE, * PEXP_TYPE;


typedef enum enumDAPI_DATA_TYPE
{
   DAPI_NO_VALUE = 0,
   DAPI_STRING8,
   DAPI_UNICODE,
   DAPI_BINARY,
   DAPI_INT,
   DAPI_BOOL,
} DAPI_DATA_TYPE, * PDAPI_DATA_TYPE;

#ifdef UNICODE
#define DAPI_TEXT DAPI_UNICODE
#else
#define DAPI_TEXT DAPI_STRING8
#endif

typedef union _DAPI_VALUE
{
   LPSTR    pszA;
   LPWSTR   pszW;
#ifdef UNICODE
   LPWSTR   pszValue;
#else
   LPSTR    pszValue;
#endif
   LPBYTE   lpBinary;
   INT      iValue;
   BOOL     bool;
} DAPI_VALUE, * PDAPI_VALUE;



// The ATT_VALUE structure contains a text representation of an attribute value
// A linked list of these structures is used for a multi-valued attribute
typedef struct _ATT_VALUE
{
   DAPI_DATA_TYPE       DapiType;         // How to evaluate DAPI_VALUE union
   DAPI_VALUE           Value;
   UINT                 size;             // size of the value -- 
                                          //    # chars if string type
                                          //    else, # bytes
   struct _ATT_VALUE *  pNextValue;
} ATT_VALUE, * PATT_VALUE;


typedef struct _DAPI_ENTRY
{
   UINT           unAttributes;              // Number of attributes exported
   DAPI_EVAL      ulEvalTag;                 // rgEntryValues is interpreted based on this value
   PATT_VALUE     rgEntryValues;             // if (ulEvalTag == TEXT_LINE)
                                             //    There is a single value, w/ delimited line
                                             // else
                                             //    unAttributes, each w/ 1 or more value in list
} DAPI_ENTRY, * PDAPI_ENTRY;

// Define type for address of application routine 
// for call-back on each exported entry.
// Return value of FALSE indicates that export operation should be cancelled
typedef BOOL (PASCAL DAPI_FNExportEntry) (
               EXP_TYPE    ExportDataType,   // What type of data is being exported
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_ENTRY pExportEntry      // pointer to exported entry data
                                             // NOTE: Data in this structure
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNExportEntry * PDAPI_FNExportEntry;

typedef struct _EXPORT_CALLBACK
{
   DWORD       dwFlags;                      // Flags defined to control callback functionality
                                             // See flag definitions below
   DAPI_EVAL   ulEvalTag;                    // Specifies data format on callback
   LPVOID      lpvAppDefined;                // Application-defined field, passed as parm to callback
   PDAPI_FNExportEntry  pfnExportEntry;      // Pointer to function called to process
                                             // each exported entry

} EXPORT_CALLBACK, * PEXPORT_CALLBACK;



/*******************************************************************************
*  procedure :  pfnErrorCallback
*               
*    purpose :  The following section defines structures for the error callback
*               mechanism of the Batch Import APIs
*               Events will be filtered based on the ControlfFlags set in the 
*               API parameter block
*               
********************************************************************************/

// Define flags used for export callback

// Define the maximum number of substitutions in a single event string
#define DAPI_MAX_SUBST 8


typedef struct _DAPI_EVENTA
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPSTR             rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPSTR             pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPSTR             pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTA * pNextEvent;       // Pointer to next event
} DAPI_EVENTA, *PDAPI_EVENTA;

typedef struct _DAPI_EVENTW
{
   DWORD             dwDAPIError;            // Message ID for event log
   LPWSTR            rgpszSubst[DAPI_MAX_SUBST];   // Event message substitution array
   UINT              unSubst;                // number of substitution strings
   LPWSTR            pszAttribute;           // Name of attribute specifically affected
                                             //    Note:  may be NULL on some errors
   LPWSTR            pszHoldLine;            // point to buffer containing copy
                                             //    of current import line
   HINSTANCE         hinstDAPI;              // Instance of DAPI DLL
   struct _DAPI_EVENTW * pNextEvent;       // Pointer to next event
} DAPI_EVENTW, *PDAPI_EVENTW;

#ifdef UNICODE
typedef DAPI_EVENTW  DAPI_EVENT;
typedef PDAPI_EVENTW PDAPI_EVENT;
#else
typedef DAPI_EVENTA  DAPI_EVENT;
typedef PDAPI_EVENTA PDAPI_EVENT;
#endif

// Define type for address of application routine 
// for call-back on each error encountered.
// Return value of FALSE indicates that operation should be cancelled
typedef BOOL (PASCAL DAPI_FNErrorCallback) (
               LPVOID      lpvAppDefined,    // Application-defined parameter,
                                             // passed in EXPORT_CALLBACK structure
                                             // on initialization
               PDAPI_EVENT pDapiEvent        // Event information structure
                                             // NOTE: Data in the event record
                                             // will NOT remain valid after return
                                             // from this function
               );
typedef DAPI_FNErrorCallback * PDAPI_FNErrorCallback;


typedef struct tagERROR_CALLBACK
{
   DWORD                   dwFlags;          // Flags defined to control callback functionality
                                             // See flag definitions above
   LPVOID                  lpvAppDefined;    // Application-defined field, passed back in callback
   PDAPI_FNErrorCallback   pfnErrorCallback; // Address of function that should be
                                             // called on each error encountered
                                             // If not supplied (NULL), default
                                             // error handler is called, which
                                             // writes the error into the 
                                             // NT Application event log

} ERROR_CALLBACK, * PERROR_CALLBACK;





/*******************************************************************************
*  
*   Batch Directory Import Interface definitions
*               
********************************************************************************/

/*******************************************************************************
*  procedure :  DAPIUninitialize
*               
*    purpose :  Notify DAPI that it is time to terminate background threads
*               and such in preparation for process shutdown
*               
* parameters :  dwFlags		combinable bits which may be set to control function
*               
*    returns :  nothing
*               
*    created :  11/01/95 
*               
*    changes :  
*               
********************************************************************************/
extern void APIENTRY DAPIUninitialize (
                              DWORD    dwFlags // Flags for call
);



/*******************************************************************************
*  procedure :  SchemaPreload
*               
*    purpose :  Called to perform asyncronous schema load.  This entry point
*               spawns a thread that initializes all the attribute and class
*               tables for normal import/export operation.
*               
* parameters :  pSchemaPreloadParms    pointer to SchemaPreloadParameter block
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY SchemaPreloadA (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPSTR    pszDSA   // name of DSA from which to read schema
);

extern void APIENTRY SchemaPreloadW (
                              DWORD    dwFlags, // Flags used to control schema load.
                              LPWSTR   pszDSA   // name of DSA from which to read schema
);

#ifdef UNICODE
#define  SchemaPreload  SchemaPreloadW
#else
#define  SchemaPreload  SchemaPreloadA
#endif

typedef struct _BIMPORT_PARMSW
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;                // Windows handle to use when displaying message boxes
   LPWSTR   pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   WCHAR    chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR    chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR    chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR    creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPWSTR   pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPWSTR   pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSW, *PBIMPORT_PARMSW, *LPBIMPORT_PARMSW;

typedef struct _BIMPORT_PARMSA
{
   // NOTE:  the order of the first three fields of this structure 
   //       should NOT be changed.
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszImportFile;       // Fully qualified pathname to Import Data file
                                 //   On Batch Import, objects are imported into
                                 //   the DIT from this file.
   UINT     uCodePage;           // Code page specification for import file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Import file is Unicode
                                 //                        Will return error if file is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If ANSI, assume CP_ACP
                                 // other                File contains text in the
                                 //                        specified code page
                                 //                        Will return error if file is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     creserved;           // alignment
   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup / create NT accounts.
                                 //    Defaults to current logon domain if NULL or empty
   LPSTR    pszCreateTemplate;   // DN of the Default User (NULL if none) from which
                                 //    to draw template values

} BIMPORT_PARMSA, *PBIMPORT_PARMSA, *LPBIMPORT_PARMSA;

#ifdef UNICODE
typedef  BIMPORT_PARMSW    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSW   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSW  LPBIMPORT_PARMS;
#else
typedef  BIMPORT_PARMSA    BIMPORT_PARMS;
typedef  PBIMPORT_PARMSA   PBIMPORT_PARMS;
typedef  LPBIMPORT_PARMSA  LPBIMPORT_PARMS;
#endif

// The BatchImport function provides single-call BatchImport from the
//    specified import file.  All import parameters are specified in the
//    BIMPORT_PARMS structure pointed to by lpBimportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Import.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD APIENTRY BatchImportW (LPBIMPORT_PARMSW lpBimportParms);
extern DWORD APIENTRY BatchImportA (LPBIMPORT_PARMSA lpBimportParms);

#ifdef UNICODE
#define BatchImport        BatchImportW
#else
#define BatchImport        BatchImportA
#endif

/*******************************************************************************
*  
*   Batch Directory Export Interface definitions
*               
********************************************************************************/

typedef struct _BEXPORT_PARMSW
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPWSTR   pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPWSTR   pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR   pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR   pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   WCHAR     chColSep;           // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   WCHAR     chQuote;            // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   WCHAR     chMVSep;            // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   WCHAR     cReserved;          // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes;      // DAPI_ENTRY filled with names of attributes to export
                                       // Optional if pszExportFile specified
                                       // Required if ExportCallback specified
   LPWSTR   pszHomeServer;       // Name of server for server-associated export
   LPWSTR * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSW, *PBEXPORT_PARMSW, *LPBEXPORT_PARMSW;

typedef struct _BEXPORT_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control export action
   HWND     hwndParent;          // Windows handle to use when displaying message boxes
   LPSTR    pszExportFile;       // Fully qualified pathname of file to export into
                                 //   Ignored if ExportCallback is specified
   UINT     uCodePage;           // Code page specification for export file.
                                 // The following values are interpreted:
                                 // DAPI_UNICODE_FILE    Export file is Unicode.
                                 //                      Will return error 
                                 //                        if file exists and is ANSI
                                 // 0                    Auto-detect file type
                                 //                        If file does not exist,
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is ANSI
                                 //                          export file will contain CP_ACP text.
                                 //                        If file exists and is Unicode,
                                 //                          export file will contain Unicode
                                 // other                Export text to file in the
                                 //                        specified code page
                                 //                      Will return error 
                                 //                        if file exists and is Unicode
                                 //                      Will return error if code page is not
                                 //                        supported by the system
   LPSTR    pszDSAName;          // Computer name of DSA from which to export
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of container from which to export objects
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          the contents of all containers below
                                 //          the BaseImportPoint will be exported.
   CHAR     chColSep;            // Column Separator -- 
                                 //    DEFAULT_DELIM is used if this value is zero
   CHAR     chQuote;             // String enclosing character -- 
                                 //    DEFAULT_QUOTE is used if this value is zero
   CHAR     chMVSep;             // Multi-value Property Separator --
                                 //    DEFAULT_MV_SEP is used if this value is zero
   CHAR     cReserved;           // alignment

   CALLBACKPROGRESS  ProgressCallBacks;    // Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   PDAPI_ENTRY       pAttributes; // DAPI_ENTRY filled with names of attributes to export
                                        // Optional if pszExportFile specified
                                        // Required if ExportCallback specified
   LPSTR    pszHomeServer;       // Name of server for server-associated export
   LPSTR  * rgpszClasses;        // array of pointers to zero-terminated object classes to export
                                 // The last entry must be NULL
                                 // NOTE:  The Directory will be queried for objects
                                 //          of the classes in the specified order.
   ULONG       ulUSNBase;        // Base USN to use for export restriction.  
                                 //    If non-zero, only items having USN-Changed >= ulUSNBase will be exported
   LPVOID      pReserved;        // Reserved -- Must be zero
   
} BEXPORT_PARMSA, *PBEXPORT_PARMSA, *LPBEXPORT_PARMSA;


#ifdef UNICODE
typedef  BEXPORT_PARMSW    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSW   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSW  LPBEXPORT_PARMS;
#else
typedef  BEXPORT_PARMSA    BEXPORT_PARMS;
typedef  PBEXPORT_PARMSA   PBEXPORT_PARMS;
typedef  LPBEXPORT_PARMSA  LPBEXPORT_PARMS;
#endif



// Batch Export entry points

// The BatchExport function provides single-call BatchExport from the
//    specified import file.  All import parameters are specified in the
//    BEXPORT_PARMS structure pointed to by lpBexportParms.
//    The return value indicates the number of errors logged in the
//    NT Application log.  Please note that this does not indicate
//    success or failure of the Batch Export.
//    UI and Logging of errors and warnings into the Application log 
//    are controlled through import parameters.
extern DWORD   APIENTRY BatchExportW (LPBEXPORT_PARMSW lpBexportParms);
extern DWORD   APIENTRY BatchExportA (LPBEXPORT_PARMSA lpBexportParms);

#ifdef UNICODE
#define BatchExport     BatchExportW
#else
#define BatchExport     BatchExportA
#endif


/*******************************************************************************
*  
*  Single-Object Interface definitions             
*               
********************************************************************************/

typedef struct _DAPI_PARMSW
{
   DWORD        dwDAPISignature;
   DWORD        dwFlags;         // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPWSTR       pszDSAName;      // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPWSTR       pszBasePoint;    // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPWSTR       pszContainer;    // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPWSTR       pszNTDomain;     // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPWSTR       pszCreateTemplate;// DN of the template object used for default values
   PDAPI_ENTRY  pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSW, *PDAPI_PARMSW, FAR *LPDAPI_PARMSW;

typedef struct _DAPI_PARMSA
{
   DWORD    dwDAPISignature;
   DWORD    dwFlags;             // Bitmapped flags that control import action
                                 //    See Import Control flags defined above.
   LPSTR    pszDSAName;          // Computer name of DSA to update
                                 //    Default:  local DSA (if operating)
                                 //              if no local DSA, first DSA found 
                                 //              on network is used
   LPSTR    pszBasePoint;        // DN of base-point in DIT for bulk operations
                                 //    Default values:
                                 //       if NULL, Messaging Site containing bound server
                                 //       if empty string, enterprise containing bound server
   LPSTR    pszContainer;        // RDN of default container under which
                                 //    to perform bulk import operations
                                 //    NOTE:  This container is assumed to be
                                 //          at the level below that indicated by
                                 //          the pszBasePoint.  If NULL, 
                                 //          bulk operations will be performed at
                                 //          the level below BaseImportPoint.
                                 //          Container names specified in the 
                                 //          import file will override this value.
   LPSTR    pszNTDomain;         // Name of NT Domain in which to lookup accounts
                                 //   and to create NT accounts.
                                 //   Current logon domain is used if NULL or empty string.
   LPSTR    pszCreateTemplate;   // DN of the template object used for default values
   PDAPI_ENTRY   pAttributes;    // DAPI_ENTRY filled with default attribute list
} DAPI_PARMSA, *PDAPI_PARMSA, FAR *LPDAPI_PARMSA;


#ifdef UNICODE
typedef  DAPI_PARMSW    DAPI_PARMS;
typedef  PDAPI_PARMSW   PDAPI_PARMS;
typedef  LPDAPI_PARMSW  LPDAPI_PARMS;
#else
typedef  DAPI_PARMSA    DAPI_PARMS;
typedef  PDAPI_PARMSA   PDAPI_PARMS;
typedef  LPDAPI_PARMSA  LPDAPI_PARMS;
#endif


typedef  LPVOID   DAPI_HANDLE;
typedef  LPVOID * PDAPI_HANDLE;
typedef  LPVOID FAR * LPDAPI_HANDLE;

#define  DAPI_INVALID_HANDLE  ((DAPI_HANDLE) -1)



// DAPIStart initializes a DAPI session.
//    for use by DAPIRead and DAPIWrite.  The return value is 0 if no errors
//    are encountered.  A pointer to a DAPI_EVENT structure is returned if an 
//    error is encountered.  
//    NOTE:  The DAPI_HANDLE must be returned via a call to DAPIEnd.
//           If a non-NULL value is returned, its memory must be freed by
//           a call to DAPIFreeMemory
extern PDAPI_EVENTW APIENTRY DAPIStartW  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSW     lpDAPIParms);
extern PDAPI_EVENTA APIENTRY DAPIStartA  (LPDAPI_HANDLE    lphDAPISession,
                                          LPDAPI_PARMSA     lpDAPIParms);

#ifdef UNICODE
#define DAPIStart    DAPIStartW
#else
#define DAPIStart    DAPIStartA
#endif

// DAPIEnd invalidates the DAPI_HANDLE obtained by the call to DAPIStart.
//    NOTE:  There are no separate Unicode / Ansi entry points defined 
extern   void  APIENTRY DAPIEnd (LPDAPI_HANDLE lphDAPISession);


// DAPIRead() Reads indicated attributes from the named Directory Object
// Parameters:  
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        control operation
//    pszObjectName  String containing name of object to read.
//                      If specified as RDN, combined w/ session's
//                      pszBasePoint and pszParentContainer.
//                      If specified w/ prefix of "/cn=", the string 
//                      is concatenated to the session pszBasePoint.
//                      If specified w/ prefix of "/o=", the string
//                      is taken to be a fully-qualified DN.
//    pAttList       Pointer to DAPI_ENTRY structure containing names of
//                      attributes to read.  The session default list is
//                      overridden for the present call only.
//    ppValues       Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the values read from the DIT entry.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
//    ppAttributes   Address of variable receiving pointer to DAPI_ENTRY
//                      structure containing the names of attributes read
//                      from the DIT IFF DAPI_ALL_ATTRIBUTES or DAPI_LEGAL_ATTRIBUTES
//                      were set in dwFlags.
//                      The pointer returned must be freed by call to 
//                      DAPIFreeMemory.
extern PDAPI_EVENTW APIENTRY DAPIReadW   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPWSTR         pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);
extern PDAPI_EVENTA APIENTRY DAPIReadA   (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             LPSTR          pszObjectName,
                                             PDAPI_ENTRY    pAttList,
                                             PDAPI_ENTRY *  ppValues,
                                             PDAPI_ENTRY *  ppAttributes);

#ifdef UNICODE
#define DAPIRead     DAPIReadW
#else
#define DAPIRead     DAPIReadA
#endif


// DAPIWrite() 
//   Perform the indicated write operation on the named object
// Returned value:   NULL indicates no difficulties encountered.
//                   Else, pointer to structure containing description of 
//                      error(s) or warning(s) encountered.
//                      Must be freed by call to DAPIFreeMemory.
// Parameters:  
//    hDAPISession   DAPI Session handle obtained via InitDAPISession
//    dwFlags        Operational control
//    pAttributes   Pointer to DAPI_ENTRY structure containing names of
//                      attributes to write.  The session default list is
//                      used if this parameter is NULL
//    pValues        Pointer to DAPI_ENTRY structure containing the values 
//                      to set on the DIT entry.
//    lpulUSN         Optional:  Address of variable receiving USN of updated
//                      DIT entry.  May be specified as NULL to suppress this
//                      return value.
//    lppszCreatedAccount  Address receiving pointer to name of created NT account
//    lppszPassword  Address receiving pointer to password generated if
//                      NT Account is created. 
extern PDAPI_EVENTW APIENTRY DAPIWriteW (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPWSTR *       lppszCreatedAccount,
                                             LPWSTR *       lppszPassword);
extern PDAPI_EVENTA APIENTRY DAPIWriteA (DAPI_HANDLE        hDAPISession,
                                             DWORD          dwFlags,
                                             PDAPI_ENTRY    pAttributes,
                                             PDAPI_ENTRY    pValues,
                                             PULONG         lpulUSN,
                                             LPSTR *        lppszCreatedAccount,
                                             LPSTR *        lppszPassword);
#ifdef UNICODE
#define DAPIWrite      DAPIWriteW
#else
#define DAPIWrite      DAPIWriteA
#endif


/*******************************************************************************
*  procedure :  DAPIAllocBuffer
*               
*    purpose :  Allocate buffer, logically linking it to the pvAllocBase
*               The first buffer in logically linked set of allocations must be 
*               freed by call to DAPIFreeMemory
*               
* parameters :  cbSize		dword containing size of allocation request (in bytes)
*               pvAllocBase	base for logical linking of allocated block
*                             May be NULL
*                             If non-NULL, must be a block previously allocated
*                             by DAPIAllocBuffer or returned by DAPI function
*               
*    returns :  ptr to allocated block
*               
*    history :  
*               
********************************************************************************/
extern LPVOID APIENTRY DAPIAllocBuffer (DWORD	cbSize, LPVOID	pvAllocBase);


/*******************************************************************************
*  procedure :  DAPIFreeMemory
*               
*    purpose :  Release memory allocated for structures returned by DAPI calls.
*               
* parameters :  lpVoid  pointer to block to free
*               
*    returns :  nothing
*               
*    history :  
*               
********************************************************************************/
extern void APIENTRY DAPIFreeMemory (LPVOID   lpVoid);


/* 
 * NetUserList interface definitions
 */
// When getting callbacks from NTExport / NWExport, these indices
// can be used to interpret the value array returned in the callback
// >>>>    NOTE:  These indices are NOT valid for Bexport callback!    <<<<
#define  NET_CLASS         0
#define  NET_COMMON_NAME   1
#define  NET_DISPLAY_NAME  2
#define  NET_HOME_SERVER   3
#define  NET_COMMENT       4     /* NTExport only */

#define  NTEXP_ENTRY_COUNT 5 /* number of parts in NT User export */
#define  NWEXP_ENTRY_COUNT 4 /* number of parts in NetWare user export */



/*******************************************************************************
*  
* NTIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NTEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszDCName;        // Name of Domain Controller from which to get users
                                       // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
   LPWSTR            pszNTDomain;      // Name of Domain from which to read users
                                       // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
} NTEXPORT_PARMSW, *PNTEXPORT_PARMSW, FAR *LPNTEXPORT_PARMSW;

typedef struct _NTEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszDCName;        // NOTE:  Specification of Domain Controller overrides
                                       //        the NTDomain
                                       // Name of Domain from which to read users
   LPSTR             pszNTDomain;      // If neither pszNTDomain and pszDCName are specified,
                                       //   users are extracted from the current login domain
                                       
} NTEXPORT_PARMSA, *PNTEXPORT_PARMSA, FAR *LPNTEXPORT_PARMSA;

#ifdef UNICODE
typedef  NTEXPORT_PARMSW      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSW     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSW    LPNTEXPORT_PARMS;
#else
typedef  NTEXPORT_PARMSA      NTEXPORT_PARMS;
typedef  PNTEXPORT_PARMSA     PNTEXPORT_PARMS;
typedef  LPNTEXPORT_PARMSA    LPNTEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NTExportW (LPNTEXPORT_PARMSW pNTExportParms);
extern   DWORD APIENTRY    NTExportA (LPNTEXPORT_PARMSA pNTExportParms);

#ifdef UNICODE
#define NTExport              NTExportW
#else
#define NTExport              NTExportA
#endif


/*******************************************************************************
*  
* NWIMPORT Interface definitions
*               
********************************************************************************/

typedef struct _NWEXPORT_PARMSW
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPWSTR            pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPWSTR            pszFileServer;    // Name of the file server to connect to
   LPWSTR            pszUserName;      // User Name -- Must have administrator priviliges
   LPWSTR            pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSW, *PNWEXPORT_PARMSW, *LPNWEXPORT_PARMSW;

typedef struct _NWEXPORT_PARMSA
{
   DWORD             dwDAPISignature;
   DWORD             dwFlags;          // Bitmapped flags that control the user export
   HWND              hwndParent;       // Windows handle to use when displaying message boxes
   LPSTR             pszExportFile;    // Name of file to create
                                       //   Ignored if using callbacks
   CALLBACKPROGRESS  ProgressCallBacks;// Progress call-back entry points
   ERROR_CALLBACK    ErrorCallback;
   EXPORT_CALLBACK   ExportCallback;   // Structure filled in by calling app to 
                                       // receive callback on each exported item
                                       // NOTE:  Callback functions are optional
                                       // The default export function (write to file)
                                       // will be called if these pointers are NULL
   LPSTR             pszFileServer;    // Name of the file server to connect to
   LPSTR             pszUserName;      // User Name -- Must have administrator priviliges
   LPSTR             pszPassword;      // Password to connect to the server
} NWEXPORT_PARMSA, *PNWEXPORT_PARMSA, *LPNWEXPORT_PARMSA;

#ifdef UNICODE
typedef  NWEXPORT_PARMSW      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSW     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSW    LPNWEXPORT_PARMS;
#else
typedef  NWEXPORT_PARMSA      NWEXPORT_PARMS;
typedef  PNWEXPORT_PARMSA     PNWEXPORT_PARMS;
typedef  LPNWEXPORT_PARMSA    LPNWEXPORT_PARMS;
#endif

extern   DWORD APIENTRY    NWExportW (LPNWEXPORT_PARMSW pNWExportParms);
extern   DWORD APIENTRY    NWExportA (LPNWEXPORT_PARMSA pNWExportParms);

#ifdef UNICODE
#define NWExport              NWExportW
#else
#define NWExport              NWExportA
#endif


// Definitions for the DAPIGetSiteInfo call

typedef struct _NAME_INFOA
{
   LPSTR    pszName;                            // Simple object name
   LPSTR    pszDNString;                        // DN of object
   LPSTR    pszDisplayName;                     // Display name of object
} NAME_INFOA, *PNAME_INFOA;

typedef struct _NAME_INFOW
{
   LPWSTR   pszName;                            // Simple object name
   LPWSTR   pszDNString;                        // DN of object
   LPWSTR   pszDisplayName;                     // Display name of object
} NAME_INFOW, *PNAME_INFOW;

typedef struct _PSITE_INFOA
{
   LPSTR       pszCountry;                      // Country code
   NAME_INFOA  objServer;                       // Name information for server
   NAME_INFOA  objSite;                         // Name information for site containing server
   NAME_INFOA  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOA, *PSITE_INFOA;

typedef struct _PSITE_INFOW
{
   LPWSTR      pszCountry;                      // Country code
   NAME_INFOW  objServer;                       // Name information for server
   NAME_INFOW  objSite;                         // Name information for site containing server
   NAME_INFOW  objEnterprise;                   // Name information for enterprise containing server
} SITE_INFOW, *PSITE_INFOW;

#ifdef UNICODE
typedef  NAME_INFOW        NAME_INFO;
typedef  PNAME_INFOW       PNAME_INFO;
typedef  SITE_INFOW        SITE_INFO;
typedef  PSITE_INFOW       PSITE_INFO;
#else
typedef  NAME_INFOA        NAME_INFO;
typedef  PNAME_INFOA       PNAME_INFO;
typedef  SITE_INFOA        SITE_INFO;
typedef  PSITE_INFOA       PSITE_INFO;
#endif

extern PDAPI_EVENTA APIENTRY DAPIGetSiteInfoA (
                              DWORD    dwFlags,                // Flags for request
                              LPSTR    pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOA *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return data
);

extern PDAPI_EVENTW APIENTRY DAPIGetSiteInfoW (
                              DWORD    dwFlags,                // Flags for request
                              LPWSTR   pszDSA,                 // name of DSA from which to get information
                              PSITE_INFOW *   ppSiteInfo       // Address receiving pointer to pSiteInfo structure
                                                               // containing return dataname of DSA from which to read schema
);

#ifdef UNICODE
#define  DAPIGetSiteInfo DAPIGetSiteInfoW
#else
#define  DAPIGetSiteInfo DAPIGetSiteInfoA
#endif



#ifdef __cplusplus
}
#endif

#endif   // _DAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\comenum.h ===
//
// common to COM object and Proxy code
//
// GENERAL COMMENT - do not change the order in any of these enum definitions!
//                   pls consult ZviB b4 making any change here

// This file is used in order to generate VB & JS constant files that
// reside on the retail CD. Therefore, there are some conventions regarding
// the comments inside it:
//
// 1. Only C-style comments (slash-asterisk) are included in the generated
//    files. In order to use comments that will not appear, use C++-style
//    ones.
//
// 2. The C-style comments included SHOULD END THE SAME LINE THEY STARTED!!!!
//                                  -----------------------------------------
//
// 3. The PERL scripts that do the conversion put the comments to appropriate
//    form of JS/VB comments.
//
// 4. IN ANY CASE, DO NOT USE BIT MASKS FOR ENUMS!!!
//    You can put the hex value of the bit mask and a C++ comment near it
//    stating why the value is indeed so.
//
// For any issues regarding these enforcements, contact t-nadavr.

// These are retail CD comments
/* To include this file in HTML documents use the following HTML statements: */
/*   using JavaScript: */
/*      <script Language="JScript" src="CometCfg.js"> */
/*      </script> */
/*   using VBScript: */
/*      <script Language="VBScript" src="CometCfg.vbs"> */
/*      </script> */
/* */

/* This file holds VBScript constants that are needed to compensate for the fact */
/* that scripting engines cannot use the enumerated type information stored */
/* in the COM objects' type library. */
/* This file should be included in any VBScript scripts that use the Comet COM */
/* objects. */
/* */

#ifndef __COMENUM_H_
#define __COMENUM_H_

//TEMP from \ui\rwsprop\clustobj.h
typedef enum _RouteTypeEnum
{
    prxRouteNone            = -1,
    prxRouteDirect          =  0,
    prxRouteServer          =  1,
    prxRouteCluster         =  2,
    prxRouteAutoDetect      =  3,
    prxRouteSimpleServer    =  4

}RouteType;

///////////////////////////////////////////////
// @enum PublishRouteType | type of action performed by a publishing rule.

typedef enum _PublishRouteType
{
    prxRouteDiscard = 0,   // @emem Discard the coming requet.
    prxRouteRedirect       // @emem Redirect the request to another computer.
} PublishRouteType;

////////////////////////////////////////////////
// @enum PublishProtocolRedirectionType | the protocol choosed when redirecting a web request.

typedef enum _PublishProtocolRedirectionType
{
    prxSameAsInbound = 0,   // @emem The routed request is done using the same
                            // protocol as that of the inbound request
    prxFTP,                 // @emem The routed request is done using the FTP protocol
    prxHTTP,                // @emem The routed request is done using the HTTP protocol
} PublishProtocolRedirectionType;

/* Type _RouteRuleActionType from IRoutingRule */

/////////////////////////////////////////////////
// @enum RouteRuleActionType | proxy routing behavior

typedef enum _RouteRuleActionType
{
    prxRouteActionNone = 0,    // @emem No action
    prxRouteActionDirect,      // @emem Direct request to Internet.
    prxRouteActionUpstream,    // @emem Send the request to an upstream Comet server or array.
    prxRouteActionAlternate    // @emem Route to any other server.
} RouteRuleActionType;

/* Type _AuthType from ICredentials */

///////////////////////////////////////////////////
// @enum AuthType | Authentication method used for inter server connections

typedef enum _AuthType
{
    prxUiAuthBasic = 0,         // @emem Basic authentication
    prxUiAuthNtlm               // @emem NT Challenge Response authentication
} AuthType;

// code from dfltdata.h
typedef enum _DomainFiltersListType {
    prxDomainFilterDisabled, //              0
    prxDomainFilterDeny,     //              1
    prxDomainFilterGrant     //              2
} DomainFiltersListType;

// from alertdef.h

typedef enum _AlertTypes
{
    prxAlertTypePacketRate = 0,
    prxAlertTypeProtocolViolation,
    prxAlertTypeDiskFull,
    prxNumAlertTypes
} AlertTypes;

// from socksinf.h
///////////////////////////////////////////////////////
// @enum SOCKS_PERMISSION_ACTION | Action taken in a socks rule

typedef enum _SOCKS_PERMISSION_ACTION {


    prxSPermisNoAction = 0,       // @emem No action
    prxSPermisAllow,              // @emem allow the requested connection
    prxSPermisDeny,               // @emem deny the requested connection


} SOCKS_PERMISSION_ACTION;

//////////////////////////////////////////////////////
// @enum SOCKS_PORT_OPERATION | socks rule port criteria

typedef enum _SOCKS_PORT_OPERATION {

    prxSocksOpNop   = 0,        // @emem No criteria
    prxSocksOpEq    = 1,        // @emem Actual port equal to specified port
    prxSocksOpNeq   = 2,        // @emem Actual port not equal to specified port.
    prxSocksOpGt    = 3,        // @emem Actual port greater than specified port
    prxSocksOpLt    = 4,        // @emem Actual port less than specified port
    prxSocksOpGe    = 5,        // @emem Actual port greater or equal to specified port
    prxSocksOpLe    = 6         // @emem Actual port less or equal to specified port

} SOCKS_PORT_OPERATION;

// from clacctyp.h

//////////////////////////////////////////////////////
// @enum WspAccessByType | Winsock Proxy client way of identifying a server
typedef enum _WspAccessByType
{
    prxClientAccessSetByIp,         // @emem Identify by IP
    prxClientAccessSetByName,       // @emem Identify by name
    prxClientAccessSetManual        // @emem Identification set manually in ini file
} WspAccessByType;


// used in client configuration

/////////////////////////////////////////////////////
// @enum DirectDestinationType | type of destination used in browser "bypass" configuration.
typedef enum _DirectDestinationType
{
    prxLocalServersDirectDestination, // @emem All local addresses
    prxIPAddressDirectDestination,    // @emem A destination specified by IP
    prxDomainDirectDestination        // A destination specified by a Domain name.
}   DirectDestinationType;

typedef enum _BackupRouteType
{
    prxBackupRouteDirectToInternet,
    prxBackupRouteViaProxy
} BackupRouteType;

// new def - will be used by logginp.cpp in ui code
typedef enum _MSP_LOG_FORMAT {

    prxLogFormatVerbose=0,
    prxLogFormatRegular=1

} MSP_LOG_FORMAT;


//
// Only in COM object code
//

/////////////////////////////////////////////////////
//@enum SocksAddressType | the way an address of a socks connection is defined
typedef enum _SocksAddressType {

    prxSocksAddressNone = 1,    // @emem No address is defined
    prxSocksAddressIp,          // @emem Address defined by IP
    prxSocksAddressDomain,      // @emem Address defined by domain name
    prxSocksAddressAll          // @emem All addresses are used.


} SocksAddressType;

// proxy code uses different ugly enum that encompasses the enable state
typedef enum MSP_LOG_TYPE {

   prxLogTypeSqlLog=1,
   prxLogTypeFileLog

} MSP_LOG_TYPE;

// in proxy code this is computed on the fly from other data
typedef enum _DomainFilterType {
    prxSingleComputer = 1,
    prxGroupOfComputers,
    prxDomain
} DomainFilterType;

///////////////////////////////////////////////////////////
// @enum CacheExpirationPolicy | defines how soon cached web pages expire.

/* Type _CacheExpirationPolicy from IPrxCache */
typedef enum _CacheExpirationPolicy
{
    prxCachePolicyNotPredefined,          // @emem Not defined
    prxCachePolicyEmphasizeMoreUpdates,   // @emem Cached object exire more quickly.
    prxCachePolicyNoEmphasize,            // @emem Avarege behavior
    prxCachePolicyEmphasizeMoreCacheHits  // @emem Cached objects live longer.

}  CacheExpirationPolicy;


/* Type _ActiveCachingPolicy from IPrxCache */

/////////////////////////////////////////////////////////////
// @enum ActiveCachingPolicy | behavior of the active caching mechanism

typedef enum _ActiveCachingPolicy {
    prxActiveCachingEmphasizeOnFewerNetworkAccesses = 1, // @emem Less active caching is initiated
    prxActiveCachingNoEmphasize,                         // @emem Avarege behavior
    prxActiveCachingEmphasizeOnFasterUserResponse        // @emem More content is activelly cached.

}  ActiveCachingPolicy;


// enums for set sort by
typedef enum _PublishSortCriteria {
   prxPublishSortCriteriaURL = 1,
   prxPublishSortCriteriaRequestPath
} PublishSortCriteria;

typedef enum  _CacheFilterType {
   prxAlwaysCache = 1,
   prxNeverCache
} CacheFilterType;

typedef enum  _CacheFilterSortCriteria {
   prxCacheFilterSortCriteriaURL = 1,
   prxCacheFilterSortCriteriaStatus
} CacheFilterSortCriteria;

/////////////////////////////////////////////////////////////
// @enum PF_FILTER_TYPE | predefined static packet filters

typedef enum _PF_FILTER_TYPE
{
    prxCustomFilterType                 = 1,   // @emem no predefined filter. See custom options
    prxDnsLookupPredefinedType,                // @emem DNS lookup predefined static filter
    prxIcmpAllOutboundPredefinedType,          // @emem ICMP outbound predefined static filter
    prxIcmpPingResponsePredefinedType,         // @emem ICMP ping response predefined static filter
    prxIcmpPingQueryPredefinedType,            // @emem ICMP ping query predefined static filter
    prxIcmpSrcQuenchPredefinedType,            // @emem ICMP source quench predefined static filter
    prxIcmpTimeoutPredefinedType,              // @emem ICMP timeout predefined static filter
    prxIcmpUnreachablePredefinedType,          // @emem ICMP unreachable predefined static filter
    prxPptpCallPredefinedType,                 // @emem PPTP call predefined static filter
    prxPptpReceivePredefinedType,              // @emem PPTP receive predefined static filter
    prxSmtpPredefinedType,                     // @emem SMTP receive predefined static filter
    prxPop3PredefinedType,                     // @emem POP3 predefined static filter
    prxIdentdPredefinedType,                   // @emem Identd predefined static filter
    prxHttpServerPredefinedType,               // @emem HTTP server predefined static filter
    prxHttpsServerPredefinedType,              // @emem HTTPS server predefined static filter
    prxNetbiosWinsClientPredefinedType,        // @emem Netbios WINS predefined static filter
    prxNetbiosAllPredefinedType                // @emem Netbios all predefined static filter
} PF_FILTER_TYPE;

#define MIN_FILTER_TYPE prxCustomFilterType
#define MAX_FILTER_TYPE prxNetbiosAllPredefinedType

//
// type of protocol of the filter
// Keep the following in sync with structure aProtocolIds in file pfbase.h
// Keep the following in sync with the above (should never have to change).
//
//

/////////////////////////////////////////////////////////////////////
// @enum PF_PROTOCOL_TYPE | predefined static packet filters IP ports

typedef enum _PF_PROTOCOL_TYPE
{
    prxPfAnyProtocolIpIndex     = 0,           // @emem Any  protocol
    prxPfIcmpProtocolIpIndex    = 1,           // @emem ICMP protocol
    prxPfTcpProtocolIpIndex     = 6,           // @emem TCP  protocol
    prxPfUdpProtocolIpIndex     = 17           // @emem UDP  protocol
}
    PF_PROTOCOL_TYPE;

#define prxPfCustomProtocol      255
#define MIN_PROTOCOL_TYPE        prxPfAnyProtocolIpIndex
#define MAX_PROTOCOL_TYPE        prxPfUdpProtocolIpIndex

///////////////////////////////////////////////////////
// @enum PF_DIRECTION_TYPE | protocol direction options

typedef enum _PF_DIRECTION_TYPE
{
    prxPfDirectionIndexBoth = 0xC0000000,  // @emem both directions (in and out)
    prxPfDirectionIndexIn   = 0x80000000,  // @emem in direction
    prxPfDirectionIndexOut  = 0x40000000,  // @emem out direction
    prxPfDirectionIndexNone = 0            // @emem none - no direction defined
}
    PF_DIRECTION_TYPE;

#define MIN_DIRECTION_TYPE     1
#define MAX_DIRECTION_TYPE     4

/////////////////////////////////////////
// @enum PF_PORT_TYPE | port type options

typedef enum _PF_PORT_TYPE
{
    prxPfAnyPort=1,              // @emem Any port
    prxPfFixedPort,            // @emem fixed port (followed by port number)
    prxPfDynamicPort           // @emem dynamic port (1024-5000)
}
    PF_PORT_TYPE;

#define MIN_PORT_TYPE      prxPfAnyPort
#define MAX_PORT_TYPE      prxPfDynamicPort

///////////////////////////////////////////////////////////////////
// @enum PF_LOCAL_HOST_TYPE | local host (of packet filter) options

typedef enum _PF_LOCAL_HOST_TYPE
{
    prxPfDefaultProxyExternalIp = 1,     // @emem no host specified (default external IP)
    prxPfSpecificProxyIp,                // @emem specific proxy IP specified
    prxPfInternalComputer                // @emem specific internal computer specified
}
    PF_LOCAL_HOST_TYPE;


///////////////////////////////////////////////////////////////////
// @enum PF_REMOTE_HOST_TYPE | remote host (of packet filter) options

typedef enum _PF_REMOTE_HOST_TYPE
{
    prxPfSingleHost = 1,                 // @emem specific single host specified
    prxPfAnyHost                         // @emem Any host possible
}
    PF_REMOTE_HOST_TYPE;


/////////////////////////////////////////////
// @enum PF_SORT_ORDER_TYPE | PF sort options

typedef enum _PF_SORT_ORDER_TYPE
{
    prxPfSortByDirection = 1,                 // @emem sort by direction
    prxPfSortByProtocol,                      // @emem sort by protocol
    prxPfSortByLocalPort,                     // @emem sort by local port
    prxPfSortByRemotePort,                    // @emem sort by remote port
    prxPfSortByLocalAddress,                  // @emem sort by local address
    prxPfSortByRemoteAddress                  // @emem sort by remote address
}
    PF_SORT_ORDER_TYPE;


/////////////////////////////////////////////
// @enum PF_FILTER_STATUS_TYPE | PF status options

typedef enum _PF_FILTER_STATUS_TYPE
{
    prxFilterNotChanged = 1,                 // @emem No changes happed in the filter
    prxFilterWasAdded,                       // @emem a Packet filter was added
    prxFilterWasRemoved,                     // @emem a Packet filter was removed
    prxFilterWasChanged                      // @emem a Packet filter was changed
}
    PF_FILTER_STATUS_TYPE;

///////////////////////////////////////////////////////////////
// @enum RuleActions | kinds of actions performed when a rule criteria is met.
typedef enum _RuleActions
{
    prxRuleActionPermit,        // @emem Permit access to the requested web page
    prxRuleActionDeny,          // @emem Deny access tothe requested web page
    prxRuleActionRedirect       // @emem Redirect to a specific web page

} RuleActions;

///////////////////////////////////////////////////////////////
// @enum DestinationAddressType | type of a destination definition

typedef enum _DestinationAddressType
{
   prxDestinationTypeDomain,    // @emem Destination defined by domain name
   prxDestinationTypeSingleIP,  // @emem Destination defined by single IP
   prxDestinationTypeIPRange    // @emem Destination defined by an IP range.
} DestinationAddressType;

////////////////////////////////////////////////////////////////
// @enum DestinationSelection | type of destinations reffered to in a rule.
typedef enum _DestinationSelection
{
   prxAllDestinations,           // @emem All destinations
   prxAllInternalDestinations,   // @emem All internal destinations
   prxAllExternalDestinations,   // @emem All external destinations
   prxDestinationSet             // @emem Destinations that are part of a specified set

} DestinationSelection;

//////////////////////////////////////////////////////////
// @enum Days| the days of the week. Used in Schedule Templates
typedef enum _Days
{
  ALL_WEEK = -1,                 // @emem All days in week
  SUN,                           // @emem Sunday
  MON,                           // @emem Monday
  TUE,                           // @emem Tuesday
  WED,                           // @emem Wednesday
  THU,                           // @emem Thursday
  FRI,                           // @emem Friday
  SAT                            // @emem Saturday
} ScheduleDays;

//////////////////////////////////////////////////////////
// @enum Hours | the hours of the day. Used in Schedule Templates

typedef enum _Hours
{
    ALL_DAY=-1,                  // @emem All hours of the day
    AM_0,                        // @emem Midnight
    AM_1,                        // @emem 1 AM
    AM_2,                        // @emem 2 AM
    AM_3,                        // @emem 3 AM
    AM_4,                        // @emem 4 AM
    AM_5,                        // @emem 5 AM
    AM_6,                        // @emem 6 AM
    AM_7,                        // @emem 7 AM
    AM_8,                        // @emem 8 AM
    AM_9,                        // @emem 9 AM
    AM_10,                       // @emem 10 AM
    AM_11,                       // @emem 11 AM
    AM_12,                       // @emem 12 AM
    PM_1,                        // @emem 1 PM
    PM_2,                        // @emem 2 PM
    PM_3,                        // @emem 3 PM
    PM_4,                        // @emem 4 PM
    PM_5,                        // @emem 5 PM
    PM_6,                        // @emem 6 PM
    PM_7,                        // @emem 7 PM
    PM_8,                        // @emem 8 PM
    PM_9,                        // @emem 9 PM
    PM_10,                       // @emem 10 PM
    PM_11                        // @emem 11 PM
} ScheduleHours;


#define ENUM_INCR(type, x) x = ( (type) (  ((int)(x)) + 1 ) )

//
// Alert Enumerations.
//

////////////////////////////////////////////////////////////
// @enum ActionTypes | types of action that can be triggered by events

typedef enum _Actions {
    alrtLogEvent = 0,       //@emem Log event to System Event Log
    alrtCommand,            //@emem Run command line
    alrtSendMail,           //@emem Send Mail message
    alrtStopServices,       //@emem Stop Comet services
    alrtRestartServices,    //@emem Restart Comet services
    alrtPage,               //@emem Notify Pager
    alrtMakeCall            //@emem Make phone call using Web-based IVR
} ActionTypes;

#define alrtActionInvalid (-1)
#define alrtMaxActionType (alrtMakeCall + 1)

/////////////////////////////////////////////////////////
// @enum Events | type of events handled by Comet.
typedef enum _Events {
    alrtLowDiskSpace,        // @emem Low disk space.
    alrtZeroDiskSpace,       // @emem Out of disk space.
    alrtEventLogFailure,     // @emem Failure to log an event.
    alrtConfigurationError,  // @emem Configuration Error
    alrtRrasFailure,         // @emem Failure of RRAS service.
    alrtDllLoadFailure,      // @emem Failure to load a DLL.
    alrtDroppedPackets,      // @emem Dropped Packets (PFD)
    alrtProtocolViolation,   // @emem Protocol violations
    alrtProxyChaining,       // @emem Proxy chaining failure
    alrtServiceShutdown,     // @emem Service keep alive failure
    alrtRrasLineQuality,     // @emem RRAS line quality threshold
    alrtCacheCleanupFrequency, // @emem Cache cleanup frequency
    alrtTapiReinit,          // @emem TAPI reinitialized
    alrtDialOnDemandFailure, // @emem Dial On Demand failure (busy, no line)
    alrtIntraArrayCredentials, // @emem Intra array credentials incorrect
    alrtUpstreamChainingCredentials, // @emem Upstream chaining credentials incorrect
    alrtDialOnDemandCredentials, // @emem Dial On Demand credentials incorrect
    alrtOdbcCredentials,         // @emem Log to ODBC credentials incorrect
} EventTypes;
#define     alrtMaxEventType (alrtOdbcCrenetials + 1)

/////////////////////////////////////////////////////////
// @enum OperationModes | Alerting operation modes.
typedef enum _OperationModes {
    alrtCountThreshold,      //@emem events count before reraising alert
    alrtRateThreshold,       //@emem minimal events per second rate for raising alert
    alrtIntervalThreshold,   //@emem minimal interval in minutes before reraise
} OperationModes;
#define     alrtMaxOperationModes (alrtIntervalThreshold + 1)

///////////////////////////////////////////////////////////
// @enum Accounttypes | types of NT accounts
typedef enum _AccountTypes
{
  prxAccountTypeUser,                // @emem A User.
  prxAccountTypeGroup,               // @emem A group of users
  prxAccountTypeDomain,              // @emem A domain of users.
  prxAccountTypeAlias,               // @emem An alias.
  prxAccountTypeWellKnownGroup       // @emem A predefined account such as "Everyone"
} AccountTypes;

///////////////////////////////////////////////////////////
// @enum IncludeStatus | defines whether an accouint is included or excluded
// in the list of accounts to which a rule applies.
typedef enum _IncludeStatus
{
    prxInclude,                      // @emem Account is included.
    prxExclude                       // @emem Account is excluded.
} IncludeStatusEnum;

///////////////////////////////////////////////////////////
// @enum ConnectionProtocoltype | Type of IP protocol that consists a part
// of a Winsock Proxy Protocol definition.
typedef enum _ConnectionProtocolType
{
    prxTCP,                          // @emem TCP-IP
    prxUDP                           // @emem UDP-IP
}  ConnectionProtocolType;

///////////////////////////////////////////////////////////
// @enum Connectiondirectiontype | Type of connection that consists a part
// of a Winsock Proxy Protocol definition.
typedef enum _ConnectionDirectionType
{
   prxInbound,                       // @emem Inbound connection.
   prxOutbound                       // @emem Outbound connection.
}  ConnectionDirectionType;

///////////////////////////////////////////////////////////
// @enum CrmApplication | Type of application that uses a CRM
// line.
typedef enum _CrmApplication
{
    CRM_APPLICATION_NONE        =0,  // @emem No application
    CRM_APPLICATION_RAS         =1,  // @emem RAS
    CRM_APPLICATION_FAX         =2,  // @emem Fax
    CRM_APPLICATION_WEBIVR      =4,  // @emem Web-based IVR
    CRM_APPLICATION_MP          =8,  // @emem Modem Share
    CRM_ALL_APPLICATIONS        =0xF // @emem All the above values ORed
} CrmApplication;

///////////////////////////////////////////////////////////////
// @enum LoggingComponents
typedef enum _LoggingComponents
{
    logProxyWEB,           // @emem The Web Proxy log.
    logProxyWSP,           // @emem The Winsock Proxy log
    logProxySocks,         // @emem The Socks Proxy log.
    logProxyPacketFilters, // @emem Packet filters log.
    logWEBIVR,             // @emem The Web IVR log.
    logModemSharing,       // @emem The Modem Sharing log.
    logCRMLines,           // @emem The Telephone lines log.
    logFax,                // @emem The Fax Server log.
} LoggingComponents;

///////////////////////////////////////////////////////////////
// @enum LogFileDirectoryType
typedef enum _LogFileDirectoryType
{
    logFullPath,            // @emem The directory of the log files is given in full path.
    logRelativePath         // @emem The directory of the log files is relative to Comet install directory.
} LogFileDirectoryType;

typedef enum _ProtocolSelectionTypeEnum
{

   prxAllProtocols,
   prxAllDefinedProtocols,
   prxSpecifiedProtocols

} ProtocolSelectionTypeEnum;
//////////////////////////////////////////////////////
// @enum AppliesToType | types of request origins for which a rule applies..
typedef enum _AppliesToType
{
   cometAppliesToAll,                    // @emem All requests regardless of origin
   cometAppliesToUsers,                  // @emem requests coming from specified users.
   cometAppliesToClientSets              // @emem requests coming from specified machines.
} AppliesToType;

///////////////////////////////////////////////////////
// @enum CometServices | assigns numerical values for various
// components of Comet.
typedef enum _CometServices
{
    cometWspSrvSvc                  = 1,//@emem The Winsock Proxy component
    cometW3Svc                      = 2,//@emem The web proxy component.
    cometAllServices                = 0xFFFFFFFF // All the above values ORed
} CometServices;

///////////////////////////////////////////////////////////
// @enum DeviceType | The Fax Devices Types which are
// Device, Provider [Fax Over IP], or other.
typedef enum _DeviceType
{
    DEVICE = 1,  // TAPI Device
    PROVIDER,    // Non TAPI Device FaxOver IP or Virtual.
    OTHER
} DeviceType;

///////////////////////////////////////////////////////////
// @enum RemoveOldType | This is an enumerator for Fax
// different policies to remove old faxes from archive
typedef enum _RemoveOldType
{
    MAX_TIME_TO_KEEP = 1,   // how long to keep
    MAX_FAX_SIZE,           // maximal fax size allow to keep
    MAX_TOTAL_SIZE,         // maximal total size of archive
} RemoveOldType;

///////////////////////////////////////////////////////////
// @enum LineStatus | Telephony line status.
typedef enum _LineStatus
{
    lsError = 0,       // @emem Device is in error (the server may be down).
    lsIdle = 1,        // @emem The device state is idle - there is no active call on it.
    lsInbound = 2,     // @emem The device handles an inbound call.
    lsOutbound = 4     // @emem The device handles an outbound call.
} LineStatus;

///////////////////////////////////////////////////////////
// @enum ProtocolSelectiontype | type of protocols that a protocols rule
// applies to
typedef enum _ProtocolSelectionType
{
    cometAllIpTraffic, // @emem All IP connections.
    cometAllProtocols, // @emem All the protocols defined by Comet.
    cometSpecifiedProtocols // @emem the protocols specified by the
} ProtocolSelectionType;    // SpecifiedProtocols property

///////////////////////////////////////////////////////////
// @enum ProtocolRuleAction | the types of actions performed
// by the default protocol rule,
typedef enum _ProtocolRuleAction
{
  cometActionAllow, // @emem allow all IP connection requests.
  cometActionDeny   // @emem Deny all IP connection requests.
} ProtocolRuleAction;

///////////////////////////////////////////////////////////
// @enum INETLOG_TYPE | the types of logging methods
typedef enum  _LOG_TYPE   {

    InetLogInvalidType = -1, //@emem Indicates invalid log type
    InetNoLog = 0,           //@emem Logging disabled
    InetLogToFile,           //@emem Logging to text log files
    InetLogToSql,            //@emem Logging to ODBC log
    InetDisabledLogToFile,   //@emem Logging disabled
    InetDisabledLogToSql     //@emem Logging disabled
}  INETLOG_TYPE;


///////////////////////////////////////////////////////////
// @enum INETLOG_PERIOD | these options identify logging periods for text files
typedef enum  _INETLOG_PERIOD {
    InetLogInvalidPeriod = -1,     //@emem Indicates invalid logging period
    InetLogNoPeriod = 0,           //@emem no logging period in use
    InetLogDaily,                  //@emem one file per day
    InetLogWeekly,                 //@emem one log file per week
    InetLogMonthly,                //@emem one log file per month
    InetLogYearly                  //@emem one log file per year.
} INETLOG_PERIOD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\startup.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  startup.c

Abstract:

  This module:  
    1) Retrieves all the printer monitors
    2) Verifies the fax printer monitor is installed
    3) Retrieves all the printer ports
    4) Verifies the fax printer port is installed
    5) Retrieves all the printer drivers
    6) Verifies the fax printer driver is installed
    7) Retrieves all the printers
    8) Verifies the fax printer is installed
    9) Verifies fax is installed
    10) Verifies the faxcom com objects are installed
    11) Verifies the faxadmin com objects are installed
    12) Verifies the routeext com objects are installed
    13) Verifies the com objects are installed
    14) Verifies the fax service is installed
    15) Stops the fax service
    16) Initializes FaxRcv
    17) Initializes RAS

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _STARTUP_C
#define _STARTUP_C

#include <winspool.h>

#define FAX_MONITOR_NAME  L"Microsoft Shared Fax Monitor"	// FAX_MONITOR_NAME is the name of the Fax Printer Monitor
//#define FAX_MONITOR_NAME2  L"Fax Monitor"					// FAX_MONITOR_NAME2 is a workaround for apossible bug
#define FAX_MONITOR_DLL   L"FXSMON.DLL"						// FAX_MONITOR_DLL is the name of the Fax Printer Monitor Dll
#define FAX_PORT_NAME     L"SHRFAX:"						// FAX_PORT_NAME is the name of the Fax Printer Port
#define FAX_DRIVER_NAME   L"Microsoft Shared Fax Driver"	// FAX_DRIVER_NAME is the name of the Fax Printer Driver
#define FAX_DRIVER_DLL    L"FXSDRV.DLL"						// FAX_DRIVER_DLL is the name of the Fax Printer Driver Dll
#define FAX_SERVICE       L"Fax"							// FAX_SERVICE is the name of the Fax Service

PVOID
fnLocalEnumPrinterMonitors(
    LPDWORD  pdwNumPrinterMonitors
)
/*++

Routine Description:

  Retrieves all the printer monitors

Arguments:

  pdwNumPrinterMonitors - pointer to number of printer monitors

Return Value:

  PVOID - pointer to the printer monitors info

--*/
{
    // pPrinterMonitorInfo is a pointer to a buffer of printer monitor info structures
    LPBYTE  pPrinterMonitorInfo;
    // cb is the size of the buffer of printer driver info structures
    DWORD   cb;

    *pdwNumPrinterMonitors = 0;
    // Get all printer monitors
    if ((!EnumMonitors(NULL, 2, NULL, 0, &cb, pdwNumPrinterMonitors)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumMonitors failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterMonitorInfo = (LPBYTE)MemAllocMacro(cb);
        // Call EnumMonitors again with the correct size buffer
        if (!EnumMonitors(NULL, 2, pPrinterMonitorInfo, cb, &cb, pdwNumPrinterMonitors)) {
            // EnumMonitors failed
            // Free the buffer
            MemFreeMacro(pPrinterMonitorInfo);
            goto ExitLevel0;
        }
        // EnumMonitors succeeded, so return pointer to the buffer
        return pPrinterMonitorInfo;
    }

ExitLevel0:
    // EnumMonitors failed
    DebugMacro(L"EnumMonitors() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterMonitorInstalled(
)
/*++

Routine Description:

  Verifies the fax printer monitor is installed

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the fax printer monitor dll resides
    WCHAR             szDllPath[_MAX_PATH];

    // pAllPrinterMonitors is the pointer to all printer monitors info
    LPMONITOR_INFO_2  pAllPrinterMonitors;
    // dwNumPrinterMonitors is the number of all printer monitors
    DWORD             dwNumPrinterMonitors;
    // dwNumFaxPrinterMonitors is the number of fax printer monitors
    DWORD             dwNumFaxPrinterMonitors;
    // dwIndex is a counter to enumerate each printer monitor
    DWORD             dwIndex;

    // Clear the dll path
    ZeroMemory(szDllPath, sizeof(szDllPath));

    // Get the path
    if (GetSystemDirectory(szDllPath, sizeof(szDllPath)) == 0) {
        DebugMacro(L"GetSystemDirectory() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Concatenate the fax printer monitor dll with the path
    lstrcat(szDllPath, L"\\");
    lstrcat(szDllPath, FAX_MONITOR_DLL);

    // Verify fax printer monitor dll exists
    if (GetFileAttributes(szDllPath) == 0xFFFFFFFF) {
        DebugMacro(L"The Fax Printer Monitor DLL does not exist.\n");
        return FALSE;
    }

    // Get all printer monitors
    pAllPrinterMonitors = (LPMONITOR_INFO_2)fnLocalEnumPrinterMonitors(&dwNumPrinterMonitors);
    if (!pAllPrinterMonitors)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printer monitors
    for (dwIndex = 0, dwNumFaxPrinterMonitors = 0; dwIndex < dwNumPrinterMonitors; dwIndex++) {
        // A fax printer monitor is determined by comparing the name of the current printer monitor against the name of the fax printer monitor
        if ((!lstrcmpi(pAllPrinterMonitors[dwIndex].pName, FAX_MONITOR_NAME)) && (!lstrcmpi(pAllPrinterMonitors[dwIndex].pDLLName, FAX_MONITOR_DLL))) {
            // Name of the current printer monitor and the name of the fax printer monitor match
            // Increment the number of fax printer monitors
            dwNumFaxPrinterMonitors++;
        }
    }

    // Free all printer monitors
    MemFreeMacro(pAllPrinterMonitors);

    if (dwNumFaxPrinterMonitors == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterMonitors > 1) {
        DebugMacro(L"The Fax Printer Monitor is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Monitor is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinterPorts(
    LPDWORD  pdwNumPrinterPorts
)
/*++

Routine Description:

  Retrieves all the printer ports

Arguments:

  pdwNumPrinterPorts - pointer to number of printer ports

Return Value:

  PVOID - pointer to the printer ports info

--*/
{
    // pPrinterPortInfo is a pointer to a buffer of printer port info structures
    LPBYTE  pPrinterPortInfo;
    // cb is the size of the buffer of printer port info structures
    DWORD   cb;

    *pdwNumPrinterPorts = 0;
    // Get all printer ports
    if ((!EnumPorts(NULL, 2, NULL, 0, &cb, pdwNumPrinterPorts)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPorts failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterPortInfo = (LPBYTE)MemAllocMacro(cb);
        // Call EnumPorts again with the correct size buffer
        if (!EnumPorts(NULL, 2, pPrinterPortInfo, cb, &cb, pdwNumPrinterPorts)) {
            // EnumPorts failed
            // Free the buffer
            MemFreeMacro(pPrinterPortInfo);
            goto ExitLevel0;
        }
        // EnumPorts succeeded, so return pointer to the buffer
        return pPrinterPortInfo;
    }

ExitLevel0:
    // EnumPorts failed
    DebugMacro(L"EnumPorts() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterPortInstalled(
)
/*++

Routine Description:

  Verifies the fax printer port is installed

Return Value:

  TRUE on success

--*/
{
    // pAllPrinterPorts is the pointer to all printer ports info
    LPPORT_INFO_2  pAllPrinterPorts;
    // dwNumPrinterPorts is the number of all printer ports
    DWORD          dwNumPrinterPorts;
    // dwNumFaxPrinterPorts is the number of fax printer ports
    DWORD          dwNumFaxPrinterPorts;
    // dwIndex is a counter to enumerate each printer ports
    DWORD          dwIndex;

    // Get all printer ports
    pAllPrinterPorts = (LPPORT_INFO_2)fnLocalEnumPrinterPorts(&dwNumPrinterPorts);
    if (!pAllPrinterPorts) {
        // Return FALSE
        return FALSE;
    }

    // Determine the number of fax printer ports
    for (dwIndex = 0, dwNumFaxPrinterPorts = 0; dwIndex < dwNumPrinterPorts; dwIndex++)
	{
        //
		// A fax printer port is determined by comparing the name of the current printer port against the name of the fax printer port
        //
		if ((!lstrcmpi(pAllPrinterPorts[dwIndex].pPortName, FAX_PORT_NAME)) && (!lstrcmpi(pAllPrinterPorts[dwIndex].pMonitorName, FAX_MONITOR_NAME)))
		{
			//
		    // Name of the current printer port and the name of the fax printer port match
            // Increment the number of fax printer ports
			//
            dwNumFaxPrinterPorts++;
        }
    }

    // Free all printer ports
    MemFreeMacro(pAllPrinterPorts);

    if (dwNumFaxPrinterPorts == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterPorts > 1) {
        DebugMacro(L"The Fax Printer Port is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Port is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinterDrivers(
    LPDWORD  pdwNumPrinterDrivers
)
/*++

Routine Description:

  Retrieves all the printer drivers

Arguments:

  pdwNumPrinterDrivers - pointer to number of printer drivers

Return Value:

  PVOID - pointer to the printer drivers info

--*/
{
    // pPrinterDriverInfo is a pointer to a buffer of printer driver info structures
    LPBYTE  pPrinterDriverInfo;
    // cb is the size of the buffer of printer driver info structures
    DWORD   cb;

    *pdwNumPrinterDrivers = 0;
    // Get all printer drivers
    if ((!EnumPrinterDrivers(NULL, NULL, 2, NULL, 0, &cb, pdwNumPrinterDrivers)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPrinterDrivers failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterDriverInfo = (LPBYTE)MemAllocMacro(cb);
        // Call EnumPrinterDrivers again with the correct size buffer
        if (!EnumPrinterDrivers(NULL, NULL, 2, pPrinterDriverInfo, cb, &cb, pdwNumPrinterDrivers)) {
            // EnumPrinterDrivers failed
            // Free the buffer
            MemFreeMacro(pPrinterDriverInfo);
            goto ExitLevel0;
        }
        // EnumPrinterDrivers succeeded, so return pointer to the buffer
        return pPrinterDriverInfo;
    }

ExitLevel0:
    // EnumPrinterDrivers failed
    DebugMacro(L"EnumPrinterDrivers() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterDriverInstalled(
)
/*++

Routine Description:

  Verifies the fax printer driver is installed

Return Value:

  TRUE on success

--*/
{
    // pAllPrinterDrivers is the pointer to all printer drivers info
    LPDRIVER_INFO_2  pAllPrinterDrivers;
    // dwNumPrinterDrivers is the number of all printer drivers
    DWORD            dwNumPrinterDrivers;
    // dwNumFaxPrinterDrivers is the number of fax printer drivers
    DWORD            dwNumFaxPrinterDrivers;
    // dwIndex is a counter to enumerate each printer driver
    DWORD            dwIndex;

    // Get all printer drivers
    pAllPrinterDrivers = (LPDRIVER_INFO_2)fnLocalEnumPrinterDrivers(&dwNumPrinterDrivers);
    if (!pAllPrinterDrivers)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printer drivers
    for (dwIndex = 0, dwNumFaxPrinterDrivers = 0; dwIndex < dwNumPrinterDrivers; dwIndex++) {
        // A fax printer driver is determined by comparing the name of the current printer driver against the name of the fax printer driver
        if ((!lstrcmpi(pAllPrinterDrivers[dwIndex].pName, FAX_DRIVER_NAME)) && (!lstrcmpi((LPWSTR) ((UINT_PTR) pAllPrinterDrivers[dwIndex].pDriverPath + (lstrlen(pAllPrinterDrivers[dwIndex].pDriverPath) - lstrlen(FAX_DRIVER_DLL)) * sizeof(WCHAR)), FAX_DRIVER_DLL)) && (GetFileAttributes(pAllPrinterDrivers[dwIndex].pDriverPath) != 0xFFFFFFFF)) {
            // Name of the current printer driver and the name of the fax printer driver match
            // Increment the number of fax printer drivers
            dwNumFaxPrinterDrivers++;
        }
    }

    // Free all printer drivers
    MemFreeMacro(pAllPrinterDrivers);

    if (dwNumFaxPrinterDrivers == 1) {
        return TRUE;
    }
    else if (dwNumFaxPrinterDrivers > 1) {
        DebugMacro(L"The Fax Printer Driver is installed more than once.\n");
        return FALSE;
    }
    else {
        DebugMacro(L"The Fax Printer Driver is not installed.\n");
        return FALSE;
    }
}

PVOID
fnLocalEnumPrinters(
    LPDWORD  pdwNumPrinters
)
/*++

Routine Description:

  Retrieves all the printers

Arguments:

  pdwNumPrinters - pointer to number of printers

Return Value:

  PVOID - pointer to the printer info

--*/
{
    // pPrinterInfo is a pointer to a buffer of printer info structures
    LPBYTE  pPrinterInfo;
    // cb is the size of the buffer of printer info structures
    DWORD   cb;

    *pdwNumPrinters = 0;
    // Get all printers
    if ((!EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 2, NULL, 0, &cb, pdwNumPrinters)) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        // EnumPrinters failed because the buffer is too small
        // cb is the size of the buffer needed, so allocate a buffer of that size
        pPrinterInfo = (LPBYTE)MemAllocMacro(cb);
        // Call EnumPrinters again with the correct size buffer
        if (!EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 2, pPrinterInfo, cb, &cb, pdwNumPrinters)) {
            // EnumPrinters failed
            // Free the buffer
            MemFreeMacro(pPrinterInfo);
            goto ExitLevel0;
        }
        // EnumPrinters succeeded, so return pointer to the buffer
        return pPrinterInfo;
    }

ExitLevel0:
    // EnumPrinters failed
    DebugMacro(L"EnumPrinters() failed, ec = 0x%08x\n", GetLastError());
    // Return a NULL handle
    return NULL;
}

BOOL
fnIsFaxPrinterInstalled(
)
/*++

Routine Description:

  Verifies the fax printer is installed

Return Value:

  TRUE on success

--*/
{
    // pPrinterInfo is the pointer to all printers info
    LPPRINTER_INFO_2  pAllPrinters;
    // dwNumPrinters is the number of all printers
    DWORD             dwNumPrinters;
    // dwNumFaxPrinters is the number of fax printers
    DWORD             dwNumFaxPrinters;
    // dwIndex is a counter to enumerate each printer
    DWORD             dwIndex;

    // Get all printers
    pAllPrinters = (LPPRINTER_INFO_2)fnLocalEnumPrinters(&dwNumPrinters);
    if (!pAllPrinters)
        // Return FALSE
        return FALSE;

    // Determine the number of fax printers
    for (dwIndex = 0, dwNumFaxPrinters = 0; dwIndex < dwNumPrinters; dwIndex++) {
        // A fax printer is determined by comparing the name of the current printer driver against the name of the fax printer driver
        if ((!lstrcmpi(pAllPrinters[dwIndex].pDriverName, FAX_DRIVER_NAME)) && (!lstrcmpi(pAllPrinters[dwIndex].pPortName, FAX_PORT_NAME))) {
            // Name of the current printer driver and the name of the fax printer driver match
            // Increment the number of fax printers
            dwNumFaxPrinters++;
        }
    }

    // Free all printers
    MemFreeMacro(pAllPrinters);

    if (dwNumFaxPrinters) {
        return TRUE;
    }
    else {
        DebugMacro(L"A Fax Printer is not installed.\n");
        return FALSE;
    }
}

UINT
fnIsFaxInstalled(
)
/*++

Routine Description:

  Verifies fax is installed

Return Value:

  UINT - resource id

--*/
{
    // Verify the fax printer monitor is installed
    if (!fnIsFaxPrinterMonitorInstalled()) {
        return IDS_FAX_MONITOR_NOT_INSTALLED;
    }

    // Verify the fax printer port is installed
    if (!fnIsFaxPrinterPortInstalled()) {
        return IDS_FAX_PORT_NOT_INSTALLED;
    }

    // Verify the fax printer driver is installed
    if (!fnIsFaxPrinterDriverInstalled()) {
        return IDS_FAX_DRIVER_NOT_INSTALLED;
    }

    // Verify the fax printer is installed
    if (!fnIsFaxPrinterInstalled()) {
        return IDS_FAX_PRINTER_NOT_INSTALLED;
    }

    return ERROR_SUCCESS;
}



BOOL
fnIsFaxSvcInstalled(
)
/*++

Routine Description:

  Verifies the fax service is installed

Return Value:

  TRUE on success

--*/
{
    SC_HANDLE  hManager = NULL;
    SC_HANDLE  hService = NULL;

    // Open the service control manager
    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

    if (!hManager) {
        DebugMacro(L"OpenSCManager() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Open the service
    hService = OpenService(hManager, FAX_SERVICE, SERVICE_ALL_ACCESS);

    if (!hService)
	{
        CloseServiceHandle(hManager);
		hManager = NULL;
        DebugMacro(L"OpenService() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    CloseServiceHandle(hService);
	hService = NULL;

    CloseServiceHandle(hManager);
	hManager = NULL;
    
	return TRUE;
}

BOOL
fnStopFaxSvc(
)
/*++

Routine Description:

  Stops the fax service

Return Value:

  TRUE on success

--*/
{
    SC_HANDLE       hManager;
    SC_HANDLE       hService;
    SERVICE_STATUS  ServiceStatus;
    BOOL            bRslt;

    bRslt = FALSE;

    // Open the service control manager
    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
    if (!hManager) {
        DebugMacro(L"OpenSCManager() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Open the service
    hService = OpenService(hManager, FAX_SERVICE, SERVICE_ALL_ACCESS);
    if (!hService) {
        DebugMacro(L"OpenService() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Query the service status
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    if (!QueryServiceStatus(hService, &ServiceStatus)) {
        DebugMacro(L"QueryServiceStatus() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
        // Service is stopped
        bRslt = TRUE;
        goto ExitLevel0;
    }

    // Stop the service
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus)) {
        DebugMacro(L"ControlService() failed, ec = 0x%08x\n", GetLastError());
        goto ExitLevel0;
    }

    // Wait until the service is stopped
    ZeroMemory(&ServiceStatus, sizeof(SERVICE_STATUS));
    while (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
        Sleep(1000);

        // Query the service status
        if (!QueryServiceStatus(hService, &ServiceStatus)) {
            DebugMacro(L"QueryServiceStatus() failed, ec = 0x%08x\n", GetLastError());
            goto ExitLevel0;
        }

        // Verify the service is stopped or stopping
        if (!((ServiceStatus.dwCurrentState == SERVICE_STOPPED) || (ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING))) {
            DebugMacro(L"The Fax Service is in an unexpected state.  dwCurrentState: 0x%08x\n", ServiceStatus.dwCurrentState);
            goto ExitLevel0;
        }
    }

    bRslt = TRUE;

    Sleep(1000);

ExitLevel0:
    if (hService)
	{
        CloseServiceHandle(hService);
		hService = NULL;
    }
    if (hManager)
	{
        CloseServiceHandle(hManager);
		hManager = NULL;
    }
    return bRslt;
}

UINT
fnInitializeFaxRcv(
)
/*++

Routine Description:

  Initializes FaxRcv

Return Value:

  UINT - resource id

--*/
{
    // szFaxRcvDll is the FaxRcv dll
    WCHAR   szFaxRcvDll[_MAX_PATH];

    // hFaxRcvExtKey is the handle to the FaxRcv Extension Registry key
    HKEY    hFaxRcvExtKey = NULL;
    
	// hRoutingMethodsKey is the handle to the FaxRcv Routing Methods Registry key
    HKEY    hRoutingMethodsKey = NULL;
    
	// hFaxRcvMethodKey is the handle to the FaxRcv Method Registry key
    HKEY    hFaxRcvMethodKey = NULL;
    DWORD   dwDisposition = 0;

    DWORD   dwData = 0;
    LPWSTR  szData = NULL;

    UINT    uRslt = 0;

    uRslt = IDS_FAX_RCV_NOT_INITIALIZED;

    if (!fnIsFaxSvcInstalled()) {
        return IDS_FAX_SVC_NOT_INSTALLED;
    }

    if (!fnStopFaxSvc()) {
        return IDS_FAX_SVC_NOT_STOPPED;
    }

    ExpandEnvironmentStrings(IMAGENAME_EXT_REGDATA, szFaxRcvDll, sizeof(szFaxRcvDll) / sizeof(WCHAR));
    if (!lstrcmpi(IMAGENAME_EXT_REGDATA, szFaxRcvDll)) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // 
    // Copy the test routing extension to the system32 directory
	//
	if (!CopyFile(FAXRCV_DLL, szFaxRcvDll, FALSE)) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // Create or open the FaxRcv Extension Registry key
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, FAXRCV_EXT_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hFaxRcvExtKey, &dwDisposition) != ERROR_SUCCESS) {
        return IDS_FAX_RCV_NOT_INITIALIZED;
    }

    // Create or open the FaxRcv Routing Methods Registry key
    if (RegCreateKeyEx(hFaxRcvExtKey, ROUTINGMETHODS_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hRoutingMethodsKey, &dwDisposition) != ERROR_SUCCESS) {
        goto ExitLevel0;
    }

    // Create or open the FaxRcv Method Registry key
    if (RegCreateKeyEx(hRoutingMethodsKey, FAXRCV_METHOD_REGKEY, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hFaxRcvMethodKey, &dwDisposition) != ERROR_SUCCESS) {
        goto ExitLevel1;
    }

    // Set FaxRcv Extension bEnable Registry value
    dwData = BENABLE_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, BENABLE_EXT_REGVAL, 0, REG_DWORD, (PBYTE) &dwData, sizeof(DWORD)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Extension FriendlyName Registry value
    szData = FRIENDLYNAME_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, FRIENDLYNAME_EXT_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Extension ImageName Registry value
    szData = IMAGENAME_EXT_REGDATA;
    if (RegSetValueEx(hFaxRcvExtKey, IMAGENAME_EXT_REGVAL, 0, REG_EXPAND_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method FriendlyName Registry value
    szData = FRIENDLYNAME_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, FRIENDLYNAME_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method FunctionName Registry value
    szData = FUNCTIONNAME_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, FUNCTIONNAME_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method Guid Registry value
    szData = GUID_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, GUID_METHOD_REGVAL, 0, REG_SZ, (PBYTE) szData, (lstrlen(szData) + 1) * sizeof(WCHAR)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    // Set FaxRcv Method Priority Registry value
    dwData = PRIORITY_METHOD_REGDATA;
    if (RegSetValueEx(hFaxRcvMethodKey, PRIORITY_METHOD_REGVAL, 0, REG_DWORD, (PBYTE) &dwData, sizeof(DWORD)) != ERROR_SUCCESS) {
        goto ExitLevel2;
    }

    uRslt = ERROR_SUCCESS;

ExitLevel2:
    // Close the FaxRcv Method Registry key
    RegCloseKey(hFaxRcvMethodKey);
	hFaxRcvMethodKey = NULL;

ExitLevel1:
    // Close the FaxRcv Routing Methods Registry key
    RegCloseKey(hRoutingMethodsKey);
	hRoutingMethodsKey = NULL;

ExitLevel0:
    // Close the FaxRcv Extension Registry key
    RegCloseKey(hFaxRcvExtKey);
	hFaxRcvExtKey = NULL;

    return uRslt;
}

BOOL
fnInitializeRas(
)
/*++

Routine Description:

  Initializes RAS

Return Value:

  TRUE on success

--*/
{
    // szDllPath is the path where the RAS dll resides
    WCHAR      szDllPath[_MAX_PATH];
    // hInstance is the handle to the RAS dll
    HINSTANCE  hInstance;

    // Clear the dll path
    ZeroMemory(szDllPath, sizeof(szDllPath));

    // Get the path
    if (GetSystemDirectory(szDllPath, sizeof(szDllPath)) == 0) {
        DebugMacro(L"GetSystemDirectory() failed, ec = 0x%08x\n", GetLastError());
        return FALSE;
    }

    // Concatenate the RAS dll with the path
    lstrcat(szDllPath, RASAPI32_DLL);

    // Get the handle to the RAS dll
    hInstance = LoadLibrary((LPCWSTR) szDllPath);
    if (!hInstance) {
        DebugMacro(L"LoadLibrary(%s) failed, ec = 0x%08x\n", szDllPath, GetLastError());
        return FALSE;
    }

    // Map all needed functions

    g_RasApi.hInstance = hInstance;

    // RasDial
    g_RasApi.RasDial = (PRASDIAL)GetProcAddress(hInstance, "RasDialW");
	
    if (!g_RasApi.RasDial) {
        DebugMacro(L"GetProcAddress(RasDial) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
		hInstance = NULL;
        return FALSE;
    }

    // RasGetErrorString
    g_RasApi.RasGetErrorString = (PRASGETERRORSTRING)GetProcAddress(hInstance, "RasGetErrorStringW");
	
    if (!g_RasApi.RasGetErrorString) {
        DebugMacro(L"GetProcAddress(RasGetErrorString) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // RasGetConnectStatus
    g_RasApi.RasGetConnectStatus = (PRASGETCONNECTSTATUS)GetProcAddress(hInstance, "RasGetConnectStatusW");
	
    if (!g_RasApi.RasGetConnectStatus) {
        DebugMacro(L"GetProcAddress(RasGetConnectStatus) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // RasGetConnectionStatistics
    g_RasApi.RasGetConnectionStatistics = (PRASGETCONNECTIONSTATISTICS)GetProcAddress(hInstance, "RasGetConnectionStatistics");
	
    if (!g_RasApi.RasGetConnectionStatistics) {
        DebugMacro(L"GetProcAddress(RasGetConnectionStatistics) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // RasHangUp
    g_RasApi.RasHangUp = (PRASHANGUP)GetProcAddress(hInstance, "RasHangUpW");
	
    if (!g_RasApi.RasHangUp) {
        DebugMacro(L"GetProcAddress(RasHangUp) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\dsinterface.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    DSInterfaceInterface.h

Abstract:

    This module contains all the definitions for the access to the
    CometStorage configuration databse (through the COM admin layer)

Author:

    Eran Yariv (EranY)  May-1999

Revision History:

--*/

#ifndef __cplusplus
#error This header must compile as C++ only
#endif

#ifndef _FAX_DS_INTERFACE_H_
#define _FAX_DS_INTERFACE_H_

#include <msneroot.h>

#ifndef __ATLBASE_H__
class CComBSTR;
#endif

HRESULT
GetIsCurrentOutQueueSendEnabled (IFaxApplication *, BOOL *);

HRESULT
SetIsCurrentOutQueueSendEnabled (IFaxApplication *, BOOL);

//
// Callbacks definitions:
//

typedef BOOL (WINAPI *ENUM_DS_LIST_CALLBACK) (  IDispatch  *pItem, 
                                                DWORD       dwIndex, 
                                                PVOID       ContextData, 
                                                DWORD       dwCollectionSize);

typedef BOOL (WINAPI *ENUM_CRM_LINES_CALLBACK) (ICometCRMLine *pLine, PVOID ContextData);

//
// Enumeration functions:
//

HRESULT
EnumCRMLinesOnThisServer (
    ENUM_CRM_LINES_CALLBACK Callback,
    PVOID                   Context );

HRESULT
EnumIFaxApplicationDevices (
    IFaxApplication *pInterface, 
    LPDWORD lpdwCount,
    ENUM_DS_LIST_CALLBACK Callback, 
    PVOID Context );

HRESULT
EnumIFaxApplicationRoutingExtensions (
    IFaxApplication      *pInterface, 
    LPDWORD lpdwCount,
    ENUM_DS_LIST_CALLBACK Callback, 
    PVOID                 Context );

HRESULT
EnumIFaxApplicationRoutingMethods (
    IFaxRoutingExtension *pInterface, 
    LPDWORD lpdwCount,
    ENUM_DS_LIST_CALLBACK Callback, 
    PVOID                 Context );

//
// IFaxApplication related:
//

HRESULT   IsIFaxApplicationEnabled (IFaxApplication *pInterface, PBOOL);

LPWSTR GetIFaxApplicationServerMapiProfile (IFaxApplication *pInterface);
BOOL   SetIFaxApplicationServerMapiProfile (IFaxApplication *pInterface, LPCWSTR dwVal);

DWORD GetIFaxApplicationRetries (IFaxApplication *pInterface);
BOOL  SetIFaxApplicationRetries (IFaxApplication *pInterface, DWORD dwVal);

DWORD GetIFaxApplicationRetryDelay (IFaxApplication *pInterface);
BOOL  SetIFaxApplicationRetryDelay (IFaxApplication *pInterface, DWORD dwVal);

DWORD GetIFaxApplicationDirtyDays (IFaxApplication *pInterface);
BOOL  SetIFaxApplicationDirtyDays (IFaxApplication *pInterface, DWORD dwVal);

BOOL GetIFaxApplicationBranding (IFaxApplication *pInterface);
BOOL SetIFaxApplicationBranding (IFaxApplication *pInterface, BOOL bVal);

BOOL GetIFaxApplicationUseDeviceTsid (IFaxApplication *pInterface);
BOOL SetIFaxApplicationUseDeviceTsid (IFaxApplication *pInterface, BOOL bVal);

BOOL  GetIFaxApplicationAllowPersonalCoverpage (IFaxApplication *pInterface);
BOOL  SetIFaxApplicationAllowPersonalCoverpage (IFaxApplication *pInterface, BOOL bVal);

VOID GetIFaxApplicationDiscountRateStart (IFaxApplication *pInterface, PWORD pwHours, PWORD pwMinutes);
BOOL SetIFaxApplicationDiscountRateStart (IFaxApplication *pInterface, WORD wHour, WORD wMinute);

VOID GetIFaxApplicationDiscountRateEnd (IFaxApplication *pInterface, PWORD pwHours, PWORD pwMinutes);
BOOL SetIFaxApplicationDiscountRateEnd (IFaxApplication *pInterface, WORD wHour, WORD wMinute);

LPWSTR GetIFaxArchivePolicyFolderName (IFaxArchivePolicy *pInterface);
BOOL   SetIFaxArchivePolicyFolderName (IFaxArchivePolicy *pInterface, LPCWSTR dwVal);

BOOL  GetIFaxArchivePolicyEnabled (IFaxArchivePolicy *pInterface);
BOOL  SetIFaxArchivePolicyEnabled (IFaxArchivePolicy *pInterface, BOOL bVal);

//
// IFaxDevice related:
//

HRESULT FindFaxDeviceByID (DWORD dwDeviceID, IFaxDevice **);
HRESULT GetFaxDeviceID (IFaxDevice *pIFaxDev, LPDWORD);

HRESULT
ComposePermanentLineId (
    DWORD dwID,
    BSTR *pMachineName,
    BSTR *pDstStr);

HRESULT
IsThisDeviceOnMyServer (
    IFaxDevice *pIDevice,
    PBOOL);


LPWSTR GetIFaxDeviceServerName (IFaxDevice *pInterface);

LPWSTR GetIFaxDeviceCsid (IFaxDevice *pInterface);
BOOL   SetIFaxDeviceCsid (IFaxDevice *pInterface, LPCWSTR dwVal);

LPWSTR GetIFaxDeviceName (IFaxDevice *pInterface);
BOOL   SetIFaxDeviceName (IFaxDevice *pInterface, LPCWSTR dwVal);

LPWSTR GetIFaxDeviceProviderGuid (IFaxDevice *pInterface);
BOOL   SetIFaxDeviceProviderGuid (IFaxDevice *pInterface, LPCWSTR dwVal);

LPWSTR GetIFaxDeviceTsid (IFaxDevice *pInterface);
BOOL   SetIFaxDeviceTsid (IFaxDevice *pInterface, LPCWSTR dwVal);

BOOL GetIFaxDeviceReceiveEnabled (IFaxDevice *pInterface);
BOOL SetIFaxDeviceReceiveEnabled (IFaxDevice *pInterface, BOOL bVal);

BOOL GetIFaxDeviceSendEnabled (IFaxDevice *pInterface);
BOOL SetIFaxDeviceSendEnabled (IFaxDevice *pInterface, BOOL bVal);

DWORD GetIFaxDevicePriority (IFaxDevice *pInterface);
BOOL  SetIFaxDevicePriority (IFaxDevice *pInterface, DWORD dwVal);

DWORD GetIFaxDeviceRings (IFaxDevice *pInterface);
BOOL  SetIFaxDeviceRings (IFaxDevice *pInterface, DWORD dwVal);

DWORD GetIFaxDeviceTapiDeviceID (IFaxDevice *pInterface);
BOOL  SetIFaxDeviceTapiDeviceID  (IFaxDevice *pInterface, DWORD dwVal);

LPWSTR GetIFaxDeviceDeviceID (IFaxDevice *pInterface);

//
// Associated methods related:
//

IFaxAssociatedRoutingMethods *GetIFaxDeviceAssociatedRoutingMethods (IFaxDevice *pInterface);
IFaxAssociatedRoutingMethods *GetICrmLineAssociatedRoutingMethods (ICometCRMLine *pInterface);

LPWSTR GetIFaxRoutingMethodName (IFaxRoutingMethod *pInterface);
LPWSTR GetIFaxRoutingMethodFunctionName (IFaxRoutingMethod *pInterface);
LPWSTR GetIFaxRoutingMethodGuid (IFaxRoutingMethod *pInterface);
DWORD  GetIFaxRoutingMethodPriority (IFaxRoutingMethod *pInterface);

LPWSTR GetIFaxRoutingExtensionName (IFaxRoutingExtension *pInterface);     
LPWSTR GetIFaxRoutingExtensionImageName (IFaxRoutingExtension *pInterface);
LPWSTR GetIFaxRoutingExtensionGuid (IFaxRoutingExtension *pInterface);    

//
// ICometCRMLine related:
//
LPWSTR GetICrmLineName (ICometCRMLine *pInterface);
LPWSTR GetICrmLineTsid (ICometCRMLine *pInterface);
LPWSTR GetICrmLineCsid (ICometCRMLine *pInterface);
LPWSTR GetICrmLineProviderGuid (ICometCRMLine *pInterface);
DWORD GetICrmLinePriority (ICometCRMLine *pInterface);
DWORD GetICrmLineRings (ICometCRMLine *pInterface);
DWORD GetICrmLineTapiDeviceID (ICometCRMLine *pInterface);
BOOL GetICrmLineReceiveEnabled (ICometCRMLine *pInterface);
BOOL GetICrmLineSendEnabled (ICometCRMLine *pInterface);

DWORD GetCrmLineUniqueFaxID (ICometCRMLine *pInterface);
BOOL  SetCrmLineUniqueFaxID (ICometCRMLine *pInterface, DWORD dwID);

HRESULT FindCRMDeviceByID (DWORD dwDeviceID, ICometCRMLine **);


HRESULT
IsThisCRMLineAssignedToFax (
    ICometCRMLine *,
    PBOOL);


//
// Specific interfaces for Microsoft routing extension:
//

HRESULT GetMicrosoftFaxRoutingProperties ( IFaxAssociatedRoutingMethods *pRoutMethods,
                                           LPWSTR                       *pPrinter,
                                           LPWSTR                       *pDir,
                                           LPWSTR                       *pProfile);

HRESULT SetMicrosoftFaxRoutingProperties ( IFaxAssociatedRoutingMethods *pRoutMethods,
                                           DWORD                         dwMask,
                                           LPCWSTR                       wszPrinter,
                                           LPCWSTR                       wszDir,
                                           LPCWSTR                       wszProfile);


HRESULT 
GetCometRelativePath (
    CComBSTR &bstrInitialPath,
    CComBSTR &bstrFinalPath
);

#endif  // _FAX_DS_INTERFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\faxverify\faxvrfy\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module:
    1) Finds the device name of a port
    2) Initializes NTLog
    3) Starts the log file
    4) Closes the log file
    5) Gets the current time
    6) Writes a string to the log and text files
    7) Checks if an edit control string is composed of only ASCII characters
    8) Encodes a TSID
    9) Decodes a TSID

Author:

  Steven Kehrli (steveke) 11/15/1997

--*/

#ifndef _UTIL_C
#define _UTIL_C

VOID
fnFindDeviceName(
    PFAX_PORT_INFO  pFaxPortsConfig,
    DWORD           dwNumPorts,
    DWORD           dwDeviceId,
    LPWSTR          *pszDeviceName
)
/*++

Routine Description:

  Finds the device name of a port

Arguments:

  pFaxPortsConfig - pointer to the fax ports configuration
  dwNumFaxPorts - number of ports
  dwDeviceId - port id
  pszDeviceName - device name

Return Value:

  None

--*/
{
    // dwIndex is a counter to enumerate each port
    DWORD  dwIndex;

    // Set szDeviceName to NULL
    *pszDeviceName = NULL;

    for (dwIndex = 0; dwIndex < dwNumPorts; dwIndex++) {
        // Search, by priority, each port for the appropriate port
        if (pFaxPortsConfig[dwIndex].DeviceId == dwDeviceId) {
            if (pFaxPortsConfig[dwIndex].DeviceName) {
                *pszDeviceName = (LPWSTR) pFaxPortsConfig[dwIndex].DeviceName;
            }
            return;
        }
    }
}

BOOL
fnInitializeNTLog(
)
/*++

Routine Description:

  Initializes NTLog

Return Value:

  TRUE on success

--*/
{
    // hInstance is the handle to the NTLog dll
    HINSTANCE  hInstance;

    // Get the handle to the NTLog dll
    hInstance = LoadLibrary((LPCWSTR) NTLOG_DLL);
    if (!hInstance) {
        DebugMacro(L"LoadLibrary(%s) failed, ec = 0x%08x\n", NTLOG_DLL, GetLastError());
        return FALSE;
    }

    // Map all needed functions

    g_NTLogApi.hInstance = hInstance;

    // tlCreateLog
    g_NTLogApi.ptlCreateLog = (PTLCREATELOG) GetProcAddress(hInstance, "tlCreateLog_W");

    if (!g_NTLogApi.ptlCreateLog) {
        DebugMacro(L"GetProcAddress(tlCreateLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // tlDestroyLog
    g_NTLogApi.ptlDestroyLog = (PTLDESTROYLOG) GetProcAddress(hInstance, "tlDestroyLog");

    if (!g_NTLogApi.ptlDestroyLog) {
        DebugMacro(L"GetProcAddress(tlDestroyLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // tlAddParticipant
    g_NTLogApi.ptlAddParticipant = (PTLADDPARTICIPANT) GetProcAddress(hInstance, "tlAddParticipant");

    if (!g_NTLogApi.ptlAddParticipant) {
        DebugMacro(L"GetProcAddress(tlAddParticipant) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // tlRemoveParticipant
    g_NTLogApi.ptlRemoveParticipant = (PTLREMOVEPARTICIPANT) GetProcAddress(hInstance, "tlRemoveParticipant");

    if (!g_NTLogApi.ptlRemoveParticipant) {
        DebugMacro(L"GetProcAddress(tlRemoveParticipant) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    // tlLog
    g_NTLogApi.ptlLog = (PTLLOG) GetProcAddress(hInstance, "tlLog_W");

    if (!g_NTLogApi.ptlLog) {
        DebugMacro(L"GetProcAddress(tlLog) failed, ec = 0x%08x\n", GetLastError());
        FreeLibrary(hInstance);
        hInstance = NULL;
		return FALSE;
    }

    return TRUE;
}

VOID
fnStartLogFile(
)
/*++

Routine Description:

  Starts the log file

Return Value:

  None

--*/
{
    // cUnicodeBOM is the Unicode BOM
    WCHAR  cUnicodeBOM = 0xFEFF;
    DWORD  cb;

    // Create the new text log file
    g_hTxtFile = CreateFile(FAXVRFY_TXT, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    WriteFile(g_hLogFile, &cUnicodeBOM, sizeof(WCHAR), &cb, NULL);

    // Create the new NTLog log file
    if (g_bNTLogAvailable) {
        g_hLogFile = (HANDLE) g_NTLogApi.ptlCreateLog(FAXVRFY_LOG, TLS_INFO | TLS_SEV2 | TLS_WARN | TLS_PASS | TLS_TEST | TLS_VARIATION | TLS_REFRESH);
        g_NTLogApi.ptlAddParticipant(g_hLogFile, 0, 0);
    }
}

VOID
fnCloseLogFile(
)
/*++

Routine Description:

  Closes the log file

Return Value:

  None

--*/
{
    CloseHandle(g_hTxtFile);
	g_hTxtFile = NULL;

    if (g_bNTLogAvailable) {
        g_NTLogApi.ptlRemoveParticipant(g_hLogFile);
        g_NTLogApi.ptlDestroyLog(g_hLogFile);
        FreeLibrary(g_NTLogApi.hInstance);
		g_NTLogApi.hInstance = NULL;
    }
}

VOID
fnGetCurrentTime(
    LPWSTR  *szCurrentTime
)
/*++

Routine Description:

  Gets the current time

Arguments:

  szFaxTime - string representation of the current time

Return Value:

  None

--*/
{
    // CurrentTime is the current time
    SYSTEMTIME  CurrentTime;
    // lcid is the default locale
    LCID        lcid;
    // szDate is the date
    LPWSTR      szDate;
    // szTime is the time
    LPWSTR      szTime;
    DWORD       cb;

    // Set szCurrentTime to NULL
    *szCurrentTime = NULL;

    // Get the current time
    GetLocalTime(&CurrentTime);

    // Get the default locale
    lcid = GetUserDefaultLCID();

    // Determine the memory required by the date
    cb = GetDateFormat(lcid, DATE_SHORTDATE, &CurrentTime, NULL, NULL, 0);
    // Allocate the memory for the date
    szDate = (LPWSTR)MemAllocMacro(cb * sizeof(WCHAR));
    // Get the date
    GetDateFormat(lcid, DATE_SHORTDATE, &CurrentTime, NULL, szDate, cb);

    // Determine the memory required by the time
    cb = GetTimeFormat(lcid, TIME_FORCE24HOURFORMAT, &CurrentTime, NULL, NULL, 0);
    // Allocate the memory for the time
    szTime = (LPWSTR)MemAllocMacro(cb * sizeof(WCHAR));
    // Get the time
    GetTimeFormat(lcid, 0, &CurrentTime, NULL, szTime, cb);

    // Allocate the memory for the time of the fax
    *szCurrentTime = (LPWSTR)MemAllocMacro((lstrlen(szDate) + lstrlen(szTime) + 4) * sizeof(WCHAR));
    // Copy the date
    lstrcpy(*szCurrentTime, szDate);
    // Append a space
    lstrcat(*szCurrentTime, L" ");
    // Append the time
    lstrcat(*szCurrentTime, szTime);
    lstrcat(*szCurrentTime, L"\r\n");
}

VOID
fnWriteLogFile(
    BOOL    bTime,
    LPWSTR  szFormatString,
    ...
)
/*++

Routine Description:

  Writes a string to the log and text files

Arguments:

  bTime - indicates current time should be logged
  szFormatString - pointer to the string

Return Value:

  None

--*/
{
    va_list  varg_ptr;
    // szOutputString is the output string
    WCHAR    szOutputString[1024];
    // szCurrentTime is the current time
    LPWSTR   szCurrentTime;
    DWORD    cb;

    if (bTime) {
        // Get the current time
        fnGetCurrentTime(&szCurrentTime);

        WriteFile(g_hTxtFile, szCurrentTime, lstrlen(szCurrentTime) * sizeof(WCHAR), &cb, NULL);

        // Free the current time
        MemFreeMacro(szCurrentTime);
    }

    va_start(varg_ptr, szFormatString);
    _vsnwprintf(szOutputString, sizeof(szOutputString), szFormatString, varg_ptr);

    WriteFile(g_hTxtFile, szOutputString, lstrlen(szOutputString) * sizeof(WCHAR), &cb, NULL);
}

BOOL
fnIsStringASCII(
    LPWSTR  szString
)
/*++

Routine Description:

  Checks if a string is composed of only ASCII characters

Arguments:

  szString - string

Return Value:

  TRUE on success

--*/
{
    // szSearchString is the string used to search for non-ASCII characters
    LPWSTR  szSearchString;
    BOOL    bRslt;

    szSearchString = szString;
    bRslt = TRUE;

    while ((*szSearchString) && (bRslt)) {
        if ((*szSearchString < (WCHAR) 0x0020) || (*szSearchString >= (WCHAR) MAXCHAR)) {
            // Found a non-ASCII character
            bRslt = FALSE;
        }

        szSearchString = CharNext(szSearchString);
    }

    return bRslt;
}

BOOL
fnIsEditControlASCII(
    HWND   hWnd,
    UINT   uResource,
    DWORD  dwResourceLen
)
/*++

Routine Description:

  Checks if an edit control string is composed of only ASCII characters

Arguments:

  hWnd - handle to the window
  uResource - edit control resource id
  dwResourceLen - length of the edit control

Return Value:

  TRUE on success

--*/
{
    // szResourceString is the edit control string
    LPWSTR  szResourceString;
    BOOL    bRslt;

    bRslt = TRUE;

    // Allocate the memory for the edit control string
    szResourceString = (LPWSTR)MemAllocMacro(dwResourceLen * sizeof(WCHAR));

    // Get the edit control string
    GetDlgItemText(hWnd, uResource, szResourceString, dwResourceLen);

    bRslt = fnIsStringASCII(szResourceString);

    MemFreeMacro(szResourceString);

    return bRslt;
}

VOID
fnEncodeTsid(
    LPWSTR  szTsid,
    LPWSTR  szControlChars,
    LPWSTR  szEncodedTsid
)
/*++

Routine Description:

  Encodes a TSID

Arguments:

  szTsid - original TSID
  szControlChars - control characters to prepend TSID
  szEncodedTsid - encoded TSID

  Encoding a TSID is difficult.  Each ASCII value of the TSID must fall in the range 32 (0x0020) and 126 (0x009E), a range of 95.
  The TSID is encoded as follows:
     1) Prepend TSID with the control characters.  The control characters are used to verify FaxVrfy sent the fax.
     2) Create a random number based on wMilliseconds:
        1) wMilliseconds MOD 48 (0x0030): This gives a range of 0 - 48, half the ASCII value range of TSID
        2) Add 24 (0x0018): This moves the range to 24 - 72, guaranteeing the ASCII values of the TSID will be changed.
     3) Create a shift number based on the random number:
        1) wRandomNumber MOD (TSID length / 2): This gives a range of 0 - (TSID length / 2), half the TSID length
        2) Add (TSID length / 4): This moves the range to (TSID length / 4) - 3 * (TSID length / 4), guaranteeing the ASCII values of the TSID will be shifted.
     4) Create an intermediate string where each ASCII value of the intermediate string is
        1) Subtract 32 (0x0020) from each ASCII value of the TSID: This gives a range of 0 - 94.
        2) Add the random number
        3) MOD 95 (0x005F): This ensures each ASCII value of the intermediate string is in the range 0 - 94.
        4) Add 32 (0x0020): This moves the range back to 32 - 126.
     5) Create an array of pointers to each ASCII value of the encoded TSID
     6) Determine the appropriate offset in the encoded TSID
        1) Add the shift number to the current offset
        2) MOD (TSID length - wIndex): This ensures the offset is in the range 0 - (number of remaining offsets).
     7) Place the next ASCII value of the intermediate string into the appropriate offset in the encoded TSID
     8) Compact the remaining offsets of the encoded TSID
     9) Repeat steps 6 - 8 until all offsets have been used
    10) Create the final encoded string
        1) Add 32 (0x0020) to the random number: This ensure the random number is in the range 56 - 104.
        2) Set the first character of the encoded string to the ASCII value of the random number.
        3) Concatenate the encoded string with the encoded TSID

Return Value:

  None

--*/
{
    // szControlString is the TSID prepended by the control characters
    WCHAR       szControlString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szEncodeChar is the encoding character
    WCHAR       szEncodeChar[ENCODE_CHAR_LEN + 1] = {'\0'};
    // szIntermediateString is the intermediate encoded string
    WCHAR      szIntermediateString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szFinalString is the final encoded string
    WCHAR       szFinalString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szShiftChars is an array of pointers to each ASCII value of the encoded TSID
    LPWSTR      szShiftChars[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};

    // SystemTime is the current system time where wMilliseconds is used to generate wRandomNumber and wShiftNumber
    SYSTEMTIME  SystemTime;
    // wRandomNumber is a number to increment each ASCII value of the TSID
    WORD        wRandomNumber;
    // wShiftNumber is a number to shift the order of each ASCII value of the TSID
    WORD        wShiftNumber;
    // wIndex is a counter to enumerate each ASCII value of the TSID
    WORD        wIndex;
    // wOffset is a counter to identify the appropriate offset of the encoded TSID when shifting each ASCII value of the TSID
    WORD        wOffset;
    // wCompact is a counter to compact the remaining offsets of the encoded TSID
    WORD        wCompact;

    // Set szControlString
    lstrcpy(szControlString, szControlChars);
    lstrcat(szControlString, szTsid);

    // Get the current system time
    GetSystemTime(&SystemTime);

    // Create the random number: (wMilliseconds MOD 48) + 24
    wRandomNumber = (SystemTime.wMilliseconds % (WORD) 0x0030) + (WORD) 0x0018;
    // Create the shift number: (wRandomNumber MOD (lstrlen(szControlString) / 2)) + (lstrlen(szControlString) / 4)
    wShiftNumber = ((wRandomNumber) % ((WORD) lstrlen(szControlString) / 2)) + ((WORD) lstrlen(szControlString) / 4);

    // Set szEncodeChar
    szEncodeChar[0] = (WCHAR) wRandomNumber + (WCHAR) 0x0020;

    for (wIndex = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Create the intermediate string: ((ASCII value of the TSID - 32 + wRandomNumber) MOD 95) + 32
        szIntermediateString[wIndex] = ((szControlString[wIndex] - (WCHAR) 0x0020 + (WCHAR) wRandomNumber) % (WCHAR) 0x005F) + (WCHAR) 0x0020;
    }

    for (wIndex = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Create the list of remaining offsets of the encoded TSID
        szShiftChars[wIndex] = (LPWSTR) ((UINT_PTR) szFinalString + (sizeof(WCHAR) * wIndex));
    }

    for (wIndex = 0, wOffset = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Determine the appropriate offset of the encoded TSID
        wOffset = (wOffset + wShiftNumber) % (lstrlen(szIntermediateString) - wIndex);
        // Set the appropriate offset of the encoded TSID
        *((LPWSTR) szShiftChars[wOffset]) = szIntermediateString[wIndex];
        // Compact the remaining offsets of the encoded TSID
        for (wCompact = wOffset; wCompact < (lstrlen(szIntermediateString) - wIndex); wCompact++) {
            szShiftChars[wCompact] = szShiftChars[wCompact + 1];
        }
    }

    // Set szEncodedTsid
    lstrcpy(szEncodedTsid, szEncodeChar);
    lstrcat(szEncodedTsid, szFinalString);
}

BOOL
fnDecodeTsid(
    LPWSTR  szTsid,
    LPWSTR  szControlChars,
    LPWSTR  szDecodedTsid
)
/*++

Routine Description:

  Decodes a TSID

Arguments:

  szTsid - encoded TSID
  szControlChars - control characters to prepend TSID
  szDecodedTsid - decoded TSID

  The TSID is decoded as follows:
     1) Isolate the encoded TSID from the random number.
     2) Get the random number:
        1) The first character in the TSID is the ASCII value of the random number
        2) Subtract 32 (0x0020) from the ASCII value to get the random number.
     3) Get the shift number based on the random number:
        1) wRandomNumber MOD (TSID length / 2): This gives a range of 0 - (TSID length / 2), half the TSID length
        2) Add (TSID length / 4): This moves the range to (TSID length / 4) - 3 * (TSID length / 4), guaranteeing the ASCII values of the TSID will be shifted.
     4) Create an array of pointers to each ASCII value of the intermediate string
     5) Determine the appropriate offset in the intermediate string
        1) Add the shift number to the current offset
        2) MOD (TSID length - wIndex): This ensures the offset is in the range 0 - (number of remaining offsets).
     6) Place the next ASCII value of the encoded TSID into the appropriate offset in the intermediate string
     7) Compact the remaining offsets of the intermediate string
     8) Repeat steps 6 - 8 until all offsets have been used
     9) Create the final string where each ASCII value of the final string is
        1) Subtract 32 (0x0020) from each ASCII value of the intermediate string: This gives a range of 0 - 94.
        2) Add 95 (0x005F): This ensures each ASCII value will not underflow when subtracting the random number.
        3) Subtract the random number
        3) MOD 95 (0x005F): This ensures each ASCII value of the intermediate string is in the range 0 - 94.
        4) Add 32 (0x0020): This moves the range back to 32 - 126.
    10) Create the final decoded string
    11) Isolate and compare the control characters

Return Value:

  TRUE if control characters match

--*/
{
    // szControlString is the TSID prepended by the control characters
    WCHAR   szControlString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szEncodeChar is the encoding character
    WCHAR   szEncodeChar[ENCODE_CHAR_LEN + 1] = {'\0'};
    // szIntermediateString is the intermediate encoded string
    WCHAR   szIntermediateString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szFinalString is the final encoded string
    WCHAR   szFinalString[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};
    // szShiftChars is an array of pointers to each ASCII value of the encoded TSID
    LPWSTR  szShiftChars[CONTROL_CHAR_LEN + PHONE_NUM_LEN + 1] = {'\0'};

    // wRandomNumber is a number to decrement each ASCII value of the encoded TSID
    WORD    wRandomNumber;
    // wShiftNumber is a number to shift the order of each ASCII value of the encoded TSID
    WORD    wShiftNumber;
    // wIndex is a counter to enumerate each ASCII value of the TSID
    WORD    wIndex;
    // wOffset is a counter to identify the appropriate offset of the decoded TSID when shifting each ASCII value of the encoded TSID
    WORD    wOffset;
    // wCompact is a counter to compact the remaining offsets of the decoded TSID
    WORD    wCompact;

    // Get szControlString
    lstrcpy(szControlString, (LPWSTR) ((UINT_PTR) szTsid + sizeof(WCHAR)));

    // Get szEncodeChar
    szEncodeChar[0] = *szTsid;

    // Get the random number
    wRandomNumber = (WORD) ((WCHAR) szEncodeChar[0] - (WCHAR) 0x0020);
    // Create the shift number: (wRandomNumber MOD (lstrlen(szControlString) / 2)) + (lstrlen(szControlString) / 4)
    wShiftNumber = ((wRandomNumber) % ((WORD) lstrlen(szControlString) / 2)) + ((WORD) lstrlen(szControlString) / 4);

    for (wIndex = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Create the list of remaining offsets of the decoded TSID
        szShiftChars[wIndex] = (LPWSTR) ((UINT_PTR) szControlString + (sizeof(WCHAR) * wIndex));
    }

    for (wIndex = 0, wOffset = 0; wIndex < (WORD) lstrlen(szControlString); wIndex++) {
        // Determine the appropriate offset of the decoded TSID
        wOffset = (wOffset + wShiftNumber) % (lstrlen(szControlString) - wIndex);
        // Set the appropriate offset of the decoded TSID
        szIntermediateString[wIndex] = *((LPWSTR) szShiftChars[wOffset]);
        // Compact the remaining offsets of the decoded TSID
        for (wCompact = wOffset; wCompact < (lstrlen(szControlString) - wIndex); wCompact++) {
            szShiftChars[wCompact] = szShiftChars[wCompact + 1];
        }
    }

    for (wIndex = 0; wIndex < (WORD) lstrlen(szIntermediateString); wIndex++) {
        // Create the final string: ((ASCII value of the TSID - 32 + 95 - wRandomNumber) MOD 95) + 32
        szFinalString[wIndex] = ((szIntermediateString[wIndex] - (WCHAR) 0x0020 + (WCHAR) 0x005F - (WCHAR) wRandomNumber) % (WCHAR) 0x005F) + (WCHAR) 0x0020;
    }

    // Set szDecodedTsid
    lstrcpy(szDecodedTsid, (LPWSTR) ((UINT_PTR) szFinalString + lstrlen(szControlChars) * sizeof(WCHAR)));

    // Isolate the control characters
    lstrcpy((LPWSTR) ((UINT_PTR) szFinalString + lstrlen(szControlChars) * sizeof(WCHAR)), L"\0");
    // Compare the control characters
    return lstrcmp(szControlChars, szFinalString) ? FALSE : TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxdev.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider API.

--*/

#include <commctrl.h>


#ifndef _FAXDEV_
#define _FAXDEV_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// FAX status constants
//

#define FS_INITIALIZING         0x20000000
#define FS_DIALING              0x20000001
#define FS_TRANSMITTING         0x20000002
#define FS_RECEIVING            0x20000004
#define FS_COMPLETED            0x20000008
#define FS_HANDLED              0x20000010
#define FS_LINE_UNAVAILABLE     0x20000020
#define FS_BUSY                 0x20000040
#define FS_NO_ANSWER            0x20000080
#define FS_BAD_ADDRESS          0x20000100
#define FS_NO_DIAL_TONE         0x20000200
#define FS_DISCONNECTED         0x20000400
#define FS_FATAL_ERROR          0x20000800  // see the stringid for the real status
#define FS_NOT_FAX_CALL         0x20001000
#define FS_CALL_DELAYED         0x20002000
#define FS_CALL_BLACKLISTED     0x20004000
#define FS_USER_ABORT           0x20200000
#define FS_ANSWERED             0x20800000


//
// data structures
//

typedef struct _FAX_SEND {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  CallerName;
    LPWSTR  CallerNumber;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    BOOL    Branding;
    HCALL   CallHandle;
    DWORD   Reserved[3];
} FAX_SEND, *PFAX_SEND;

typedef struct _FAX_RECEIVE {
    DWORD   SizeOfStruct;
    LPWSTR  FileName;
    LPWSTR  ReceiverName;
    LPWSTR  ReceiverNumber;
    DWORD   Reserved[4];
} FAX_RECEIVE, *PFAX_RECEIVE;

typedef struct _FAX_DEV_STATUS {
    DWORD   SizeOfStruct;
    DWORD   StatusId;
    DWORD   StringId;
    DWORD   PageCount;
    LPWSTR  CSI;
    LPWSTR  CallerId;
    LPWSTR  RoutingInfo;
    DWORD   ErrorCode;
    DWORD   Reserved[3];
} FAX_DEV_STATUS, *PFAX_DEV_STATUS;

typedef BOOL
(CALLBACK *PFAX_SERVICE_CALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

typedef void
(CALLBACK *PFAX_LINECALLBACK)(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD_PTR dwInstance,
    IN DWORD_PTR dwParam1,
    IN DWORD_PTR dwParam2,
    IN DWORD_PTR dwParam3
    );

BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );

HRESULT WINAPI FaxDevShutdown(
    void
);

BOOL WINAPI
FaxDevVirtualDeviceCreation(
    OUT LPDWORD DeviceCount,
    OUT LPWSTR DeviceNamePrefix,
    OUT LPDWORD DeviceIdPrefix,
    IN  HANDLE CompletionPort,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle,
    IN  HANDLE CompletionPortHandle,
    IN  ULONG_PTR CompletionKey
    );

BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    );

typedef BOOL
(CALLBACK *PFAX_SEND_CALLBACK)(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    );

BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    );

#define FAXDEVRECEIVE_SIZE 4096

BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    );

#define FAXDEVREPORTSTATUS_SIZE 4096

BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    );

BOOL WINAPI
FaxDevConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    );


typedef BOOL (WINAPI *PFAXDEVINITIALIZE)                (HLINEAPP,HANDLE,PFAX_LINECALLBACK*,PFAX_SERVICE_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVVIRTUALDEVICECREATION)     (LPDWORD,LPWSTR,LPDWORD,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVSTARTJOB)                  (HLINE,DWORD,PHANDLE,HANDLE,ULONG_PTR);
typedef BOOL (WINAPI *PFAXDEVENDJOB)                    (HANDLE);
typedef BOOL (WINAPI *PFAXDEVSEND)                      (HANDLE,PFAX_SEND,PFAX_SEND_CALLBACK);
typedef BOOL (WINAPI *PFAXDEVRECEIVE)                   (HANDLE,HCALL,PFAX_RECEIVE);
typedef BOOL (WINAPI *PFAXDEVREPORTSTATUS)              (HANDLE,PFAX_DEV_STATUS,DWORD,LPDWORD);
typedef BOOL (WINAPI *PFAXDEVABORTOPERATION)            (HANDLE);
typedef BOOL (WINAPI *PFAXDEVCONFIGURE)                 (HPROPSHEETPAGE*);
typedef HRESULT (WINAPI * PFAXDEVSHUTDOWN)              (void);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\debugex.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Debug.h

Abstract:

    Interface for the CDebug class.

Author:

    Eran Yariv (EranY)  Jul, 1999

Revision History:

--*/

#if !defined(AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_)
#define AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined(DEBUG)
    #if defined(_DEBUG)
        #define DEBUG
    #elif defined(DBG)
        #define DEBUG
    #endif
#endif

//
// Remove previous declarations:
//
#if defined(ASSERTION)
    #undef ASSERTION
#endif

#ifdef VERBOSE
    #undef VERBOSE
#endif

#ifdef ASSERTION_FAILURE
    #undef ASSERTION_FAILURE
#endif

#include <FaxDebug.h>
//
// Bit-mask of errors / messages :
//
typedef enum 
{
    ASSERTION_FAILED        = 0x00000001,    // Debug messages are displayed when an assertion fails
    DBG_MSG                 = 0x00000002,    // General messages (not warnings or errors)
    FUNC_TRACE              = 0x00000004,    // Function entry / exit traces
    DBG_WARNING             = 0x00000008,    // Warnings
    MEM_ERR                 = 0x00000010,    // Errors start from here...
    COM_ERR                 = 0x00000020,
    RESOURCE_ERR            = 0x00000040,
    STARTUP_ERR             = 0x00000080,
    GENERAL_ERR             = 0x00000100,
    EXCEPTION_ERR           = 0x00000200,
    RPC_ERR                 = 0x00000400,
    WINDOW_ERR              = 0x00000800,
    FILE_ERR                = 0x00001000,
    SECURITY_ERR            = 0x00002000,
    REGISTRY_ERR            = 0x00004000,
    PRINT_ERR               = 0x00008000,
    SETUP_ERR               = 0x00010000,
    NET_ERR                 = 0x00020000,
    SCM_ERR                 = 0x00040000,

    DBG_ERRORS_ONLY         = 0xFFFFFFF1,   // everything but DBG_MSG,FUNC_TRACE,DBG_WARNING
    DBG_ERRORS_WARNINGS     = 0xFFFFFFF9,   // everything but DBG_MSG,FUNC_TRACE
    DBG_ALL                 = 0xFFFFFFFF
}   DbgMsgType;

#ifdef ENABLE_FRE_LOGGING
#define ENABLE_LOGGING
#endif

#ifdef DEBUG 
#define ENABLE_LOGGING
#endif

#ifdef ENABLE_LOGGING

#define DEFAULT_DEBUG_MASK          ASSERTION_FAILED
#define DEFAULT_FORMAT_MASK         DBG_PRNT_ALL_TO_STD

// use these in your debugging sessions
#define DBG_ENTER       CDebug debugObject
#define VERBOSE         debugObject.Trace

#ifndef DEBUG
#define DebugBreak() ;
#endif

#define ASSERTION_FAILURE   {                                               \
                                debugObject.DbgPrint  (ASSERTION_FAILED,    \
                                        TEXT(__FILE__),                     \
                                        __LINE__,                           \
                                        TEXT("ASSERTION FAILURE!!!"));      \
                                DebugBreak();                               \
							}

#define ASSERTION(x)        if (!(x)) ASSERTION_FAILURE

#define CALL_FAIL(t,szFunc,hr)                                  \
    debugObject.DbgPrint(t,                                     \
    TEXT(__FILE__),                                             \
    __LINE__,                                                   \
    TEXT("Call to function %s failed with 0x%08X"),             \
    szFunc,                                                     \
    hr);         
//////////////////////////////////////////

// use these to cofigure the debug output
#define SET_DEBUG_MASK(m)           CDebug::SetDebugMask(m)
#define SET_FORMAT_MASK(m)          CDebug::SetFormatMask(m)

#define GET_DEBUG_MASK              CDebug::GetDebugMask()
#define GET_FORMAT_MASK             CDebug::GetFormatMask()

#define MODIFY_DEBUG_MASK(a,b)      CDebug::ModifyDebugMask(a,b)
#define MODIFY_FORMAT_MASK(a,b)     CDebug::ModifyFormatMask(a,b)

#define IS_DEBUG_SESSION_FROM_REG   CDebug::DebugFromRegistry()

#define OPEN_DEBUG_LOG_FILE(f)      CDebug::OpenLogFile(f)
#define CLOSE_DEBUG_LOG_FILE        CDebug::CloseLogFile()
#define SET_DEBUG_FILE_HANDLE(h)    CDebug::SetLogFile(h)
//////////////////////////////////////////

#ifndef _DEBUG_INDENT_SIZE
#define _DEBUG_INDENT_SIZE      3
#endif // #ifndef _DEBUG_INDENT_SIZE

class CDebug  
{
public:

    CDebug (LPCTSTR lpctstrModule) :
        m_ReturnType (DBG_FUNC_RET_UNKNOWN)
    {
        EnterModule (lpctstrModule);
    }

    CDebug (LPCTSTR lpctstrModule,
            LPCTSTR lpctstrFormat,
            ...) :
        m_ReturnType (DBG_FUNC_RET_UNKNOWN)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
    }

    CDebug (LPCTSTR lpctstrModule, HRESULT &hr)
    {
        EnterModule (lpctstrModule);
        SetHR (hr);
    }

    CDebug (LPCTSTR lpctstrModule,
            HRESULT &hr,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetHR (hr);
    }

    CDebug (LPCTSTR lpctstrModule, DWORD &dw)
    {
        EnterModule (lpctstrModule);
        SetDWRes (dw);
    }

    CDebug (LPCTSTR lpctstrModule, UINT &dw)
    {
        EnterModule (lpctstrModule);
        SetDWRes ((DWORD &)dw);
    }

    CDebug (LPCTSTR lpctstrModule,
            DWORD &dw,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetDWRes (dw);
    }

    CDebug (LPCTSTR lpctstrModule,
            UINT &dw,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetDWRes ((DWORD &)dw);
    }

    CDebug (LPCTSTR lpctstrModule, BOOL &b)
    {
        EnterModule (lpctstrModule);
        SetBOOL (b);
    }

    CDebug (LPCTSTR lpctstrModule,
            BOOL &b,
            LPCTSTR lpctstrFormat,
            ...)
    {
        va_list arg_ptr;
        va_start(arg_ptr, lpctstrFormat);
        EnterModuleWithParams (lpctstrModule, lpctstrFormat, arg_ptr);
        SetBOOL (b);
    }

    virtual ~CDebug();

    static void DbgPrint ( 
        DbgMsgType type,
        LPCTSTR    lpctstrFileName, 
        DWORD      dwLine,
        LPCTSTR    lpctstrFormat,
        ...
    );

    void Trace (
        DbgMsgType type,
        LPCTSTR    lpctstrFormat,
        ...
    );

    static void     ResetIndent()          { InterlockedExchange(&m_sdwIndent,0); }
    static void     Indent()               { InterlockedIncrement(&m_sdwIndent); }
    static void     Unindent();

    // calling any of those functions overrides the registry entries
    // SetDebugMask - overrides the DebugLevelEx entry
    // SetFormatMask - overrides the DebugFormatEx entry
    static void     SetDebugMask(DWORD dwMask);
    static void     SetFormatMask(DWORD dwMask);

    static DWORD    GetDebugMask()  { return m_sDbgMask; }
    static DWORD    GetFormatMask() { return m_sFmtMask; }

    static DWORD    ModifyDebugMask(DWORD dwAdd,DWORD dwRemove);
    static DWORD    ModifyFormatMask(DWORD dwAdd,DWORD dwRemove);

    static HANDLE   SetLogFile(HANDLE hFile);
    static BOOL     OpenLogFile(LPCTSTR lpctstrFilename);
    static void     CloseLogFile();

    // returns whether we find debug setting in the registry
    // call this before using SetDebugMask or SetFormatMask to verify 
    // if the registry is being used, so registry will decide on 
    // debug level
    static BOOL DebugFromRegistry();

private:

    static void Print (
        DbgMsgType type,
        LPCTSTR    lpctstrFileName, 
        DWORD      dwLine,
        LPCTSTR    lpctstrFormat,
        va_list    arg_ptr
    );

    void   EnterModuleWithParams (LPCTSTR lpctstrModule, 
                                  LPCTSTR lpctstrFormat, 
                                  va_list arg_ptr);

    void  EnterModule           (LPCTSTR lpctstrModule);

    void  SetHR (HRESULT &hr)           { m_ReturnType = DBG_FUNC_RET_HR; m_phr = &hr; }
    void  SetDWRes (DWORD &dw)          { m_ReturnType = DBG_FUNC_RET_DWORD; m_pDword = &dw; }
    void  SetBOOL (BOOL &b)             { m_ReturnType = DBG_FUNC_RET_BOOL; m_pBool = &b; }

    static LONG     m_sdwIndent;
    static DWORD    m_sDbgMask;                 // a combination of DbgMsgType values
    static DWORD    m_sFmtMask;                 // a combination of DbgMsgFormat values
    static HANDLE   m_shLogFile;
    static BOOL     m_sbMaskReadFromReg;        // Did we already read the debug & format mask from the registry?
    static BOOL     m_sbRegistryExist;          // Do we use debug mask of registry?
    static BOOL     ReadMaskFromReg();          // Attempt to read debug & format mask from registry.

    static LPCTSTR GetMsgTypeString(DWORD dwMask);
    static BOOL OutputFileString(LPCTSTR szMsg);

    TCHAR        m_tszModuleName[MAX_PATH];

    typedef enum 
    {   
        DBG_FUNC_RET_UNKNOWN,
        DBG_FUNC_RET_HR,
        DBG_FUNC_RET_DWORD,
        DBG_FUNC_RET_BOOL
    } DbgFuncRetType;

    DbgFuncRetType  m_ReturnType;
    HRESULT        *m_phr;
    DWORD          *m_pDword;
    BOOL           *m_pBool;

};

#define START_RPC_TIME(f)   DWORD dwRPCTimeCheck=GetTickCount();
#define END_RPC_TIME(f)     VERBOSE (DBG_MSG, TEXT("%s took %ld millisecs"), \
                                f, GetTickCount()-dwRPCTimeCheck);

#else   // ENABLE_LOGGING

#define DBG_ENTER                   void(0);
#define VERBOSE                     void(0);
#define ASSERTION_FAILURE           void(0);
#define ASSERTION(x)                void(0);
#define CALL_FAIL(t,szFunc,hr)      void(0);
#define START_RPC_TIME(f)           void(0);
#define END_RPC_TIME(f)             void(0);

#define SET_DEBUG_MASK(m)           void(0);
#define SET_FORMAT_MASK(m)          void(0);

#define GET_DEBUG_MASK              0;
#define GET_FORMAT_MASK             0;

#define MODIFY_DEBUG_MASK(a,b)      0;
#define MODIFY_FORMAT_MASK(a,b)     0;

#define IS_DEBUG_SESSION_FROM_REG   FALSE;

#define OPEN_DEBUG_LOG_FILE(f)      FALSE;
#define CLOSE_DEBUG_LOG_FILE        void(0);
#define SET_DEBUG_FILE_HANDLE(h)    void(0);

#endif  // ENABLE_LOGGING

#endif // !defined(AFX_DEBUG_H__DDEC9CAD_CF2D_4F3F_9538_2F6041A022B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxisapi.h ===
#include "winfax.h"

//
// command codes
//

#define ICMD_CONNECT                0x80000001
#define ICMD_DISCONNECT             0x80000002
#define ICMD_ENUM_PORTS             0x80000003
#define ICMD_OPEN_PORT              0x80000004
#define ICMD_GET_PORT               0x80000006
#define ICMD_SET_PORT               0x80000007
#define ICMD_CLOSE                  0x80000008
#define ICMD_GET_ROUTINGINFO        0x80000009
#define ICMD_GET_DEVICE_STATUS      0x8000000a
#define ICMD_ENUM_ROUTING_METHODS   0x8000000b
#define ICMD_ENABLE_ROUTING_METHOD  0x8000000c
#define ICMD_GET_VERSION            0x8000000d

//
// packets
//

typedef struct _IFAX_CONNECT {
    DWORD   Command;
    WCHAR   ServerName[64];
} IFAX_CONNECT, *PIFAX_CONNECT;

typedef struct _IFAX_GENERAL {
    DWORD   Command;
    HANDLE  FaxHandle;
} IFAX_GENERAL, *PIFAX_GENERAL;

typedef struct _IFAX_OPEN_PORT {
    DWORD   Command;
    HANDLE  FaxHandle;
    DWORD   DeviceId;
    DWORD   Flags;
} IFAX_OPEN_PORT, *PIFAX_OPEN_PORT;

typedef struct _IFAX_SET_PORT {
    DWORD           Command;
    HANDLE          FaxPortHandle;
    FAX_PORT_INFOW  PortInfo;
} IFAX_SET_PORT, *PIFAX_SET_PORT;

typedef struct _IFAX_GET_ROUTINGINFO {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
} IFAX_GET_ROUTINGINFO, *PIFAX_GET_ROUTINGINFO;

typedef struct _IFAX_ENABLE_ROUTING_METHOD {
    DWORD   Command;
    HANDLE  FaxPortHandle;
    WCHAR   RoutingGuid[MAX_GUID_STRING_LEN];
    BOOL    Enabled;
} IFAX_ENABLE_ROUTING_METHOD, *PIFAX_ENABLE_ROUTING_METHOD;

typedef struct _IFAX_RESPONSE_HEADER {
    DWORD   Size;
    DWORD   ErrorCode;
} IFAX_RESPONSE_HEADER, *PIFAX_RESPONSE_HEADER;





typedef BOOL (WINAPI *PUNLOADINIT)(VOID);
typedef BOOL (WINAPI *PUNLOADER)(HMODULE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\expdef.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : ExpDef.h                                               //
//                                                                         //
//  DESCRIPTION   : Definitions of 'dllexp'.                               //
//                                                                         //
//  AUTHOR        : BarakH                                                 //
//                                                                         //
//  HISTORY       :                                                        //
//      Mar 22 1998 BarakH  Init.                                          //
//      Oct 15 1998 BarakH  Move to Comet SLM.                             //
//                                                                         //
//  Copyright (C) 1996 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef EXPDEF_H_INCLUDED
#define EXPDEF_H_INCLUDED

#ifndef dllexp

/////////////////////////////////////////////////////////////////////////////
// EXPORT_COMET_LOG is defined only in the log DLL project settings.
// This causes dllexp to be defined as __declspec( dllexport ) only when
// building the DLL. Otherwise the definition is empty so the log functions
// are not exported by other code that uses the headers of the log DLL.
/////////////////////////////////////////////////////////////////////////////

#ifdef EXPORT_COMET_LOG
#define dllexp __declspec( dllexport )

#else // ! defined EXPORT_COMET_LOG
#define dllexp
#endif // EXPORT_COMET_LOG

#endif // ! defined dllexp

#endif // EXPDEF_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxcfg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxcfg.h

Abstract:

    Public interface to the fax configuration DLL

Environment:

        Windows XP fax configuration applet

Revision History:

        05/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

Note:

    The fax configuration DLL is not thread-safe. Make sure you're not
    using it simultaneously from multiples of a single process.

--*/


#ifndef _FAXCFG_H_
#define _FAXCFG_H_


//
// Fax configuration types
//

#define FAXCONFIG_CLIENT        0
#define FAXCONFIG_SERVER        1
#define FAXCONFIG_WORKSTATION   2

//
// Initialize the fax configuration DLL
//
// Parameters:
//
//  pServerName - Specifies the name of the fax server machine.
//      Pass NULL for local machine.
//
// Return value:
//
//  -1 - An error has occurred
//  FAXCONFIG_CLIENT -
//  FAXCONFIG_SERVER -
//  FAXCONFIG_WORKSTATION - Indicates the type of configuration the user can run
//

INT
FaxConfigInit(
    LPTSTR  pServerName,
    BOOL    CplInit
    );

//
// De-initialize the fax configuration DLL
//
//  You should call this function after you're done using the
//  fax configuration DLL.
//

VOID
FaxConfigCleanup(
    VOID
    );

//
// Get an array of handles to client/server/workstation configuration pages
//
// Parameters:
//
//  phPropSheetPages - Specifies a buffer for storing property page handles
//  count - Specifies the maximum number of handles the input buffer can hold
//
// Return value:
//
//  -1 - An error has occurred
//  >0 - Total number of configuration pages available
//
// Note:
//
//  To figure out how large the input buffer should be, the caller can
//  first call these functions with phPropSheetPages set to NULL and
//  count set to 0.
//

INT
FaxConfigGetClientPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetServerPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

INT
FaxConfigGetWorkstationPages(
    HPROPSHEETPAGE *phPropSheetPages,
    INT             count
    );

#endif  // !_FAXCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxmmc.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxmmc.h

Abstract:

    This header file contains public constants for extension of MMC components.

--*/

#ifndef H_FXS_MMCEXT_H
#define H_FXS_MMCEXT_H

#define FAXSRV_DEVICE_NODETYPE_GUID_STR OLESTR("{3115A19A-6251-46ac-9425-14782858B8C9}")
#define FAXSRV_DEVICE_NODETYPE_GUID { 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } }

#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID_STR OLESTR("{BD38E2AC-B926-4161-8640-0F6956EE2BA3}")
#define FAXSRV_DEVICE_PROVIDER_NODETYPE_GUID { 0xbd38e2ac, 0xb926, 0x4161, { 0x86, 0x40, 0x0f, 0x69, 0x56, 0xee, 0x2b, 0xa3 } }

#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID_STR OLESTR("{220D2CB0-85A9-4a43-B6E8-9D66B44F1AF5}")
#define FAXSRV_ROUTING_METHOD_NODETYPE_GUID { 0x220d2cb0, 0x85a9, 0x4a43, { 0xb6, 0xe8, 0x9d, 0x66, 0xb4, 0x4f, 0x1a, 0xf5 } }

#define FAXSRV_MAX_GUID_LEN              sizeof(FAXSRV_DEVICE_NODETYPE_GUID_STR)/sizeof(WCHAR)
#define FAXSRV_MAX_SERVER_NAME           MAX_PATH
#define FAXSRV_MAX_ROUTEEXT_NAME_LEN     MAX_PATH

#define CF_MSFAXSRV_DEVICE_ID           TEXT("FAXSRV_DeviceID")
#define CF_MSFAXSRV_FSP_GUID            TEXT("FAXSRV_FSPGuid")
#define CF_MSFAXSRV_SERVER_NAME         TEXT("FAXSRV_ServerName")
#define CF_MSFAXSRV_ROUTEEXT_NAME       TEXT("FAXSRV_RoutingExtName")
#define CF_MSFAXSRV_ROUTING_METHOD_GUID TEXT("FAXSRV_RoutingMethodGuid")

#endif  //H_FXS_MMCEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxext.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxext.h

Abstract:

    Declarations of fax extension configuration and notification functions.

--*/


#ifndef _FAX_EXT_H_
#define _FAX_EXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/************************************
*                                   *
*   Extension configuration data    *
*                                   *
************************************/

typedef enum
{
    DEV_ID_SRC_FAX,         // Device id is generated by the fax server of EFSP
    DEV_ID_SRC_TAPI         // Device id is generated by a TAPI TSP (of FSP).
}   FAX_ENUM_DEVICE_ID_SOURCE;

//
// Prototype of FaxExtGetData 
// 
DWORD
FaxExtGetData (
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                     *ppData,         // (Out) Pointer to allocated data
    LPDWORD                     lpdwDataSize    // (Out) Pointer to data size
);
typedef DWORD (CALLBACK *PFAX_EXT_GET_DATA) (DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE *, LPDWORD);

//
// Prototype of FaxExtSetData 
// 
DWORD
FaxExtSetData (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    LPBYTE                      pData,          // Pointer to  data
    DWORD                       dwDataSize      // Data size
);
typedef DWORD (CALLBACK *PFAX_EXT_SET_DATA) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, LPBYTE, DWORD);

HRESULT
FaxExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrDataGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
);
typedef HRESULT (WINAPI *PFAX_EXT_CONFIG_CHANGE) (DWORD, LPCWSTR, LPBYTE, DWORD);

//
// Prototype of FaxExtRegisterForEvents 
//
HANDLE
FaxExtRegisterForEvents (
    HINSTANCE                   hInst,          // Instance of calling extension
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrDataGUID,// GUID of data
    PFAX_EXT_CONFIG_CHANGE      lpConfigChangeCallback
);
typedef HANDLE (CALLBACK *PFAX_EXT_REGISTER_FOR_EVENTS) (HINSTANCE, DWORD, FAX_ENUM_DEVICE_ID_SOURCE, LPCWSTR, PFAX_EXT_CONFIG_CHANGE);

//
// Prototype of FaxExtUnregisterForEvents 
//
DWORD
FaxExtUnregisterForEvents (
    HANDLE      hNotification
);
typedef DWORD (CALLBACK *PFAX_EXT_UNREGISTER_FOR_EVENTS) (HANDLE);

//
// Prototype of FaxExtFreeBuffer
//
VOID
FaxExtFreeBuffer (
    LPVOID lpvBuffer
);
typedef VOID (CALLBACK *PFAX_EXT_FREE_BUFFER) (LPVOID);

//
// The extension should implement and export the following function:
//
HRESULT 
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA,              // Pointer to FaxExtGetExtensionData in service
    PFAX_EXT_SET_DATA,              // Pointer to FaxExtSetExtensionData in service
    PFAX_EXT_REGISTER_FOR_EVENTS,   // Pointer to FaxExtRegisterForExtensionEvents in service
    PFAX_EXT_UNREGISTER_FOR_EVENTS, // Pointer to FaxExtUnregisterForExtensionEvents in service
    PFAX_EXT_FREE_BUFFER            // Pointer to FaxExtFreeBuffer in service
);
typedef HRESULT (WINAPI *PFAX_EXT_INITIALIZE_CONFIG) (PFAX_EXT_GET_DATA, PFAX_EXT_SET_DATA, PFAX_EXT_REGISTER_FOR_EVENTS, PFAX_EXT_UNREGISTER_FOR_EVENTS, PFAX_EXT_FREE_BUFFER);

#ifdef __cplusplus
}
#endif

#endif // _FAX_EXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxlog.h ===
/*++


Module Name:

 faxlog.h

Abstract:

    This is the main fax service logging header file.

Author:



Revision History:

--*/

#ifndef _FAX_LOG
#define _FAX_LOG

#include "faxlogres.h"

#define MAX_LOG_STRING 256

#define INBOX_TABLE             TEXT("Inbox")
#define OUTBOX_TABLE            TEXT("Outbox")
#define EMPTY_LOG_STRING             TEXT(" ")
#define TAB_LOG_STRING               TEXT("    ")   // Define '/t' to 4 spaces ,so we can use TAB as a delimeter
#define NEW_LINE_LOG_CHAR            TEXT(' ')      // Define '/n' to 1 space ,so we can log strings with '/n'


#define FIELD_TYPE_TEXT     TEXT("Char")
#define FIELD_TYPE_DATE     TEXT("Date")
#define FIELD_TYPE_LONG     TEXT("Long")

typedef struct _LOG_STRING_TABLE {
    DWORD   FieldStringResourceId;
    LPTSTR  Type;
    DWORD   Size;
    LPTSTR  String;
} LOG_STRING_TABLE, *PLOG_STRING_TABLE;



extern HANDLE g_hInboxActivityLogFile;
extern HANDLE g_hOutboxActivityLogFile;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxdevex.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxdevex.h

Abstract:

    This file contains the prototypes, etc for the
    FAX device provider extended API.

--*/

#ifndef _FAX_DEV_EX_H_
#define _FAX_DEV_EX_H_

#include <faxdev.h>

#include <oleauto.h>

//
// Extended Fax Service Provider Interface
//


//
// Maximum string length constants
//
#define FSPI_MAX_FRIENDLY_NAME  256

//
// FaxServiceCallbackEx() message types
//
#define FSPI_MSG_VIRTUAL_DEVICE_STATUS              0x00000001
#define FSPI_MSG_VIRTUAL_DEVICE_LIST_CHANGED        0x00000002
#define FSPI_MSG_JOB_STATUS                         0x00000003

//
// FSPI_MSG_VIRTUAL_DEVICE_STATUS status codes
//
#define FSPI_DEVSTATUS_READY_TO_SEND                 0x00000001
#define FSPI_DEVSTATUS_CAN_NOT_SEND                  0x00000002
#define FSPI_DEVSTATUS_NEW_INBOUND_MESSAGE           0x00000003
#define FSPI_DEVSTATUS_RINGING                       0x00000004

//
// Job Queue Status codes
//

#define FSPI_JS_UNKNOWN             0x00000001
#define FSPI_JS_PENDING             0x00000002
#define FSPI_JS_INPROGRESS          0x00000003
#define FSPI_JS_SUSPENDING          0x00000004
#define FSPI_JS_SUSPENDED           0x00000005
#define FSPI_JS_RESUMING            0x00000006
#define FSPI_JS_ABORTING            0x00000007
#define FSPI_JS_ABORTED             0x00000008
#define FSPI_JS_COMPLETED           0x00000009
#define FSPI_JS_RETRY               0x0000000A
#define FSPI_JS_FAILED              0x0000000B
#define FSPI_JS_FAILED_NO_RETRY     0x0000000C
#define FSPI_JS_DELETED             0x0000000D


//
// Extended job status codes
//

#define FSPI_ES_DISCONNECTED        0x00000001
#define FSPI_ES_INITIALIZING        0x00000002
#define FSPI_ES_DIALING             0x00000003
#define FSPI_ES_TRANSMITTING        0x00000004
#define FSPI_ES_ANSWERED            0x00000005
#define FSPI_ES_RECEIVING           0x00000006
#define FSPI_ES_LINE_UNAVAILABLE    0x00000007
#define FSPI_ES_BUSY                0x00000008
#define FSPI_ES_NO_ANSWER           0x00000009
#define FSPI_ES_BAD_ADDRESS         0x0000000A
#define FSPI_ES_NO_DIAL_TONE        0x0000000B
#define FSPI_ES_FATAL_ERROR         0x0000000C
#define FSPI_ES_CALL_DELAYED        0x0000000D
#define FSPI_ES_CALL_BLACKLISTED    0x0000000E
#define FSPI_ES_NOT_FAX_CALL        0x0000000F
#define FSPI_ES_PARTIALLY_RECEIVED  0x00000010
#define FSPI_ES_HANDLED             0x00000011
#define FSPI_ES_CALL_COMPLETED      0x00000012
#define FSPI_ES_CALL_ABORTED        0x00000013
#define FSPI_ES_PROPRIETARY         0x30000000 // Must be greater than FPS_ANSWERED to preserve
                                               // backward compatibiity with W2K FSPs

//
// Status information fields availability flags
//
#define FSPI_JOB_STATUS_INFO_PAGECOUNT             0x00000001
#define FSPI_JOB_STATUS_INFO_TRANSMISSION_START    0x00000002
#define FSPI_JOB_STATUS_INFO_TRANSMISSION_END      0x00000004




//
// EFSPI success and error HRESULT codes
//
#define FSPI_S_OK                       S_OK
#define FSPI_E_INVALID_GUID             MAKE_HRESULT(1,FACILITY_ITF,0x0001)
#define FSPI_E_DUPLICATE_IMAGE          MAKE_HRESULT(1,FACILITY_ITF,0x0002)
#define FSPI_E_DUPLICATE_TSP            MAKE_HRESULT(1,FACILITY_ITF,0x0003)
#define FSPI_E_INVALID_LOG_INFO         MAKE_HRESULT(1,FACILITY_ITF,0x0004)
#define FSPI_E_FSP_NOT_FOUND            MAKE_HRESULT(1,FACILITY_ITF,0x0005)
#define FSPI_E_INVALID_COVER_PAGE       MAKE_HRESULT(1,FACILITY_ITF,0x0006)
#define FSPI_E_CAN_NOT_CREATE_FILE      MAKE_HRESULT(1,FACILITY_ITF,0x0007)
#define FSPI_E_CAN_NOT_OPEN_FILE        MAKE_HRESULT(1,FACILITY_ITF,0x0008)
#define FSPI_E_CAN_NOT_WRITE_FILE       MAKE_HRESULT(1,FACILITY_ITF,0x0009)
#define FSPI_E_NO_DISK_SPACE            MAKE_HRESULT(1,FACILITY_ITF,0x000A)
#define FSPI_E_NOMEM                    MAKE_HRESULT(1,FACILITY_ITF,0x000B)
#define FSPI_E_FAILED                   MAKE_HRESULT(1,FACILITY_ITF,0x000C)
#define FSPI_E_INVALID_MESSAGE_ID       MAKE_HRESULT(1,FACILITY_ITF,0x000E)
#define FSPI_E_INVALID_JOB_HANDLE       MAKE_HRESULT(1,FACILITY_ITF,0x000F)
#define FSPI_E_INVALID_MSG              MAKE_HRESULT(1,FACILITY_ITF,0x0010)
#define FSPI_E_INVALID_PARAM1           MAKE_HRESULT(1,FACILITY_ITF,0x0011)
#define FSPI_E_INVALID_PARAM2           MAKE_HRESULT(1,FACILITY_ITF,0x0012)
#define FSPI_E_INVALID_PARAM3           MAKE_HRESULT(1,FACILITY_ITF,0x0013)
#define FSPI_E_INVALID_EFSP             MAKE_HRESULT(1,FACILITY_ITF,0x0014)
#define FSPI_E_BUFFER_OVERFLOW          MAKE_HRESULT(1,FACILITY_ITF,0x0015)

//
// EFSP capability flags
//
#define  FSPI_CAP_BROADCAST                         0x00000001
#define  FSPI_CAP_MULTISEND                         0x00000002
#define  FSPI_CAP_SCHEDULING                        0x00000004
#define  FSPI_CAP_ABORT_RECIPIENT                   0x00000008
#define  FSPI_CAP_ABORT_PARENT                      0x00000010
#define  FSPI_CAP_AUTO_RETRY                        0x00000020
#define  FSPI_CAP_SIMULTANEOUS_SEND_RECEIVE         0x00000040
#define  FSPI_CAP_USE_DIALABLE_ADDRESS              0x00000080

//
// Fax Log Identifiers
//
#define  FSPI_LOG_RECEIVE           0x00000001
#define  FSPI_LOG_SEND              0x00000002

//
// Cover page format constants
//

#define FSPI_COVER_PAGE_FMT_COV     0x00000001
#define EFSPI_MAX_DEVICE_COUNT      (DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_STEP - 1) // Max devices a single FSP can export

//
// data structures
//

typedef struct _FSPI_PERSONAL_PROFILE {
    DWORD      dwSizeOfStruct;
    LPWSTR     lpwstrName;
    LPWSTR     lpwstrFaxNumber;
    LPWSTR     lpwstrCompany;
    LPWSTR     lpwstrStreetAddress;
    LPWSTR     lpwstrCity;
    LPWSTR     lpwstrState;
    LPWSTR     lpwstrZip;
    LPWSTR     lpwstrCountry;
    LPWSTR     lpwstrTitle;
    LPWSTR     lpwstrDepartment;
    LPWSTR     lpwstrOfficeLocation;
    LPWSTR     lpwstrHomePhone;
    LPWSTR     lpwstrOfficePhone;
    LPWSTR     lpwstrEmail;
    LPWSTR     lpwstrBillingCode;
    LPWSTR     lpwstrTSID;
} FSPI_PERSONAL_PROFILE;

typedef FSPI_PERSONAL_PROFILE * LPFSPI_PERSONAL_PROFILE;
typedef const FSPI_PERSONAL_PROFILE * LPCFSPI_PERSONAL_PROFILE;

typedef struct _FSPI_COVERPAGE_INFO {
    DWORD   dwSizeOfStruct;
    DWORD   dwCoverPageFormat;
    LPWSTR  lpwstrCoverPageFileName;
    DWORD   dwNumberOfPages;
    LPWSTR  lpwstrNote;
    LPWSTR  lpwstrSubject;
} FSPI_COVERPAGE_INFO;


typedef FSPI_COVERPAGE_INFO * LPFSPI_COVERPAGE_INFO;
typedef const FSPI_COVERPAGE_INFO * LPCFSPI_COVERPAGE_INFO;


typedef struct _FSPI_MESSAGE_ID {
    DWORD   dwSizeOfStruct;
    DWORD   dwIdSize;
    LPBYTE  lpbId;
} FSPI_MESSAGE_ID;

typedef FSPI_MESSAGE_ID * LPFSPI_MESSAGE_ID;
typedef const FSPI_MESSAGE_ID * LPCFSPI_MESSAGE_ID;

typedef struct _FSPI_DEVICE_INFO {
    DWORD dwSizeOfStruct;
    WCHAR szFriendlyName[FSPI_MAX_FRIENDLY_NAME];
    DWORD dwId;
} FSPI_DEVICE_INFO;

typedef FSPI_DEVICE_INFO * LPFSPI_DEVICE_INFO;
typedef const FSPI_DEVICE_INFO * LPCFSPI_DEVICE_INFO;

typedef struct _FSPI_JOB_STATUS {
    DWORD dwSizeOfStruct;
    DWORD fAvailableStatusInfo;
    DWORD dwJobStatus;
    DWORD dwExtendedStatus;
    DWORD dwExtendedStatusStringId;
    LPWSTR lpwstrRemoteStationId;
    LPWSTR lpwstrCallerId;
    LPWSTR lpwstrRoutingInfo;
    DWORD dwPageCount;
    SYSTEMTIME tmTransmissionStart;
    SYSTEMTIME tmTransmissionEnd;
} FSPI_JOB_STATUS;

typedef FSPI_JOB_STATUS * LPFSPI_JOB_STATUS;
typedef const FSPI_JOB_STATUS * LPCFSPI_JOB_STATUS;


//
// EFSPI Interface Functions
//

typedef HRESULT (CALLBACK * PFAX_SERVICE_CALLBACK_EX)(
    IN HANDLE hFSP,
    IN DWORD  dwMsgType,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
) ;


HRESULT WINAPI FaxDevInitializeEx(
    IN  HANDLE                      hFSP,
    IN  HLINEAPP                    LineAppHandle,
    OUT PFAX_LINECALLBACK *         LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK_EX    FaxServiceCallbackEx,
    OUT LPDWORD                     lpdwMaxMessageIdSize
);


HRESULT WINAPI FaxDevSendEx(
    IN  HLINE                       hTapiLine,
    IN  DWORD                       dwDeviceId,
    IN  LPCWSTR                     lpcwstrBodyFileName,
    IN  LPCFSPI_COVERPAGE_INFO      lpcCoverPageInfo,
    IN  BOOL                        bAddBranding,
    IN  SYSTEMTIME                  tmSchedule,
    IN  LPCFSPI_PERSONAL_PROFILE    lpcSenderProfile,
    IN  DWORD                       dwNumRecipients,
    IN  LPCFSPI_PERSONAL_PROFILE    lpcRecipientProfiles,
    OUT LPFSPI_MESSAGE_ID           lpRecipientMessageIds,
    OUT PHANDLE                     lphRecipientJobs,
    OUT LPFSPI_MESSAGE_ID           lpParentMessageId,
    OUT LPHANDLE                    lphParentJob

);

HRESULT WINAPI FaxDevReestablishJobContext(
    IN  HLINE               hTapiLine,
    IN  DWORD               dwDeviceId,
    IN  LPCFSPI_MESSAGE_ID  lpcParentMessageId,
    OUT PHANDLE             lphParentJob,
    IN  DWORD               dwRecipientCount,
    IN  LPCFSPI_MESSAGE_ID  lpcRecipientMessageIds,
    OUT PHANDLE             lpRecipientJobs
);

HRESULT WINAPI FaxDevReportStatusEx(
  IN         HANDLE hJob,
  IN OUT     LPFSPI_JOB_STATUS lpStatus,
  IN         DWORD dwStatusSize,
  OUT        LPDWORD lpdwRequiredStatusSize
);


HRESULT WINAPI FaxDevEnumerateDevices(
    IN      DWORD dwDeviceIdBase,
    IN OUT  LPDWORD lpdwDeviceCount,
    OUT     LPFSPI_DEVICE_INFO lpDevices
);


HRESULT WINAPI FaxDevGetLogData(
    IN  HANDLE hFaxHandle,
    OUT VARIANT * lppLogData
);

typedef HRESULT (WINAPI * PFAXDEVINITIALIZEEX)
(
    IN  HANDLE                      hFSP,
    IN  HLINEAPP                    LineAppHandle,
    OUT PFAX_LINECALLBACK *         LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK_EX    FaxServiceCallbackEx,
    OUT LPDWORD                     lpdwMaxMessageIdSize
);

typedef HRESULT (WINAPI * PFAXDEVSENDEX)
(
    IN  HLINE                       hTapiLine,
    IN  DWORD                       dwDeviceId,
    IN  LPCWSTR                     lpcwstrBodyFileName,
    IN  LPCFSPI_COVERPAGE_INFO      lpcCoverPageInfo,
    IN  BOOL                        bAddBranding,
    IN  SYSTEMTIME                  tmSchedule,
    IN  LPCFSPI_PERSONAL_PROFILE    lpcSenderProfile,
    IN  DWORD                       dwNumRecipients,
    IN  LPCFSPI_PERSONAL_PROFILE    lpcRecipientProfiles,
    OUT LPFSPI_MESSAGE_ID           lpRecipientMessageIds,
    OUT PHANDLE                     lphRecipientJobs,
    OUT LPFSPI_MESSAGE_ID           lpParentMessageId,
    OUT LPHANDLE                    lphParentJob
);


typedef HRESULT (WINAPI * PFAXDEVREESTABLISHJOBCONTEXT)
(
    IN  HLINE               hTapiLine,
    IN  DWORD               dwDeviceId,
    IN  LPCFSPI_MESSAGE_ID  lpcParentMessageId,
    OUT PHANDLE             lphParentJob,
    IN  DWORD               dwRecipientCount,
    IN  LPCFSPI_MESSAGE_ID  lpcRecipientMessageIds,
    OUT PHANDLE             lpRecipientJobs
);

typedef HRESULT (WINAPI * PFAXDEVREPORTSTATUSEX)
(
  IN         HANDLE hJob,
  IN OUT     LPFSPI_JOB_STATUS lpStatus,
  IN         DWORD dwStatusSize,
  OUT        LPDWORD lpdwRequiredStatusSize
);

typedef HRESULT (WINAPI * PFAXDEVENUMERATEDEVICES)
(
    IN      DWORD dwDeviceIdBase,
    IN OUT  LPDWORD lpdwDeviceCount,
    OUT     LPFSPI_DEVICE_INFO lpDevices
);


typedef HRESULT (WINAPI * PFAXDEVGETLOGDATA)
(
    IN  HANDLE hFaxHandle,
    OUT VARIANT * lppLogData
);

//
// Microsoft Fax Cover Page Version 5 signature.
//
#define FAX_COVER_PAGE_V5_SIGNATURE \
                    {0x46, 0x41, 0x58, 0x43, \
                     0x4F, 0x56, 0x45, 0x52, \
                     0x2D, 0x56, 0x45, 0x52, \
                     0x30, 0x30, 0x35, 0x77, \
                     0x87, 0x00, 0x00, 0x00};

//
// Cover page header section
//
typedef struct
{
    BYTE    abSignature[20];
    DWORD   dwEMFSize;
    DWORD   nTextBoxes;
    SIZE    sizeCoverPage;
} FAXCOVERPAGETEMPLATEHEADER;

//
// Cover page text box.
//
typedef struct
{
    RECT        rectPosition;
    COLORREF    colorrefColor;
    LONG        lAlignment;
    LOGFONTW    logfontFont;
    WORD        wTextBoxId;
    DWORD       dwStringBytes;
} FAXCOVERPAGETEMPLATETEXTBOX;

//
// Cover page miscellaneous data.
//
typedef struct
{
    short       sScale;
    short       sPaperSize;
    short       sOrientation;
    COLORREF    colorrefPaperColor;
} FAXCOVERPAGETEMPLATEMISCDATA;

//
// Cover page text box IDs.
//
#define IDS_PROP_RP_NAME                2001 // Recipient Name
#define IDS_PROP_RP_FXNO                2003 // Recipient Fax Number
#define IDS_PROP_RP_COMP                2005 // Recipient's Company
#define IDS_PROP_RP_ADDR                2007 // Recipient's Street Address
#define IDS_PROP_RP_TITL                2009 // Recipient's Title
#define IDS_PROP_RP_DEPT                2011 // Recipient's Department
#define IDS_PROP_RP_OFFI                2013 // Recipient's Office Location
#define IDS_PROP_RP_HTEL                2015 // Recipient's Home Telephone #
#define IDS_PROP_RP_OTEL                2017 // Recipient's Office Telephone #
#define IDS_PROP_RP_TOLS                2019 // To: List
#define IDS_PROP_RP_CCLS                2021 // Cc: List
#define IDS_PROP_SN_NAME                2023 // Sender Name
#define IDS_PROP_SN_FXNO                2025 // Sender Fax #
#define IDS_PROP_SN_COMP                2027 // Sender's Company
#define IDS_PROP_SN_ADDR                2029 // Sender's Address
#define IDS_PROP_SN_TITL                2031 // Sender's Title
#define IDS_PROP_SN_DEPT                2033 // Sender's Department
#define IDS_PROP_SN_OFFI                2035 // Sender's Office Location
#define IDS_PROP_SN_HTEL                2037 // Sender's Home Telephone #
#define IDS_PROP_SN_OTEL                2039 // Sender's Office Telephone #
#define IDS_PROP_MS_SUBJ                2041 // Subject
#define IDS_PROP_MS_TSNT                2043 // Time Sent
#define IDS_PROP_MS_NOPG                2045 // # of Pages
#define IDS_PROP_MS_NOAT                2047 // # of Attachments
#define IDS_PROP_MS_BCOD                2049 // Billing Code
#define IDS_PROP_RP_CITY                2053 // Recipient's City
#define IDS_PROP_RP_STAT                2055 // Recipient's State
#define IDS_PROP_RP_ZIPC                2057 // Recipient's Zip Code
#define IDS_PROP_RP_CTRY                2059 // Recipient's Country
#define IDS_PROP_RP_POBX                2061 // Recipient's Post Office Box
#define IDS_PROP_MS_NOTE                2063 // Note



#endif // _FAX_DEV_EX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxhelp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    Help related declarations

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#ifndef _FAXHELP_H_
#define _FAXHELP_H_

#include <htmlhelp.h>

//
// Name of the help file for the fax configuration applet
//

#define FAXCFG_HELP_FILENAME    TEXT("fax.hlp")
#define FAX_HTMLHELP_FILENAME   TEXT("fax.chm")
#define FAXQUEUE_HTMLHELP_FILENAME   TEXT("faxqueue.chm")
#define FAXMMC_HTMLHELP_FILENAME   TEXT("%SystemRoot%\\help\\faxmgmt.chm")
#define FAXMMC_HTMLHELP_TOPIC   TEXT("faxmgmt.chm::/fax_mgmt_welcome.htm")


#define FAXWINHELP( iMsg, wParam, lParam, HelpIDs )       \
                                                          \
    if ((iMsg) == WM_HELP) {                              \
                                                          \
        WinHelp((HWND)((LPHELPINFO) (lParam))->hItemHandle,     \
                FAXCFG_HELP_FILENAME,                     \
                HELP_WM_HELP,                             \
                (ULONG_PTR) (HelpIDs));                    \
                                                          \
    } else {                                              \
                                                          \
        WinHelp((HWND) (wParam),                          \
                FAXCFG_HELP_FILENAME,                     \
                HELP_CONTEXTMENU,                         \
                (ULONG_PTR) (HelpIDs));                    \
    }

//
// Help topic mappings
//

#define IDH_INACTIVE                ((ULONG_PTR)-1)

// Fax Service dialog, General tab  
#define IDH_Fax_Service_General_RetryCharacteristics_GRP            101
#define IDH_Fax_Service_General_NumberOfRetries                     102
#define IDH_Fax_Service_General_MinutesBetweenRetries               103
#define IDH_Fax_Service_General_DaysUnsentJobKept                   104
#define IDH_Fax_Service_General_SendSettings_GRP                    105
#define IDH_Fax_Service_General_PrintBannerOnTop                    106
#define IDH_Fax_Service_General_UseSendingDeviceTSID                107
#define IDH_Fax_Service_General_ForceServerCoverPages               108
#define IDH_Fax_Service_General_DiscountPeriod                      109
#define IDH_Fax_Service_General_ArchiveOutgoingFaxes                110
#define IDH_Fax_Service_General_ArchiveOutgoingFaxes_Browse         111
#define IDH_Fax_Service_General_MapiProfile                         112


// Fax Service dialog, Routing tab  
#define IDH_Fax_Service_Routing_PriorityList                        201
#define IDH_Fax_Service_Routing_Up                                  202
#define IDH_Fax_Service_Routing_Down                                203

// Fax Service Modem dialog 
#define IDH_Fax_Modem_General_SendTSID                              400
#define IDH_Fax_Modem_General_ReceiveTSID                           401
#define IDH_Fax_Modem_General_RingsBeforeAnswer                     402
#define IDH_Fax_Modem_Routing_InboundRouting_GRP                    403
#define IDH_Fax_Modem_Routing_PrintTo                               404
#define IDH_Fax_Modem_Routing_SaveInFolder                          405
#define IDH_Fax_Modem_Routing_SendToLocalInbox                      406
#define IDH_Fax_Modem_Routing_ProfileName                           407
#define IDH_Fax_Modem_General_Send_GRP                              408
#define IDH_Fax_Modem_General_Receive_GRP                           409
#define IDH_Fax_Modem_General_Send                                  410
#define IDH_Fax_Modem_General_Receive                               411

// User Info tab in printer dialog box properties   
#define IDH_USERINFO_FAX_NUMBER                                     1024
#define IDH_USERINFO_ADDRESS                                        1049
#define IDH_USERINFO_COMPANY                                        1050
#define IDH_USERINFO_DEPARTMENT                                     1052
#define IDH_USERINFO_HOME_PHONE                                     1053
#define IDH_USERINFO_EMAIL_ADDRESS                                  1054
#define IDH_USERINFO_FULL_NAME                                      1055
#define IDH_USERINFO_OFFICE_LOCATION                                1056
#define IDH_USERINFO_WORK_PHONE                                     1057
#define IDH_USERINFO_TITLE                                          1058
#define IDH_USERINFO_BILLING_CODE                                   1059
#define IDH_USERINFO_RETURN_FAX_GRP                                 1071
// Fax Default - Fax Options (formally faxui.hlp)   
#define IDH_FAXDEFAULT_IMAGE_QUALITY                                2025
#define IDH_FAXDEFAULT_LANDSCAPE                                    2026
#define IDH_FAXDEFAULT_PAPER_SIZE                                   2037
#define IDH_FAXDEFAULT_PORTRAIT                                     2038
#define IDH_FAXDEFAULT_ORIENTATION                                  2062
#define IDH_FAXDEFAULT_DEFAULT_PRINT_SETUP_GRP                      2070

// Fax properties - Cover Page tab  
#define IDH_COVERPAGE_PERSONAL_LIST                                 501
#define IDH_COVERPAGE_ADD                                           502
#define IDH_COVERPAGE_NEW                                           503
#define IDH_COVERPAGE_OPEN                                          504
#define IDH_COVERPAGE_REMOVE                                        505
#define IDH_COVERPAGE_SERVER_LIST                                   511

// Fax details dialog box   
#define IDH_FAXDETAILS_DETAILS_LIST                                 1110
#define IDH_FAXDETAILS_CLOSE                                        1111

// Fax monitor dialog box   
#define IDH_FAXMONITOR_END_CALL                                     1112
#define IDH_FAXMONITOR_DETAILS                                      1113
#define IDH_FAXMONITOR_STATUS                                       1114
#define IDH_FAXMONITOR_ANSWER_NEXT_CALL                             1115
#define IDH_FAXMONITOR_ICON                                         1116

// Fax mail transport property sheet
#define IDH_FAXMAILTRANSPORT_FAX_PRINTERS                           1120
#define IDH_FAXMAILTRANSPORT_INCLUDE_COVER_PAGE                     1121
#define IDH_FAXMAILTRANSPORT_COVER_PAGES                            1122
#define IDH_FAXMAILTRANSPORT_DEFAULT_MESSAGE_FONT_GRP               1123
#define IDH_FAXMAILTRANSPORT_FONT                                   1124
#define IDH_FAXMAILTRANSPORT_FONT_STYLE                             1125
#define IDH_FAXMAILTRANSPORT_SIZE                                   1126
#define IDH_FAXMAILTRANSPORT_SET_FONT                               1127

// Fax Message Attributes Dialog Box    
#define IDH_FMA_FAX_PRINTERS                                        1130
#define IDH_FMA_DIALING_LOCATION                                    1131
#define IDH_FMA_INCLUDE_COVER_PAGE                                  1132
#define IDH_FMA_COVER_PAGES                                         1133

#endif  // !_FAXHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxdebug.h ===
/*************************************************

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDebug.h

Abstract:

    This file defines the debugging enum/masks
    available to the FAX compoments.

Author:

    Mooly Beery (MoolyB) 22-06-2000

Environment:

    User Mode

**************************************************/

#ifndef __FAX_EDBUG_HEADER_FILE__
#define __FAX_EDBUG_HEADER_FILE__

typedef enum
{
    DEBUG_CONTEXT_T30_MAIN          = 0x00000001,
    DEBUG_CONTEXT_T30_CLASS1        = 0x00000002,
    DEBUG_CONTEXT_T30_CLASS2        = 0x00000004,
    DEBUG_CONTEXT_T30_COMM          = 0x00000008,
    DEBUG_CONTEXT_ADMIN_FAXCLIENT   = 0x00000010,
    DEBUG_CONTEXT_ADMIN_MMC         = 0x00000020,
    DEBUG_CONTEXT_ADMIN_FAXRES      = 0x00000040,
    DEBUG_CONTEXT_ADMIN_T30EXT      = 0x00000080,
    DEBUG_CONTEXT_ADMIN_ROUTINGEXT  = 0x00000100,
    DEBUG_CONTEXT_CLIENT_CONSOLE    = 0x00000200,
    DEBUG_CONTEXT_EXCHANGE_EXT      = 0x00000400,
    DEBUG_CONTEXT_EXCHANGE_XPORT    = 0x00000800,
    DEBUG_CONTEXT_FAXCOVER_SRC      = 0x00001000,
    DEBUG_CONTEXT_FAXCOVER_RENDERER = 0x00002000,
    DEBUG_CONTEXT_SERVICE_RPC       = 0x00004000,
    DEBUG_CONTEXT_SERVICE_EFSPUTIL  = 0x00008000,
    DEBUG_CONTEXT_SERVICE_REGISTRY  = 0x00010000,
    DEBUG_CONTEXT_SERVICE_CLIENT    = 0x00020000,
    DEBUG_CONTEXT_SERVICE_FAXEVENT  = 0x00040000,
    DEBUG_CONTEXT_SERVICE_FAXROUTE  = 0x00080000,
    DEBUG_CONTEXT_SERVICE_SERVER    = 0x00100000,
    DEBUG_CONTEXT_SETUP_UTIL        = 0x00200000,
    DEBUG_CONTEXT_SETUP_CLIENT      = 0x00400000,
    DEBUG_CONTEXT_SETUP_SERVER      = 0x00800000,
    DEBUG_CONTEXT_TIFF_SRC          = 0x01000000,
    DEBUG_CONTEXT_UTIL              = 0x02000000,
    DEBUG_CONTEXT_DEBUGEX           = 0x04000000,

    DEBUG_CONTEXT_ALL               = 0xFFFFFFFF

} DEBUG_MESSAGE_CONTEXT;

typedef enum
{
    DBG_PRNT_THREAD_ID      = 0x80000000,   // Print thread ID in debug stream
    DBG_PRNT_TIME_STAMP     = 0x40000000,   // Print Date/Time in debug stream
    DBG_PRNT_MSG_TYPE       = 0x20000000,   // Print [MSG],[WRN],[ERR] in debug stream
    DBG_PRNT_FILE_LINE      = 0x10000000,   // Print Filename & line number in debug stream
    DBG_PRNT_TO_FILE        = 0x08000000,   // Output debug stream to a file (you have to call OpenLogFile with a filename
    DBG_PRNT_TO_STD         = 0x04000000,   // Use std debug output
    DBG_PRNT_TICK_COUNT     = 0x02000000,   // Print Tick count
    DBG_PRNT_MOD_NAME       = 0x01000000,   // Print the module name

    DBG_PRNT_ALL            = 0xFFFFFFFF,
    DBG_PRNT_ALL_TO_FILE    = DBG_PRNT_ALL & ~DBG_PRNT_TO_STD,
    DBG_PRNT_ALL_TO_STD     = DBG_PRNT_ALL & ~DBG_PRNT_TO_FILE,

} DbgMsgFormat;


#endif // __FAX_EDBUG_HEADER_FILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxlogres.h ===
#define IDS_JOB_ID                  1000
#define IDS_STATUS                  1002
#define IDS_ERROR_DESC              1003
#define IDS_ERROR_CODE              1004
#define IDS_DEVICE                  1005
#define IDS_FILE_NAME               1006
#define IDS_FILE_SIZE               1007
#define IDS_DIALED_NUMBER           1008
#define IDS_CSID                    1009
#define IDS_TSID                    1010
#define IDS_CALLER_ID               1011
#define IDS_ROUTING_INFO            1012
#define IDS_PAGES                   1013
#define IDS_SUBMITED                1014
#define IDS_START_TIME              1015
#define IDS_COVER_PAGE              1016
#define IDS_SENDER_NAME             1017
#define IDS_RECIPIENT_NAME          1018
#define IDS_RECIPIENT_FAX_NUMBER    1019
#define IDS_RETRIES                 1020
#define IDS_BILLING_CODE            1021
#define IDS_PARENT_JOB_ID           1022
#define IDS_END_TIME                1023
#define IDS_SCHEDULED               1024
#define IDS_DOCUMENT                1025
#define IDS_SUBJECT                 1026
#define IDS_NOTE                    1027
#define IDS_USER_NAME               1028
#define IDS_SENDER_FAX_NUMBER       1029
#define IDS_SENDER_COMPANY          1030
#define IDS_SENDER_STREET           1031
#define IDS_SENDER_CITY             1032
#define IDS_SENDER_ZIP              1033
#define IDS_SENDER_COUNTRY          1034
#define IDS_SENDER_TITLE            1035
#define IDS_SENDER_DEPARTMENT       1036
#define IDS_SENDER_OFFICE           1037
#define IDS_SENDER_H_PHONE          1038
#define IDS_SENDER_O_PHONE          1039
#define IDS_SENDER_E_MAIL           1041
#define IDS_RECIPIENT_COMPANY       1042
#define IDS_RECIPIENT_STREET        1043
#define IDS_RECIPIENT_CITY          1044
#define IDS_RECIPIENT_ZIP           1045
#define IDS_RECIPIENT_COUNTRY       1046
#define IDS_RECIPIENT_TITLE         1047
#define IDS_RECIPIENT_DEPARTMENT    1048
#define IDS_RECIPIENT_OFFICE        1049
#define IDS_RECIPIENT_H_PHONE       1050
#define IDS_RECIPIENT_O_PHONE       1051
#define IDS_RECIPIENT_E_MAIL        1053
#define IDS_TOTAL_PAGES             1054
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxroute.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    faxroute.h

Abstract:

    This file contains the prototypes, etc for the
    FAX routing extension API.


--*/

#include <commctrl.h>

#ifndef _FAXROUTE_
#define _FAXROUTE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// microsoft routing guids
//

#define MS_FAXROUTE_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")
#define MS_FAXROUTE_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

//
// callback routines
//

typedef LONG (WINAPI *PFAXROUTEADDFILE)(DWORD JobId, LPCWSTR FileName, GUID *Guid);
typedef LONG (WINAPI *PFAXROUTEDELETEFILE)(DWORD JobId, LPCWSTR FileName);
typedef BOOL (WINAPI *PFAXROUTEGETFILE)(DWORD JobId, DWORD Index, LPWSTR FileNameBuffer, LPDWORD RequiredSize);
typedef BOOL (WINAPI *PFAXROUTEENUMFILE)(DWORD JobId, GUID *GuidOwner, GUID *GuidCaller, LPCWSTR FileName, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEENUMFILES)(DWORD JobId, GUID *Guid,PFAXROUTEENUMFILE FileEnumerator, PVOID Context);
typedef BOOL (WINAPI *PFAXROUTEMODIFYROUTINGDATA)(DWORD JobId, LPCWSTR RoutingGuid, LPBYTE RoutingData, DWORD RoutingDataSize );


typedef struct _FAX_ROUTE_CALLBACKROUTINES {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
} FAX_ROUTE_CALLBACKROUTINES, *PFAX_ROUTE_CALLBACKROUTINES;


//
// routing data structure
//

typedef struct _FAX_ROUTE {
    DWORD           SizeOfStruct;       // size of the struct set by the fax service
    DWORD           JobId;              // Fax job identifier
    DWORDLONG       ElapsedTime;        // Elapsed time for whole fax job in Coordinated Universal Time (UTC)
    DWORDLONG       ReceiveTime;        // Starting time for fax job in Coordinated Universal Time (UTC)
    DWORD           PageCount;          // Number of pages received
    LPCWSTR         Csid;               // Called station identifier
    LPCWSTR         Tsid;               // Transmitting station identifier
    LPCWSTR         CallerId;           // Caller id
    LPCWSTR         RoutingInfo;        // Routing info such as DID, T.30-subaddress, etc.
    LPCWSTR         ReceiverName;       // Receiver's name
    LPCWSTR         ReceiverNumber;     // Receiver's fax number
    LPCWSTR         DeviceName;         // Device name for the line that received the fax
    DWORD           DeviceId;           // Permenant line identifier for the receiving device
    LPBYTE          RoutingInfoData;    // Routing infor data to override configured info
    DWORD           RoutingInfoDataSize;// Size of routing info data
} FAX_ROUTE, *PFAX_ROUTE;

enum FAXROUTE_ENABLE {
    QUERY_STATUS = -1,
    STATUS_DISABLE = 0,
    STATUS_ENABLE = 1
};


//
// prototypes
//

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    );

BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LONG Enabled
    );

BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD DeviceId,
    IN  BOOL  NewDevice
    );

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  LPBYTE RoutingInfo,
    OUT LPDWORD RoutingInfoSize
    );

BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR RoutingGuid,
    IN  DWORD DeviceId,
    IN  const BYTE *RoutingInfo,
    IN  DWORD RoutingInfoSize
    );


typedef BOOL (WINAPI *PFAXROUTEINITIALIZE)               (HANDLE,PFAX_ROUTE_CALLBACKROUTINES);
typedef BOOL (WINAPI *PFAXROUTEMETHOD)                   (const FAX_ROUTE*,PVOID*,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTEDEVICEENABLE)             (LPCWSTR,DWORD,LONG);
typedef BOOL (WINAPI *PFAXROUTEDEVICECHANGENOTIFICATION) (DWORD,BOOL);
typedef BOOL (WINAPI *PFAXROUTEGETROUTINGINFO)           (LPCWSTR,DWORD,LPBYTE,LPDWORD);
typedef BOOL (WINAPI *PFAXROUTESETROUTINGINFO)           (LPCWSTR,DWORD,const BYTE*,DWORD);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxmapi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    This file contains the prototypes, etc for the
    FAX mapi API.

Author:

    Wesley Witt (wesw) 7-Mar-1997

Environment:

    User Mode

--*/

#ifndef _FAXMAPI_
#define _FAXMAPI_

#ifdef __cplusplus
extern "C" {
#endif


typedef BOOL
(WINAPI *PFAXLOG)(
    IN DWORD Category,
    IN DWORD Level,
    IN DWORD StringCount,
    IN DWORD FormatId,
    IN ...
    );

typedef BOOL
(WINAPI *PSERVICEMESSAGEBOX)(
    IN LPCWSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    );


VOID
FXSMAPIFree(
    VOID
    );



BOOL WINAPI
FaxMapiInitialize(
    IN PSERVICEMESSAGEBOX pServiceMessageBox
    );

LPCWSTR WINAPI
GetProfileName(
    IN LPVOID ProfileInfo
    );

LPVOID WINAPI
AddNewMapiProfile(
    LPCWSTR ProfileName,
    BOOL UseMail,
    BOOL ShowPopUp
    );

BOOL WINAPI
StoreMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         MsgSenderNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    );

BOOL WINAPI
MailMapiMessage(
    LPVOID          ProfileInfo,
    LPCWSTR         RecipientNameW,
    LPCWSTR         MsgSubjectW,
    LPCWSTR         MsgBodyW,
    LPCWSTR         MsgAttachmentFileNameW,
    LPCWSTR         MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    );

LONG WINAPI
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    );



typedef BOOL (WINAPI *PFAXMAPIINITIALIZE)         (VOID);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxname.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxName.h                                              //
//                                                                         //
//  DESCRIPTION   : The central place for FaxName strings                  //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      May  4 2000 yossg  created                                         //
//                                                                         //
//  Copyright (C) 2000 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

//
// This file should be localized
//

#ifndef _FAX_NAME_H_
#define _FAX_NAME_H_

#define FAX_FULL_NAME_MICROSOFT       "Microsoft "
#define FAX_SPACE                     " "

#define FAX_NAME                      "Fax"
#define FAX_FULL_NAME                 FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_NAME
#define FAX_SERVER_NAME               FAX_NAME FAX_SPACE "Service"
#define FAX_SERVER_FULL_NAME          FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_SERVER_NAME
#define FAX_SERVER_NAME_SERVER        FAX_NAME FAX_SPACE "Server"
#define FAX_CLIENT_CONSOLE_NAME       FAX_NAME FAX_SPACE "Console"
#define FAX_CLIENT_CONSOLE_FULL_NAME  FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_CLIENT_CONSOLE_NAME

#define FAX_SERVER_MANAGMENT_NAME     FAX_NAME FAX_SPACE "Manager"
#define FAX_SERVER_MANAGMENT_FULL_NAME   FAX_FULL_NAME_MICROSOFT FAX_SPACE FAX_SERVER_MANAGMENT_NAME

#define FAX_PERSONAL_COVER_PAGE_SUFFIX  "\\Fax\\Personal Cover Pages\\"
#endif  // !_FAX_NAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxwiz.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxwiz.h

Abstract:

    This file defines the fax setup wizard api.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;

//
// install modes
//

#define INSTALL_NEW                 0x00000001
#define INSTALL_UPGRADE             0x00000002
#define INSTALL_DRIVERS             0x00000004
#define INSTALL_REMOVE              0x00000008
#define INSTALL_UNATTENDED          0x00000010


BOOL WINAPI
FaxWizInit(
    VOID
    );

DWORD
WINAPI
FaxWizGetError(
    VOID
    );

VOID
WINAPI
FaxWizSetInstallMode(
    DWORD RequestedInstallMode,
    DWORD RequestedInstallType,
    LPWSTR AnswerFile
    );

BOOL WINAPI
FaxWizPointPrint(
    LPTSTR DirectoryName,
    LPTSTR PrinterName
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetServerPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetWorkstationPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetClientPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizGetPointPrintPages(
    LPDWORD PageCount
    );

LPHPROPSHEETPAGE WINAPI
FaxWizRemoteAdminPages(
    LPDWORD PageCount
    );

PFNPROPSHEETCALLBACK WINAPI
FaxWizGetPropertySheetCallback(
    VOID
    );

//
// Function pointer types used when the client doesn't
// statically link to faxwiz.dll.
//

typedef BOOL (WINAPI *LPFAXWIZINIT)(VOID);
typedef DWORD (WINAPI *LPFAXWIZGETERROR)(VOID);
typedef BOOL (WINAPI*LPFAXWIZPOINTPRINT)(LPTSTR, LPTSTR);
typedef LPHPROPSHEETPAGE (WINAPI *LPFAXWIZGETPOINTPRINTPAGES)(LPDWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxres.h ===
#ifndef FXSRES_H
#define FXSRES_H
#include <windows.h>
#include <FXSAPIP.H>

#ifdef __cplusplus
extern "C"{
#endif

HINSTANCE WINAPI GetResInstance(void);
UINT WINAPI GetRpcErrorStringId(DWORD ec);

#define FAXRES_ERROR_CODE_TO_STRING_FNAME   "GetRpcErrorStringId"

typedef UINT (WINAPI *FUNC_GETRPCERRORSTRINGID)(DWORD ec);


#ifdef __cplusplus
}
#endif

#define FAXUI_ERROR_DEVICE_LIMIT        14000L
#define FAXUI_ERROR_INVALID_RING_COUNT  14001L
#define FAXUI_ERROR_SELECT_PRINTER      14002L
#define FAXUI_ERROR_NAME_IS_TOO_LONG    14003L
#define FAXUI_ERROR_INVALID_RETRIES     14004L
#define FAXUI_ERROR_INVALID_RETRY_DELAY 14005L
#define FAXUI_ERROR_INVALID_DIRTY_DAYS  14006L
#define FAXUI_ERROR_INVALID_CSID        14007L
#define FAXUI_ERROR_INVALID_TSID        14008L


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxperf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxperf.h

Abstract:

    This file defines the fax perfmon dll interface.

Author:

    Wesley Witt (wesw) 22-Aug-1996

Environment:

    User Mode

--*/


#ifndef _FAXPERF_
#define _FAXPERF_

#ifdef __cplusplus
extern "C" {
#endif


#define FAXPERF_SHARED_MEMORY       TEXT("Global\\FaxPerfCounters") // We use the global kernel object name space.
                                                                    // See Terminal Services and kernel objects name space


typedef struct _FAX_PERF_COUNTERS {
    DWORD InboundBytes;
    DWORD InboundFaxes;
    DWORD InboundPages;
    DWORD InboundMinutes;
    DWORD InboundFailedReceive;
    DWORD OutboundBytes;
    DWORD OutboundFaxes;
    DWORD OutboundPages;
    DWORD OutboundMinutes;
    DWORD OutboundFailedConnections;
    DWORD OutboundFailedXmit;
    DWORD TotalBytes;
    DWORD TotalFaxes;
    DWORD TotalPages;
    DWORD TotalMinutes;
} FAX_PERF_COUNTERS, *PFAX_PERF_COUNTERS;



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This file contains all fax registry strings and general constants.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/


#ifndef _FAXREG_H_
#define _FAXREG_H_

#define FAX_PATH_SEPARATOR_STR  TEXT("\\")
#define FAX_PATH_SEPARATOR_CHR  TEXT('\\')
#define CP_SHORTCUT_EXT     _T(".lnk")

/*****************************************************************************
**                                                                          **
**               Global project definitions and constants                   **
**                                                                          **
*****************************************************************************/

#define FAX_API_MODULE_NAME                 TEXT("FXSAPI.DLL")                          // Used by the print monitor and setup
#define FAX_SERVICE_IMAGE_NAME              TEXT("%systemroot%\\system32\\FXSSVC.EXE")  // Used by the service
#define FAX_WZRD_MODULE_NAME                TEXT("FXSWZRD.DLL")                         // Used by setup
#define FAX_TIFF_MODULE_NAME                TEXT("FXSTIFF.DLL")                         // Used by setup
#define FAX_DRV_MODULE_NAME                 TEXT("FXSDRV.DLL")                          // Used by setup
#define FAX_DRV_WIN9X_32_MODULE_NAME        TEXT("FXSDRV32.DLL")
#define FAX_DRV_WIN9X_16_MODULE_NAME        TEXT("FXSDRV16.DRV")
#define FAX_DRV_UNIDRV_MODULE_NAME          TEXT("UNIDRV.DLL")
#define FAX_DRV_UNIDRV_HELP                 TEXT("UNIDRV.HLP")
#define FAX_DRV_DEPEND_FILE                 TEXT("FXSWZRD.DLL")
#define FAX_TIFF_FILE                       TEXT("FXSTIFF.DLL")
#define FAX_RES_FILE                        TEXT("FXSRES.DLL")
#define FAX_DRV_ICONLIB                     TEXT("ICONLIB.DLL")
#define FAX_UI_MODULE_NAME                  TEXT("FXSUI.DLL")                           // Used by setup
#define FAX_MONITOR_FILE                    TEXT("FXSMON.DLL")                          // Used by setup
#define FAX_EVENT_MSG_FILE                  TEXT("%systemroot%\\system32\\fxsevent.dll")// Used by service\regsitry\faxreg.c: CreateFaxEventSource()
#define FAX_MAIL_TRANSPORT_MODULE_NAME      TEXT("FXSXP32.DLL")                         // Used by exchange\xport\faxxp.h
#define FAX_POINT_PRINT_SETUP_DLL           TEXT("FXSOCM.DLL")                          // Used by print\faxprint\faxui\prnevent.c
#define FAX_SEND_IMAGE_NAME                 TEXT("fxssend.exe")                         // Used by the client console
#define FAX_COVER_IMAGE_NAME                TEXT("fxscover.exe")                        // Used by MMC and ClientConsole
#define FAX_COVER_PAGE_EXT_LETTERS          TEXT("cov")                                 // Used by MMC, CoverPage editor, and ClientConsole
#define FAX_COVER_PAGE_FILENAME_EXT         TEXT(".") FAX_COVER_PAGE_EXT_LETTERS        // Used by many
#define FAX_COVER_PAGE_MASK                 TEXT("*") FAX_COVER_PAGE_FILENAME_EXT       // Used by MMC, Outlook ext, and ClientConsole
#define FAX_LNK_FILE_EXT                    TEXT("lnk")                                 // Used by MAPI transport
#define FAX_LNK_FILE_DOT_EXT                TEXT(".") FAX_LNK_FILE_EXT                  // Used by MAPI transport
#define FAX_LNK_FILE_MASK                   TEXT("*") FAX_LNK_FILE_DOT_EXT              // Used by MAPI transport and Outlook ext.
#define FAX_TIF_FILE_EXT                    TEXT("tif")                                 // Used by the service
#define FAX_TIF_FILE_DOT_EXT                TEXT(".") FAX_TIF_FILE_EXT                  // Used by the service
#define FAX_TIF_FILE_MASK                   TEXT("*") FAX_TIF_FILE_DOT_EXT              // Used by the service
#define FAX_TIFF_FILE_EXT                   TEXT("tiff")                                // Used by print monitor
#define FAX_TIFF_FILE_DOT_EXT               TEXT(".") FAX_TIFF_FILE_EXT                 // Used by print monitor
#define FAX_TIFF_FILE_MASK                  TEXT("*") FAX_TIFF_FILE_DOT_EXT             // Used by print monitor
#define FAX_HTML_HELP_EXT                   TEXT("chm")                                 // Used by the client console
#define FAX_ADMIN_CONSOLE_IMAGE_NAME        TEXT("fxsadmin.msc")                        // Used by configuration wizard and ClientConsole
#define FAX_SERVICE_NAME                    TEXT("Fax")                                 // Used by the service
#define FAX_SERVICE_DISPLAY_NAME            TEXT("Microsoft Fax Server Service")        // Used by the service
#define FAX_SERVICE_DISPLAY_NAME_W          L"Microsoft Fax Server Service"             // Used by the service
#define FAX_PRINTER_NAME                    TEXT("Fax")                                 // Used everywhere
#define FAX_MONITOR_PORT_NAME               TEXT("SHRFAX:")                             // Used by print monitor and setup
#define FAX_PORT_NAME                       FAX_MONITOR_PORT_NAME                       // Used by print monitor and setup
#define FAX_DRIVER_NAME                     TEXT("Microsoft Shared Fax Driver")         // Used by print monitor and setup
#define FAX_DRIVER_NAME_A                   "Microsoft Shared Fax Driver"               // Used by print driver
#define FAX_WIN2K_DRIVER_NAME               TEXT("Windows NT Fax Driver")       // Legacy - for routing extension snap-in
#define FAX_MONITOR_NAME                    TEXT("Microsoft Shared Fax Monitor")        // Used by print monitor and setup
#define FAX_ADDRESS_TYPE_A                  "FAX"                                       // Used by MAPI transport
#define TRANSPORT_DISPLAY_NAME_STRING       "Microsoft Fax Mail Transport"              // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W2K        "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_W9X        "AWFAX"                                     // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME            "MSFAX XP"                                  // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_NAME_T          TEXT(FAX_MESSAGE_SERVICE_NAME)
#define FAX_MESSAGE_PROVIDER_NAME           "MSFAX XPP"                                 // Used by MAPI transport
#define FAX_MESSAGE_PROVIDER_NAME_T         TEXT(FAX_MESSAGE_PROVIDER_NAME)
#define FAX_MESSAGE_SERVICE_NAME_SBS50      "SHAREDFAX XP"
#define FAX_MESSAGE_SERVICE_NAME_SBS50_T    TEXT(FAX_MESSAGE_SERVICE_NAME_SBS50)
#define FAX_MESSAGE_PROVIDER_NAME_SBS50     "SHAREDFAX XPP"
#define FAX_MESSAGE_PROVIDER_NAME_SBS50_T   TEXT(FAX_MESSAGE_PROVIDER_NAME_SBS50)


#define FAX_ROUTE_MODULE_NAME               TEXT("FXSROUTE")
#define FAX_T30_MODULE_NAME                 TEXT("FXST30")

#define FAX_MESSAGE_SERVICE_PROVIDER_NAME   "Microsoft Fax XPP"                         // Used by MAPI transport
#define FAX_MESSAGE_SERVICE_PROVIDER_NAME_T TEXT(FAX_MESSAGE_SERVICE_PROVIDER_NAME)     // Used by MAPI transport
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME    "FXSXP.DLL"                                 // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_MESSAGE_TRANSPORT_IMAGE_NAME_T  TEXT(FAX_MESSAGE_TRANSPORT_IMAGE_NAME)      // Used by setup - Translated to fxsXP32.DLL by MAPI
#define FAX_RPC_ENDPOINTW                   L"SHAREDFAX"                                // Used by RPC - Same EndPoint as for BOS
#define FAX_RPC_ENDPOINT                    TEXT("SHAREDFAX")                           // Used by RPC - Same EndPoint as for BOS
#define FAX_CLIENT_CONSOLE_IMAGE_NAME       TEXT("FXSCLNT.exe")                         // Used by MMC
#define FAX_CONTEXT_HELP_FILE               TEXT("FXSCLNT.hlp")                         // Used by ClientConsole
#define FAX_CLIENT_HELP_FILE                TEXT("FXSCLNT.chm")                         // Used by ClientConsole
#define FAX_COVERPAGE_HELP_FILE             TEXT("FXSCOVER.chm")                        // Used by the cover page editor
#define FAX_ADMIN_HELP_FILE                 TEXT("FXSADMIN.chm")                        // Used by MMC
#define FAX_CLIENTS_SHARE_NAME              TEXT("FxsClients$")                         // Used by FxsUI.dll
#define FAX_COVER_PAGES_SHARE_NAME          TEXT("FxsSrvCp$")                           // Used by send wizard
#define ADAPTIVE_ANSWER_SECTION             TEXT("Adaptive Answer Modems")              // Used by the service
#define REGKEY_CLIENT_EXT                   TEXT("Software\\Microsoft\\Exchange\\Client\\Extensions")   // Used by setup
#define EXCHANGE_CLIENT_EXT_FILE            "%windir%\\system32\\fxsext32.dll"          // Used by setup
#define FAX_FILENAME_FAXPERF_INI            TEXT("FXSPERF.INI")                         // Used by setup
#define USE_SERVER_DEVICE                   MAXDWORD                                    // Used by the service - this line id value is reserved for internal use.
#define SHARED_FAX_SERVICE_SETUP_LOG_FILE   TEXT("XPFaxServiceSetupLog.txt")
#define SERVICE_ALWAYS_RUNS                 TEXT("/AlwaysRun")                          // Command line parameter to service to disable idle-activity suicide
#define SERVICE_DELAY_SUICIDE               TEXT("/DelaySuicide")                       // Command line parameter to service to delay idle-activity suicide
#define FAX_SERVER_EVENT_NAME               TEXT("Global\\FaxSvcRPCStarted-1ed23866-f90b-4ec5-b77e-36e8709422b6")   // Name of event that notifies service RPC is on.
                                                                                                                    // This event should be "Global" (see terminal services and named kernel objects)

#define FAX_MODEM_PROVIDER_NAME             TEXT("Windows Telephony Service Provider for Universal Modem Driver")

//
// Install types
//
#define FAX_INSTALL_NETWORK_CLIENT          0x00000001                                  // Used by the coverpage editor
#define FAX_INSTALL_SERVER                  0x00000002                                  // Used by the coverpage editor
#define FAX_INSTALL_WORKSTATION             0x00000004                                  // Used by the coverpage editor
#define FAX_INSTALL_REMOTE_ADMIN            0x00000008                                  // Used by the coverpage editor
//
// Product types
//
#define PRODUCT_TYPE_WINNT                  1                                           // Used by the utility library
#define PRODUCT_TYPE_SERVER                 2                                           // Used by the utility library
//
// Shared memory region name for faxui & faxxp32
//
#define FAX_ENVVAR_PRINT_FILE               TEXT("MS_FAX_PRINTFILE")
#define FAXXP_ATTACH_MUTEX_NAME             TEXT("MS_FAXXP_ATTACHMENT_MUTEX")
#define FAXXP_MEM_NAME                      TEXT("MS_FAXXP_ATTACHMENT_REGION")
#define FAXXP_MEM_MUTEX_NAME                TEXT("MS_FAXXP_ATTACHMENTREGION_MUTEX")
#define FAXXP_ATTACH_END_DOC_EVENT          TEXT("_END_DOC_EVENT")                      // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_ABORT_EVENT            TEXT("_ABORT_EVENT")                        // Update FAXXP_ATTACH_EVENT_NAME_LEN if change
#define FAXXP_ATTACH_EVENT_NAME_LEN         (MAX_PATH+20)
//
// Fax dirs. These are hardcoded relative paths. We call into the shell to get the base path.
//
#define FAX_SHARE_DIR                       TEXT("Microsoft\\Windows NT\\MSFax")
#define FAX_RECEIVE_DIR                     FAX_SHARE_DIR TEXT("\\FaxReceive")          // Used by MS routing extension
#define FAX_QUEUE_DIR                       FAX_SHARE_DIR TEXT("\\Queue")               // Used by service

#define FAX_PREVIEW_TMP_DIR                 TEXT("FxsTmp")    // Created under %windir%\system32 with full access to everyone.
                                                              // Used for mapping of preview file in W2K and NT4 if
                                                              // Access to %windir%\system32 is denied for guest users.


/*****************************************************************************
**                                                                          **
**                     Registry keys, values, paths etc.                    **
**                                                                          **
*****************************************************************************/

//
// Fax Server Registry Root (relative to LOCAL_MACHINE or CURRENT_USER)
//
#define REGKEY_FAXSERVER_A              "Software\\Microsoft\\Fax"
#define REGKEY_FAXSERVER                TEXT(REGKEY_FAXSERVER_A)

#define REGKEY_CLIENT                   TEXT("Microsoft\\Fax")
#define CLIENT_ARCHIVE_KEY              TEXT("Archive")
#define CLIENT_ARCHIVE_MSGS_PER_CALL    TEXT("MessagesPerCall")
#define CLIENT_INBOX_VIEW               TEXT("InboxView")
#define CLIENT_SENT_ITEMS_VIEW          TEXT("SentItemsView")
#define CLIENT_INCOMING_VIEW            TEXT("IncomingView")
#define CLIENT_OUTBOX_VIEW              TEXT("OutboxView")
#define CLIENT_COVER_PAGES_VIEW         TEXT("CoverPagesView")
#define CLIENT_VIEW_COLUMNS             TEXT("Columns")
#define CLIENT_VIEW_COL_WIDTH           TEXT("Width")
#define CLIENT_VIEW_COL_SHOW            TEXT("Show")
#define CLIENT_VIEW_COL_ORDER           TEXT("Order")
#define CLIENT_VIEW_SORT_ASCENDING      TEXT("SortAscending")
#define CLIENT_VIEW_SORT_COLUMN         TEXT("SortColumn")
#define CLIENT_MAIN_FRAME               TEXT("MainFrame")
#define CLIENT_MAXIMIZED                TEXT("Maximized")
#define CLIENT_NORMAL_POS_TOP           TEXT("NormalPosTop")
#define CLIENT_NORMAL_POS_RIGHT         TEXT("NormalPosRight")
#define CLIENT_NORMAL_POS_BOTTOM        TEXT("NormalPosBottom")
#define CLIENT_NORMAL_POS_LEFT          TEXT("NormalPosLeft")
#define CLIENT_SPLITTER_POS             TEXT("SplitterPos")
#define CLIENT_CONFIRM_SEC              TEXT("Confirm")
#define CLIENT_CONFIRM_ITEM_DEL         TEXT("ItemDeletion")
#define CLIENT_CONFIRM_PRN_REMOVE       TEXT("FaxPrinterRemoval")
//
// Registry values stored under HKEY_CURRENT_USER
//
//
// User information is stored under Fax\UserInfo subkey
//
#define   REGVAL_FULLNAME                       TEXT("FullName")
#define   REGVAL_FAX_NUMBER                     TEXT("FaxNumber")
#define   REGVAL_MAILBOX                        TEXT("Mailbox")
#define   REGVAL_COMPANY                        TEXT("Company")
#define   REGVAL_TITLE                          TEXT("Title")
#define   REGVAL_ADDRESS                        TEXT("Address")
#define   REGVAL_CITY                           TEXT("City")
#define   REGVAL_STATE                          TEXT("State")
#define   REGVAL_ZIP                            TEXT("ZIP")
#define   REGVAL_COUNTRY                        TEXT("Country")
#define   REGVAL_DEPT                           TEXT("Department")
#define   REGVAL_OFFICE                         TEXT("Office")
#define   REGVAL_HOME_PHONE                     TEXT("HomePhone")
#define   REGVAL_OFFICE_PHONE                   TEXT("OfficePhone")
#define   REGVAL_BILLING_CODE                   TEXT("BillingCode")

#define   REGVAL_SEND_COVERPG                   TEXT("SendCoverPage")
#define   REGVAL_COVERPG                        TEXT("CoverPageFile")
#define   REGVAL_FAX_PRINTER                    TEXT("LastSelectedPrinter")
#define   REGVAL_LAST_COUNTRYID                 TEXT("LastCountryID")
#define   REGVAL_LAST_RECNAME                   TEXT("LastRecipientName")
#define   REGVAL_LAST_RECAREACODE               TEXT("LastRecipientAreaCode")
#define   REGVAL_LAST_RECNUMBER                 TEXT("LastRecipientNumber")
#define   REGVAL_USE_DIALING_RULES              TEXT("LastUseDialingRules")
#define   REGVAL_USE_OUTBOUND_ROUTING           TEXT("LastUseOutboundRouting")
#define   REGVAL_STRESS_INDEX                   TEXT("LastStressPrinterIndex")

#define   REGVAL_RECEIPT_NO_RECEIPT             TEXT("ReceiptNoRecipt")
#define   REGVAL_RECEIPT_GRP_PARENT             TEXT("ReceiptGroupParent")
#define   REGVAL_RECEIPT_MSGBOX                 TEXT("ReceiptMessageBox")
#define   REGVAL_RECEIPT_EMAIL                  TEXT("ReceiptEMail")
#define   REGVAL_RECEIPT_ADDRESS                TEXT("ReceiptAddress")
#define   REGVAL_RECEIPT_ATTACH_FAX             TEXT("ReceiptAttachFax")
//
// Status UI configuration values
//
#define   REGVAL_DEVICE_TO_MONITOR              TEXT("DeviceToMonitor") // device ID for monitoring
#define   REGVAL_MONITOR_ON_SEND                TEXT("MonitorOnSend")
#define   REGVAL_MONITOR_ON_RECEIVE             TEXT("MonitorOnReceive")
#define   REGVAL_NOTIFY_PROGRESS                TEXT("NotifyProgress")
#define   REGVAL_NOTIFY_IN_COMPLETE             TEXT("NotifyIncomingCompletion")
#define   REGVAL_NOTIFY_OUT_COMPLETE            TEXT("NotifyOutgoingCompletion")

#define   REGVAL_SOUND_ON_RING                  TEXT("SoundOnRing")
#define   REGVAL_SOUND_ON_RECEIVE               TEXT("SoundOnReceive")
#define   REGVAL_SOUND_ON_SENT                  TEXT("SoundOnSent")
#define   REGVAL_SOUND_ON_ERROR                 TEXT("SoundOnError")

#define   REGVAL_ALWAYS_ON_TOP                  TEXT("AlwaysOnTop")
#define   REGVAL_TASKBAR                        TEXT("OnTaskBar")
#define   REGVAL_VISUAL_NOTIFICATION            TEXT("VisualNotification")
#define   REGVAL_SOUND_NOTIFICATION             TEXT("SoundNotification")
#define   REGVAL_ANSWER_NEXTCALL                TEXT("AnswerNextCall")
#define   REGVAL_ENABLE_MANUAL_ANSWER           TEXT("EnableManualAnswer")

#define   REGVAL_BALLOON_RECEIVE                TEXT("ReceiveNotification")
#define   REGVAL_BALLOON_SENDERROR              TEXT("SendErrorNotification")
#define   REGVAL_BALLOON_RINGING                TEXT("RingingNotification")
#define   REGVAL_BALLOON_TIMEOUT                TEXT("BalloonTimeOut")

//
// Fax status monitor and fax notification bar icon contants:
//
#define FAXSTAT_WINCLASS                        TEXT("FaxMonWinClass{3FD224BA-8556-47fb-B260-3E451BAE2793}")    // Window class for fax notification bar messages
#define FAX_SYS_TRAY_DLL                        TEXT("fxsst.dll")   // Fax notification bar DLL (loaded by STObject.dll)
#define IS_FAX_MSG_PROC                         "IsFaxMessage"      // Fax message handler (used by GetProcAddress)
typedef BOOL (*PIS_FAX_MSG_PROC)(PMSG);                             // IsFaxMessage type
#define FAX_MONITOR_SHUTDOWN_PROC               "FaxMonitorShutdown"// Fax monitor shutdown (used by GetProcAddress)
typedef BOOL (*PFAX_MONITOR_SHUTDOWN_PROC)();                       // FaxMonitorShutdown type
#define WM_FAXSTAT_CONTROLPANEL                 (WM_USER + 201)     // Fax notification bar configuration has changed
#define WM_FAXSTAT_OPEN_MONITOR                 (WM_USER + 211)     // User explicitly asks for fax status monitor
#define WM_FAXSTAT_INBOX_VIEWED                 (WM_USER + 212)     // Message viewed or deleted in the fax client console's inbox folder
#define WM_FAXSTAT_OUTBOX_VIEWED                (WM_USER + 213)     // Message in error was restarted or deleted in the fax client console's outbox folder
#define WM_FAXSTAT_RECEIVE_NOW                  (WM_USER + 214)     // Start receiving now
#define WM_FAXSTAT_PRINTER_PROPERTY             (WM_USER + 215)     // Open Fax Printer Property Sheet. WPARAM is an initiall page number

//
// Setup information is stored under Fax\Setup subkey
//
#define REGKEY_FAX_SETUP                        REGKEY_FAXSERVER TEXT("\\Setup")
#define REGKEY_FAX_SETUP_SUBKEY                 TEXT("Setup")

#define   REGVAL_CP_EDITOR                      TEXT("CoverPageEditor")
#define   REGVAL_CP_LOCATION                    TEXT("CoverPageDir")
#define   REGVAL_FAX_PROFILE                    TEXT("FaxProfileName")
#define   REGVAL_FAXINSTALLED                   TEXT("Installed")
#define   REGVAL_DONT_UNATTEND_INSTALL          TEXT("DenyUnattendInstall")
#define   REGVAL_FAXINSTALL_TYPE                TEXT("InstallType")
#define   REGVAL_FAXINSTALLED_PLATFORMS         TEXT("InstalledPlatforms")
#define   REGVAL_CFGWZRD_USER_INFO              TEXT("CfgWzdrUserInfo")
#define   REGVAL_CPE_CONVERT                    TEXT("WereCpesConverted")
#define   REGVAL_CFGWZRD_DEVICE                 TEXT("CfgWzdrDevice")
#define   REGVAL_SERVER_CP_LOCATION             TEXT("ServerCoverPageDir")
#define   REGVAL_IMPORT_INFO                    TEXT("ImportInfoDisplayed")
#define   REGVAL_INSTALLED_COMPONENTS           TEXT("InstalledComponents")

#define   REGVAL_W2K_SENT_ITEMS                 TEXT("W2K_SentItems")
#define   REGVAL_W2K_INBOX                      TEXT("W2K_Inbox")

#define DEFAULT_COVERPAGE_EDITOR                FAX_COVER_IMAGE_NAME    // Used by print\faxprint\lib\registry.c
#define DEFAULT_COVERPAGE_DIR                   TEXT("%systemroot%\\Fax\\CoverPg")

#define REGKEY_INSTALLLOCATION                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")
#define REGVAL_SOURCEPATH                       TEXT("SourcePath")
#define REGVAL_DEFAULT_TSID                     TEXT("Fax")
#define REGVAL_DEFAULT_CSID                     TEXT("Fax")

//
// Per-user devmode information is stored under Fax\Devmode subkey
//
#define REGKEY_FAX_DEVMODE                      REGKEY_FAXSERVER TEXT("\\Devmode")
//
// Registry values stored under HKEY_LOCAL_MACHINE
//

//
// Server registry values
// stored under REGKEY_FAXSERVER
//
#define REGVAL_DBGLEVEL                         TEXT("DebugLevel")
#define REGVAL_DBGLEVEL_EX                      TEXT("DebugLevelEx")
#define REGVAL_DBGFORMAT_EX                     TEXT("DebugFormatEx")
#define REGVAL_DBGCONTEXT_EX                    TEXT("DebugContextEx")
#define REGVAL_DBG_SKU                          TEXT("DebugSKU")
#define FAX_SVC_EVENT                           TEXT("Microsoft Fax")
#define REGKEY_EVENTLOG                         TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\") FAX_SVC_EVENT

#define   REGVAL_EVENTMSGFILE                   TEXT("EventMessageFile")
#define   REGVAL_CATEGORYMSGFILE                TEXT("CategoryMessageFile")
#define   REGVAL_CATEGORYCOUNT                  TEXT("CategoryCount")
#define   REGVAL_TYPESSUPPORTED                 TEXT("TypesSupported")

#define REGKEY_SOFTWARE                         REGKEY_FAXSERVER

#define   REGVAL_RETRIES                        TEXT("Retries")
#define   REGVAL_RETRYDELAY                     TEXT("Retry Delay")
#define   REGVAL_MANUAL_ANSWER_DEVICE           TEXT("ManualAnswerDevice")
#define   REGVAL_DIRTYDAYS                      TEXT("Dirty Days")
#define   REGVAL_BRANDING                       TEXT("Branding")
#define   REGVAL_USE_DEVICE_TSID                TEXT("UseDeviceTsid")
#define   REGVAL_SERVERCP                       TEXT("ServerCoverPageOnly")
#define   REGVAL_STARTCHEAP                     TEXT("StartCheapTime")
#define   REGVAL_STOPCHEAP                      TEXT("StopCheapTime")
#define   REGVAL_QUEUE_STATE                    TEXT("QueueState")
#define   REGVAL_JOB_NUMBER                     TEXT("NextJobNumber")
#define   REGVAL_SCANNER_SUPPORT                TEXT("ScannerSupport")
#define   REGVAL_MISSING_DEVICE_LIFETIME        TEXT("MissingDeviceLifetime")
#define   REGVAL_MAX_LINE_CLOSE_TIME            TEXT("MaxLineCloseTime")
//
// 31 days * 24 hours * 60 minutes * 60 seconds * 1000000 microseconds * 10 (100 ns is one unit)
//
#define   DEFAULT_REGVAL_MISSING_DEVICE_LIFETIME 26784000000000

#define   DEFAULT_REGVAL_RETRIES                3
#define   DEFAULT_REGVAL_RETRYDELAY             10
#define   DEFAULT_REGVAL_DIRTYDAYS              30
#define   DEFAULT_REGVAL_BRANDING               1
#define   DEFAULT_REGVAL_USEDEVICETSID          1
#define   DEFAULT_REGVAL_SERVERCP               0
#define   DEFAULT_REGVAL_STARTCHEAP             MAKELONG(20,0)
#define   DEFAULT_REGVAL_STOPCHEAP              MAKELONG(7,0)
#define   DEFAULT_REGVAL_QUEUE_STATE            0
#define   DEFAULT_REGVAL_JOB_NUMBER             1

#define   REGKEY_DEVICE_PROVIDERS               TEXT("Device Providers")
#define     REGVAL_FRIENDLY_NAME                TEXT("FriendlyName")
#define     REGVAL_IMAGE_NAME                   TEXT("ImageName")
#define     REGVAL_PROVIDER_NAME                TEXT("ProviderName")
#define     REGVAL_PROVIDER_CAPABILITIES        TEXT("Capabilities")
#define     REGVAL_PROVIDER_GUID                TEXT("GUID")
#define     REGVAL_PROVIDER_API_VERSION         TEXT("APIVersion")
//
// The following value is an incremental prefix for device ids assigned to FSPs
//
#define     REGVAL_PROVIDER_DEVICE_ID_PREFIX    TEXT("DeviceIdPerfix")
//
// The following value is the base device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE   DWORD(0x20000)
//
// The following value is the base for our internal unique fax ids
//
#define     DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE        DWORD(0x10000)
//
// The following value is the increase step of device id assigned to FSPs
//
#define     DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_STEP   DWORD(0x10000)
//
// How device ids are allocated:
// -----------------------------
// Fax unique devices (allocated by the server), VFSP devices, and EVFSP devices all share
// the same device id space (32-bit = 4GB of ids).
//
// Notice: TAPI permanent line ids (used by FSPs / EFSPs) are not in this space.
//
// Range [1 ... DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE-1] : Reserved for VFSPs.
//     Since we cannot dictate the range of device ids the VFSPS use, we allocate a space for them
//     and leave segments allocation to a PM effort here.
//
// Range [DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE ... DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE-1] :
//     Used by the fax server for the unique device ids of TAPI devices discovered by the server.
//
// Range [DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE ... MAXDWORD] : Used for VEFSPs.
//     Luckily, we can tell VEFSPs the base of the ids they give their devices.
//     It is the server's responsibility to segment this range for each VEFSP.
//     The size of each segment is DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_STEP.
//
#define   REGKEY_RECEIPTS_CONFIG                TEXT("Receipts")    // Key of receipts configuration
#define     REGVAL_RECEIPTS_TYPE                TEXT("Type")        // Receipts supported
#define     REGVAL_RECEIPTS_SERVER              TEXT("Server")      // SMTP Server's name
#define     REGVAL_RECEIPTS_PORT                TEXT("Port")        // SMTP Server's port
#define     REGVAL_RECEIPTS_FROM                TEXT("From")        // SMTP sender address
#define     REGVAL_RECEIPTS_USER                TEXT("User")        // SMTP user name
#define     REGVAL_RECEIPTS_PASSWORD            TEXT("Password")    // SMTP password
#define     REGVAL_RECEIPTS_SMTP_AUTH_TYPE      TEXT("SMTPAuth")    // SMTP authentication type
#define     REGVAL_ISFOR_MSROUTE                TEXT("UseForMsRoute")  // TRUE if to use for MS route through e-mail method

#define     DEFAULT_REGVAL_SMTP_PORT            25                  // Default SMTP port number

#define   REGKEY_ARCHIVE_SENTITEMS_CONFIG       TEXT("SentItems")// Key of SentItems archive configuration
#define   REGKEY_ARCHIVE_INBOX_CONFIG           TEXT("Inbox")    // Key of Inbox archive configuration
#define     REGVAL_ARCHIVE_USE                  TEXT("Use")      // Archive?
#define     REGVAL_ARCHIVE_FOLDER               TEXT("Folder")   // Archive location
#define     REGVAL_ARCHIVE_SIZE_QUOTA_WARNING   TEXT("SizeQuotaWarn") // Warn on size excess?
#define     REGVAL_ARCHIVE_HIGH_WATERMARK       TEXT("HighWatermark") // Warning high watermark
#define     REGVAL_ARCHIVE_LOW_WATERMARK        TEXT("LowWatermark")  // Warning low watermark
#define     REGVAL_ARCHIVE_AGE_LIMIT            TEXT("AgeLimit") // Archive age limit

#define     DEFAULT_REGVAL_ARCHIVE_USE          0        // Don't use archive by default
#define     DEFAULT_REGVAL_ARCHIVE_FOLDER       TEXT("") // Default location of archive
#define     DEFAULT_REGVAL_SIZE_QUOTA_WARNING   1        // Warn on size by default
#define     DEFAULT_REGVAL_HIGH_WATERMARK       100      // High watermark default
#define     DEFAULT_REGVAL_LOW_WATERMARK        95       // Low watermark default
#define     DEFAULT_REGVAL_AGE_LIMIT            60       // Default archive age limit

#define   REGKEY_ACTIVITY_LOG_CONFIG            TEXT("ActivityLogging")    // Key of Activity Logging configuration
#define     REGVAL_ACTIVITY_LOG_DB              TEXT("DBFile")             // Database file
#define     REGVAL_ACTIVITY_LOG_IN              TEXT("LogIncoming")        // Log incoming faxes?
#define     REGVAL_ACTIVITY_LOG_OUT             TEXT("LogOutgoing")        // Log outgoing faxes?

#define   REGKEY_OUTBOUND_ROUTING                   TEXT("Outbound Routing")   // Outbound routing key
#define     REGKEY_OUTBOUND_ROUTING_GROUPS          TEXT("Groups")             // Outbound routing groups key
#define         REGVAL_ROUTING_GROUP_DEVICES        TEXT("Devices")            // List of all group's devices
#define     REGKEY_OUTBOUND_ROUTING_RULES           TEXT("Rules")              // Outbound routing rules key
#define         REGVAL_ROUTING_RULE_COUNTRY_CODE    TEXT("CountryCode")        // Outbound routing rule country code
#define         REGVAL_ROUTING_RULE_AREA_CODE       TEXT("AreaCode")           // Outbound routing rule area code
#define         REGVAL_ROUTING_RULE_GROUP_NAME      TEXT("GroupName")          // Outbound routing rule dest group name
#define         REGVAL_ROUTING_RULE_DEVICE_ID       TEXT("DeviceID")           // Outbound routing rule dest device ID
#define         REGVAL_ROUTING_RULE_USE_GROUP       TEXT("UseGroup")           // Flag inidicating to use group destination

#define   REGKEY_ROUTING_EXTENSIONS             TEXT("Routing Extensions")
#define     REGKEY_ROUTING_METHODS              TEXT("Routing Methods")
#define         REGVAL_FUNCTION_NAME            TEXT("Function Name")
#define         REGVAL_GUID                     TEXT("Guid")
#define         REGVAL_ROUTING_PRIORITY         TEXT("Priority")

#define   REGKEY_UNASSOC_EXTENSION_DATA         TEXT("UnassociatedExtensionData")
#define   REGKEY_DEVICES                        TEXT("Devices")
#define     REGKEY_FAXSVC_DEVICE_GUID           TEXT("{F10A5326-0261-4715-B367-2970427BBD99}")
#define       REGVAL_DEVICE_NAME                TEXT("Device Name")
#define       REGVAL_PROVIDER                   TEXT("Provider Name")
#define       REGVAL_PERMANENT_LINEID           TEXT("Permanent Lineid")
#define       REGVAL_TAPI_PERMANENT_LINEID      TEXT("TAPI Permanent Lineid")

#define       REGVAL_FLAGS                      TEXT("Flags")
#define       REGVAL_RINGS                      TEXT("Rings")
#define       REGVAL_ROUTING_CSID               TEXT("CSID")
#define       REGVAL_ROUTING_TSID               TEXT("TSID")
#define       REGVAL_DEVICE_DESCRIPTION         TEXT("Description")
#define       REGVAL_LAST_DETECTED_TIME         TEXT("LastDetected")
#define       REGVAL_MANUAL_ANSWER              TEXT("ManualAnswer")

#define       REGVAL_LAST_UNIQUE_LINE_ID        TEXT("LastUniqueLineId")

#define   REGKEY_LOGGING                        TEXT("Logging")
#define     REGVAL_CATEGORY_NAME                TEXT("Name")
#define     REGVAL_CATEGORY_LEVEL               TEXT("Level")
#define     REGVAL_CATEGORY_NUMBER              TEXT("Number")

#define   REGKEY_DEVICES_CACHE                  TEXT("Devices Cache")
#define     REGKEY_TAPI_DATA                    TEXT("TAPI Data")

#define REGKEY_FAX_LOGGING                      REGKEY_FAXSERVER TEXT("\\Logging")
#define REGKEY_FAX_INBOX                        REGKEY_FAXSERVER TEXT("\\Inbox")
#define REGKEY_FAX_SENTITEMS                    REGKEY_FAXSERVER TEXT("\\SentItems")
#define REGKEY_FAX_DEVICES                      REGKEY_FAXSERVER TEXT("\\Devices")
#define REGKEY_FAX_DEVICES_CACHE                REGKEY_FAXSERVER TEXT("\\Devices Cache")
#define REGKEY_TAPIDEVICES                      REGKEY_FAXSERVER TEXT("\\TAPIDevices")
#define REGKEY_DEVICE_PROVIDER_KEY              REGKEY_FAXSERVER TEXT("\\Device Providers")
#define REGKEY_ROUTING_EXTENSION_KEY            REGKEY_FAXSERVER TEXT("\\Routing Extensions")
#define REGKEY_USERINFO                         REGKEY_FAXSERVER TEXT("\\UserInfo")
#define REGKEY_FAX_USERINFO                     REGKEY_USERINFO
#define REGKEY_FAX_OUTBOUND_ROUTING             REGKEY_FAXSERVER TEXT("\\Outbound Routing")
#define REGKEY_FAX_OUTBOUND_ROUTING_GROUPS      REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\Groups")
#define REGKEY_FAX_OUTBOUND_ROUTING_RULES       REGKEY_FAX_OUTBOUND_ROUTING TEXT("\\Rules")

#define REGKEY_FAX_SETUP_ORIG                   REGKEY_FAXSERVER TEXT("\\Setup\\Original Setup Data")
//
// device provider reg values
//
#define REGKEY_MODEM_PROVIDER                   TEXT("Microsoft Modem Device Provider")
#define   REGVAL_T30_PROVIDER_GUID_STRING       TEXT("{2172FD8F-11F6-11d3-90BF-006094EB630B}")
//
// MSFT standard routing methods
//
#define REGKEY_ROUTING_METHOD_EMAIL             TEXT("Email")
#define   REGVAL_RM_EMAIL_GUID                  TEXT("{6bbf7bfe-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_FOLDER            TEXT("Folder")
#define   REGVAL_RM_FOLDER_GUID                 TEXT("{92041a90-9af2-11d0-abf7-00c04fd91a4e}")

#define REGKEY_ROUTING_METHOD_PRINTING          TEXT("Printing")
#define   REGVAL_RM_PRINTING_GUID               TEXT("{aec1b37c-9af2-11d0-abf7-00c04fd91a4e}")
//
// GUID of routing methods usage flags - used by the Microsoft Fax Routing Extension DLL:
//
#define   REGVAL_RM_FLAGS_GUID                  TEXT("{aacc65ec-0091-40d6-a6f3-a2ed6057e1fa}")
//
// Routing mask bits
//
#define LR_PRINT                                0x00000001
#define LR_STORE                                0x00000002
#define LR_INBOX                                0x00000004
#define LR_EMAIL                                0x00000008
//
// Routing extension reg values
//
#define REGKEY_ROUTING_EXTENSION                TEXT("Microsoft Routing Extension")
//
// Performance key/values
//
#define REGKEY_FAXPERF                          TEXT("SYSTEM\\CurrentControlSet\\Services\\") FAX_SERVICE_NAME TEXT("\\Performance")
#define   REGVAL_OPEN                           TEXT("Open")
#define     REGVAL_OPEN_DATA                    TEXT("OpenFaxPerformanceData")
#define   REGVAL_CLOSE                          TEXT("Close")
#define     REGVAL_CLOSE_DATA                   TEXT("CloseFaxPerformanceData")
#define   REGVAL_COLLECT                        TEXT("Collect")
#define     REGVAL_COLLECT_DATA                 TEXT("CollectFaxPerformanceData")
#define   REGVAL_LIBRARY                        TEXT("Library")
#define     REGVAL_LIBRARY_DATA                 TEXT("%systemroot%\\system32\\fxsperf.dll")
//
// Security descriptors
//
#define REGKEY_FAX_SECURITY                     REGKEY_FAXSERVER TEXT("\\Security")
#define   REGVAL_DESCRIPTOR                     TEXT("Descriptor")
//
// AppEvents
//
#define REGKEY_FAXSTAT                          TEXT("AppEvents\\Schemes\\Apps\\systray")
#define REGKEY_EVENT_LABEL_IN                   TEXT("AppEvents\\EventLabels\\Incoming-Fax")
#define REGKEY_SCHEMES_DEFAULT_IN               TEXT("AppEvents\\Schemes\\Apps\\systray\\Incoming-Fax\\.Default")
#define REGKEY_SCHEMES_CURRENT_IN               TEXT("AppEvents\\Schemes\\Apps\\systray\\Incoming-Fax\\.Current")
#define REGKEY_EVENT_LABEL_OUT                  TEXT("AppEvents\\EventLabels\\Outgoing-Fax")
#define REGKEY_SCHEMES_DEFAULT_OUT              TEXT("AppEvents\\Schemes\\Apps\\systray\\Outgoing-Fax\\.Default")
#define REGKEY_SCHEMES_CURRENT_OUT              TEXT("AppEvents\\Schemes\\Apps\\systray\\Outgoing-Fax\\.Current")

//
// default mail client
//
#define  REGKEY_MAIL_CLIENT     TEXT("SOFTWARE\\Clients\\Mail")
#define  REGVAL_MS_OUTLOOK      TEXT("Microsoft Outlook")

//
// Combined translated strings from the wizard to the service
// Format is "{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED<dialable string>{11d0ecca-4072-4c7b-9af1-541d9778375f}<displayable string>"
//
#define COMBINED_PREFIX                         TEXT("{0cd77475-c87d-4921-86cf-84d502714666}TRANSLATED")
#define COMBINED_SUFFIX                         TEXT("{11d0ecca-4072-4c7b-9af1-541d9778375f}")
#define COMBINED_TRANSLATED_STRING_FORMAT       COMBINED_PREFIX TEXT("%s") COMBINED_SUFFIX TEXT("%s")
#define COMBINED_TRANSLATED_STRING_EXTRA_LEN    (_tcslen(COMBINED_TRANSLATED_STRING_FORMAT) - 4)

//
// These prefixes are used by all temp preview TIFF files (generated by the client console and the fax send wizard)
//
#define CONSOLE_PREVIEW_TIFF_PREFIX                     TEXT("MSFaxConsoleTempPreview-#")
#define WIZARD_PREVIEW_TIFF_PREFIX                      TEXT("MSFaxWizardTempPreview-#")

#define FAX_ADDERSS_VALID_CHARACTERS                    TEXT("0123456789 -|^!#$*,?@ABCbcdDPTWdptw")

//
// Client console command line parameters.
// All parameters are case insensitive.
//
#define CONSOLE_CMD_FLAG_STR_FOLDER                     TEXT("folder")          // Sets initial startup folder. Usage: "fxsclnt.exe /folder <folder>"
#define CONSOLE_CMD_PRM_STR_OUTBOX                          TEXT("outbox")          // Outbox startup folder. Usage: "fxsclnt.exe /folder outbox"
#define CONSOLE_CMD_PRM_STR_INCOMING                        TEXT("incoming")        // Incoming startup folder. Usage: "fxsclnt.exe /folder incoming"
#define CONSOLE_CMD_PRM_STR_INBOX                           TEXT("inbox")           // Inbox startup folder. Usage: "fxsclnt.exe /folder inbox". This is the default
#define CONSOLE_CMD_PRM_STR_SENT_ITEMS                      TEXT("sent_items")      // sent items startup folder. Usage: "fxsclnt.exe /folder sent_items"

#define CONSOLE_CMD_FLAG_STR_MESSAGE_ID                 TEXT("MessageId")       // Select a message in the startup folder. Usage: "fxsclnt.exe /MessageId 0x0201c0d62f36ec0b"
#define CONSOLE_CMD_FLAG_STR_NEW                        TEXT("New")             // Force a new instance. Usage: "fxsclnt.exe /new"

#endif  // !_FAXREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxuiconstants.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : FaxUIConstants.h                                       //
//                                                                         //
//  DESCRIPTION   : Fax UI Constants.                                      //
//                                                                         //
//  AUTHOR        : yossg                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 28 1999 yossg   create                                         //  
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////
#ifndef _FXS_CONST_H_
#define _FXS_CONST_H_

#include <lmcons.h>

#define FXS_RETRIES_DEFAULT         2
#define FXS_RETRIES_LOWER           0   
#define FXS_RETRIES_UPPER          99    
#define FXS_RETRIES_LENGTH          2 //num of digits of FXS_RETRIES_UPPER

#define FXS_RETRYDELAY_DEFAULT     10
#define FXS_RETRYDELAY_LOWER        0   
#define FXS_RETRYDELAY_UPPER      999    
#define FXS_RETRYDELAY_LENGTH       3 //num of digits of FXS_RETRYDELAY_UPPER

// FXS_DIRTYDAYS_LOWER  
// is actually must have FXS_DIRTYDAYS_ZERO equls zero
// for UI implementation reasons
// Do not change FXS_DIRTYDAYS_LOWER current value!
#define FXS_DIRTYDAYS_ZERO          0   

#define FXS_DIRTYDAYS_DEFAULT      30
#define FXS_DIRTYDAYS_LOWER         1   
#define FXS_DIRTYDAYS_UPPER        99    
#define FXS_DIRTYDAYS_LENGTH        2 //num of digits of FXS_DIRTYDAYS_UPPER

#define FXS_QUOTA_HIGH_DEFAULT     50
#define FXS_QUOTA_HIGH_LOWER        1   
#define FXS_QUOTA_HIGH_UPPER      999    
#define FXS_QUOTA_LENGTH            3 //num of digits of FXS_RINGS_UPPER

#define FXS_QUOTA_LOW_DEFAULT      48
#define FXS_QUOTA_LOW_LOWER         0   
#define FXS_QUOTA_LOW_UPPER       998    

#define FXS_RINGS_DEFAULT           3 
#define FXS_RINGS_LOWER             0   
#define FXS_RINGS_UPPER            99    
#define FXS_RINGS_LENGTH            2 //num of digits of FXS_RINGS_UPPER

#define FXS_DWORD_LEN              10
//Do not change 
#define FXS_MAX_RINGS_LEN          FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_NUM_OF_DEVICES_LEN FXS_DWORD_LEN   //to be safe 
#define FXS_MAX_CODE_LEN           FXS_DWORD_LEN   //to be safe           

#define FXS_MAX_AREACODE_LEN       FXS_DWORD_LEN
#define FXS_MAX_COUNTRYCODE_LEN    FXS_DWORD_LEN

#define FXS_MAX_COUNTRYNAME_LEN   256
#define FXS_MAX_LOG_REPORT_LEVEL    4

//for Node's Display Name
#define FXS_MAX_DISPLAY_NAME_LEN      MAX_FAX_STRING_LEN
//Used in browse dialog, page error msg etc.
#define FXS_MAX_TITLE_LEN             128

#define FXS_MAX_MESSAGE_LEN          1024

#define FXS_MAX_ERROR_MSG_LEN         512
#define FXS_MAX_GENERAL_BUF_LEN       200

#define FXS_THIN_COLUMN_WIDTH          30
#define FXS_NORMAL_COLUMN_WIDTH       120
#define FXS_WIDE_COLUMN_WIDTH         180
#define FXS_LARGE_COLUMN_WIDTH        200

#define FXS_IDS_STATUS_ERROR          999
#define FXS_FIRST_DEVICE_ORDER          1
#define FXS_FIRST_METHOD_PRIORITY       1

#define NUL                             0
#define EQUAL_STRING                    0

#define FXS_STARTSTOP_MAX_SLEEP      1000  //Sec^(-3)
#define FXS_STARTSTOP_MAX_WAIT      20000  //Sec^(-3)

#define FXS_ITEMS_NEVER_COUNTED        -1

//constants from lmcons.h (without the final null)
#define FXS_MAX_PASSWORD_LENGTH     PWLEN  //256
#define FXS_MAX_USERNAME_LENGTH     UNLEN  //256
#define FXS_MAX_DOMAIN_LENGTH       DNLEN  //15
//#define FXS_MAX_SERVERNAME_LENGTH   CNLEN  //15  == MAX_COMPUTERNAME_LENGTH

#define FXS_MAX_EMAIL_ADDRESS         128  

#define FXS_MAX_PORT_NUM           0xffff  //MAX_LONG
#define FXS_MIN_PORT_NUM                0
#define FXS_MAX_PORT_NUM_LEN            5

#define FXS_TSID_CSID_MAX_LENGTH       20

#define FXS_GLOBAL_METHOD_DEVICE_ID     0

//temp
#define FXS_ADMIN_HLP_FILE     L"FxsAdmin.hlp"

#define MAX_USERINFO_FULLNAME            128
#define MAX_USERINFO_FAX_NUMBER          64
#define MAX_USERINFO_COMPANY             128
#define MAX_USERINFO_ADDRESS             256
#define MAX_USERINFO_TITLE               64
#define MAX_USERINFO_DEPT                64
#define MAX_USERINFO_OFFICE              64
#define MAX_USERINFO_HOME_PHONE          64
#define MAX_USERINFO_WORK_PHONE          64
#define MAX_USERINFO_BILLING_CODE        64
#define MAX_USERINFO_MAILBOX             64
#define MAX_USERINFO_STREET              256
#define MAX_USERINFO_CITY                256
#define MAX_USERINFO_STATE               64
#define MAX_USERINFO_ZIP_CODE            64
#define MAX_USERINFO_COUNTRY             256

#endif // _FXS_CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxsendw.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsendw.h

Abstract:

    

Environment:

    

Revision History:

    10/05/99 -v-sashab-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef __FAXSENDW_H_
#define __FAXSENDW_H_

#include <fxsapip.h>

typedef struct {
    DWORD                   dwSizeOfStruct;
    PFAX_COVERPAGE_INFO_EX  lpCoverPageInfo;
    DWORD                   dwNumberOfRecipients;
    PFAX_PERSONAL_PROFILE   lpRecipientsInfo;	
    PFAX_PERSONAL_PROFILE   lpSenderInfo;	
    BOOL                    bSaveSenderInfo;
    BOOL                    bUseDialingRules;
    BOOL                    bUseOutboundRouting;
    DWORD                   dwScheduleAction;
    SYSTEMTIME              tmSchedule;
    DWORD                   dwReceiptDeliveryType;
    LPTSTR                  szReceiptDeliveryAddress; // Depending on the value of dwReceiptDeliveryType this holds:
                                                      // DRT_MSGBOX: The computer name to which the message will be delivered
                                                      // DRT_EMAIL: SMTP address to deliver the receipt to
    LPTSTR                  lptstrPreviewFile;        // The full path to the TIFF to be used as the based for the preview (no cover page included)
    BOOL                    bShowPreview;             // TRUE if the preview option should be enabled
    DWORD                   dwPageCount;              // The number of pages in the preview TIFF (not including cover page). 
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORD                   dwLastRecipientCountryId;
} FAX_SEND_WIZARD_DATA,*LPFAX_SEND_WIZARD_DATA;

enum {	
	FSW_FORCE_COVERPAGE		= 1,
	FSW_FORCE_SUBJECT_OR_NOTE	= 2,
	FSW_USE_SCANNER			= 4,
	FSW_USE_SCHEDULE_ACTION		= 8,
	FSW_USE_RECEIPT			= 16,
	FSW_USE_SEND_WIZARD		= 32,
	FSW_RESEND_WIZARD		= 64,
	FSW_PROPERTY_SHEET		= 128,
        FSW_PRINT_PREVIEW_OPTION    	= 256
};

#endif //__FAXSENDW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\faxutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file defines the debugging interfaces
    available to the FAX compoments.

Author:

    Wesley Witt (wesw) 22-Dec-1995

Environment:

    User Mode

--*/


#ifndef _FAXUTIL_
#define _FAXUTIL_
#include <windows.h>
#include <crtdbg.h>
#include <malloc.h>
#include <WinSpool.h>
#ifndef _FAXAPI_
    //
    // WinFax.h is not already included
    //
    #include <fxsapip.h>
#else
    //
    // WinFax.h is already included
    // This happens by the W2K COM only.
    //
#endif // !defined _FAXAPI_

#include <FaxDebug.h>
#ifdef __cplusplus
extern "C" {
#endif

#define ARR_SIZE(x) (sizeof(x)/sizeof((x)[0]))

//
// Nul terminator for a character string
//

#define NUL             0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)


#define OffsetToString( Offset, Buffer ) ((Offset) ? (LPTSTR) ((Buffer) + ((ULONG_PTR) Offset)) : NULL)
#define StringSize(_s)              (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)
#define StringSizeW(_s)              (( _s ) ? (wcslen( _s ) + 1) * sizeof(WCHAR) : 0)
#define MultiStringSize(_s)         ( ( _s ) ?  MultiStringLength((_s)) * sizeof(TCHAR) : 0 )
#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null

#define FAXBITS     1728
#define FAXBYTES    (FAXBITS/BYTEBITS)

#define MAXHORZBITS FAXBITS
#define MAXVERTBITS 3000        // 14inches plus

#define MINUTES_PER_HOUR    60
#define MINUTES_PER_DAY     (24 * 60)

#define SECONDS_PER_MINUTE  60
#define SECONDS_PER_HOUR    (SECONDS_PER_MINUTE * MINUTES_PER_HOUR)
#define SECONDS_PER_DAY     (MINUTES_PER_DAY * SECONDS_PER_MINUTE)

#define FILETIMETICKS_PER_SECOND    10000000    // 100 nanoseconds / second
#define FILETIMETICKS_PER_DAY       ((LONGLONG) FILETIMETICKS_PER_SECOND * (LONGLONG) SECONDS_PER_DAY)
#define MILLISECONDS_PER_SECOND     1000

#ifndef MAKELONGLONG
#define MAKELONGLONG(low,high) ((LONGLONG)(((DWORD)(low)) | ((LONGLONG)((DWORD)(high))) << 32))
#endif

#define HideWindow(_hwnd)   SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#define UnHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)|WS_VISIBLE)

#define DWord2FaxTime(pFaxTime, dwValue) (pFaxTime)->hour = LOWORD(dwValue), (pFaxTime)->minute = HIWORD(dwValue)
#define FaxTime2DWord(pFaxTime) MAKELONG((pFaxTime)->hour, (pFaxTime)->minute)

#define EMPTY_STRING    TEXT("")

#define IsSmallBiz()        (ValidateProductSuite( VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED))
#define IsCommServer()      (ValidateProductSuite( VER_SUITE_COMMUNICATIONS ))
#define IsProductSuite()    (ValidateProductSuite( VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED | VER_SUITE_COMMUNICATIONS ))

//
// Private T30 and Service status
//
#define FS_SYSTEM_ABORT             0x40000000 // Private T30 status. Used if FaxDevShutDown() was called.
#define FSPI_JS_SYSTEM_ABORT        0x40000001 // Private Service status. Used if FaxDevShutDown() was called.

typedef GUID *PGUID;

typedef enum {
    DEBUG_VER_MSG   =0x00000001,
    DEBUG_WRN_MSG   =0x00000002,
    DEBUG_ERR_MSG   =0x00000004
    } DEBUG_MESSAGE_TYPE;
#define DEBUG_ALL_MSG    DEBUG_VER_MSG | DEBUG_WRN_MSG |  DEBUG_ERR_MSG


//
// Tags used to pass information about fax jobs
//
typedef struct {
    LPTSTR lptstrTagName;
    LPTSTR lptstrValue;
} FAX_TAG_MAP_ENTRY;


void
ParamTagsToString(
     FAX_TAG_MAP_ENTRY * lpTagMap,
     DWORD dwTagCount,
     LPTSTR lpTargetBuf,
     LPDWORD dwSize);


//
// debugging information
//

#ifndef FAXUTIL_DEBUG

#ifdef ENABLE_FRE_LOGGING
#define ENABLE_LOGGING
#endif  // ENABLE_FRE_LOGGING

#ifdef DEBUG
#define ENABLE_LOGGING
#endif  // DEBUG

#ifdef DBG
#define ENABLE_LOGGING
#endif  // DBG

#ifdef ENABLE_LOGGING

#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     fax_dprintf _x_

#define DebugStop(_x_)      {\
                                fax_dprintf _x_;\
                                fax_dprintf(TEXT("Stopping at %s @ %d"),TEXT(__FILE__),__LINE__);\
                                __try {\
                                    DebugBreak();\
                                } __except (UnhandledExceptionFilter(GetExceptionInformation())) {\
                                }\
                            }
#define ASSERT_FALSE \
    {                                           \
        int bAssertCondition = TRUE;            \
        Assert(bAssertCondition == FALSE);      \
    }                                           \



#ifdef USE_DEBUG_CONTEXT

#define DEBUG_WRN USE_DEBUG_CONTEXT,DEBUG_WRN_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_ERR USE_DEBUG_CONTEXT,DEBUG_ERR_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_MSG USE_DEBUG_CONTEXT,DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__

#else

#define DEBUG_WRN DEBUG_CONTEXT_ALL,DEBUG_WRN_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_ERR DEBUG_CONTEXT_ALL,DEBUG_ERR_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__
#define DEBUG_MSG DEBUG_CONTEXT_ALL,DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__

#endif

#define DebugPrintEx dprintfex
#define DebugError
#define DebugPrintEx0(Format) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format);
#define DebugPrintEx1(Format,Param1) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1);
#define DebugPrintEx2(Format,Param1,Param2) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1,Param2);
#define DebugPrintEx3(Format,Param1,Param2,Param3) \
            dprintfex(DEBUG_VER_MSG,faxDbgFunction,TEXT(__FILE__),__LINE__,Format,Param1,Param2,Param3);

#define DEBUG_TRACE_ENTER DebugPrintEx(DEBUG_MSG,TEXT("Entering: %s"),faxDbgFunction);
#define DEBUG_TRACE_LEAVE DebugPrintEx(DEBUG_MSG,TEXT("Leaving: %s"),faxDbgFunction);


#define DEBUG_FUNCTION_NAME(_x_) LPCTSTR faxDbgFunction=_x_; \
                                 DEBUG_TRACE_ENTER;

#define OPEN_DEBUG_FILE(f)   debugOpenLogFile(f)
#define CLOSE_DEBUG_FILE     debugCloseLogFile()

#define SET_DEBUG_PROPERTIES(level,format,context)  debugSetProperties(level,format,context)

#else   // ENABLE_LOGGING

#define ASSERT_FALSE
#define Assert(exp)
#define DebugPrint(_x_)
#define DebugStop(_x_)
#define DebugPrintEx 1 ? (void)0 : dprintfex
#define DebugPrintEx0(Format)
#define DebugPrintEx1(Format,Param1)
#define DebugPrintEx2(Format,Param1,Param2)
#define DebugPrintEx3(Format,Param1,Param2,Param3)
#define DEBUG_FUNCTION_NAME(_x_)
#define DEBUG_TRACE_ENTER
#define DEBUG_TRACE_LEAVE
#define DEBUG_WRN DEBUG_CONTEXT_ALL,DEBUG_WRN_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define DEBUG_ERR DEBUG_CONTEXT_ALL,DEBUG_ERR_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define DEBUG_MSG DEBUG_CONTEXT_ALL,DEBUG_VER_MSG,TEXT(""),TEXT(__FILE__),__LINE__
#define OPEN_DEBUG_FILE(f)
#define CLOSE_DEBUG_FILE
#define SET_DEBUG_PROPERTIES(level,format,context)

#endif  // ENABLE_LOGGING

extern BOOL ConsoleDebugOutput;

void
dprintfex(
    DEBUG_MESSAGE_CONTEXT nMessageContext,
    DEBUG_MESSAGE_TYPE nMessageType,
    LPCTSTR lpctstrDbgFunction,
    LPCTSTR lpctstrFile,
    DWORD dwLine,
    LPCTSTR lpctstrFormat,
    ...
    );

void
fax_dprintf(
    LPCTSTR Format,
    ...
    );

VOID
AssertError(
    LPCTSTR Expression,
    LPCTSTR File,
    ULONG  LineNumber
    );

BOOL debugOpenLogFile(LPCTSTR lpctstrFilename);

void debugCloseLogFile();

void debugSetProperties(DWORD dwLevel,DWORD dwFormat,DWORD dwContext);

BOOL debugIsRegistrySession();
#endif

//
// list management
//

#ifndef NO_FAX_LIST

#define InitializeListHead(ListHead) {\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead);\
    Assert((ListHead)->Flink && (ListHead)->Blink);\
    }

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    Assert ( !((Entry)->Flink) && !((Entry)->Blink) );\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    Assert ( !((Entry)->Flink) && !((Entry)->Blink) );\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    Assert((ListHead)->Flink && (ListHead)->Blink && (Entry)->Blink  && (Entry)->Flink);\
    }

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    Assert((Entry)->Blink  && (Entry)->Flink);\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    (Entry)->Flink = NULL;\
    (Entry)->Blink = NULL;\
    }

#define RemoveHeadList(ListHead) \
    Assert((ListHead)->Flink);\
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#endif

//
// memory allocation
//

#ifndef FAXUTIL_MEM

#define HEAP_SIZE   (1024*1024)

#ifdef FAX_HEAP_DEBUG
#define HEAP_SIG 0x69696969
typedef struct _HEAP_BLOCK {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
    SIZE_T      Size;
    ULONG       Line;
#ifdef UNICODE
    WCHAR       File[22];
#else
    CHAR        File[20];
#endif
} HEAP_BLOCK, *PHEAP_BLOCK;

#define MemAlloc(s)          pMemAlloc(s,__LINE__,__FILE__)
#define MemReAlloc(d,s)      pMemReAlloc(d,s,__LINE__,__FILE__)
#define MemFree(p)           pMemFree(p,__LINE__,__FILE__)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p,__LINE__,__FILE__)
#define CheckHeap(p)         pCheckHeap(p,__LINE__,__FILE__)
#else
#define MemAlloc(s)          pMemAlloc(s)
#define MemReAlloc(d,s)      pMemReAlloc(d,s)
#define MemFree(p)           pMemFree(p)
#define MemFreeForHeap(h,p)  pMemFreeForHeap(h,p)
#define CheckHeap(p)         (TRUE)
#endif

typedef LPVOID (WINAPI *PMEMALLOC)   (SIZE_T);
typedef LPVOID (WINAPI *PMEMREALLOC) (LPVOID,DWORD);
typedef VOID   (WINAPI *PMEMFREE)  (LPVOID);

#define HEAPINIT_NO_VALIDATION      0x00000001
#define HEAPINIT_NO_STRINGS         0x00000002

int GetY2KCompliantDate (
    LCID                Locale,
    DWORD               dwFlags,
    CONST SYSTEMTIME   *lpDate,
    LPTSTR              lpDateStr,
    int                 cchDate
);


HANDLE
HeapInitialize(
    HANDLE hHeap,
    PMEMALLOC pMemAlloc,
    PMEMFREE pMemFree,
    DWORD Flags
    );

BOOL
HeapExistingInitialize(
    HANDLE hExistHeap
    );

BOOL
HeapCleanup(
    VOID
    );

#ifdef FAX_HEAP_DEBUG
BOOL
pCheckHeap(
    PVOID MemPtr,
    ULONG Line,
    LPSTR File
    );

VOID
PrintAllocations(
    VOID
    );

#else

#define PrintAllocations()

#endif

PVOID
pMemAlloc(
    SIZE_T AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

PVOID
pMemReAlloc(
    PVOID dest,
    ULONG AllocSize
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFree(
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

VOID
pMemFreeForHeap(
    HANDLE hHeap,
    PVOID MemPtr
#ifdef FAX_HEAP_DEBUG
    ,ULONG Line
    ,LPSTR File
#endif
    );

#endif

//
// TAPI functions
//
BOOL
GetCallerIDFromCall(
    HCALL hCall,
    LPTSTR lptstrCallerID,
    DWORD dwCallerIDSize
    );

//
// file functions
//

#ifndef FAXUTIL_FILE

typedef struct _FILE_MAPPING {
    HANDLE  hFile;
    HANDLE  hMap;
    LPBYTE  fPtr;
    DWORD   fSize;
} FILE_MAPPING, *PFILE_MAPPING;

BOOL
MapFileOpen(
    LPCTSTR FileName,
    BOOL ReadOnly,
    DWORD ExtendBytes,
    PFILE_MAPPING FileMapping
    );

VOID
MapFileClose(
    PFILE_MAPPING FileMapping,
    DWORD TrimOffset
    );

DWORDLONG
GenerateUniqueFileName(
    LPTSTR Directory,
    LPTSTR Extension,
    OUT LPTSTR FileName,
    DWORD  FileNameSize
    );

DWORDLONG
GenerateUniqueFileNameWithPrefix(
    BOOL   bUseProcessId,
    LPTSTR lptstrDirectory,
    LPTSTR lptstrPrefix,
    LPTSTR lptstrExtension,
    LPTSTR lptstrFileName,
    DWORD  dwFileNameSize
    );

VOID
DeleteTempPreviewFiles (
    LPTSTR lptstrDirectory,
    BOOL   bConsole
);

BOOL
ValidateCoverpage(
    LPCTSTR  CoverPageName,
    LPCTSTR  ServerName,
    BOOL     ServerCoverpage,
    LPTSTR   ResolvedName
    );

#endif

//
// string functions
//

LPTSTR
AllocateAndLoadString(
                      HINSTANCE     hInstance,
                      UINT          uID
                      );

#ifndef FAXUTIL_STRING

#define USES_DWORD_2_STR LPTSTR _lptstrConvert;
#define DWORD2DECIMAL(dwVal)                                    \
            (_lptstrConvert = (LPTSTR) _alloca(11*sizeof(TCHAR)),               \
            _lptstrConvert ? _stprintf(_lptstrConvert,TEXT("%ld"),dwVal) : 0,       \
            _lptstrConvert)
#define DWORD2HEX(dwVal)                                        \
            (_lptstrConvert = (LPTSTR) _alloca(11*sizeof(TCHAR)),               \
            _lptstrConvert ? _stprintf(_lptstrConvert,TEXT("0x%08X"),dwVal):0,      \
             _lptstrConvert)

typedef struct _STRING_PAIR {
        LPTSTR lptstrSrc;
        LPTSTR * lpptstrDst;
} STRING_PAIR, * PSTRING_PAIR;

int MultiStringDup(PSTRING_PAIR lpPairs, int nPairCount);

VOID
StoreString(
    LPCTSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    );

VOID
StoreStringW(
    LPCWSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    );


DWORD
IsValidGUID (
    LPCWSTR lpcwstrGUID
);

LPCTSTR
GetCurrentUserName ();

LPCTSTR
GetRegisteredOrganization ();

BOOL
IsValidSubscriberIdA (
    LPCSTR lpcstrSubscriberId
);

BOOL
IsValidSubscriberIdW (
    LPCWSTR lpcwstrSubscriberId
);

#ifdef UNICODE
    #define IsValidSubscriberId IsValidSubscriberIdW
#else
    #define IsValidSubscriberId IsValidSubscriberIdA
#endif

BOOL
IsValidFaxAddress (
    LPCTSTR lpctstrFaxAddress,
    BOOL    bAllowCanonicalFormat
);

BOOL
SafeTcsLen(
    LPCTSTR lpctstrString,
    LPDWORD lpdwLen
    );


LPTSTR
StringDup(
    LPCTSTR String
    );

LPWSTR
StringDupW(
    LPCWSTR String
    );

LPWSTR
AnsiStringToUnicodeString(
    LPCSTR AnsiString
    );

LPSTR
UnicodeStringToAnsiString(
    LPCWSTR UnicodeString
    );

VOID
FreeString(
    LPVOID String
    );

BOOL
MakeDirectory(
    LPCTSTR Dir
    );

VOID
DeleteDirectory(
    LPTSTR Dir
    );

VOID
HideDirectory(
    LPTSTR Dir
    );

LPTSTR
ConcatenatePaths(
    LPTSTR Path,
    LPCTSTR Append
    );


VOID
ConsoleDebugPrint(
    LPCTSTR buf
    );

int
FormatElapsedTimeStr(
    FILETIME *ElapsedTime,
    LPTSTR TimeStr,
    DWORD StringSize
    );

LPTSTR
ExpandEnvironmentString(
    LPCTSTR EnvString
    );

LPTSTR
GetEnvVariable(
    LPCTSTR EnvString
    );


DWORD
IsCanonicalAddress(
    LPCTSTR lpctstrAddress,
    BOOL* lpbRslt,
    LPDWORD lpdwCountryCode,
    LPDWORD lpdwAreaCode,
    LPCTSTR* lppctstrSubNumber
    );

BOOL
IsLocalMachineNameA (
    LPCSTR lpcstrMachineName
    );

BOOL
IsLocalMachineNameW (
    LPCWSTR lpcwstrMachineName
    );

void
GetSecondsFreeTimeFormat(
    LPTSTR tszTimeFormat,
    ULONG  cchTimeFormat
);

size_t
MultiStringLength(
    LPCTSTR psz
    );


LPTSTR
CopyMultiString (
    LPTSTR strDestination, LPCTSTR strSource
    );

#ifdef UNICODE
    #define IsLocalMachineName IsLocalMachineNameW
#else
    #define IsLocalMachineName IsLocalMachineNameA
#endif

#endif

//
// product suite functions
//

#ifndef FAXUTIL_SUITE

BOOL
ValidateProductSuite(
    WORD Mask
    );

DWORD
GetProductType(
    VOID
    );

BOOL
IsWinXPOS();

typedef enum
{
    PRODUCT_SKU_UNKNOWN             = 0x0000,
    PRODUCT_SKU_PERSONAL            = 0x0001,
    PRODUCT_SKU_PROFESSIONAL        = 0x0002,
    PRODUCT_SKU_SERVER              = 0x0004,
    PRODUCT_SKU_ADVANCED_SERVER     = 0x0008,
    PRODUCT_SKU_DATA_CENTER         = 0x0010,
    PRODUCT_SKU_DESKTOP_EMBEDDED    = 0x0020,
    PRODUCT_SKU_SERVER_EMBEDDED     = 0x0040,
    PRODUCT_SERVER_SKUS             = PRODUCT_SKU_SERVER | PRODUCT_SKU_ADVANCED_SERVER | PRODUCT_SKU_DATA_CENTER | PRODUCT_SKU_SERVER_EMBEDDED,
    PRODUCT_DESKTOP_SKUS            = PRODUCT_SKU_PERSONAL | PRODUCT_SKU_PROFESSIONAL | PRODUCT_SKU_DESKTOP_EMBEDDED,

    PRODUCT_ALL_SKUS                = 0xFFFF
} PRODUCT_SKU_TYPE;

PRODUCT_SKU_TYPE GetProductSKU();

BOOL IsDesktopSKU();

DWORD
GetDeviceLimit();

typedef enum
{
    FAX_COMPONENT_SERVICE           = 0x0001, // FXSSVC.exe   - Fax service
    FAX_COMPONENT_CONSOLE           = 0x0002, // FXSCLNT.exe  - Fax console
    FAX_COMPONENT_ADMIN             = 0x0004, // FXSADMIN.dll - Fax admin console
    FAX_COMPONENT_SEND_WZRD         = 0x0008, // FXSSEND.exe  - Send wizard invocation
    FAX_COMPONENT_CONFIG_WZRD       = 0x0010, // FXSCFGWZ.dll - Configuration wizard
    FAX_COMPONENT_CPE               = 0x0020, // FXSCOVER.exe - Cover page editor
    FAX_COMPONENT_HELP_CLIENT_HLP   = 0x0040, // fxsclnt.hlp  - Client help
    FAX_COMPONENT_HELP_CLIENT_CHM   = 0x0080, // fxsclnt.chm  - Client context help
    FAX_COMPONENT_HELP_ADMIN_HLP    = 0x0100, // fxsadmin.hlp - Admin help
    FAX_COMPONENT_HELP_ADMIN_CHM    = 0x0200, // fxsadmin.chm - Admin context help
    FAX_COMPONENT_HELP_CPE_CHM      = 0x0400, // fxscover.chm - Cover page editor help
    FAX_COMPONENT_MONITOR           = 0x0800, // fxsst.dll    - Fax monitor
    FAX_COMPONENT_DRIVER_UI         = 0x1000  // fxsui.dll    - Fax printer driver

} FAX_COMPONENT_TYPE;

BOOL
IsFaxComponentInstalled(FAX_COMPONENT_TYPE component);

#endif

#ifndef FAXUTIL_LANG

//
// Unicode control characters
//
#define UNICODE_RLM 0x200F  // RIGHT-TO-LEFT MARK      (RLM)
#define UNICODE_RLE 0x202B  // RIGHT-TO-LEFT EMBEDDING (RLE)
#define UNICODE_RLO 0x202E  // RIGHT-TO-LEFT OVERRIDE  (RLO)

#define UNICODE_LRM 0x200E  // LEFT-TO-RIGHT MARK      (LRM)
#define UNICODE_LRE 0x202A  // LEFT-TO-RIGHT EMBEDDING (LRE)
#define UNICODE_LRO 0x202D  // LEFT-TO-RIGHT OVERRIDE  (LRO)

#define UNICODE_PDF 0x202C  // POP DIRECTIONAL FORMATTING (PDF)

//
// language functions
//

BOOL
IsRTLUILanguage();

BOOL
IsWindowRTL(HWND hWnd);

DWORD
SetLTREditDirection(
    HWND    hDlg,
    DWORD   dwEditID
);

DWORD
SetLTRControlLayout(
    HWND    hDlg,
    DWORD   dwCtrlID
);

DWORD
SetLTRComboBox(
    HWND    hDlg,
    DWORD   dwCtrlID
);

BOOL
StrHasRTLChar(
    LCID    Locale,
    LPCTSTR pStr
);

BOOL
IsRTLLanguageInstalled();

int
FaxTimeFormat(
  LCID    Locale,             // locale
  DWORD   dwFlags,            // options
  CONST   SYSTEMTIME *lpTime, // time
  LPCTSTR lpFormat,           // time format string
  LPTSTR  lpTimeStr,          // formatted string buffer
  int     cchTime             // size of string buffer
);

int
AlignedMessageBox(
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType          // message box style
);

#endif

#ifndef FAXUTIL_NET

BOOL
IsSimpleUI();

#endif

//
// registry functions
//

#ifndef FAXUTIL_REG

typedef BOOL (WINAPI *PREGENUMCALLBACK) (HKEY,LPTSTR,DWORD,LPVOID);

HKEY
OpenRegistryKey(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    );

//
// caution!!! this is a recursive delete function !!!
//
BOOL
DeleteRegistryKey(
    HKEY hKey,
    LPCTSTR SubKey
    );

DWORD
EnumerateRegistryKeys(
    HKEY hKey,
    LPCTSTR KeyName,
    BOOL ChangeValues,
    PREGENUMCALLBACK EnumCallback,
    LPVOID ContextData
    );

LPTSTR
GetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue
    );

LPTSTR
GetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR DefaultValue,
    LPDWORD StringSize
    );

DWORD
GetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName
    );

DWORD
GetRegistryDwordEx(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD lpdwValue
    );

LPBYTE
GetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    LPDWORD DataSize
    );

DWORD
GetSubKeyCount(
    HKEY hKey
    );

DWORD
GetMaxSubKeyLen(
    HKEY hKey
    );

BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryString(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value
    );

BOOL
SetRegistryDword(
    HKEY hKey,
    LPCTSTR ValueName,
    DWORD Value
    );

BOOL
SetRegistryBinary(
    HKEY hKey,
    LPCTSTR ValueName,
    const LPBYTE Value,
    LONG Length
    );

BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPCTSTR ValueName,
    LPCTSTR Value,
    DWORD Length
    );

DWORD
CopyRegistrySubkeysByHandle(
    HKEY    hkeyDest,
    HKEY    hkeySrc
    );

DWORD
CopyRegistrySubkeys(
    LPCTSTR strDest,
    LPCTSTR strSrc
    );

BOOL SetPrivilege(
    LPTSTR pszPrivilege,
    BOOL bEnable,
    PTOKEN_PRIVILEGES oldPrivilege
    );


BOOL RestorePrivilege(
    PTOKEN_PRIVILEGES oldPrivilege
    );

DWORD
DeleteDeviceEntry(
    DWORD dwServerPermanentID
    );

DWORD
DeleteTapiEntry(
    DWORD dwTapiPermanentLineID
    );

DWORD
DeleteCacheEntry(
    DWORD dwTapiPermanentLineID
    );

#endif

//
// shortcut routines
//

#ifndef FAXUTIL_SHORTCUT

LPTSTR
GetCometPath();


BOOL
ResolveShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

BOOL
CreateShortcut(
    LPTSTR  pLinkName,
    LPTSTR  pFileName
    );

BOOL
IsCoverPageShortcut(
    LPCTSTR  pLinkName
    );

BOOL
IsValidCoverPage(
    LPCTSTR  pFileName
);

BOOL
GetServerCpDir(
    LPCTSTR ServerName OPTIONAL,
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
GetClientCpDir(
    LPTSTR CpDir,
    DWORD CpDirSize
    );

BOOL
SetClientCpDir(
    LPTSTR CpDir
    );

BOOL
GetSpecialPath(
    int Id,
    LPTSTR DirBuffer
    );

#ifdef _FAXAPIP_


#endif // _FAXAPIP_

DWORD
WinHelpContextPopup(
    ULONG_PTR dwHelpId,
    HWND hWnd
);

#endif

PPRINTER_INFO_2
GetFaxPrinterInfo(
    LPCTSTR lptstrPrinterName
    );

BOOL
GetFirstLocalFaxPrinterName(
    IN LPTSTR lptstrPrinterName,
    IN DWORD dwMaxLenInChars
    );

DWORD
IsLocalFaxPrinterInstalled(
    LPBOOL lpbLocalFaxPrinterInstalled
    );

DWORD
SetLocalFaxPrinterSharing (
    BOOL bShared
    );

#ifdef UNICODE
typedef struct
{
    LPCWSTR lpcwstrDisplayName;     // The display name of the printer
    LPCWSTR lpcwstrPath;            // The (UNC or other) path to the printer - as used by the fax service
} PRINTER_NAMES, *PPRINTER_NAMES;

PPRINTER_NAMES
CollectPrinterNames (
    LPDWORD lpdwNumPrinters,
    BOOL    bFilterOutFaxPrinters
);

VOID
ReleasePrinterNames (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters
);

LPCWSTR
FindPrinterNameFromPath (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrPath
);

LPCWSTR
FindPrinterPathFromName (
    PPRINTER_NAMES pNames,
    DWORD          dwNumPrinters,
    LPCWSTR        lpcwstrName
);

#endif // UNICODE

BOOL
VerifyPrinterIsOnline (
    LPCTSTR lpctstrPrinterName
);

VOID FaxPrinterProperty(DWORD dwPage);

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   dwLevel,
    PDWORD  pcPrinters,
    DWORD   dwFlags
    );


PVOID
MyEnumDrivers3(
    LPTSTR pEnvironment,
    PDWORD pcDrivers
    );


DWORD
IsLocalFaxPrinterShared (
    LPBOOL lpbShared
    );

DWORD
AddLocalFaxPrinter (
    LPCTSTR lpctstrPrinterName,
    LPCTSTR lpctstrPrinterDescription
);

HRESULT
RefreshPrintersAndFaxesFolder ();

PVOID
MyEnumMonitors(
    PDWORD  pcMonitors
    );

BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    );

BOOL
MultiFileDelete(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrFilesDirectory
    );

BOOL
EnsureFaxServiceIsStarted(
    LPCTSTR lpctstrMachineName
    );

BOOL
StopService (
    LPCTSTR lpctstrMachineName,
    LPCTSTR lpctstrServiceName,
    BOOL    bStopDependents
    );

BOOL
WaitForServiceRPCServer (DWORD dwTimeOut);

DWORD
IsFaxServiceRunningUnderLocalSystemAccount (
    LPCTSTR lpctstrMachineName,
    LPBOOL lbpResultFlag
    );

PSID
GetCurrentThreadSID ();

SECURITY_ATTRIBUTES *
CreateSecurityAttributesWithThreadAsOwner (
    DWORD dwAuthUsersAccessRights
);

VOID
DestroySecurityAttributes (
    SECURITY_ATTRIBUTES *pSA
);

HANDLE
OpenSvcStartEvent ();

HANDLE
EnablePrivilege (
    LPCTSTR lpctstrPrivName
);

void
ReleasePrivilege(
    HANDLE hToken
);

DWORD
FaxGetAbsoluteSD(
    PSECURITY_DESCRIPTOR pSelfRelativeSD,
    PSECURITY_DESCRIPTOR* ppAbsoluteSD
);

void
FaxFreeAbsoluteSD (
    PSECURITY_DESCRIPTOR pAbsoluteSD,
    BOOL bFreeOwner,
    BOOL bFreeGroup,
    BOOL bFreeDacl,
    BOOL bFreeSacl,
    BOOL bFreeDescriptor
);




BOOL
MultiFileCopy(
    DWORD    dwNumberOfFiles,
    LPCTSTR* fileList,
    LPCTSTR  lpctstrSrcDirectory,
    LPCTSTR  lpctstrDestDirerctory
    );

typedef enum
{
    CDO_AUTH_ANONYMOUS, // No authentication in SMTP server
    CDO_AUTH_BASIC,     // Basic (plain-text) authentication in SMTP server
    CDO_AUTH_NTLM       // NTLM authentication in SMTP server
}   CDO_AUTH_TYPE;

HRESULT
SendMail (
    LPCTSTR         lpctstrFrom,
    LPCTSTR         lpctstrTo,
    LPCTSTR         lpctstrSubject,
    LPCTSTR         lpctstrBody,
    LPCTSTR         lpctstrAttachmentPath,
    LPCTSTR         lpctstrAttachmentMailFileName,
    LPCTSTR         lpctstrServer,
#ifdef __cplusplus  // Provide default parameters values for C++ clients
    DWORD           dwPort              = 25,
    CDO_AUTH_TYPE   AuthType            = CDO_AUTH_ANONYMOUS,
    LPCTSTR         lpctstrUser         = NULL,
    LPCTSTR         lpctstrPassword     = NULL,
    HANDLE          hLoggedOnUserToken  = NULL
#else
    DWORD           dwPort,
    CDO_AUTH_TYPE   AuthType,
    LPCTSTR         lpctstrUser,
    LPCTSTR         lpctstrPassword,
    HANDLE          hLoggedOnUserToken
#endif
);


//
// FAXAPI structures utils
//


#ifdef _FAXAPIP_

BOOL CopyPersonalProfile(
    PFAX_PERSONAL_PROFILE lpDstProfile,
    LPCFAX_PERSONAL_PROFILE lpcSrcProfile
    );

void FreePersonalProfile (
    PFAX_PERSONAL_PROFILE  lpProfile,
    BOOL bDestroy
    );

#endif // _FAXAPIP_

//
// Tapi helper routines
//

#ifndef FAXUTIL_ADAPTIVE

#include <setupapi.h>

BOOL
IsDeviceModem (
    LPLINEDEVCAPS lpLineCaps,
    LPCTSTR       lpctstrUnimodemTspName
    );

LPLINEDEVCAPS
SmartLineGetDevCaps(
    HLINEAPP hLineApp,
    DWORD    dwDeviceId,
    DWORD    dwAPIVersion
    );


DWORD
GetFaxCapableTapiLinesCount (
    LPDWORD lpdwCount,
    LPCTSTR lpctstrUnimodemTspName
    );

#endif


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//
//  This was borrowed from fatprocs.h

#ifdef DBG
#define try_fail(S) { DebugPrint(( TEXT("Failure in FILE %s LINE %d"), TEXT(__FILE__), __LINE__ )); S; goto try_exit; }
#else
#define try_fail(S) { S; goto try_exit; }
#endif

#define try_return(S) { S; goto try_exit; }
#define NOTHING

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\warning.h ===
#pragma warning(3:4101)         // Unreferenced local variable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\jobtag.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jobtag.h

Abstract:

    Tags used in JOB_INFO_2.pParameters field for passing information
    about fax jobs through the print system to the fax service.

Environment:

        Windows XP fax driver

Revision History:

        06/03/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _JOBTAG_H_
#define _JOBTAG_H_

//
// Tags used to pass in fax job parameters - JOB_INFO_2.pParameters
//
//  JOB_INFO_2.pParameters field contains a tagged string of the form
//      <tag>value<tag>value
//
//  The format of tags is defined as:
//      <$FAXTAG$ tag-name>
//
//  There is exactly one space between the tag keyword and the tag name.
//  Characters in a tag are case-sensitive.
//
//  Currently only two tag names are defined:
//      REC#    recipient's phone number
//      RECNAME recipient's name
//      TSID    sending station identifier
//      SDRNAME sender's name
//      SDRCO   sender's company
//      SDRDEPT sender's department
//      BILL    billing code
//
//  If no recipient number tag is present, the entire string is used
//  as the recipient's fax number.
//

//
// Number fo job parameter tags in the parameter strings.
// UPDATE THIS FIELD when adding fields.
//
#define FAXTAG_PREFIX					TEXT("<$FAXTAG$ ")
#define FAXTAG_NEW_RECORD				TEXT("<$FAXTAG$ NEWREC>")
#define FAXTAG_NEW_RECORD_VALUE			TEXT("1")



//
//Job parameters (11 tags)
//
#define FAXTAG_TSID             TEXT("<$FAXTAG$ TSID>")
#define FAXTAG_BILLING_CODE     TEXT("<$FAXTAG$ BILL>")
#define FAXTAG_SEND_RETRY       TEXT("<$FAXTAG$ SENDRETRY>")
#define FAXTAG_ROUTE_FILE       TEXT("<$FAXTAG$ ROUTEFILE>")
#define FAXTAG_PROFILE_NAME     TEXT("<$FAXTAG$ PROFILENAME>")
#define FAXTAG_RECEIPT_TYPE     TEXT("<$FAXTAG$ RECEIPT_TYPE>")
#define FAXTAG_RECEIPT_ADDR     TEXT("<$FAXTAG$ RECEIPT_ADDR>")
#define FAXTAG_PRIORITY         TEXT("<$FAXTAG$ PRIORITY>")
#define FAXTAG_WHEN_TO_SEND     TEXT("<$FAXTAG$ WHENTOSEND>")  // string == "cheap" | "at"
#define FAXTAG_SEND_AT_TIME     TEXT("<$FAXTAG$ SENDATTIME>")  // string == "hh:mm"
#define FAXTAG_COVERPAGE_NAME   TEXT("<$FAXTAG$ COVERPAGE>")
#define FAXTAG_SERVER_COVERPAGE TEXT("<$FAXTAG$ SRV_COVERPAGE>")
#define FAXTAG_PAGE_COUNT		TEXT("<$FAXTAG$ PAGECOUNT>")
#define FAXTAG_RECIPIENT_COUNT  TEXT("<$FAXTAG$ RECPCOUNT>")
//
//Recipient information (13 tags)
//
#define FAXTAG_RECIPIENT_NAME				TEXT("<$FAXTAG$ REC_NAME>")
#define FAXTAG_RECIPIENT_NUMBER				TEXT("<$FAXTAG$ REC_NUM>")
#define FAXTAG_RECIPIENT_COMPANY			TEXT("<$FAXTAG$ REC_COMPANY>")
#define FAXTAG_RECIPIENT_STREET				TEXT("<$FAXTAG$ REC_STREET>")
#define FAXTAG_RECIPIENT_CITY				TEXT("<$FAXTAG$ REC_CITY>")
#define FAXTAG_RECIPIENT_STATE				TEXT("<$FAXTAG$ REC_STATE>")
#define FAXTAG_RECIPIENT_ZIP				TEXT("<$FAXTAG$ REC_ZIP>")
#define FAXTAG_RECIPIENT_COUNTRY			TEXT("<$FAXTAG$ REC_COUNTRY>")
#define FAXTAG_RECIPIENT_TITLE				TEXT("<$FAXTAG$ REC_TITLE>")
#define FAXTAG_RECIPIENT_DEPT				TEXT("<$FAXTAG$ REC_DEPT>")
#define FAXTAG_RECIPIENT_OFFICE_LOCATION	TEXT("<$FAXTAG$ REC_OFFICE_LOC>")
#define FAXTAG_RECIPIENT_HOME_PHONE			TEXT("<$FAXTAG$ REC_HOME_PHONE>")
#define FAXTAG_RECIPIENT_OFFICE_PHONE		TEXT("<$FAXTAG$ REC_OFFICE_PHONE>")
//
//Sender information (9 tags)
//
#define FAXTAG_SENDER_NAME					TEXT("<$FAXTAG$ SDR_NAME>")
#define FAXTAG_SENDER_NUMBER				TEXT("<$FAXTAG$ SDR_NUM>")
#define FAXTAG_SENDER_COMPANY				TEXT("<$FAXTAG$ SDR_COMPANY>")
#define FAXTAG_SENDER_TITLE					TEXT("<$FAXTAG$ SDR_TITLE>")
#define FAXTAG_SENDER_DEPT					TEXT("<$FAXTAG$ SDR_DEPT>")
#define FAXTAG_SENDER_OFFICE_LOCATION		TEXT("<$FAXTAG$ SDR_OFFICE_LOC>")
#define FAXTAG_SENDER_HOME_PHONE			TEXT("<$FAXTAG$ SDR_HOME_PHONE>")
#define FAXTAG_SENDER_OFFICE_PHONE			TEXT("<$FAXTAG$ SDR_OFFICE_PHONE>")
#define FAXTAG_SENDER_STREET				TEXT("<$FAXTAG$ SDR_STREET>")
#define FAXTAG_SENDER_CITY					TEXT("<$FAXTAG$ SDR_CITY>")
#define FAXTAG_SENDER_STATE					TEXT("<$FAXTAG$ SDR_STATE>")
#define FAXTAG_SENDER_ZIP					TEXT("<$FAXTAG$ SDR_ZIP>")
#define FAXTAG_SENDER_COUNTRY				TEXT("<$FAXTAG$ SDR_COUNTRY>")
#define FAXTAG_SENDER_EMAIL				    TEXT("<$FAXTAG$ SDR_EMAIL>")

//
// Coverpage information (2 tags)
//
#define FAXTAG_NOTE			TEXT("<$FAXTAG$ NOTE>")
#define FAXTAG_SUBJECT		TEXT("<$FAXTAG$ SUBJECT>")

#endif  // !_JOBTAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\hlpres.h ===
// Help ID include file.
// Used by ClientConsole.rc
//

#ifndef _FAX_CLIENT_UI_HELP_IDS_H_
#define _FAX_CLIENT_UI_HELP_IDS_H_

//
// Common
//
#define HIDOK                           1000000001  
#define HIDCANCEL                       1000000002   
#define HIDC_CLOSE                      1000000008

//
// IDD_COLUMN_SELECT
//
#define HIDC_BUT_DOWN                   1000000011  
#define HIDC_BUT_ADD                    1000000012  
#define HIDC_BUT_REMOVE                 1000000013  
#define HIDC_BUT_UP                     1000000014  
#define HIDC_LIST_AVAILABLE             1000000015  
#define HIDC_LIST_DISPLAYED             1000000016  

//
// IDD_OPTIONS_USER_INFO
//
#define HIDC_ADDRESS_TITLE              1000000031  
#define HIDC_BILLING_CODE_TITLE         1000000032  
#define HIDC_BUSINESS_PHONE_TITLE       1000000033  
#define HIDC_COMPANY_TITLE              1000000034  
#define HIDC_DEPARTMENT_TITLE           1000000035  
#define HIDC_EMAIL_TITLE                1000000036  
#define HIDC_FAX_NUMBER_TITLE           1000000037  
#define HIDC_HOME_PHONE_TITLE           1000000038  
#define HIDC_NAME_TITLE                 1000000039  
#define HIDC_OFFICE_TITLE               1000000040  
#define HIDC_TITLE_TITLE                1000000041  
#define HIDC_USER_INFO_JUST_THIS_TIME   1000000043   

//
// IDD_INBOX_GENERAL
//
#define HIDC_DURATION_TITLE             1000000051  
#define HIDC_END_TIME_TITLE             1000000052  
#define HIDC_INBOX_PAGES_VALUE          1000000053  
#define HIDC_SIZE_TITLE                 1000000054  
#define HIDC_START_TIME_TITLE           1000000055  
#define HIDC_INBOX_STATUS_VALUE         1000000056  

//
// IDD_INBOX_DETAILS
//
#define HIDC_CALLER_ID_TITLE            1000000061  
#define HIDC_CSID_TITLE                 1000000062  
#define HIDC_DEVICE_TITLE               1000000063  
#define HIDC_JOB_ID_TITLE               1000000064  
#define HIDC_ROUTING_INFO_TITLE         1000000065  
#define HIDC_TSID_TITLE                 1000000066  

//
// IDD_OUTBOX_GENERAL
//
#define HIDC_DOC_NAME_TITLE             1000000071  
#define HIDC_RECIPIENT_NAME_TITLE       1000000072  
#define HIDC_RECIPIENT_NUMBER_TITLE     1000000073  
#define HIDC_SUBJECT_TITLE              1000000074  
#define HIDC_TRANSMISSION_TIME_TITLE    1000000075  
#define HIDC_OUTBOX_STATUS_VALUE        1000000076   
#define HIDC_OUTBOX_PAGES_VALUE         1000000077   
#define HIDC_OUTBOX_CURRENT_PAGE_VALUE  1000000078   
#define HIDC_OUTBOX_EXTENDED_STATUS     1000000079   

//
// IDD_OUTBOX_DETAILS
//
#define HIDC_PRIORITY_TITLE             1000000081  
#define HIDC_SCHEDULED_TIME_TITLE       1000000082  
#define HIDC_SUBMISSION_TIME_TITLE      1000000083  
#define HIDC_USER_TITLE                 1000000084  
#define HIDC_BROADCAST_ID_TITLE         1000000085 

//
// IDD_INCOMING_GENERAL
//
#define HIDC_INCOMING_CURRENT_PAGE_VALUE 1000000091  
#define HIDC_INCOMING_EXTENDED_STATUS    1000000092  
#define HIDC_INCOMING_STATUS_VALUE       1000000093  
#define HIDC_INCOMING_PAGES_VALUE        1000000094  

//
// IDD_INCOMING_DETAILS
//
#define HIDC_RETRIES_TITLE              1000000101
#define HIDC_RCV_DEVICE_TITLE           1000000102
#define HIDC_ROUTE_TIME_TITLE           1000000103
#define HIDC_ROUTE_RETRIES_TITLE        1000000104

//
// IDD_SENT_ITEMS_GENERAL
//
#define HIDC_SENDER_NAME_TITLE          1000000111  
#define HIDC_SENDER_NUMBER_TITLE        1000000112  
#define HIDC_SENT_ITEMS_PAGES_VALUE     1000000113   

//
// IDD_COVER_PAGES
//
#define HIDC_LIST_CP                    1000000121
#define HIDC_CP_OPEN                    1000000122
#define HIDC_CP_NEW                     1000000123
#define HIDC_CP_RENAME                  1000000124
#define HIDC_CP_DELETE                  1000000125
#define HIDC_CP_ADD                     1000000126

//
// IDD_SERVER_STATUS
//
#define HIDC_LIST_SERVER                1000000131

//
// Outlook extention
//
#define HIDC_MAPI_PRINTER_LIST          1000000141 
#define HIDC_MAPI_INCLUDE_COVER_PAGES   1000000142 
#define HIDC_MAPI_COVERPAGE_LIST        1000000143 
#define HIDC_MAPI_SEND_SINGLE_RECEIPT   1000000144 
#define HIDC_MAPI_FONT_NAME             1000000145 
#define HIDC_MAPI_FONT_STYLE            1000000146 
#define HIDC_MAPI_FONT_SIZE             1000000147 
#define HIDC_MAPI_BUT_SET_FONT          1000000148 
#define HIDC_MAPI_ATTACH_FAX            1000000149 
#define HIDC_MAPI_IENABLE_SINGLECP      1000000150 // Should read for a specific fax
#define HIDC_MAPI_SINGLE_ATTACH_FAX     1000000151 
#define HIDC_MAPI_SINGLE_CP_LIST        1000000152 // For a specific fax


//
// IDD_PRINTER_SELECT
//
#define HIDC_PRINTER_SELECTOR           1000000161

//
// IDD_PERSONAL_INFO - Sender Information Page
//  
#define HIDC_READ_NAME_VALUE            1000000172
#define HIDC_READ_FAX_NUMBER_VALUE      1000000173
#define HIDC_READ_EMAIL_VALUE           1000000174
#define HIDC_READ_TITLE_VALUE           1000000175
#define HIDC_READ_COMPANY_VALUE         1000000176
#define HIDC_READ_DEPARTMENT_VALUE      1000000177
#define HIDC_READ_OFFICE_VALUE          1000000178
#define HIDC_READ_BUSINESS_PHONE_VALUE  1000000179
#define HIDC_READ_HOME_PHONE_VALUE      1000000180
#define HIDC_READ_ADDRESS_VALUE         1000000181
#define HIDC_READ_BILLING_CODE_VALUE    1000000182

//
// IDD_DOCPROP - Fax Preferences
//
#define HIDC_FP_PAPER                   1000000191
#define HIDC_FP_IMAGE                   1000000192
#define HIDC_FP_ORIENT                  1000000193
#define HIDC_FP_PORTRAIT                1000000194
#define HIDC_FP_LANDSCAPE               1000000195

//
// IDD_DEVICE_INFO - Devices
//
#define HIDC_PFDevice_Details           1000000201
#define HIDC_PFDevice_TSID              1000000202
#define HIDC_PFDevice_CSID              1000000203
#define HIDC_PFDevice_Rings             1000000204
#define HIDC_PFDevice_Prop              1000000205

//
// IDD_RECEIVE_PROP - Receive
//
#define HIDC_PFRecv_Enable              1000000211 // Enable receive checkbox
#define HIDC_PFRecv_CSID                1000000212 // CSID text box
#define HIDC_PFRecv_Manual              1000000213 // Manual option button: 
#define HIDC_PFRecv_Auto                1000000214 // Auto option button: 
#define HIDC_PFRecv_NumRings            1000000215 // Rings spin box 
#define HIDC_PFRecv_Print               1000000216 // Enable to Print 
#define HIDC_PFRecv_Save                1000000217 // Enable to Save 
#define HIDC_PFRecv_PrintLoc            1000000218 // Print location 
#define HICD_PFRecv_SaveLoc             1000000219 // Folder location 
#define HICD_PFRecv_Browse              1000000220 // Browse button

//
// IDD_SEND_PROP - Send
//
#define HIDC_PFSend_Enable              1000000231 // Enable send checkbox 
#define HIDC_PFSend_TSID                1000000232 // TSID text box
#define HIDC_PFSend_NumRetry            1000000233 // Number of retries
#define HIDC_PFSend_RetryAfter          1000000234 // Retry after
#define HIDC_PFSend_DiscStart           1000000235 // Discount rate start 
#define HIDC_PFSend_DiscEnd             1000000236 // Discount rate end 
#define HIDC_PFSend_Banner              1000000237 // Enable banner 
#define HIDC_PFSend_Days_chk            1000000238 // "Automatically delete failed incoming and outgoing faxes after..." checkbox
#define HIDC_PFSend_Days_edt            1000000239 // "Automatically delete failed incoming and outgoing faxes after..." days edit box
#define HIDC_PFSend_Days_days           1000000240 // "Automatically delete failed incoming and outgoing faxes after..." days static text

//
// IDD_ARCHIVE_FOLDER - Archives
//
#define HIDC_PFArch_Recv                1000000241 // Enable incoming archive 
#define HIDC_PFArch_Sent                1000000242 // Enable outgoing archive 
#define HIDC_PFArch_RecvLoc             1000000243 // Text box incoming location 
#define HIDC_PFArch_SentLoc             1000000244 // Text box sent items location 
#define HIDC_PFArch_Browse              1000000245 // Browse button 

//
// IDD_SOUNDS - Sound Settings
//
#define HIDC_PFTrack_Sounds			    1000000251

//
// IDD_STATUS_OPTIONS - Tracking
//
#define HIDC_PFTrack_Device             1000000261 // Select fax device label and dropdown 
#define HIDC_PFTrack_Progress           1000000262 // Checkbox show progress 
#define HIDC_PFTrack_In                 1000000263 // Checkbox success in 
#define HIDC_PFTrack_Out                1000000264 // Checkbox success out 
#define HIDC_PRTrack_MonOut             1000000265 // Checkbox open FM for outgoing
#define HIDC_PRTrack_MonIn              1000000266 // Checkbox open FM for incoming 
#define HIDC_PRTrack_ConfSound          1000000267 // Button sound 

//
// IDD_MONITOR - Fax Monitor
//
#define HIDC_FaxMon_Status              1000000271 // Status label 
#define HIDC_FaxMon_Elapsed             1000000272 // Elapsed time label 
#define HIDC_FaxMon_OnTop               1000000273 // Enable keep on top 
#define HIDC_FaxMon_Hide                1000000274 // Hide button 
#define HIDC_FaxMon_Disconnect          1000000275 // Disconnect button 
#define HIDC_FaxMon_More_Less           1000000276 // More/Less button
#define HIDC_FaxMon_MoreInfo            1000000277 // Time/Status list
#define HIDC_FaxMon_ClearList           1000000278 // Clear list button

//
// IDD_SELECT_FAXPRINTER - Select Fax Printer
//
#define HIDC_SelectFP                   1000000281 // Fax Printer List 

//
// IDD_OBJ_PROP - Line, Fill and Color
//
#define HIDC_CPE_DrawBorder             1000000291 // Draw border/line
#define HIDC_CPE_Thickness              1000000292 // Thickness
#define HIDC_CPE_LineColor              1000000293 // Line color
#define HIDC_CPE_FillTrans              1000000294 // Fill color transparent
#define HIDC_CPE_FillColor              1000000295 // Fill color
#define HIDC_CPE_TextColor              1000000296 // Text color

#endif // _FAX_CLIENT_UI_HELP_IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\makefile.inc ===
all: FAXINC
clean: cleansrc

FAXINC: WINFAX.H FXSAPIP.H

WINFAX.X FXSAPIP.X: WINFAX.W
	hsplit -o WINFAX.X FXSAPIP.X WINFAX.W
WINFAX.H: WINFAX.X
	wcshdr < WINFAX.X > WINFAX.H

FXSAPIP.H: FXSAPIP.X
	wcshdr < FXSAPIP.X > FXSAPIP.H


cleansrc:
	-del winfax.h
	-del fxsapip.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\prtcovpg.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    prtcovpg.h

Abstract:

    This module contains the WIN32 FAX API header
    for the Windows XP FaxCover rendering routine.

Author:

    Julia Robinson (a-juliar) 5-20-96

Revision History:

    Julia Robinson (a-juliar) 6-7-76
    Julia Robinson (a-juliar) 9-20-96     Allow passing paper size and orientation.
--*/

#ifndef __PRTCOVPG_H__
#define __PRTCOVPG_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Structure of the composite file header
//

typedef struct {
    BYTE      Signature[20];
    DWORD     EmfSize;
    DWORD     NbrOfTextRecords;
    SIZE      CoverPageSize;
} COMPOSITEFILEHEADER;

//
// Structure of the text box entries appended to
// the composite file
//

typedef struct {
    RECT           PositionOfTextBox;
    COLORREF       TextColor;
    LONG           TextAlignment;
    LOGFONTW       FontDefinition;
    WORD           ResourceID ;
    DWORD          NumStringBytes;     // Variable length string will follow this structure
} TEXTBOX;


//
// Structure of user data for text insertions
//

typedef struct _COVERPAGEFIELDS {

  //
  // Recipient stuff...
  //

  DWORD   ThisStructSize;
  LPTSTR  RecName;
  LPTSTR  RecFaxNumber;
  LPTSTR  RecCompany;
  LPTSTR  RecStreetAddress;
  LPTSTR  RecCity;
  LPTSTR  RecState;
  LPTSTR  RecZip;
  LPTSTR  RecCountry;
  LPTSTR  RecTitle;
  LPTSTR  RecDepartment;
  LPTSTR  RecOfficeLocation;
  LPTSTR  RecHomePhone;
  LPTSTR  RecOfficePhone;

  //
  // Senders stuff...
  //

  LPTSTR  SdrName;
  LPTSTR  SdrFaxNumber;
  LPTSTR  SdrCompany;
  LPTSTR  SdrAddress;
  LPTSTR  SdrTitle;
  LPTSTR  SdrDepartment;
  LPTSTR  SdrOfficeLocation;
  LPTSTR  SdrHomePhone;
  LPTSTR  SdrOfficePhone;

  //
  // Misc Stuff...
  //
  LPTSTR  Note;
  LPTSTR  Subject;
  LPTSTR  TimeSent;
  LPTSTR  NumberOfPages;
  LPTSTR  ToList;
  LPTSTR  CCList ;
} COVERPAGEFIELDS, *PCOVERPAGEFIELDS;

#define  NUM_INSERTION_TAGS   ((sizeof(COVERPAGEFIELDS) - sizeof(DWORD)) / sizeof(LPTSTR))

//
// pFlags fields: bit 0 is Recipient Name, bit 1 is Recipient Fax Number, et cetera.
//

#define  COVFP_NOTE         0x00400000
#define  COVFP_SUBJECT      0x00800000
#define  COVFP_NUMPAGES     0x02000000

typedef struct _COVDOCINFO {
    DWORD       Flags ;
    RECT        NoteRect ;
    short       Orientation ;
    short       PaperSize ;
    LOGFONT     NoteFont ;
} COVDOCINFO, *PCOVDOCINFO ;


//
// Function prototypes
//

DWORD WINAPI
PrintCoverPage(
    HDC               hDC,
    PCOVERPAGEFIELDS  pUserData,
    LPCTSTR           lpctstrTemplateFileName,
    PCOVDOCINFO       pCovDocInfo
    );

DWORD
WINAPI
RenderCoverPage(
    HDC              hdc,
	LPCRECT			 lpcRect,
    PCOVERPAGEFIELDS pUserData,
    LPCTSTR          lpctstrTemplateFileName,
    PCOVDOCINFO      pCovDocInfo,
    BOOL             bPreview
    );


DWORD
PrintCoverPageToFile(
    LPTSTR lptstrCoverPage,
    LPTSTR lptstrTargetFile,
    LPTSTR lptstrPrinterName,
    short sCPOrientation,
	short sCPYResolution,
    PCOVERPAGEFIELDS pCPFields);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\winres.h ===
//
// this header file is necessay because
// vc is lame.  it insists on including
// a file named winres.h in it's generated
// rc file.  the problem is that winres.h
// is a non-standard header file that
// exists only in a vc install.
//

#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\routemapi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    routemapi.h

Abstract:

    This module provides the implemantation of registry manipulations to 
    route MAPI calls to the Microsoft Outlook mail client

Author:

    Mooly Beery (moolyb) 5-Nov-2000


Revision History:

--*/

#ifndef __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__
#define __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__

// EXPORT_MAPI_ROUTE_CALLS is defined in the module only
// this way when the module is compiled the class exports its functions
// when others use this header file the functions won't be exported by them
#ifdef EXPORT_MAPI_ROUTE_CALLS
    #define dllexp __declspec( dllexport )
#else   // EXPORT_MAPI_ROUTE_CALLS
    #define dllexp 
#endif  // EXPORT_MAPI_ROUTE_CALLS

class dllexp CRouteMAPICalls
{
public:
    CRouteMAPICalls();    
    ~CRouteMAPICalls();                             // used to restore the changes the Init method performed

    DWORD Init(LPCTSTR lpctstrProcessName);         // this is the process for which the MAPI calls are routed
                                                    // used to set up the registry to route MAPI calls of the 
                                                    // proper process to the Microsoft Outlook mail client
                                                    // and to suppress any pop-ups which might occur
private:

    bool m_bMSOutlookInstalled;                     // is Microsoft Outlook mail client installed
    bool m_bMSOutlookIsDefault;                     // is Microsoft Outlook the default mail client
    bool m_bProcessIsRouted;                        // are calls from the requested process already routed
    bool m_bProcessIsRoutedToMsOutlook;             // are calls from the process routed to Ms Outlook

    TCHAR* m_ptProcessName;                         // process name to route calls for

};

#endif  // __FAX_MAPI_ROUTE_CALLS_HEADER_FILE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\tiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiff.h

Abstract:

    This file the data structures and constant
    definitions for the TIFF file format.
    See the TIFF specification Revision 6.0,
    dated 6-3-92, from Adobe for specific details.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/


#ifndef _TIFF_
#define _TIFF_

#define TIFF_VERSION    42

#define TIFF_BIGENDIAN          0x4d4d
#define TIFF_LITTLEENDIAN       0x4949

#pragma pack(1)

typedef struct _TIFF_HEADER {
    WORD        Identifier;
    WORD        Version;
    DWORD       IFDOffset;
} TIFF_HEADER, *PTIFF_HEADER;

//
// TIFF Image File Directories are comprised of
// a table of field descriptors of the form shown
// below.  The table is sorted in ascending order
// by tag.  The values associated with each entry
// are disjoint and may appear anywhere in the file
// (so long as they are placed on a word boundary).
//
// If the value is 4 bytes or less, then it is placed
// in the offset field to save space.  If the value
// is less than 4 bytes, it is left-justified in the
// offset field.
//
typedef struct _TIFF_TAG {
    WORD        TagId;
    WORD        DataType;
    DWORD       DataCount;
    DWORD       DataOffset;
} TIFF_TAG;

typedef TIFF_TAG UNALIGNED *PTIFF_TAG;

typedef struct TIFF_IFD {
    WORD        wEntries;
    TIFF_TAG    ifdEntries[1];
} TIFF_IFD;

typedef TIFF_IFD UNALIGNED *PTIFF_IFD;


#pragma pack()


//
// NB: In the comments below,
//  - items marked with a + are obsoleted by revision 5.0,
//  - items marked with a ! are introduced in revision 6.0.
//  - items marked with a % are introduced post revision 6.0.
//  - items marked with a $ are obsoleted by revision 6.0.
//

//
// Tag data type information.
//
#define TIFF_NOTYPE                     0       // placeholder
#define TIFF_BYTE                       1       // 8-bit unsigned integer
#define TIFF_ASCII                      2       // 8-bit bytes w/ last byte null
#define TIFF_SHORT                      3       // 16-bit unsigned integer
#define TIFF_LONG                       4       // 32-bit unsigned integer
#define TIFF_RATIONAL                   5       // 64-bit unsigned fraction
#define TIFF_SBYTE                      6       // !8-bit signed integer
#define TIFF_UNDEFINED                  7       // !8-bit untyped data
#define TIFF_SSHORT                     8       // !16-bit signed integer
#define TIFF_SLONG                      9       // !32-bit signed integer
#define TIFF_SRATIONAL                  10      // !64-bit signed fraction
#define TIFF_FLOAT                      11      // !32-bit IEEE floating point
#define TIFF_DOUBLE                     12      // !64-bit IEEE floating point

//
// TIFF Tag Definitions.
//
#define TIFFTAG_SUBFILETYPE             254     // subfile data descriptor
#define     FILETYPE_REDUCEDIMAGE       0x1     // reduced resolution version
#define     FILETYPE_PAGE               0x2     // one page of many
#define     FILETYPE_MASK               0x4     // transparency mask
#define TIFFTAG_OSUBFILETYPE            255     // +kind of data in subfile
#define     OFILETYPE_IMAGE             1       // full resolution image data
#define     OFILETYPE_REDUCEDIMAGE      2       // reduced size image data
#define     OFILETYPE_PAGE              3       // one page of many
#define TIFFTAG_IMAGEWIDTH              256     // image width in pixels
#define TIFFTAG_IMAGELENGTH             257     // image height in pixels
#define TIFFTAG_BITSPERSAMPLE           258     // bits per channel (sample)
#define TIFFTAG_COMPRESSION             259     // data compression technique
#define     COMPRESSION_NONE            1       // dump mode
#define     COMPRESSION_CCITTRLE        2       // CCITT modified Huffman RLE
#define     COMPRESSION_CCITTFAX3       3       // CCITT Group 3 fax encoding
#define     COMPRESSION_CCITTFAX4       4       // CCITT Group 4 fax encoding
#define     COMPRESSION_LZW             5       // Lempel-Ziv  & Welch
#define     COMPRESSION_OJPEG           6       // !6.0 JPEG
#define     COMPRESSION_JPEG            7       // %JPEG DCT compression
#define     COMPRESSION_NEXT            32766   // NeXT 2-bit RLE
#define     COMPRESSION_CCITTRLEW       32771   // #1 w/ word alignment
#define     COMPRESSION_PACKBITS        32773   // Macintosh RLE
#define     COMPRESSION_THUNDERSCAN     32809   // ThunderScan RLE
//
// compression codes 32908-32911 are reserved for Pixar
//
#define     COMPRESSION_PIXARFILM       32908   // Pixar companded 10bit LZW
#define     COMPRESSION_DEFLATE         32946   // Deflate compression
#define     COMPRESSION_JBIG            34661   // ISO JBIG
#define TIFFTAG_PHOTOMETRIC             262     // photometric interpretation
#define     PHOTOMETRIC_MINISWHITE      0       // min value is white
#define     PHOTOMETRIC_MINISBLACK      1       // min value is black
#define     PHOTOMETRIC_RGB             2       // RGB color model
#define     PHOTOMETRIC_PALETTE         3       // color map indexed
#define     PHOTOMETRIC_MASK            4       // $holdout mask
#define     PHOTOMETRIC_SEPARATED       5       // !color separations
#define     PHOTOMETRIC_YCBCR           6       // !CCIR 601
#define     PHOTOMETRIC_CIELAB          8       // !1976 CIE L*a*b*
#define TIFFTAG_THRESHHOLDING           263     // +thresholding used on data
#define     THRESHHOLD_BILEVEL          1       // b&w art scan
#define     THRESHHOLD_HALFTONE         2       // or dithered scan
#define     THRESHHOLD_ERRORDIFFUSE     3       // usually floyd-steinberg
#define TIFFTAG_CELLWIDTH               264     // +dithering matrix width
#define TIFFTAG_CELLLENGTH              265     // +dithering matrix height
#define TIFFTAG_FILLORDER               266     // data order within a byte
#define     FILLORDER_MSB2LSB           1       // most significant -> least
#define     FILLORDER_LSB2MSB           2       // least significant -> most
#define TIFFTAG_DOCUMENTNAME            269     // name of doc. image is from
#define TIFFTAG_IMAGEDESCRIPTION        270     // info about image
#define TIFFTAG_MAKE                    271     // scanner manufacturer name
#define TIFFTAG_MODEL                   272     // scanner model name/number
#define TIFFTAG_STRIPOFFSETS            273     // offsets to data strips
#define TIFFTAG_ORIENTATION             274     // +image orientation
#define     ORIENTATION_TOPLEFT         1       // row 0 top, col 0 lhs
#define     ORIENTATION_TOPRIGHT        2       // row 0 top, col 0 rhs
#define     ORIENTATION_BOTRIGHT        3       // row 0 bottom, col 0 rhs
#define     ORIENTATION_BOTLEFT         4       // row 0 bottom, col 0 lhs
#define     ORIENTATION_LEFTTOP         5       // row 0 lhs, col 0 top
#define     ORIENTATION_RIGHTTOP        6       // row 0 rhs, col 0 top
#define     ORIENTATION_RIGHTBOT        7       // row 0 rhs, col 0 bottom
#define     ORIENTATION_LEFTBOT         8       // row 0 lhs, col 0 bottom
#define TIFFTAG_SAMPLESPERPIXEL         277     // samples per pixel
#define TIFFTAG_ROWSPERSTRIP            278     // rows per strip of data
#define TIFFTAG_STRIPBYTECOUNTS         279     // bytes counts for strips
#define TIFFTAG_MINSAMPLEVALUE          280     // +minimum sample value
#define TIFFTAG_MAXSAMPLEVALUE          281     // +maximum sample value
#define TIFFTAG_XRESOLUTION             282     // pixels/resolution in x
#define TIFFTAG_YRESOLUTION             283     // pixels/resolution in y
#define TIFFTAG_PLANARCONFIG            284     // storage organization
#define     PLANARCONFIG_CONTIG         1       // single image plane
#define     PLANARCONFIG_SEPARATE       2       // separate planes of data
#define TIFFTAG_PAGENAME                285     // page name image is from
#define TIFFTAG_XPOSITION               286     // x page offset of image lhs
#define TIFFTAG_YPOSITION               287     // y page offset of image lhs
#define TIFFTAG_FREEOFFSETS             288     // +byte offset to free block
#define TIFFTAG_FREEBYTECOUNTS          289     // +sizes of free blocks
#define TIFFTAG_GRAYRESPONSEUNIT        290     // $gray scale curve accuracy
#define     GRAYRESPONSEUNIT_10S        1       // tenths of a unit
#define     GRAYRESPONSEUNIT_100S       2       // hundredths of a unit
#define     GRAYRESPONSEUNIT_1000S      3       // thousandths of a unit
#define     GRAYRESPONSEUNIT_10000S     4       // ten-thousandths of a unit
#define     GRAYRESPONSEUNIT_100000S    5       // hundred-thousandths
#define TIFFTAG_GRAYRESPONSECURVE       291     // $gray scale response curve
#define TIFFTAG_GROUP3OPTIONS           292     // 32 flag bits
#define     GROUP3OPT_2DENCODING        0x1     // 2-dimensional coding
#define     GROUP3OPT_UNCOMPRESSED      0x2     // data not compressed
#define     GROUP3OPT_FILLBITS          0x4     // fill to byte boundary
#define TIFFTAG_GROUP4OPTIONS           293     // 32 flag bits
#define     GROUP4OPT_UNCOMPRESSED      0x2     // data not compressed
#define TIFFTAG_RESOLUTIONUNIT          296     // units of resolutions
#define     RESUNIT_NONE                1       // no meaningful units
#define     RESUNIT_INCH                2       // english
#define     RESUNIT_CENTIMETER          3       // metric
#define TIFFTAG_PAGENUMBER              297     // page numbers of multi-page
#define TIFFTAG_COLORRESPONSEUNIT       300     // $color curve accuracy
#define     COLORRESPONSEUNIT_10S       1       // tenths of a unit
#define     COLORRESPONSEUNIT_100S      2       // hundredths of a unit
#define     COLORRESPONSEUNIT_1000S     3       // thousandths of a unit
#define     COLORRESPONSEUNIT_10000S    4       // ten-thousandths of a unit
#define     COLORRESPONSEUNIT_100000S   5       // hundred-thousandths
#define TIFFTAG_TRANSFERFUNCTION        301     // !colorimetry info
#define TIFFTAG_SOFTWARE                305     // name & release
#define TIFFTAG_DATETIME                306     // creation date and time
#define TIFFTAG_ARTIST                  315     // creator of image
#define TIFFTAG_HOSTCOMPUTER            316     // machine where created
#define TIFFTAG_PREDICTOR               317     // prediction scheme w/ LZW
#define TIFFTAG_WHITEPOINT              318     // image white point
#define TIFFTAG_PRIMARYCHROMATICITIES   319     // !primary chromaticities
#define TIFFTAG_COLORMAP                320     // RGB map for pallette image
#define TIFFTAG_HALFTONEHINTS           321     // !highlight+shadow info
#define TIFFTAG_TILEWIDTH               322     // !rows/data tile
#define TIFFTAG_TILELENGTH              323     // !cols/data tile
#define TIFFTAG_TILEOFFSETS             324     // !offsets to data tiles
#define TIFFTAG_TILEBYTECOUNTS          325     // !byte counts for tiles
#define TIFFTAG_BADFAXLINES             326     // lines w/ wrong pixel count
#define TIFFTAG_CLEANFAXDATA            327     // regenerated line info
#define     CLEANFAXDATA_CLEAN          0       // no errors detected
#define     CLEANFAXDATA_REGENERATED    1       // receiver regenerated lines
#define     CLEANFAXDATA_UNCLEAN        2       // uncorrected errors exist
#define TIFFTAG_CONSECUTIVEBADFAXLINES  328     // max consecutive bad lines
#define TIFFTAG_SUBIFD                  330     // subimage descriptors
#define TIFFTAG_INKSET                  332     // !inks in separated image
#define     INKSET_CMYK                 1       // !cyan-magenta-yellow-black
#define TIFFTAG_INKNAMES                333     // !ascii names of inks
#define TIFFTAG_DOTRANGE                336     // !0% and 100% dot codes
#define TIFFTAG_TARGETPRINTER           337     // !separation target
#define TIFFTAG_EXTRASAMPLES            338     // !info about extra samples
#define     EXTRASAMPLE_UNSPECIFIED     0       // !unspecified data
#define     EXTRASAMPLE_ASSOCALPHA      1       // !associated alpha data
#define     EXTRASAMPLE_UNASSALPHA      2       // !unassociated alpha data
#define TIFFTAG_SAMPLEFORMAT            339     // !data sample format
#define     SAMPLEFORMAT_UINT           1       // !unsigned integer data
#define     SAMPLEFORMAT_INT            2       // !signed integer data
#define     SAMPLEFORMAT_IEEEFP         3       // !IEEE floating point data
#define     SAMPLEFORMAT_VOID           4       // !untyped data
#define TIFFTAG_SMINSAMPLEVALUE         340     // !variable MinSampleValue
#define TIFFTAG_SMAXSAMPLEVALUE         341     // !variable MaxSampleValue
#define TIFFTAG_JPEGTABLES              347     // %JPEG table stream
//
// Tags 512-521 are obsoleted by Technical Note #2
// which specifies a revised JPEG-in-TIFF scheme.
//
#define TIFFTAG_JPEGPROC                512     // !JPEG processing algorithm
#define     JPEGPROC_BASELINE           1       // !baseline sequential
#define     JPEGPROC_LOSSLESS           14      // !Huffman coded lossless
#define TIFFTAG_JPEGIFOFFSET            513     // !pointer to SOI marker
#define TIFFTAG_JPEGIFBYTECOUNT         514     // !JFIF stream length
#define TIFFTAG_JPEGRESTARTINTERVAL     515     // !restart interval length
#define TIFFTAG_JPEGLOSSLESSPREDICTORS  517     // !lossless proc predictor
#define TIFFTAG_JPEGPOINTTRANSFORM      518     // !lossless point transform
#define TIFFTAG_JPEGQTABLES             519     // !Q matrice offsets
#define TIFFTAG_JPEGDCTABLES            520     // !DCT table offsets
#define TIFFTAG_JPEGACTABLES            521     // !AC coefficient offsets
#define TIFFTAG_YCBCRCOEFFICIENTS       529     // !RGB -> YCbCr transform
#define TIFFTAG_YCBCRSUBSAMPLING        530     // !YCbCr subsampling factors
#define TIFFTAG_YCBCRPOSITIONING        531     // !subsample positioning
#define     YCBCRPOSITION_CENTERED      1       // !as in PostScript Level 2
#define     YCBCRPOSITION_COSITED       2       // !as in CCIR 601-1
#define TIFFTAG_REFERENCEBLACKWHITE     532     // !colorimetry info
//
// tags 32952-32956 are private tags registered to Island Graphics
//
#define TIFFTAG_REFPTS                  32953   // image reference points
#define TIFFTAG_REGIONTACKPOINT         32954   // region-xform tack point
#define TIFFTAG_REGIONWARPCORNERS       32955   // warp quadrilateral
#define TIFFTAG_REGIONAFFINE            32956   // affine transformation mat
//
// tags 32995-32999 are private tags registered to SGI
//
#define TIFFTAG_MATTEING                32995   // $use ExtraSamples
#define TIFFTAG_DATATYPE                32996   // $use SampleFormat
#define TIFFTAG_IMAGEDEPTH              32997   // z depth of image
#define TIFFTAG_TILEDEPTH               32998   // z depth/data tile
//
// tags 33300-33309 are private tags registered to Pixar
//
// TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
// are set when an image has been cropped out of a larger image.
// They reflect the size of the original uncropped image.
// The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
// to determine the position of the smaller image in the larger one.
//
#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   // full image size in x
#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   // full image size in y
//
// tag 33432 is listed in the 6.0 spec w/ unknown ownership
//
#define TIFFTAG_COPYRIGHT               33432   // copyright string
//
// tags 34232-34236 are private tags registered to Texas Instruments
//
#define TIFFTAG_FRAMECOUNT              34232   // Sequence Frame Count
//
// tag 34750 is a private tag registered to Pixel Magic
//
#define TIFFTAG_JBIGOPTIONS             34750   // JBIG options
//
// tags 34908-34914 are private tags registered to SGI
//
#define TIFFTAG_FAXRECVPARAMS           34908   // encoded Class 2 ses. parms
#define TIFFTAG_FAXSUBADDRESS           34909   // received SubAddr string
#define TIFFTAG_FAXRECVTIME             34910   // receive time (secs)
//
// tags 40001-40100 are private tags registered to ms
//
#define MS_TIFFTAG_START                40001

#define TIFFTAG_CSID                    40001
#define TIFFTAG_TSID                    40002
#define TIFFTAG_PORT                    40003

#define TIFFTAG_ROUTING                 40004
#define TIFFTAG_CALLERID                40005

#define TIFFTAG_RECIP_NAME              40006
#define TIFFTAG_RECIP_NUMBER            40007
#define TIFFTAG_RECIP_COMPANY           40008
#define TIFFTAG_RECIP_STREET            40009
#define TIFFTAG_RECIP_CITY              40010
#define TIFFTAG_RECIP_STATE             40011
#define TIFFTAG_RECIP_ZIP               40012
#define TIFFTAG_RECIP_COUNTRY           40013
#define TIFFTAG_RECIP_TITLE             40014
#define TIFFTAG_RECIP_DEPARTMENT        40015
#define TIFFTAG_RECIP_OFFICE_LOCATION   40016
#define TIFFTAG_RECIP_HOME_PHONE        40017
#define TIFFTAG_RECIP_OFFICE_PHONE      40018
#define TIFFTAG_RECIP_EMAIL             40020
#define TIFFTAG_SENDER_NAME             40021
#define TIFFTAG_SENDER_NUMBER           40022
#define TIFFTAG_SENDER_COMPANY          40023
#define TIFFTAG_SENDER_STREET           40024
#define TIFFTAG_SENDER_CITY             40025
#define TIFFTAG_SENDER_STATE            40026
#define TIFFTAG_SENDER_ZIP              40027
#define TIFFTAG_SENDER_COUNTRY          40028
#define TIFFTAG_SENDER_TITLE            40029
#define TIFFTAG_SENDER_DEPARTMENT       40030
#define TIFFTAG_SENDER_OFFICE_LOCATION  40031
#define TIFFTAG_SENDER_HOME_PHONE       40032
#define TIFFTAG_SENDER_OFFICE_PHONE     40033
#define TIFFTAG_SENDER_EMAIL            40035
#define TIFFTAG_SENDER_BILLING          40036
#define TIFFTAG_SENDER_USER_NAME        40037
#define TIFFTAG_SENDER_TSID             40038
#define TIFFTAG_DOCUMENT                40039
#define TIFFTAG_SUBJECT                 40040
#define TIFFTAG_RETRIES                 40041
#define TIFFTAG_PRIORITY                40042
#define TIFFTAG_BROADCAST_ID            40043
#define TIFFTAG_FAX_SUBMISSION_TIME     40044
#define TIFFTAG_FAX_SCHEDULED_TIME      40045

#define TIFFTAG_PAGES                   40046
#define TIFFTAG_TYPE                    40047
#define TIFFTAG_STATUS                  40048
#define TIFFTAG_EXTENDED_STATUS         40049
#define TIFFTAG_EXTENDED_STATUS_TEXT    40050
#define TIFFTAG_FAX_START_TIME          40051
#define TIFFTAG_FAX_END_TIME            40052
#define TIFFTAG_FAX_VERSION             40053


#define MS_TIFFTAG_END                  40053

#define MAX_MS_TIFFTAGS                 MS_TIFFTAG_END - MS_TIFFTAG_START +1

//
// TIFF tags defined in W2K fax
//
#define TIFFTAG_W2K_RECIP_NAME          40001
#define TIFFTAG_W2K_RECIP_NUMBER        40002
#define TIFFTAG_W2K_SENDER_NAME         40003
#define TIFFTAG_W2K_ROUTING             40004
#define TIFFTAG_W2K_CALLERID            40005
#define TIFFTAG_W2K_TSID                40006
#define TIFFTAG_W2K_CSID                40007
#define TIFFTAG_W2K_FAX_TIME            40008

//
// The following TIFF tags are used by the Shell group (contact: DavidShi)
// They are added here so we don't collide with their tags in the future
//
#define PropertyTagUnicodeDescription   40091
#define PropertyTagUnicodeComment       40092
#define PropertyTagUnicodeArtist        40093
#define PropertyTagUnicodeKeywords      40094
#define PropertyTagUnicodeSubject       40095


//
// The following are ``pseudo tags'' that can be
// used to control codec-specific functionality.
// These tags are not written to file.  Note that
// these values start at 0xffff+1 so that they'll
// never collide with Aldus-assigned tags.
//
// If you want your private pseudo tags ``registered''
// (i.e. added to this file), send mail to sam@sgi.com
// with the appropriate C definitions to add.
//
#define TIFFTAG_FAXMODE                 65536   // Group 3/4 format control
#define     FAXMODE_CLASSIC     0x0000          // default, include RTC
#define     FAXMODE_NORTC       0x0001          // no RTC at end of data
#define     FAXMODE_NOEOL       0x0002          // no EOL code at end of row
#define     FAXMODE_BYTEALIGN   0x0004          // byte align row
#define     FAXMODE_WORDALIGN   0x0008          // word align row
#define     FAXMODE_CLASSF      FAXMODE_NORTC   // TIFF Class F
#define TIFFTAG_JPEGQUALITY             65537   // Compression quality level
//
// Note: quality level is on the IJG 0-100 scale.  Default value is 75
//
#define TIFFTAG_JPEGCOLORMODE           65538   // Auto RGB<=>YCbCr convert?
#define     JPEGCOLORMODE_RAW   0x0000          // no conversion (default)
#define     JPEGCOLORMODE_RGB   0x0001          // do auto conversion
#define TIFFTAG_JPEGTABLESMODE          65539   // What to put in JPEGTables
#define     JPEGTABLESMODE_QUANT 0x0001         // include quantization tbls
#define     JPEGTABLESMODE_HUFF 0x0002          // include Huffman tbls
//
// Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF
//
#define TIFFTAG_FAXFILLFUNC             65540   // G3/G4 fill function
#define TIFFTAG_PIXARLOGDATAFMT         65549   // PixarLogCodec I/O data sz
#define     PIXARLOGDATAFMT_8BIT        0       // regular u_char samples
#define     PIXARLOGDATAFMT_8BITABGR    1       // ABGR-order u_chars
#define     PIXARLOGDATAFMT_10BITLOG    2       // 10-bit log-encoded (raw)
#define     PIXARLOGDATAFMT_12BITPICIO  3       // as per PICIO (1.0==2048)
#define     PIXARLOGDATAFMT_16BIT       4       // signed short samples
#define     PIXARLOGDATAFMT_FLOAT       5       // IEEE float samples

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\inc\smartptr.h ===
// -*- c++ -*-
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    auto.h

Abstract:

    Smart pointer and auto handle classes

Author:


Revision History:
--*/

#ifndef COMET_SMARTPTR__H
#define COMET_SMARTPTR__H

#ifndef RWSASSERT
#define RWSASSERT(x) ATLASSERT(x)
#endif


//
// Class for automatic handle close.
//
template<int _CHV>
class CAutoCloseHandle_ {
    HANDLE m_h;

    void _Close() { if (m_h != ((HANDLE)(_CHV))) CloseHandle(m_h); }
public:
    CAutoCloseHandle_(HANDLE h =((HANDLE)(_CHV))) { m_h = h; }
    ~CAutoCloseHandle_() { _Close(); }

    CAutoCloseHandle_ & operator =(HANDLE h) {
        _Close();
        m_h = h;
        return *this;
    }

    HANDLE * operator &()  {
        RWSASSERT(m_h == ((HANDLE)(_CHV)));
        return &m_h;
    }

    operator HANDLE() { return m_h; }
    // Set to INVALID_HANDLE_VALUE without closing
    HANDLE Detach()   { HANDLE h = m_h; m_h = ((HANDLE)(_CHV)); return h; }
    void Attach(HANDLE h) { _Close(); m_h = h;                            }
    void Close()      { _Close(); m_h = ((HANDLE)(_CHV));                 }
};

typedef CAutoCloseHandle_<0>  CAutoCloseHandle;
// -1 is INVALID_HANDLE_VALUE, can't use it as template parameter
typedef CAutoCloseHandle_<-1> CAutoCloseFileHandle;

//-----------------------------
//
//  Auto delete pointer
//
template<class T>
class P {
private:
    T* m_p;
    void _Del()             { delete m_p; }

public:
    P() : m_p(0)            {}
    P(T* p) : m_p(p)        {}
   ~P()                     { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    P<T>& operator =(T* p)  { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Auto delete pointer for struct/class
//
template<class T>
class PC {
private:
    T* m_p;
    void _Del()             { delete m_p; }

public:
    PC() : m_p(0)           {}
    PC(T* p) : m_p(p)       {}
   ~PC()                    { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    PC<T>& operator =(T* p) { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Auto delete[] pointer, used for arrays
//
template<class T>
class AP {
private:
    T* m_p;
    void _Del() { delete [] m_p; }
public:
    AP() : m_p(0)           {}
    AP(T* p) : m_p(p)       {}
   ~AP()                    { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    AP<T>& operator =(T* p) { _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};

//-----------------------------
//
//  Auto delete[] pointer, used for arrays of class/struct
//
template<class T>
class APC {
private:
    T* m_p;
    void _Del() { delete [] m_p; }
public:
    APC() : m_p(0)          {}
    APC(T* p) : m_p(p)      {}
   ~APC()                   { _Del(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    APC<T>& operator =(T* p){ _Del(); m_p = p; return *this; }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Del(); m_p = p;                      }
};


//-----------------------------
//
//  Smart pointer that does both addref and relese
//
//  Used when CComPtr cannot be used.
template<class T>
class AR {
private:
    void _Rel()             { if(m_p) m_p->Release(); }
public:
    T* m_p;
    AR() : m_p(0)           {}
    AR(T* p) : m_p(p)       { if (m_p) m_p->AddRef(); }
   ~AR()                    { _Rel(); }

    operator T*()           { return m_p; }
    T** operator &()        { RWSASSERT(!m_p); return &m_p;}
    T* operator ->()        { return m_p; }
    T* operator =(T* p) { _Rel();
                          if(p) p->AddRef();
                          m_p = p;
                          return p; }
    T* operator=(const AR<T>& p) {
        _Rel();
        if(p.m_p) p.m_p->AddRef();
        m_p = p.m_p;
        return p.m_p;
    }
    // Set to NULL without freeing
    T* Detach()             { T* ret = m_p; m_p = NULL; return ret; }
    void Attach(T* p)       { _Rel(); m_p = p;                      }
    HRESULT CopyTo(T** ppT) {
        RWSASSERT(ppT != NULL);
        DBGPRINT(("CopyTo: ppT=%X m_p=%X\n", ppT,m_p));
        if (ppT == NULL) return E_POINTER;
        *ppT = m_p;
        if (m_p) m_p->AddRef();
        return S_OK;
    }
};

#ifdef RWS
//
// Class that automatically closes sockets if not instructed otherwise.
//
class CAutoSocket {
private:
    SOCKET m_Socket;
    void Free()                 { if (m_Socket != INVALID_SOCKET)
                                     closesocket(m_Socket);       }

public:
    CAutoSocket()               { m_Socket = INVALID_SOCKET;      }
    CAutoSocket(SOCKET s)       { m_Socket = s;                   }
    ~CAutoSocket()              { Free();                         }

    operator SOCKET()           { return m_Socket;                }
    CAutoSocket& operator=(SOCKET s) { Free(); m_Socket = s; return *this;}
    SOCKET* operator &()        { return &m_Socket;               }
    SOCKET Detach()             { SOCKET s = m_Socket;
                                  m_Socket = INVALID_SOCKET;
                                  return s;                       }
    void Attach(SOCKET s)       { Free(); m_Socket = s;           }
};
#endif

//
// Class for automatic HKEY close.
//
class CAutoHKEY {
    HKEY m_h;

    void _Close() { if (m_h != NULL) RegCloseKey(m_h); }
public:
    CAutoHKEY(HKEY h = NULL) { m_h = h; }
    ~CAutoHKEY() { _Close(); }

    CAutoHKEY & operator =(HKEY h) {
        _Close();
        m_h = h;
        return *this;
    }

    HKEY * operator &()  {
        RWSASSERT(m_h == NULL);
        return &m_h;
    }

    operator HKEY()         { return m_h; }
    HKEY Detach()           { HKEY hk = m_h; m_h = NULL; return hk; }
    void Attach(HKEY h)     { _Close(); m_h = h;                    }
};

#endif // COMET_SMARTPTR__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\perfmon\faxcount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\perfmon\fxscount.h ===
//
//  faxcount.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//

#define FAXOBJ                           0
#define INBOUND_BYTES                    2
#define INBOUND_FAXES                    4
#define INBOUND_PAGES                    6
#define INBOUND_MINUTES                  8
#define INBOUND_FAILED_RECEIVE          10
#define OUTBOUND_BYTES                  12
#define OUTBOUND_FAXES                  14
#define OUTBOUND_PAGES                  16
#define OUTBOUND_MINUTES                18
#define OUTBOUND_FAILED_CONNECTIONS     20
#define OUTBOUND_FAILED_XMIT            22
#define TOTAL_BYTES                     24
#define TOTAL_FAXES                     26
#define TOTAL_PAGES                     28
#define TOTAL_MINUTES                   30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxmon\faxmon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.c

Abstract:

    Implementation of the following print monitor entry points:
        InitializePrintMonitor
        OpenPort
        ClosePort
        StartDocPort
        EndDocPort
        WritePort
        ReadPort

Environment:

    Windows XP fax print monitor

Revision History:

    05/09/96 -davidx-
        Remove caching of ports from the monitor.

    02/22/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxmon.h"
#include "tiff.h"
#include "faxreg.h"
#include "faxext.h"
#include "faxsvcrg.h"
#include "faxevent.h"
#include "messages.h"

//
// tag mapping structure for getting job parameters out of parameter string.
// see GetTagsFromParam().
//


typedef struct {
    LPTSTR lptstrTagName;
    LPTSTR * lpptstrValue;
    int nLen;
} FAX_TAG_MAP_ENTRY2;

//
// Determine whether we're at the beginning of a TIFF file
//

#define ValidTiffFileHeader(p) \
        (((LPSTR) (p))[0] == 'I' && ((LPSTR) (p))[1] == 'I' && \
         ((PBYTE) (p))[2] == 42  && ((PBYTE) (p))[3] == 0)

//
// Read a DWORD value from an unaligned address
//

#define ReadUnalignedDWord(p) *((DWORD UNALIGNED *) (p))

//
// Write a DWORD value to an unaligned address
//

#define WriteUnalignedDWord(p, value) (*((DWORD UNALIGNED *) (p)) = (value))

//
// Fax monitor name string
//

TCHAR   faxMonitorName[CCHDEVICENAME] = FAX_MONITOR_NAME;   // Name defined in faxreg.h

//
// DLL instance handle
//

HANDLE  ghInstance = NULL;

//
// Retry parameters when failing to connect to the fax service
//  default = infinite retry with 5 seconds interval
//

DWORD   connectRetryCount = 0;
DWORD   connectRetryInterval = 5;


BOOL
WriteToLog(
    IN  DWORD       dwMsgId,
    IN  DWORD       dwError,
    IN  PFAXPORT    pFaxPort,
    IN  JOB_INFO_2  *pJobInfo
    );



BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {

    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}



LPMONITOREX
InitializePrintMonitor(
    LPTSTR  pRegistryRoot
    )

/*++

Routine Description:

    Initialize the print monitor

Arguments:

    pRegistryRoot = Points to a string that specifies the registry root for the monitor

Return Value:

    Pointer to a MONITOREX structure which contains function pointers
    to other print monitor entry points. NULL if there is an error.

--*/

{
    static MONITOREX faxmonFuncs = {

        sizeof(MONITOR),
        {
            FaxMonEnumPorts,
            FaxMonOpenPort,
            NULL,                   // OpenPortEx
            FaxMonStartDocPort,
            FaxMonWritePort,
            FaxMonReadPort,
            FaxMonEndDocPort,
            FaxMonClosePort,
            FaxMonAddPort,
            FaxMonAddPortEx,
            FaxMonConfigurePort,
            FaxMonDeletePort,
            NULL,                   // GetPrinterDataFromPort
            NULL,                   // SetPortTimeOuts
        }
    };

    DEBUG_FUNCTION_NAME(TEXT("InitializePrintMonitor"));



    //
    // Get fax service connection retry parameters from the registry
    //

    if (pRegistryRoot)
    {
        HKEY    hRegKey = NULL;
        LONG    status;

        status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                pRegistryRoot,
                                0,
                                NULL,
                                0,
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &hRegKey,
                                NULL);

        if (status == ERROR_SUCCESS)
        {
            connectRetryCount =
                GetRegistryDWord(hRegKey, REGVAL_CONNECT_RETRY_COUNT, connectRetryCount);

            connectRetryInterval =
                GetRegistryDWord(hRegKey, REGVAL_CONNECT_RETRY_INTERVAL, connectRetryInterval);

            if (hRegKey)
            {
                RegCloseKey(hRegKey);
            }
        }
    }

    return &faxmonFuncs;
}



BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    )

/*++

Routine Description:

    Provides a port for a newly connected printer

Arguments:

    pName - Points to a string that specifies the port name
    pHandle - Returns a handle to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT         pFaxPort     = NULL;
	LPTSTR			 pPortNameDup = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxMonOpenPort"));


    Assert(pHandle != NULL && pPortName != NULL && !lstrcmp(pPortName,FAX_PORT_NAME) );


	// only support one port - It's name must be FAX_PORT_NAME
	if ( lstrcmp(pPortName,FAX_PORT_NAME) )
	{
		*pHandle = NULL;
		return FALSE;
	}

    //
    // Get information about the specified port
    //

    if ((pFaxPort     = MemAllocZ(sizeof(FAXPORT))) &&
        (pPortNameDup = DuplicateString(FAX_PORT_NAME)) )
    {
        pFaxPort->startSig = pFaxPort->endSig = pFaxPort;
        pFaxPort->pName = pPortNameDup;
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
        pFaxPort->hCoverPageFile = INVALID_HANDLE_VALUE;
        pFaxPort->pCoverPageFileName=NULL;
        pFaxPort->bDocumentSentToServer=FALSE;
    } else {

        MemFree(pFaxPort);
        pFaxPort = NULL;
    }

    *pHandle = (HANDLE) pFaxPort;
    return (*pHandle != NULL);
}



VOID
FreeFaxJobInfo(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Free up memory used for maintaining information about the current job

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    NONE

--*/

{


    DEBUG_FUNCTION_NAME(TEXT("FreeFaxJobInfo"));

    //
    // Close and delete the temporary file if necessary
    //

    if (pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pFaxPort->hCoverPageFile);
        pFaxPort->hCoverPageFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->pCoverPageFileName) {

        //If the cover page is a server based cover page it was not generated by the print monitor.
        //No need to delete it.
        //This however is a personal cover page temp file. It was generated by the print monitor and we
        //need to delete it.
        if (!pFaxPort->bDocumentSentToServer) {
            //
            // Do not delete the cover page template file if the send operation succeeded. The server uses it
            // and will delete it itself when it no longer needs it.
            //

            if (!DeleteFile(pFaxPort->pCoverPageFileName)) {
                DebugPrintEx(DEBUG_WRN,TEXT("Failed to delete cover page file: %s  (ec: %ld)"),pFaxPort->pCoverPageFileName,GetLastError());
                Assert(FALSE);
            }
        }
        MemFree(pFaxPort->pCoverPageFileName);
        pFaxPort->pCoverPageFileName = NULL;
    }

    if (pFaxPort->hFile != INVALID_HANDLE_VALUE) {

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    if (pFaxPort->pFilename) {

        if (!DeleteFile(pFaxPort->pFilename)) {
            DebugPrintEx(DEBUG_WRN,TEXT("Failed to delete body file: %s  (ec: %ld)"),pFaxPort->pFilename,GetLastError());
            Assert(FALSE);
        }


        MemFree(pFaxPort->pFilename);
        pFaxPort->pFilename = NULL;
    }

    if (pFaxPort->hPrinter) {

        ClosePrinter(pFaxPort->hPrinter);
        pFaxPort->hPrinter = NULL;
    }

    MemFree(pFaxPort->pPrinterName);
    pFaxPort->pPrinterName = NULL;

    //
    // Note: freeing pFaxPort->pParameters effectively frees the memory pointed by the strings in
    // FAXPORT.JobParamsEx, FAXPORT.CoverPageEx, FAXPORT.SenderProfile and the recipients in
    // FAXPORT.pRecipients
    //

    MemFree(pFaxPort->pParameters);
    pFaxPort->pParameters = NULL;

    ZeroMemory(&pFaxPort->JobParamsEx, sizeof(pFaxPort->JobParamsEx));
    ZeroMemory(&pFaxPort->CoverPageEx, sizeof(pFaxPort->CoverPageEx));
    ZeroMemory(&pFaxPort->SenderProfile, sizeof(pFaxPort->SenderProfile));

    //
    // Free the recipients array
    //
    MemFree(pFaxPort->pRecipients);
    pFaxPort->pRecipients = NULL;

    //
    // Disconnect from the fax service if necessary
    //

    if (pFaxPort->hFaxSvc) {

        if (! pFaxPort->pFaxClose(pFaxPort->hFaxSvc)) {
            DebugPrintEx(DEBUG_ERR,TEXT("FaxClose failed: %d\n"), GetLastError());
        }

        FreeLibrary( pFaxPort->hWinFax );

        pFaxPort->hFaxSvc = NULL;
        pFaxPort->pFaxConnectFaxServerW = NULL;
        pFaxPort->pFaxClose = NULL;
        pFaxPort->pFaxSendDocumentW = NULL;
        pFaxPort->pFaxAccessCheck = NULL;

    }
}



BOOL
FaxMonClosePort(
    HANDLE  hPort
    )

/*++

Routine Description:

    Closes the port specified by hPort when there are no printers connected to it

Arguments:

    hPort - Specifies the handle of the port to be close

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;

    DEBUG_FUNCTION_NAME(TEXT("FaxMonClosePort"));
    DEBUG_TRACE_ENTER;



    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort)) {

        DebugPrintEx(DEBUG_ERR,TEXT("Trying to close an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Free up memory used for maintaining information about the current job
    //

    FreeFaxJobInfo(pFaxPort);

    MemFree(pFaxPort->pName);
    MemFree(pFaxPort);
    return TRUE;
}



LPTSTR
CreateTempFaxFile(
    LPCTSTR lpctstrPrefix
    )

/*++

Routine Description:

    Create a temporary file in the system temp directory. The file name is prefixed
    With the specified prefix.

Arguments:

    lpctstrPrefix - [in] The temporary file prefix (3 characters).

Return Value:

    Pointer to the name of the newly created temporary file
    NULL if there is an error.

    Caller should free the return value.

--*/

{

    LPTSTR  pFilename;
    DWORD   dwRes;
    TCHAR   TempDir[MAX_PATH];

    DEBUG_FUNCTION_NAME(TEXT("CreateTempFaxFile"));
    //
    // Allocate a memory buffer for holding the temporary filename
    //
    pFilename = MemAlloc(sizeof(TCHAR) * MAX_PATH);
    if (!pFilename)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate %ld bytes"),
                     sizeof(TCHAR) * MAX_PATH);
        return NULL;
    }
    dwRes = GetTempPath(sizeof(TempDir)/sizeof(TCHAR),TempDir);
    if (!dwRes || dwRes > sizeof(TempDir)/sizeof(TCHAR))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetTempPath failed with %ld"),
                     GetLastError ());
        MemFree(pFilename);
        return NULL;
    }

    if (!GetTempFileName(TempDir, lpctstrPrefix, 0, pFilename))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetTempFileName failed with %ld"),
                     GetLastError ());
        MemFree(pFilename);
        return NULL;
    }
    return pFilename;
}   // CreateTempFaxFile



BOOL OpenCoverPageFile(PFAXPORT pFaxPort)
{

    DEBUG_FUNCTION_NAME(TEXT("OpenCoverPageFile"));
    //
    //Generate a unique file name for the cover page temp file in the TEMP directory
    //
    pFaxPort->pCoverPageFileName=CreateTempFaxFile(FAX_COVER_PAGE_EXT_LETTERS);
    if (!pFaxPort->pCoverPageFileName) {
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to generate temporary file for cover page template (ec: %d).\n"),GetLastError());
        return FALSE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Cover page temportary file: %ws\n"), pFaxPort->pCoverPageFileName);

    //
    // Open the file for reading and writing
    //

    pFaxPort->hCoverPageFile = CreateFile(pFaxPort->pCoverPageFileName,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);
    if (INVALID_HANDLE_VALUE == pFaxPort->hCoverPageFile) {
            DebugPrintEx(DEBUG_ERR,TEXT("Failed to open for WRITE temporary file for cover page template (ec: %d).\n"),GetLastError());
            Assert(FALSE);
    }


    return (pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE);

}



BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    )

/*++

Routine Description:

    Open a handle to the current fax job file associated with a port

Arguments:

    pFaxPort - Points to a fax port structure
    doAppend - Specifies whether to discard existing data in the file or
        append new data to it

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   creationFlags;

    DEBUG_FUNCTION_NAME(TEXT("OpenTempFaxFile"));

    Assert(pFaxPort->pFilename && pFaxPort->hFile == INVALID_HANDLE_VALUE);
    DebugPrintEx(DEBUG_MSG,TEXT("Temporary fax job file: %ws\n"), pFaxPort->pFilename);

    //
    // Open the file for reading and writing
    //

    creationFlags = doAppend ? OPEN_ALWAYS : (OPEN_ALWAYS | TRUNCATE_EXISTING);

    pFaxPort->hFile = CreateFile(pFaxPort->pFilename,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 NULL,
                                 creationFlags,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    //
    // If we're appending, then move the file pointer to end of file
    //

    if (doAppend && pFaxPort->hFile != INVALID_HANDLE_VALUE &&
        SetFilePointer(pFaxPort->hFile, 0, NULL, FILE_END) == 0xffffffff)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("SetFilePointer failed: %d\n"), GetLastError());

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    return (pFaxPort->hFile != INVALID_HANDLE_VALUE);
}



LPCTSTR
ExtractFaxTag(
    LPCTSTR      pTagKeyword,
    LPCTSTR      pTaggedStr,
    INT        *pcch
    )

/*++

Routine Description:

    Find the value of for the specified tag in a tagged string.

Arguments:

    pTagKeyword - specifies the interested tag keyword
    pTaggedStr - points to the tagged string to be searched
    pcch - returns the length of the specified tag value (if found)

Return Value:

    Points to the value for the specified tag.
    NULL if the specified tag is not found

NOTE:

    Tagged strings have the following form:
        <tag>value<tag>value

    The format of tags is defined as:
        <$FAXTAG$ tag-name>

    There is exactly one space between the tag keyword and the tag name.
    Characters in a tag are case-sensitive.

--*/

{
    LPCTSTR  pValue;

    if (pValue = _tcsstr(pTaggedStr, pTagKeyword)) {

        pValue += _tcslen(pTagKeyword);

        if (pTaggedStr = _tcsstr(pValue, FAXTAG_PREFIX))
            *pcch = (INT)(pTaggedStr - pValue);
        else
            *pcch = _tcslen(pValue);
    }

    return pValue;
}




//*********************************************************************************
//* Name:   GetTagsFromParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Given a tagged parameter string this function populates a FAX_TAG_MAP_ENTRY2
//*     array with pointers to each of the tag values and the length of each tag
//*     value (for those tages specified in the tag map array).
//* PARAMETERS:
//*     lpctstrParams
//*         A pointer to the string containin the tagged parameters.
//*     lpcTags
//*         A pointer to a FAX_TAG_MAP_ENTRY2 array. For each element in the array
//*         FAX_TAG_MAP_ENTRY2.lptstrTagName must point to the name of the tag to
//*         look for.
//*         FAX_TAG_MAP_ENTRY2.lpptstrValue will be set to a pointer to the first
//*         char of the value string or NULL if the tag is not found.
//*         If the tage is found FAX_TAG_MAP_ENTRY2.nLen will be set to the its
//*         string value length. Otherwise its value is not defined.
//*
//*     int nTagCount
//*         The number of tages in the tag map array.
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     The function does not allocate any memory !!!
//*     It returns pointers to substrings in the provided tagged paramter string.
//*********************************************************************************
void
GetTagsFromParam(
    LPCTSTR lpctstrParams,
    FAX_TAG_MAP_ENTRY2 * lpcTags,
    int nTagCount)
{
    //
    // Note: GetTagsFromParam DOES NOT ALLOCATE any memory for the returned tag values.
    //       It returns pointers to location within the parameter string.
    //       Thus, freeing the parameter string (deallocated when the port is closed)
    //       is enough. DO NOT attempt to free the memory for each tag.
    //
    int nTag;
    //
    // Extract individual fields out of the tagged string
    //
    for (nTag=0; nTag < nTagCount; nTag++)
    {
      *(lpcTags[nTag].lpptstrValue) = (LPTSTR)ExtractFaxTag(lpcTags[nTag].lptstrTagName,
                                         lpctstrParams,
                                         &(lpcTags[nTag].nLen));
    }
    //
    // Null-terminate each field
    //
    for (nTag=0; nTag < nTagCount; nTag++)
    {
        if (*(lpcTags[nTag].lpptstrValue))
        {
            (*(lpcTags[nTag].lpptstrValue))[lpcTags[nTag].nLen] = NUL;
        }
    }
}




//*********************************************************************************
//* Name:   SetRecipientFromTaggedParams()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Populates a recipient FAX_PERSONAL_PROFILE with pointers to relevant
//*     information in in the provided tagged parameter string.
//* PARAMETERS:
//*     pParamStr
//*
//*     PFAX_PERSONAL_PROFILE lpProfile
//*
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     This function does not allocate memory !!!
//*     The returned pointers are pointed to locations within the provided
//*     pParamStr string.
//*********************************************************************************
VOID SetRecipientFromTaggedParams(
    LPCTSTR pParamStr,
    PFAX_PERSONAL_PROFILE lpProfile)
{
    FAX_TAG_MAP_ENTRY2 tagMap[] =
    {
        { FAXTAG_RECIPIENT_NAME,            (LPTSTR *)&lpProfile->lptstrName},
        { FAXTAG_RECIPIENT_NUMBER,          (LPTSTR *)&lpProfile->lptstrFaxNumber },
        { FAXTAG_RECIPIENT_COMPANY,         (LPTSTR *)&lpProfile->lptstrCompany },
        { FAXTAG_RECIPIENT_STREET,          (LPTSTR *)&lpProfile->lptstrStreetAddress },
        { FAXTAG_RECIPIENT_CITY,            (LPTSTR *)&lpProfile->lptstrCity },
        { FAXTAG_RECIPIENT_STATE,           (LPTSTR *)&lpProfile->lptstrState },
        { FAXTAG_RECIPIENT_ZIP,             (LPTSTR *)&lpProfile->lptstrZip },
        { FAXTAG_RECIPIENT_COUNTRY,         (LPTSTR *)&lpProfile->lptstrCountry },
        { FAXTAG_RECIPIENT_TITLE,           (LPTSTR *)&lpProfile->lptstrTitle },
        { FAXTAG_RECIPIENT_DEPT,            (LPTSTR *)&lpProfile->lptstrDepartment },
        { FAXTAG_RECIPIENT_OFFICE_LOCATION, (LPTSTR *)&lpProfile->lptstrOfficeLocation },
        { FAXTAG_RECIPIENT_HOME_PHONE,      (LPTSTR *)&lpProfile->lptstrHomePhone },
        { FAXTAG_RECIPIENT_OFFICE_PHONE,    (LPTSTR *)&lpProfile->lptstrOfficePhone },
    };

    ZeroMemory(lpProfile, sizeof(FAX_PERSONAL_PROFILE));
    lpProfile->dwSizeOfStruct = sizeof( FAX_PERSONAL_PROFILE);
    GetTagsFromParam(pParamStr,tagMap,sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY2));
}


//*********************************************************************************
//* Name:   SetJobInfoFromTaggedParams()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Popultaes pFaxPort->JobParamsEx, CoverPageEx , SenderProfile and
//*     nRecipientCount using the provided tagged parameter string.
//*     The string must be NULL terminated.
//* PARAMETERS:
//*     LPCTSTR pParamStr [IN\OUT]
//*
//*     PFAXPORT pFaxPort [OUT]
//*
//* RETURN VALUE:
//*     NONE
//* NOTE:
//*     The string pointers put into the populated pFaxPort structures are pointers
//*     into the provided pParamStr string. No memory is allocated by this
//*     function !!!
//*********************************************************************************
void SetJobInfoFromTaggedParams(
    LPCTSTR pParamStr,
    PFAXPORT pFaxPort)
{

    LPTSTR lptstrServerCoverPage;
    LPTSTR WhenToSend = NULL;
    LPTSTR SendAtTime = NULL;
    LPTSTR lptstrPageCount=NULL; //temp for holding the page count string;
    LPTSTR lptstrRecipientCount=NULL;
    LPTSTR lptstrReceiptFlags = NULL;
    LPTSTR lptstrPriority = NULL;

    FAX_TAG_MAP_ENTRY2 tagMap[] =
    {
        { FAXTAG_SENDER_NAME,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrName},
        { FAXTAG_SENDER_NUMBER,             (LPTSTR *)&pFaxPort->SenderProfile.lptstrFaxNumber },
        { FAXTAG_SENDER_COMPANY,            (LPTSTR *)&pFaxPort->SenderProfile.lptstrCompany },
        { FAXTAG_SENDER_TITLE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrTitle },
        { FAXTAG_SENDER_DEPT,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrDepartment },
        { FAXTAG_SENDER_OFFICE_LOCATION,    (LPTSTR *)&pFaxPort->SenderProfile.lptstrOfficeLocation },
        { FAXTAG_SENDER_HOME_PHONE,         (LPTSTR *)&pFaxPort->SenderProfile.lptstrHomePhone },
        { FAXTAG_SENDER_OFFICE_PHONE,       (LPTSTR *)&pFaxPort->SenderProfile.lptstrOfficePhone },
        { FAXTAG_SENDER_STREET,             (LPTSTR *)&pFaxPort->SenderProfile.lptstrStreetAddress },
        { FAXTAG_SENDER_CITY,               (LPTSTR *)&pFaxPort->SenderProfile.lptstrCity },
        { FAXTAG_SENDER_STATE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrState },
        { FAXTAG_SENDER_ZIP,                (LPTSTR *)&pFaxPort->SenderProfile.lptstrZip },
        { FAXTAG_SENDER_COUNTRY,            (LPTSTR *)&pFaxPort->SenderProfile.lptstrCountry },
        { FAXTAG_SENDER_EMAIL,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrEmail },
        { FAXTAG_TSID,                      (LPTSTR *)&pFaxPort->SenderProfile.lptstrTSID },
        { FAXTAG_BILLING_CODE,              (LPTSTR *)&pFaxPort->SenderProfile.lptstrBillingCode},
        { FAXTAG_COVERPAGE_NAME,            (LPTSTR *)&pFaxPort->CoverPageEx.lptstrCoverPageFileName },
        { FAXTAG_SERVER_COVERPAGE,          (LPTSTR *)&lptstrServerCoverPage },
        { FAXTAG_NOTE,                      (LPTSTR *)&pFaxPort->CoverPageEx.lptstrNote },
        { FAXTAG_SUBJECT,                   (LPTSTR *)&pFaxPort->CoverPageEx.lptstrSubject},
        { FAXTAG_WHEN_TO_SEND,              (LPTSTR *)&WhenToSend },
        { FAXTAG_SEND_AT_TIME,              (LPTSTR *)&SendAtTime },
        { FAXTAG_PAGE_COUNT,                (LPTSTR *)&lptstrPageCount },
        { FAXTAG_RECEIPT_TYPE,              (LPTSTR *)&lptstrReceiptFlags},
        { FAXTAG_RECEIPT_ADDR,              (LPTSTR *)&pFaxPort->JobParamsEx.lptstrReceiptDeliveryAddress},
        { FAXTAG_PRIORITY,                  (LPTSTR *)&lptstrPriority},
        { FAXTAG_RECIPIENT_COUNT,           (LPTSTR *)&lptstrRecipientCount}
    };


    ZeroMemory(&pFaxPort->SenderProfile, sizeof(FAX_PERSONAL_PROFILE));
    pFaxPort->SenderProfile.dwSizeOfStruct = sizeof( FAX_PERSONAL_PROFILE);

    ZeroMemory(&pFaxPort->CoverPageEx, sizeof(FAX_COVERPAGE_INFO_EXW));
    pFaxPort->CoverPageEx.dwSizeOfStruct = sizeof( FAX_COVERPAGE_INFO_EXW);

    ZeroMemory(&pFaxPort->JobParamsEx, sizeof(FAX_JOB_PARAM_EXW));
    pFaxPort->JobParamsEx.dwSizeOfStruct = sizeof( FAX_JOB_PARAM_EXW);
    //
    // Note: GetTagsFromParam DOES NOT ALLOCATE any memory for the returned tag values.
    //       It returns pointers to location within the parameter string.
    //       Thus, freeing the parameter string (deallocated when the port is closed)
    //       is enough. DO NOT attempt to free the memory for each tag.
    //

    GetTagsFromParam(pParamStr,tagMap,sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY2));


    if (lptstrServerCoverPage) {
        pFaxPort->CoverPageEx.bServerBased=TRUE;
    } else {
        pFaxPort->CoverPageEx.bServerBased=FALSE;
    }
    pFaxPort->CoverPageEx.dwCoverPageFormat=FAX_COVERPAGE_FMT_COV;

    if (WhenToSend) {
        if (_tcsicmp( WhenToSend, TEXT("cheap") ) == 0) {
            pFaxPort->JobParamsEx.dwScheduleAction = JSA_DISCOUNT_PERIOD;
        } else if (_tcsicmp( WhenToSend, TEXT("at") ) == 0) {
            pFaxPort->JobParamsEx.dwScheduleAction = JSA_SPECIFIC_TIME;
        }
    }

    if (SendAtTime) {
        if (_tcslen(SendAtTime) == 5 && SendAtTime[2] == L':' &&
            _istdigit(SendAtTime[0]) && _istdigit(SendAtTime[1]) &&
            _istdigit(SendAtTime[3]) && _istdigit(SendAtTime[4]))
        {
            DWORDLONG FileTime;
            SYSTEMTIME LocalTime;
            INT Minutes;
            INT SendMinutes;

            SendAtTime[2] = 0;

            //
            // Calculate the number of minutes from now to send and add that to the current time.
            //

            GetLocalTime( &LocalTime );
            SystemTimeToFileTime( &LocalTime, (LPFILETIME) &FileTime );

            SendMinutes = min(23,_ttoi( &SendAtTime[0] )) * 60 + min(59,_ttoi( &SendAtTime[3] ));

            Minutes = LocalTime.wHour * 60 + LocalTime.wMinute;

            Minutes = SendMinutes - Minutes;


            // Account for passing midnight
            //
            if (Minutes < 0) {
                Minutes += 24 * 60;
            }

            FileTime += (DWORDLONG)(Minutes * 60I64 * 1000I64 * 1000I64 * 10I64);

            FileTimeToSystemTime((LPFILETIME) &FileTime, &pFaxPort->JobParamsEx.tmSchedule );

        }
    }

    // setting PageCount=0 means the server will count the number of pages in the job
    pFaxPort->JobParamsEx.dwPageCount = 0;
    pFaxPort->nRecipientCount =_ttoi(lptstrRecipientCount);
    pFaxPort->JobParamsEx.Priority = _ttoi(lptstrPriority);
    pFaxPort->JobParamsEx.dwReceiptDeliveryType = _ttoi(lptstrReceiptFlags);
}



//*********************************************************************************
//* Name:   GetJobInfo()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Popultes the sender information , cover page information ,job parameters
//*     information and recipients information in the pointed FAXPORT structure.
//*     The information is retrieved from pFaxPort->pParameters tagged parameter string.
//* PARAMETERS:
//*     pFaxPort [OUT]
//*
//*     jobId    [IN]
//*
//* RETURN VALUE:
//*
//* Notes:
//* the format of the tagged parameter string is:
//* The string is partitioned to "records" each record starts with the <$FAXTAG NEWREC>
//* tag with a dummy value of "1" (exactly one character).
//* The first record contains all the information which is not recipient related
//* (cover page, sender info, etc.) and also contains the number of recipients in
//* the transmission.
//* This record is followed by a number of records which is equal to the number
//* of specified recipients. Rach of these records contains recipient information
//* which is equivalent to the content of FAX_PERSONAL_PROFILE.
//*********************************************************************************
BOOL
GetJobInfo(
    PFAXPORT    pFaxPort,
    DWORD       jobId

    )
{
    JOB_INFO_2 *pJobInfo2 = NULL;
    LPTSTR      pParameters = NULL;
    LPTSTR       lptstrCurRecipient = NULL;
    LPTSTR       lptstrNextRecipient = NULL;
    UINT nRecp;

    DEBUG_FUNCTION_NAME(TEXT("GetJobInfo"));

    pJobInfo2 = MyGetJob(pFaxPort->hPrinter, 2, jobId);

    if (!pJobInfo2) { // pJobInfo2 is allocated here
        DebugPrintEx(DEBUG_ERR,TEXT("Failed to get job information for print job: %ld"),jobId);
        goto Error;
    }

    if (!pJobInfo2->pParameters) {
        DebugPrintEx(DEBUG_ERR,TEXT("Print job %ld has NULL tagged parameter string. No op."),jobId);
        goto Error;
    }

    if ((pFaxPort->pParameters = DuplicateString(pJobInfo2->pParameters)) == NULL)
    {
        DebugPrintEx(DEBUG_ERR, _T("DuplicateString(pJobInfo2->pParameters) failed"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    pParameters = pFaxPort->pParameters;

    //
    // Find the first recipient new record tag and place a NULL at its start.
    // This makes the first record into a NULL terminated string and
    // allows us to use _tcsstr (used by ExtractTag) to locate tags in the first record.

    lptstrCurRecipient=_tcsstr(pParameters+1,FAXTAG_NEW_RECORD);
    if (lptstrCurRecipient) {
        *lptstrCurRecipient=TEXT('\0');
        //
        // move past the <$FAXTAG NEWREC> dummy value so we point to the start of
        // the recipient info.
        lptstrCurRecipient=lptstrCurRecipient+_tcslen(FAXTAG_NEW_RECORD)+1;
    } else {
        //
        // Bad job info  e.g. LPR/LPD job
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Bad job info, No recipients - pFaxPort->pParameters is %s"),
                     pFaxPort->pParameters);
        goto Error;
    }
    //
    // Populate all but the recipient information from the tagged parameter string (1st record)
    //
    SetJobInfoFromTaggedParams(pParameters,pFaxPort);

    //
    // Allocate the recipient list (Note that only after calling SetJobInfoFromTaggedParams()
    // we know how many recipients there are).
    //

    pFaxPort->pRecipients=MemAlloc(sizeof(FAX_PERSONAL_PROFILE)*pFaxPort->nRecipientCount);
    if (!pFaxPort->pRecipients) {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("Failed to allocate %ld bytes for recipient array.(ec: 0x%0X)"),
                        sizeof(FAX_PERSONAL_PROFILE)*pFaxPort->nRecipientCount,
                        GetLastError());
        goto Error;
    }

    //
    // Go over the recipients array and populate each recipient from the parameter string.
    //
    for (nRecp=0;nRecp<pFaxPort->nRecipientCount;nRecp++) {
        //
        // At each stage we must first turn the string into null terminated string
        // by locating the next new record tag and replacing its first char with NULL.
        // This allows us to use ExtractTag on the current recipient record alone (without
        // crossing over into the content of the next recipient record).
        // lptstrCurRecipient allways points to the first char past the new record tag and
        // dummy value.
        //
        lptstrNextRecipient=_tcsstr(lptstrCurRecipient,FAXTAG_NEW_RECORD);
        if (lptstrNextRecipient) {
            *lptstrNextRecipient=TEXT('\0');
            //
            // Before being assigned into lptstrCurRecipient we make sure lptstrNextRecipient
            // points to the data following the next recipient new record tag and dummy value.
            //
            lptstrNextRecipient=lptstrNextRecipient+_tcslen(FAXTAG_NEW_RECORD);
        } else {
            Assert(nRecp == (pFaxPort->nRecipientCount-1)); //only the last recipient does not have a following recipient
        }

        SetRecipientFromTaggedParams( lptstrCurRecipient,&pFaxPort->pRecipients[nRecp]);

        //
        // Move to the next record in the parameter string
        //
        lptstrCurRecipient=lptstrNextRecipient;
    }

    MemFree(pJobInfo2);
    return TRUE;

Error:
    MemFree(pJobInfo2);
    return FALSE;
}



BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    )

/*++

Routine Description:

    Spooler calls this function to start a new print job on the port

Arguments:

    hPort - Identifies the port
    pPrinterName - Specifies the name of the printer to which the job is being sent
    JobId - Identifies the job being sent by the spooler
    Level - Specifies the DOC_INFO_x level
    pDocInfo - Points to the document information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_3  *pJobInfo;
    PFAXPORT                pFaxPort = (PFAXPORT) hPort;



    DEBUG_FUNCTION_NAME(TEXT("FaxMonStartDocPort"));

    DebugPrintEx(DEBUG_MSG,TEXT("Entering StartDocPort: %d ...\n"), JobId);

    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort)) {

        DebugPrintEx(DEBUG_ERR,TEXT("StartDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Check if we're at the beginning of a series of chained jobs
    //

    pFaxPort->bCoverPageJob=FALSE;
    if (INVALID_HANDLE_VALUE != pFaxPort->hCoverPageFile)
    {
        //Cover page file exists.
        //We already written to it (since this startdoc event is for the body of the fax)
        //so lets close the file.
        CloseHandle(pFaxPort->hCoverPageFile);
        pFaxPort->hCoverPageFile=INVALID_HANDLE_VALUE;
    }


    if (! pFaxPort->hFaxSvc) {
        //
        // If we are not connected to the fax server yet.
        // This means that this is the FIRST job we handle since the port was last opened.
        // (This means it is the cover page job).

        PJOB_INFO_1 pJobInfo1;
        PORT_INFO_3 portInfo3;
        HANDLE      hPrinter = NULL;
        BOOL        offline = FALSE;
        DWORD       count = connectRetryCount;
        DWORD       jobStatus = 0;
        DWORD       dwErr = ERROR_SUCCESS;

        Assert(pFaxPort->pPrinterName == NULL &&
               pFaxPort->hPrinter == NULL &&
               pFaxPort->pParameters == NULL &&
               pFaxPort->pFilename == NULL &&
               pFaxPort->hFile == INVALID_HANDLE_VALUE);

        //
        // load the winfax dll
        //

        pFaxPort->hWinFax = LoadLibrary( FAX_API_MODULE_NAME);
        if (pFaxPort->hWinFax == NULL) {
            DebugPrintEx(DEBUG_ERR,TEXT("LoadLibrary failed loading winfax.dll\n"));
            return FALSE;
        }

        //
        // get the function addresses
        //

        pFaxPort->pFaxConnectFaxServerW = (PFAXCONNECTFAXSERVERW) GetProcAddress( pFaxPort->hWinFax, "FaxConnectFaxServerW" );
        pFaxPort->pFaxClose = (PFAXCLOSE) GetProcAddress( pFaxPort->hWinFax, "FaxClose" );
        pFaxPort->pFaxSendDocumentW = (PFAXSENDDOCUMENTW) GetProcAddress( pFaxPort->hWinFax, "FaxSendDocumentW" );
        pFaxPort->pFaxAccessCheck = (PFAXACCESSCHECK) GetProcAddress( pFaxPort->hWinFax, "FaxAccessCheck" );
        pFaxPort->pFaxSendDocumentExW = (PFAXSENDDOCUMENTEXW) GetProcAddress( pFaxPort->hWinFax, "FaxSendDocumentExW" );

        if (pFaxPort->pFaxSendDocumentExW == NULL ||
            pFaxPort->pFaxConnectFaxServerW == NULL ||
            pFaxPort->pFaxClose == NULL ||
            pFaxPort->pFaxSendDocumentW == NULL ||
            pFaxPort->pFaxAccessCheck == NULL) {
            DebugPrintEx(DEBUG_ERR,TEXT("GetProcAddress failed loading winfax.dll\n"));
            return FALSE;
        }

        //
        // Connect to the fax service and obtain a session handle
        //

        while (! pFaxPort->pFaxConnectFaxServerW(NULL, &pFaxPort->hFaxSvc)) {

            dwErr = GetLastError();

            DebugPrintEx(DEBUG_ERR, _T("FaxConnectFaxServer failed: %d\n"), dwErr);
            pFaxPort->hFaxSvc = NULL;

            if (! offline) {

                portInfo3.dwStatus = PORT_STATUS_OFFLINE;
                portInfo3.pszStatus = NULL;
                portInfo3.dwSeverity = PORT_STATUS_TYPE_WARNING;

                if (! SetPort(NULL, pFaxPort->pName, 3, (LPBYTE) &portInfo3))
                    DebugPrintEx(DEBUG_ERR,TEXT("SetPort failed: %d\n"), GetLastError());
            }

            offline = TRUE;
            Sleep(connectRetryInterval * 1000);

            //
            // Check if the job has been deleted or restarted
            //

            if (!hPrinter && !OpenPrinter(pPrinterName, &hPrinter, NULL)) {

                DebugPrintEx(DEBUG_ERR,TEXT("OpenPrinter failed: %d\n"), GetLastError());
                hPrinter = NULL;

            } else if (pJobInfo1 = MyGetJob(hPrinter, 1, JobId)) {

                jobStatus = pJobInfo1->Status;

            }

            MemFree(pJobInfo1);

            if (count-- == 0 || (jobStatus & (JOB_STATUS_DELETING|
                                              JOB_STATUS_DELETED|
                                              JOB_STATUS_RESTART)))
            {
                break;
            }
        }

        //
        // Remove the offline status on the port
        //

        if (offline) {

            portInfo3.dwStatus = 0;
            portInfo3.pszStatus = NULL;
            portInfo3.dwSeverity = PORT_STATUS_TYPE_INFO;

            if (! SetPort(NULL, pFaxPort->pName, 3, (LPBYTE) &portInfo3)) {
                DebugPrintEx(DEBUG_ERR,TEXT("SetPort failed: %d\n"), GetLastError());
            }
        }

        if (hPrinter) {
            ClosePrinter(hPrinter);
        }

        if (pFaxPort->hFaxSvc)
        {
            //
            // Remember the printer name because we'll need it at EndDocPort time.
            //
            pFaxPort->pPrinterName = DuplicateString(pPrinterName);
            if (!pFaxPort->pPrinterName)
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to duplicate printer name (ec: %d)"),GetLastError());
                goto Error;
            }

            if (!OpenPrinter(pPrinterName, &pFaxPort->hPrinter, NULL))
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to open printer %s (ec: %d)"),pPrinterName,GetLastError());
                goto Error;
            }

            //
            //  All Jobs are chained, with first job being Cover Page and
            //      second one being the Body.
            //
            //  The only case where only one Job is arrived, is when the Job
            //      is created by FaxStartPrintJob(). In this case, the Job
            //      contains both the Cover Page Info and the Body together.
            //
            //  To check whether the Job is chained or not, MyGetJob() is called.
            //
            //  If NextJob is NOT zero ==> there is chained job ==>
            //      ==> so the current job is the Cover Page job.
            //
            if (pJobInfo = MyGetJob(pFaxPort->hPrinter, 3, JobId))
            {
                pFaxPort->bCoverPageJob = (pJobInfo->NextJobId != 0);
                MemFree(pJobInfo);
            }
            else
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("MyGetJob() for JobId = %ld failed, ec = %ld"),
                    JobId,
                    GetLastError());
                if (!SetJob(pFaxPort->hPrinter, JobId, 0, NULL, JOB_CONTROL_DELETE))
                {
                    DebugPrintEx(DEBUG_ERR, _T("Failed to delete job with id: %d"), JobId);
                }
                goto Error;
            }

            //
            // Get the job parameters from the string in JOB_INFO_2:pParameters.
            //
            if (!GetJobInfo(pFaxPort, JobId))
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to get job info for job id : %d"),JobId);
                if (!SetJob(pFaxPort->hPrinter, JobId, 0, NULL, JOB_CONTROL_DELETE))
                {
                    DebugPrintEx(DEBUG_ERR,TEXT("Failed to delete job with id: %d"),JobId);
                }
                goto Error;
            }
            //
            // CreateTempFaxFile() creates a temporray files into which the fax body
            // data written by FaxMonWritePort() will be saved.
            //
            if (!(pFaxPort->pFilename = CreateTempFaxFile(TEXT("fax"))))
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to Create temp file for fax body. (ec: %d)"),GetLastError());
                goto Error;
            }
            //
            // Open the temporary file we just created for write operation.
            //
            if (!OpenTempFaxFile(pFaxPort, FALSE))
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to Open temp file for fax body. (ec: %d)"),GetLastError());
                goto Error;
            }

            if (pFaxPort->CoverPageEx.lptstrCoverPageFileName && !pFaxPort->CoverPageEx.bServerBased) {
                //
                // A cover page is specified and it is a personal cover page.
                // The cover page (template) is in the chained print job.
                // We create a file to which the cover page will be written (by FaxMonWriteDocPort).
                //
                DebugPrintEx(DEBUG_MSG,TEXT("Personal cover page detected."));
                if (!OpenCoverPageFile(pFaxPort))
                {
                    DebugPrintEx(DEBUG_ERR,TEXT("Failed to open temp file for fax cover page. (ec: %d)"),GetLastError());
                    goto Error;
                }
            }
            else
            {
                //
                // The specified cover page is a server based cover page or no cover page is specified.
                // In both cases there is no cover page data in the print job body so we do not create
                // the file to hold it.
                //
                DebugPrintEx(DEBUG_MSG,TEXT("Server cover page detected or no cover page specified."));
                pFaxPort->hCoverPageFile=INVALID_HANDLE_VALUE;
            }

            //
            // If we got here there were no errors. Keep the job id.
            //
            pFaxPort->jobId = JobId;

            //
            // Switch back to the original context if necessary
            //
            /*
            if (hToken && !ImpersonatePrinterClient(hToken))
                Error(("ImpersonatePrinterClient failed: %d\n", GetLastError()));
            */
        }
        else
        {
            //
            //  pFaxPort->hFaxSvc == NULL
            //      i.e. FaxConnectFaxServer failed
            //
            //  So, we need to Write to Fax Log
            //

            JOB_INFO_2  *pJobInfo2 = NULL;

            if (!OpenPrinter(pPrinterName, &pFaxPort->hPrinter, NULL))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("Failed to open printer %s (ec: %d)"),
                    pPrinterName,
                    GetLastError());
                goto Error;
            }

            if (!GetJobInfo(pFaxPort, JobId))
            {
                DebugPrintEx(DEBUG_ERR,TEXT("Failed to get job info for job id : %d"),JobId);
                if (!SetJob(pFaxPort->hPrinter, JobId, 0, NULL, JOB_CONTROL_DELETE))
                {
                    DebugPrintEx(DEBUG_ERR, _T("Failed to delete job with id: %d"),JobId);
                }
                goto Error;
            }

            pJobInfo2 = MyGetJob( pFaxPort->hPrinter, 2, JobId );
            if (pJobInfo2)
            {
                WriteToLog(MSG_FAX_MON_CONNECT_FAILED, dwErr, pFaxPort, pJobInfo2);
                MemFree(pJobInfo2);
            }
            else
            {
                DebugPrintEx(DEBUG_WRN, _T("MyGetJob failed for JobId: %d."), pFaxPort->jobId);
            }

            //
            //  Clear the data for next StartDoc
            //
            FreeFaxJobInfo(pFaxPort);
        }

    } else {
        //
        // If pFaxPort->hFaxSvc is not NULL then we are in the job following the cover page print job.
        // FaxMonEndDocPort() that was called after the cover page print job updated pFaxPort->NextJobId
        // to the next job id in the chain. Thus, the job id we got as a parameter must be
        // the same is pFaxPort->JobId.
        //
        Assert(pFaxPort->jobId == JobId);
    }

    goto Exit;


Error:
    FreeFaxJobInfo(pFaxPort);

Exit:
    return (pFaxPort->hFaxSvc != NULL);
}



INT
FixUpFaxFile(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Fixed up the saved print job data into a well-formed TIFF file

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    error code FAXERR_*

--*/

{
    DWORD   fileSize;
    PBYTE   pFileEnd, pFileHdr;
    PBYTE   pFileView = NULL;
    HANDLE  hFileMap = NULL;
    INT     result = FAXERR_BAD_TIFF;


    DEBUG_FUNCTION_NAME(TEXT("FixUpFile"));
    //
    // Get the size of print job file
    //

    FlushFileBuffers(pFaxPort->hFile);

    if ((fileSize = GetFileSize(pFaxPort->hFile, NULL)) == 0)
        return FAXERR_IGNORE;

    if (fileSize == 0xffffffff)
        return FAXERR_FATAL;

    __try {

        //
        // Map the fax job file into memory
        //

        if ((hFileMap = CreateFileMapping(pFaxPort->hFile, NULL, PAGE_READWRITE, 0, 0, NULL)) &&
            (pFileHdr = pFileView = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, fileSize)) &&
            ValidTiffFileHeader(pFileHdr))
        {
            DWORD   ifdOffset, maxOffset, fileOffset;
            PBYTE   pIfdOffset;

            //
            // A fax print job may contain multiple TIFF files. Each each iteration
            // of the outer loop below deals with a single embedded TIFF file.
            //

            pFileEnd = pFileHdr + fileSize;
            ifdOffset = ReadUnalignedDWord(pFileHdr + sizeof(DWORD));

            do {

                DebugPrintEx(DEBUG_MSG,TEXT("Reading embedded TIFF file ...\n"));
                maxOffset = 0;
                fileOffset = (DWORD)(pFileHdr - pFileView);

                //
                // Each iteration of the following loops processes one IFD
                // from an embedded TIFF file.
                //

                do {

                    PTIFF_IFD           pIfd;
                    PTIFF_TAG           pIfdEntry;
                    INT                 ifdCount;
                    DWORD               size, index, stripCount = 0;
                    PDWORD              pStripOffsets = NULL;

                    pIfd = (PTIFF_IFD) (pFileHdr + ifdOffset);
                    Assert( (PBYTE) pIfd < pFileEnd);
                    if ((PBYTE) pIfd >= pFileEnd) {
                        result = FAXERR_FATAL;
                        __leave;
                    }
                    ifdOffset += sizeof(WORD) + pIfd->wEntries * sizeof(TIFF_TAG);
                    pIfdOffset = pFileHdr + ifdOffset;

                    Assert(pIfdOffset < pFileEnd);
                    if (pIfdOffset >= pFileEnd) {
                        result = FAXERR_FATAL;
                        __leave;
                    }

                    if ((ifdOffset + sizeof(DWORD)) > maxOffset)
                        maxOffset = ifdOffset + sizeof(DWORD);

                    //
                    // We should add the file offset to any non-zero IFD offset
                    //

                    if ((ifdOffset = ReadUnalignedDWord(pIfdOffset)) != 0)
                        WriteUnalignedDWord(pIfdOffset, ifdOffset + fileOffset);

                    //
                    // Now go through each IFD entry and calculate the largest offset
                    //

                    pIfdEntry = (PTIFF_TAG) ((PBYTE) pIfd + sizeof(WORD));
                    ifdCount = pIfd->wEntries;

                    DebugPrintEx(DEBUG_MSG,TEXT("  Reading IFD: %d entries ...\n"), ifdCount);

                    while (ifdCount-- > 0) {

                        //
                        // Figure the size of various TIFF data types
                        //

                        switch (pIfdEntry->DataType) {

                        case TIFF_ASCII:
                        case TIFF_BYTE:
                        case TIFF_SBYTE:
                        case TIFF_UNDEFINED:

                            size = 1;
                            break;

                        case TIFF_SHORT:
                        case TIFF_SSHORT:

                            size = 2;
                            break;

                        case TIFF_LONG:
                        case TIFF_SLONG:
                        case TIFF_FLOAT:

                            size = 4;
                            break;

                        case TIFF_RATIONAL:
                        case TIFF_SRATIONAL:
                        case TIFF_DOUBLE:

                            size = 8;
                            break;

                        default:

                            DebugPrintEx(DEBUG_WRN,TEXT("Unknown TIFF data type: %d\n"), pIfdEntry->DataType);
                            size = 1;
                            break;
                        }

                        //
                        // Look for StripOffsets and StripByteCounts tags
                        //

                        if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS ||
                            pIfdEntry->TagId == TIFFTAG_STRIPBYTECOUNTS)
                        {
                            DWORD   n = pIfdEntry->DataCount;

                            if ((pIfdEntry->DataType == TIFF_LONG) &&
                                (stripCount == 0 || stripCount == n) &&
                                (pStripOffsets || (pStripOffsets = MemAllocZ(sizeof(DWORD)*n))))
                            {
                                if ((stripCount = n) == 1) {

                                    pStripOffsets[0] += pIfdEntry->DataOffset;

                                    if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS)
                                        pIfdEntry->DataOffset += fileOffset;

                                } else {

                                    DWORD UNALIGNED *p;

                                    DebugPrintEx(DEBUG_MSG,TEXT("Multiple strips per page: %d\n"), n);

                                    p = (DWORD UNALIGNED *) (pFileHdr + pIfdEntry->DataOffset);

                                    for (index=0; index < stripCount; index++) {

                                        n = *p;
                                        pStripOffsets[index] += n;

                                        if (pIfdEntry->TagId == TIFFTAG_STRIPOFFSETS)
                                            *p = n + fileOffset;

                                        p = (DWORD UNALIGNED *) ((LPBYTE) p + sizeof(DWORD));
                                    }
                                }

                            } else
                                DebugPrintEx(DEBUG_ERR,TEXT("Bad StripOffsets/StripByteCounts tag\n"));
                        }

                        //
                        // For a composite value, IFDENTRY.value is an offset
                        //

                        if (size * pIfdEntry->DataCount > sizeof(DWORD)) {

                            if (pIfdEntry->DataOffset > maxOffset)
                                maxOffset = pIfdEntry->DataOffset;

                            pIfdEntry->DataOffset += fileOffset;
                        }

                        pIfdEntry++;
                    }

                    //
                    // Make sure to skip the image data when search for the next file
                    //

                    if (pStripOffsets) {

                        for (index=0; index < stripCount; index++) {

                            if (pStripOffsets[index] > maxOffset)
                                maxOffset = pStripOffsets[index];
                        }

                        MemFree(pStripOffsets);
                    }

                } while (ifdOffset);

                //
                // Search for the beginning of next TIFF file
                //

                pFileHdr += maxOffset;

                while (pFileHdr < pFileEnd) {

                    if (ValidTiffFileHeader(pFileHdr)) {

                        //
                        // Modify the offset in the last IFD
                        //

                        ifdOffset = ReadUnalignedDWord(pFileHdr + sizeof(DWORD));
                        WriteUnalignedDWord(pIfdOffset, ifdOffset + (DWORD)(pFileHdr - pFileView));
                        break;
                    }

                    pFileHdr++;
                }

            } while (pFileHdr < pFileEnd);

            result = FAXERR_NONE;
        }

    } __finally {

        //
        // Perform necessary cleanup before returning to caller
        //

        if (pFileView)
            UnmapViewOfFile(pFileView);

        if (hFileMap)
            CloseHandle(hFileMap);

        CloseHandle(pFaxPort->hFile);
        pFaxPort->hFile = INVALID_HANDLE_VALUE;
    }

    return result;
}



INT
CheckJobRestart(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Check if the job has been restarted.
    If not, get the ID of the next job in the chain.

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    FAXERR_RESTART or FAXERR_NONE

--*/

{
    JOB_INFO_3 *pJobInfo3;
    JOB_INFO_2 *pJobInfo2;
    INT         status = FAXERR_NONE;

    //
    // If not, get the ID of the next job in the chain.
    //


    DEBUG_FUNCTION_NAME(TEXT("CheckJobRestart"));

    DebugPrintEx(DEBUG_MSG,TEXT("Job chain: id = %d\n"), pFaxPort->nextJobId);

    if (pJobInfo3 = MyGetJob(pFaxPort->hPrinter, 3, pFaxPort->jobId)) {

        pFaxPort->nextJobId = pJobInfo3->NextJobId;
        MemFree(pJobInfo3);

    } else
        pFaxPort->nextJobId = 0;

    //
    // Determine whether the job has been restarted or deleted
    //

    if (pJobInfo2 = MyGetJob(pFaxPort->hPrinter, 2, pFaxPort->jobId)) {

        if (pJobInfo2->Status & (JOB_STATUS_RESTART | JOB_STATUS_DELETING))
            status = FAXERR_RESTART;

        MemFree(pJobInfo2);
    }

    return status;
}


BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    )

/*++

Routine Description:

    Spooler calls this function at the end of a print job

Arguments:

    hPort - Identifies the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;
    INT         status;
    BOOL        Rslt;
    JOB_INFO_2  *pJobInfo2 = NULL;
    FAX_COVERPAGE_INFO_EX * pCovInfo;
    BOOL bBodyFileIsEmpty=FALSE;
    DWORDLONG  dwlParentJobId; // Receives teh parent job id after job submittion
    DWORDLONG* lpdwlRecipientJobIds = NULL; // Receives the recipient job ids after job submittion


    DEBUG_FUNCTION_NAME(TEXT("FaxMonEndDocPort"));


    //
    // Make sure we have a valid handle
    //

    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) {

        DebugPrintEx(DEBUG_ERR,TEXT("EndDocPort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Check if the job has been restarted. If not, get the ID of
    // the next job in the chain.
    //
    //
    // set pFaxPort->nextJobId to the next job id reported by JOB_INFO_3
    // set to 0 if no more chained jobs.
    //
    if ((status = CheckJobRestart(pFaxPort)) != FAXERR_NONE)
        goto ExitEndDocPort;

    //
    // Check if we're at the end of a job chain
    //
    //
    // The job chain starts with a cover page job and ends with a body job.
    // The cover page job has JOB_INFO_2:pParametes which is not NULL. This string
    // is copied to pFaxPort->pParameters when GetJobInfo() was called at FaxMonStartDocPort().
    // This is pParameters is not NULL it means that the current job is a cover page job.
    // In case the current job is a cover page job we report that we sent the job to the printer
    // and do nothing more. Since we do not close the temp file to which FaxMonWriteDoc() is writing
    // the next job (body) will continue to write to the same file. This effectively merges the cover
    // page with the body.
    //
    if (pFaxPort->nextJobId != 0 && pFaxPort->pParameters != NULL) {

        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        return TRUE;
    }
    //
    // If we are here then we are at the end of writing the body (the last job in the chain).
    // In the temporaty file we have a TIFF file with the cover page followed by the body.
    //
    //
    // The monitor runs in the context of the current job's owner.
    // In order to create temporary files in the spool directory,
    // we need to revert to the spooler context first.
    //

/*    if (! (hToken = RevertToPrinterSelf()))
        Error(("RevertToPrinterSelf failed: %d\n", GetLastError()));
*/
    //
    // Check if we're dealing with fax jobs from win31 or win95 clients
    //

    if ((pFaxPort->pParameters == NULL) &&
        (status = ProcessDownlevelFaxJob(pFaxPort)) != FAXERR_NONE)
    {
        goto ExitEndDocPort;
    }

    //
    // Fix up the temporary fax data into a properly formatted TIFF file.
    //
    status = FixUpFaxFile(pFaxPort);
    if (FAXERR_IGNORE == status)
    {
        DebugPrintEx(DEBUG_WRN,TEXT("Body TIFF file is empty."));
        bBodyFileIsEmpty=TRUE;
    }
    else
    if (status != FAXERR_NONE)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("FixUpFaxFile failed ( status = %ld)"),status);
        goto ExitEndDocPort;
    }

    //
    // Call the fax service to send the TIFF file
    //


    pJobInfo2 = MyGetJob( pFaxPort->hPrinter, 2, pFaxPort->jobId );
    if (pJobInfo2) {
        pFaxPort->JobParamsEx.lptstrDocumentName = pJobInfo2->pDocument;
    } else {
        DebugPrintEx(DEBUG_WRN,TEXT("MyGetJob failed for JobId: %d. Setting document name to NULL."),pFaxPort->jobId);
        pFaxPort->JobParamsEx.lptstrDocumentName = NULL;
    }

/*    if (hToken && !ImpersonatePrinterClient(hToken)) {
        Error(("ImpersonatePrinterClient failed: %d\n", GetLastError()));
    } */

    pFaxPort->JobParamsEx.dwReserved[0] = 0xffffffff;
    pFaxPort->JobParamsEx.dwReserved[1] = pFaxPort->jobId;

    if (pFaxPort->CoverPageEx.lptstrCoverPageFileName) {
        //
        // If a cover page is specified at all.
        //
        if (pFaxPort->CoverPageEx.bServerBased) {
            //
            // Server cover page. Use the user specified path.
            //
            pCovInfo=&(pFaxPort->CoverPageEx);
            DebugPrintEx(DEBUG_MSG,TEXT("Using server based cover page: %s"),pFaxPort->CoverPageEx.lptstrCoverPageFileName);
        } else {
            //
            // Personal cover page. Use the cover page file created from the print job.
            // Note that there is no cleanup issue here. pCoverPageFileName is deallocated on cleanup.
            // and pFaxPort->CoverPageEx.lptstrCoverPageFileName is never deallocated directly. It points
            // to a location within pFaxPort->pParameters which is freed at cleanup.
            pFaxPort->CoverPageEx.lptstrCoverPageFileName=pFaxPort->pCoverPageFileName;
            pCovInfo=&(pFaxPort->CoverPageEx);
            DebugPrintEx(DEBUG_MSG,TEXT("Using personal cover page copied to : %s"),pFaxPort->CoverPageEx.lptstrCoverPageFileName);
        }
    } else {
        //
        // No cover page specified by the user. Nullify the cover page info sent to FaxSendDocument.
        //
        pCovInfo=NULL;
    }

    if (!pCovInfo && bBodyFileIsEmpty)
    {
        DebugPrintEx(DEBUG_WRN,TEXT("Body file is empty and cover page is not specified. Job is ignored."));
        status=FAXERR_IGNORE;
        goto ExitEndDocPort;
    }

    //
    // Allocate array of recipient job ids
    //

    lpdwlRecipientJobIds=(DWORDLONG*)MemAlloc(sizeof(DWORDLONG)*pFaxPort->nRecipientCount);
    if (!lpdwlRecipientJobIds) {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to allocate array of size %ld for recipient job ids (ec: 0x%0X)."),
                     sizeof(DWORD)*pFaxPort->nRecipientCount,
                     GetLastError());
        goto ExitEndDocPort;
    }


    if (bBodyFileIsEmpty )
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Sending fax with EMPTY body (cover page is available)"));
        Rslt= pFaxPort->pFaxSendDocumentExW(
                    pFaxPort->hFaxSvc,
                    NULL, // NO BODY
                    pCovInfo,
                    &pFaxPort->SenderProfile,
                    pFaxPort->nRecipientCount,
                    pFaxPort->pRecipients,
                    &pFaxPort->JobParamsEx,
                    &dwlParentJobId,
                    lpdwlRecipientJobIds);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,TEXT("Sending fax with body"));
        Rslt= pFaxPort->pFaxSendDocumentExW(
            pFaxPort->hFaxSvc,
            pFaxPort->pFilename,
            pCovInfo,
            &pFaxPort->SenderProfile,
            pFaxPort->nRecipientCount,
            pFaxPort->pRecipients,
            &pFaxPort->JobParamsEx,
            &dwlParentJobId,
            lpdwlRecipientJobIds);
    }

    /*
    if (! (hToken = RevertToPrinterSelf())) {
        Error(("RevertToPrinterSelf failed: %d\n", GetLastError()));
    }
    */

    if (Rslt) {

        DebugPrintEx(DEBUG_MSG,TEXT("Successfuly submitted job. Parent Job Id = 0x%I64x"),dwlParentJobId);
        pFaxPort->bDocumentSentToServer=TRUE;
        status = FAXERR_NONE;
        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
        //pFaxPort>pFileName will be deleted on exit by FreeFaxJobInfo()
    } else {

        status = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            _T("FaxSendDocument failed: ec = %d, job id = %ld\n"),
            GetLastError(),
            pFaxPort->jobId);

        if (pJobInfo2)
        {
            WriteToLog(MSG_FAX_MON_SEND_FAILED, status, pFaxPort, pJobInfo2);
        }

        SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_DELETE);
        status = FAXERR_NONE;
    }

ExitEndDocPort:



    //
    // If the job wasn't successfully sent to the fax service,
    // inform the spooler that there is an error on the job.
    //
    // Or if the print job has no data, simply ignore it.
    //

    switch (status) {

        case FAXERR_NONE:
            break;

        case FAXERR_RESTART:

            DebugPrintEx(DEBUG_WRN,TEXT("Job restarted or deleted: id = %d\n"), pFaxPort->jobId);

        case FAXERR_IGNORE:

            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_SENT_TO_PRINTER);
            break;

        default:

            DebugPrintEx(DEBUG_ERR,TEXT("Error sending fax job: id = %d\n"), pFaxPort->jobId);
            SetJob(pFaxPort->hPrinter, pFaxPort->jobId, 0, NULL, JOB_CONTROL_DELETE);
            break;
    }



    if (pJobInfo2) {
        MemFree( pJobInfo2 );
        pFaxPort->JobParamsEx.lptstrDocumentName = NULL; // It was set to point into pJobInfo2
    }

    if (lpdwlRecipientJobIds) {
        MemFree(lpdwlRecipientJobIds);
        lpdwlRecipientJobIds=NULL;
    }


    FreeFaxJobInfo(pFaxPort);

    //
    // Switch back to the original context if necessary
    //

/*    if (hToken && !ImpersonatePrinterClient(hToken))
        Error(("ImpersonatePrinterClient failed: %d\n", GetLastError()));*/

    return (status < FAXERR_SPECIAL);
}



BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    )

/*++

Routine Description:

    Writes data to a port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer that contains data to be written to the port
    cbBuf - Specifies the size in bytes of the buffer
    pcbWritten - Returns the count of bytes successfully written to the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXPORT    pFaxPort = (PFAXPORT) hPort;
    BOOL bRet;
    //
    // Make sure we have a valid handle
    //

    DEBUG_FUNCTION_NAME(TEXT("FaxMonWritePort"));

    if (! ValidFaxPort(pFaxPort) || ! pFaxPort->hFaxSvc) {

        DebugPrintEx(DEBUG_ERR,TEXT("WritePort is given an invalid fax port handle\n"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    //
    //
    if (pFaxPort->bCoverPageJob)
    {
        //
        // If pFaxPort->bCoverPageJob is on it means that the print job that writes is the cover page print job.
        // If the cover page is a personal cover page then it is embedded (the template itself) in this print job
        // and we write it to the temp cover page file we created earlier (pFaxPort->hCoverPageFile).
        // If the cover page is a server cover page then it is NOT embedded in the print job (since it can be found
        // directly on the server) and we do not create a temp cover page file and do not write the print job content
        // into it.
        //
        if (!pFaxPort->CoverPageEx.bServerBased)
        {
            //
            // Personal cover page
            //
            Assert(pFaxPort->hCoverPageFile != INVALID_HANDLE_VALUE);
            bRet=WriteFile(pFaxPort->hCoverPageFile, pBuffer, cbBuf, pcbWritten, NULL);
        } else
        {
            //
            // Server cover page - the print job body is empty and the port shoult not be written to.
            // This should never execute.
            //
            Assert(FALSE);
            bRet=TRUE;
            *pcbWritten=cbBuf;
        }
    }
    else
    {
        Assert(pFaxPort->hFile!=INVALID_HANDLE_VALUE);
        bRet=WriteFile(pFaxPort->hFile, pBuffer, cbBuf, pcbWritten, NULL);
    }

    return bRet;

}



BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    )

/*++

Routine Description:

    Reads data from the port

Arguments:

    hPort - Identifies the port
    pBuffer - Points to a buffer where data read from the printer can be written
    cbBuf - Specifies the size in bytes of the buffer pointed to by pBuffer
    pcbRead - Returns the number of bytes successfully read from the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonReadPort"));


    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    )

/*++

Routine Description:

    Enumerates the ports available on the specified server

Arguments:

    pServerName - Specifies the name of the server whose ports are to be enumerated
    dwLevel - Specifies the version of the structure to which pPorts points
    pPorts - Points to an array of PORT_INFO_1 structures where data describing
        the available ports will be writteno
    cbBuf - Specifies the size in bytes of the buffer to which pPorts points
    pcbNeeded - Returns the required buffer size identified by pPorts
    pReturned -  Returns the number of PORT_INFO_1 structures returned

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAX_DESC_LEN    64

{
    TCHAR            portDescStr[MAX_DESC_LEN];
    INT              descStrSize, faxmonNameSize;
    DWORD            cbNeeded;
    BOOL             status = TRUE;
    PORT_INFO_1      *pPortInfo1 = (PORT_INFO_1 *) pPorts;
    PORT_INFO_2      *pPortInfo2 = (PORT_INFO_2 *) pPorts;
    INT              strSize;



    DEBUG_FUNCTION_NAME(TEXT("FaxMonEnumPorts"));

    DEBUG_TRACE_ENTER;


    if (pcbNeeded == NULL || pReturned == NULL || (pPorts == NULL && cbBuf != 0)) {

        DebugPrintEx(DEBUG_ERR,TEXT("Invalid input parameters\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Load the fax port description string
    //

    if (! LoadString(ghInstance, IDS_FAX_PORT_DESC, portDescStr, MAX_DESC_LEN))
        portDescStr[0] = NUL;

    descStrSize = SizeOfString(portDescStr);
    faxmonNameSize = SizeOfString(faxMonitorName);

    switch (Level) {

    case 1:

        cbNeeded = sizeof(PORT_INFO_1) + SizeOfString(FAX_PORT_NAME);
        break;

    case 2:

        cbNeeded = sizeof(PORT_INFO_2) + descStrSize + faxmonNameSize + SizeOfString(FAX_PORT_NAME);
        break;
    }

    *pReturned = 1;
    *pcbNeeded = cbNeeded;

    if (cbNeeded > cbBuf) {

        //
        // Caller didn't provide a big enough buffer
        //

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        status = FALSE;

    } else {

        //
        // Strings must be packed at the end of the caller provided buffer.
        // Otherwise, spooler will screw up royally.
        //

        pPorts += cbBuf;

        //
        // Copy the requested port information to the caller provided buffer
        //

        strSize = SizeOfString(FAX_PORT_NAME);
        pPorts -= strSize;
        CopyMemory(pPorts, FAX_PORT_NAME, strSize);

        switch (Level) {

        case 1:

            pPortInfo1->pName = (LPTSTR) pPorts;
            DebugPrintEx(DEBUG_MSG,TEXT("Port info 1: %ws\n"), pPortInfo1->pName);

            pPortInfo1++;
            break;

        case 2:

            pPortInfo2->pPortName = (LPTSTR) pPorts;

            //
            // Copy the fax monitor name string
            //

            pPorts -= faxmonNameSize;
            pPortInfo2->pMonitorName = (LPTSTR) pPorts;
            CopyMemory(pPorts, faxMonitorName, faxmonNameSize);

            //
            // Copy the fax port description string
            //

            pPorts -= descStrSize;
            pPortInfo2->pDescription = (LPTSTR) pPorts;
            CopyMemory(pPorts, portDescStr, descStrSize);

            pPortInfo2->fPortType = PORT_TYPE_WRITE;
            pPortInfo2->Reserved = 0;

            DebugPrintEx(DEBUG_MSG,TEXT("Port info 2: %ws, %ws, %ws\n"),
                     pPortInfo2->pPortName,
                     pPortInfo2->pMonitorName,
                     pPortInfo2->pDescription);

            pPortInfo2++;
            break;
        }
    }

    return status;
}


BOOL
DisplayErrorNotImplemented(
    HWND    hwnd,
    INT     titleId
    )

/*++

Routine Description:

    Display an error dialog to tell the user that he cannot manage
    fax devices in the Printers folder.

Arguments:

    hwnd - Specifies the parent window for the message box
    titleId - Message box title string resource ID

Return Value:

    FALSE

--*/

{
    TCHAR   title[128];
    TCHAR   message[256];

    LoadString(ghInstance, titleId, title, 128);
    LoadString(ghInstance, IDS_CONFIG_ERROR, message, 256);
    AlignedMessageBox(hwnd, message, title, MB_OK|MB_ICONERROR);

    SetLastError(ERROR_SUCCESS);
    return FALSE;
}



BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    )

/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/


{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonAddPort"));



    return DisplayErrorNotImplemented(hwnd, IDS_ADD_PORT);
}



BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    )

/*++

Routine Description:

    Adds the name of a port to the list of supported ports

Arguments:

    pServerName - Specifies the name of the server to which the port is to be added
    hwnd - Identifies the parent window of the AddPort dialog box
    pMonitorName - Specifies the monitor associated with the port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonAddPortEx"));



    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}



BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    )

/*++

Routine Description:

    Delete the specified port from the list of supported ports

Arguments:

    pServerName - Specifies the name of the server from which the port is to be removed
    hwnd - Identifies the parent window of the port-deletion dialog box
    pPortName - Specifies the name of the port to be deleted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonDeletePort"));


    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}



BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    )

/*++

Routine Description:

    Display a dialog box to allow user to configure the specified port

Arguments:

    pServerName - Specifies the name of the server on which the given port exists
    hwnd - Identifies the parent window of the port-configuration dialog
    pPortName - Specifies the name of the port to be configured

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxMonConfigurePort"));



    return DisplayErrorNotImplemented(hwnd, IDS_CONFIGURE_PORT);
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     strSize;


    DEBUG_FUNCTION_NAME(TEXT("DuplicateString"));

    if (pSrcStr != NULL) {

        strSize = SizeOfString(pSrcStr);

        if (pDestStr = MemAlloc(strSize))
            CopyMemory(pDestStr, pSrcStr, strSize);
        else
            DebugPrintEx(DEBUG_ERR,TEXT("Memory allocation failed\n"));

    } else
        pDestStr = NULL;

    return pDestStr;
}



PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;


    DEBUG_FUNCTION_NAME(TEXT("MyGetJob"));

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    DebugPrintEx(DEBUG_ERR,TEXT("GetJob failed: %d\n"), GetLastError());
    MemFree(pJobInfo);
    return NULL;
}



BOOL
SetJobStatus(
    HANDLE  hPrinter,
    DWORD   jobId,
    INT     statusStrId
    )

/*++

Routine Description:

    Update the status information of a print job

Arguments:

    hPrinter - Specifies the printer on which the job is printed
    jobId - Specifies the job identifier
    statusStrID - Specifies the status string resource ID

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define MAX_MESSAGE_LEN 256

{
    JOB_INFO_1 *pJobInfo1;
    BOOL        result = FALSE;
    TCHAR       message[MAX_MESSAGE_LEN];


    DEBUG_FUNCTION_NAME(TEXT("SetJobStatus"));

    //
    // Get the current job information
    //

    if (pJobInfo1 = MyGetJob(hPrinter, 1, jobId)) {

        //
        // Update the status field
        //

        if (LoadString(ghInstance, statusStrId, message, MAX_MESSAGE_LEN))
            pJobInfo1->pStatus = message;
        else {

            pJobInfo1->pStatus = NULL;
            pJobInfo1->Status = JOB_STATUS_ERROR;
        }

        pJobInfo1->Position = JOB_POSITION_UNSPECIFIED;

        if (! (result = SetJob(hPrinter, jobId, 1, (PBYTE) pJobInfo1, 0)))
            DebugPrintEx(DEBUG_ERR,TEXT("SetJob failed: %d\n"), GetLastError());

        MemFree(pJobInfo1);
    }

    return result;
}



DWORD
GetRegistryDWord(
    HKEY    hRegKey,
    LPTSTR  pValueName,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value from the registry

Arguments:

    hRegKey - Handle to the user info registry key
    pValueName - Specifies the name of the string value in registry
    defaultValue - Specifies the default value to be used in case of an error

Return Value:

    Requested DWORD value from the user info registry key

--*/

{
    DWORD   size, type, value;

    //
    // Retrieve the country code value from the registry.
    // Use the default value if none exists.
    //

    size = sizeof(value);

    if (RegQueryValueEx(hRegKey, pValueName, NULL, &type, (PBYTE) &value, &size) != ERROR_SUCCESS ||
        type != REG_DWORD)
    {
        value = defaultValue;
    }

    return value;
}



BOOL
WriteToLog(
    IN DWORD        dwMsgId,
    IN DWORD        dwError,
    IN PFAXPORT     pFaxPort,
    IN JOB_INFO_2*  pJobInfo
    )
/*++

Routine name : WriteToLog

Routine description:

    Write to the Event Log of Fax Service

Author:

    Iv Garber (IvG),    Sep, 2000

Arguments:

    dwError           [in]    - error code
    pFaxPort          [in]    - data about the fax
    pJobInfo          [in]    - data about the fax job

Return Value:

    TRUE if succeded to write to the event log, FALSE otherwise.

--*/
{
    DWORD   dwBufferSize = MAX_PATH - 1;
    TCHAR   tszBuffer[MAX_PATH] = {0};
    HMODULE hFxsEvent = NULL;
    BOOL    bRes = FALSE;

    long lDefaultCategoryCount = 0;
    PREG_FAX_SERVICE pFaxReg = NULL;

    FAX_LOG_CATEGORY DefaultCategories[] =
    {
        { NULL, FAXLOG_CATEGORY_INIT,     FAXLOG_LEVEL_MED },
        { NULL, FAXLOG_CATEGORY_OUTBOUND, FAXLOG_LEVEL_MED },
        { NULL, FAXLOG_CATEGORY_INBOUND,  FAXLOG_LEVEL_MED },
        { NULL, FAXLOG_CATEGORY_UNKNOWN,  FAXLOG_LEVEL_MED }
    };

    TCHAR tszNumRecipients[11] = {0};
    USES_DWORD_2_STR

    DEBUG_FUNCTION_NAME(_T("WriteToLog"));

    lDefaultCategoryCount = (sizeof(DefaultCategories) / sizeof(FAX_LOG_CATEGORY));
    //
    //  Initialize the Log
    //
    if (!InitializeEventLog(&pFaxReg, DefaultCategories, lDefaultCategoryCount ))
    {
        DebugPrintEx(DEBUG_ERR, _T("InitializeEventLog() failed: %ld"), GetLastError());
        goto Exit;
    }

    //
    //  Write to the Event Log
    //
    _stprintf(tszNumRecipients, _T("%ld"), pFaxPort->nRecipientCount);

    bRes = FaxLog(FAXLOG_CATEGORY_OUTBOUND,
        FAXLOG_LEVEL_MIN,
        8,
        dwMsgId,
        DWORD2DECIMAL(dwError),
        pJobInfo->pMachineName,
        pJobInfo->pUserName,
        pFaxPort->SenderProfile.lptstrName,
        pFaxPort->CoverPageEx.lptstrSubject,
        pFaxPort->pRecipients->lptstrName,
        pFaxPort->pRecipients->lptstrFaxNumber,
        tszNumRecipients);
    if (!bRes)
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxLog() failed, ec = %ld"), GetLastError());
    }

Exit:

    FreeLibrary(hFxsEvent);
    return bRes;
}



#if DBG

//
// Variable for controlling the amount of debug messages generated
//

INT _debugLevel = 1;


LPCSTR
StripDirPrefixA(
    LPCSTR  pFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename

Arguments:

    pFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    LPCSTR  pstr;

    if (pstr = strrchr(pFilename, FAX_PATH_SEPARATOR_CHR))
        return pstr + 1;

    return pFilename;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxmon\client16.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    client16.c

Abstract:

    Support for 16-bit (win31 and win95) fax clients

Environment:

        Windows XP fax monitor

Revision History:

        06/02/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxmon.h"
#include "tiffstub.h"
#include "prtcovpg.h"
#include "jobtag.h"
#include "faxreg.h"


//
// File header for the fax data from downlevel client
//

#define FAX16_SIGNATURE         'NF16'

typedef struct {

    WORD    Magic;              // 'II'
    WORD    Magic2;             // 0x0042
    DWORD   FirstIFDOffset;     // offset to the first IFD
    DWORD   Fax16Signature;     // 'NF16'
    DWORD   CodePage;           // code page use for converting multibyte strings to Unicode

    DWORD   SenderName;         // sender's name string
    DWORD   SenderFaxNumber;    // sender's fax number string
    DWORD   SenderCompany;      // sender's company string
    DWORD   SenderAddress;      // sender's address string
    DWORD   SenderTitle;        // sender's title string
    DWORD   SenderDepartment;   // sender's department string
    DWORD   SenderOffice;       // sender's office location string
    DWORD   SenderHomePhone;    // sender's home phone number string
    DWORD   SenderOfficePhone;  // sender's office phone number string

    DWORD   RecName;            // recipient's name string
    DWORD   RecFaxNumber;       // recipient's fax number string
    DWORD   RecCompany;         // recipient's company string
    DWORD   RecAddress;         // recipient's address string
    DWORD   RecCity;            // recipient's city string
    DWORD   RecState;           // recipient's state string
    DWORD   RecZip;             // recipient's zip code string
    DWORD   RecCountry;         // recipient's country string
    DWORD   RecTitle;           // recipient's title string
    DWORD   RecDepartment;      // recipient's department string
    DWORD   RecOffice;          // recipient's office string
    DWORD   RecHomePhone;       // recipient's home phone number string
    DWORD   RecOfficePhone;     // recipient's office phone number string

    DWORD   SubjectLine;        // subject string
    DWORD   NoteMessage;        // note string
    DWORD   TimeSent;           // time-sent string
    DWORD   BillingCode;        // billing code string

    DWORD   CoverPageFilename;  // cover page filename string
    DWORD   CoverPageDataSize;  // size of embedded cover page file in bytes
    DWORD   CoverPageData;      // offset to beginning of embedded cover page file
    DWORD   NumberOfPages;      // number of pages (not including the cover page)
    DWORD   EmailNotify;        // offset to Email notification address
    DWORD   Reserved[7];        // reserved - must be 0 for now

    //
    // String data and embedded cover page file if any
    //

} FAX16_TIFF_HEADER, *PFAX16_TIFF_HEADER;



LPWSTR
CopyClientStringToUnicode(
    PFAX16_TIFF_HEADER  pFax16Hdr,
    ULONG_PTR               offset
    )

/*++

Routine Description:

    Copy ANSI string from 16-bit clients to Unicode string

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client
    offset - Specifies the starting offset for the ANSI string

Return Value:

    Pointer to the duplicated Unicode string
    NULL if there is an error

--*/

{
    LPSTR   pAnsiStr;
    INT     cch;
    LPWSTR  pUnicodeStr = NULL;

    if (offset != 0) {

        pAnsiStr = (LPSTR) ((LPBYTE) pFax16Hdr + offset);
        cch = strlen(pAnsiStr);

        if (pUnicodeStr = MemAllocZ((cch + 1) * sizeof(WCHAR)))
            MultiByteToWideChar(pFax16Hdr->CodePage, 0, pAnsiStr, cch, pUnicodeStr, cch);
    }

    return pUnicodeStr;
}



VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Dispose of cover page field information

Arguments:

    pCPFields - Points to cover page field information

Return Value:

    NONE

--*/

{



    if (pCPFields != NULL) {

        LPTSTR *ppStr;
        LONG_PTR     count;

        //
        // Free individual cover page field strings.
        // HACK: We assume all fields between RecName and ToList are LPTSTRs.
        //

        ppStr = &pCPFields->RecName;
        count = (offsetof(COVERPAGEFIELDS, ToList) -
                 offsetof(COVERPAGEFIELDS, RecName)) / sizeof(LPTSTR);

        while (count-- > 0) {

            MemFree(*ppStr);
            ppStr++;
        }

        MemFree(pCPFields);
    }
}



PCOVERPAGEFIELDS
CollectFax16CoverPageFields(
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Collect cover page field information  from 16bit client fax job

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client

Return Value:

    Pointer to cover page field information
    NULL if there is an error

--*/

{
    //
    // Map fields in FAX16_TIFF_HEADER to fields in COVERPAGEFIELDS.
    // HACK: We assume all fields between RecName and NumberOfPages are LPTSTRs.
    //

    #define NUM_CPFIELDS ((offsetof(COVERPAGEFIELDS, NumberOfPages) - \
                           offsetof(COVERPAGEFIELDS, RecName)) / sizeof(LPTSTR))

    ULONG_PTR strOffsets[NUM_CPFIELDS] = {

        pFax16Hdr->RecName,
        pFax16Hdr->RecFaxNumber,
        pFax16Hdr->RecCompany,
        pFax16Hdr->RecAddress,
        pFax16Hdr->RecCity,
        pFax16Hdr->RecState,
        pFax16Hdr->RecZip,
        pFax16Hdr->RecCountry,
        pFax16Hdr->RecTitle,
        pFax16Hdr->RecDepartment,
        pFax16Hdr->RecOffice,
        pFax16Hdr->RecHomePhone,
        pFax16Hdr->RecOfficePhone,

        pFax16Hdr->SenderName,
        pFax16Hdr->SenderFaxNumber,
        pFax16Hdr->SenderCompany,
        pFax16Hdr->SenderAddress,
        pFax16Hdr->SenderTitle,
        pFax16Hdr->SenderDepartment,
        pFax16Hdr->SenderOffice,
        pFax16Hdr->SenderHomePhone,
        pFax16Hdr->SenderOfficePhone,

        pFax16Hdr->NoteMessage,
        pFax16Hdr->SubjectLine,
        pFax16Hdr->TimeSent,
    };

    PCOVERPAGEFIELDS pCPFields;
    LPTSTR          *ppStr;
    LONG_PTR         index;

    if ((pCPFields = MemAllocZ(sizeof(COVERPAGEFIELDS))) == NULL)
        return NULL;

    //
    // Convert individual cover page field from ANSI to Unicode string
    //

    for (index=0, ppStr = &pCPFields->RecName; index < NUM_CPFIELDS; index++, ppStr++) {

        if ((strOffsets[index] != 0) &&
            (*ppStr = CopyClientStringToUnicode(pFax16Hdr, strOffsets[index])) == NULL)
        {
            FreeCoverPageFields(pCPFields);
            return NULL;
        }
    }

    //
    // Number of pages printed
    //

    if ((pCPFields->NumberOfPages = MemAllocZ(sizeof(TCHAR) * 16)) == NULL) {

        FreeCoverPageFields(pCPFields);
        return NULL;
    }

    return pCPFields;
}



BOOL
CollectFax16JobParam(
    PFAXPORT            pFaxPort,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR              pBillingCode
    )

/*++

Routine Description:

    Collect 16-bit client fax job parameters

Arguments:

    pFaxPort - Points to a fax port structure
    pCPFields - Points to cover page field information
    pBillingCode - Points to billing code string from 16-bit client

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    //
    // Cover page fields which are passed fax service as parameters
    //

    LPTSTR  pSrcStr[NUM_JOBPARAM_TAGS] = {

        pCPFields->RecFaxNumber,
        pCPFields->RecName,
        pCPFields->SdrFaxNumber,
        pCPFields->SdrName,
        pCPFields->SdrCompany,
        pCPFields->SdrDepartment,
        pBillingCode
    };

    LPTSTR *ppDestStr[NUM_JOBPARAM_TAGS] = {
/*
		need to be fixed when enabling client 16 support
        (LPTSTR *)&pFaxPort->JobParamEx.lptstrFaxNumber,
        (LPTSTR *)&pFaxPort->JobParamEx.lptstrName,
        (LPTSTR *)&pFaxPort->jobParam.Tsid,
*/
        (LPTSTR *)&pFaxPort->SenderProfile.lptstrName,
        (LPTSTR *)&pFaxPort->SenderProfile.lptstrCompany,
        (LPTSTR *)&pFaxPort->SenderProfile.lptstrDepartment,
        (LPTSTR *)&pFaxPort->SenderProfile.lptstrBillingCode
    };

    INT     size, index;
    LPTSTR  p;

    //
    // Calculate the total length for all parameters
    //

    for (index=size=0; index < NUM_JOBPARAM_TAGS; index++) {

        if (pSrcStr[index])
            size += SizeOfString(pSrcStr[index]);
    }


    //
    // Concatenate all parameters into a single string
    //

    if (size > 0 && (p = pFaxPort->pParameters = MemAllocZ(size))) {

        for (index=0; index < NUM_JOBPARAM_TAGS; index++) {

            if (pSrcStr[index]) {

                *ppDestStr[index] = p;
                _tcscpy(p, pSrcStr[index]);
                p += _tcslen(p) + 1;
            }
        }
    }

    return (pFaxPort->pParameters != NULL);
}



LPTSTR
GetClientCoverPageFile(
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Return the cover page file associated with a 16-bit client fax job

Arguments:

    pFax16Hdr - Points to the fax data from downlevel client

Return Value:

    Points to the name of the cover page file
    NULL if there is an error

--*/

#define SERVER_CP_DIRECTORY TEXT("\\coverpg\\")

{
    LPTSTR  pFilename;
	
	DEBUG_FUNCTION_NAME(TEXT("GetClientCoverPageFile"));

    if (pFax16Hdr->CoverPageFilename) {

        //
        // Use server-based cover page file
        //

        if (pFilename = CopyClientStringToUnicode(pFax16Hdr, pFax16Hdr->CoverPageFilename)) {

            LPTSTR  pServerDir = NULL, p;
            DWORD   cb, len;

            len = (_tcslen(SERVER_CP_DIRECTORY) + _tcslen(pFilename) + 1) * sizeof(TCHAR);

            if (!GetPrinterDriverDirectory(NULL, NULL, 1, NULL, 0, &cb) &&
                GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                (pServerDir = MemAllocZ(cb + len)) &&
                GetPrinterDriverDirectory(NULL, NULL, 1, (PBYTE) pServerDir, cb, &cb))
            {
                //
                // Strip off the last component of the driver directory
                // which should be w32<arch>.
                //

                if (p = _tcsrchr(pServerDir, TEXT('\\')))
                    *p = NUL;

                _tcscat(pServerDir, SERVER_CP_DIRECTORY);
                _tcscat(pServerDir, pFilename);

                MemFree(pFilename);
                pFilename = pServerDir;

            } else {

                MemFree(pServerDir);
                MemFree(pFilename);
                pFilename = NULL;
            }
        }

    } else if (pFilename = CreateTempFaxFile(FAX_TIFF_FILE_EXT)) {

        //
        // Cover page data is embedded in the cover page job
        //  Create a temporary file and copy cover page data into it
        //

        HANDLE  hFile;
        DWORD   cbWritten;
        BOOL    copied = FALSE;

        Assert(pFax16Hdr->CoverPageData != 0 && pFax16Hdr->CoverPageDataSize != 0);

        hFile = CreateFile(pFilename,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS | TRUNCATE_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile != INVALID_HANDLE_VALUE) {

            copied = WriteFile(hFile,
                               (LPBYTE) pFax16Hdr + pFax16Hdr->CoverPageData,
                               pFax16Hdr->CoverPageDataSize,
                               &cbWritten,
                               NULL);

            CloseHandle(hFile);
        }

        if (! copied) {

            DebugPrintEx(DEBUG_ERR,TEXT("Failed to copy cover page data to a temporary file\n"));
            DeleteFile(pFilename);
            MemFree(pFilename);
            pFilename = NULL;
        }
    }

    return pFilename;
}



LPTSTR
GetBaseNoteFilename(
    VOID
    )

/*++

Routine Description:

    Get the name of base cover page file in system32 directory

Arguments:

    NONE

Return Value:

    Pointer to name of base cover page file
    NULL if there is an error

--*/

#define BASENOTE_FILENAME   TEXT("\\basenote.cov")

{
    TCHAR       systemDir[MAX_PATH];
    LPTSTR      pBaseNoteName = NULL;
    COVDOCINFO  covDocInfo;

	DEBUG_FUNCTION_NAME(TEXT("GetBaseNoteFilename"));

    if (GetSystemDirectory(systemDir, MAX_PATH) &&
        (pBaseNoteName = MemAlloc(SizeOfString(systemDir) + SizeOfString(BASENOTE_FILENAME))))
    {
        _tcscpy(pBaseNoteName, systemDir);
        _tcscat(pBaseNoteName, BASENOTE_FILENAME);
        DebugPrintEx(DEBUG_MSG,TEXT("Base cover page filename: %ws\n"), pBaseNoteName);

        if (PrintCoverPage(NULL, NULL, pBaseNoteName, &covDocInfo) ||
            ! (covDocInfo.Flags & COVFP_NOTE) ||
            ! (covDocInfo.Flags & COVFP_SUBJECT))
        {
            DebugPrintEx(DEBUG_ERR,TEXT("Invalid base cover page file: %ws\n"), pBaseNoteName);
            MemFree(pBaseNoteName);
            pBaseNoteName = NULL;
        }
    }

    return pBaseNoteName;
}



BOOL
ProcessFax16CoverPage(
    PFAXPORT            pFaxPort,
    PFAX16_TIFF_HEADER  pFax16Hdr
    )

/*++

Routine Description:

    Render the cover page for downlevel client into a temporary file

Arguments:

    pFaxPort - Points to a fax port structure
    pFax16Hdr - Pointer to the fax data from downlevel client

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOVERPAGEFIELDS    pCPFields;
    LPTSTR              pBillingCode;
    INT                 result = FALSE;

	DEBUG_FUNCTION_NAME(TEXT("ProcessFax16CoverPage"));

    //
    // Make sure the recipient's fax number is specified
    //

    if (pFax16Hdr->RecFaxNumber == 0) {

        DebugPrintEx(DEBUG_ERR,TEXT("No recipient number is specified\n"));
        return FALSE;
    }

    //
    // Collect cover page field information and
    // assemble fax job parameters and
    // create a new temporary file for storing cover page job
    //

    pBillingCode = CopyClientStringToUnicode(pFax16Hdr, pFax16Hdr->BillingCode);

    if ((pCPFields = CollectFax16CoverPageFields(pFax16Hdr)) &&
        CollectFax16JobParam(pFaxPort, pCPFields, pBillingCode) &&
        (pFaxPort->pFilename = CreateTempFaxFile(FAX_TIFF_FILE_EXT)))
    {
        LPTSTR      pCPFilename = NULL;
        LPTSTR      pBaseNoteName = NULL;
        DWORD       pageCount = pFax16Hdr->NumberOfPages;
        BOOL        renderCP;
        COVDOCINFO  covDocInfo;

        //
        // Check if cover page is requested - either a server cover page filename
        // is specified or the cover page data is embedded in the file.
        //

        renderCP = (pFax16Hdr->CoverPageFilename ||
                    (pFax16Hdr->CoverPageDataSize && pFax16Hdr->CoverPageData));

        ZeroMemory(&covDocInfo, sizeof(covDocInfo));

        if (renderCP) {

            if (pCPFilename = GetClientCoverPageFile(pFax16Hdr)) {

                //
                // Find out if the specified cover page contains note/subject fields
                //

                DWORD ec = PrintCoverPage( NULL, NULL, pCPFilename, &covDocInfo );
                if (ec) {
                    DebugPrintEx(DEBUG_ERR,TEXT("Cannot examine cover page: %d\n"), ec );
                }

                result = TRUE;
                pageCount++;
            }

        } else
            result = TRUE;

        //
        // Calculate the total number of pages including cover page(s)
        //

        if (((pCPFields->Note &&
              !IsEmptyString(pCPFields->Note) &&
              !(covDocInfo.Flags & COVFP_NOTE)) ||

             (pCPFields->Subject &&
              !IsEmptyString(pCPFields->Subject) &&
              !(covDocInfo.Flags & COVFP_SUBJECT))) &&

            (pBaseNoteName = GetBaseNoteFilename()))
        {
            renderCP = TRUE;
            pageCount++;
        }

        wsprintf(pCPFields->NumberOfPages, TEXT("%d"), pageCount);

        //
        // Render the fax cover page(s)
        //

        if (result && renderCP) {

            DOCINFO docinfo;
            HDC     hdc = NULL;
            DEVMODE devmode, *pDevmode;

            ZeroMemory(&docinfo, sizeof(docinfo));
            docinfo.cbSize = sizeof(docinfo);
            docinfo.lpszDocName = TEXT("faxmon");
            docinfo.lpszOutput = pFaxPort->pFilename;
            renderCP = FALSE;

            if (covDocInfo.PaperSize > 0) {

                ZeroMemory(&devmode, sizeof(devmode));
                _tcsncpy(devmode.dmDeviceName, pFaxPort->pPrinterName, CCHDEVICENAME);

                devmode.dmSpecVersion = DM_SPECVERSION;
                devmode.dmSize = sizeof(devmode);

                devmode.dmFields = DM_PAPERSIZE|DM_ORIENTATION;
                devmode.dmPaperSize = covDocInfo.PaperSize;
                devmode.dmOrientation = covDocInfo.Orientation;

                pDevmode = &devmode;

            } else
                pDevmode = NULL;

            if ((hdc = CreateDC(NULL, pFaxPort->pPrinterName, NULL, pDevmode)) &&
                (StartDoc(hdc, &docinfo) > 0))
            {
                //
                // Render the user specified cover page
                //

                if (pCPFilename) {

                    if (StartPage(hdc) > 0) {

                        renderCP = PrintCoverPage(hdc, pCPFields, pCPFilename, &covDocInfo) == 0 ? TRUE : FALSE;
                        EndPage(hdc);
                    }

                } else
                    renderCP = TRUE;

                //
                // Render the extra cover page for note and subject
                //

                if (pBaseNoteName && renderCP) {

                    if (StartPage(hdc) > 0) {

                        renderCP = PrintCoverPage(hdc, pCPFields, pBaseNoteName, &covDocInfo) == 0 ? TRUE : FALSE;
                        EndPage(hdc);

                    } else
                        renderCP = FALSE;
                }

                if (renderCP)
                    EndDoc(hdc);
                else
                    AbortDoc(hdc);
            }

            result = renderCP;

            if (hdc)
                DeleteDC(hdc);
        }

        //
        // In the embedded cover page data case, we created a temporary
        // cover page file earlier. So delete it here.
        //

        if (pCPFilename && !pFax16Hdr->CoverPageFilename)
            DeleteFile(pCPFilename);

        MemFree(pCPFilename);
        MemFree(pBaseNoteName);
    }

    FreeCoverPageFields(pCPFields);
    MemFree(pBillingCode);

    //
    // Open the cover page TIFF file if there was no error
    //

    return result && OpenTempFaxFile(pFaxPort, TRUE);
}



BOOL
ConcatFax16Data(
    PFAXPORT            pFaxPort,
    PFAX16_TIFF_HEADER  pFax16Hdr,
    DWORD               size
    )

/*++

Routine Description:

    Concatenate the fax data from downlevel client to the end of cover page TIFF file

Arguments:

    pFaxPort - Points to a fax port structure
    pFax16Hdr - Pointer to the fax data from downlevel client
    size - Size of the fax data from downlevel client

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD   bytesWritten;

    return (pFax16Hdr->NumberOfPages == 0) ||
           (WriteFile(pFaxPort->hFile, pFax16Hdr, size, &bytesWritten, NULL) &&
            bytesWritten == size);
}



INT
ProcessDownlevelFaxJob(
    PFAXPORT    pFaxPort
    )

/*++

Routine Description:

    Process fax jobs sent from win31 and win95 clients

Arguments:

    pFaxPort - Points to a fax port structure

Return Value:

    error code FAXERR_*

--*/

{
    DWORD   fileSize;
    LPVOID  pFileView = NULL;
    HANDLE  hFileMap = NULL;
    INT     result = FAXERR_BAD_DATA16;
    LPTSTR  pOrigFilename;

	DEBUG_FUNCTION_NAME(TEXT("ProcessDownlevelJob"));
    //
    // Get the size of fax job file
    //

    FlushFileBuffers(pFaxPort->hFile);

    if ((fileSize = GetFileSize(pFaxPort->hFile, NULL)) == 0xffffffff ||
        (fileSize < sizeof(DWORD) * 2))
    {
        return FAXERR_FATAL;
    }

    //
    // Map the fax job data into memory
    //

    if (hFileMap = CreateFileMapping(pFaxPort->hFile, NULL, PAGE_READONLY, 0, 0, NULL))
        pFileView = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, fileSize);

    CloseHandle(pFaxPort->hFile);
    pFaxPort->hFile = INVALID_HANDLE_VALUE;

    pOrigFilename = pFaxPort->pFilename;
    pFaxPort->pFilename = NULL;

    __try {

        PFAX16_TIFF_HEADER  pFax16Hdr = pFileView;

        //
        // Validate the fax data from the downlevel client
        //

        if (hFileMap != NULL &&
            pFileView != NULL &&
            ValidTiffFileHeader(pFileView) &&
            pFax16Hdr->Fax16Signature == FAX16_SIGNATURE)
        {
            //
            // Render the cover page into a temporary TIFF file
            // and concatenate the original TIFF data at the end
            //

            if (ProcessFax16CoverPage(pFaxPort, pFax16Hdr) &&
                ConcatFax16Data(pFaxPort, pFax16Hdr, fileSize))
            {
                result = FAXERR_NONE;

            } else {

                DebugPrintEx(DEBUG_ERR,TEXT("Error processing downlevel fax job\n"));
                result = FAXERR_FATAL;
            }

        } else {

            DebugPrintEx(DEBUG_ERR,TEXT("Bad TIFF file from downlevel fax client\n"));
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DebugPrintEx(DEBUG_ERR,TEXT("Access violation while reading downlevel fax job\n"));
    }

    //
    // Perform necessary cleanup before returning to caller
    //

    if (pFileView)
        UnmapViewOfFile(pFileView);

    if (hFileMap)
        CloseHandle(hFileMap);

    DeleteFile(pOrigFilename);
    MemFree(pOrigFilename);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxmon\faxmon.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxmon.h

Abstract:

    Header file for fax print monitor

Environment:

        Windows XP fax print monitor

Revision History:

        02/22/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXMON_H_
#define _FAXMON_H_

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winspool.h>
#include <winsplp.h>
#include <tchar.h>
#include "faxutil.h"
#include <fxsapip.h>
#include "jobtag.h"

//
// String resource IDs
//

#define IDS_FAX_PORT_DESC       257
#define IDS_PORT_ALREADY_EXISTS 258
#define IDS_FAXERR_RECOVERABLE  259
#define IDS_FAXERR_FATAL        260
#define IDS_FAXERR_BAD_TIFF     261
#define IDS_FAXERR_BAD_DATA16   262
#define IDS_ADD_PORT            263
#define IDS_DELETE_PORT         264
#define IDS_CONFIGURE_PORT      265
#define IDS_CONFIG_ERROR        266
#define IDS_ADD_ERROR           267
#define IDS_DELETE_ERROR        268

//
// Data structure for representing a fax monitor port
//

typedef struct _FAXPORT {

    PVOID                   startSig;               // signature
    LPTSTR                  pName;                  // port name
    HANDLE                  hFaxSvc;                // fax service handle
    DWORD                   jobId;                  // main job ID
    DWORD                   nextJobId;              // next job ID in the chain
    HANDLE                  hFile;                  // handle to currently open file
    LPTSTR                  pFilename;              // pointer to currently open file name
    LPTSTR                  pPrinterName;           // currently connected printer name
    HANDLE                  hPrinter;               // open handle to currently connected printer
    LPTSTR                  pParameters;            // pointer to job parameter string
    FAX_JOB_PARAM_EX        JobParamsEx;             // pointer to individual job parameters
	//
	FAX_COVERPAGE_INFO_EX   CoverPageEx;			// Cover page information
    FAX_PERSONAL_PROFILE    SenderProfile;          // Sender information
    PFAX_PERSONAL_PROFILE   pRecipients;            // Array of recipient information for this transmission
    UINT                    nRecipientCount;        // The number of recipients in this transmission
	HANDLE					hCoverPageFile;
	LPTSTR					pCoverPageFileName;		// The name of the cover page file generated on the server by the fax monitor.
													// This file contains the cover page template as transfered via the cover page 
    												// print job.
    BOOL                    bDocumentSentToServer;  // TRUE if the print operation completed successfuly and the document
                                                    // was sent to the server. FreeFaxJobInfo() uses it to figure
                                                    // out if to delete the generated COV template file or not.

	BOOL					bCoverPageJob;          // TRUE if the current print job is the cover page job.
    HMODULE                 hWinFax;                // handle for loaded winfax dll
    PFAXCONNECTFAXSERVERW   pFaxConnectFaxServerW;  // function pointer
    PFAXCLOSE               pFaxClose;              // function pointer
    PFAXSENDDOCUMENTW       pFaxSendDocumentW;      // function pointer
    PFAXACCESSCHECK         pFaxAccessCheck;        // function pointer
    PFAXSENDDOCUMENTEXW     pFaxSendDocumentExW;      // function pointer
    PVOID                   endSig;                 // signature

} FAXPORT, *PFAXPORT;

#define ValidFaxPort(pFaxPort) \
        ((pFaxPort) && (pFaxPort) == (pFaxPort)->startSig && (pFaxPort) == (pFaxPort)->endSig)

//
// Different error code when sending fax document
//

#define FAXERR_NONE         0
#define FAXERR_IGNORE       1
#define FAXERR_RESTART      2
#define FAXERR_SPECIAL      3

#define FAXERR_FATAL        IDS_FAXERR_FATAL
#define FAXERR_RECOVERABLE  IDS_FAXERR_RECOVERABLE
#define FAXERR_BAD_TIFF     IDS_FAXERR_BAD_TIFF
#define FAXERR_BAD_DATA16   IDS_FAXERR_BAD_DATA16

//
// Memory allocation and deallocation macros
//

//
// undefine the memory allocation routines from FAXUTIL.H
//
#undef MemAlloc
#undef MemFree

#define MemAlloc(size)  ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size) ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(ptr)    { if (ptr) LocalFree((HLOCAL) (ptr)); }

//
// Number of tags used for passing fax job parameters
//

#define NUM_JOBPARAM_TAGS 12

//
// Nul terminator for a character string
//

#define NUL             0

//
// Result of string comparison
//

#define EQUAL_STRING    0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define IsNulChar(c)        ((c) == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif


//
// Declaration of print monitor entry points
//

BOOL
FaxMonOpenPort(
    LPTSTR  pPortName,
    PHANDLE pHandle
    );

BOOL
FaxMonClosePort(
    HANDLE  hPort
    );

BOOL
FaxMonStartDocPort(
    HANDLE  hPort,
    LPTSTR  pPrinterName,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pDocInfo
    );

BOOL
FaxMonEndDocPort(
    HANDLE  hPort
    );

BOOL
FaxMonWritePort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbWritten
    );

BOOL
FaxMonReadPort(
    HANDLE  hPort,
    LPBYTE  pBuffer,
    DWORD   cbBuf,
    LPDWORD pcbRead
    );

BOOL
FaxMonEnumPorts(
    LPTSTR  pServerName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pReturned
    );

BOOL
FaxMonAddPort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonAddPortEx(
    LPTSTR  pServerName,
    DWORD   level,
    LPBYTE  pBuffer,
    LPTSTR  pMonitorName
    );

BOOL
FaxMonDeletePort(
    LPTSTR  pServerName,
    HWND    hwnd,
    LPTSTR  pPortName
    );

BOOL
FaxMonConfigurePort(
    LPWSTR  pServerName,
    HWND    hwnd,
    LPWSTR  pPortName
    );

//
// Get the list of fax devices from the service
//

PFAX_PORT_INFO
MyFaxEnumPorts(
    LPDWORD pcPorts,
    BOOL    useCache
    );

//
// Wrapper function for fax service's FaxGetPort API
//

PFAX_PORT_INFO
MyFaxGetPort(
    LPTSTR  pPortName,
    BOOL    useCache
    );

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Update the status information of a print job
//

BOOL
SetJobStatus(
    HANDLE  hPrinter,
    DWORD   jobId,
    INT     statusStrId
    );

//
// Wrapper function for spooler API GetJob
//

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    );

//
// Create a temporary file in the system spool directory for storing fax data
//

LPTSTR
CreateTempFaxFile(
    LPCTSTR lpctstrPrefix
    );

//
// Open a handle to the current fax job file associated with a port
//

BOOL
OpenTempFaxFile(
    PFAXPORT    pFaxPort,
    BOOL        doAppend
    );

//
// Process fax jobs sent from win31 and win95 clients
//

INT
ProcessDownlevelFaxJob(
    PFAXPORT    pFaxPort
    );


//
// Retrieve a DWORD value from the registry
//

DWORD
GetRegistryDWord(
    HKEY    hRegKey,
    LPTSTR  pValueName,
    DWORD   defaultValue
    );

#define REGVAL_CONNECT_RETRY_COUNT      TEXT("ConnectRetryCount")
#define REGVAL_CONNECT_RETRY_INTERVAL   TEXT("ConnectRetryInterval")


#if DBG

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  A variable which controls the amount of debug messages. To generate
//  lots of debug messages, enter the following line in the debugger:
//
//      ed _debugLevel 1
//
// Verbose
//  Display a debug message if _debugLevel is set to non-zero.
//
//      Verbose(("Entering XYZ: param = %d\n", param));
//
// Error
//  Display an error message along with the filename and the line number
//  to indicate where the error occurred.
//
//      Error(("XYZ failed"));
//
// Assert
//  Verify a condition is true. If not, force a breakpoint.
//
//      Assert(p != NULL && (p->flags & VALID));

extern INT  _debugLevel;
extern VOID DbgPrint(LPCSTR, ...);
extern LPCSTR StripDirPrefixA(LPCSTR);
#if 0
#define Warning(arg) {\
            DbgPrint("WRN %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Error(arg) {\
            DbgPrint("ERR %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Verbose(arg) { if (_debugLevel > 0) DbgPrint arg; }
#endif

#define Trace(funcName) { if (_debugLevel > 0) DebugPrintEx(DEBUG_MSG,TEXT("Entering %s ...\n"), funcName); }





#else   // !DBG

#define Verbose(arg)
//#define Assert(cond)
#define Warning(arg)
#define Error(arg)
#define Trace(funcName)

#endif // DBG

#endif // !_FAXMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxmon\tiffstub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tiffstub.h

Abstract:

    Miminal set of declarations for dealing with TIFF files. We need this in the
    monitor because a fax print job may consist of several TIFF files concatenated
    together. We must patch it up into a single valid TIFF before passing it to
    the fax service.

Environment:

	Windows XP fax print monitor

Revision History:

	02/25/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _TIFFSTUB_H_
#define _TIFFSTUB_H_

//
// Constants for various TIFF data types
//

#define TIFFTYPE_BYTE       1
#define TIFFTYPE_ASCII      2
#define TIFFTYPE_SHORT      3
#define TIFFTYPE_LONG       4
#define TIFFTYPE_RATIONAL   5
#define TIFFTYPE_SBYTE      6
#define TIFFTYPE_UNDEFINED  7
#define TIFFTYPE_SSHORT     8
#define TIFFTYPE_SLONG      9
#define TIFFTYPE_SRATIONAL  10
#define TIFFTYPE_FLOAT      11
#define TIFFTYPE_DOUBLE     12

//
// Constants for TIFF tags which we're interested in
//

#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_STRIPBYTECOUNTS     279

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY;

typedef IFDENTRY UNALIGNED *PIFDENTRY_UNALIGNED;

//
// Data structure for representing an IFD
//

typedef struct {

    WORD        wEntries;
    IFDENTRY    ifdEntries[1];

} IFD;

typedef IFD UNALIGNED *PIFD_UNALIGNED;

//
// Determine whether we're at the beginning of a TIFF file
//

#define ValidTiffFileHeader(p) \
        (((LPSTR) (p))[0] == 'I' && ((LPSTR) (p))[1] == 'I' && \
         ((PBYTE) (p))[2] == 42  && ((PBYTE) (p))[3] == 0)

//
// Read a DWORD value from an unaligned address
//

#define ReadUnalignedDWord(p) *((DWORD UNALIGNED *) (p))

//
// Write a DWORD value to an unaligned address
//

#define WriteUnalignedDWord(p, value) (*((DWORD UNALIGNED *) (p)) = (value))

#endif	// !_TIFFSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\escape.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    escape.c

Abstract:

    Implementation of escape related DDI entry points:
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



ULONG
DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEscape.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface the call is directed to
    iEsc - Specifies a query
    cjIn - Specifies the size in bytes of the buffer pointed to by pvIn
    pvIn - Points to input data buffer
    cjOut - Specifies the size in bytes of the buffer pointed to by pvOut
    pvOut -  Points to the output buffer

Return Value:

    Depends on the query specified by iEsc parameter

--*/

{
    Verbose(("Entering DrvEscape...\n"));

    switch (iEsc) {

    case QUERYESCSUPPORT:

        //
        // Query which escapes are supported: The only escape we support
        // is QUERYESCSUPPORT itself.
        //

        if (cjIn != sizeof(ULONG) || !pvIn) {

            Error(("Invalid input paramaters\n"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return DDI_ERROR;
        }

        if (*((PULONG) pvIn) == QUERYESCSUPPORT)
            return TRUE;

        break;

    default:

        Verbose(("Unsupported iEsc: %d\n", iEsc));
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\perfmon\faxperf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxperf.cpp

Abstract:

    This module contains the fax perfom dll code.

Author:

    Wesley Witt (wesw) 22-Aug-1996

--*/

#include <windows.h>
#include <winperf.h>

#include "faxcount.h"
#include "faxperf.h"
#include "faxreg.h"
#include "faxutil.h"



#define FAX_NUM_PERF_OBJECT_TYPES           1
#define COUNTER_SIZE                        sizeof(DWORD)


#define INBOUND_BYTES_OFFSET                (COUNTER_SIZE                                     )  //   1
#define INBOUND_FAXES_OFFSET                (INBOUND_BYTES_OFFSET               + COUNTER_SIZE)  //   2
#define INBOUND_PAGES_OFFSET                (INBOUND_FAXES_OFFSET               + COUNTER_SIZE)  //   3
#define INBOUND_MINUTES_OFFSET              (INBOUND_PAGES_OFFSET               + COUNTER_SIZE)  //   4
#define INBOUND_FAILED_RECEIVE_OFFSET       (INBOUND_MINUTES_OFFSET             + COUNTER_SIZE)  //   5
#define OUTBOUND_BYTES_OFFSET               (INBOUND_FAILED_RECEIVE_OFFSET      + COUNTER_SIZE)  //   6
#define OUTBOUND_FAXES_OFFSET               (OUTBOUND_BYTES_OFFSET              + COUNTER_SIZE)  //   7
#define OUTBOUND_PAGES_OFFSET               (OUTBOUND_FAXES_OFFSET              + COUNTER_SIZE)  //   8
#define OUTBOUND_MINUTES_OFFSET             (OUTBOUND_PAGES_OFFSET              + COUNTER_SIZE)  //   9
#define OUTBOUND_FAILED_CONNECTIONS_OFFSET  (OUTBOUND_MINUTES_OFFSET            + COUNTER_SIZE)  //  10
#define OUTBOUND_FAILED_XMIT_OFFSET         (OUTBOUND_FAILED_CONNECTIONS_OFFSET + COUNTER_SIZE)  //  11
#define TOTAL_BYTES_OFFSET                  (OUTBOUND_FAILED_XMIT_OFFSET        + COUNTER_SIZE)  //  12
#define TOTAL_FAXES_OFFSET                  (TOTAL_BYTES_OFFSET                 + COUNTER_SIZE)  //  13
#define TOTAL_PAGES_OFFSET                  (TOTAL_FAXES_OFFSET                 + COUNTER_SIZE)  //  14
#define TOTAL_MINUTES_OFFSET                (TOTAL_PAGES_OFFSET                 + COUNTER_SIZE)  //  15
#define LAST_COUNTER_OFFSET                 (TOTAL_MINUTES_OFFSET               + COUNTER_SIZE)  //

#define SIZE_OF_FAX_PERFORMANCE_DATA        LAST_COUNTER_OFFSET

#define PERF_COUNTER_DEFINITION(nm,ty)   \
    {                                    \
        sizeof(PERF_COUNTER_DEFINITION), \
        nm,                              \
        0,                               \
        nm,                              \
        0,                               \
        0,                               \
        PERF_DETAIL_NOVICE,              \
        ty,                              \
        COUNTER_SIZE,                    \
        nm##_OFFSET                      \
    }

#define PERF_COUNTER_INC(nm) \
    FaxDataDefinition.nm##.CounterNameTitleIndex += dwFirstCounter; \
    FaxDataDefinition.nm##.CounterHelpTitleIndex += dwFirstHelp


#pragma pack (4)

typedef struct _FAX_DATA_DEFINITION {
    PERF_OBJECT_TYPE            FaxObjectType;
    PERF_COUNTER_DEFINITION     InboundBytes;
    PERF_COUNTER_DEFINITION     InboundFaxes;
    PERF_COUNTER_DEFINITION     InboundPages;
    PERF_COUNTER_DEFINITION     InboundMinutes;
    PERF_COUNTER_DEFINITION     InboundFailedReceive;
    PERF_COUNTER_DEFINITION     OutboundBytes;
    PERF_COUNTER_DEFINITION     OutboundFaxes;
    PERF_COUNTER_DEFINITION     OutboundPages;
    PERF_COUNTER_DEFINITION     OutboundMinutes;
    PERF_COUNTER_DEFINITION     OutboundFailedConnections;
    PERF_COUNTER_DEFINITION     OutboundFailedXmit;
    PERF_COUNTER_DEFINITION     TotalBytes;
    PERF_COUNTER_DEFINITION     TotalFaxes;
    PERF_COUNTER_DEFINITION     TotalPages;
    PERF_COUNTER_DEFINITION     TotalMinutes;
} FAX_DATA_DEFINITION, *PFAX_DATA_DEFINITION;

#pragma pack ()


FAX_DATA_DEFINITION FaxDataDefinition = {
    {
        sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA,
        sizeof(FAX_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        FAXOBJ,
        0,
        FAXOBJ,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(FAX_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/sizeof(PERF_COUNTER_DEFINITION),
        0,
        PERF_NO_INSTANCES,
        0,
    },

    PERF_COUNTER_DEFINITION( INBOUND_BYTES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAXES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_PAGES,                      PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_MINUTES,                    PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( INBOUND_FAILED_RECEIVE,             PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_BYTES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAXES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_PAGES,                     PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_MINUTES,                   PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_CONNECTIONS,        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( OUTBOUND_FAILED_XMIT,               PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_BYTES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_FAXES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_PAGES,                        PERF_COUNTER_RAWCOUNT  ),
    PERF_COUNTER_DEFINITION( TOTAL_MINUTES,                      PERF_COUNTER_RAWCOUNT  )

};

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

WCHAR GLOBAL_STRING[]  = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[]  = L"Costly";
WCHAR NULL_STRING[]    = L"\0";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)




DWORD dwOpenCount = 0;
BOOL bInitOK = FALSE;
HANDLE hMap = NULL;
PFAX_PERF_COUNTERS pPerfCounters = NULL;


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0)
    {
        return QUERY_GLOBAL;
    }
    else if (*lpValue == 0)
    {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0))
    {
        if (*pwcArgChar++ != *pwcTypeChar++)
        {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE)
    {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter))
        {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem)
                {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber)
                {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber)
                {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0)
                {
                    return FALSE;
                }
                else
                {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

DWORD APIENTRY
OpenFaxPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the Fax Service to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened


Return Value:

    None.

--*/

{
    LONG            status;
    HKEY            hKeyDriverPerf = NULL;
    DWORD           size;
    DWORD           type;
    DWORD           dwFirstCounter;
    DWORD           dwFirstHelp;
    DEBUG_FUNCTION_NAME(TEXT("OpenFaxPerformanceData"));

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {
        hMap = OpenFileMapping(
            FILE_MAP_READ,
            FALSE,
            FAXPERF_SHARED_MEMORY
            );
        if (NULL == hMap)
        {
            //
            // Maybe the service is down and the memeory mapped file does not exist.
            // Try to create it
            //
            SECURITY_ATTRIBUTES *pSA;
            DWORD Rval;

            pSA = CreateSecurityAttributesWithThreadAsOwner (FILE_MAP_READ);
            if (!pSA)
            {
                Rval = GetLastError ();
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CreateSecurityAttributesWithThreadAsOwner() failed. (ec: %ld)"),
                        Rval);
            }
            else
            {
                hMap = CreateFileMapping(
                    INVALID_HANDLE_VALUE,
                    pSA,
                    PAGE_READWRITE | SEC_COMMIT,
                    0,
                    sizeof(FAX_PERF_COUNTERS),
                    FAXPERF_SHARED_MEMORY
                    );
                DestroySecurityAttributes (pSA);
            }

            if (NULL == hMap)
            {
                goto OpenExitPoint;
            }
        }

        pPerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
        if (!pPerfCounters)
        {
            goto OpenExitPoint;
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REGKEY_FAXPERF,
            0L,
            KEY_ALL_ACCESS,
            &hKeyDriverPerf
            );

        if (status != ERROR_SUCCESS)
        {
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Counter",
            0L,
            &type,
            (LPBYTE)&dwFirstCounter,
            &size
            );

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
            hKeyDriverPerf,
            "First Help",
            0L,
            &type,
            (LPBYTE)&dwFirstHelp,
            &size
            );

        if (status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto OpenExitPoint;
        }

        FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex += dwFirstCounter;
        FaxDataDefinition.FaxObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        PERF_COUNTER_INC( InboundBytes              );
        PERF_COUNTER_INC( InboundFaxes              );
        PERF_COUNTER_INC( InboundPages              );
        PERF_COUNTER_INC( InboundMinutes            );
        PERF_COUNTER_INC( InboundFailedReceive      );
        PERF_COUNTER_INC( OutboundBytes             );
        PERF_COUNTER_INC( OutboundFaxes             );
        PERF_COUNTER_INC( OutboundPages             );
        PERF_COUNTER_INC( OutboundMinutes           );
        PERF_COUNTER_INC( OutboundFailedConnections );
        PERF_COUNTER_INC( OutboundFailedXmit        );
        PERF_COUNTER_INC( TotalBytes                );
        PERF_COUNTER_INC( TotalFaxes                );
        PERF_COUNTER_INC( TotalPages                );
        PERF_COUNTER_INC( TotalMinutes              );

        RegCloseKey (hKeyDriverPerf); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }

    InterlockedIncrement( (PLONG)&dwOpenCount); // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    if (!bInitOK)
    {
        if (hKeyDriverPerf)
        {
            RegCloseKey (hKeyDriverPerf);
        }

        if (pPerfCounters)
        {
            UnmapViewOfFile(pPerfCounters);
        }

        if (hMap)
        {
            CloseHandle( hMap );
        }

    }

    //
    // the performance APIs log an error in eventvwr if you fail this call
    // so we always return ERROR_SUCCESS so we don't clutter the logs
    //
    //return status;
    return ERROR_SUCCESS;
}

DWORD APIENTRY
CollectFaxPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the Fax counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    LPDWORD             pData;
    ULONG               SpaceNeeded;
    DWORD               dwQueryType;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if (!(IsNumberInUnicodeList (FaxDataDefinition.FaxObjectType.ObjectNameTitleIndex, lpValueName)))
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            return ERROR_SUCCESS;
        }
    }

    SpaceNeeded = sizeof(FAX_DATA_DEFINITION) + SIZE_OF_FAX_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        return ERROR_MORE_DATA;
    }

    pData = (LPDWORD) *lppData;

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    CopyMemory(
        pData,
        &FaxDataDefinition,
        sizeof(FAX_DATA_DEFINITION)
        );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_DATA_DEFINITION));

    //
    //  Format and collect Fax data from the service
    //

    *pData = SIZE_OF_FAX_PERFORMANCE_DATA;
    pData += 1;

    CopyMemory( pData, pPerfCounters, sizeof(FAX_PERF_COUNTERS) );
    pData = (LPDWORD)((LPBYTE)pData + sizeof(FAX_PERF_COUNTERS));

    *lpNumObjectTypes = FAX_NUM_PERF_OBJECT_TYPES;
    *lpcbTotalBytes = (DWORD)((LPBYTE)pData - (LPBYTE)*lppData);
    *lppData = (PVOID) pData;

    return ERROR_SUCCESS;
}


DWORD APIENTRY
CloseFaxPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Fax performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    InterlockedDecrement( (PLONG)&dwOpenCount );

    if ((dwOpenCount == 0) && bInitOK)
    {
        if (pPerfCounters)
        {
            UnmapViewOfFile(pPerfCounters);
            pPerfCounters = NULL;
        }

        if (hMap)
        {
            CloseHandle( hMap );
            hMap = NULL;
        }

        bInitOK = FALSE;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\sources.inc ===
!IF 0

Copyright (c) 1989-1995 Microsoft Corporation

!ENDIF

!include ..\..\..\..\faxsrc.inc

TARGETPATH=obj
DLLDEF=..\faxdrv.def

INCLUDES=..;..\..\inc;$(INCLUDES)

TARGETLIBS=$(TARGETLIBS) \
    $(BASEDIR)\public\sdk\lib\*\libcntpr.lib

C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -DUSELSB

SOURCES=..\enable.c    \
        ..\escape.c    \
        ..\page.c      \
        ..\faxtiff.c   \
        ..\faxdrv.rc

PRECOMPILED_INCLUDE=..\faxdrv.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\archfldr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    archfldr.c

Abstract:

    Property sheet handler for "Archive folder" page and "Remote" page

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

INT_PTR 
CALLBACK 
ArchiveInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the archive folder tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    DWORD   dwRes = 0;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            PFAX_ARCHIVE_CONFIG     pFaxArchiveConfig;

            SetLTREditDirection(hDlg, IDC_OUTGOING_FOLDER);
            SetLTREditDirection(hDlg, IDC_INCOMING_FOLDER);

            // set edit box text limit
            SendDlgItemMessage(hDlg, IDC_INCOMING_FOLDER, EM_SETLIMITTEXT, MAX_PATH - 1, 0);
            SendDlgItemMessage(hDlg, IDC_OUTGOING_FOLDER, EM_SETLIMITTEXT, MAX_PATH - 1, 0);

            if(!Connect(hDlg, TRUE))
            {
                return TRUE;
            }

            // load incoming archive folder info
            if(FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, &pFaxArchiveConfig))
            {
                CheckDlgButton(hDlg, IDC_INCOMING, pFaxArchiveConfig->bUseArchive ? BST_CHECKED : BST_UNCHECKED);
                SetDlgItemText(hDlg, IDC_INCOMING_FOLDER, pFaxArchiveConfig->lpcstrFolder);
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER), IsDlgButtonChecked(hDlg, IDC_INCOMING));
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER_BR), IsDlgButtonChecked(hDlg, IDC_INCOMING));
                }
                FaxFreeBuffer(pFaxArchiveConfig);
            }
            else
            {
                dwRes = GetLastError();
                Error(("FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                goto Exit;
            }

            // load incoming archive folder info
            if(FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, &pFaxArchiveConfig))
            {
                CheckDlgButton(hDlg, IDC_OUTGOING, pFaxArchiveConfig->bUseArchive ? BST_CHECKED : BST_UNCHECKED);
                SetDlgItemText(hDlg, IDC_OUTGOING_FOLDER, pFaxArchiveConfig->lpcstrFolder);
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), IsDlgButtonChecked(hDlg, IDC_OUTGOING));
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER_BR), IsDlgButtonChecked(hDlg, IDC_OUTGOING));
                }
                FaxFreeBuffer(pFaxArchiveConfig);
            }
            else
            {
                dwRes = GetLastError();
                Error(( "FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                goto Exit;
            }

            SHAutoComplete (GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), SHACF_FILESYSTEM);
            SHAutoComplete (GetDlgItem(hDlg, IDC_INCOMING_FOLDER), SHACF_FILESYSTEM);

Exit:
            DisConnect();

            if (dwRes != 0)
            {
                DisplayErrorMessage(hDlg, 0, dwRes);
                return TRUE;
            }

            if(!g_bUserCanChangeSettings)
            {
                PageEnable(hDlg, FALSE);
            }

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_INCOMING_FOLDER:
            case IDC_OUTGOING_FOLDER:
            
                if(HIWORD(wParam) == EN_CHANGE) // notification code
                {      
                    Notify_Change(hDlg);
                }

                if (HIWORD(wParam) == EN_KILLFOCUS) 
                {
                    TCHAR szFolder[MAX_PATH * 2];
                    TCHAR szResult[MAX_PATH * 2];
                    //
                    // Edit control lost its focus
                    //
                    GetDlgItemText (hDlg, LOWORD(wParam), szFolder, ARR_SIZE(szFolder));
                    if (lstrlen (szFolder))
                    {
                        if (GetFullPathName(szFolder, ARR_SIZE(szResult), szResult, NULL))
                        {
                            PathMakePretty (szResult);
                            SetDlgItemText (hDlg, LOWORD(wParam), szResult);
                        }
                    }
                }
                break;                    

            case IDC_INCOMING:
            case IDC_OUTGOING:

                if( HIWORD(wParam) == BN_CLICKED ) // notification code
                {
                    BOOL    bEnabled;

                    if(LOWORD(wParam) == IDC_INCOMING)
                    {
                        bEnabled = IsDlgButtonChecked(hDlg, IDC_INCOMING);
                        EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER), bEnabled);
                        EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER_BR), bEnabled);
                    }
                    else
                    {
                        bEnabled = IsDlgButtonChecked(hDlg, IDC_OUTGOING);
                        EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), bEnabled);
                        EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER_BR), bEnabled);
                    }

                    Notify_Change(hDlg);
                }

                break;                    

            case IDC_INCOMING_FOLDER_BR:
            case IDC_OUTGOING_FOLDER_BR:
            {
                TCHAR   szTitle[MAX_TITLE_LEN];
                BOOL    bResult;

                if(!LoadString(ghInstance, IDS_BROWSE_FOLDER, szTitle, MAX_TITLE_LEN))
                {
                    Error(( "LoadString failed, string ID is %d.\n", IDS_BROWSE_FOLDER ));
                }

                if( LOWORD(wParam) == IDC_INCOMING_FOLDER_BR )
                {
                    bResult = BrowseForDirectory(hDlg, IDC_INCOMING_FOLDER, szTitle);
                }
                else
                {
                    bResult = BrowseForDirectory(hDlg, IDC_OUTGOING_FOLDER, szTitle);
                }

                if(bResult) 
                {
                    Notify_Change(hDlg);
                }

                break;
            }

            default:
                break;
        }

        break;

    case WM_NOTIFY:
    {

        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {
            case PSN_APPLY:
            {
                PFAX_ARCHIVE_CONFIG     pFaxArchiveConfig = NULL;
                BOOL                    bEnabled;
                TCHAR                   szArchiveFolder[MAX_PATH] = {0};
                HWND                    hControl;
                DWORD                   dwRes = 0;

                // if the user only has read permission, return immediately
                if(!g_bUserCanChangeSettings)
                {
                    return TRUE;
                }

                // check the validaty of edit box if they are enabled.
                if(IsDlgButtonChecked(hDlg, IDC_INCOMING))
                {
                    hControl = GetDlgItem(hDlg, IDC_INCOMING_FOLDER);
                    GetWindowText(hControl, szArchiveFolder, MAX_PATH);

                    if (PathIsRelative (szArchiveFolder) ||
                        !DirectoryExists(szArchiveFolder))
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SendMessage(hControl, EM_SETSEL, 0, -1);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    szArchiveFolder[0] = 0; // set string to empty string
                }

                if(IsDlgButtonChecked(hDlg, IDC_OUTGOING))
                {
                    hControl = GetDlgItem(hDlg, IDC_OUTGOING_FOLDER);
                    GetWindowText(hControl, szArchiveFolder, MAX_PATH);

                    // if(lstrlen(szArchiveFolder) == 0)
                    if( !DirectoryExists(szArchiveFolder) )
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SendMessage(hControl, EM_SETSEL, 0, -1);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    szArchiveFolder[0] = 0; // set string to empty string
                }

                if(!Connect(hDlg, TRUE))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    return TRUE;
                }

                //
                // save incoming archive folder info
                //
                if(!FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, &pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(( "FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                bEnabled = (IsDlgButtonChecked(hDlg, IDC_INCOMING) == BST_CHECKED);
                GetDlgItemText(hDlg, IDC_INCOMING_FOLDER, szArchiveFolder, MAX_PATH);
                ValidatePath(szArchiveFolder);

                pFaxArchiveConfig->bUseArchive = bEnabled;
                pFaxArchiveConfig->lpcstrFolder = szArchiveFolder;

                if (!FaxSetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxSetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                FaxFreeBuffer(pFaxArchiveConfig);
                pFaxArchiveConfig = NULL;

                //
                // save outgoing archive folder info
                //

                if(!FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, &pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                bEnabled = (IsDlgButtonChecked(hDlg, IDC_OUTGOING) == BST_CHECKED);
                GetDlgItemText(hDlg, IDC_OUTGOING_FOLDER, szArchiveFolder, MAX_PATH);
                ValidatePath(szArchiveFolder);
                
                pFaxArchiveConfig->bUseArchive = bEnabled;
                pFaxArchiveConfig->lpcstrFolder = szArchiveFolder;
                
                if(!FaxSetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxSetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                Notify_UnChange(hDlg);

ApplyExit:
                DisConnect();

                if (pFaxArchiveConfig)
                {
                    FaxFreeBuffer(pFaxArchiveConfig);
                }

                if (dwRes != 0)
                {
                    DisplayErrorMessage(hDlg, 0, dwRes);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                }

                return TRUE;
            }

            default :
                break;
        } // switch

        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}

INT_PTR  
CALLBACK 
RemoteInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the archive folder tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\enable.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of device and surface related DDI entry points:

        DrvEnableDriver
        DrvDisableDriver
        DrvEnablePDEV
        DrvResetPDEV
        DrvCompletePDEV
        DrvDisablePDEV
        DrvEnableSurface
        DrvDisableSurface
        DrvBitBlt
        DrvStretchBlt
        DrvDitherColor
        DrvEscape

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"
#include "forms.h"

#define CLOSE_HANDLE(h)     if (!CloseHandle(h)) Error(("CloseHandle failed: %d.\n", GetLastError()))

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

static DRVFN FaxDriverFuncs[] =
{
    { INDEX_DrvEnablePDEV,          (PFN) DrvEnablePDEV         },
    { INDEX_DrvResetPDEV,           (PFN) DrvResetPDEV          },
    { INDEX_DrvCompletePDEV,        (PFN) DrvCompletePDEV       },
    { INDEX_DrvDisablePDEV,         (PFN) DrvDisablePDEV        },
    { INDEX_DrvEnableSurface,       (PFN) DrvEnableSurface      },
    { INDEX_DrvDisableSurface,      (PFN) DrvDisableSurface     },

    { INDEX_DrvStartDoc,            (PFN) DrvStartDoc           },
    { INDEX_DrvEndDoc,              (PFN) DrvEndDoc             },
    { INDEX_DrvStartPage,           (PFN) DrvStartPage          },
    { INDEX_DrvSendPage,            (PFN) DrvSendPage           },

    { INDEX_DrvBitBlt,              (PFN) DrvBitBlt             },
    { INDEX_DrvStretchBlt,          (PFN) DrvStretchBlt         },
    { INDEX_DrvCopyBits,            (PFN) DrvCopyBits           },
    { INDEX_DrvDitherColor,         (PFN) DrvDitherColor        },
    { INDEX_DrvEscape,              (PFN) DrvEscape             },
};

//
// Forward declaration of local functions
//

VOID SelectPrinterForm(PDEVDATA);
BOOL FillDevInfo(PDEVDATA, ULONG, PVOID);
BOOL FillGdiInfo(PDEVDATA, ULONG, PVOID);
VOID FreeDevData(PDEVDATA);



HINSTANCE   ghInstance;


BOOL
DllEntryPoint(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
    case DRVQUERY_USERMODE:

        Assert(pcbNeeded != NULL);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;

    default:

        Error(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}



BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pDrvEnableData
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    iEngineVersion - Specifies the DDI version number that GDI is written for
    cb - Size of the buffer pointed to by pDrvEnableData
    pDrvEnableData - Points to an DRVENABLEDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvEnableDriver...\n"));

    //
    // Make sure we have a valid engine version and
    // we're given enough room for the DRVENABLEDATA.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4 || cb < sizeof(DRVENABLEDATA)) {

        Error(("DrvEnableDriver failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }

    //
    // Fill in the DRVENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = DDI_DRIVER_VERSION_NT4;
    pDrvEnableData->c = sizeof(FaxDriverFuncs) / sizeof(DRVFN);
    pDrvEnableData->pdrvfn = FaxDriverFuncs;

    return TRUE;
}



DHPDEV
DrvEnablePDEV(
    PDEVMODE  pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pGdiInfo,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    pdm - Points to a DEVMODE structure that contains driver data
    pLogAddress - Points to the logical address string
    cPatterns - Specifies the number of standard patterns
    phsurfPatterns - Buffer to hold surface handles to standard patterns
    cjGdiInfo - Size of GDIINFO buffer
    pGdiInfo - Points to a GDIINFO structure
    cjDevInfo - Size of DEVINFO buffer
    pDevInfo - Points to a DEVINFO structure
    hdev - GDI device handle
    pDeviceName - Points to device name string
    hPrinter - Spooler printer handle

Return Value:

    Driver device handle, NULL if there is an error

--*/

{
    PDEVDATA    pdev;
#ifndef USERMODE_DRIVER
    ULONG       ul;
#endif

    Verbose(("Entering DrvEnablePDEV...\n"));

    //
    // Allocate memory for our DEVDATA structure and initialize it
    //
    if (! (pdev = MemAllocZ(sizeof(DEVDATA)))) {

        Error(("Memory allocation failed\n"));
        return NULL;
    }

    pdev->hPrinter = hPrinter;
    pdev->bPrintPreview = FALSE;
    pdev->hPreviewMapping = NULL;

#ifdef USERMODE_DRIVER
    pdev->hPreviewFile = INVALID_HANDLE_VALUE;
#endif

    pdev->pTiffPageHeader = NULL;
    pdev->pbTiffPageFP = NULL;
    pdev->startDevData = pdev;
    pdev->endDevData = pdev;

    //
    // Save and validate DEVMODE information
    //  start with the driver default
    //  then merge with the system default
    //  finally merge with the input devmode
    //

    if (CurrentVersionDevmode(pdm)) {

        memcpy(&pdev->dm, pdm, sizeof(DRVDEVMODE));

        //
        // NOTE: We now use dmPrintQuality and dmYResolution fields
        // to store the resolution measured in dots-per-inch. Add
        // the following check as a safety precaution in case older
        // DEVMODE is passed to us.
        //

        if (pdev->dm.dmPublic.dmPrintQuality <= 0 ||
            pdev->dm.dmPublic.dmYResolution <= 0)
        {
            pdev->dm.dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
            pdev->dm.dmPublic.dmYResolution = FAXRES_VERTICAL;
        }

        //
        // Check if we were given a mapping file
        //
        if (pdev->dm.dmPrivate.szMappingFile[0] != TEXT('\0'))
        {
            //
            // Load the preview file image:
            //
            // In user mode this is done by - CreateFile(), CreateFileMapping() and MapViewOfFile().
            // In kernel mode this is done by - EngLoadModuleForWrite() and EngMapModule().
            //

#ifdef USERMODE_DRIVER

            //
            // First, open the file
            //
            if ( INVALID_HANDLE_VALUE == (pdev->hPreviewFile = CreateFile(
                        pdev->dm.dmPrivate.szMappingFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_TEMPORARY,
                        NULL)) )
            {
                Error(("Failed opening mapping file.\n"));
            }
            else
            {
                //
                // Then create a mapping object
                //
                pdev->hPreviewMapping = CreateFileMapping(
                    pdev->hPreviewFile,                     // handle to file
                    NULL,                                   // security
                    PAGE_READWRITE,                         // protection
                    0,                                      // high-order DWORD of size
                    MAX_TIFF_PAGE_SIZE,                     // low-order DWORD of size
                    NULL                                    // object name
                    );
#else
                //
                // First, load the file image
                //
                pdev->hPreviewMapping = EngLoadModuleForWrite(pdev->dm.dmPrivate.szMappingFile, 0);
#endif

                if (pdev->hPreviewMapping)
                {
                    //
                    // Now, open a view to the image in our address space
                    //

#ifdef USERMODE_DRIVER
                    pdev->pTiffPageHeader = (PMAP_TIFF_PAGE_HEADER) MapViewOfFile(
                        pdev->hPreviewMapping,              // handle to file-mapping object
                        FILE_MAP_WRITE,                     // access mode
                        0,                                  // high-order DWORD of offset
                        0,                                  // low-order DWORD of offset
                        0                                   // number of bytes to map
                        );
                    if ( (NULL != pdev->pTiffPageHeader) && 
                         (sizeof(MAP_TIFF_PAGE_HEADER) == pdev->pTiffPageHeader->cb) )
#else
                    pdev->pTiffPageHeader = 
                                (PMAP_TIFF_PAGE_HEADER) EngMapModule(pdev->hPreviewMapping, &ul);
                    if ( (NULL != pdev->pTiffPageHeader) && 
                         (MAX_TIFF_PAGE_SIZE == ul)      &&
                         (sizeof(MAP_TIFF_PAGE_HEADER) == pdev->pTiffPageHeader->cb) )
#endif
                    {
                        //
                        // Sucess
                        //
                        pdev->bPrintPreview = pdev->pTiffPageHeader->bPreview;
                        pdev->pbTiffPageFP = (LPBYTE) (pdev->pTiffPageHeader + 1);
                    }
                    else
                    {
                        Error(("Failed opening view.\n"));

#ifdef USERMODE_DRIVER
                        if (pdev->pTiffPageHeader)
                        {
                            UnmapViewOfFile(pdev->pTiffPageHeader);
                        }
                        CLOSE_HANDLE(pdev->hPreviewMapping);
                        CLOSE_HANDLE(pdev->hPreviewFile);
                        pdev->hPreviewFile = NULL;
#else
                        EngFreeModule(pdev->hPreviewMapping);
#endif
                        pdev->hPreviewMapping = NULL;
                        pdev->pTiffPageHeader = NULL;
                    }
                }
                else
                {
                    Error(("Failed mapping file: %s.\n", pdev->dm.dmPrivate.szMappingFile));

#ifdef USERMODE_DRIVER
                    // Close the file handle
                    CLOSE_HANDLE(pdev->hPreviewFile);
                    pdev->hPreviewFile = NULL;
#endif
                }

#ifdef USERMODE_DRIVER
            }
#endif

        }
        else
        {
            Warning(("No mapping file specified.\n"));
        }
    } else {

        Error(("Bad DEVMODE passed to DrvEnablePDEV\n"));
        DriverDefaultDevmode(&pdev->dm, NULL, hPrinter);
    }

    //
    // Calculate the paper size information
    //

    SelectPrinterForm(pdev);

    //
    // Fill out GDIINFO and DEVINFO structure
    //

    if (! FillGdiInfo(pdev, cjGdiInfo, pGdiInfo) ||
        ! FillDevInfo(pdev, cjDevInfo, pDevInfo))
    {
        FreeDevData(pdev);
        return NULL;
    }

    //
    // Zero out the array of HSURF's so that the engine will
    // automatically simulate the standard patterns for us
    //

    memset(phsurfPatterns, 0, sizeof(HSURF) * cPatterns);

    //
    // Return a pointer to our DEVDATA structure
    //

    return (DHPDEV) pdev;
}



BOOL
DrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvResetPDEV.
    Please refer to DDK documentation for more details.

Arguments:

    phpdevOld - Driver handle to the old device
    phpdevNew - Driver handle to the new device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdevOld, pdevNew;

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Validate both old and new device
    //

    pdevOld = (PDEVDATA) dhpdevOld;
    pdevNew = (PDEVDATA) dhpdevNew;

    if (! ValidDevData(pdevOld) || ! ValidDevData(pdevNew)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Verbose(("Entering DrvResetPDEV...\n"));

    //
    // Transfer information from old device to new device
    //

    if (pdevOld->pageCount != 0) {

        pdevNew->pageCount = pdevOld->pageCount;
        pdevNew->flags |= PDEV_RESETPDEV;
        pdevNew->fileOffset = pdevOld->fileOffset;

        if (pdevOld->pFaxIFD) {

            pdevNew->pFaxIFD = pdevOld->pFaxIFD;
            pdevOld->pFaxIFD = NULL;
        }
    }

    //
    // Carry over relevant flag bits
    //
    pdevNew->flags |= pdevOld->flags & PDEV_CANCELLED;
    return TRUE;
}



VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCompletePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    hdev - GDI device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvCompletePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Remember the engine's handle to the physical device
    //

    pdev->hdev = hdev;
}



HSURF
DrvEnableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    Handle to newly created surface, NULL if there is an error

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;
    FLONG       flHooks;

    Verbose(("Entering DrvEnableSurface...\n"));

    //
    // Validate the pointer to our DEVDATA structure
    //

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Adjust the bitmap size so that we always end up with 1728 pixels per scanline
    //

    Assert(MAX_WIDTH_PIXELS % DWORDBITS == 0);

    if (IsLandscapeMode(pdev)) {

        Assert(pdev->imageSize.cy <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cy = MAX_WIDTH_PIXELS;
        pdev->imageSize.cx = ((pdev->imageSize.cx + (BYTEBITS - 1)) / BYTEBITS) * BYTEBITS;

    } else {

        Assert(pdev->imageSize.cx <= MAX_WIDTH_PIXELS);
        pdev->imageSize.cx = MAX_WIDTH_PIXELS;
    }

    pdev->lineOffset = PadBitsToBytes(pdev->imageSize.cx, sizeof(DWORD));

    //
    // Call the engine to create a standard bitmap surface for us
    //

    pdev->hbitmap = (HSURF) EngCreateBitmap(pdev->imageSize,
                                            pdev->lineOffset,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT | BMF_USERMEM,
                                            NULL);

    if (pdev->hbitmap == NULL) {

        Error(("EngCreateBitmap failed\n"));
        return NULL;
    }

    //
    // Associate the surface with the device and inform the
    // engine which functions we have hooked out
    //

    if (pdev->dm.dmPrivate.flags & FAXDM_NO_HALFTONE)
        flHooks = 0;
    else
        flHooks = (HOOK_STRETCHBLT | HOOK_BITBLT | HOOK_COPYBITS);

    EngAssociateSurface(pdev->hbitmap, pdev->hdev, flHooks);

    //
    // Return the surface handle to the engine
    //

    return pdev->hbitmap;
}



VOID
DrvDisableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisableSurface...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Call the engine to delete the surface handle
    //

    if (pdev->hbitmap != NULL) {

        EngDeleteSurface(pdev->hbitmap);
        pdev->hbitmap = NULL;
    }
}



VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{
    PDEVDATA    pdev = (PDEVDATA) dhpdev;

    Verbose(("Entering DrvDisablePDEV...\n"));

    if (! ValidDevData(pdev)) {

        Assert(FALSE);
        return;
    }

    //
    // Free up memory allocated for the current PDEV
    //
    FreeDevData(pdev);
}



VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    Verbose(("Entering DrvDisableDriver...\n"));
}



BOOL
IsCompatibleSurface(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    XLATEOBJ   *pxlo
    )

/*++

Routine Description:

    Check if the source surface is compatible with the destination surface
    i.e. we can bitblt without halftonig

Arguments:

    psoDst - Specifies the destination surface
    psoSrc - Specifies the source surface
    pxlo - How to transform colors between the source surface and the destination surface

Return Value:

    TRUE if the source surface is compatible with the destination surface
    FALSE otherwise

--*/

{
    BOOL result;

    //
    // We know our destination surface is always 1bpp
    //

    Assert(psoDst->iBitmapFormat == BMF_1BPP);

    //
    // Check whether the transformation is trivial
    //

    if (!pxlo || (pxlo->flXlate & XO_TRIVIAL)) {

        result = (psoSrc->iBitmapFormat == psoDst->iBitmapFormat);

    } else if ((pxlo->flXlate & XO_TABLE) && pxlo->cEntries <= 2) {
        
        ULONG srcPalette[2];

        srcPalette[0] = srcPalette[1] = RGB_BLACK;
        XLATEOBJ_cGetPalette(pxlo, XO_SRCPALETTE, pxlo->cEntries, srcPalette);

        result = (srcPalette[0] == RGB_BLACK || srcPalette[0] == RGB_WHITE) &&
                 (srcPalette[1] == RGB_BLACK || srcPalette[1] == RGB_WHITE);

    } else
        result = FALSE;

    return result;
}



BOOL
DrvCopyBits(
    SURFOBJ    *psoTrg,   
    SURFOBJ    *psoSrc,    
    CLIPOBJ    *pco,   
    XLATEOBJ   *pxlo, 
    RECTL      *prclDst, 
    POINTL     *pptlSrc 
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    Verbose(("Entering DrvCopyBits ...\n"));
    
    //
    // Check if halftoning is necessary
    // If not, let the engine handle it
    //

    if ((psoSrc->iType != STYPE_BITMAP) ||
        (psoTrg->iType != STYPE_BITMAP) ||
        IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        return EngCopyBits(psoTrg, psoSrc, pco, pxlo, prclDst, pptlSrc);
    }
    else
    {
        POINTL  ptlBrushOrg;
        RECTL   rclDst, rclSrc;

        ptlBrushOrg.x = ptlBrushOrg.y = 0;

        rclDst        = *prclDst;
        rclSrc.left   = pptlSrc->x;
        rclSrc.top    = pptlSrc->y;
        rclSrc.right  = rclSrc.left + (rclDst.right - rclDst.left);
        rclSrc.bottom = rclSrc.top  + (rclDst.bottom - rclDst.top);

        if ((rclSrc.right > psoSrc->sizlBitmap.cx) ||
            (rclSrc.bottom > psoSrc->sizlBitmap.cy))
        {
            rclSrc.right  = psoSrc->sizlBitmap.cx;
            rclSrc.bottom = psoSrc->sizlBitmap.cy;
            rclDst.right  = rclDst.left + (rclSrc.right - rclSrc.left);
            rclDst.bottom = rclDst.top  + (rclSrc.bottom - rclSrc.top);
        }

        return EngStretchBlt(psoTrg,
                             psoSrc,
                             NULL,
                             pco,
                             pxlo,
                             &DefHTClrAdj,
                             &ptlBrushOrg,
                             &rclDst,
                             &rclSrc,
                             NULL,
                             HALFTONE);
    }
}



BOOL
DrvBitBlt(
    SURFOBJ    *psoTrg,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclTrg,
    POINTL     *pptlSrc,
    POINTL     *pptlMask,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrush,
    ROP4        rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    COLORADJUSTMENT *pca;
    PDEVDATA        pdev;
    DWORD           rop3Foreground, rop3Background;
    SURFOBJ         *psoNewSrc;
    HBITMAP         hbmpNewSrc;
    POINTL          brushOrg;
    BOOL            result;

    Verbose(("Entering DrvBitBlt...\n"));
    
    //
    // Validate input parameters
    //

    Assert(psoTrg != NULL);
    pdev = (PDEVDATA) psoTrg->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Use the system default color adjustment information
    //

    pca = &DefHTClrAdj;

    //
    // Figure out the foreground and background ROP3
    //

    psoNewSrc = NULL;
    hbmpNewSrc = NULL;
    rop3Foreground = GetForegroundRop3(rop4);
    rop3Background = GetBackgroundRop3(rop4);

    if ((Rop3NeedPattern(rop3Foreground) || Rop3NeedPattern(rop3Background)) && pptlBrush) {

        brushOrg = *pptlBrush;

    } else {

        brushOrg.x = brushOrg.y = 0;
    }

    //
    // If a source bitmap is involved in the raster operation and
    // the source is not compatible with the destination surface,
    // then we'll halftone the source bitmap into a new bitmap and
    // bitblt the new bitmap onto the destination surface.
    //

    if ((Rop3NeedSource(rop3Foreground) || Rop3NeedSource(rop3Background)) &&
        !IsCompatibleSurface(psoTrg, psoSrc, pxlo))
    {
        RECTL   rclNewSrc, rclOldSrc;
        SIZEL   bmpSize;
        LONG    lDelta;

        rclNewSrc.left = rclNewSrc.top = 0;
        rclNewSrc.right = prclTrg->right - prclTrg->left;
        rclNewSrc.bottom = prclTrg->bottom - prclTrg->top;

        rclOldSrc.left = pptlSrc->x;
        rclOldSrc.top = pptlSrc->y;
        rclOldSrc.right = rclOldSrc.left + rclNewSrc.right;
        rclOldSrc.bottom = rclOldSrc.top + rclNewSrc.bottom;

        //
        // Express path for the most common case: SRCCOPY
        //

        if (rop4 == 0xcccc) {

            return EngStretchBlt(psoTrg,
                                 psoSrc,
                                 psoMask,
                                 pco,
                                 pxlo,
                                 pca,
                                 &brushOrg,
                                 prclTrg,
                                 &rclOldSrc,
                                 pptlMask,
                                 HALFTONE);
        }

        //
        // Modify the brush origin, because when we blt to the clipped bitmap
        // the origin is at bitmap's (0, 0) minus the original location
        //

        brushOrg.x -= prclTrg->left;
        brushOrg.y -= prclTrg->top;

        //
        // Create a temporary bitmap surface
        // Halftone the source bitmap into the temporary bitmap
        //

        Assert(psoTrg->iBitmapFormat == BMF_1BPP);

        bmpSize.cx = rclNewSrc.right;
        bmpSize.cy = rclNewSrc.bottom;
        lDelta = PadBitsToBytes(bmpSize.cx, sizeof(DWORD));

        if (! (hbmpNewSrc = EngCreateBitmap(bmpSize,
                                            lDelta,
                                            BMF_1BPP,
                                            BMF_TOPDOWN | BMF_NOZEROINIT,
                                            NULL)) ||
            ! EngAssociateSurface((HSURF) hbmpNewSrc, pdev->hdev, 0) ||
            ! (psoNewSrc = EngLockSurface((HSURF) hbmpNewSrc)) ||
            ! EngStretchBlt(psoNewSrc,
                            psoSrc,
                            NULL,
                            NULL,
                            pxlo,
                            pca,
                            &brushOrg,
                            &rclNewSrc,
                            &rclOldSrc,
                            NULL,
                            HALFTONE))
        {
            if (psoNewSrc)
                EngUnlockSurface(psoNewSrc);
        
            if (hbmpNewSrc)
                EngDeleteSurface((HSURF) hbmpNewSrc);

            return FALSE;
        }

        //
        // Proceed to bitblt from the temporary bitmap to the destination
        //

        psoSrc = psoNewSrc;
        pptlSrc = (PPOINTL) &rclNewSrc.left;
        pxlo = NULL;
        brushOrg.x = brushOrg.y = 0;
    }

    //
    // Let engine do the work
    //

    result = EngBitBlt(psoTrg,
                       psoSrc,
                       psoMask,
                       pco,
                       pxlo,
                       prclTrg,
                       pptlSrc,
                       pptlMask,
                       pbo,
                       &brushOrg,
                       rop4);

    //
    // Clean up properly before returning
    //

    if (psoNewSrc)
        EngUnlockSurface(psoNewSrc);

    if (hbmpNewSrc)
        EngDeleteSurface((HSURF) hbmpNewSrc);

    return result;
}



BOOL
DrvStretchBlt(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    COLORADJUSTMENT  *pca,
    POINTL     *pptlBrushOrg,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    POINTL     *pptlMask,
    ULONG       iMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    We need to hook out this function. Otherwise bitmaps won't be halftoned.

Arguments:

    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    Verbose(("Entering DrvStretchBlt...\n"));

    //
    // If no color adjustment information is provided, use the system default 
    //

    if (pca == NULL)
        pca = &DefHTClrAdj;

    //
    // Let engine do the work; make sure halftone is enabled
    //

    return EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         HALFTONE);
}



ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgb,
    ULONG  *pul
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iMode - Determines the palette to dither against
    rgb - Specifies the RGB color that is to be dithered
    pul - Points to a memory location in which the dithering information is to be recorded

Return Value:

    DCR_HALFTONE to indicate that the engine should create a halftone
    approximation for the driver.

--*/

{
    return DCR_HALFTONE;
}



BOOL
FillDevInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pdevinfo
    )

/*++

Routine Description:

    Fill in the DEVINFO structure pointed to by pdevinfo.

Arguments:

    pdev - Pointer to our DEVDATA structure
    cb - Size of structure pointed to by pdevinfo
    pdevinfo - Pointer to DEVINFO structure

[Notes:]

    Since we have to worry about not writing out more than cb bytes to
    pdevinfo, we will first fill in a local buffer, then copy cb bytes
    to pdevinfo.

Return Value:

    TRUE if successful. FALSE otherwise.

--*/

{
    static ULONG paletteColors[2] = {

        RGB_BLACK,
        RGB_WHITE,
    };

    DEVINFO devinfo;

    memset(&devinfo, 0, sizeof(devinfo));

    //
    // Fill in the graphics capabilities flags: we let the engine
    // do almost everything. Also, we have to tell the engine not
    // to do metafile spooling because we hook out DrvDocumentEvent.
    //

    devinfo.flGraphicsCaps = GCAPS_HALFTONE |
                             GCAPS_MONO_DITHER |
                             GCAPS_COLOR_DITHER |
                             GCAPS_DONTJOURNAL;

    //
    // No device fonts
    //

    devinfo.cFonts = 0;

    //
    // Black and white palette: entry 0 is black and entry 1 is white
    //

    if (! (pdev->hpal = EngCreatePalette(PAL_INDEXED, 2, paletteColors, 0, 0, 0))) {

        Error(("EngCreatePalette failed\n"));
        return FALSE;
    }

    devinfo.hpalDefault = pdev->hpal;
    devinfo.iDitherFormat = BMF_1BPP;
    devinfo.cxDither = devinfo.cyDither = 4;

    //
    // Copy cb bytes from devinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(devinfo))
    {
        memset(pdevinfo, 0, cb);
        memcpy(pdevinfo, &devinfo, sizeof(devinfo));
    }
    else
        memcpy(pdevinfo, &devinfo, cb);

    return TRUE;
}



BOOL
FillGdiInfo(
    PDEVDATA    pdev,
    ULONG       cb,
    PVOID       pgdiinfo
    )

/*++

Routine Description:

    Fill in the device capabilities information for the engine.

Arguments:

    pdev - Pointer to DEVDATA structure
    cb - Size of buffer pointed to by pgdiinfo
    pgdiinfo - Pointer to a GDIINFO buffer

Return Value:

    NONE

--*/

{
    GDIINFO gdiinfo;
    LONG    maxRes;

    memset(&gdiinfo, 0, sizeof(gdiinfo));

    //
    // This field doesn't seem to have any effect for printer drivers.
    // Put our driver version number in there anyway.
    //

    gdiinfo.ulVersion = DRIVER_VERSION;

    //
    // We're raster printers
    //

    gdiinfo.ulTechnology = DT_RASPRINTER;

    //
    // Width and height of the imageable area measured in microns.
    // Remember to turn on the sign bit.
    //

    gdiinfo.ulHorzSize = - (pdev->imageArea.right - pdev->imageArea.left);
    gdiinfo.ulVertSize = - (pdev->imageArea.bottom - pdev->imageArea.top);

    //
    // Convert paper size and imageable area from microns to pixels
    //

    pdev->paperSize.cx = MicronToPixel(pdev->paperSize.cx, pdev->xres);
    pdev->paperSize.cy = MicronToPixel(pdev->paperSize.cy, pdev->yres);

    pdev->imageArea.left = MicronToPixel(pdev->imageArea.left, pdev->xres);
    pdev->imageArea.right = MicronToPixel(pdev->imageArea.right, pdev->xres);
    pdev->imageArea.top = MicronToPixel(pdev->imageArea.top, pdev->yres);
    pdev->imageArea.bottom = MicronToPixel(pdev->imageArea.bottom, pdev->yres);

    pdev->imageSize.cx = pdev->imageArea.right - pdev->imageArea.left;
    pdev->imageSize.cy = pdev->imageArea.bottom - pdev->imageArea.top;

    //
    // Width and height of the imageable area measured in device pixels
    //

    gdiinfo.ulHorzRes = pdev->imageSize.cx;
    gdiinfo.ulVertRes = pdev->imageSize.cy;

    //
    // Color depth information
    //

    gdiinfo.cBitsPixel = 1;
    gdiinfo.cPlanes = 1;
    gdiinfo.ulNumColors = 2;

    //
    // Resolution information
    //

    gdiinfo.ulLogPixelsX = pdev->xres;
    gdiinfo.ulLogPixelsY = pdev->yres;

    //
    // Win31 compatible text capability flags. Are they still used by anyone?
    //

    gdiinfo.flTextCaps = 0;

    //
    // Device pixel aspect ratio
    //

    gdiinfo.ulAspectX = pdev->yres;
    gdiinfo.ulAspectY = pdev->xres;
    gdiinfo.ulAspectXY = CalcHypot(pdev->xres, pdev->yres);

    //
    // Dotted line appears to be approximately 25dpi
    // We assume either xres is a multiple of yres or yres is a multiple of xres
    //

    maxRes = max(pdev->xres, pdev->yres);
    Assert((maxRes % pdev->xres) == 0 && (maxRes % pdev->yres == 0));

    gdiinfo.xStyleStep = maxRes / pdev->xres;
    gdiinfo.yStyleStep = maxRes / pdev->yres;
    gdiinfo.denStyleStep = maxRes / 25;

    //
    // Size and margins of physical surface measured in device pixels
    //

    gdiinfo.szlPhysSize.cx = pdev->paperSize.cx;
    gdiinfo.szlPhysSize.cy = pdev->paperSize.cy;

    gdiinfo.ptlPhysOffset.x = pdev->imageArea.left;
    gdiinfo.ptlPhysOffset.y = pdev->imageArea.top;

    //
    // Use default halftone information
    //

    gdiinfo.ciDevice = DefDevHTInfo.ColorInfo;
    gdiinfo.ulDevicePelsDPI = max(pdev->xres, pdev->yres);
    gdiinfo.ulPrimaryOrder = PRIMARY_ORDER_CBA;
    gdiinfo.ulHTOutputFormat = HT_FORMAT_1BPP;
    gdiinfo.flHTFlags = HT_FLAG_HAS_BLACK_DYE;
    gdiinfo.ulHTPatternSize = HT_PATSIZE_4x4_M;

    //
    // Copy cb byte from gdiinfo structure into the caller-provided buffer
    //

    if (cb > sizeof(gdiinfo))
    {
        memset(pgdiinfo, 0, cb);
        memcpy(pgdiinfo, &gdiinfo, sizeof(gdiinfo));
    }
    else
        memcpy(pgdiinfo, &gdiinfo, cb);

    return TRUE;
}



VOID
FreeDevData(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free up all memory associated with the specified PDEV

Arguments:

    pdev    Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->hpal)
        EngDeletePalette(pdev->hpal);

    //
    // Close our preview file mapping if opened
    //

#ifdef USERMODE_DRIVER

    if (pdev->pTiffPageHeader)
    {
        UnmapViewOfFile(pdev->pTiffPageHeader);
        pdev->pTiffPageHeader = NULL;
    }
    if (pdev->hPreviewMapping)
    {
        CLOSE_HANDLE(pdev->hPreviewMapping);
        pdev->hPreviewMapping = NULL;
    }
    if (INVALID_HANDLE_VALUE != pdev->hPreviewFile)
    {
        CLOSE_HANDLE(pdev->hPreviewFile);
        pdev->hPreviewFile = INVALID_HANDLE_VALUE;
    }

#else

    if (pdev->hPreviewMapping)
    {
        EngFreeModule(pdev->hPreviewMapping);
    }

#endif // USERMODE_DRIVER

    MemFree(pdev->pFaxIFD);
    MemFree(pdev);
}



VOID
SelectPrinterForm(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Store printer paper size information in our DEVDATA structure

Arguments:

    pdev - Pointer to our DEVDATA structure

Return Value:

    NONE

--*/

{
    FORM_INFO_1 formInfo;

    //
    // Validate devmode form specification; use default form if it's invalid.
    //

    if (! ValidDevmodeForm(pdev->hPrinter, &pdev->dm.dmPublic, &formInfo)) {

        memset(&formInfo, 0, sizeof(formInfo));

        //
        // Default to A4 paper
        //

        formInfo.Size.cx = formInfo.ImageableArea.right = A4_WIDTH;
        formInfo.Size.cy = formInfo.ImageableArea.bottom = A4_HEIGHT;
    }

    Assert(formInfo.Size.cx > 0 && formInfo.Size.cy > 0);
    Assert(formInfo.ImageableArea.left >= 0 &&
           formInfo.ImageableArea.top >= 0 &&
           formInfo.ImageableArea.left < formInfo.ImageableArea.right &&
           formInfo.ImageableArea.top < formInfo.ImageableArea.bottom &&
           formInfo.ImageableArea.right <= formInfo.Size.cx &&
           formInfo.ImageableArea.bottom <= formInfo.Size.cy);

    //
    // Take landscape into consideration
    //

    if (IsLandscapeMode(pdev)) {

        LONG    width, height;

        //
        // Swap the width and height
        //

        pdev->paperSize.cy = width = formInfo.Size.cx;
        pdev->paperSize.cx = height = formInfo.Size.cy;

        //
        // Rotate the coordinate system 90 degrees counterclockwise
        //

        pdev->imageArea.left = height - formInfo.ImageableArea.bottom;
        pdev->imageArea.top = formInfo.ImageableArea.left;
        pdev->imageArea.right = height - formInfo.ImageableArea.top;
        pdev->imageArea.bottom = formInfo.ImageableArea.right;

        //
        // Swap x and y resolution
        //
    
        pdev->xres = pdev->dm.dmPublic.dmYResolution;
        pdev->yres = pdev->dm.dmPublic.dmPrintQuality;

    } else {

        pdev->paperSize = formInfo.Size;
        pdev->imageArea = formInfo.ImageableArea;

        pdev->xres = pdev->dm.dmPublic.dmPrintQuality;
        pdev->yres = pdev->dm.dmPublic.dmYResolution;
    }
}



LONG
CalcHypot(
    LONG    x,
    LONG    y
    )

/*++

Routine Description:

    Returns the length of the hypotenouse of a right triangle

Arguments:

    x, y - Edges of the right triangle

Return Value:

    Hypotenouse of the right triangle

--*/

{
    LONG    hypo, delta, target;

    //
    // Take care of negative inputs
    //
    
    if (x < 0)
        x = -x;

    if (y < 0)
        y = -y;

    //
    // use sq(x) + sq(y) = sq(hypo);
    // start with MAX(x, y),
    // use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the target hypotenouse.
    //

    hypo = max(x, y);
    target = min(x, y);
    target *= target;

    for(delta = 0; delta < target; hypo++)
        delta += (hypo << 1) + 1;

    return hypo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\faxtable.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtable.h

Abstract:

    Tables used for Group3 fax compression

Environment:

	Windows XP Fax driver, kernel mode

Revision History:

	01/23/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FAXTABLE_H_
#define _FAXTABLE_H_

//
// Data structure for representing code table entries
//

typedef struct {

    WORD    length;     // code length
    WORD    code;       // code word itself

} CODETABLE;

typedef const CODETABLE *PCODETABLE;

//
// Code word for end-of-line (EOL)
//  000000000001
//

#define EOL_CODE        1
#define EOL_LENGTH      12

//
// Code word for 2D encoding - pass mode
//  0001
//

#define PASSCODE        1
#define PASSCODE_LENGTH 4

//
// Code word for 2D encoding - horizontal mode prefix
//  001
//

#define HORZCODE        1
#define HORZCODE_LENGTH 3

//
// Code word for 2D encoding - vertical mode
//

static const CODETABLE VertCodes[] = {

    {  7, 0x02 },       // 0000010         VL3
    {  6, 0x02 },       // 000010          VL2
    {  3, 0x02 },       // 010             VL1
    {  1, 0x01 },       // 1                V0
    {  3, 0x03 },       // 011             VR1
    {  6, 0x03 },       // 000011          VR2
    {  7, 0x03 },       // 0000011         VR3
};

//
// Code table for white runs
//

static const CODETABLE WhiteRunCodes[] = {
    
    {  8, 0x35 },       // 00110101          0
    {  6, 0x07 },       // 000111            1
    {  4, 0x07 },       // 0111              2
    {  4, 0x08 },       // 1000              3
    {  4, 0x0b },       // 1011              4
    {  4, 0x0c },       // 1100              5
    {  4, 0x0e },       // 1110              6
    {  4, 0x0f },       // 1111              7
    {  5, 0x13 },       // 10011             8
    {  5, 0x14 },       // 10100             9
    {  5, 0x07 },       // 00111            10
    {  5, 0x08 },       // 01000            11
    {  6, 0x08 },       // 001000           12
    {  6, 0x03 },       // 000011           13
    {  6, 0x34 },       // 110100           14
    {  6, 0x35 },       // 110101           15
    {  6, 0x2a },       // 101010           16
    {  6, 0x2b },       // 101011           17
    {  7, 0x27 },       // 0100111          18
    {  7, 0x0c },       // 0001100          19
    {  7, 0x08 },       // 0001000          20
    {  7, 0x17 },       // 0010111          21
    {  7, 0x03 },       // 0000011          22
    {  7, 0x04 },       // 0000100          23
    {  7, 0x28 },       // 0101000          24
    {  7, 0x2b },       // 0101011          25
    {  7, 0x13 },       // 0010011          26
    {  7, 0x24 },       // 0100100          27
    {  7, 0x18 },       // 0011000          28
    {  8, 0x02 },       // 00000010         29
    {  8, 0x03 },       // 00000011         30
    {  8, 0x1a },       // 00011010         31
    {  8, 0x1b },       // 00011011         32
    {  8, 0x12 },       // 00010010         33
    {  8, 0x13 },       // 00010011         34
    {  8, 0x14 },       // 00010100         35
    {  8, 0x15 },       // 00010101         36
    {  8, 0x16 },       // 00010110         37
    {  8, 0x17 },       // 00010111         38
    {  8, 0x28 },       // 00101000         39
    {  8, 0x29 },       // 00101001         40
    {  8, 0x2a },       // 00101010         41
    {  8, 0x2b },       // 00101011         42
    {  8, 0x2c },       // 00101100         43
    {  8, 0x2d },       // 00101101         44
    {  8, 0x04 },       // 00000100         45
    {  8, 0x05 },       // 00000101         46
    {  8, 0x0a },       // 00001010         47
    {  8, 0x0b },       // 00001011         48
    {  8, 0x52 },       // 01010010         49
    {  8, 0x53 },       // 01010011         50
    {  8, 0x54 },       // 01010100         51
    {  8, 0x55 },       // 01010101         52
    {  8, 0x24 },       // 00100100         53
    {  8, 0x25 },       // 00100101         54
    {  8, 0x58 },       // 01011000         55
    {  8, 0x59 },       // 01011001         56
    {  8, 0x5a },       // 01011010         57
    {  8, 0x5b },       // 01011011         58
    {  8, 0x4a },       // 01001010         59
    {  8, 0x4b },       // 01001011         60
    {  8, 0x32 },       // 00110010         61
    {  8, 0x33 },       // 00110011         62
    {  8, 0x34 },       // 00110100         63
    {  5, 0x1b },       // 11011            64
    {  5, 0x12 },       // 10010           128
    {  6, 0x17 },       // 010111          192
    {  7, 0x37 },       // 0110111         256
    {  8, 0x36 },       // 00110110        320
    {  8, 0x37 },       // 00110111        384
    {  8, 0x64 },       // 01100100        448
    {  8, 0x65 },       // 01100101        512
    {  8, 0x68 },       // 01101000        576
    {  8, 0x67 },       // 01100111        640
    {  9, 0xcc },       // 011001100       704
    {  9, 0xcd },       // 011001101       768
    {  9, 0xd2 },       // 011010010       832
    {  9, 0xd3 },       // 011010011       896
    {  9, 0xd4 },       // 011010100       960
    {  9, 0xd5 },       // 011010101      1024
    {  9, 0xd6 },       // 011010110      1088
    {  9, 0xd7 },       // 011010111      1152
    {  9, 0xd8 },       // 011011000      1216
    {  9, 0xd9 },       // 011011001      1280
    {  9, 0xda },       // 011011010      1344
    {  9, 0xdb },       // 011011011      1408
    {  9, 0x98 },       // 010011000      1472
    {  9, 0x99 },       // 010011001      1536
    {  9, 0x9a },       // 010011010      1600
    {  6, 0x18 },       // 011000         1664
    {  9, 0x9b },       // 010011011      1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

//
// Code table for black runs
//

static const CODETABLE BlackRunCodes[] = {
    
    { 10, 0x37 },       // 0000110111        0
    {  3, 0x02 },       // 010               1
    {  2, 0x03 },       // 11                2
    {  2, 0x02 },       // 10                3
    {  3, 0x03 },       // 011               4
    {  4, 0x03 },       // 0011              5
    {  4, 0x02 },       // 0010              6
    {  5, 0x03 },       // 00011             7
    {  6, 0x05 },       // 000101            8
    {  6, 0x04 },       // 000100            9
    {  7, 0x04 },       // 0000100          10
    {  7, 0x05 },       // 0000101          11
    {  7, 0x07 },       // 0000111          12
    {  8, 0x04 },       // 00000100         13
    {  8, 0x07 },       // 00000111         14
    {  9, 0x18 },       // 000011000        15
    { 10, 0x17 },       // 0000010111       16
    { 10, 0x18 },       // 0000011000       17
    { 10, 0x08 },       // 0000001000       18
    { 11, 0x67 },       // 00001100111      19
    { 11, 0x68 },       // 00001101000      20
    { 11, 0x6c },       // 00001101100      21
    { 11, 0x37 },       // 00000110111      22
    { 11, 0x28 },       // 00000101000      23
    { 11, 0x17 },       // 00000010111      24
    { 11, 0x18 },       // 00000011000      25
    { 12, 0xca },       // 000011001010     26
    { 12, 0xcb },       // 000011001011     27
    { 12, 0xcc },       // 000011001100     28
    { 12, 0xcd },       // 000011001101     29
    { 12, 0x68 },       // 000001101000     30
    { 12, 0x69 },       // 000001101001     31
    { 12, 0x6a },       // 000001101010     32
    { 12, 0x6b },       // 000001101011     33
    { 12, 0xd2 },       // 000011010010     34
    { 12, 0xd3 },       // 000011010011     35
    { 12, 0xd4 },       // 000011010100     36
    { 12, 0xd5 },       // 000011010101     37
    { 12, 0xd6 },       // 000011010110     38
    { 12, 0xd7 },       // 000011010111     39
    { 12, 0x6c },       // 000001101100     40
    { 12, 0x6d },       // 000001101101     41
    { 12, 0xda },       // 000011011010     42
    { 12, 0xdb },       // 000011011011     43
    { 12, 0x54 },       // 000001010100     44
    { 12, 0x55 },       // 000001010101     45
    { 12, 0x56 },       // 000001010110     46
    { 12, 0x57 },       // 000001010111     47
    { 12, 0x64 },       // 000001100100     48
    { 12, 0x65 },       // 000001100101     49
    { 12, 0x52 },       // 000001010010     50
    { 12, 0x53 },       // 000001010011     51
    { 12, 0x24 },       // 000000100100     52
    { 12, 0x37 },       // 000000110111     53
    { 12, 0x38 },       // 000000111000     54
    { 12, 0x27 },       // 000000100111     55
    { 12, 0x28 },       // 000000101000     56
    { 12, 0x58 },       // 000001011000     57
    { 12, 0x59 },       // 000001011001     58
    { 12, 0x2b },       // 000000101011     59
    { 12, 0x2c },       // 000000101100     60
    { 12, 0x5a },       // 000001011010     61
    { 12, 0x66 },       // 000001100110     62
    { 12, 0x67 },       // 000001100111     63
    { 10, 0x0f },       // 0000001111       64
    { 12, 0xc8 },       // 000011001000    128
    { 12, 0xc9 },       // 000011001001    192
    { 12, 0x5b },       // 000001011011    256
    { 12, 0x33 },       // 000000110011    320
    { 12, 0x34 },       // 000000110100    384
    { 12, 0x35 },       // 000000110101    448
    { 13, 0x6c },       // 0000001101100   512
    { 13, 0x6d },       // 0000001101101   576
    { 13, 0x4a },       // 0000001001010   640
    { 13, 0x4b },       // 0000001001011   704
    { 13, 0x4c },       // 0000001001100   768
    { 13, 0x4d },       // 0000001001101   832
    { 13, 0x72 },       // 0000001110010   896
    { 13, 0x73 },       // 0000001110011   960
    { 13, 0x74 },       // 0000001110100  1024
    { 13, 0x75 },       // 0000001110101  1088
    { 13, 0x76 },       // 0000001110110  1152
    { 13, 0x77 },       // 0000001110111  1216
    { 13, 0x52 },       // 0000001010010  1280
    { 13, 0x53 },       // 0000001010011  1344
    { 13, 0x54 },       // 0000001010100  1408
    { 13, 0x55 },       // 0000001010101  1472
    { 13, 0x5a },       // 0000001011010  1536
    { 13, 0x5b },       // 0000001011011  1600
    { 13, 0x64 },       // 0000001100100  1664
    { 13, 0x65 },       // 0000001100101  1728
    { 11, 0x08 },       // 00000001000    1792
    { 11, 0x0c },       // 00000001100    1856
    { 11, 0x0d },       // 00000001101    1920
    { 12, 0x12 },       // 000000010010   1984
    { 12, 0x13 },       // 000000010011   2048
    { 12, 0x14 },       // 000000010100   2112
    { 12, 0x15 },       // 000000010101   2176
    { 12, 0x16 },       // 000000010110   2240
    { 12, 0x17 },       // 000000010111   2304
    { 12, 0x1c },       // 000000011100   2368
    { 12, 0x1d },       // 000000011101   2432
    { 12, 0x1e },       // 000000011110   2496
    { 12, 0x1f },       // 000000011111   2560
};

#ifdef USELSB

//
// Table used to reverse fill order from MSB to LSB
//

static const BYTE BitReverseTable[256] = {

    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

#endif

#endif	// !_FAXTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\faxdrv.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    faxdrv.h

Abstract:

    Fax driver graphics DLL header file

[Environment:]

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    20/10/99 -danl-
        Organize DEVDATA for 95 use.

    dd/mm/yy -author-
        description

--*/


#ifndef _FAXDRV_H_
#define _FAXDRV_H_

#include "faxlib.h"


//
// Data structure maintained by the fax driver graphics DLL
//

typedef struct {

    PVOID       startDevData;   // data structure signature

    HANDLE      hPrinter;       // handle to printer

#ifdef USERMODE_DRIVER
    HANDLE      hPreviewFile;   // handle to print preview mapping file
#endif

    HANDLE      hPreviewMapping;// handle to print preview mapping object
    PMAP_TIFF_PAGE_HEADER pTiffPageHeader;  // points to the header of the mapping file
    LPBYTE      pbTiffPageFP;   // The mapping virutal 'File Pointer'.
    BOOL        bPrintPreview;  // Indicates print preview is requested
    DRVDEVMODE  dm;             // devmode information
    INT         pageCount;      // number of pages printed
    LONG        lineOffset;     // bitmap scanline byte offset
    DWORD       flags;          // flag bits
    SIZEL       imageSize;      // image size measured in pixels

#ifndef WIN__95
    HDEV        hdev;           // handle to GDI device
    HANDLE      hpal;           // handle to default palette
    SIZEL       paperSize;      // paper size measured in pixels
    RECTL       imageArea;      // imageable area measured in pixels
    LONG        xres, yres;     // x- and y-resolution
    HSURF       hbitmap;        // handle to bitmap surface
    DWORD       jobId;          // job ID
#endif //WIN__95

    DWORD       fileOffset;     // output byte count for current document
    PBYTE       pCompBits;      // buffer to hold G4 compressed bitmap data
    PBYTE       pCompBufPtr;    // pointer to next free byte in the buffer
    PBYTE       pCompBufMark;   // high-water mark
    DWORD       compBufSize;    // size of compressed bitmap data buffer
    DWORD       compBufInc;     // increment to enlarge the buffer when necessary
    PBYTE       prefline;       // raster data for the reference line
    INT         bitcnt;         // these two fields are used for assembling variable-length
    DWORD       bitdata;        // compressed bits into byte stream
    PVOID       pFaxIFD;        // IFD entries for each page

    PVOID       endDevData;     // data structure signature

} DEVDATA, *PDEVDATA;

//
// Constants for DEVDATA.flags field
//

#define PDEV_CANCELLED  0x0001  // current job has been cancelled
#define PDEV_RESETPDEV  0x0002  // DrvResetPDEV has been called
#define PDEV_WITHINPAGE 0x0004  // drawing on a page

//
// Check if a DEVDATA structure is valid
//

#define ValidDevData(pdev)  \
        ((pdev) && (pdev)->startDevData == (pdev) && (pdev)->endDevData == (pdev))

//
// Color values and indices
//

#define RGB_BLACK   RGB(0, 0, 0)
#define RGB_WHITE   RGB(255, 255, 255)

#define BLACK_INDEX 0
#define WHITE_INDEX 1

//
// Number of bits consisting a BYTE and a DWORD
//

#define BYTEBITS    8
#define DWORDBITS   (sizeof(DWORD) * BYTEBITS)

//
// Pad bit scanline data to N-byte boundary
//

#define PadBitsToBytes(bits, N) \
        ((((bits) + ((N) * BYTEBITS - 1)) / ((N) * BYTEBITS)) * (N))

//
// Macros for manipulating ROP4s and ROP3s
//

#define GetForegroundRop3(rop4) ((rop4) & 0xFF)
#define GetBackgroundRop3(rop4) (((rop4) >> 8) & 0xFF)
#define Rop3NeedPattern(rop3)   (((rop3 >> 4) & 0x0F) != (rop3 & 0x0F))
#define Rop3NeedSource(rop3)    (((rop3 >> 2) & 0x33) != (rop3 & 0x33))
#define Rop3NeedDest(rop3)      (((rop3 >> 1) & 0x55) != (rop3 & 0x55))

//
// Determine whether the page is in landscape mode
//

#define IsLandscapeMode(pdev)   ((pdev)->dm.dmPublic.dmOrientation == DMORIENT_LANDSCAPE)

//
// Returns the length of the hypotenouse of a right triangle
//

LONG
CalcHypot(
    LONG    x,
    LONG    y
    );

//
// Output a completed page bitmap to the spooler
//

BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    );

//
// Output document trailer information to the spooler
//

BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    );

#endif // !_FAXDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\faxtiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    Declarations for Group3 2D compression and generating TIFF files

Environment:

        Windows XP Fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

NOTE:

    Structure of the TIFF output file from the driver:

    4949        II
    002a        42
    00000008    Offset to the first IFD

    IFD for the first page

    Number of directory entries
    NEWSUBFILETYPE  LONG     1  2 - Page in a multi-page document
    PAGENUMBER      SHORT    2  PageNumber 0000
    IMAGEWIDTH      LONG     1  ImageWidth
    IMAGEHEIGHT     LONG     1  ImageHeight
    BITSPERSAMPLE   SHORT    1  1
    SAMPLESPERPIXEL SHORT    1  1
    COMPRESSION     SHORT    1  4 - G4Fax
    GROUP4OPTIONS   SHORT    1  0
    CLEANFAXDATA    SHORT    1  0
    FILLORDER       SHORT    1  2
    PHOTOMETRIC     SHORT    1  0 - WhiteIsZero
    RESOLUTIONUNIT  SHORT    1  2 - Inch
    XRESOLUTION     RATIONAL 1  Xdpi
    YRESOLUTION     RATIONAL 1  Ydpi
    ROWSPERSTRIP    LONG     1  ImageHeight
    STRIPBYTECOUNTS LONG     1  Compressed data byte count
    STRIPOFFSETS    LONG     1  Offset to compressed data
    Next IFD offset
    Compressed data for the first page

    IFD for the second page
    Compressed data for the second page
    ...

    Last IFD

    0001
    SOFTWARE        ASCII    n  "Microsoft Shared Fax Driver"
    00000000
    00000000

--*/

#ifndef _FAXTIFF_H_
#define _FAXTIFF_H_

//
// TIFF field tag and type constants
//

#define TIFFTYPE_ASCII              2
#define TIFFTYPE_SHORT              3
#define TIFFTYPE_LONG               4
#define TIFFTYPE_RATIONAL           5

#define TIFFTAG_NEWSUBFILETYPE      254
#define     SUBFILETYPE_PAGE        2
#define TIFFTAG_IMAGEWIDTH          256
#define TIFFTAG_IMAGEHEIGHT         257
#define TIFFTAG_BITSPERSAMPLE       258
#define TIFFTAG_COMPRESSION         259
#define     COMPRESSION_G3FAX       3
#define     COMPRESSION_G4FAX       4
#define TIFFTAG_PHOTOMETRIC         262
#define     PHOTOMETRIC_WHITEIS0    0
#define     PHOTOMETRIC_BLACKIS0    1
#define TIFFTAG_FILLORDER           266
#define     FILLORDER_MSB           1
#define     FILLORDER_LSB           2
#define TIFFTAG_STRIPOFFSETS        273
#define TIFFTAG_SAMPLESPERPIXEL     277
#define TIFFTAG_ROWSPERSTRIP        278
#define TIFFTAG_STRIPBYTECOUNTS     279
#define TIFFTAG_XRESOLUTION         282
#define     TIFFF_RES_X             204
#define TIFFTAG_YRESOLUTION         283
#define     TIFFF_RES_Y             196
#define     TIFFF_RES_Y_DRAFT       98
#define TIFFTAG_G3OPTIONS           292
#define     G3_2D                   1
#define     G3_ALIGNEOL             4
#define TIFFTAG_G4OPTIONS           293
#define TIFFTAG_RESUNIT             296
#define     RESUNIT_INCH            2
#define TIFFTAG_PAGENUMBER          297
#define TIFFTAG_SOFTWARE            305
#define TIFFTAG_CLEANFAXDATA        327

//
// Data structure for representing our TIFF output file header information
//

typedef struct {

    WORD    magic1;     // II
    WORD    magic2;     // 42
    LONG    firstIFD;   // offset to first IFD
    DWORD   signature;  // driver private signature

} TIFFFILEHEADER;

#define TIFF_MAGIC1     'II'
#define TIFF_MAGIC2     42

//
// Data structure for representing a single IFD entry
//

typedef struct {

    WORD    tag;        // field tag
    WORD    type;       // field type
    DWORD   count;      // number of values
    DWORD   value;      // value or value offset

} IFDENTRY, *PIFDENTRY;

//
// IFD entries we generate for each page
//

enum {

    IFD_NEWSUBFILETYPE,
    IFD_IMAGEWIDTH,
    IFD_IMAGEHEIGHT,
    IFD_BITSPERSAMPLE,
    IFD_COMPRESSION,
    IFD_PHOTOMETRIC,
    IFD_FILLORDER,
    IFD_STRIPOFFSETS,
    IFD_SAMPLESPERPIXEL,
    IFD_ROWSPERSTRIP,
    IFD_STRIPBYTECOUNTS,
    IFD_XRESOLUTION,
    IFD_YRESOLUTION,
    IFD_G3G4OPTIONS,
    IFD_RESUNIT,
    IFD_PAGENUMBER,
    IFD_SOFTWARE,
    IFD_CLEANFAXDATA,

    NUM_IFD_ENTRIES
};

typedef struct {

    WORD        reserved;
    WORD        wIFDEntries;
    IFDENTRY    ifd[NUM_IFD_ENTRIES];
    DWORD       nextIFDOffset;
    DWORD       filler;
    DWORD       xresNum;
    DWORD       xresDenom;
    DWORD       yresNum;
    DWORD       yresDenom;
    CHAR        software[32];

} FAXIFD, *PFAXIFD;

//
// Output compressed data bytes in correct fill order
//

#ifdef USELSB

#define OutputByte(n)   BitReverseTable[(BYTE) (n)]

#else

#define OutputByte(n)   ((BYTE) (n))

#endif

//
// Output a sequence of compressed bits
//

#define OutputBits(pdev, length, code) { \
            (pdev)->bitdata |= (code) << ((pdev)->bitcnt - (length)); \
            if (((pdev)->bitcnt -= (length)) <= 2*BYTEBITS) { \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 2*BYTEBITS)); \
                (pdev)->bitdata <<= 2*BYTEBITS; \
                (pdev)->bitcnt += 2*BYTEBITS; \
            } \
        }

//
// Flush any leftover bits into the compressed bitmap buffer
//

#define FlushBits(pdev) { \
            while ((pdev)->bitcnt < DWORDBITS) { \
                (pdev)->bitcnt += BYTEBITS; \
                *(pdev)->pCompBufPtr++ = OutputByte(((pdev)->bitdata >> 3*BYTEBITS)); \
                (pdev)->bitdata <<= BYTEBITS; \
            } \
            (pdev)->bitdata = 0; \
            (pdev)->bitcnt = DWORDBITS; \
        }

//
// Find the next pixel on the scanline whose color is opposite of
// the specified color, starting from the specified starting point
//

#define NextChangingElement(pbuf, startBit, stopBit, isBlack) \
        ((startBit) + ((isBlack) ? FindBlackRun((pbuf), (startBit), (stopBit)) : \
                                   FindWhiteRun((pbuf), (startBit), (stopBit))))

//
// Check if the specified pixel on the scanline is black or white
//  1 - the specified pixel is black
//  0 - the specified pixel is white
//

#define GetBit(pbuf, bit)   (((pbuf)[(bit) >> 3] >> (((bit) ^ 7) & 7)) & 1)

//
// Compress the specified number of scanlines
//

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    );

//
// Output TIFF IFD for the current page
//

BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBits
    );

//
// Output the compressed bitmap data for the current page
//

BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBits
    );

//
// Enlarge the buffer for holding the compressed bitmap data
//

BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    );

//
// Free the buffer for holding the compressed bitmap data
//

VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    );

//
// Initialize the fax encoder
//

BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    );

#endif  // !_FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\faxtiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxtiff.c

Abstract:

    Functions to compress the bitmap bits using CCITT Group3 2-dimensional coding
    and output the resulting data as TIFF-F file.

Environment:

        Windows XP fax driver, kernel mode

Revision History:

        01/23/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

#include "faxdrv.h"
#include "faxtiff.h"
#include "faxtable.h"



BOOL
WriteData(
    PDEVDATA    pdev,
    PVOID       pbuf,
    DWORD       cbbuf
    )

/*++

Routine Description:

    Output a buffer of data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pbuf - Points to data buffer
    cbbuf - Number of bytes in the buffer

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    DWORD   cbwritten;

    //
    // Stop if the document has been cancelled.
    //
    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Send output to spooler directly
    //

    if (! WritePrinter(pdev->hPrinter, pbuf, cbbuf, &cbwritten) || cbbuf != cbwritten) {
        Error(("WritePrinter failed\n"));
        pdev->flags |= PDEV_CANCELLED;

        // Abort preview as well - just in case ...
        if (pdev->bPrintPreview)
        {
            Assert(pdev->pTiffPageHeader);
            pdev->pTiffPageHeader->bPreview = FALSE;
            pdev->bPrintPreview = FALSE;
        }
        return FALSE;
    }

    //
    // If print preview is enabled, send a copy to our preview page
    //
    if (pdev->bPrintPreview)
    {
        Assert(pdev->pTiffPageHeader);
        Assert(pdev->pbTiffPageFP == 
            ((LPBYTE) (pdev->pTiffPageHeader + 1)) + pdev->pTiffPageHeader->dwDataSize);

        //
        // Add the bits in if we don't overflow
        //
        if (pdev->pTiffPageHeader->dwDataSize + cbbuf >
                MAX_TIFF_PAGE_SIZE - sizeof(MAP_TIFF_PAGE_HEADER))
        {
            Error(("MAX_TIFF_PAGE_SIZE exeeded!\n"));

            //
            // Cancel print preview for this document
            //
            pdev->pTiffPageHeader->bPreview = FALSE;
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            CopyMemory(pdev->pbTiffPageFP, pbuf, cbbuf);
            pdev->pbTiffPageFP += cbbuf;
            pdev->pTiffPageHeader->dwDataSize += cbbuf;
        }
    }

    pdev->fileOffset += cbbuf;
    return TRUE;
}



PDWORD
CalcXposeMatrix(
    VOID
    )

/*++

Routine Description:

    Generate the transpose matrix for rotating landscape bitmaps

Arguments:

    NONE

Return Value:

    Pointer to the generated transpose matrix
    NULL if there is an error

--*/

{
    static DWORD templateData[16] = {

        /* 0000 */  0x00000000,
        /* 0001 */  0x00000001,
        /* 0010 */  0x00000100,
        /* 0011 */  0x00000101,
        /* 0100 */  0x00010000,
        /* 0101 */  0x00010001,
        /* 0110 */  0x00010100,
        /* 0111 */  0x00010101,
        /* 1000 */  0x01000000,
        /* 1001 */  0x01000001,
        /* 1010 */  0x01000100,
        /* 1011 */  0x01000101,
        /* 1100 */  0x01010000,
        /* 1101 */  0x01010001,
        /* 1110 */  0x01010100,
        /* 1111 */  0x01010101
    };

    PDWORD  pdwXpose, pTemp;
    INT     index;

    //
    // First check if the transpose matrix has been generated already
    //

    if (pdwXpose = MemAlloc(sizeof(DWORD) * 2 * (1 << BYTEBITS))) {

        for (index=0, pTemp=pdwXpose; index < (1 << BYTEBITS); index++, pTemp++) {

            pTemp[0] = templateData[index >> 4];
            pTemp[1 << BYTEBITS] = templateData[index & 0xf];
        }
    }

    return pdwXpose;
}



BOOL
OutputPageBitmap(
    PDEVDATA    pdev,
    PBYTE       pBitmapData
    )

/*++

Routine Description:

    Output a completed page bitmap to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pBitmapData - Points to bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LONG    bmpWidth, bmpHeight;
    BOOL    result;
    DWORD   compressedBytes;

    Verbose(("Sending page %d...\n", pdev->pageCount));
    Assert(pdev->pCompBits == NULL);

    //
    // For portrait output, encode the entire bitmap in one shot
    // For landscape output, we need to rotate the bitmap here:
    //  Generate the transpose matrix and allocate a
    //  temporary buffer large enough to hold 8 scanlines
    //

    if (IsLandscapeMode(pdev)) {

        bmpWidth = pdev->imageSize.cy;
        bmpHeight = pdev->imageSize.cx;

    } else {

        bmpWidth = pdev->imageSize.cx;
        bmpHeight = pdev->imageSize.cy;
    }

    //
    // Initialize fax encodier
    //

    if (! InitFaxEncoder(pdev, bmpWidth, bmpHeight))
        return FALSE;

    if (! IsLandscapeMode(pdev)) {

        LONG    dwordCount;
        PDWORD  pBits;

        //
        // Invert the entire page bitmap in memory
        //

        Assert(bmpWidth % DWORDBITS == 0);
        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        //
        // Compress the page bitmap
        //

        result = EncodeFaxData(pdev, pBitmapData, bmpWidth, bmpHeight);

        //
        // Restore the original page bitmap
        //

        dwordCount = (bmpWidth * bmpHeight) / DWORDBITS;
        pBits = (PDWORD) pBitmapData;

        while (dwordCount--)
            *pBits++ ^= 0xffffffff;

        if (! result) {

            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

    } else {

        register PDWORD pdwXposeHigh, pdwXposeLow;
        register DWORD  dwHigh, dwLow;
        PBYTE           pBuffer, pbCol;
        LONG            deltaNew;

        //
        // Calculate the transpose matrix for fast bitmap rotation
        //

        if (!(pdwXposeHigh = CalcXposeMatrix()) || !(pBuffer = MemAllocZ(bmpWidth))) {

            MemFree(pdwXposeHigh);
            FreeCompBitsBuffer(pdev);
            return FALSE;
        }

        pdwXposeLow = pdwXposeHigh + (1 << BYTEBITS);

        //
        // During each iteration thru the following loop, we will process
        // one byte column and generate 8 rotated scanlines.
        //

        Assert(bmpHeight % BYTEBITS == 0);
        Assert(bmpWidth  % DWORDBITS == 0);

        deltaNew = bmpWidth / BYTEBITS;
        pbCol = pBitmapData + (bmpHeight / BYTEBITS - 1);

        do {

            PBYTE   pbWrite = pBuffer;
            PBYTE   pbTemp = pbCol;
            LONG    loopCount = deltaNew;

            while (loopCount--) {

                //
                // Rotate the next 8 bytes in the current column
                // Unroll the loop here in hopes of faster execution
                //

                dwHigh = pdwXposeHigh[*pbTemp];
                dwLow  = pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                dwHigh = (dwHigh << 1) | pdwXposeHigh[*pbTemp];
                dwLow  = (dwLow  << 1) | pdwXposeLow[*pbTemp];
                pbTemp += pdev->lineOffset;

                //
                // Invert black and white pixel polarity
                //

                dwHigh ^= 0xffffffff;
                dwLow  ^= 0xffffffff;

                //
                // Distribute the resulting byte to 8 separate scanlines
                //

                *pbWrite = (BYTE) dwLow;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwLow >> BYTEBITS*3);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) dwHigh;
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*2);
                pbWrite += deltaNew;

                *pbWrite = (BYTE) (dwHigh >> BYTEBITS*3);
                pbWrite -= (deltaNew * BYTEBITS - deltaNew - 1);
            }

            //
            // Encode the next band of scanlines
            //

            if (! EncodeFaxData(pdev, pBuffer, bmpWidth, BYTEBITS)) {

                MemFree(pdwXposeHigh);
                MemFree(pBuffer);
                FreeCompBitsBuffer(pdev);
                return FALSE;
            }

        } while (pbCol-- != pBitmapData);

        MemFree(pdwXposeHigh);
        MemFree(pBuffer);
    }

    //
    // Output EOB (two EOLs) after the last scanline
    // and make sure the compressed data is WORD aligned
    //

    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    OutputBits(pdev, EOL_LENGTH, EOL_CODE);
    FlushBits(pdev);

    if ((compressedBytes = (DWORD)(pdev->pCompBufPtr - pdev->pCompBits)) & 1) {

        *pdev->pCompBufPtr++ = 0;
        compressedBytes++;
    }

    //
    // Output the IFD for the previous page and generate the IFD for the current page
    // Output the compressed bitmap data
    //

    result = WriteTiffIFD(pdev, bmpWidth, bmpHeight, compressedBytes) &&
             WriteTiffBits(pdev, pdev->pCompBits, compressedBytes);

    FreeCompBitsBuffer(pdev);

    return result;
}



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}



INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf - Points to uncompressed pixel data for the current line
    startBit - Starting bit index
    stopBit - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((ULONG_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}



VOID
OutputRun(
    PDEVDATA    pdev,
    INT         run,
    PCODETABLE  pCodeTable
    )

/*++

Routine Description:

    Output a single run (black or white) using the specified code table

Arguments:

    pdev - Points to our DEVDATA structure
    run - Specifies the length of the run
    pCodeTable - Specifies the code table to use

Return Value:

    NONE

--*/

{
    PCODETABLE  pTableEntry;

    //
    // Use make-up code word for 2560 for any runs of at least 2624 pixels
    // This is currently not necessary for us since our scanlines always
    // have 1728 pixels.
    //

    while (run >= 2624) {

        pTableEntry = pCodeTable + (63 + (2560 >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run -= 2560;
    }

    //
    // Use appropriate make-up code word if the run is longer than 63 pixels
    //

    if (run >= 64) {

        pTableEntry = pCodeTable + (63 + (run >> 6));
        OutputBits(pdev, pTableEntry->length, pTableEntry->code);
        run &= 0x3f;
    }

    //
    // Output terminating code word
    //

    OutputBits(pdev, pCodeTable[run].length, pCodeTable[run].code);
}



#ifdef USE1D

VOID
OutputEOL(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output EOL code at the beginning of each scanline

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    DWORD   length, code;

    //
    // EOL code word always ends on a byte boundary
    //

    code = EOL_CODE;
    length = EOL_LENGTH + ((pdev->bitcnt - EOL_LENGTH) & 7);
    OutputBits(pdev, length, code);
}


BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     bitIndex, run;

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Output byte-aligned EOL code
        //

        OutputEOL(pdev);

        //
        // Use 1-dimensional encoding scheme
        //

        bitIndex = 0;

        while (TRUE) {

            //
            // Code white run
            //

            run = FindWhiteRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, WhiteRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;

            //
            // Code black run
            //

            run = FindBlackRun(plinebuf, bitIndex, lineWidth);
            OutputRun(pdev, run, BlackRunCodes);

            if ((bitIndex += run) >= lineWidth)
                break;
        }

        //
        // Move on to the next scanline
        //

        plinebuf += delta;
    }

    return TRUE;
}



#else //!USE1D

BOOL
EncodeFaxData(
    PDEVDATA    pdev,
    PBYTE       plinebuf,
    INT         lineWidth,
    INT         lineCount
    )

/*++

Routine Description:

    Compress the specified number of scanlines

Arguments:

    pdev - Points to our DEVDATA structure
    plinebuf - Points to scanline data to be compressed
    lineWidth - Scanline width in pixels
    lineCount - Number of scanlines

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT     delta = lineWidth / BYTEBITS;
    INT     a0, a1, a2, b1, b2, distance;
    PBYTE   prefline = pdev->prefline;

    Assert(lineWidth % BYTEBITS == 0);

    while (lineCount--) {

        //
        // Make sure the compressed bitmap buffer doesn't overflow
        //

        if ((pdev->pCompBufPtr >= pdev->pCompBufMark) && !GrowCompBitsBuffer(pdev, delta))
            return FALSE;

        //
        // Use 2-dimensional encoding scheme
        //

        a0 = 0;
        a1 = GetBit(plinebuf, 0) ? 0 : NextChangingElement(plinebuf, 0, lineWidth, 0);
        b1 = GetBit(prefline, 0) ? 0 : NextChangingElement(prefline, 0, lineWidth, 0);

        while (TRUE) {

            b2 = (b1 >= lineWidth) ? lineWidth :
                    NextChangingElement(prefline, b1, lineWidth, GetBit(prefline, b1));

            if (b2 < a1) {

                //
                // Pass mode
                //

                OutputBits(pdev, PASSCODE_LENGTH, PASSCODE);
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                OutputBits(pdev, VertCodes[distance+3].length, VertCodes[distance+3].code);
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= lineWidth) ? lineWidth :
                        NextChangingElement(plinebuf, a1, lineWidth, GetBit(plinebuf, a1));

                OutputBits(pdev, HORZCODE_LENGTH, HORZCODE);

                if (a1 != 0 && GetBit(plinebuf, a0)) {

                    OutputRun(pdev, a1-a0, BlackRunCodes);
                    OutputRun(pdev, a2-a1, WhiteRunCodes);

                } else {

                    OutputRun(pdev, a1-a0, WhiteRunCodes);
                    OutputRun(pdev, a2-a1, BlackRunCodes);
                }

                a0 = a2;
            }

            if (a0 >= lineWidth)
                break;

            a1 = NextChangingElement(plinebuf, a0, lineWidth, GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, a0, lineWidth, !GetBit(plinebuf, a0));
            b1 = NextChangingElement(prefline, b1, lineWidth, GetBit(plinebuf, a0));
        }

        //
        // Move on to the next scanline
        //

        prefline = plinebuf;
        plinebuf += delta;
    }

    //
    // Remember the last line as a reference
    //

    CopyMemory(pdev->prefline, prefline, delta);

    return TRUE;
}

#endif //!USE1D



//
// IFD entries we generate for each page
//

WORD FaxIFDTags[NUM_IFD_ENTRIES] = {

    TIFFTAG_NEWSUBFILETYPE,
    TIFFTAG_IMAGEWIDTH,
    TIFFTAG_IMAGEHEIGHT,
    TIFFTAG_BITSPERSAMPLE,
    TIFFTAG_COMPRESSION,
    TIFFTAG_PHOTOMETRIC,
    TIFFTAG_FILLORDER,
    TIFFTAG_STRIPOFFSETS,
    TIFFTAG_SAMPLESPERPIXEL,
    TIFFTAG_ROWSPERSTRIP,
    TIFFTAG_STRIPBYTECOUNTS,
    TIFFTAG_XRESOLUTION,
    TIFFTAG_YRESOLUTION,
#ifdef USE1D
    TIFFTAG_G3OPTIONS,
#else
    TIFFTAG_G4OPTIONS,
#endif
    TIFFTAG_RESUNIT,
    TIFFTAG_PAGENUMBER,
    TIFFTAG_SOFTWARE,
    TIFFTAG_CLEANFAXDATA,
};

static FAXIFD FaxIFDTemplate = {

    0,
    NUM_IFD_ENTRIES,

    {
        { TIFFTAG_NEWSUBFILETYPE, TIFFTYPE_LONG, 1, SUBFILETYPE_PAGE },
        { TIFFTAG_IMAGEWIDTH, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_IMAGEHEIGHT, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_BITSPERSAMPLE, TIFFTYPE_SHORT, 1, 1 },
#ifdef USE1D
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G3FAX },
#else
        { TIFFTAG_COMPRESSION, TIFFTYPE_SHORT, 1, COMPRESSION_G4FAX },
#endif
        { TIFFTAG_PHOTOMETRIC, TIFFTYPE_SHORT, 1, PHOTOMETRIC_WHITEIS0 },
#ifdef USELSB
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_LSB },
#else
        { TIFFTAG_FILLORDER, TIFFTYPE_SHORT, 1, FILLORDER_MSB },
#endif
        { TIFFTAG_STRIPOFFSETS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_SAMPLESPERPIXEL, TIFFTYPE_SHORT, 1, 1 },
        { TIFFTAG_ROWSPERSTRIP, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_STRIPBYTECOUNTS, TIFFTYPE_LONG, 1, 0 },
        { TIFFTAG_XRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
        { TIFFTAG_YRESOLUTION, TIFFTYPE_RATIONAL, 1, 0 },
#ifdef USE1D
        { TIFFTAG_G3OPTIONS, TIFFTYPE_LONG, 1, G3_ALIGNEOL },
#else
        { TIFFTAG_G4OPTIONS, TIFFTYPE_LONG, 1, 0 },
#endif
        { TIFFTAG_RESUNIT, TIFFTYPE_SHORT, 1, RESUNIT_INCH },
        { TIFFTAG_PAGENUMBER, TIFFTYPE_SHORT, 2, 0 },
        { TIFFTAG_SOFTWARE, TIFFTYPE_ASCII, sizeof(FAX_DRIVER_NAME_A)+1, 0 },
        { TIFFTAG_CLEANFAXDATA, TIFFTYPE_SHORT, 1, 0 },
    },

    0,
    DRIVER_SIGNATURE,
    TIFFF_RES_X,
    1,
    TIFFF_RES_Y,
    1,
    FAX_DRIVER_NAME_A
};



BOOL
OutputDocTrailer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Output document trailer information to the spooler

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;

    if (pFaxIFD == NULL || pdev->pageCount == 0)
        return TRUE;

    //
    // Output the IFD for the last page of the document
    //

    pFaxIFD->nextIFDOffset = pFaxIFD->filler = 0;

    return WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
}



BOOL
WriteTiffIFD(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the IFD for the previous page and generate the IFD for the current page

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap image
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Please refer to faxtiff.h for a description of
    the structure of our TIFF output file.

--*/

{
    PFAXIFD pFaxIFD = pdev->pFaxIFD;
    ULONG_PTR   offset;
    BOOL    result = TRUE;

    //
    // Create the IFD data structure if necessary
    //

    if (pFaxIFD == NULL) {

        if (! (pFaxIFD = MemAlloc(sizeof(FAXIFD))))
            return FALSE;

        pdev->pFaxIFD = pFaxIFD;
        memcpy(pFaxIFD, &FaxIFDTemplate, sizeof(FAXIFD));

        #if DBG

        for (offset=0; offset < NUM_IFD_ENTRIES; offset++) {

            Assert(pFaxIFD->ifd[offset].tag == FaxIFDTags[offset]);
        }

        #endif
    }

    if (pdev->pageCount <= 1) {

        //
        // If this is the very first page, there is no previous IFD.
        // Output the TIFF file header instead.
        //

        TIFFFILEHEADER *pTiffFileHeader;

        pdev->fileOffset = 0;

        if (pTiffFileHeader = MemAlloc(sizeof(TIFFFILEHEADER))) {

            pTiffFileHeader->magic1 = TIFF_MAGIC1;
            pTiffFileHeader->magic2 = TIFF_MAGIC2;
            pTiffFileHeader->signature = DRIVER_SIGNATURE;
            pTiffFileHeader->firstIFD = sizeof(TIFFFILEHEADER) +
                                        compressedBytes +
                                        offsetof(FAXIFD, wIFDEntries);

            result = WriteData(pdev, pTiffFileHeader, sizeof(TIFFFILEHEADER));
            MemFree(pTiffFileHeader);

        } else {

            Error(("Memory allocation failed\n"));
            result = FALSE;
        }

    } else {

        //
        // Not the first page of the document
        // Output the IFD for the previous page
        //

        pFaxIFD->nextIFDOffset = pdev->fileOffset + compressedBytes + sizeof(FAXIFD) +
                                 offsetof(FAXIFD, wIFDEntries);

        result = WriteData(pdev, pFaxIFD, sizeof(FAXIFD));
    }

    //
    // Generate the IFD for the current page
    //

    offset = pdev->fileOffset;

    pFaxIFD->ifd[IFD_PAGENUMBER].value = MAKELONG(pdev->pageCount-1, 0);
    pFaxIFD->ifd[IFD_IMAGEWIDTH].value = bmpWidth;
    pFaxIFD->ifd[IFD_IMAGEHEIGHT].value = bmpHeight;
    pFaxIFD->ifd[IFD_ROWSPERSTRIP].value = bmpHeight;
    pFaxIFD->ifd[IFD_STRIPBYTECOUNTS].value = compressedBytes;
    pFaxIFD->ifd[IFD_STRIPOFFSETS].value = (ULONG)offset;
    offset += compressedBytes;

    pFaxIFD->ifd[IFD_XRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, xresNum);
    pFaxIFD->ifd[IFD_YRESOLUTION].value = (ULONG)offset + offsetof(FAXIFD, yresNum);
    pFaxIFD->ifd[IFD_SOFTWARE].value = (ULONG)offset + offsetof(FAXIFD, software);

    pFaxIFD->yresNum = (pdev->dm.dmPublic.dmYResolution == FAXRES_VERTDRAFT) ?
                            TIFFF_RES_Y_DRAFT :
                            TIFFF_RES_Y;

    return result;
}



BOOL
WriteTiffBits(
    PDEVDATA    pdev,
    PBYTE       pCompBits,
    DWORD       compressedBytes
    )

/*++

Routine Description:

    Output the compressed bitmap data to the spooler

Arguments:

    pdev - Points to our DEVDATA structure
    pCompBits - Points to a buffer containing compressed bitmap data
    compressedBytes - Size of compressed bitmap data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define OUTPUT_BUFFER_SIZE  4096

{
    PBYTE   pBuffer;
    DWORD   bytesToWrite;

#ifndef USERMODE_DRIVER
    //
    // Since we allocated the compressed bitmap data buffer from
    // the user mode memory space, we couldn't passed it directly
    // to EngWritePrinter.
    //
    // Here we allocate a temporary buffer from kernel mode memory
    // space and output the compressed data one buffer at a time.
    //

    if (! (pBuffer = MemAlloc(OUTPUT_BUFFER_SIZE))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    while (compressedBytes > 0) {

        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);
        CopyMemory(pBuffer, pCompBits, bytesToWrite);

        if (! WriteData(pdev, pBuffer, bytesToWrite)) {

            MemFree(pBuffer);
            return FALSE;
        }

        pCompBits += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    MemFree(pBuffer);
    return TRUE;
#else
    //
    // just dump the data in OUTPUT_BUFFER_SIZE increments
    //
    pBuffer = pCompBits;
    while (compressedBytes > 0) {
        bytesToWrite = min(compressedBytes, OUTPUT_BUFFER_SIZE);

        if (! WriteData(pdev, pBuffer, bytesToWrite) ) {
            return FALSE;
        }

        pBuffer += bytesToWrite;
        compressedBytes -= bytesToWrite;
    }

    return TRUE;    
#endif

}



BOOL
GrowCompBitsBuffer(
    PDEVDATA    pdev,
    LONG        scanlineSize
    )

/*++

Routine Description:

    Enlarge the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure
    scanlineSize - Number of uncompressed bytes per scanline

Return Value:

    TRUE if successful, FALSE if memory allocation fails

--*/

{
    DWORD   oldBufferSize;
    PBYTE   pNewBuffer;

    //
    // Allocate a new buffer which is one increment larger than existing one
    //

    oldBufferSize = pdev->pCompBits ? pdev->compBufSize : 0;
    pdev->compBufSize = oldBufferSize + pdev->compBufInc;

    if (! (pNewBuffer = MemAlloc(pdev->compBufSize))) {

        Error(("MemAlloc failed\n"));
        FreeCompBitsBuffer(pdev);
        return FALSE;
    }

    if (pdev->pCompBits) {

        //
        // Growing an existing buffer
        //

        Warning(("Growing compressed bitmap buffer: %d -> %d\n", oldBufferSize, pdev->compBufSize));

        memcpy(pNewBuffer, pdev->pCompBits, oldBufferSize);
        pdev->pCompBufPtr = pNewBuffer + (pdev->pCompBufPtr - pdev->pCompBits);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pNewBuffer;

    } else {

        //
        // First time allocation
        //

        pdev->pCompBufPtr = pdev->pCompBits = pNewBuffer;
    }

    //
    // Set a high-water mark to about 4 scanlines before the end of the buffer
    //

    pdev->pCompBufMark = pdev->pCompBits + (pdev->compBufSize - 4*scanlineSize);

    return TRUE;
}



VOID
FreeCompBitsBuffer(
    PDEVDATA    pdev
    )

/*++

Routine Description:

    Free the buffer for holding the compressed bitmap data

Arguments:

    pdev - Points to our DEVDATA structure

Return Value:

    NONE

--*/

{
    if (pdev->pCompBits) {

        MemFree(pdev->prefline);
        MemFree(pdev->pCompBits);
        pdev->pCompBits = pdev->pCompBufPtr = NULL;
        pdev->compBufSize = 0;
    }
}



BOOL
InitFaxEncoder(
    PDEVDATA    pdev,
    LONG        bmpWidth,
    LONG        bmpHeight
    )

/*++

Routine Description:

    Initialize the fax encoder

Arguments:

    pdev - Points to our DEVDATA structure
    bmpWidth, bmpHeight - Width and height of the bitmap

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Calculate the increment in which to enlarge the compressed bits buffer:
    //  about 1/4 of the uncompressed bitmap buffer
    //

    bmpWidth /= BYTEBITS;
    pdev->compBufInc = bmpWidth * bmpHeight / 4;

    //
    // Allocate the initial buffer
    //

    if (! (pdev->prefline = MemAllocZ(bmpWidth)) ||
        ! GrowCompBitsBuffer(pdev, bmpWidth))
    {
        MemFree(pdev->prefline);
        return FALSE;
    }

    //
    // Perform other initialization of fax encoder
    //

    pdev->bitdata = 0;
    pdev->bitcnt = DWORDBITS;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxdrv\page.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    page.c

Abstract:

    Implementation of document and page related DDI entry points:
        DrvStartDoc
        DrvEndDoc
        DrvStartPage
        DrvSendPage

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxdrv.h"



BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    pDocName - Specifies a Unicode document name
    jobId - Identifies the print job

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvStartDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Initialize page count and other information
    //

    if (! (pdev->flags & PDEV_RESETPDEV)) {

        pdev->pageCount = 0;
        pdev->jobId = jobId;
    }

    //
    // Check if print preview was requested
    //
    if (NULL == pdev->pTiffPageHeader)
    {
        Assert(FALSE == pdev->bPrintPreview);
    }
    else
    {
        //
        // Validate preview mapping
        //
        if (sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
        {
            Error(("Preview mapping corrupted\n"));
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            //
            // This is the place to check if print preview was requested: DrvStartDoc() is called
            // immediately after the UI dll sets pTiffPageHeader->bPreview value in DOCUMENTEVENT_STARTDOCPRE, or after ResetDC
            //
            pdev->bPrintPreview = pdev->pTiffPageHeader->bPreview;

            //
            // Reset page count in map file to 0. This causes the UI dll to ignore the first
            // DOCUMENTEVENT_STARTPAGE event when there is no real preview page ready.
            // The true page count will be updated every call to DrvStartPage().
            // If DrvStartDoc() called as a result of ResetDC(), we should restore the previous page count.		
			//
            pdev->pTiffPageHeader->iPageCount = pdev->pageCount;
							
			//
			// If DrvStartDoc() called as a result of ResetDC(), we should restore the previous page file pointer			
			//			
			pdev->pbTiffPageFP = (((LPBYTE)(pdev->pTiffPageHeader + 1)) + pdev->pTiffPageHeader->dwDataSize);			
        }
    }
    return TRUE;
}



BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;
    RECTL       pageRect;

    Verbose(("Entering DrvStartPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Ignore nested calls to DrvStartPage
    //

    if (pdev->flags & PDEV_WITHINPAGE) {

        Error(("Nested call to DrvStartPage\n"));
        return TRUE;
    }

    pdev->flags |= PDEV_WITHINPAGE;

    //
    // Erase the page to all white
    //

    pageRect.left = pageRect.top = 0;
    pageRect.right = pdev->imageSize.cx;
    pageRect.bottom = pdev->imageSize.cy;

    EngEraseSurface(pso, &pageRect, WHITE_INDEX);
    pdev->pageCount++;

    //
    // Reset our 'Mapping file pointer' if we have an open mapping and print preview is enabled
    //
    if (pdev->bPrintPreview)
    {
        Assert(pdev->pTiffPageHeader);

        //
        // Validate preview mapping
        //
        if (sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
        {
            Error(("Preview mapping corrupted\n"));
            pdev->bPrintPreview = FALSE;
        }
        else
        {
            if (FALSE == pdev->pTiffPageHeader->bPreview)
            {
                //
                // Preview operation was cancled by the UI dll
                //
                pdev->bPrintPreview = FALSE;
            }
            else
            {
                pdev->pbTiffPageFP = (LPBYTE) (pdev->pTiffPageHeader + 1);
                pdev->pTiffPageHeader->dwDataSize = 0;
                pdev->pTiffPageHeader->iPageCount = pdev->pageCount;
            }
        }
    }
    return TRUE;
}



BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvSendPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvSendPage...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Assert(pdev->flags & PDEV_WITHINPAGE);
    pdev->flags &= ~PDEV_WITHINPAGE;

    if (pdev->flags & PDEV_CANCELLED)
        return FALSE;

    //
    // Validate preview mapping
    //
    if (pdev->bPrintPreview && sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pdev->bPrintPreview = FALSE;
    }

    //
    // Output code to end a page
    //

    Assert(pso->lDelta == pdev->lineOffset);
    Assert(pso->fjBitmap & BMF_TOPDOWN);

    return OutputPageBitmap(pdev, pso->pvBits);
}



BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEndDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    flags - A set of flag bits

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEVDATA    pdev;

    Verbose(("Entering DrvEndDoc...\n"));

    //
    // Verify input parameters
    //

    Assert(pso != NULL);
    pdev = (PDEVDATA) pso->dhpdev;

    if (! ValidDevData(pdev)) {

        Error(("ValidDevData failed\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Validate preview mapping
    //
    if (pdev->bPrintPreview && sizeof(MAP_TIFF_PAGE_HEADER) != pdev->pTiffPageHeader->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pdev->bPrintPreview = FALSE;
    }

    if ((pdev->flags & PDEV_CANCELLED) || (flags & ED_ABORTDOC)) {

        Error(("Print job was cancelled\n"));

    } else if (pdev->pageCount) {

        //
        // Perform any necessary work at the end of a document
        //

        Verbose(("Number of pages printed: %d\n", pdev->pageCount));
        if (!OutputDocTrailer(pdev)) {
                Error(("OutputDocTrailer failed\n"));
                return FALSE;
        }
    }

    //
    // Clean up
    //
    pdev->pageCount = 0;
    pdev->flags = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\devinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devinfo.c

Abstract:

    Property sheet handler for "Device" page 

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

const static COLUMN_HEADER ColumnHeader[] = 
{
    { IDS_DEVICE_NAME,  190 },
    { IDS_SEND,         60  },
    { IDS_RECEIVE,      60  }
};

#define ColumnHeaderCount sizeof(ColumnHeader)/sizeof(COLUMN_HEADER)

PFAX_PORT_INFO_EX
GetSelectedPortInfo(
    HWND    hDlg
)
/*++

Routine Description:

  Find port info of the selected device

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    FAX_PORT_INFO_EX if successful, 
    NULL if failed or no device is selected

--*/
{
    HWND    hwndLv;
    INT     iItem;
    LVITEM  lvi = {0};

    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
    if(!hwndLv)
    {
        Assert(FALSE);
        return NULL;                
    }

    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
    if(iItem == -1)
    {
        return NULL;
    }

    lvi.iItem = iItem;
    lvi.mask  = LVIF_PARAM;
    ListView_GetItem(hwndLv, &lvi);

    pFaxPortInfo = FindPortInfo((DWORD)lvi.lParam);
    if(!pFaxPortInfo)
    {
        Error(("FindPortInfo() failed\n"));
        Assert(FALSE);
        return NULL;                
    }

    return pFaxPortInfo;
}

BOOL
FillInDeviceInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Fill in device information for currently selected device, if no
    device is selected, all text windows are empty

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed or no device is selected

--*/

{
    PFAX_PORT_INFO_EX   pFaxPortInfo;   // receive the fax port info
    TCHAR               szBuffer[MAX_TITLE_LEN];

    Verbose(("Entering FillInDeviceInfo...\n"));

    pFaxPortInfo = GetSelectedPortInfo(hDlg);
    if(!pFaxPortInfo)
    {
        Error(("GetSelectedPortInfo() failed\n"));
        goto error;
    }

    SetDlgItemText(hDlg, IDC_DEVICE_INFO_GRP, pFaxPortInfo->lpctstrDeviceName);

    SetDlgItemText(hDlg, IDC_TSID, pFaxPortInfo->bSend ? pFaxPortInfo->lptstrTsid : TEXT(""));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TSID), pFaxPortInfo->bSend);

    if(pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF)
    {
        SetDlgItemText(hDlg, IDC_CSID,  pFaxPortInfo->lptstrCsid);

        if(FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode)
        {
            DWORD               dwRes;
            BOOL                bVirtual;

            if(!Connect(hDlg, TRUE))
            {
                return FALSE;
            }

            dwRes = IsDeviceVirtual (g_hFaxSvcHandle, pFaxPortInfo->dwDeviceID, &bVirtual);
            if (ERROR_SUCCESS != dwRes)
            {
                return FALSE;
            }
            SetDlgItemInt (hDlg, IDC_RINGS, bVirtual? 1 : pFaxPortInfo->dwRings, FALSE);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));
        }
    }
    else // receive off
    {
        SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));
        SetDlgItemText(hDlg, IDC_CSID,  TEXT(""));        
    }

    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),  (pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS), (pFaxPortInfo->ReceiveMode == FAX_DEVICE_RECEIVE_MODE_AUTO));

    return TRUE;

error:
    //
    // make all info fields empty
    //
    if(!LoadString(ghInstance, IDS_NO_DEVICE_SELECTED, szBuffer, MAX_TITLE_LEN))
    {
        Error(( "LoadString failed, string ID is %d.\n", IDS_NO_DEVICE_SELECTED ));
        lstrcpy(szBuffer, TEXT(""));
    }

    SetDlgItemText(hDlg, IDC_DEVICE_INFO_GRP, szBuffer);
    SetDlgItemText(hDlg, IDC_TSID, TEXT(""));
    SetDlgItemText(hDlg, IDC_CSID, TEXT(""));
    SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));

    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TSID),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS), FALSE);

    return FALSE;
}

BOOL
UpdateDeviceInfo(
    HWND    hDlg
)

/*++

Routine Description:

    Display the send and receive information in the list view

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    HWND                hwndLv;
    INT                 iItem;
    INT                 iDeviceCount;
    LVITEM              lvi = {0};
    PFAX_PORT_INFO_EX   pFaxPortInfo;
    DWORD               dwResId;

    Verbose(("Entering UpdateDeviceInfo...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        lvi.iItem = iItem;
        lvi.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lvi);

        pFaxPortInfo = FindPortInfo((DWORD)lvi.lParam);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
   
        //
        // Send
        //
        dwResId = pFaxPortInfo->bSend ? IDS_DEVICE_ENABLED : IDS_DEVICE_DISABLED;
        ListView_SetItemText(hwndLv, iItem, 1, GetString(dwResId));

        //
        // Receive
        //
        switch (pFaxPortInfo->ReceiveMode)
        {
            case FAX_DEVICE_RECEIVE_MODE_OFF:
                dwResId = IDS_DEVICE_DISABLED;
                break;
            case FAX_DEVICE_RECEIVE_MODE_AUTO:
                dwResId = IDS_DEVICE_AUTO_ANSWER;
                break;
            case FAX_DEVICE_RECEIVE_MODE_MANUAL:
                dwResId = IDS_DEVICE_MANUAL_ANSWER;
                break;
            default:
                Assert (FALSE);
                dwResId = IDS_DEVICE_DISABLED;
                break;
        }
        ListView_SetItemText(hwndLv, iItem, 2, GetString(dwResId));
    }

    return TRUE;
}

BOOL
DoInitDeviceList(
    HWND hDlg // window handle of the device info page
    )

/*++

Routine Description:

    Initialize the list view and fill in device info of the first device in the list

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    HWND      hwndLv;  // list view window
    LVITEM    lv = {0};
    DWORD     dwDeviceIndex;
    DWORD     dwResId;

    PFAX_OUTBOUND_ROUTING_GROUP pFaxRoutingGroup = NULL;
    DWORD                       dwGroups;       // group number
    DWORD                       dwGroupIndex;
    DWORD                       dwDeviceCount;  // the return device number from FaxEnumOutboundGroups
    LPDWORD                     lpdwDevices = NULL; // temporary pointer to save group device info
    PFAX_PORT_INFO_EX           pFaxPortInfo;

    Verbose(("Entering DoInitDeviceList...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);


    if (!IsDesktopSKU())
    {
        if(!Connect(hDlg, TRUE))
        {
            return FALSE;
        }
        //
        // FaxEnumPortsEx doesn't provide device list under send device order
        // so we need to use FaxEnumOutboundGroups to do that.
        //
        if(!FaxEnumOutboundGroups(g_hFaxSvcHandle, &pFaxRoutingGroup, &dwGroups))
        {
            dwResId = GetLastError();
            Error(( "FaxEnumOutboundGroups() failed with %d.\n", dwResId));
            DisplayErrorMessage(hDlg, 0, dwResId);
            DisConnect();
            return FALSE;
        }
        DisConnect();
    

        for(dwGroupIndex = 0; dwGroupIndex < dwGroups; dwGroupIndex++)
        {
            if(!lstrcmp(pFaxRoutingGroup[dwGroupIndex].lpctstrGroupName, ROUTING_GROUP_ALL_DEVICES))
            {
                dwDeviceCount = pFaxRoutingGroup[dwGroupIndex].dwNumDevices;            
                lpdwDevices   = pFaxRoutingGroup[dwGroupIndex].lpdwDevices;

                Verbose(( "Total device number is %d.\n", dwDeviceCount ));
                Verbose(( "Group status is %d.\n", pFaxRoutingGroup[dwGroupIndex].Status ));
                break;
            }
        }

        // the device number from FaxEnumPortsEx and in the <All Devices> group should be the same.
        Assert(g_dwPortsNum == dwDeviceCount);
    }
    else
    {
        //
        // In desktop SKU
        // Fax outbound routing groups do not exist.
        // Fake the <All Devices> group now.
        //
        lpdwDevices = MemAlloc (sizeof (DWORD) * g_dwPortsNum);
        if (!lpdwDevices)
        {
            dwResId = GetLastError();
            Error(( "MemAlloc() failed with %d.\n", dwResId));
            DisplayErrorMessage(hDlg, 0, dwResId);
            DisConnect();
            return FALSE;
        }
        dwDeviceCount = g_dwPortsNum;
        for (dwDeviceIndex = 0; dwDeviceIndex < g_dwPortsNum; dwDeviceIndex++)
        {
            lpdwDevices[dwDeviceIndex] = g_pFaxPortInfo[dwDeviceIndex].dwDeviceID;
        }
    }
    lv.mask = LVIF_TEXT | LVIF_PARAM;

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; dwDeviceIndex++)
    {
        pFaxPortInfo = FindPortInfo(lpdwDevices[dwDeviceIndex]);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        lv.iItem   = dwDeviceIndex;
        lv.pszText = (LPTSTR)pFaxPortInfo->lpctstrDeviceName;
        lv.lParam  = (LPARAM)pFaxPortInfo->dwDeviceID;
        ListView_InsertItem(hwndLv, &lv);

        //
        // Send column
        //
        dwResId = pFaxPortInfo->bSend ? IDS_DEVICE_ENABLED : IDS_DEVICE_DISABLED;
        ListView_SetItemText(hwndLv, dwDeviceIndex, 1, GetString(dwResId));

        //
        // Receive column
        //
        switch (pFaxPortInfo->ReceiveMode)
        {
            case FAX_DEVICE_RECEIVE_MODE_OFF:
                dwResId = IDS_DEVICE_DISABLED;
                break;
            case FAX_DEVICE_RECEIVE_MODE_AUTO:
                dwResId = IDS_DEVICE_AUTO_ANSWER;
                break;
            case FAX_DEVICE_RECEIVE_MODE_MANUAL:
                dwResId = IDS_DEVICE_MANUAL_ANSWER;
                break;
            default:
                Assert (FALSE);
                dwResId = IDS_DEVICE_DISABLED;
                break;
        }
        ListView_SetItemText(hwndLv, dwDeviceIndex, 2, GetString(dwResId));
    }

    if (!IsDesktopSKU())
    {
        //
        // Server SKU
        //
        FaxFreeBuffer(pFaxRoutingGroup);
        pFaxRoutingGroup = NULL;
    }
    else
    {
        //
        // Desktop SKU
        //
        MemFree (lpdwDevices);
        lpdwDevices = NULL;
        //
        // Hide the label that talks about device priorities
        //
        ShowWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE), SW_HIDE);
        //
        // Hide the priority arrows
        //
        ShowWindow(GetDlgItem(hDlg, IDC_PRI_UP), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), SW_HIDE);
    }
    //
    // Select the first device and show its information
    //
    if(dwDeviceCount >= 1)
    {
        ListView_SetItemState(hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED);
        ValidateControl(hDlg, 0);
    }
    else
    {
        ValidateControl(hDlg, -1);
    }
    if (dwDeviceCount < 2)
    {
        //
        // Less than 2 devices - hide the label which talks about priorities
        //
        ShowWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE), SW_HIDE);
    }
    
    FillInDeviceInfo(hDlg);
    return TRUE;
}
    
BOOL
ValidateControl(
    HWND            hDlg,
    INT             iItem
    )
/*++

Routine Description:

    Validate the up and down button in the property page

Arguments:

    hDlg - Handle to the property sheet page
    iItem - index of the item being selected

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT     iDeviceCount;
    HWND    hwndLv;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    if(!g_bUserCanChangeSettings)
    {
        PageEnable(hDlg, FALSE);

        EnableWindow(hwndLv, TRUE);
    }

    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP), (iItem != -1));

    //
    // if there is only one device or we don't click on any item
    // up and down buttons are disabled
    //
    if(iDeviceCount < 2 || iItem == -1)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), FALSE);

        return TRUE;
    }

    if(g_bUserCanChangeSettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_UP), iItem > 0); // not the top one
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), iItem < iDeviceCount - 1); // not the last one
    }
    if (!IsWindowEnabled (GetFocus()))
    {
        //
        // The currently selected control turned disabled - select the list control
        //
        SetFocus (GetDlgItem (hDlg, IDC_DEVICE_LIST));
    }

    return TRUE;
}

BOOL
ChangePriority(
    HWND            hDlg,
    BOOL            bMoveUp
    )
/*++

Routine Description:

    Validate the up and down button in the fax property page

Arguments:

    hDlg - Handle to the fax property sheet page
    bMoveUp -- TRUE for moving up, FALSE for moving down

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT             iItem;
    BOOL            rslt;
    LVITEM          lv = {0};
    TCHAR           pszText[MAX_DEVICE_NAME];
    TCHAR           szEnableSend[64];           // for enable/disable send text
    TCHAR           szEnableReceive[64];        // for enable/disable receive text
    INT             iDeviceCount;
    HWND            hwndLv;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    // 
    // find the current selected Item
    //
    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

    if(iItem == -1)
    {
        Error(("No device is selected. Can't change priority.\n"));
        return FALSE;
    }

    // 
    // get selected item information and then remove it
    //
    lv.iItem      = iItem;
    lv.iSubItem   = 0;
    lv.mask       = LVIF_TEXT | LVIF_PARAM;
    lv.pszText    = pszText;
    lv.cchTextMax = ARRAYSIZE(pszText);
    ListView_GetItem(hwndLv, &lv);

    ListView_GetItemText(hwndLv, iItem, 1, szEnableSend,    ARRAYSIZE(szEnableSend)); // for send
    ListView_GetItemText(hwndLv, iItem, 2, szEnableReceive, ARRAYSIZE(szEnableReceive)); // for receive

    rslt = ListView_DeleteItem(hwndLv, iItem);

    //
    // recalculate the item index;
    //
    if(bMoveUp)
    {
        lv.iItem--;
    }
    else
    {
        lv.iItem++;
    }

    //
    // reinsert the item and validate button state
    //
    iItem = ListView_InsertItem(hwndLv, &lv);
    ListView_SetItemText(hwndLv, iItem, 1, szEnableSend);
    ListView_SetItemText(hwndLv, iItem, 2, szEnableReceive);

    ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);
    ValidateControl(hDlg, iItem);

    return TRUE;
}

BOOL
DoSaveDeviceList(
    HWND hDlg // window handle of the device info page
    )

/*++

Routine Description:

    Save the list view info to the system

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    INT                 iItem;
    INT                 iDeviceCount;
    HWND                hwndLv;                 // list view window
    LVITEM              lv;
    DWORD               dwDeviceId;
    DWORD               dwRes = 0;

    Verbose(("Entering DoSaveDeviceList...\n"));
    //
    // Get the list view window handle
    //
    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }
    //
    // Get total number of fax devices
    //
    iDeviceCount = ListView_GetItemCount(hwndLv);
    //
    // 1st iteration - disabled receive and send devices only
    //
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        // Get device ID first, then save the changes.
        ZeroMemory(&lv, sizeof(lv));
        lv.iItem = iItem;
        lv.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lv);

        dwDeviceId = (DWORD)lv.lParam;

        pFaxPortInfo = FindPortInfo(dwDeviceId);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        if (pFaxPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pFaxPortInfo->ReceiveMode))
        {
            //
            // Fax device is active - skip it for now
            //
            continue;
        }
        if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
        {
            dwRes = GetLastError();
            Error(("FaxSetPortEx() failed with %d.\n", dwRes));
            break;
        }
    }
    //
    // 2nd iteration - enabled receive or send devices only
    //
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        // Get device ID first, then save the changes.
        ZeroMemory(&lv, sizeof(lv));
        lv.iItem = iItem;
        lv.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lv);

        dwDeviceId = (DWORD)lv.lParam;

        pFaxPortInfo = FindPortInfo(dwDeviceId);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        if (!pFaxPortInfo->bSend && (FAX_DEVICE_RECEIVE_MODE_OFF == pFaxPortInfo->ReceiveMode))
        {
            //
            // Fax device is inactive - skip it.
            // It was already set in the 1st iteration.
            //
            continue;
        }
        if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
        {
            dwRes = GetLastError();
            Error(("FaxSetPortEx() failed with %d.\n", dwRes));
            break;
        }
    }
    if (!IsDesktopSKU())
    {
        //
        // 3rd iteration.
        // Save send priority, FAX_PORT_INFO_EX doesn't have Priority field, so use FaxSetDeviceOrderInGroup
        // Send priority is only relevant to server SKUs.
        //
        for(iItem = 0; iItem < iDeviceCount; ++iItem)
        {
            // Get device ID first, then save the changes.
            ZeroMemory(&lv, sizeof(lv));
            lv.iItem = iItem;
            lv.mask  = LVIF_PARAM;
            ListView_GetItem(hwndLv, &lv);

            dwDeviceId = (DWORD)lv.lParam;

            pFaxPortInfo = FindPortInfo(dwDeviceId);
            if(!pFaxPortInfo)
            {
                Error(("FindPortInfo() failed\n"));
                Assert(FALSE);
                continue;
            }
            if(!FaxSetDeviceOrderInGroup(g_hFaxSvcHandle, ROUTING_GROUP_ALL_DEVICES, dwDeviceId, iItem + 1))
            {
                dwRes = GetLastError();
                Error(("FaxSetDeviceOrderInGroup() failed with %d.\n", dwRes));
                break;
            }
        }
    }
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            break;
    }
    return (dwRes == 0);
}   // DoSaveDeviceList

void
DisplayDeviceProperty(
    HWND    hDlg
)

/*++

Routine Description:

    Open a property sheet for a specific device

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    none

--*/

{
    HWND            hwndLv;
    INT             iDeviceCount;
    INT             iItem;
    TCHAR           szDeviceName[MAX_PATH] = {0};
    PROPSHEETHEADER psh = {0};
    PROPSHEETPAGE   psp[3] = {0};                   // property sheet pages info for device info
    HPROPSHEETPAGE  hPropSheetPages[3];
    LVITEM          lvi = {0};
    DWORD           dw;

    PFAX_PORT_INFO_EX  pFaxPortInfo; 
    DWORD              dwPortsNum;  

    Verbose(("Entering DisplayDeviceProperty...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    // 
    // find the current selected Item
    //
    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

    if(iItem == -1)
    {
        Verbose(("No device is selected. Can't display properties.\n"));
        return;
    }

    lvi.iItem      = iItem;
    lvi.mask       = LVIF_PARAM | LVIF_TEXT;
    lvi.pszText    = szDeviceName;
    lvi.cchTextMax = MAX_PATH;

    ListView_GetItem(hwndLv, &lvi);

    //
    // Get an array of property sheet page handles
    //
    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].hInstance   = ghInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEND_PROP);
    psp[0].pfnDlgProc  = DevSendDlgProc;
    psp[0].lParam      = lvi.lParam;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].hInstance   = ghInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_RECEIVE_PROP);
    psp[1].pfnDlgProc  = DevRecvDlgProc;
    psp[1].lParam      = lvi.lParam;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].hInstance   = ghInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_CLEANUP_PROP);
    psp[2].pfnDlgProc  = DevCleanupDlgProc;
    psp[2].lParam      = lvi.lParam;

    hPropSheetPages[0] = CreatePropertySheetPage( &psp[0] );
    hPropSheetPages[1] = CreatePropertySheetPage( &psp[1] );
    if (IsDesktopSKU())
    {
        hPropSheetPages[2] = CreatePropertySheetPage( &psp[2] );
    }

    Assert(hPropSheetPages[0]);
    Assert(hPropSheetPages[1]);
    if (IsDesktopSKU())
    {
        Assert(hPropSheetPages[2]);
    }

    //
    // Fill out PROPSHEETHEADER structure
    //
    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_USEICONID;
    psh.hwndParent = hDlg;
    psh.hInstance  = ghInstance;
    psh.pszIcon    = MAKEINTRESOURCE(IDI_DEVICE_INFO);
    psh.pszCaption = szDeviceName;
    psh.nPages     = IsDesktopSKU() ? 3 : 2;
    psh.nStartPage = 0;
    psh.phpage     = hPropSheetPages;

    //
    // Display the property sheet
    //
    if(PropertySheet(&psh) == -1)
    {
        Error(( "PropertySheet() failed with %d\n", GetLastError() ));
        return;
    }

    if(!g_bPortInfoChanged)
    {
        return;
    }

    //
    // merge the changes into the g_pFaxPortInfo
    //
    if(Connect(NULL, FALSE))
    {
        if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pFaxPortInfo, &dwPortsNum))
        {
            Error(( "FaxEnumPortsEx failed with %d\n", GetLastError()));
        }

        DisConnect();
    }

    if(!pFaxPortInfo || !dwPortsNum)
    {
        FaxFreeBuffer(pFaxPortInfo);
        return;
    }

    for(dw = 0; dw < dwPortsNum; ++dw)
    {
        PFAX_PORT_INFO_EX  pPortInfo; 

        if(pFaxPortInfo[dw].dwDeviceID == (DWORD)lvi.lParam)
        {
            //
            // Selected device already updated
            //
            continue;
        }

        pPortInfo = FindPortInfo(pFaxPortInfo[dw].dwDeviceID);
        if(!pPortInfo)
        {
            continue;
        }

        pFaxPortInfo[dw].bSend    = pPortInfo->bSend;
        pFaxPortInfo[dw].ReceiveMode = pPortInfo->ReceiveMode;
    }

    FaxFreeBuffer(g_pFaxPortInfo);
    g_pFaxPortInfo = pFaxPortInfo;
    g_dwPortsNum   = dwPortsNum;
    NotifyDeviceUsageChanged ();
    g_bPortInfoChanged = FALSE;
}


BOOL
ShowContextMenu(
    HWND                hDlg
    )

/*++

Routine Description:

    Display the context menu in the device list

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/
{
    DWORD               dwMessagePos;
    DWORD               dwRes;
    BOOL                bVirtual;
    PFAX_PORT_INFO_EX   pFaxPortInfo;

    HMENU hMenu;
    HMENU hSubMenu;
    HMENU hSubSubMenu;

    Verbose(("Entering ShowContextMenu...\n"));

    pFaxPortInfo = GetSelectedPortInfo(hDlg);
    if(!pFaxPortInfo)
    {
        Error(("GetSelectedPortInfo() failed\n"));
        return FALSE;              
    }
    //
    // Load context-sensitive menu
    //
    hMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(IDR_SEND_RECEIVE));
    if(!hMenu)
    {
        Assert(FALSE);
        return FALSE;
    }
    hSubMenu = GetSubMenu(hMenu, 0);
    if(!hSubMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }
    //
    // Send
    //
    hSubSubMenu = GetSubMenu(hSubMenu, 0);
    if(!hSubSubMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }

    CheckMenuItem(hSubSubMenu, 
                  IDM_SEND_ENABLE,  
                  pFaxPortInfo->bSend ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_SEND_DISABLE, 
                  !pFaxPortInfo->bSend ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);


    //
    // Receive
    //
    hSubSubMenu = GetSubMenu(hSubMenu, 1);
    if(!hMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_AUTO,  
                  (FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_MANUAL, 
                  (FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_DISABLE, 
                  (FAX_DEVICE_RECEIVE_MODE_OFF == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);



    if(!Connect(hDlg, TRUE))
    {
        DestroyMenu (hMenu);
        return FALSE;
    }

    dwRes = IsDeviceVirtual (g_hFaxSvcHandle, pFaxPortInfo->dwDeviceID, &bVirtual);
    if (ERROR_SUCCESS != dwRes)
    {
        DestroyMenu (hMenu);
        return FALSE;
    }

    if (bVirtual)
    {
        //
        // If the device is virtual, can't set to to manual answer mode
        //
        Assert (FAX_DEVICE_RECEIVE_MODE_MANUAL != pFaxPortInfo->ReceiveMode);
        EnableMenuItem (hSubSubMenu, IDM_RECEIVE_MANUAL, MF_BYCOMMAND | MF_GRAYED);
    }

    SetMenuDefaultItem(hSubMenu, IDM_PROPERTY, FALSE);

    // Get the cursor position
    dwMessagePos = GetMessagePos();

    // Display the context menu
    TrackPopupMenu(hSubMenu, 
                   TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                   LOWORD(dwMessagePos), 
                   HIWORD(dwMessagePos), 0, hDlg, NULL);

    DestroyMenu (hMenu);
    DisConnect();
    return TRUE;
}   // ShowContextMenu

INT_PTR 
CALLBACK 
DeviceInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the device info tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            HICON       hIconUp, hIconDown;
            LV_COLUMN   lvc = {0};
            DWORD       dwIndex;
            TCHAR       szBuffer[RESOURCE_STRING_LEN];
            HWND        hwndLv;

            //
            // Load icons.
            //
            hIconUp = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_UP));
            hIconDown = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_DOWN));

            // icon handles for up and down arrows.
            SendDlgItemMessage(hDlg, IDC_PRI_UP, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconUp);
            SendDlgItemMessage(hDlg, IDC_PRI_DOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconDown);

            SendDlgItemMessage(hDlg, IDC_TSID, EM_SETLIMITTEXT, TSID_LIMIT, 0);
            SendDlgItemMessage(hDlg, IDC_CSID, EM_SETLIMITTEXT, CSID_LIMIT, 0);

            //
            // Set list view style and columns
            //
            hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
            ListView_SetExtendedListViewStyle(hwndLv, LVS_EX_FULLROWSELECT);

            lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt     = LVCFMT_LEFT;
            lvc.pszText = szBuffer;

            for(dwIndex = 0; dwIndex < ColumnHeaderCount; dwIndex++)
            {
                if(!LoadString(ghInstance, ColumnHeader[dwIndex].uResourceId ,szBuffer, RESOURCE_STRING_LEN))
                {
                    Error(( "LoadString failed, string ID is %d.\n", ColumnHeader[dwIndex].uResourceId ));
                    lstrcpy(szBuffer, TEXT(""));
                }

                lvc.cx       = ColumnHeader[dwIndex].ColumnWidth;
                lvc.iSubItem = (INT)dwIndex;

                ListView_InsertColumn( hwndLv, dwIndex, &lvc );
            }

            DoInitDeviceList(hDlg);
            return TRUE;
            break;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_PRI_UP:
            case IDC_PRI_DOWN:

                ChangePriority(hDlg, (LOWORD(wParam) == IDC_PRI_UP) ? TRUE : FALSE);
                Notify_Change(hDlg);
                break;

            case IDM_PROPERTY:
            case IDC_DEVICE_PROP:
            {
                HWND    hwndLv;     // handle of the list view window
                INT     iItem = -1; // default value for non client area

                //
                // Get current selected item
                //
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem  = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

                if(iItem == -1)
                {
                    Verbose(("No device is selected. Can't display device info.\n"));
                    break;
                }

                DisplayDeviceProperty(hDlg);

                // refresh the list view
                UpdateDeviceInfo(hDlg);
                FillInDeviceInfo(hDlg);
                break;
            }


            case IDM_SEND_ENABLE:
            case IDM_SEND_DISABLE:
            case IDM_RECEIVE_AUTO:
            case IDM_RECEIVE_MANUAL:
            case IDM_RECEIVE_DISABLE:
            {
                PFAX_PORT_INFO_EX   pFaxPortInfo;

                pFaxPortInfo = GetSelectedPortInfo(hDlg);
                if(!pFaxPortInfo)
                {
                    Error(("GetSelectedPortInfo() failed\n"));
                    break;                
                }

                if(IDM_SEND_ENABLE    == LOWORD(wParam) ||
                   IDM_RECEIVE_AUTO   == LOWORD(wParam) ||
                   IDM_RECEIVE_MANUAL == LOWORD(wParam))
                {
                    if(!IsDeviceInUse(pFaxPortInfo->dwDeviceID) && 
                       GetDeviceLimit() == CountUsedFaxDevices())
                    {
                        //
                        // Device is *NOT* in use and we're about to make it used and
                        // we're at the limit point.
                        //
                        BOOL bLimitExceeded = TRUE;

                        if (IDM_RECEIVE_MANUAL == LOWORD(wParam))
                        {
                            //
                            // Do one more check: if we make the device manual-answer, let's make sure the 
                            // previous manual-answer device will turn to inactive. If that's the case, we don't exceed
                            // the device limit.
                            //
                            DWORD dw;

                            for (dw = 0; dw < g_dwPortsNum; dw++)
                            {
                                if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                                {
                                    //
                                    // We found the other device who's about to loose its manual-answer mode
                                    //
                                    if (!g_pFaxPortInfo[dw].bSend)
                                    {
                                        //
                                        // This is the special case we were looking for
                                        //
                                        bLimitExceeded = FALSE;
                                    }
                                    break;
                                }
                            }
                        }
                        if (bLimitExceeded)
                        {
                            DisplayErrorMessage(hDlg, 
                                MB_OK | MB_ICONSTOP, 
                                FAXUI_ERROR_DEVICE_LIMIT, 
                                GetDeviceLimit());
                            break;
                        }
                    }
                }

                if(IDM_RECEIVE_MANUAL == LOWORD(wParam))
                {
                    //
                    // Turn off manual-answer for ALL devices.
                    //
                    DWORD dw;

                    for (dw = 0; dw < g_dwPortsNum; dw++)
                    {
                        if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                        {
                            g_pFaxPortInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                        }
                    }
                    //
                    // Turn on manual-answer for selected device only.
                    //
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
                }
                else if(IDM_RECEIVE_AUTO == LOWORD(wParam))
                {
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
                }
                else if(IDM_RECEIVE_DISABLE == LOWORD(wParam))
                {
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                }
                else if(IDM_SEND_ENABLE  == LOWORD(wParam) ||
                        IDM_SEND_DISABLE == LOWORD(wParam))
                {
                    pFaxPortInfo->bSend = (IDM_SEND_ENABLE == LOWORD(wParam)) ? TRUE : FALSE;
                }
                UpdateDeviceInfo(hDlg);
                FillInDeviceInfo(hDlg);

                Notify_Change(hDlg);
                NotifyDeviceUsageChanged ();
                break;
            }

            default:
                break;
        }

        break;

    case WM_CONTEXTMENU:
        //
        // Also handle keyboard-originated context menu (<Shift>+F10 or VK_APP)
        //
        if (!g_bUserCanChangeSettings)
        {
            //
            // User has no rights to change the device settings - show no menu
            //
            break;
        }
        if (GetDlgItem(hDlg, IDC_DEVICE_LIST) != GetFocus())
        {
            //
            // Only show context sensitive menu if the focus is on the list control
            //
            break;
        }
        if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DEVICE_LIST)) == 0)
        {
            //
            // If there aren't item in the list, return immediately.
            //
            break;
        }
        //
        // Popup context menu near mouse cursor
        //
        ShowContextMenu(hDlg);
        break;

    case WM_NOTIFY:
    {

        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {

            case NM_CLICK:
            case NM_RCLICK:
            {
                //
                // Handle a Click event
                //
                LPNMITEMACTIVATE lpnmitem;

                lpnmitem = (LPNMITEMACTIVATE)lParam;

                if (IDC_DEVICE_LIST != lpnmitem->hdr.idFrom)
                {
                    //
                    // Not our list view control
                    //
                    break;
                }
                //
                // If there aren't item in the list, return immediately.
                //
                if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DEVICE_LIST)) == 0)
                {
                    break;
                }
                if(lpnmitem->iItem == -1)
                {
                    //
                    // User just un-selected the selected item from the list.
                    // Update the other controls on the dialog
                    //
                    ValidateControl(hDlg, lpnmitem->iItem);
                    FillInDeviceInfo(hDlg);
                }

                break;
            }

            case NM_DBLCLK:
            {
                // do the same thing as clicking the "Properties" button
                SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_DEVICE_PROP, BN_CLICKED), 0L);
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 
                LPNMLISTVIEW pnmv; 

                pnmv = (LPNMLISTVIEW) lParam; 
                if(pnmv->uNewState & LVIS_SELECTED)
                {
                    ValidateControl(hDlg, pnmv->iItem);
                    FillInDeviceInfo(hDlg);
                }

                break;
            }

            case PSN_APPLY:

                if(g_bUserCanChangeSettings)
                {
                    if (DoSaveDeviceList(hDlg))
                    {
                        FillInDeviceInfo(hDlg);
                        Notify_UnChange(hDlg);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                }

                return TRUE;

            default :
                break;

        } // switch

        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\devcaps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devcaps.c

Abstract:

    Implementation of DrvDeviceCapabilities

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"

//
// Forward declaration for local functions
//

DWORD
CalcMinMaxExtent(
    PPOINT      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

DWORD
EnumResolutions(
    PLONG       pResolutions
    );



DWORD
DrvDeviceCapabilities(
    HANDLE      hPrinter,
    LPTSTR      pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Provides information about the specified device and its capabilities

Arguments:

    hPrinter - Identifies a printer object
    pDeviceName - Points to a null-terminated device name string
    wCapability - Specifies the interested device capability
    pOutput - Points to the output buffer
    pdm - Points to the source devmode structure

Return Value:

    The return value depends on wCapability.

Note:

    Please refer for DDK documentation for more details.

--*/

{
    FORM_INFO_1 *pFormsDB=NULL;
    DWORD       cForms;
    DWORD       result = 0;
    DRVDEVMODE  dmCombinedDevMode;

    Verbose(("Entering DrvDeviceCapabilities: %d %x...\n", wCapability, pOutput));

    //
    // Validate input devmode and combine it with driver default
    //
    ZeroMemory(&dmCombinedDevMode,sizeof(dmCombinedDevMode));
    GetCombinedDevmode(&dmCombinedDevMode, pdm, hPrinter, NULL, FALSE);

    result = 0;

    //
    // Return appropriate information depending upon wCapability
    //

    switch (wCapability) {

    case DC_VERSION:

        result = dmCombinedDevMode.dmPublic.dmSpecVersion;
        break;

    case DC_DRIVER:

        result = dmCombinedDevMode.dmPublic.dmDriverVersion;
        break;

    case DC_SIZE:

        result = dmCombinedDevMode.dmPublic.dmSize;
        break;

    case DC_EXTRA:

        result = dmCombinedDevMode.dmPublic.dmDriverExtra;
        break;

    case DC_FIELDS:

        result = dmCombinedDevMode.dmPublic.dmFields;
        break;

    case DC_COPIES:

        result = 1;
        break;

    case DC_ORIENTATION:

        //
        // Landscape rotates counterclockwise
        //

        result = 90;
        break;

    case DC_PAPERNAMES:
    case DC_PAPERS:
    case DC_PAPERSIZE:
    case DC_MINEXTENT:
    case DC_MAXEXTENT:

        //
        // Get a list of forms in the forms database
        //

        pFormsDB = GetFormsDatabase(hPrinter, &cForms);

        if (pFormsDB == NULL || cForms == 0) {

            Error(("Cannot get system forms\n"));
            return GDI_ERROR;
        }

        result = (wCapability == DC_MINEXTENT || wCapability == DC_MAXEXTENT) ?
                    CalcMinMaxExtent(pOutput, pFormsDB, cForms, wCapability) :
                    EnumPaperSizes(pOutput, pFormsDB, cForms, wCapability);

        MemFree(pFormsDB);
        break;

    case DC_BINNAMES:

        //
        // Simulate a single input slot
        //

        if (pOutput)
            LoadString(ghInstance, IDS_SLOT_ONLYONE, pOutput, CCHBINNAME);
        result = 1;
        break;

    case DC_BINS:

        if (pOutput)
            *((PWORD) pOutput) = DMBIN_ONLYONE;
        result = 1;
        break;

    case DC_ENUMRESOLUTIONS:

        result = EnumResolutions(pOutput);
        break;

    default:

        Error(("Unknown device capability: %d\n", wCapability));
        result = GDI_ERROR;
        break;
    }

    return result;
}



DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves a list of supported paper sizes

Arguments:

    pOutput - Specifies a buffer for storing requested information
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - Specifies what the caller is interested in

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LPTSTR  pPaperNames = NULL;
    PWORD   pPapers = NULL;
    PPOINT  pPaperSizes = NULL;

    //
    // Figure out what the caller is interested in
    //

    switch (wCapability) {

    case DC_PAPERNAMES:
        pPaperNames = pOutput;
        break;

    case DC_PAPERSIZE:
        pPaperSizes = pOutput;
        break;

    case DC_PAPERS:
        pPapers = pOutput;
        break;

    default:
        Assert(FALSE);
    }

    //
    // Go through each form in the forms database
    //

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect requested information
        //

        if (! IsSupportedForm(pFormsDB))
            continue;

        count++;

        //
        // Return the size of the form in 0.1mm units.
        // The unit used in FORM_INFO_1 is 0.001mm.
        //

        if (pPaperSizes) {

            pPaperSizes->x = pFormsDB->Size.cx / 100;
            pPaperSizes->y = pFormsDB->Size.cy / 100;
            pPaperSizes++;
        }

        //
        // Return the formname.
        //

        if (pPaperNames) {

            CopyString(pPaperNames, pFormsDB->pName, CCHPAPERNAME);
            pPaperNames += CCHPAPERNAME;
        }

        //
        // Return one-based index of the form.
        //

        if (pPapers)
            *pPapers++ = (WORD) index + DMPAPER_FIRST;
    }

    return count;
}



DWORD
CalcMinMaxExtent(
    PPOINT      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves the minimum or maximum paper size extent

Arguments:

    pOutput - Specifies a buffer for storing requested information
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - What the caller is interested in: DC_MAXEXTENT or DC_MINEXTENT

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LONG    minX, minY, maxX, maxY;

    //
    // Go through each form in the forms database
    //

    minX = minY = MAX_LONG;
    maxX = maxY = 0;

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect the requested information
        //

        if (! IsSupportedForm(pFormsDB))
            continue;

        count++;

        if (pOutput == NULL)
            continue;

        if (minX > pFormsDB->Size.cx)
            minX = pFormsDB->Size.cx;

        if (minY > pFormsDB->Size.cy)
            minY = pFormsDB->Size.cy;

        if (maxX < pFormsDB->Size.cx)
            maxX = pFormsDB->Size.cx;

        if (maxY < pFormsDB->Size.cy)
            maxY = pFormsDB->Size.cy;
    }

    //
    // If an output buffer is provided, store the calculated
    // minimum and maximum extent information.
    //

    if (pOutput != NULL) {

        //
        // NOTE: What unit does the caller expect?! The documentation
        // doesn't mention anything about this. I assume this should
        // be in the same unit as DEVMODE.dmPaperLength, which is 0.1mm.
        //

        if (wCapability == DC_MINEXTENT) {

            pOutput->x = minX / 100;
            pOutput->y = minY / 100;

        } else {

            pOutput->x = maxX / 100;
            pOutput->y = maxY / 100;
        }
    }

    return count;
}



DWORD
EnumResolutions(
    PLONG       pResolutions
    )

/*++

Routine Description:

    Retrieves a list of supported resolutions

Arguments:

    pResolutions - Specifies a buffer for storing resolution information

Return Value:

    Number of resolutions supported

Note:

    Each resolution is represented by two LONGs representing
    horizontal and vertical resolutions (in dpi) respectively.

--*/

{
    if (pResolutions != NULL) {

        //
        // We support the following resolution settings:
        //  Normal = 200x200 dpi
        //  Draft = 200x100 dpi
        //

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTICAL;

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTDRAFT;
    }

    return 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\faxopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxopts.c

Abstract:

    Functions for handling the Fax Options property sheet page

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "faxhelp.h"

//
// Table for mapping control IDs to help indices
//

static ULONG_PTR faxOptionsHelpIDs[] = {

    IDC_PAPER_SIZE,                 IDH_FAXDEFAULT_PAPER_SIZE,
    IDC_IMAGE_QUALITY,              IDH_FAXDEFAULT_IMAGE_QUALITY,
    IDC_PORTRAIT,                   IDH_FAXDEFAULT_PORTRAIT,
    IDC_LANDSCAPE,                  IDH_FAXDEFAULT_LANDSCAPE,
    IDI_FAX_OPTIONS,                (DWORD) -1,
    IDC_TITLE,                      (DWORD) -1,
    IDC_DEFAULT_PRINT_SETUP_GRP,    IDH_FAXDEFAULT_DEFAULT_PRINT_SETUP_GRP,
    IDC_ORIENTATION,                IDH_FAXDEFAULT_ORIENTATION,
    0,                              0
};



VOID
DoInitializeFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Initializes the Fax Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE        pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE      pdmPrivate = &pUiData->devmode.dmPrivate;
    TCHAR           buffer[MAX_STRING_LEN];
    HWND            hwndList;
    INT             itemId;

    //
    // Initialize the print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if (hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) {

        LPTSTR  pFormName = pUiData->pFormNames;
        INT     listIdx;

        for (itemId=0; itemId < pUiData->cForms; itemId++, pFormName += CCHPAPERNAME) {

            if ((listIdx = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFormName)) != CB_ERR) {

                SendMessage(hwndList, CB_SETITEMDATA, listIdx, itemId);

                if (_tcscmp(pFormName, pdmPublic->dmFormName) == EQUAL_STRING)
                    SendMessage(hwndList, CB_SETCURSEL, listIdx, 0);
            }
        }
    }

    if (hwndList = GetDlgItem(hDlg, IDC_IMAGE_QUALITY)) {

        LoadString(ghInstance, IDS_QUALITY_NORMAL, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        LoadString(ghInstance, IDS_QUALITY_DRAFT, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        itemId = (pdmPublic->dmYResolution == FAXRES_VERTDRAFT) ? 1 : 0;
        SendMessage(hwndList, CB_SETCURSEL, itemId, 0);
    }

    itemId = (pdmPublic->dmOrientation == DMORIENT_LANDSCAPE) ?
                IDC_LANDSCAPE : IDC_PORTRAIT;

    CheckDlgButton(hDlg, itemId, TRUE);


    //
    // Disable all controls if the user has no permission
    //

    if (! pUiData->hasPermission) {
        EnableWindow(GetDlgItem(hDlg, IDC_PAPER_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_IMAGE_QUALITY), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PORTRAIT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LANDSCAPE), FALSE);
    }
}



VOID
DoSaveFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Save the information on the Fax Options property sheet page to registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE    pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE  pdmPrivate = &pUiData->devmode.dmPrivate;
    HWND        hwndList;
    INT         listIdx;

    //
    // Time to send
    //

    //
    // Retrieve the current settings of print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) &&
        (listIdx = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR)
    {
        listIdx = (INT)SendMessage(hwndList, CB_GETITEMDATA, listIdx, 0);

        if (listIdx >= 0 && listIdx < pUiData->cForms) {

            pdmPublic->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
            pdmPublic->dmFields |= DM_FORMNAME;
            pdmPublic->dmPaperSize = pUiData->pPapers[listIdx];

            CopyString(pdmPublic->dmFormName,
                        pUiData->pFormNames + listIdx * CCHPAPERNAME,
                        CCHFORMNAME);
        }
    }

    pdmPublic->dmPrintQuality = FAXRES_HORIZONTAL;

    pdmPublic->dmYResolution =
        (SendDlgItemMessage(hDlg, IDC_IMAGE_QUALITY, CB_GETCURSEL, 0, 0) == 1) ?
            FAXRES_VERTDRAFT :
            FAXRES_VERTICAL;

    pdmPublic->dmOrientation =
         IsDlgButtonChecked(hDlg, IDC_LANDSCAPE) ? DMORIENT_LANDSCAPE : DMORIENT_PORTRAIT;
}


INT_PTR
FaxOptionsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling Fax Options property sheet page

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    static BOOL bPortrait;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Remember the pointer to our UIDATA structure
        //

        lParam = ((PROPSHEETPAGE *) lParam)->lParam;
        pUiData = (PUIDATA) lParam;
        Assert(ValidUiData(pUiData));
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        //
        // Intitialize the controls with information from the registry
        //

        DoInitializeFaxOptions(hDlg, pUiData);
        bPortrait = IsDlgButtonChecked(hDlg,IDC_PORTRAIT);
        return TRUE;

    case WM_COMMAND:

        if (HIWORD(wParam) == CBN_SELCHANGE) {
            if (GetDlgCtrlID((HWND)lParam) == IDC_IMAGE_QUALITY ||
                GetDlgCtrlID((HWND)lParam) == IDC_PAPER_SIZE ) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        if (HIWORD(wParam) == BN_CLICKED) {
            if ((LOWORD(wParam) == IDC_PORTRAIT && !bPortrait) ||
                (LOWORD(wParam) == IDC_LANDSCAPE && bPortrait)) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        break;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_APPLY) {
            pUiData = (PUIDATA) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidUiData(pUiData));

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveFaxOptions(hDlg, pUiData);


            //
            // HACK: Inform common UI library that user has pressed OK
            //

            pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                     CPSFUNC_SET_RESULT,
                                     (LPARAM) pUiData->hFaxOptsPage,
                                     CPSUI_OK);

            return TRUE;
        } else if (((NMHDR *) lParam)->code == DTN_DATETIMECHANGE) {
           PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\docprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docprop.c

Abstract:

    Implemetation of DDI entry points:
        DrvDocumentPropertySheets
        DrvDocumentProperties
        DrvAdvancedDocumentProperties
        DrvConvertDevMode

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include "libproto.h"
#include "faxhelp.h"


INT_PTR FaxOptionsProc(HWND, UINT, WPARAM, LPARAM);
LONG SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER);
BOOL GenerateFormsList(PUIDATA);
BOOL AddDocPropPages(PUIDATA, LPTSTR);
LPTSTR GetHelpFilename(PUIDATA);
BOOL SaveUserInfo(PDRVDEVMODE);

BOOL
SaveUserInfo(PDRVDEVMODE pDM) {
    HKEY hKey;
    
    if ((hKey = GetUserInfoRegKey(REGKEY_USERINFO,FALSE))) {
        SetRegistryString( hKey, REGVAL_BILLING_CODE, pDM->dmPrivate.billingCode  );
        SetRegistryString( hKey, REGVAL_MAILBOX     , pDM->dmPrivate.emailAddress );

        RegCloseKey(hKey);
        return TRUE;
    }

    return FALSE;
}




LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Document Properties" property sheets

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PUIDATA                 pUiData;
    int                     iRet = -1;
    //
    // Validate input parameters
    // pPSUIInfo = NULL is a special case: don't need to display the dialog
    //

    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ? pPSUIInfo->lParamInit : lParam))) {

        Assert(FALSE);
        return -1;
    }

    if (pPSUIInfo == NULL)
    {
        return SimpleDocumentProperties(pDPHdr);
    }

    Verbose(("DrvDocumentPropertySheets: %d\n", pPSUIInfo->Reason));

    //
    // Create a UIDATA structure if necessary
    //
    pUiData = (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) ?
                    FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn) :
                    (PUIDATA) pPSUIInfo->UserData;

    if (!ValidUiData(pUiData))
    {
        goto exit;
    }
    //
    // Handle various cases for which this function might be called
    //
    switch (pPSUIInfo->Reason) 
    {
        case PROPSHEETUI_REASON_INIT:

            pUiData->hasPermission = ((pDPHdr->fMode & DM_NOPERMISSION) == 0);
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (pDPHdr->fMode & DM_USER_DEFAULT)
            {
                pUiData->configDefault = TRUE;
            }
            //
            // Find online help filename
            //
            GetHelpFilename(pUiData);
            //
            // Add our pages to the property sheet
            //
            if (GenerateFormsList(pUiData) && AddDocPropPages(pUiData, pDPHdr->pszPrinterName)) 
            {
                pPSUIInfo->UserData = (DWORD_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                iRet = 1;
                goto exit;
            }
            //
            // Clean up properly in case of an error
            //
            HeapDestroy(pUiData->hheap);
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

                pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
                pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
                pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
                pPSUIHdr->hInst = ghInstance;
                pPSUIHdr->IconID = IDI_CPSUI_PRINTER2;
            }
            iRet = 1;
            goto exit;

        case PROPSHEETUI_REASON_SET_RESULT:
            //
            // Copy the new devmode back into the output buffer provided by the caller
            // Always return the smaller of current and input devmode
            //
            {
                PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;

                Verbose(("Set result: %d\n", pSRInfo->Result));

                if (pSRInfo->Result == CPSUI_OK && (pDPHdr->fMode & (DM_COPY|DM_UPDATE))) 
                {

                    ConvertDevmodeOut((PDEVMODE) &pUiData->devmode,
                                      pDPHdr->pdmIn,
                                      pDPHdr->pdmOut);
                    SaveUserInfo(&pUiData->devmode);
                }

                pPSUIInfo->Result = pSRInfo->Result;
            }
            iRet = 1;
            goto exit;

        case PROPSHEETUI_REASON_DESTROY:
            //
            // Cleanup properly before exiting
            //
            HeapDestroy(pUiData->hheap);
            iRet = 1;
            goto exit;
    }

exit:
    return iRet;
}   // DrvDocumentPropertySheets


LONG
DoDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Arguments:

    hwnd - Handle to the parent window of the document properties dialog box.

    hPrinter - Handle to a printer object.

    pPrinterName - Points to a null-terminated string that specifies
        the name of the device for which the document properties dialog
        box should be displayed.

    pdmOutput - Points to a DEVMODE structure that receives the document
        properties data specified by the user.

    pdmInput - Points to a DEVMODE structure that initializes the dialog
        box controls. This parameter can be NULL.

    fmode - Specifies a mask of flags that determine which operations
        the function performs.

Return Value:

    > 0 if successful
    = 0 if canceled
    < 0 if error

--*/

{
    DOCUMENTPROPERTYHEADER  docPropHdr;
    DWORD                   result;

    //
    // Initialize a DOCUMENTPROPERTYHEADER structure
    //

    memset(&docPropHdr, 0, sizeof(docPropHdr));
    docPropHdr.cbSize = sizeof(docPropHdr);
    docPropHdr.hPrinter = hPrinter;
    docPropHdr.pszPrinterName = pPrinterName;
    docPropHdr.pdmIn = pdmInput;
    docPropHdr.pdmOut = pdmOutput;
    docPropHdr.fMode = fMode;

    //
    // Don't need to get compstui involved when the dialog is not displayed
    //

    if ((fMode & DM_PROMPT) == 0)
        return SimpleDocumentProperties(&docPropHdr);

    CallCompstui(hwnd, DrvDocumentPropertySheets, (LPARAM) &docPropHdr, &result);
    return result;
}


LONG
DrvDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Routine Description:

    Set the public members of a DEVMODE structure for a print document

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    LONG result;

    Verbose(("Entering DrvDocumentProperties: fMode = %x...\n", fMode));

    //
    // Check if caller is asking querying for size
    //

    if (fMode == 0 || pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Call the common routine shared with DrvAdvancedDocumentProperties
    //

    result = DoDocumentProperties(hwnd, hPrinter, pPrinterName, pdmOutput, pdmInput, fMode);

    return (result > 0) ? IDOK : (result == 0) ? IDCANCEL : result;
}


LONG
DrvAdvancedDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Set the private members of a DEVMODE structure.
    In this release, this function is almost identical to
    DrvDocumentProperties above with a few minor exceptions

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    Verbose(("Entering DrvAdvancedDocumentProperties...\n"));

    //
    // Return the number of bytes required if pdmOutput is NULL
    //

    if (pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Otherwise, call the common routine shared with DrvDocumentProperties
    //

    return DoDocumentProperties(hwnd,
                                hPrinter,
                                pPrinterName,
                                pdmOutput,
                                pdmInput,
                                DM_COPY|DM_PROMPT|DM_ADVANCED) > 0;
}



BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pdmIn,
    PDEVMODE    pdmOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    Use by SetPrinter and GetPrinter to convert devmodes

Arguments:

    pPrinterName - Points to printer name string
    pdmIn - Points to the input devmode
    pdmOut - Points to the output devmode buffer
    pcbNeeded - Specifies the size of output buffer on input
        On output, this is the size of output devmode
    fMode - Specifies what function to perform

Return Value:

    TRUE if successful
    FALSE otherwise and an error code is logged

--*/

{
    static DRIVER_VERSION_INFO versionInfo = {

        // Current driver version number and private devmode size

        DRIVER_VERSION, sizeof(DMPRIVATE),

        // 3.51 driver version number and private devmode size
        // NOTE: We don't have a 3.51 driver - use current version number and devmode size.

        DRIVER_VERSION, sizeof(DMPRIVATE)
    };

    INT     result;
    HANDLE  hPrinter;

    Verbose(("Entering DrvConvertDevMode: %x...\n", fMode));

    //
    // Call a library routine to handle the common cases
    //

    result = CommonDrvConvertDevmode(pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode, &versionInfo);

    //
    // If not handled by the library routine, we only need to worry
    // about the case when fMode is CDM_DRIVER_DEFAULT
    //

    if (result == CDM_RESULT_NOT_HANDLED && fMode == CDM_DRIVER_DEFAULT) {

        //
        // Return driver default devmode
        //

        if (OpenPrinter(pPrinterName, &hPrinter, NULL)) {

            PDRVDEVMODE pdmDefault = (PDRVDEVMODE) pdmOut;

            DriverDefaultDevmode(pdmDefault, pPrinterName, hPrinter);
            pdmDefault->dmPrivate.flags |= FAXDM_DRIVER_DEFAULT;

            result = CDM_RESULT_TRUE;
            ClosePrinter(hPrinter);

        } else
            Error(("OpenPrinter failed: %d\n", GetLastError()));
    }

    return (result == CDM_RESULT_TRUE);
}



LONG
SimpleDocumentProperties(
    PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    PUIDATA pUiData;

    //
    // Check if the caller is interested in the size only
    //

    pDPHdr->cbOut = sizeof(DRVDEVMODE);

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL)
        return pDPHdr->cbOut;

    //
    // Create a UIDATA structure
    //

    if (! (pUiData = FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn)))
        return -1;

    //
    // Copy the devmode back into the output buffer provided by the caller
    // Always return the smaller of current and input devmode
    //

    if (pDPHdr->fMode & (DM_COPY | DM_UPDATE))
        ConvertDevmodeOut((PDEVMODE) &pUiData->devmode, pDPHdr->pdmIn, pDPHdr->pdmOut);

    HeapDestroy(pUiData->hheap);
    return 1;
}



BOOL
AddDocPropPages(
    PUIDATA pUiData,
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Add our "Document Properties" pages to the property sheet

Arguments:

    pUiData - Points to our UIDATA structure
    pPrinterName - Specifies the printer name

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PROPSHEETPAGE   psp = {0};
    HANDLE          hActCtx;
    //
    // "Document Properties" dialog only has one tab - "Fax Options"
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = ghInstance;

    psp.lParam = (LPARAM) pUiData;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DOCPROP);
    psp.pfnDlgProc = FaxOptionsProc;
    //
    // Need to add a Activation Context so that Compstui will create the property page using
    // ComCtl v6 (i.e. so it will / can be Themed).
    //
    hActCtx = GetFaxActivationContext();
    if (INVALID_HANDLE_VALUE != hActCtx)
    {
        pUiData->pfnComPropSheet(pUiData->hComPropSheet, 
                                 CPSFUNC_SET_FUSION_CONTEXT, 
                                 (LPARAM)hActCtx, 
                                 0);
    }

    pUiData->hFaxOptsPage = (HANDLE)
        pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                 CPSFUNC_ADD_PROPSHEETPAGE,
                                 (LPARAM) &psp,
                                 0);

    return (pUiData->hFaxOptsPage != NULL);
}



BOOL
GenerateFormsList(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Generate the list of forms supported by the fax driver

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFORM_INFO_1    pFormsDB;
    DWORD           cForms, count;

    //
    // Get a list of forms in the forms database
    //

    pFormsDB = GetFormsDatabase(pUiData->hPrinter, &cForms);

    if (pFormsDB == NULL || cForms == 0) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    //
    // Enumerate the list of supported forms
    //

    pUiData->cForms = count = EnumPaperSizes(NULL, pFormsDB, cForms, DC_PAPERS);
    Assert(count != GDI_ERROR);

    pUiData->pFormNames = HeapAlloc(pUiData->hheap, 0, sizeof(TCHAR) * count * CCHPAPERNAME);
    pUiData->pPapers = HeapAlloc(pUiData->hheap, 0, sizeof(WORD) * count);

    if (!pUiData->pFormNames || !pUiData->pPapers) 
    {
        if(pUiData->pFormNames)
        {
            HeapFree(pUiData->hheap, 0, pUiData->pFormNames);
        }

        if(pUiData->pPapers)
        {
            HeapFree(pUiData->hheap, 0, pUiData->pPapers);
        }

        MemFree(pFormsDB);
        return FALSE;
    }

    EnumPaperSizes(pUiData->pFormNames, pFormsDB, cForms, DC_PAPERNAMES);
    EnumPaperSizes(pUiData->pPapers, pFormsDB, cForms, DC_PAPERS);

    MemFree(pFormsDB);
    return TRUE;
}



LPTSTR
GetHelpFilename(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Return the driver's help filename string

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    Pointer to the driver help filename, NULL if error

--*/

{
    PDRIVER_INFO_3  pDriverInfo3 = NULL;
    PVOID           pHelpFile = NULL;

    //
    // Attempt to get help file name using the new DRIVER_INFO_3
    //

    if (pDriverInfo3 = MyGetPrinterDriver(pUiData->hPrinter, 3)) {

        if ((pDriverInfo3->pHelpFile != NULL) &&
            (pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(pDriverInfo3->pHelpFile))))
        {
            _tcscpy(pHelpFile, pDriverInfo3->pHelpFile);
        }

        MemFree(pDriverInfo3);
    }

    //
    // If DRIVER_INFO_3 isn't supported, get help file name the old fashion way
    //

    if (pHelpFile == NULL) {
        if (!(pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(FAXCFG_HELP_FILENAME))) )
        {
            pHelpFile = NULL;

        } else {

            _tcscpy(pHelpFile, FAXCFG_HELP_FILENAME);
        }
    }

    Verbose(("Driver help filename: %ws\n", pHelpFile));
    return (pUiData->pHelpFile = pHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\print\faxprint\faxui\docevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docevent.c

Abstract:

    Implementation of DrvDocumentEvent

Environment:

    Fax driver user interface

Revision History:

    01/13/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include "prtcovpg.h"
#include "jobtag.h"
#include "faxreg.h"
#include "faxsendw.h"
#include "InfoWzrd.h"
#include "tifflib.h"
#include "faxutil.h"
#include "covpg.h"


//
// Defenitions
//
#define SZ_CONT                             TEXT("...")
#define SZ_CONT_SIZE                        (sizeof(SZ_CONT) / sizeof(TCHAR))


//
// Data structure passed in during CREATEDCPRE document event
//

typedef struct 
{
    LPTSTR      pDriverName;    // driver name
    LPTSTR      pPrinterName;   // printer name
    PDEVMODE    pdmInput;       // input devmode
    ULONG       fromCreateIC;   // whether called from CreateIC

} CREATEDCDATA, *PCREATEDCDATA;

//
// Data structure passed in during ESCAPE document event
//

typedef struct 
{
    ULONG       iEscape;        // nEscape parameter passed to ExtEscape
    ULONG       cbInput;        // cbInput parameter passed to ExtEscape
    LPCSTR      p