ss *pEvent)
{
    if (!_fSelectOnMouseDown)
    {
        return OptionClicked(pEvent, SELECT_FIREEVENT);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OptionClicked()
//
// Synopsis:    Handles the event if the option is clicked
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OptionClicked(CEventObjectAccess *pEvent, DWORD dwFlags /* = 0 */)
{
    HRESULT         hr;
    IPrivateSelect  *pSelect    = NULL;
    long            lIndex;
    long            lKeyboardStatus = NULL;
    long            lMouseButtons = NULL;
    VARIANT_BOOL    bDisabled;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    hr = pSelect->GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    // Check if the button that went down is the left mouse button
    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Setup the key status
        dwFlags |= (lKeyboardStatus & EVENT_ALTKEY) ? SELECT_ALT : 0;
        dwFlags |= (lKeyboardStatus & EVENT_SHIFTKEY) ? SELECT_SHIFT : 0;
        dwFlags |= (lKeyboardStatus & EVENT_CTRLKEY) ? SELECT_CTRL : 0;

        hr = get_index(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionClicked(lIndex, dwFlags);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::RenderChanges()
//
// Synopsis:    When the select has a viewlink, we do not want to render
//              changes in the option since it's hidden.
//
// Arguments:   BOOL *pbRender - Returns whether we want to render
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::RenderChanges(BOOL *pbRender)
{
    HRESULT         hr;
    DWORD           dwFlavor;
    IPrivateSelect  *pSelect    = NULL;

    Assert(pbRender);

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    pSelect->GetFlavor(&dwFlavor);
    if (FAILED(hr))
        goto Cleanup;

    *pbRender = SELECT_ISLISTBOX(dwFlavor);

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnPropertyChange()
//
// Synopsis:    Allows a recalc of the option's width
//
// Arguments:   CEventObjectAccess *pEvent - Event info
//              BSTR bstr
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstr)
{
    _fResize = TRUE;
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnSelectStart()
//
// Synopsis:    Cancels the selection event so that users cannot
//              drag and select text in the option. SELECT will
//              handle mouse drags as selecting OPTION elements.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnSelectStart(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::CancelEvent()
//
// Synopsis:    Cancels the event.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::CancelEvent(CEventObjectAccess *pEvent)
{
    HRESULT     hr;
    CVariant    var;

    // Cancel the event by returning FALSE
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_FALSE;
    hr = pEvent->EventObj()->put_returnValue(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IPrivateOption overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetSelected()
//
// Synopsis:    Sets the current selected status to bOn.
//
// Arguments:   VARIANT_BOOL bOn - The new selected status
//              BOOL *pbChanged  - Returns if the selection status changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetSelected(VARIANT_BOOL bOn)
{
    HRESULT         hr;
    long            lSel = bOn ? 0 : -1;

    hr = GetProps()[eSelected].Set(lSel);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetHighlight(bOn);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelected()
//
// Synopsis:    Sets *pbOn to the current selected status.
//
// Arguments:   VARIANT_BOOL *pbOn - Receives the selected status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetSelected(VARIANT_BOOL *pbOn)
{
    HRESULT hr;
    long    lSel;

    hr = GetProps()[eSelected].Get(&lSel);
    if (FAILED(hr))
        goto Cleanup;

    *pbOn = (lSel == -1) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetHighlight()
//
// Synopsis:    Sets the current highlight status to bOn.
//
// Arguments:   VARIANT_BOOL bOn - The new highlight status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetHighlight(VARIANT_BOOL bOn)
{
    HRESULT         hr;
    BOOL            bRender;
    CComBSTR        bstrBkCol;
    CComBSTR        bstrCol;
    CVariant        var;
    CContextAccess  a(_pSite);

    _fPrevHighlight = _fHighlight;

    if ((_fHighlight ? VARIANT_TRUE : VARIANT_FALSE) == bOn)
    {
        hr = S_OK;
        goto Cleanup;
    }

    _fHighlight = bOn;

    hr = RenderChanges(&bRender);
    if (FAILED(hr) || !bRender)     // If failed or no need to render, stop
        goto Cleanup;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup Colors
    if (_fHighlight)
    {
        bstrBkCol = _T("highlight");
        bstrCol = _T("highlighttext");
    }
    else
    {
        bstrBkCol = _T("");
        bstrCol = _T("");
    }

    // Setup background
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrBkCol;
    hr = a.DefStyle()->put_backgroundColor(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup foreground color
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrCol;
    hr = a.DefStyle()->put_color(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetHighlight()
//
// Synopsis:    Sets *pbOn to the current highlight status.
//
// Arguments:   VARIANT_BOOL *pbOn - Receives the highlight status
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetHighlight(VARIANT_BOOL *pbOn)
{
    Assert(pbOn);

    *pbOn = _fHighlight ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetIndex()
//
// Synopsis:    Sets the index property. (For initialization)
//
// Arguments:   long lIndex - The new index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetIndex(long lIndex)
{
    return GetProps()[eIndex].Set(lIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetIndex()
//
// Synopsis:    Gets the index property.
//
// Arguments:   long *plIndex - The index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::GetIndex(long *plIndex)
{
    return GetProps()[eIndex].Get(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::Reset()
//
// Synopsis:    Sets the selection status back to the initial status.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::Reset()
{
    return SetHighlight(_fInitSel ? VARIANT_TRUE : VARIANT_FALSE);
}

#ifndef OPTION_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetFinalDefaultStyles()
//
// Synopsis:    After setting dimensions, sets some final styles.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetFinalDefaultStyles()
{
    HRESULT         hr = S_OK;
    CComBSTR        bstrWidth(_T("100%"));
    CComBSTR        bstrNoWrap(_T("nowrap"));
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Force the width to 100%
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrWidth;
    hr = a.Style()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

    // Turn on nowrap
    hr = a.DefStyle()->put_whiteSpace(bstrNoWrap);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetFinalHeight()
//
// Synopsis:    Sets the final height of the option.
//
// Arguments:   long lHeight    The new height
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIEOptionElement::SetFinalHeight(long lHeight)
{
    HRESULT         hr = S_OK;
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Force the height
    V_VT(&var) = VT_I4;
    V_I4(&var) = lHeight;
    hr = a.Style()->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}
#endif

#ifdef OPTION_GETSIZE

/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorLayout overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetLayoutInfo()
//
// Synopsis:    Returns the type of layout we want.
//
// Arguments:   LONG *plLayoutInfo - Returns the layout info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetLayoutInfo(LONG *plLayoutInfo)
{
    Assert(plLayoutInfo);

    *plLayoutInfo = BEHAVIORLAYOUTINFO_MODIFYNATURAL;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSize()
//
// Synopsis:    Returns the size we want.
//
// Arguments:   LONG  dwFlags         - Request type
//              SIZE  sizeContent     - Content size
//              POINT *pptTranslate   - Translation point
//              POINT *pptTopLeft     - Top left point
//              SIZE  *psizeProposed  - Returns our proposed size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSize(LONG dwFlags, 
                          SIZE sizeContent, 
                          POINT * pptTranslate, 
                          POINT * pptTopLeft, 
                          SIZE  * psizeProposed)
{
    HRESULT         hr;
    IPrivateSelect  *pSelect = NULL;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    hr = pSelect->OnOptionSized(&sizeContent, _fFirstSize, _fResize);
    if (FAILED(hr))
        goto Cleanup;

    *psizeProposed = sizeContent;
    _fFirstSize = FALSE;
    _fResize = FALSE;

Cleanup:
    ReleaseInterface(pSelect);
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\select.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\select.cxx
//
// Contents:    The SELECT control.
//
// Classes:     CIESelectElement
//
// Interfaces:  IHTMLSelectElement3
//              IPrivateSelect
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_HXX_
#define __X_IEXTAG_HXX_
#include "iextag.h"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif


// TODO: This is a magic number right now, should be based on font
#define SELECT_OPTIONWIDTH  4
#define SELECT_OPTIONHEIGHT 16
#define SELECT_MAXOPTIONS   12

#define SELECT_SCROLLWAIT   250
#define SELECT_TIMERVLWAIT  10

const CBaseCtl::PROPDESC CIESelectElement::s_propdesc[] = 
{
    {_T("size"), VT_I4, -1},
    {_T("selectedIndex"), VT_I4, -1},
    {_T("multiple"), VT_I4, -1},
    {_T("name"), VT_BSTR, NULL, NULL},
    {_T("length"), VT_I4, 0},
    {_T("type"), VT_BSTR, NULL, NULL},
    NULL
};

enum
{
    eSize               = 0,
    eSelectedIndex      = 1,
    eMultiple           = 2,
    eName               = 3,
    eLength             = 4,
    eType               = 5,
};


/////////////////////////////////////////////////////////////////////////////
//
// CIESelectElement
//
/////////////////////////////////////////////////////////////////////////////


BOOL                CIESelectElement::_bSavedCtrl       = FALSE;
UINT_PTR            CIESelectElement::_iTimerID         = 0;
CIESelectElement    *CIESelectElement::_pTimerSelect    = NULL;
POINT               CIESelectElement::_ptSavedPoint;
#ifdef SELECT_TIMERVL
UINT_PTR            CIESelectElement::_iTimerVL         = 0;
LONG                CIESelectElement::_lTimerVLRef      = 0;
CRITICAL_SECTION    CIESelectElement::_lockTimerVL;
CIESelectElement::SELECT_TIMERVL_LINKELEM  *CIESelectElement::_queueTimerVL = NULL;
#endif

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CIESelectElement()
//
// Synopsis:    Initializes member variables.
//
// Arguments:   None
//
// Returns:     None.
//
//-------------------------------------------------------------------
CIESelectElement::CIESelectElement()
{
    _lShiftAnchor = -1;
    _lTopChanged = -1;
    _lBottomChanged = -1;
    _pDispDocLink = NULL ;

#ifdef SELECT_GETSIZE
    _fLayoutDirty = TRUE;
#endif
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::~CIESelectElement()
//
// Synopsis:    Releases the event sink.
//
// Arguments:   None
//
// Returns:     None.
//
//-------------------------------------------------------------------
CIESelectElement::~CIESelectElement()
{
    if (_pSinkPopup)
    {
        delete _pSinkPopup;
    }
    if (_pSinkVL)
    {
        delete _pSinkVL;
    }
    if (_pSinkButton)
    {
        delete _pSinkButton;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehavior overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Detach()
{
    HRESULT         hr = S_OK;
    VARIANT_BOOL    bOpen;
    
    ClearInterface(&_pDispDocLink);
    ClearInterface(&_pLastSelected);
    ClearInterface(&_pLastHighlight);
    ClearInterface(&_pSelectInPopup);
    ClearInterface(&_pElemDisplay);
    ClearInterface(&_pStyleButton);

    if (_pPopup && !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            hr = HidePopup();
            if (FAILED(hr))
                goto Cleanup;
         }

        ClearInterface(&_pPopup);
    }

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorSubmit overrides and helpers
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Reset()
//
// Synopsis:    Resets the selection status to the original status.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Reset()
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IPrivateOption          *pOption        = NULL;
    CVariant                var, var2;
    VARIANT_BOOL            bOn;
    long                    lLastSelected   = -1;
    CContextAccess          a(_pSite);
    

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the children and length
    //
    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Go through all of the children and
    // run a reset on them.
    //
    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        // Reset the option's selection status
        hr = pOption->Reset();
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->GetHighlight(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (bOn)
        {
            lLastSelected = iItem;
            ClearInterface(&_pLastHighlight);
            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

    if (lLastSelected == -1)
    {
        lLastSelected = 0;
    }

    if (SELECT_ISDROPBOX(_fFlavor) && (cItems > 0))
    {
        hr = GetIndex(lLastSelected, &pOption);
        if (FAILED(hr))
            goto Cleanup;

        if (pOption)
        {
            DropDownSelect(pOption);
        }
    }

    hr = CommitSelection(NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSubmitInfo(IHTMLSubmitData *pSubmitData)
{
    HRESULT             hr;
    CComBSTR            bstrName;
    CContextAccess      a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get this control's name
    hr = get_name(&bstrName);
    if (FAILED(hr))
        goto Cleanup;

    if ((bstrName == NULL) || (bstrName[0] == 0))
    {
        //
        // If the control does not have a name,
        // then the operation failed.
        //
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    // Append the submit info
    //
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = GetMultipleSubmitInfo(pSubmitData, bstrName);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = GetSingleSubmitInfo(pSubmitData, bstrName);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSingleSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission when
//              the select is a single select.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//              CComBSTR *pbstrName  - the name of the select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSingleSubmitInfo(IHTMLSubmitData *pSubmitData, CComBSTR bstrName)
{
    HRESULT             hr;
    long                lIndex;
    CComBSTR            bstrVal;
    IHTMLOptionElement2 *pOption = NULL;

    hr = get_selectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lIndex < 0)
    {
        // There is no selection, so stop
        goto Cleanup;
    }

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr) || !pOption)
    {
        // If the option does not exist,
        // ignore the error and stop
        hr = S_OK;
        goto Cleanup;
    }

    // Get the value to submit
    hr = pOption->get_value(&bstrVal);
    if (FAILED(hr))
        goto Cleanup;

    // Append the data
    hr = pSubmitData->appendNameValuePair(bstrName, bstrVal);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetMultipleSubmitInfo()
//
// Synopsis:    Sends the information for a forms submission when
//              the select is a multiple select.
//
// Arguments:   IHTMLSubmitData *pSubmitData - submit interface
//              CComBSTR *pbstrName  - the name of the select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetMultipleSubmitInfo(IHTMLSubmitData *pSubmitData, CComBSTR bstrName)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    CComBSTR                bstrVal;
    CVariant                var, var2;
    BOOL                    bNeedSeparator  = FALSE;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IHTMLOptionElement2     *pOption        = NULL;
    CContextAccess          a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Go through all the children, find the selected ones, and submit their info
    //
    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IHTMLOptionElement2, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        hr = pOption->get_selected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected)
        {
            //
            // The option is selected, so submit its value
            //
            if (bNeedSeparator)
            {
                // Separate the item from the previous item
                hr = pSubmitData->appendItemSeparator();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else
            {
                bNeedSeparator = TRUE;
            }

            hr = pOption->get_value(&bstrVal);
            if (FAILED(hr))
                goto Cleanup;

            hr = pSubmitData->appendNameValuePair(bstrName, bstrVal);
            if (FAILED(hr))
                goto Cleanup;
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorFocus overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetFocusRect()
//
// Synopsis:    Sets pRect to the rectangle of the focus rect.
//
// Arguments:   pRect - Receives the focus rectangle
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetFocusRect(RECT * pRect)
{
    HRESULT         hr;
    long            lNumOptions;
    IHTMLElement    *pElem      = NULL;
    IDispatch       *pDispatch  = NULL;
    VARIANT_BOOL    bOpen;
    long            lTopIndex;
    long            lBottomIndex;
    CContextAccess  a(_pSite);
    RECT            rect;
    long            lIndex;
    
    Assert(pRect);

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    lIndex = _lFocusIndex;

    if (SELECT_ISLISTBOX(_fFlavor))
    {
        hr = a.Open(CA_ELEM2);
        if (FAILED(hr))
            goto Cleanup;

        if (lNumOptions == 0)
        {
            if (!SELECT_ISINPOPUP(_fFlavor))
            {
                pRect->top = 0;
                pRect->left = 0;
#ifdef SELECT_GETSIZE
                pRect->right = _sizeOption.cx;
                pRect->bottom = _sizeOption.cy;
#else
                pRect->bottom = SELECT_OPTIONHEIGHT;
                hr = a.Elem2()->get_clientWidth(&pRect->right);
                if (FAILED(hr))
                    goto Cleanup;
#endif
            }
        }
        else
        {
            hr = GetTopVisibleOptionIndex(&lTopIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetBottomVisibleOptionIndex(&lBottomIndex);
            if (FAILED(hr))
                goto Cleanup;

            // Make sure the option is onscreen
            if ((_lFocusIndex >= lTopIndex) && (_lFocusIndex < lBottomIndex))
            {
                // If the writingmode is "tb-rl", the index is got with counting from left to right.
                // Hence, it needs to be changed to the actual index so that the index is as from 
                // right to left.
                if (_fWritingModeTBRL)
                {
                    lIndex = lNumOptions-_lFocusIndex-1;
                }
                hr = GetIndex(lIndex, &pDispatch);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pDispatch->QueryInterface(IID_IHTMLElement, (void**)&pElem);
                if (FAILED(hr))
                    goto Cleanup;
                
                hr = pElem->get_offsetTop(&rect.top);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pElem->get_offsetLeft(&rect.left);
                if (FAILED(hr))
                    goto Cleanup;

                // If the writingmode is "tb-rl", then, the top and left values are interchaged to 
                // present the options in right to left manner.
                if (_fWritingModeTBRL)
                {
                    pRect->left = rect.top;
                    pRect->top = rect.left;
                }
                else
                {
                    pRect->top = rect.top; 
                    pRect->left = rect.left;
                }

#ifdef SELECT_GETSIZE
                if (_fWritingModeTBRL)
                {
                    // The rectangle now changes to present the options text in vertical direction 
                    // and hence the changes in width and height.
                    hr = a.Elem2()->get_clientHeight(&pRect->right); 
                    if (FAILED(hr))
                        goto Cleanup;

                    pRect->right += pRect->left;
                    pRect->bottom = pRect->top + _sizeOption.cy; 
                }
                else
                {
                    hr = a.Elem2()->get_clientWidth(&pRect->right); 
                    if (FAILED(hr))
                        goto Cleanup;

                    pRect->bottom = pRect->top + _sizeOption.cy;
                }
#else
                hr = pElem->get_offsetWidth(&pRect->right);
                if (FAILED(hr))
                    goto Cleanup;

                hr = pElem->get_offsetHeight(&pRect->bottom);
                if (FAILED(hr))
                    goto Cleanup;

                pRect->right += pRect->left;
                pRect->bottom += pRect->top;
#endif

            }
        }
    }
    else if (SELECT_ISDROPBOX(_fFlavor) && (lNumOptions > 0))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOpen)
        {
#ifdef SELECT_GETSIZE
            // TODO: Handle with real borders
            pRect->left = 1;
            pRect->top = 1;
            pRect->right = pRect->left + _sizeOption.cx;
            pRect->bottom = pRect->top + _sizeOption.cy;

#else
            hr = _pElemDisplay->get_offsetTop(&rect.top);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetLeft(&rect.left);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetWidth(&rect.bottom);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pElemDisplay->get_offsetHeight(&rect.right);
            if (FAILED(hr))
                goto Cleanup;

            *pRect = rect;
            if (_fWritingModeTBRL)
            {
                pRect->top = rect.left;
                pRect->left = rect.top;
            }
            else
            {
                pRect->right = rect.bottom;
                pRect->bottom = rect.right;
            }

            pRect->right += pRect->left;
            pRect->bottom += pRect->top;
#endif
        }
    }


Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshFocusRect()
//
// Synopsis:    Refreshes the focus rectangle.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::RefreshFocusRect()
{
    HRESULT             hr;
    CContextAccess      a(_pSite);

    hr = a.Open(CA_ELEM3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->put_hideFocus(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->put_hideFocus(VARIANT_FALSE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


#ifdef SELECT_GETSIZE
/////////////////////////////////////////////////////////////////////////////
//
// IElementBehaviorLayout overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetLayoutInfo()
//
// Synopsis:    Returns the type of layout we want.
//
// Arguments:   LONG *plLayoutInfo - Returns the layout info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetLayoutInfo(LONG *plLayoutInfo)
{
    Assert(plLayoutInfo);

    *plLayoutInfo = BEHAVIORLAYOUTINFO_MODIFYNATURAL;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSize()
//
// Synopsis:    Returns the size we want.
//
// Arguments:   LONG  dwFlags         - Request type
//              SIZE  sizeContent     - Content size
//              POINT *pptTranslate   - Translation point
//              POINT *pptTopLeft     - Top left point
//              SIZE  *psizeProposed  - Returns our proposed size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetSize(LONG  dwFlags, 
                          SIZE  sizeContent, 
                          POINT *pptTranslate, 
                          POINT *pptTopLeft, 
                          SIZE  *psizeProposed)
{
    HRESULT     hr = S_OK;
    BOOL        bWidthSet;
    BOOL        bHeightSet;
    long        lButtonWidth    = GetSystemMetrics(SM_CXVSCROLL);


    // if this is not a normal sizing pass, or if this is the second
    // call due to percent sized children, just leave.
    if (! (dwFlags & BEHAVIORLAYOUTMODE_NATURAL)
         || dwFlags & BEHAVIORLAYOUTMODE_FINAL_PERCENT)
        goto Cleanup;

    hr = IsWidthHeightSet(&bWidthSet, &bHeightSet);
    if (FAILED(hr))
        goto Cleanup;

    if (!_fLayoutDirty && (bWidthSet || bHeightSet))
    {
        // Check to see if the layout really is dirty
        _fLayoutDirty = (psizeProposed->cx != _sizeSelect.cx) ||
                        (psizeProposed->cy != _sizeSelect.cy);
    }

    if (!_fAllOptionsSized)
    {
        // If we have zero options, then all the options have been sized
        // This doesn't get set correctly because OnOptionSized will never get
        // called when there are no options.
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        _fAllOptionsSized = lNumOptions == 0;
    }

    if (_fLayoutDirty && _fContentReady && _fAllOptionsSized)
    {

        _fLayoutDirty = FALSE;

        if (SELECT_ISDROPBOX(_fFlavor) && _fVLEngaged)
        {
            _sizeContent = _sizeOption;             // the forced option size
            // TODO: +2 for padding
            _sizeContent.cx += lButtonWidth + 2;
            _sizeContent.cy += 2;

            _sizeSelect = _sizeContent;
        }
        else
        {
            long        lSize;

            hr = get_size(&lSize);
            if (FAILED(hr))
                goto Cleanup;

            // If we have no default option size, then set to a default size
            if (_sizeOption.cx == 0)
            {
                _sizeOption.cx = SELECT_OPTIONWIDTH;

                if (!_fNeedScrollBar)
                {
                    _sizeOption.cx += lButtonWidth;
                }
            }

            if (_sizeOption.cy == 0)
            {
                _sizeOption.cy = SELECT_OPTIONHEIGHT;
            }

            if (_fNeedScrollBar)
            {
                _sizeContent.cx = _sizeOption.cx;
            }
            else if(_sizeContent.cx < _sizeOption.cx)
            {
                _sizeContent.cx = _sizeOption.cx;
            }

            if (_fNeedScrollBar)
            {
                _sizeContent.cx += lButtonWidth;
            }  
            _sizeContent.cy = _sizeOption.cy * lSize;

            _sizeSelect = _sizeContent;
        }

        // Add in the border and padding
        // TODO: Replace with real border
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            _sizeSelect.cx += 4;
            _sizeSelect.cy += 4;
        }
        else if (!SELECT_ISINPOPUP(_fFlavor))
        {
            _sizeSelect.cx += 6;
            _sizeSelect.cy += 6;
        }
        

        if (bHeightSet)
        {
            _sizeSelect.cy = psizeProposed->cy;

            // TODO: Replace with real border
            _sizeContent.cy = _sizeSelect.cy - 6;

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                // Make sure that the content height is a multiple of the height of the options
                _sizeContent.cy -= _sizeContent.cy % _sizeOption.cy;
                // TODO: Replace with real border
                _sizeSelect.cy = _sizeContent.cy + 6;
            }
        }

        if (bWidthSet)
        {
            _sizeSelect.cx = psizeProposed->cx;
            // TODO: Replace with real border

            _sizeContent.cx = _sizeSelect.cx - 6;
            // _sizeContent.cx -= 8;

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                long lNumOptions;

                hr = GetNumOptions(&lNumOptions);
                if (FAILED(hr))
                    goto Cleanup;

                _sizeOption.cx = _sizeContent.cx;
                if (lNumOptions > (_sizeContent.cy / _sizeOption.cy))
                {
                    // Scrollbars are needed
                    _sizeOption.cx -= lButtonWidth;
                }
            }

            if (SELECT_ISDROPBOX(_fFlavor))
            {
                _sizeSelect.cx += lButtonWidth + 2;
            }
        }

        // TODO: Remove _lMaxHeight everywhere
        _lMaxHeight = _sizeOption.cy;
    }

    *psizeProposed = _sizeSelect;

    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::IsWidthHeightSet()
//
// Synopsis:    Returns whether the width and/or height was set in the style.
//
// Arguments:   BOOL *pbWidthSet    - Returns if the width was set
//              BOOL *pbHeightSet   - Returns if the height was set
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::IsWidthHeightSet(BOOL *pbWidthSet, BOOL *pbHeightSet)
{
    HRESULT         hr;
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    if (pbWidthSet)
    {
        hr = a.Style()->get_width(&var);
        if (FAILED(hr))
            goto Cleanup;

        *pbWidthSet = !(var.IsEmpty() || ((V_VT(&var) == VT_BSTR) && (V_BSTR(&var) == NULL)));
    }

    if (pbHeightSet)
    {
        hr = a.Style()->get_height(&var);
        if (FAILED(hr))
            goto Cleanup;

        *pbHeightSet = !(var.IsEmpty() || ((V_VT(&var) == VT_BSTR) && (V_BSTR(&var) == NULL)));
    }

Cleanup:
    return hr;
}
#endif


/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Init()
//
// Synopsis:    Attaches events and sets the default style.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Init()
{
    HRESULT         hr;
    CComBSTR        bstr;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_DEFAULTS | CA_SITEOM | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;
    
    // Register the behavior name
    hr = a.SiteOM()->RegisterName(_T("select"));
    if (FAILED(hr))
        goto Cleanup;

    //
    // Register for events
    //
    hr = AttachEvent(EVENT_ONFOCUS, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONBLUR, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEOVER, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEOUT, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEMOVE, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONKEYPRESS, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSELECTSTART, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSCROLL, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONCONTEXTMENU, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onchange");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnChangeCookie);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onmousedown");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnMouseDownCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onmouseup");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnMouseUpCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onclick");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnClickCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeydown");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyDownCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeyup");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyUpCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onkeypress");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnKeyPressedCookie, BEHAVIOREVENTFLAGS_STANDARDADDITIVE | BEHAVIOREVENTFLAGS_BUBBLE);
    if (FAILED(hr))
        goto Cleanup;

    // Be able to receive keyboard focus
    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Defaults()->put_viewMasterTab(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

    // Force a layout
    hr = a.Style()->put_display(_T("inline-block"));
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupDefaultStyle();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDefaultStyle()
//
// Synopsis:    Sets the default style for the select control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDefaultStyle()
{
    HRESULT         hr;
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrBorder(_T("3 window-inset"));
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrFont(_T("MS Sans Serif"));
    CComBSTR        bstrFontSize(_T("10pt"));
    CComBSTR        bstrWindow(_T("window"));
    CComBSTR        bstrColor(_T("windowtext"));
    CComBSTR        bstrVert(_T("text-bottom"));
    CVariant        var;
    CContextAccess  a(_pSite);

    //
    //  TODO: Can this be made into a table?
    //

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup hidden
    hr = a.DefStyle()->put_visibility(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Setup border
    hr = a.DefStyle()->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

    // Setup mouse
    hr = a.DefStyle()->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Setup overflow
    hr = a.DefStyle()->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Setup font
    hr = a.DefStyle()->put_fontFamily(bstrFont);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the font size
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrFontSize;
    hr = a.DefStyle()->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup background
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrWindow;
    hr = a.DefStyle()->put_backgroundColor(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the foreground color
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)bstrColor;
    hr = a.DefStyle()->put_color(var);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the vertical alignment
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrVert;
    hr = a.DefStyle()->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set a top margin
    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;
    hr = a.DefStyle()->put_marginTop(var);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    V_I4(&var) = 7;
    hr = a.DefStyle()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnContentReady()
//
// Synopsis:    Initializes the flavor of the control and the flavor
//              of the OPTION elements.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnContentReady()
{
    return InitContent();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitContent()
//
// Synopsis:    Initializes the flavor of the control and the flavor
//              of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::InitContent()
{
    HRESULT         hr;
    VARIANT_BOOL    bMult;
    long            lSize;

    hr = SetWritingModeFlag();
    if (FAILED(hr))
        goto Cleanup;

    //
    // Retrieve properties
    //
    hr = get_multiple(&bMult);
    if (FAILED(hr))
        goto Cleanup;
    if (hr == S_FALSE)
    {
        // The attribute was not set correctly, default to VARIANT_FALSE
        bMult = VARIANT_FALSE;
        hr = put_multiple(bMult);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) || (lSize < 1))
    {
        // The size was not set correctly, correct it
        lSize = bMult ? 4 : 1;
        hr = GetProps()[eSize].Set(lSize);
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Setup the flavor (default is single select listbox)
    //
    _fFlavor = _fFlavor & SELECT_INPOPUP;   // If this was set, then keep it
    if (bMult)
    {
        // Multiple select
        _fFlavor |= SELECT_MULTIPLE;
    }
    else if (lSize == 1)
    {
        // Single select dropbox.
        _fFlavor |= SELECT_DROPBOX;
    }

    //
    // Based on the flavor, setup the control
    //
    if (SELECT_ISLISTBOX(_fFlavor))
    {
#ifdef SELECT_GETSIZE
        _fLayoutDirty = TRUE;
#endif
        hr = SetupListBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else if (SELECT_ISDROPBOX(_fFlavor))
    {
        hr = SetupDropBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Initialize the options
    //
    hr = InitOptions();
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    //
    // Make the control visible
    //
    hr = MakeVisible(TRUE);
    if (FAILED(hr))
        goto Cleanup;
#endif

#ifdef SELECT_GETSIZE
    _fContentReady = TRUE;
#endif

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MakeVisible()
//
// Synopsis:    Makes the control visible or hidden.
//
// Arguments:   BOOL bShow  - True to make visible
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::MakeVisible(BOOL bShow /* = TRUE */)
{
    HRESULT         hr;
    CComBSTR        bstrVisible;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    if (bShow)
    {
        bstrVisible = _T("visible");
    }
    else
    {
        bstrVisible = _T("hidden");
    }

    // Display the control
    hr = a.DefStyle()->put_visibility(bstrVisible);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupListBox()
//
// Synopsis:    Sets up the listbox control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupListBox()
{
    HRESULT         hr;
    long            lSize;
    long            lNumOptions;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE | CA_DEFSTYLE2 | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = SetDimensions(lSize);
    if (FAILED(hr))
        goto Cleanup;
#endif

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    _fNeedScrollBar = (lNumOptions > lSize);

    if (_fWritingModeTBRL)
    {
        hr = SetPixelHeightWidth();
        if (FAILED(hr))
            goto Cleanup;
    }

    //
    // Setup the scroll segment
    //
     hr = a.Defaults()->put_scrollSegmentY(lNumOptions);
        if (FAILED(hr))
            goto Cleanup;


#ifdef SELECT_GETSIZE

    if (!_fContentReady)
    {
        // The border is different on the listbox (we need this in case we were dynamically
        // changed from a dropbox to a listbox).
        hr = a.DefStyle()->put_border(CComBSTR(_T("3 window-inset")));
        if (FAILED(hr))
            goto Cleanup;

        hr = a.DefStyle2()->put_overflowY(CComBSTR(_T("auto")));
        if (FAILED(hr))
            goto Cleanup;

        //
        // Make the control visible
        //
        hr = MakeVisible(TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropBox()
//
// Synopsis:    Sets up the dropbox control.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT 
CIESelectElement::SetupDropBox()
{
    HRESULT hr;

    hr = SetupDropControl();
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupPopup();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropControl()
//
// Synopsis:    Sets up the dropbox control portion.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT 
CIESelectElement::SetupDropControl()
{
    HRESULT                     hr              = S_OK;
    CComBSTR                    bstrHidden(_T("hidden"));
    CComBSTR                    bstrBorder(_T("2 inset"));
    CComBSTR                    bstrWritingMode(_T(""));
    CContextAccess              a(_pSite);
    long                        lTemp;

#ifndef SELECT_GETSIZE
    IHTMLDocument2              *pDocThis       = NULL;
    IDispatch                   *pDispDocLink  = NULL;
    IHTMLDocument2              *pDocLink      = NULL;
    IHTMLDocument3              *pDocLink3     = NULL;
    IHTMLElement                *pElemLink      = NULL;
    IHTMLDOMNode                *pNodeLink      = NULL;
    IHTMLElement                *pElemDisplay      = NULL;
    IHTMLDOMNode                *pNodeDisplay      = NULL;
    IHTMLElement                *pElemButton    = NULL;
    IHTMLDOMNode                *pNodeButton    = NULL;
    CComBSTR                    bstr;
    CVariant                    var;
    IDispatch                   *pDispatch      = NULL;
    IHTMLElement                *pElem          = NULL;
    IHTMLElement2               *pElem2         = NULL;
    IHTMLStyle                  *pStyle         = NULL;
    IHTMLStyle2                 *pStyle2        = NULL;
    long                        lHeight;
    long                        lWidth;
    long                        lButtonWidth;
    long                        lNumOptions;
    long                        lDiff;
#endif

#ifdef SELECT_GETSIZE
    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;
#else
    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_ELEM3 | CA_PELEM | CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;
#endif

    // Set overflow hidden for the drop control
    hr = a.DefStyle()->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // The border is different on the drop control
    hr = a.DefStyle()->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Set the dimensions of the control
    if (lNumOptions > 0)
    {
        // TODO: Change this to the real maximum number of options
        if (lNumOptions > SELECT_MAXOPTIONS)
        {
            lNumOptions = SELECT_MAXOPTIONS;
        }
        hr = SetDimensions(lNumOptions);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = SetDimensions(1);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = a.Elem2()->get_clientHeight(&_lPopupSize.cy);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.DefStyle()->get_pixelWidth(&lWidth);
    if (FAILED(hr))
        goto Cleanup;
    _lPopupSize.cx = lWidth;

    if (lNumOptions > 0)
    {
        hr = GetIndex(0, &pElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pElem->get_offsetHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;

        lDiff = _lPopupSize.cy - lHeight;

        hr = a.DefStyle()->get_pixelHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;

        lHeight -= lDiff;

        ClearInterface(&pElem);
    }
    else
    {
        hr = a.DefStyle()->get_pixelHeight(&lHeight);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lTemp;
    }

    hr = a.DefStyle()->put_pixelHeight(lHeight + 2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.DefStyle()->put_pixelWidth(lWidth + 2);
    if (FAILED(hr))
        goto Cleanup;


    // Get the client area's width
    hr = a.Elem2()->get_clientWidth(&lWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Get the client area's height
    hr = a.Elem2()->get_clientHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    // Get the document
    hr = a.Elem()->get_document((IDispatch**)&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create a superflous slave element for now
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemLink);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemLink->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the display element
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    _pElemDisplay = pElemDisplay;
    _pElemDisplay->AddRef();

    //
    // Insert the display
    //
    hr = pElemDisplay->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeDisplay, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the button
    //
    bstr = _T("SPAN");
    hr = pDocThis->createElement(bstr, &pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Insert the button
    //
    hr = pElemButton->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeButton, NULL);
    if (FAILED(hr))
        goto Cleanup;

    // Remove the superflous Link element now
    hr = pNodeLink->removeNode(VB_FALSE, NULL);
    if (FAILED(hr))
        goto Cleanup;

    // Get hold of the Link document

    if ( _pDispDocLink )
    {
        pDispDocLink = _pDispDocLink;
        _pDispDocLink->AddRef();
    }
    else
    {
        hr = pElemDisplay->get_document(&pDispDocLink);
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**)&pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the viewLink
    //
    hr = a.PElem()->putref_viewLink(pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the display's style
    //
    hr = pElemDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle2);
    if (FAILED(hr))
        goto Cleanup;

    // Set the mouse cursor be an arrow for the display
    bstr = _T("default");
    hr = pStyle->put_cursor(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the display
    bstr = _T("hidden");
    hr = pStyle->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lWidth;
    }

    // Set the width of the display
    hr = pStyle->put_pixelWidth(lWidth - lButtonWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the display
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the vertical alignment of the display to be top
    bstr = _T("top");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font for the display
    bstr = _T("MS Sans Serif");
    hr = pStyle->put_fontFamily(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size for the display
    bstr = _T("10pt");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the left padding on the display
    bstr = _T("3px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the top padding on the display
    bstr = _T("1px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingTop(var);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&pStyle);
    ClearInterface(&pStyle2);

    //
    // Set the button's style
    //
    hr = pElemButton->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&pStyle2);
    if (FAILED(hr))
        goto Cleanup;

    _pStyleButton = pStyle;
    _pStyleButton->AddRef();

    // Set the mouse cursor be an arrow for the button
    bstr = _T("default");
    hr = pStyle->put_cursor(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the button
    bstr = _T("hidden");
    hr = pStyle->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        hr = pStyle->put_pixelHeight(lButtonWidth);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Set the width of the button
        hr = pStyle->put_pixelWidth(lButtonWidth);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Set the height of the button
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    if (_fWritingModeTBRL)
    {
        hr = pStyle->put_width(var);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = pStyle->put_height(var);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Set the background color for the button
    bstr = _T("buttonface");
    hr = pStyle->put_background(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the border for the button
    bstr = _T("2 outset");
    hr = pStyle->put_border(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font family of the button
    bstr = _T("Marlett");
    hr = pStyle->put_fontFamily(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size of the button
    V_VT(&var) = VT_I4;
    V_I4(&var) = lButtonWidth - 4;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the text to be the down arrow
    bstr = _T("u");
    hr = pElemButton->put_innerText(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // Set the alignment on the arrow to be centered
    bstr = _T("center");
    hr = pStyle->put_textAlign(bstr);
    if (FAILED(hr))
        goto Cleanup;

    // The layout-grid-line is supposed to vertically
    // center the arrow, but it doesn't. The padding
    // is there to push the arrow up one pixel for IE5 compat.
    // Set the layout-grid-line of the button to be 100%
    bstr = _T("100%");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle2->put_layoutGridLine(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the bottom padding of the button
    bstr = _T("2px");
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr;
    hr = pStyle->put_paddingBottom(var);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&pStyle);
    ClearInterface(&pStyle2);

    //
    // Attach an event sink to listen for events within the view link
    //
    hr = pDocLink->QueryInterface(IID_IHTMLDocument3, (void**)&pDocLink3);
    if (FAILED(hr))
        goto Cleanup;

    if ( !_pSinkVL )
    {
        _pSinkVL = new CEventSink(this, SELECTES_VIEWLINK);
        if (!_pSinkVL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onclick");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onselectstart");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("oncontextmenu");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
    }
    if ( !_pSinkButton )
    {
        _pSinkButton = new CEventSink(this, SELECTES_BUTTON);
        if (!_pSinkButton)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pElemDisplay->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElem2);

        hr = pElemButton->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseout");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
   }
#endif
Cleanup:
#ifndef SELECT_GETSIZE
    ReleaseInterface(pDocThis);

    ReleaseInterface(pDispDocLink);
    ReleaseInterface(pDocLink);
    ReleaseInterface(pDocLink3);

    ReleaseInterface(pElemLink);
    ReleaseInterface(pNodeLink);

    ReleaseInterface(pElemDisplay);
    ReleaseInterface(pNodeDisplay);
    
    ReleaseInterface(pElemButton);
    ReleaseInterface(pNodeButton);

    ReleaseInterface(pDispatch);
    ReleaseInterface(pElem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pStyle);
    ReleaseInterface(pStyle2);
#endif

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AttachEventToSink()
//
// Synopsis:    Attaches an element's event to a given sink.
//
// Arguments:   IHTMLElement2 *pElem    - The element to listen to
//              CComBSTR& bstr          - The name of the event
//              CEventSink* pSink       - The event sink
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::AttachEventToSink(IHTMLElement2 *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT         hr;
    VARIANT_BOOL    vSuccess;

    hr = pElem->attachEvent(bstr, (IDispatch*)pSink, &vSuccess);
    if (FAILED(hr))
        goto Cleanup;

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AttachEventToSink()
//
// Synopsis:    Attaches a document's event to a given sink.
//
// Arguments:   IHTMLDocument3 *pDoc    - The document to listen to
//              CComBSTR& bstr          - The name of the event
//              CEventSink* pSink       - The event sink
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT         hr;
    VARIANT_BOOL    vSuccess;

    hr = pDoc->attachEvent(bstr, (IDispatch*)pSink, &vSuccess);
    if (FAILED(hr))
        goto Cleanup;

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupPopup()
//
// Synopsis:    Sets up the popup window for dropbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupPopup()
{
    HRESULT                 hr;

    IDispatch               *pDocMainD      = NULL;
    IHTMLDocument2          *pDocMain       = NULL;
    IHTMLWindow2            *pWinMain       = NULL;
    IHTMLWindow4            *pWinMain4      = NULL;
    IHTMLDocument           *pDocThis       = NULL;
    IHTMLDocument2          *pDoc2          = NULL;
    IDispatch               *pPopupDisp     = NULL;
    IHTMLElement            *pElemHTML      = NULL;
    IHTMLElement            *pElemBODY      = NULL;
    IHTMLElement            *pElemSELECT    = NULL;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IHTMLElement2           *pElem2         = NULL;
    IHTMLStyle              *pStyleBody     = NULL;


#ifndef SELECT_GETSIZE
    IHTMLStyle              *pStyle         = NULL;
    IHTMLElement            *pElem          = NULL;
#endif

    long                    lSize;
    CVariant                var, var2;
    CComBSTR                bstr, bstrHTML, bstrTemp;
    CComBSTR                bstrImport = _T("<?IMPORT namespace=IE implementation='#default'>");
    TCHAR                   strNum[5];
    CContextAccess          a(_pSite);


    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_document(&pDocMainD);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocMainD->QueryInterface(IID_IHTMLDocument2, (void **)&pDocMain);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocMain->get_parentWindow(&pWinMain);
    if (FAILED(hr))
        goto Cleanup;

    hr = pWinMain->QueryInterface(IID_IHTMLWindow4, (void **)&pWinMain4);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_EMPTY;
    hr = pWinMain4->createPopup(&var, &pPopupDisp);
    if (FAILED(hr))
        goto Cleanup;

    hr = pPopupDisp->QueryInterface(IID_IHTMLPopup, (void **)&_pPopup);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    hr = _pPopup->get_document(&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    pDocThis->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc2->get_body(&pElemBODY);
    if (FAILED(hr))
        goto Cleanup;

    hr = UpdatePopup();
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemBODY->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->item(var, var2, &pDispatchItem);
    if (FAILED(hr))
        goto Cleanup;

    if (!pDispatchItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Attach an event sink to listen for events within the popup
    //
    hr = pDispatchItem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    if ( !_pSinkPopup )
    {
        _pSinkPopup = new CEventSink(this, SELECTES_POPUP);
        if (!_pSinkPopup)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onchange");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeydown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeyup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onkeypress");
        hr = AttachEventToSink(pElem2, bstr, _pSinkPopup);
        if (FAILED(hr))
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pDocMainD);
    ReleaseInterface(pDocMain);
    ReleaseInterface(pWinMain);
    ReleaseInterface(pWinMain4);
    ReleaseInterface(pPopupDisp);
    ReleaseInterface(pElemHTML);
    ReleaseInterface(pElemBODY);
    ReleaseInterface(pElemSELECT);
    ReleaseInterface(pDocThis);
    ReleaseInterface(pDoc2);
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pStyleBody);
#ifndef SELECT_GETSIZE
    ReleaseInterface(pStyle);
    ReleaseInterface(pElem);
#endif

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::UpdatePopup()
//
// Synopsis:    Update the popup window for dropbox.
//              The viewlink has just the dropdown button and selected text. The _pPopup has 
//              the list of options stored in its associated document. Each time an option is
//              is added to the dropdown, it is actually added to the document associated with
//              the _pPopup. The popup of the dropdown, itself doesn't get updated. This leads
//              to wrong display of the list of options. To fix this, this function is added.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::UpdatePopup()
{
    HRESULT                 hr;
    IHTMLDocument           *pDocThis       = NULL;
    IHTMLDocument2          *pDoc2          = NULL;
    IHTMLElement            *pElemBODY      = NULL;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IHTMLStyle              *pStyleBody     = NULL;


#ifndef SELECT_GETSIZE
    IHTMLStyle              *pStyle         = NULL;
    IHTMLElement            *pElem          = NULL;
#endif

    long                    lSize;
    CVariant                var, var2;
    CComBSTR                bstr, bstrHTML, bstrTemp;
    CComBSTR                bstrImport = _T("<?IMPORT namespace=IE implementation='#default'>");
    TCHAR                   strNum[5];
    CContextAccess          a(_pSite);
    CComBSTR                bstrWritingMode(_T(""));

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //

    hr = _pPopup->get_document(&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the popup's document
    //
    pDocThis->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc2->get_body(&pElemBODY);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the style on the popup
    //
    hr = pElemBODY->get_style(&pStyleBody);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_border(CComBSTR(_T("1 solid")));
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }
        hr = _pSelectInPopup->SetWritingMode(bstrWritingMode);
        goto Cleanup;
    }

#ifdef  NEVER

    hr = pStyleBody->put_margin(CComBSTR(_T("0")));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_padding(CComBSTR(_T("0")));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyleBody->put_overflow(CComBSTR(_T("hidden")));
    if (FAILED(hr))
        goto Cleanup;

#endif

    //
    // Create a SELECT element
    //

    hr = GetNumOptions(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if (lSize <= 1)
    {
        lSize = 2;
    }

    _ltot(min(lSize, SELECT_MAXOPTIONS), strNum, 10);

    hr = a.Elem()->get_innerHTML(&bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    bstr = bstrImport;

    bstrTemp = _T("<IE:select size=");
    bstr += bstrTemp;

    bstrTemp = strNum;
    bstr += bstrTemp;

    bstrTemp = _T(" style='border:none;margin:0px'>");
    bstr += bstrTemp;

    bstr += bstrHTML;

    bstrTemp = _T("</IE:select>");
    bstr += bstrTemp;

    hr = pElemBODY->put_innerHTML(bstr);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemBODY->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->item(var, var2, &pDispatchItem);
    if (FAILED(hr))
        goto Cleanup;

    if (!pDispatchItem)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pDispatchItem->QueryInterface(IID_IPrivateSelect, (void**)&_pSelectInPopup);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pSelectInPopup->SetInPopup(_pPopup);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pSelectInPopup->InitOptions();
    if (FAILED(hr))
        goto Cleanup;

#ifndef SELECT_GETSIZE
    hr = pDispatchItem->QueryInterface(IID_IHTMLElement, (void**)&pElem);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the width/height of the popup's select
    //
    hr = pElem->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    if (_fWritingModeTBRL)
    {
        V_I4(&var) = _lPopupSize.cy;
    }
    else
    {
        V_I4(&var) = _lPopupSize.cx;
    }
    hr = pStyle->put_width(var);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        V_I4(&var) = _lPopupSize.cx;
    }
    else
    {
        V_I4(&var) = _lPopupSize.cy;
    }
    hr = pStyle->put_height(var);
    if (FAILED(hr))
        goto Cleanup;

    _lPopupSize.cx += 2;
    _lPopupSize.cy += 2;
#endif

Cleanup:
    ReleaseInterface(pElemBODY);
    ReleaseInterface(pDocThis);
    ReleaseInterface(pDoc2);
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pStyleBody);
#ifndef SELECT_GETSIZE
    ReleaseInterface(pStyle);
    ReleaseInterface(pElem);
#endif

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnFocus()
//
// Synopsis:    Update focus information.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnFocus(CEventObjectAccess *pEvent)
{
    if (SELECT_ISDROPBOX(_fFlavor))
    {
        return SetDisplayHighlight(TRUE);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnBlur()
//
// Synopsis:    When SELECT loses focus, the focused OPTION should
//              lose focus as well.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (SELECT_ISDROPBOX(_fFlavor))
    {
        
        hr = HidePopup();
        if (FAILED(hr))
            goto Cleanup;

        hr = SetDisplayHighlight(FALSE);
        if (FAILED(hr))
            goto Cleanup;
            
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDisplayHighlight()
//
// Synopsis:    Sets the highlighted state of the dropbox display.
//
// Arguments:   BOOL bOn -  Indicates whether the display should be
//                          highlighted.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetDisplayHighlight(BOOL bOn)
{
    HRESULT         hr;
    CComBSTR        bstrBack;
    CComBSTR        bstrText;
    CVariant        var;
    long            lNumOptions;
    VARIANT_BOOL    bOpen;
    IHTMLStyle      *pStyle     = NULL;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    if ((lNumOptions > 0) && _pPopup && _pElemDisplay)
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOn && !bOpen)
        {
            bstrBack = _T("highlight");
            bstrText = _T("highlighttext");
        }
        else
        {
            bstrBack = _T("");
            bstrText = _T("");
        }

        hr = _pElemDisplay->get_style(&pStyle);
        if (FAILED(hr))
            goto Cleanup;

        hr = pStyle->put_background(bstrBack);
        if (FAILED(hr))
            goto Cleanup;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = (BSTR)bstrText;
        hr = pStyle->put_color(var);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseDown()
//
// Synopsis:    Start a drag in listboxes.
//              Toggles the popup open/closed in a dropbox.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    VARIANT_BOOL        bDisabled;
    long                lMouseButtons = NULL;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            hr = TogglePopup();
            if (FAILED(hr))
                goto Cleanup;

            hr = SetDisplayHighlight(TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }
        else if (!SELECT_ISINPOPUP(_fFlavor))
        {
            // Just in case a previous drag was not completed
            hr = FinishDrag();
            if (FAILED(hr))
                goto Cleanup;

            // Start the new drag
            hr = StartDrag();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseOver()
//
// Synopsis:    Used to hang onto the current popup state.  Mouse events out of
//              our control can shut the popup without our knowledge. This gives
//              us that knowledge.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (_pPopup)
    {
        hr = _pPopup->get_isOpen(&_bPopupOpen);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseOut()
//
// Synopsis:    Used to hang onto the current popup state. Mouse events out of
//              our control can shut the popup without our knowledge.  This gives
//              us that knowledge.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseOut(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if (_pPopup)
    {
        hr = _pPopup->get_isOpen(&_bPopupOpen);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseUp()
//
// Synopsis:    Finish a drag and commit all changes.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    VARIANT_BOOL        bDisabled;
    long                lKeyboardStatus = NULL;
    POINT               ptElem;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    if (_fDragMode)
    {
        // Stop the drag
        hr = FinishDrag();
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetParentCoordinates(&ptElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Make final selection changes
        hr = HandleDownXY(ptElem, lKeyboardStatus & EVENT_CTRLKEY);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Commit all selection changes
    hr = FireOnChange();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnMouseMove()
//
// Synopsis:    Handle drag select.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnMouseMove(CEventObjectAccess *pEvent)
{
    HRESULT             hr = S_OK;
    long                lMouseButtons   = NULL;
    long                lKeyboardStatus = NULL;
    POINT               ptElem;

    if (!_fDragMode)
        goto Cleanup;

    hr = ClearScrollTimeout();
    if (FAILED(hr))
        goto Cleanup;

    hr = pEvent->GetMouseButtons(&lMouseButtons);
    if (FAILED(hr))
        goto Cleanup;

    if (lMouseButtons & EVENT_LEFTBUTTON)
    {
        hr = pEvent->GetParentCoordinates(&ptElem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
        if (FAILED(hr))
            goto Cleanup;

        // Make selection changes
        hr = HandleDownXY(ptElem, lKeyboardStatus & EVENT_CTRLKEY);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // A different mouse button is down, finish this drag
        hr = FinishDrag();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::StartDrag()
//
// Synopsis:    Capture the mouse, get focus, engage drag mode.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::StartDrag()
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    if (_fDragMode)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->setCapture();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->focus();
    if (FAILED(hr))
        goto Cleanup;

    _fDragMode = TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::FinishDrag()
//
// Synopsis:    Release the mouse, kill scroll timer, disengage drag mode.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::FinishDrag()
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    if (!_fDragMode)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = ClearScrollTimeout();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->releaseCapture();
    if (FAILED(hr))
        goto Cleanup;

    _fDragMode = FALSE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::HandleDownXY()
//
// Synopsis:    Performs special "clicks" during a drag.
//
// Arguments:   POINT pt        - Location of the mouse
//              BOOL bCtrlKey   - TRUE if the CTRL key is down
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::HandleDownXY(POINT pt, BOOL bCtrlKey)
{
    HRESULT             hr;
    long                lIndex;
    BOOL                bNeedTimer;
    long                lXY;

    Assert(!SELECT_ISINPOPUP(_fFlavor));

    if (_fWritingModeTBRL)
    {
        lXY = pt.x;
    }
    else
    {
        lXY = pt.y;
    }

    hr = GetOptionIndexFromY(lXY, &lIndex, &bNeedTimer);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) || (_lFocusIndex == lIndex))
    {
        // No need to do any selecting, so stop
        hr = S_OK;
        goto Cleanup;
    }

    // Select the option
    hr = OnOptionSelected(VARIANT_TRUE, lIndex, SELECT_EXTEND);
    if (FAILED(hr))
        goto Cleanup;

    // Check for drag mode since this could be the last call
    if (bNeedTimer && _fDragMode)
    {
        // The mouse is either above or below the control,
        // so set a timer to get the control to scroll.
        SetScrollTimeout(pt, bCtrlKey);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetOptionIndexFromY()
//
// Synopsis:    Determines the index of the option based on lY.
//
// Arguments:   long lY             - The Y coordinate
//              long *plIndex       - Returns the index
//              BOOL *pbNeedTimer   - Returns whether Y is 
//                                    above/below the control
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetOptionIndexFromY(long lY, long *plIndex, BOOL *pbNeedTimer)
{
    HRESULT             hr;
    long                lTopIndex;
    long                lBottomIndex;
    long                lNumOptions;
    long                lIndex;
    long                lTop;
    long                lScrollTop;
    long                lClientTop;
    long                lLeft;
    long                lScrollLeft;
    long                lClientLeft;


    IHTMLElement        *pElemParent    = NULL;
    IHTMLElement        *pElem          = NULL;
    IHTMLElement2       *pElem2         = NULL;
    CContextAccess      a(_pSite);

    Assert(plIndex && pbNeedTimer);

    *pbNeedTimer = FALSE;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Convert the mouse points relative to the upper left
    // corner of the select's client rectangle.
    //
    pElem = a.Elem();
    pElem->AddRef();

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    // Go through all the parents to calculate the correct offset
    while (true)
    {
        if (_fWritingModeTBRL) 
        {
            hr = pElem->get_offsetLeft(&lLeft);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElem2->get_clientLeft(&lClientLeft);
            if (FAILED(hr))
                goto Cleanup;

            lY -= lLeft + lClientLeft;
        }
        else
        {
            hr = pElem->get_offsetTop(&lTop);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElem2->get_clientTop(&lClientTop);
            if (FAILED(hr))
                goto Cleanup;

            lY -= lTop + lClientTop;
        }

        hr = pElem->get_offsetParent(&pElemParent);
        if (FAILED(hr))
            goto Cleanup;

        if (pElemParent == NULL)
        {
            break;
        }

        ClearInterface(&pElem);
        ClearInterface(&pElem2);

        pElem = pElemParent;
        pElemParent = NULL;

        hr = pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        if (_fWritingModeTBRL)
        {
            hr = pElem2->get_scrollLeft(&lScrollLeft);
            if (FAILED(hr))
                goto Cleanup;
        
            lY += lScrollLeft;
        }
        else
        {

            hr = pElem2->get_scrollTop(&lScrollTop);
            if (FAILED(hr))
                goto Cleanup;

            lY += lScrollTop;
        }
    }

    //
    // Calculate the clicked index
    //
    hr = GetTopVisibleOptionIndex(&lTopIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lY < 0)
    {
        //
        // If lY is negative, we need to subtract an extra height
        // so that the match will come out right when the division
        // truncates the remainder.
        //
        // We also want to restrict the index to only one option
        // beyond the visible range of the control.
        //
        lY = -_lMaxHeight;
        *pbNeedTimer = TRUE;
    }

    lIndex = (lY / _lMaxHeight) + lTopIndex;

    hr = GetBottomVisibleOptionIndex(&lBottomIndex);
    if (FAILED(hr))
        goto Cleanup;

    // If the writingmode is "tb-rl", the count which is made from left has to be transformed to the
    // count from right.
    if (_fWritingModeTBRL)
    {
        lIndex = lBottomIndex - lIndex -1;
    }
    if (lIndex >= lBottomIndex)
    {
        //
        // We want to restrict the index to only one option
        // beyond the visible range of the control.
        //
        lIndex = lBottomIndex;
        *pbNeedTimer = TRUE;
    }

    //
    // Make sure the index is valid
    //
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    if ((lIndex >= 0) && (lIndex < lNumOptions))
    {
        // Success!
        *plIndex = lIndex;
        hr = S_OK;
    }
    else
    {
        // Invalid index
        hr = S_FALSE;
    }

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pElem2);
    ReleaseInterface(pElemParent);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnKeyDown()
//
// Synopsis:    Changes the selection based on the key pressed.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT             hr;
    DWORD               dwFlags = 0;
    long                lNumOptions;
    long                lSize;
    long                lKeyboardStatus = 0;
    long                lKeyCode;
    VARIANT_BOOL        bDisabled;
    VARIANT_BOOL        bSelected;
    VARIANT_BOOL        bIsOpen;
    BOOL                bCancelEvent = FALSE;
    IPrivateOption      *pOption = NULL;

    hr = GetDisabled(&bDisabled);
    if (FAILED(hr) || bDisabled)
        goto Cleanup;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr) || (lNumOptions == 0))   // No need to do anything if no options
        goto Cleanup;

    hr = pEvent->GetKeyboardStatus(&lKeyboardStatus);
    if (FAILED(hr))
        goto Cleanup;

    dwFlags |= (lKeyboardStatus & EVENT_ALTKEY)    ? SELECT_ALT    : 0;
    dwFlags |= (lKeyboardStatus & EVENT_SHIFTKEY)  ? SELECT_SHIFT  : 0;
    dwFlags |= (lKeyboardStatus & EVENT_CTRLKEY)   ? SELECT_CTRL   : 0;

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (FAILED(hr))
        goto Cleanup;

    switch (lKeyCode)
    {
    case VK_UP:
    case VK_DOWN:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            Assert(_pPopup && _pSelectInPopup);

            hr = _pPopup->get_isOpen(&bIsOpen);
            if (FAILED(hr))
                goto Cleanup;

            if (lKeyboardStatus & EVENT_ALTKEY)
            {
                if (bIsOpen)
                {
                    hr = _pSelectInPopup->SelectCurrentOption(dwFlags);
                    if (FAILED(hr))
                        goto Cleanup;
                }
                else
                {
                    hr = ShowPopup();
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }
            else
            {
                BOOL bChanged;

                hr = _pSelectInPopup->MoveFocusByOne(lKeyCode == VK_UP, dwFlags | (!bIsOpen ? SELECT_FIREEVENT : 0));
                if (FAILED(hr))
                    goto Cleanup;

                hr = _pSelectInPopup->CommitSelection(&bChanged);
                if (FAILED(hr))
                    goto Cleanup;

                if (bChanged)
                {
                    hr = SynchSelWithPopup();
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }
        }
        else if ( SELECT_ISINPOPUP(_fFlavor))
        {

            VARIANT_BOOL bOpen;
            long         lSize;
            long         lPrevIndex;
            long         lTopOptionIndex;
            long         lBottomOptionIndex;

            Assert(_pPopup);

            Assert(_pLastHighlight);



            hr = _pLastHighlight->GetIndex(&lPrevIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = get_size(&lSize);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetTopVisibleOptionIndex(&lTopOptionIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = GetBottomVisibleOptionIndex(&lBottomOptionIndex);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            if ( lKeyCode == VK_DOWN)
            {
                _lFocusIndex = (lNumOptions == (lPrevIndex +1)) ? lPrevIndex : lPrevIndex +1 ;
            }
            else 
            {
                _lFocusIndex = ( lPrevIndex == 0 ) ? lPrevIndex : lPrevIndex -1 ;
            }

            hr = GetIndex(_lFocusIndex , &pOption);
            if (FAILED(hr) || !pOption)
                goto Cleanup;

            hr = pOption->SetIndex(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            // Highlight the item
            hr = pOption->SetHighlight(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            if (_pLastHighlight)
            {
                ClearInterface(&_pLastHighlight);
            }

            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();

            hr = OnOptionFocus(_lFocusIndex, VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight -> SetSelected(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            hr = _pLastHighlight -> SetIndex(_lFocusIndex);
            if (FAILED(hr))
                goto Cleanup;


            if ( ((lKeyCode == VK_UP) && ((lBottomOptionIndex  - lPrevIndex) == lSize)) ||
                 ((lKeyCode == VK_DOWN) && ((lPrevIndex - lTopOptionIndex) == lSize - 1  )) )
            {                   
                hr = MakeOptionVisible(pOption);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else if (!(lKeyboardStatus & EVENT_ALTKEY))
        {
            hr = MoveFocusByOne(lKeyCode == VK_UP, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }
        
        bCancelEvent = TRUE;
        break;

    case VK_SPACE:
        if (SELECT_ISMULTIPLE(_fFlavor))
        {
            // Select the current OPTION
            hr = OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }

        bCancelEvent = TRUE;
        break;

    case VK_RETURN:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            // Select the current OPTION
            Assert(_pSelectInPopup);

            hr = _pSelectInPopup->SelectCurrentOption(dwFlags);
            if (FAILED(hr))
                goto Cleanup;
        }
        else if ( SELECT_ISINPOPUP(_fFlavor))
        {
            hr = OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;

        }
        bCancelEvent = TRUE;
        break;

    case VK_HOME:
        hr = OnOptionClicked(0, dwFlags | SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_END:
        hr = OnOptionClicked(lNumOptions - 1, dwFlags | SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_PRIOR:
        hr = PushFocusToExtreme(FALSE);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectVisibleIndex(0);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_NEXT:
        hr = PushFocusToExtreme(TRUE);
        if (FAILED(hr))
            goto Cleanup;

        hr = get_size(&lSize);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectVisibleIndex(lSize - 1);
        if (FAILED(hr))
            goto Cleanup;

        bCancelEvent = TRUE;
        break;

    case VK_ESCAPE:
        if (SELECT_ISDROPBOX(_fFlavor))
        {
            hr = SetDisplayHighlight(TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }
        bCancelEvent = TRUE;
        break;

    default:
        //
        // If the keypressed can be displayed on screen,
        // then look for it in the options.
        //
        if (_istgraph((TCHAR)lKeyCode))
        {
            hr = SelectByKey(lKeyCode);
            if (FAILED(hr))
                goto Cleanup;
        }

        // Forces WM_CHAR to be generated when handling OnKeyDown
        hr = S_FALSE;
        break;
    }

    if (bCancelEvent)
    {
        hr = CancelEvent(pEvent);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    if ( pOption )
        ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MoveFocusByOne()
//
// Synopsis:    Moves the focus up/down by one.
//
// Arguments:   BOOL bUp        - TRUE if moving up
//              DWORD dwFlags   - Keyboard status flags
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::MoveFocusByOne(BOOL bUp, DWORD dwFlags)
{
    HRESULT         hr;
    long            lNumOptions;
    long            lDir        = bUp   ? -1    : 1;
    IPrivateOption  *pOption    = NULL;

    // No options, nothing to do
    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Trying to move beyond an extreme, stop
    if ((bUp && (_lFocusIndex <= 0)) || 
        (!bUp && (_lFocusIndex >= (lNumOptions - 1))))
        goto Cleanup;

    if (SELECT_ISMULTIPLE(_fFlavor) && (dwFlags & SELECT_CTRL))
    {
        // Move the focus
        hr = OnOptionFocus(_lFocusIndex + lDir);
        if (FAILED(hr))
            goto Cleanup;

        hr = GetIndex(_lFocusIndex, &pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = MakeOptionVisible(pOption);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Select the option
        hr = OnOptionClicked(_lFocusIndex + lDir, dwFlags);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectCurrentOption()
//
// Synopsis:    Selects the option that currently has focus.
//
// Arguments:   DWORD dwFlags   - Keyboard status flags
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SelectCurrentOption(DWORD dwFlags)
{
    return OnOptionClicked(_lFocusIndex, dwFlags | SELECT_FIREEVENT);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectByKey()
//
// Synopsis:    Selects the next option that begins with the given key.
//              Loops around, if the end is reached.
//
// Arguments:   long lKey   - The character to look for
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectByKey(long lKey)
{
    HRESULT         hr;
    long            lNumOptions;
    long            lStart;
    long            lIndex;
    IPrivateOption  *pOption = NULL;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    lStart = _lFocusIndex + 1;
    if (lStart >= lNumOptions)
    {
        lStart = 0;
    }

    // Search from the start index to the last option
    hr = SearchForKey(lKey, lStart, lNumOptions - 1, &lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if ((hr == S_FALSE) && (lStart > 0))
    {
        //
        // If the previous search did not find anything,
        // then search from index 0 to just before the
        // previous start index.
        //
        hr = SearchForKey(lKey, 0, lStart - 1, &lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (hr == S_OK)
    {
        // Select the found option
        hr = OnOptionClicked(lIndex, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectByKey()
//
// Synopsis:    Selects the next option that begins with the given key.
//              Loops around, if the end is reached.
//
// Arguments:   long lKey       - The character to look for
//              long lStart     - The first index to check
//              long lEnd       - The last index to check
//              long *plIndex   - The index of the found option (or -1)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SearchForKey(long lKey, long lStart, long lEnd, long *plIndex)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pItem          = NULL;
    IHTMLElement            *pOption        = NULL;
    long                    iItem;
    CComBSTR                bstr;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(plIndex);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = lStart; iItem <= lEnd; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pItem->QueryInterface(IID_IHTMLElement, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pItem);
            continue;
        }

        hr = pOption->get_innerText(&bstr);
        if (FAILED(hr))
            goto Cleanup;

        if (    bstr.m_str
            &&  bstr.m_str[0]
            &&  _totupper((TCHAR)bstr[0]) == _totupper((TCHAR)lKey))
        {
            // An option is found
            *plIndex = iItem;
            hr = S_OK;
            goto Cleanup;
        }

        ClearInterface(&pOption);
        ClearInterface(&pItem);
    }

    // No option found
    hr = S_FALSE;

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnPropertyChange()
//
// Synopsis:    Allows setting of a global variable about the writingmode.
//
// Arguments:   CEventObjectAccess *pEvent - Event info
//              BSTR bstr
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstr)
{
    HRESULT             hr = S_OK;


    if (!StrCmpICW(bstr, L"style.writingMode"))
    {
        hr = SetWritingModeFlag();
        if (FAILED(hr))
            goto Cleanup;

        hr = RefreshView();
        if (FAILED(hr))
           goto Cleanup;
    }

Cleanup:
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetWritingModeFlag()
//
// Synopsis:    The _fWritingModeTBRL flag is set properly based on
//              the writingmode.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: SetWritingModeFlag()
{
    CContextAccess  a(_pSite);
    HRESULT         hr = S_OK;
    CComBSTR        bstrWritingMode(_T(""));

    hr = a.Open(CA_STYLE3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style3()->get_writingMode(&bstrWritingMode);
    if (FAILED(hr))
        goto Cleanup;

    if(!bstrWritingMode || StrCmpICW(bstrWritingMode, L"tb-rl")) 
    {
        _fWritingModeTBRL = FALSE;
    }
    else
    {
        _fWritingModeTBRL = TRUE;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetPixelHeightWidth()
//
// Synopsis:    The pixelheight and pixelwidth are set accordingly 
//              based on the writingmode.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: SetPixelHeightWidth()
{
    CContextAccess  a(_pSite);
    HRESULT         hr = S_OK;
    long            lWidth;
    long            lHeight;
    long            lButtonWidth;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fWritingModeTBRL)
    {
        lWidth = _sizeOptionReported.cy + 2;
        lHeight = lButtonWidth;
    }
    else
    {
        lWidth = lButtonWidth;
        lHeight = _sizeOptionReported.cy + 2;
    }

    // Set the height
    hr = a.DefStyle()->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width
    hr = a.DefStyle()->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshView()
//
// Synopsis:    The view has to be changed after the writing mode is changed.
//
// Arguments:   None.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement:: RefreshView()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    CComBSTR        bstrWritingMode(_T(""));
    CVariant        var;
    long            lWidth;
    long            lHeight;
    long            lButtonWidth;

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;


    if(SELECT_ISLISTBOX(_fFlavor))
    {
        if (_fWritingModeTBRL)
        {
            hr = SetPixelHeightWidth();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

    if (SELECT_ISDROPBOX(_fFlavor))
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }

        hr = SetWritingMode(bstrWritingMode);
        if (FAILED(hr))
            goto Cleanup;

        hr = UpdatePopup();
        if (FAILED(hr))
            goto Cleanup;

        if (_pElemDisplay)
        {
            hr = SetupDisplay(_pElemDisplay);
            if (FAILED(hr))
                goto Cleanup;

            _pElemDisplay->Release();

            hr = SetupDropControlDimensions();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnSelectStart()
//
// Synopsis:    Cancels selection.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnSelectStart(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnScroll()
//
// Synopsis:    Cancels scroll.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnScroll(CEventObjectAccess *pEvent)
{
    return RefreshFocusRect();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnContextMenu()
//
// Synopsis:    Cancels menu.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnContextMenu(CEventObjectAccess *pEvent)
{
    return CancelEvent(pEvent);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CancelEvent()
//
// Synopsis:    Cancels the event.
//
// Arguments:   CEventObjectAccess *pEvent - Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CancelEvent(CEventObjectAccess *pEvent)
{
    HRESULT     hr;
    CVariant    var;

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VARIANT_FALSE;
    hr = pEvent->EventObj()->put_returnValue(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IHTMLSelectElement3 overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::clearSelection()
//
// Synopsis:    Deselects all of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::clearSelection()
{
    HRESULT hr = S_OK;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = SetAllSelected(VARIANT_FALSE, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Don't allow single-select to deselect

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::selectAll()
//
// Synopsis:    Selects all of the OPTION elements.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::selectAll()
{
    HRESULT hr;
    long    lNumOptions;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = SetAllSelected(VARIANT_TRUE, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        // Single select selects the last element

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr) || (lNumOptions == 0))
            goto Cleanup;

        hr = OnOptionSelected(VARIANT_TRUE, lNumOptions - 1, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_name()
//
// Synopsis:    Sets the name of the select.
//
// Arguments:   BSTR bstrName - The new name
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_name(BSTR bstrName)
{
    return GetProps()[eName].Set(bstrName);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_name()
//
// Synopsis:    Retrieves the name of the select.
//
// Arguments:   BSTR *pbstrName - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_name(BSTR *pbstrName)
{
    return GetProps()[eName].Get(pbstrName);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_size()
//
// Synopsis:    Sets the size of the SELECT.
//
// Arguments:   long lSize - The new size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_size(long lSize)
{
    HRESULT         hr          = S_OK;
    VARIANT_BOOL    bMult;
    CVariant        var;
    long            lPrevSize;
    CContextAccess  a(_pSite);

    if (lSize < 1)
    {
        return E_INVALIDARG;
    }
    else
    {
        get_size(&lPrevSize);

        if (lPrevSize == lSize)
        {
            // No need to change.
            return S_OK;
        }

        hr = GetProps()[eSize].Set(lSize);
        if (FAILED(hr))
            goto Cleanup;

#ifdef SELECT_GETSIZE
        hr = get_multiple(&bMult);
        if (FAILED(hr))
            goto Cleanup;

        // Detect major change
        if ((lSize == 1) && SELECT_ISLISTBOX(_fFlavor) && !bMult)
        {
            hr = BecomeDropBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else if ((lSize > 1) && SELECT_ISDROPBOX(_fFlavor))
        {
            hr = BecomeListBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            // Reset the height --> CalcSize gets called
            hr = a.Open(CA_DEFSTYLE);
            if (FAILED(hr))
                goto Cleanup;

            V_VT(&var) = VT_I4;
            V_I4(&var) = _sizeOptionReported.cy * lSize;
            hr = a.DefStyle()->put_height(var);
            if (FAILED(hr))
                goto Cleanup;

            hr = RefreshListBox();
            if (FAILED(hr))
                goto Cleanup;

        }
#endif
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::BecomeListBox()
//
// Synopsis:    Changes a dropbox into a listbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::BecomeListBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;

    hr = DeInitViewLink();
    if (FAILED(hr))
        goto Cleanup;

    _fContentReady = FALSE;

    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::BecomeDropBox()
//
// Synopsis:    Changes a listbox into a dropbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::BecomeDropBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;


    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

    hr = InitViewLink();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::RefreshListBox()
//
// Synopsis:    Refreshes content settings on a listbox.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::RefreshListBox()
{
    HRESULT hr;

    _sizeOption = _sizeOptionReported;

    hr = InitContent();
    if (FAILED(hr))
        goto Cleanup;

    if ( !_fNeedScrollBar)
    {
        AdjustSizeForScrollbar(&_sizeOption);
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_size()
//
// Synopsis:    Gets the size of the SELECT.
//
// Arguments:   long *plSize - Receives the size
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_size(long *plSize)
{
    return GetProps()[eSize].Get(plSize);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_selectedIndex()
//
// Synopsis:    Sets the index to be selected.  
//              Any currently selected options are unselected.
//
// Arguments:   long lIndex - The index to select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_selectedIndex(long lIndex)
{
    HRESULT             hr;
    IHTMLOptionElement2 *pOption    = NULL;

    hr = clearSelection();
    if (FAILED(hr))
        goto Cleanup;

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->put_selected(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_selectedIndex()
//
// Synopsis:    Gets the last index to be selected.
//
// Arguments:   long *plIndex - Receives the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_selectedIndex(long *plIndex)
{
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        return GetFirstSelected(plIndex);
    }
    else
    {
        return GetProps()[eSelectedIndex].Get(plIndex);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::put_multiple()
//
// Synopsis:    Turns multiple selection on/off.
//
// Arguments:   VARIANT_BOOL bMult - VARIANT_TRUE=on VARIANT_FALSE=off
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::put_multiple(VARIANT_BOOL bMult)
{
    HRESULT         hr;
    VARIANT_BOOL    bPrevMult;
    long            lMult = bMult ? 0 : -1;

    hr = get_multiple(&bPrevMult);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetProps()[eMultiple].Set(lMult);
    if (FAILED(hr))
        goto Cleanup;

    if (bPrevMult == bMult)
    {
        // Done
        goto Cleanup;
    }

    if (bMult && SELECT_ISDROPBOX(_fFlavor))
    {
        hr = BecomeListBox();
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        long lSize;

        hr = get_size(&lSize);
        if (FAILED(hr))
            goto Cleanup;

        if (!bMult && (lSize == 1) && SELECT_ISLISTBOX(_fFlavor))
        {
            hr = BecomeDropBox();
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            hr = RefreshListBox();
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_multiple()
//
// Synopsis:    Gets if the SELECT is a multiple select.
//
// Arguments:   VARIANT_BOOL *p - Receives if it is a multiple select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_multiple(VARIANT_BOOL * p)
{
    HRESULT hr;
    long    lMult;

    hr = GetProps()[eMultiple].Get(&lMult);
    if (FAILED(hr))
        goto Cleanup;

    *p = (lMult == -1) ? VARIANT_FALSE : VARIANT_TRUE;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_length()
//
// Synopsis:    Retrieves the number of options.
//
// Arguments:   long *plLength - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_length(long *plLength)
{
    return GetNumOptions(plLength);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_type()
//
// Synopsis:    Retrieves the name of the select.
//
// Arguments:   BSTR *pbstrType - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_type(BSTR *pbstrType)
{
    CComBSTR    bstr;

    if (!pbstrType)
    {
        return E_NOTIMPL;
    }
    Assert(pbstrType);

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        bstr = _T("select-multiple");
    }
    else
    {
        bstr = _T("select-one");
    }

    *pbstrType = bstr;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get_options()
//
// Synopsis:    Maps to children.
//
// Arguments:   IDispatch **ppOptions - receives children collection
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::get_options(IDispatch ** ppOptions)
{
    HRESULT             hr;
    CComPtr<IDispatch>  pItems;

    CContextAccess a(_pSite);
    
    if (!ppOptions)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    //  Restoring the old way of handling the options collection until
    //  we can sort out the DISPID issue.
    //
    //  This version simply returns the IHTMLElementCollection of children which doesn't 
    //  support Add/Remove, etc.  The new way will again return the select element's
    //  dispatch interface and support the standard collection interface methods directly.
    //

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->QueryInterface(IID_IDispatch, (void **) ppOptions);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::add()
//
// Synopsis:    Adds the element to the options collection
//
// Arguments:   IDispatch *pElement - option element to be added
//              long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::add(IDispatch *pElement, VARIANT varIndex)
{
    HRESULT hr;

    CComPtr<IHTMLOptionElement2> pOption;
    CComPtr<IHTMLElement> pHtml, pParent;

    CVariant var;

    long lIndex;


    Assert(pElement);

    hr = pElement->QueryInterface(__uuidof(IHTMLOptionElement2), (void **) &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = var.CoerceVariantArg(&varIndex, VT_I4);
    if (FAILED(hr))
        goto Cleanup;

    lIndex = var.IsEmpty() ? -1 : V_I4(&var);

    if (lIndex < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Check to see if this has already been added and is part of this document
    // by checking to see if it has a parent element already
    // 

    hr = pElement->QueryInterface( __uuidof(IHTMLElement), (void **) &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pHtml->get_parentElement(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    if(pParent) 
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = AddOptionHelper(pOption, lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        ClearInterface(&_pSelectInPopup) ;
        UpdatePopup();
    }

Cleanup:

    return hr; 
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::remove()
//
// Synopsis:    Removes the element from the options collection
//
// Arguments:   long lIndex - position in collection of the element that is to be removed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::remove(long lIndex)
{
    HRESULT hr;

    if (lIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = RemoveOptionHelper(lIndex);

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AddOptionHelper()
//
// Synopsis:    Inserts the option element into the select's child collection
//
// Arguments:   IHTMLOptionElement2 *pOption - option element to be added
//              long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::AddOptionHelper(IHTMLOptionElement2 *pOption, long lIndex)
{
    HRESULT hr;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLOptionElement2>    pPrevOption;

    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode, pPrevNode;
    CComVariant vDispatch;

    CContextAccess a(_pSite);

    long cOptions;

    Assert( lIndex >= -1 );

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get number of options

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;
    
    // Calculate the position of the added item within the child collection

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        pPrevNode = NULL;
    }
    else
    {
        // Get the adjacent option if one exists

        hr = GetIndex(lIndex, &pPrevOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pPrevOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pPrevNode);
        if (FAILED(hr))
            goto Cleanup;
    }

    // Insert the option 

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
    if (FAILED(hr))
        goto Cleanup;

    vDispatch = pPrevNode;

    hr = pElementNode->insertBefore(pOptionNode, vDispatch, NULL);
    if (FAILED(hr))
        goto Cleanup;


Cleanup:

    return ResetIndexes();
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::remove()
//
// Synopsis:    Removes the option element from the select's child collection
//
// Arguments:   long lIndex - position in collection where the element is to be added
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::RemoveOptionHelper(long lIndex)
{
    HRESULT hr = S_OK;
 
    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLOptionElement2>    pOption;

    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode;

    CContextAccess a(_pSite);

    long cOptions;

    Assert( lIndex >= -1 );

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    // Get number of options

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;

    // Get the option at the given index

    if(lIndex >= cOptions)
        goto Cleanup;
   
    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    // Remove it

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElementNode->removeChild(pOptionNode, NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return ResetIndexes();
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ParseChildren()
//
// Synopsis:    Walks through the list of children looking for any elements that 
//              do not support IPrivateOption (and are therefor not ie:option elements)
//              and removes them from the document.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT 
CIESelectElement::ParseChildren()
{
    HRESULT hr;

    CContextAccess a(_pSite);
    CComVariant name, index;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IPrivateOption> pOption;
    CComPtr<IHTMLDOMNode> pElementNode, pOptionNode;

    long i, cItems;

    //
    // Get all the children
    // 

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pElementNode);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Iterator through the collection looking for those who don't belong
    //

    for (i = cItems - 1; i >= 0; i--) 
    {
        name = i;
        hr = pItems->item(name, index, &pDispatch);
        if (FAILED(hr))
            goto Cleanup;

        //
        // If it's not an option element, remove it; it doesn't belong
        //

        hr = pDispatch->QueryInterface(IID_IPrivateOption, (void **) &pOption);
        if (FAILED(hr))
        {
            hr = pDispatch->QueryInterface( __uuidof(IHTMLDOMNode), (void **) &pOptionNode);
            if (FAILED(hr))
                goto Cleanup;

            hr = pElementNode->removeChild(pOptionNode, NULL);
            if (FAILED(hr))
                goto Cleanup;

            pOptionNode.Release();
        }
             
        pDispatch.Release();
        pOption.Release();
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ResetIndexes()
//
// Synopsis:    Sets the index of each child to the current position in the
//              child collection.
//
//              Note: this is only here because of the fact that the option elements
//              hold onto the index.  This should be removed since it makes dealing with
//              the dynamic collection difficult.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::ResetIndexes()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IDispatch> pDispatch;
    CComPtr<IPrivateOption> pPrivOption;

    CComVariant name, index;

    long i;
    long cOptions;

    // get the option collection and iterate through it

    hr = get_length(&cOptions);
    if (FAILED(hr))
        goto Cleanup;

    for(i = 0; i < cOptions; i++) 
    {
        name = i;
        hr = item(name, index, &pDispatch);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatch->QueryInterface(IID_IPrivateOption, (void **) &pPrivOption);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pPrivOption->SetIndex(i);
        if (FAILED(hr))
            goto Cleanup;  
        
        pDispatch.Release();
        pPrivOption.Release();
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::get__newEnum()
//
// Synopsis:    Standard get__newEnum collection iterator
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::get__newEnum(IUnknown ** p)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->get__newEnum(p);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::item()
//
// Synopsis:    Gets an item from the options collection.
//
// Arguments:   VARIANT name       - 
//              VARIANT index      -
//              IDispatch ** pdisp - the selected item
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::item(VARIANT name, VARIANT index, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->item(name, index, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::tags()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::tags(VARIANT tagName, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems->tags(tagName, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSingleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------

HRESULT
CIESelectElement::urns(VARIANT urn, IDispatch ** pdisp)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);
    CComPtr<IHTMLElementCollection> pItems;
    CComPtr<IHTMLElementCollection2> pItems2;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**) &pItems);
    if (FAILED(hr))
        goto Cleanup;

    hr = pItems->QueryInterface( __uuidof(IHTMLElementCollection2), (void **) &pItems2);
    if (FAILED(hr))
        goto Cleanup;
    
    hr = pItems2->urns(urn, pdisp);
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSingleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CommitSingleSelection(BOOL *pbChanged)
{
    HRESULT         hr      = S_OK;
    VARIANT_BOOL    bOn;
    long            lIndex  = -1;

    Assert(pbChanged);
    *pbChanged = FALSE;

    if (_pLastSelected)
    {
        hr = _pLastSelected->GetHighlight(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOn)
        {
            // If we're not highlighted, then our selection status changed
            hr = _pLastSelected->SetSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        ClearInterface(&_pLastSelected);
    }

    if (_pLastHighlight)
    {
        hr = _pLastHighlight->GetSelected(&bOn);
        if (FAILED(hr))
            goto Cleanup;

        if (!bOn)
        {
            // If we are not selected, then our selection status changed
            hr = _pLastHighlight->SetSelected(VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        hr = _pLastHighlight->GetIndex(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        _pLastSelected = _pLastHighlight;
        _pLastSelected->AddRef();
    }

    hr = GetProps()[eSelectedIndex].Set(lIndex);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitMultipleSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::CommitMultipleSelection(BOOL *pbChanged)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    VARIANT_BOOL            bHighlight;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    CContextAccess          a(_pSite);

    Assert(pbChanged);
    *pbChanged = FALSE;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    if ( (_lTopChanged < 0) || (_lTopChanged >= cItems) ||
            (_lBottomChanged < 0) || (_lBottomChanged >= cItems) )
    {
        hr = S_OK;
        goto Cleanup;
    }

    for (iItem = _lTopChanged; iItem <= _lBottomChanged; iItem++)
    {
        CVariant                var, var2;

        //
        // Get a child
        //
        V_VT(&var) = VT_I4;
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pPrivOption->GetSelected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        hr = pPrivOption->GetHighlight(&bHighlight);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected != bHighlight)
        {
            hr = pPrivOption->SetSelected(bHighlight);
            if (FAILED(hr))
                goto Cleanup;

            *pbChanged = TRUE;
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::CommitSelection()
//
// Synopsis:    Commits the highlighted options to being selected.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::CommitSelection(BOOL *pbChanged)
{
    HRESULT         hr          = S_OK;
    BOOL            bChanged;

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        hr = CommitMultipleSelection(&bChanged);
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = CommitSingleSelection(&bChanged);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (pbChanged)
    {
        *pbChanged = bChanged;
    }

Cleanup:
    return hr;
}
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetWritingMode
//
// Synopsis:    Commits the writing mode.
//
// Arguments:   BSTR bstrName : the writing mode.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SetWritingMode(BSTR bstrName)
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    
    hr = a.Open(CA_STYLE3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style3()->put_writingMode(bstrName);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::FireOnChange()
//
// Synopsis:    Commits the highlighted options to being selected.
//              Then, if anything changed, fires onchange.
//
// Arguments:   BOOL *pbChanged - Returns whether anything changed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::FireOnChange()
{
    HRESULT         hr          = S_OK;
    BOOL            bChanged;

    hr = CommitSelection(&bChanged);
    if (FAILED(hr))
        goto Cleanup;

    if (bChanged || SELECT_ISINPOPUP(_fFlavor))
    {
        hr = FireEvent(_lOnChangeCookie, NULL, CComBSTR("change"));
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AdjustChangedRange()
//
// Synopsis:    Ajdusts the change range to include the given index.
//
// Arguments:   long lIndex - The index to include
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
void
CIESelectElement::AdjustChangedRange(long lIndex)
{
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if ((lIndex < _lTopChanged) || (_lTopChanged == -1))
        {
            _lTopChanged = lIndex;
        }

        if (lIndex > _lBottomChanged)
        {
            _lBottomChanged = lIndex;
        }
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionClicked()
//
// Synopsis:    Called when an option is clicked (or simulated click).
//
// Arguments:   long  lIndex  - The index of the option
//              DWORD dwFlags - Selection flags (fire event, keyboard)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionClicked(long lIndex, DWORD dwFlags)
{
    VARIANT_BOOL    bSelected   = VARIANT_TRUE;
    DWORD           dwSelFlags  = dwFlags & (SELECT_FIREEVENT);

    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if (dwFlags & SELECT_SHIFT)
        {
            dwSelFlags |= SELECT_EXTEND;
        }
        else if (dwFlags & SELECT_CTRL)
        {
            dwSelFlags |= SELECT_TOGGLE;
        }
        else
        {
            dwSelFlags |= SELECT_CLEARPREV;
        }
    }
    else
    {
        dwSelFlags |= SELECT_CLEARPREV;
    }

    return OnOptionSelected(bSelected, lIndex, dwSelFlags);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionSelected()
//
// Synopsis:    Called when an option is selected/deselected.
//
// Arguments:   VARIANT_BOOL bSelected - Whether the option is selected
//              long  lIndex           - The index of the option
//              DWORD dwFlags          - Selection flags (fire event, keyboard)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionSelected(VARIANT_BOOL bSelected, long lIndex, DWORD dwFlags)
{
    HRESULT             hr;
    IPrivateOption      *pOption        = NULL;
    BOOL                bSetShiftAnchor = TRUE;
    BOOL                bRefreshFocus   = TRUE;
    BOOL                bNeedToSelect   = TRUE;
    long                lPrevIndex;

    if (!SELECT_ISMULTIPLE(_fFlavor))
    {
        //
        // Do some checking for single-select
        //

        if (!bSelected)
        {
            // Don't allow de-select in single-select
            hr = S_OK;
            goto Cleanup;
        }

        // Require this flag in single-select
        dwFlags |= SELECT_CLEARPREV;
    }

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr) || !pOption)
        goto Cleanup;

    AdjustChangedRange(lIndex);

    //
    // Remove the previously selected items only if selecting
    //
    if (bSelected)
    {
        if (SELECT_ISMULTIPLE(_fFlavor))
        {
            // Multiple select doesn't have to de-highlight previous items
            if (dwFlags & SELECT_CLEARPREV)
            {
                hr = SetAllSelected(VARIANT_FALSE, NULL);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else
        {
            // Single select must de-highlight the previous item
            if (_pLastHighlight)
            {
                hr = _pLastHighlight->GetIndex(&lPrevIndex);
                if (FAILED(hr))
                    goto Cleanup;

                // If highlighting the previous item, then don't do anything
                if (lPrevIndex != lIndex)
                {
                    // De-highlight the previous item
                    hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
                    if (FAILED(hr))
                        goto Cleanup;
                }
            }

            if (SELECT_ISINPOPUP(_fFlavor) && _pLastHighlight)
            {
                // In the popup, un-highlight the currently highlighted option.
                hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
    }

    //
    // Highlight the new item
    //
    if (SELECT_ISDROPBOX(_fFlavor))
    {
        hr = DropDownSelect(pOption);
        if (FAILED(hr))
            goto Cleanup;

        Assert(_pSelectInPopup);

        hr = _pSelectInPopup->OnOptionSelected(bSelected, lIndex, dwFlags & (~SELECT_FIREEVENT));
        if (FAILED(hr))
            goto Cleanup;

        bNeedToSelect = FALSE;
    }
    else if (SELECT_ISMULTIPLE(_fFlavor))
    {
        if ((dwFlags & SELECT_EXTEND) && (_lShiftAnchor != -1))
        {
            hr = SelectRange(_lShiftAnchor, _lFocusIndex, lIndex);
            if (FAILED(hr))
                goto Cleanup;

            bSetShiftAnchor = FALSE;
            bNeedToSelect = FALSE;
        }
        else
        {
            if (dwFlags & SELECT_TOGGLE)
            {
                hr = pOption->GetSelected(&bSelected);
                if (FAILED(hr))
                    goto Cleanup;

                bSelected = bSelected ? VARIANT_FALSE : VARIANT_TRUE;
            }
        }
    }
    else if (SELECT_ISINPOPUP(_fFlavor))
    {
        VARIANT_BOOL bOpen;

        Assert(_pPopup);

        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            bRefreshFocus = !(dwFlags & SELECT_FIREEVENT);
        }
        else
        {
            bRefreshFocus = FALSE;
        }
    }

    if (bNeedToSelect)
    {
        // Highlight the item
        hr = pOption->SetHighlight(bSelected);
        if (FAILED(hr))
            goto Cleanup;
    }

    if (bSelected || (dwFlags & SELECT_CLEARPREV))
    {
        if (_pLastHighlight)
        {
            ClearInterface(&_pLastHighlight);
        }

        if (bSelected)
        {
            _pLastHighlight = pOption;
            _pLastHighlight->AddRef();

            if (SELECT_ISLISTBOX(_fFlavor))
            {
                hr = MakeOptionVisible(_pLastHighlight);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
    }

    if (bSetShiftAnchor)
    {
        _lShiftAnchor = lIndex;
    }

    hr = OnOptionFocus(lIndex, (VARIANT_BOOL)bRefreshFocus);
    if (FAILED(hr))
        goto Cleanup;

    if (dwFlags & SELECT_FIREEVENT)
    {
        // Commit changes to selection (highlight -> selected)
        hr = FireOnChange();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionHighlighted()
//
// Synopsis:    Called back when an option is highlighted
//
// Arguments:   long lIndex - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionHighlighted(long lIndex)
{
    HRESULT             hr;

    if (_pLastHighlight)
    {
        hr = _pLastHighlight->SetHighlight(VARIANT_FALSE);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&_pLastHighlight);
    }

    hr = GetIndex(lIndex, &_pLastHighlight);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pLastHighlight->SetHighlight(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionFocus()
//
// Synopsis:    Called back when an option is focused
//
// Arguments:   long         lIndex          - Index of the option
//              VARIANT_BOOL bRequireRefresh - Force a refresh
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionFocus(long lIndex, VARIANT_BOOL bRequireRefresh /* = VARIANT_TRUE */)
{
    HRESULT             hr = S_OK ;

    _lFocusIndex = lIndex;

    if (bRequireRefresh || !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = RefreshFocusRect();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitOptions()
//
// Synopsis:    Sets option flags based on the select's flavor.
//              Initializes default selections.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::InitOptions()
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    long                    lStart, lEnd;
    long                    lDirection;

    BOOL                    bTurnOff        = FALSE;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    IHTMLOptionElement2     *pOption        = NULL;

    CVariant                var, var2;
    VARIANT_BOOL            bSelected;
    CContextAccess          a(_pSite);


    hr = a.Open(CA_ELEM | CA_STYLE);
    if (FAILED(hr))
        goto Cleanup;

    hr = ParseChildren();
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pPrivOption->SetIndex(iItem);
        if (FAILED(hr))
            goto Cleanup;

        if (SELECT_ISINPOPUP(_fFlavor))
        {
            //
            // If the listbox is in a popup, 
            // options should only be selected on onmouseup events.
            // The options should also highlight on onmouseover events.
            // 
            pPrivOption->SetSelectOnMouseDown(VARIANT_FALSE);
            pPrivOption->SetHighlightOnMouseOver(VARIANT_TRUE);
        }
        else
        {
            pPrivOption->SetSelectOnMouseDown(VARIANT_TRUE);
            pPrivOption->SetHighlightOnMouseOver(VARIANT_FALSE);
        }
    
       
        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

    //
    // Deal with default selected options
    //

    // Setup the begin and end values and the direction.
    // we're doing this since the code we want to run is the same,
    // just in different directions depending on the flavor.
    if (SELECT_ISMULTIPLE(_fFlavor))
    {
        lStart = 0;
        lEnd = cItems;
        lDirection = 1;
    }
    else
    {
        lStart = cItems - 1;
        lEnd = -1;
        lDirection = -1;
    }
    for (iItem = lStart; iItem != lEnd; iItem += lDirection)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        if (bTurnOff)
        {
            hr = pPrivOption->SetSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;

            hr = pPrivOption->SetInitSelected(VARIANT_FALSE);
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            hr = pPrivOption->GetSelected(&bSelected);
            if (FAILED(hr))
                goto Cleanup;

            if (bSelected)
            {
                hr = OnOptionSelected(VARIANT_TRUE, iItem, 0);
                if (FAILED(hr))
                    goto Cleanup;

                if (SELECT_ISMULTIPLE(_fFlavor))
                {
                    // Multiple select is done. So, break out
                    iItem = lEnd - lDirection; // Causes us to break out
                }
                else
                {
                    // Single select should turn the rest off
                    bTurnOff = TRUE;
                }
            }
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

    hr = CommitSelection(NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (SELECT_ISDROPBOX(_fFlavor) && (cItems > 0))
    {
        // Initialize the selection on dropdowns
        long lSelIndex;

        hr = get_selectedIndex(&lSelIndex);
        if (FAILED(hr))
            goto Cleanup;

        if (((lSelIndex == -1) || (hr == S_FALSE)) && (cItems > 0))
        {
            V_I4(&var) = 0;
            hr = pItems->item(var, var2, &pDispatchItem);
            if (FAILED(hr))
                goto Cleanup;

            hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
            if (SUCCEEDED(hr))
            {
                hr = pPrivOption->SetInitSelected(VARIANT_TRUE);
                if (FAILED(hr))
                    goto Cleanup;
            } // added

            // There was no slection, so select the first one
            OnOptionSelected(VARIANT_TRUE, 0, 0);
            // Ignore the return value

            hr = CommitSelection(NULL);
            if (FAILED(hr))
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

#ifdef SELECT_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnOptionSized()
//
// Synopsis:    Called by the options when they are sized.
//
// Arguments:   SIZE* psizeOption - The option's size (and returns it)
//              BOOL  bNew        - TRUE if this is the first time it's calling back
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::OnOptionSized(SIZE* psizeOption, BOOL bNew, BOOL bAdjust)
{
    HRESULT     hr = S_OK;

    BOOL bWidthSet, bHeightSet;

    if (bNew)
    {
        // If the option is reporting a new size, then compare it
        // with the current largest option.
        _lNumOptionsReported++;
    }

    if (bNew || bAdjust)
    {
        if (psizeOption->cx > _sizeOptionReported.cx)
        {
            _sizeOptionReported.cx = psizeOption->cx; 
            _fLayoutDirty = TRUE;
        }

        if(_lNumOptionsReported == 1) {
            if (psizeOption->cy > _sizeOptionReported.cy)
            {
                _sizeOptionReported.cy = psizeOption->cy;
                _fLayoutDirty = TRUE;
            }
        }
    }

    hr = IsWidthHeightSet(&bWidthSet, &bHeightSet);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Only adjust for scrollbars if the width hasn't been
    // set explicitly.  The code to handle explicitly sizing
    // accounts for the scrollbar.
    //

    // Set the return value for the option
    *psizeOption = _sizeOptionReported;

    if(!bWidthSet) 
    {
        AdjustSizeForScrollbar(psizeOption);
    }

    if (!_fAllOptionsSized)
    {
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        if (lNumOptions == _lNumOptionsReported)
        {
            // All options have reported in at least once
            // so they have all been sized.
            _fAllOptionsSized = TRUE;
        }
    }

    if (_fAllOptionsSized)
    {
        // All options have been sized, so setup the select's version
        // of an option size.

        _sizeOption = *psizeOption;

#ifdef SELECT_TIMERVL
        if (SELECT_ISDROPBOX(_fFlavor) &&
            _fContentReady && !_fVLEngaged)
        {
            // If ViewLink has not been turned on, then turn it on.
            AddSelectToTimerVLQueue(this);
        }
#endif
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AdjustSizeForScrollbar()
//
// Synopsis:    Inflates the size to account for any scrollbars.
//
// Arguments:   SIZE *pSize - The size to adjust
//
// Returns:     None.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::AdjustSizeForScrollbar(SIZE *pSize)
{
    long lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fContentReady)
    {
        if ( !_fNeedScrollBar && SELECT_ISLISTBOX(_fFlavor))
        {
            // If the select does not need a scroll bar, then
            // the option needs to be wider.
            pSize->cx += lButtonWidth;
        }

        if (SELECT_ISINPOPUP(_fFlavor))
        {
            // This is padding added in the drop control that
            // affects the width of the popup, affecting the
            // width of the option.
            pSize->cx += 4;
        }
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDropControlDimensions()
//
// Synopsis:    Setup the drop control's elements' dimensions.
//
// Arguments:   SIZE sizeOption - The option's size
//              BOOL bNew       - TRUE if this is the first time it's calling back
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDropControlDimensions()
{
    HRESULT             hr;
    long                lButtonWidth;
    IHTMLStyle          *pStyle = NULL;
    SIZE                sizeLogical;
    long                lWidth;
    long                lHeight;

    Assert(_pElemDisplay);

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    if (_fWritingModeTBRL)
    {
        sizeLogical.cx = _sizeOptionReported.cy;
        sizeLogical.cy = _sizeOptionReported.cx;
        lWidth = _sizeOptionReported.cy + 2;
        lHeight = lButtonWidth;
    }
    else
    {
        sizeLogical = _sizeOptionReported;
        lWidth = lButtonWidth;
        lHeight = _sizeOptionReported.cy + 2;
    }

    hr = _pElemDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width of the display
    hr = pStyle->put_pixelWidth(sizeLogical.cx);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the display
    hr = pStyle->put_pixelHeight(sizeLogical.cy);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width of the button
    hr = _pStyleButton->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

    // Set the height of the button (+2 for border)
    hr = _pStyleButton->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupButton()
//
// Synopsis:    Setup the drop control's button.
//
// Arguments:   IHTMLElement *pButton - The button
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupButton(IHTMLElement *pButton)
{
    HRESULT         hr;
    IHTMLStyle      *pStyle     = NULL;
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrButtonFace(_T("buttonface"));
    CComBSTR        bstrBorder(_T("2 outset"));
    CComBSTR        bstrFont(_T("Marlett"));
    CComBSTR        bstrButtonText(_T("u"));
    CComBSTR        bstrCenter(_T("center"));
    CComBSTR        bstrMiddle(_T("middle")); 
    CVariant        var;
    long            lButtonWidth;


    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    hr = pButton->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;
        
    // Store for later use
    _pStyleButton = pStyle;
    _pStyleButton->AddRef();

    // Set the mouse cursor be an arrow for the button
    hr = pStyle->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the button
    hr = pStyle->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;

    // Set the background color for the button
    hr = pStyle->put_background(bstrButtonFace);
    if (FAILED(hr))
        goto Cleanup;

    // Set the border for the button
    hr = pStyle->put_border(bstrBorder);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font family of the button
    hr = pStyle->put_fontFamily(bstrFont);
    if (FAILED(hr))
        goto Cleanup;

    // Set the font size of the button
    V_VT(&var) = VT_I4;
    V_I4(&var) = lButtonWidth - 4;
    hr = pStyle->put_fontSize(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the text to be the down arrow
    hr = pButton->put_innerText(bstrButtonText);
    if (FAILED(hr))
        goto Cleanup;

    // Set the alignment on the arrow to be centered
    hr = pStyle->put_textAlign(bstrCenter);
    if (FAILED(hr))
        goto Cleanup;

    // Align the button to the middle
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrMiddle;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetupDisplay()
//
// Synopsis:    Setup the drop control's display.
//
// Arguments:   IHTMLElement *pDisplay - The display
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetupDisplay(IHTMLElement *pDisplay)
{
    HRESULT         hr;
    IHTMLStyle      *pStyle     = NULL;
    IHTMLStyle3     *pStyle3     = NULL;
    CComBSTR        bstrDefault(_T("default"));
    CComBSTR        bstrHidden(_T("hidden"));
    CComBSTR        bstrMiddle(_T("middle"));
    CComBSTR        bstr2px(_T("2px"));
    CVariant        var;
    long            lButtonWidth;
    CComBSTR        bstrWritingMode(_T(""));

    _pElemDisplay = pDisplay;
    _pElemDisplay->AddRef();

    // Get the width of the button
    lButtonWidth = GetSystemMetrics(SM_CXVSCROLL);

    //
    // Set the display's style
    //
    hr = pDisplay->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->QueryInterface(IID_IHTMLStyle3, (void**)&pStyle3);
    if (FAILED(hr))
        goto Cleanup;

    if (_fWritingModeTBRL)
    {
        bstrWritingMode = _T("tb-rl");
    }

    hr = pStyle3->put_writingMode(bstrWritingMode);
    if (FAILED(hr))
        goto Cleanup;

    // Set the mouse cursor be an arrow for the display
    hr = pStyle->put_cursor(bstrDefault);
    if (FAILED(hr))
        goto Cleanup;

    // Set overflow hidden for the display
    hr = pStyle->put_overflow(bstrHidden);
    if (FAILED(hr))
        goto Cleanup;
   
    // Set the vertical alignment of the display to be middle
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrMiddle;
    hr = pStyle->put_verticalAlign(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the left padding on the display
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr2px;
    hr = pStyle->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

    // Set the margin on the display
    V_VT(&var) = VT_I4;
    V_I4(&var) = 1;
    hr = pStyle->put_marginLeft(var);
    if (FAILED(hr))
        goto Cleanup;
    hr = pStyle->put_marginRight(var);
    if (FAILED(hr))
        goto Cleanup;
    hr = pStyle->put_marginTop(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pStyle);
    ClearInterface(&pStyle3);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitViewLink()
//
// Synopsis:    Engages viewlink, sets up the drop control's dimensions
//              and makes the drop control visible.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::InitViewLink()
{
    HRESULT         hr;
    long            lIndex;
    IPrivateOption  *pOption = NULL;
    long            lSize;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    if ( lSize >1 )
        goto Cleanup;

    // Engage the viewlink
    hr = EngageViewLink();
    if (FAILED(hr))
        goto Cleanup;

    // Put the selected option into the display
    hr = get_selectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lIndex >= 0)
    {
        hr = GetIndex(lIndex, &pOption);
        if (SUCCEEDED(hr) && pOption)
        {
            hr = DropDownSelect(pOption);
            if (FAILED(hr))
                goto Cleanup;
        }
    }

    // Resize the elements in the viewlink
    hr = SetupDropControlDimensions();
    if (FAILED(hr))
        goto Cleanup;

    // Make the control visible
    hr = MakeVisible(TRUE);
    if (FAILED(hr))
        goto Cleanup;

    _fLayoutDirty = TRUE;

Cleanup:
    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DeInitViewLink()
//
// Synopsis:    Turns off ViewLink.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::DeInitViewLink()
{
    HRESULT         hr = E_FAIL;
    VARIANT_BOOL    bOpen;
    CContextAccess  a(_pSite);


    if (!_fVLEngaged)
    {
        goto Cleanup;
    }
    else
    {
        _fVLEngaged = FALSE;
    }

    
    //
    // Get a hold of the Link document
    //

    ReleaseInterface(_pDispDocLink);
    hr = _pElemDisplay->get_document(&_pDispDocLink);
    if (FAILED(hr))
        goto Cleanup;

    ClearInterface(&_pElemDisplay);
    ClearInterface(&_pStyleButton);
    ClearInterface(&_pSelectInPopup);

    hr = a.Open(CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    // Remove the viewLink
    hr = a.Defaults()->putref_viewLink(NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (_pPopup && !SELECT_ISINPOPUP(_fFlavor))
    {
        hr = _pPopup->get_isOpen(&bOpen);
        if (FAILED(hr))
            goto Cleanup;

        if (bOpen)
        {
            hr = HidePopup();
            if (FAILED(hr))
                goto Cleanup;
        }

        ClearInterface(&_pPopup);
    }

Cleanup:
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::EngageViewLink()
//
// Synopsis:    Turns on ViewLink.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::EngageViewLink()
{
    HRESULT             hr              = S_OK;

    IHTMLDocument2      *pDocThis       = NULL;
    IHTMLDocument2      *pDocLink       = NULL;
    IHTMLDocument3      *pDocLink3      = NULL;
    IDispatch           *pDispDocLink   = NULL;

    IHTMLElement        *pElemLink      = NULL;
    IHTMLDOMNode        *pNodeLink      = NULL;
    IHTMLElement        *pElemNOBR      = NULL;
    IHTMLDOMNode        *pNodeNOBR      = NULL;
    IHTMLElement        *pElemDisplay   = NULL;
    IHTMLDOMNode        *pNodeDisplay   = NULL;
    IHTMLElement        *pElemButton    = NULL;
    IHTMLDOMNode        *pNodeButton    = NULL;

    IHTMLElement2       *pElem2         = NULL;
    CComBSTR            bstrSpan(_T("SPAN"));
    CComBSTR            bstrNOBR(_T("NOBR"));
    CComBSTR            bstr;
    CContextAccess      a(_pSite);

    if (_fVLEngaged)
    {
        goto Cleanup;
    }
    else
    {
        _fVLEngaged = TRUE;
    }

    hr = a.Open(CA_ELEM | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    // Get the document
    hr = a.Elem()->get_document((IDispatch**)&pDocThis);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create a superflous slave element for now
    //
    hr = pDocThis->createElement(bstrSpan, &pElemLink);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemLink->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert a NOBR element
    //
    hr = pDocThis->createElement(bstrNOBR, &pElemNOBR);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemNOBR->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeNOBR);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeLink->appendChild(pNodeNOBR, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert the display element
    //
    hr = pDocThis->createElement(bstrSpan, &pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemDisplay->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeNOBR->appendChild(pNodeDisplay, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create and insert the button
    //
    hr = pDocThis->createElement(bstrSpan, &pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElemButton->QueryInterface(IID_IHTMLDOMNode, (void**)&pNodeButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pNodeNOBR->appendChild(pNodeButton, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Remove the superflous Link element now
    //
    hr = pNodeLink->removeNode(VB_FALSE, NULL);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get a hold of the Link document
    //
    if (_pDispDocLink)
    {
        ClearInterface(&_pDispDocLink);
    }

    hr = pElemDisplay->get_document(&pDispDocLink);
    if (FAILED(hr))
        goto Cleanup;

    _pDispDocLink = pDispDocLink;
    _pDispDocLink->AddRef();

    hr = pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**)&pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Create the viewLink
    //
    hr = a.Defaults()->putref_viewLink(pDocLink);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Setup styles and sizes
    //
    hr = SetupDisplay(pElemDisplay);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetupButton(pElemButton);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDocLink->QueryInterface(IID_IHTMLDocument3, (void**)&pDocLink3);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Attach an event sink to listen for events within the view link
    //

    if ( !_pSinkVL )
    {
        _pSinkVL = new CEventSink(this, SELECTES_VIEWLINK);
        if (!_pSinkVL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onclick");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onselectstart");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("oncontextmenu");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pDocLink3, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;
    }


    if ( !_pSinkButton )
    {
        _pSinkButton = new CEventSink(this, SELECTES_BUTTON);
        if (!_pSinkButton)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pElemDisplay->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pElem2);

        hr = pElemButton->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmousedown");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseup");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onmouseout");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkButton);
        if (FAILED(hr))
            goto Cleanup;

        if ( _pSinkVL )
        bstr = _T("onbeforefocusenter");
        hr = AttachEventToSink(pElem2, bstr, _pSinkVL);
        if (FAILED(hr))
            goto Cleanup;

    }
Cleanup:
    ReleaseInterface(pDocThis);

    ReleaseInterface(pDispDocLink);
    ReleaseInterface(pDocLink);
    ReleaseInterface(pDocLink3);

    ReleaseInterface(pElemLink);
    ReleaseInterface(pNodeLink);

    ReleaseInterface(pElemNOBR);
    ReleaseInterface(pNodeNOBR);

    ReleaseInterface(pElemDisplay);
    ReleaseInterface(pNodeDisplay);

    ReleaseInterface(pElemButton);
    ReleaseInterface(pNodeButton);

    ReleaseInterface(pElem2);
    
    return hr;
}
#endif

#ifndef SELECT_GETSIZE
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDimensions()
//
// Synopsis:    Sets the dimensions for the select and option controls.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::SetDimensions()
{
    HRESULT     hr;
    long        lSize;

    hr = get_size(&lSize);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetDimensions(lSize);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetDimensions()
//
// Synopsis:    Sets the dimensions for the select and option controls.
//
// Arguments:   long lSize      The size of the control.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetDimensions(long lSize)
{
    HRESULT                     hr;

    IHTMLElementCollection      *pItems         = NULL;
    IDispatch                   *pDispatchItem  = NULL;
    IHTMLElement2               *pElem2         = NULL;
    IPrivateOption              *pOption        = NULL;
    IHTMLRect                   *pRect          = NULL;
    
    long                        cNumItems;
    long                        iCurRow;

    long                        lHeight = 0;
    long                        lWidth = 0;

    long                        lScrollWidth;
    long                        lVertBorder;
    long                        lHorizBorder;

    long                        lMaxWidth = 0;
    long                        lMaxHeight = 0;

    long                        lClient;
    long                        lOffset;

    long                        lItemTop;
    long                        lItemLeft;
    long                        lItemHeight;
    long                        lItemWidth;
    long                        lTemp;

    CVariant                    var, var2;

    CContextAccess              a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the scroll bar width
    //
    lScrollWidth = GetSystemMetrics(SM_CXVSCROLL);

    //
    // Calculate the vertical padding and border
    //
    hr = a.Elem()->get_offsetHeight(&lOffset);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->get_clientHeight(&lClient);
    if (FAILED(hr))
        goto Cleanup;

    lVertBorder = lOffset - lClient;

    //
    // Calculate the horizontal padding and border
    //
    hr = a.Elem()->get_offsetWidth(&lOffset);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem2()->get_clientWidth(&lClient);
    if (FAILED(hr))
        goto Cleanup;

    lHorizBorder = lOffset - lClient;

    //
    // Get the children
    //
    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Set the scroll range
    //
    hr = pItems->get_length(&cNumItems);
    if (FAILED(hr))
        goto Cleanup;

    for (iCurRow = 0; iCurRow < cNumItems; iCurRow++)
    {
        // Get the row
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCurRow;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        // Get the IHTMLElement interface
        hr = pDispatchItem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Get the width and height of the option
        //
        hr = pElem2->getBoundingClientRect(&pRect);
        if (FAILED(hr))
            goto Cleanup;

        hr = pRect->get_top(&lItemTop);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pRect->get_left(&lItemLeft);
        if (FAILED(hr))
            goto Cleanup;
        
        hr = pRect->get_right(&lItemWidth);
        if (FAILED(hr))
            goto Cleanup;

        hr = pRect->get_bottom(&lItemHeight);
        if (FAILED(hr))
            goto Cleanup;

        lItemWidth -= lItemLeft;
        lItemHeight -= lItemTop;

        ClearInterface(&pRect);
        ClearInterface(&pElem2);

        //
        // If the width is greater than the maximum,
        // then set the max to the option's width.
        //
        if (lItemWidth > lMaxWidth)
        {
            lMaxWidth = lItemWidth;
        }

        //
        // If the width is greater than the maximum,
        // then set the max to the option's width.
        //
        if (lItemHeight > lMaxHeight)
        {
            lMaxHeight = lItemHeight;
        }

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->SetFinalDefaultStyles();
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pOption);
        ClearInterface(&pDispatchItem);
    }

    //
    // If we have no default option height,
    // then set to a default size.
    //
    if (lMaxHeight == 0)
    {
        lMaxHeight = SELECT_OPTIONHEIGHT;
    }

    //
    // Calculate the height of the control
    //
    lHeight = lMaxHeight * lSize;

    // Add in the border
    lHeight += lVertBorder;

    // Add in the border and the scroll bar + padding
    // for IE5 compat, there is 2 pixels padding at left and right
    lWidth = lMaxWidth + lHorizBorder + lScrollWidth + 4;

    if (_fWritingModeTBRL)
    {
        lTemp = lWidth;
        lWidth = lHeight;
        lHeight = lTemp;
    }
    // Set the height
    hr = a.DefStyle()->put_pixelHeight(lHeight);
    if (FAILED(hr))
        goto Cleanup;

    // Set the width
    hr = a.DefStyle()->put_pixelWidth(lWidth);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Take care of some last minute styles
    // Force fixed height
    //
    _lMaxHeight = lMaxHeight;
    for (iCurRow = 0; iCurRow < cNumItems; iCurRow++)
    {
        // Get the row
        V_VT(&var) = VT_I4;
        V_I4(&var) = iCurRow;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        hr = pOption->SetFinalHeight(lMaxHeight);
        if (FAILED(hr))
            goto Cleanup;

        ClearInterface(&pDispatchItem);
        ClearInterface(&pOption);
    }

Cleanup:
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);
    ReleaseInterface(pElem2);
    ReleaseInterface(pRect);
    ReleaseInterface(pOption);
    return hr;
}
#endif

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetSelectedIndex()
//
// Synopsis:    Returns the currently selected index.
//
// Arguments:   long *plIndex - Returns the index.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::GetSelectedIndex(long *plIndex)
{
    return get_selectedIndex(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetDisabled()
//
// Synopsis:    Returns if the control is disabled.
//
// Arguments:   VARIANT_BOOL *pbDisabled - Returns VARIANT_TRUE if disabled.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CIESelectElement::GetDisabled(VARIANT_BOOL *pbDisabled)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(pbDisabled);

    hr = a.Open(CA_ELEM3);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem3()->get_disabled(pbDisabled);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetAllSelected()
//
// Synopsis:    Sets all of the options to the given selection status.
//
// Arguments:   VARIANT_BOOL bSelected - Select/Deselect elements
//              DWORD        dwFlags   - Selection flags (fire event)
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetAllSelected(VARIANT_BOOL bSelected, DWORD dwFlags)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bPrev;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pPrivOption    = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(SELECT_ISMULTIPLE(_fFlavor));

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        if ((dwFlags & SELECT_FIREEVENT) && (iItem == (cItems - 1)))
        {
            hr = OnOptionSelected(bSelected, iItem, SELECT_FIREEVENT);
            if (FAILED(hr))
                goto Cleanup;
        }
        else
        {
            V_I4(&var) = iItem;
            hr = pItems->item(var, var2, &pDispatchItem);
            if (FAILED(hr))
            {
                ClearInterface(&pDispatchItem);
                continue;
            }

            hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pPrivOption);
            if (FAILED(hr))
                goto Cleanup;

            hr = pPrivOption->GetHighlight(&bPrev);
            if (FAILED(hr))
                goto Cleanup;

            if (bPrev != bSelected)
            {
                hr = pPrivOption->SetHighlight(bSelected);
                if (FAILED(hr))
                    goto Cleanup;

                AdjustChangedRange(iItem);
            }
        }

        ClearInterface(&pPrivOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pPrivOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetNumOptions()
//
// Synopsis:    Returns the number of options in the select.
//
// Arguments:   long *plItems - Returns the number of options
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetNumOptions(long *plItems)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    CContextAccess          a(_pSite);

    Assert(plItems);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(plItems);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetScrollTopBottom()
//
// Synopsis:    Returns the scroll top and bottom values.
//
// Arguments:   long *plScrollTop    - The top value
//              long *plScrollBottom - The bottom value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetScrollTopBottom(long *plScrollTop, long *plScrollBottom)
{
    HRESULT                 hr;
    long                    lHeight;
    CContextAccess          a(_pSite);

    Assert(plScrollTop);
    Assert(plScrollBottom);

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = a.Elem2()->get_scrollTop(plScrollTop);
    if (FAILED(hr))
        goto Cleanup;

#ifdef SELECT_GETSIZE
    // TODO: Just use this instead of lHeight
    lHeight = _sizeContent.cy;
#else
    hr = a.Elem2()->get_clientHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;
#endif

    *plScrollBottom = *plScrollTop + lHeight;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetTopVisibleOptionIndex()
//
// Synopsis:    Returns the index of the first visible option.
//
// Arguments:   long *plItems - Returns the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetTopVisibleOptionIndex(long *plIndex)
{
    HRESULT                 hr              = S_OK;
    long                    lScrollTop;
    long                    lScrollBottom;

    Assert(plIndex);

    if (_lMaxHeight > 0)
    {
        //
        // Calculate the visible range
        //
        hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Assuming fixed height to calc index
        //
        *plIndex = lScrollTop / _lMaxHeight;
    }
    else
    {
        *plIndex = 0;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetBottomVisibleOptionIndex()
//
// Synopsis:    Returns the index of the last visible option (+1)
//
// Arguments:   long *plItems - Returns the index
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetBottomVisibleOptionIndex(long *plIndex)
{
    HRESULT                 hr              = S_OK;
    long                    lScrollTop;
    long                    lScrollBottom;

    Assert(plIndex);

    if (_lMaxHeight > 0)
    {
        //
        // Calculate the visible range
        //
        hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
        if (FAILED(hr))
            goto Cleanup;

        //
        // Assuming fixed height to calc index
        //
        *plIndex = lScrollBottom / _lMaxHeight;
    }
    else
    {
        *plIndex = 0;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetFirstSelected()
//
// Synopsis:    Returns the index of the first option that's selected.
//
// Arguments:   long *plItems - Returns the index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetFirstSelected(long *plIndex)
{
    HRESULT                 hr;
    long                    cItems;
    long                    iItem;
    VARIANT_BOOL            bSelected;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pOption        = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(plIndex);
    *plIndex = -1;

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = 0; iItem < cItems; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
        {
            ClearInterface(&pDispatchItem);
            continue;
        }

        hr = pOption->GetSelected(&bSelected);
        if (FAILED(hr))
            goto Cleanup;

        if (bSelected)
        {
            // Found the first selected option
            *plIndex = iItem;
            iItem = cItems; // Causes us to break out
        }

        ClearInterface(&pOption);
        ClearInterface(&pDispatchItem);
    }

Cleanup:
    ReleaseInterface(pOption);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pItems);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::Select(long lIndex)
//
// Synopsis:    Selects the lIndex-th Option.
//              Note: Unlike put_selectedIndex, this method does *not* clear
//              the currently selected option(s),
//
// Arguments:   long lItems - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::Select(long lIndex)
{
    HRESULT             hr;
    IHTMLOptionElement2 *pOption    = NULL;

    hr = GetIndex(lIndex, &pOption);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOption->put_selected(VARIANT_TRUE);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    ReleaseInterface(pOption);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectVisibleIndex()
//
// Synopsis:    Selects the option that's lIndex down from the top
//              visible option.
//
// Arguments:   long lItems - Index of the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectVisibleIndex(long lIndex)
{
    HRESULT                 hr              = S_OK;
    IHTMLOptionElement2     *pOption        = NULL;
    VARIANT_BOOL            bSelected;
    long                    lTopIndex;
    long                    lNewIndex;
    long                    lNumOptions;

    hr = GetNumOptions(&lNumOptions);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetTopVisibleOptionIndex(&lTopIndex);
    if (FAILED(hr))
        goto Cleanup;

    lNewIndex = lTopIndex + lIndex;

    if (lNewIndex >= lNumOptions)
    {
        lNewIndex = lNumOptions - 1;
    }

    hr = GetIndex(lNewIndex, &pOption);
    if (FAILED(hr) || !pOption)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = pOption->get_selected(&bSelected);
    if (FAILED(hr))
        goto Cleanup;

    if (!bSelected)
    {
        hr = OnOptionClicked(lNewIndex, SELECT_FIREEVENT);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pOption);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::PushFocusToExtreme()
//
// Synopsis:    Pushes the focused option to the top or bottom.
//
// Arguments:   BOOL bTop - TRUE to push to the top, FALSE to the bottom
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::PushFocusToExtreme(BOOL bTop)
{
    HRESULT                 hr              = S_OK;
    IHTMLElement            *pElem          = NULL;
    long                    lScrollTop;
    long                    lScrollBottom;
    long                    lScrollHeight;
    long                    lHeight;
    long                    lTop;
    long                    lBottom;
    long                    lNewTop;
    long                    lNewBottom;
    CContextAccess          a(_pSite);

    if (_lFocusIndex < 0)
        goto Cleanup;

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
    if (FAILED(hr))
        goto Cleanup;

    a.Elem2()->get_scrollHeight(&lScrollHeight);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the option's range
    //
    hr = GetIndex(_lFocusIndex, &pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetTop(&lTop);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    lBottom = lTop + lHeight;

    //
    // Realign the scroll range
    //
    if (bTop)
    {
        lNewTop = lTop;
        lNewBottom = lScrollBottom + (lTop - lScrollTop);
    }
    else
    {
        lNewTop = lScrollTop + (lBottom - lScrollBottom);
        lNewBottom = lBottom;
    }

    if (lNewBottom > lScrollHeight)
    {
        lNewTop -= (lNewBottom - lScrollHeight);
        lNewBottom = lScrollHeight;
    }

    if (lNewTop < 0)
    {
        lNewBottom -= lNewTop;
        lNewTop = 0;
    }

    //
    // If there is a change, then change the scroll top
    //
    if (lNewTop != lScrollTop)
    {
        hr = a.Elem2()->put_scrollTop(lNewTop);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::MakeOptionVisible()
//
// Synopsis:    Makes the given option visible.
//
// Arguments:   IPrivateOption *pOption - The option to make visible
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::MakeOptionVisible(IPrivateOption *pOption)
{
    HRESULT                 hr;
    IHTMLElement            *pElem = NULL;
    long                    lScrollTop;
    long                    lScrollBottom;
    long                    lHeight;
    long                    lTop;
    long                    lBottom;
    long                    lNewTop;
    CContextAccess          a(_pSite);

#ifdef SELECT_GETSIZE
    if (SELECT_ISDROPBOX(_fFlavor) || !(_fContentReady && _fAllOptionsSized))
#else
    if (SELECT_ISDROPBOX(_fFlavor))
#endif
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = a.Open(CA_ELEM2);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Calculate the visible range
    //
    hr = GetScrollTopBottom(&lScrollTop, &lScrollBottom);
    if (FAILED(hr))
        goto Cleanup;

    //
    // Get the option's range
    //
    hr = pOption->QueryInterface(IID_IHTMLElement, (void**)&pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetTop(&lTop);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_offsetHeight(&lHeight);
    if (FAILED(hr))
        goto Cleanup;

    lBottom = lTop + lHeight;

    //
    // Make sure the option is not already visible
    //
    if ((lTop < lScrollTop) || (lBottom > lScrollBottom))
    {
        //
        // First, make sure that the option isn't just bigger than the control
        //
        if ((lTop < lScrollTop) && (lBottom > lScrollBottom))
            goto Cleanup;

        //
        // Determine if we're coming from the top or bottom
        //
        if (lTop < lScrollTop)
        {
            // From top
            lNewTop = lTop;
        }
        else
        {
            // From bottom
            lNewTop = lBottom - (lScrollBottom - lScrollTop);
        }

        hr = a.Elem2()->put_scrollTop(lNewTop);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IHTMLOptionElement2 **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IHTMLOptionElement2 **ppOption)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppOption);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IHTMLOptionElement2, (void**)ppOption);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IPrivateOption **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IPrivateOption **ppOption)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppOption);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IPrivateOption, (void**)ppOption);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IHTMLElement **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IHTMLElement **ppElem)
{
    HRESULT     hr;
    IDispatch   *pDispatch = NULL;

    Assert(ppElem);

    hr = GetIndex(lIndex, &pDispatch);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDispatch->QueryInterface(IID_IHTMLElement, (void**)ppElem);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::GetIndex()
//
// Synopsis:    Returns a pointer to the given index.
//
// Arguments:   long lIndex - Index of the option
//              IDispatch **ppOption - Returns a pointer to the option
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::GetIndex(long lIndex, IDispatch **ppOption)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pItems         = NULL;
    CVariant                var, var2;
    CContextAccess          a(_pSite);

    Assert(ppOption);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    V_I4(&var) = lIndex;
    hr = pItems->item(var, var2, ppOption);
    if (FAILED(hr))
        goto Cleanup;

    if (!*ppOption)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pItems);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SelectRange()
//
// Synopsis:    Selects a range of elements.
//              lAnchor is one end of the range. lNew is the new
//              end of the range. lLast is the old end of the range.
//              From these values, we can tell if we're selecting or
//              deselecting.
//
// Arguments:   long lAnchor - Beginning of the range
//              long lLast   - Old end of the range
//              long lNew    - New end of the range
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SelectRange(long lAnchor, long lLast, long lNew)
{
    HRESULT                 hr;
    long                    lIndexStart, lIndexEnd;
    long                    lRangeLast, lRangeNew;
    long                    iItem;
    IHTMLElementCollection  *pItems         = NULL;
    IDispatch               *pDispatchItem  = NULL;
    IPrivateOption          *pOption        = NULL;
    IPrivateOption          *pAnchor        = NULL;
    VARIANT_BOOL            bAnchorHighlight;
    CVariant                var, var2;
    BOOL                    bUndo;
    CContextAccess          a(_pSite);

#if DBG == 1                // For Assert
    long                    cItems;
#endif

    if (lNew == lLast)
    {
        // No change, so exit
        hr = S_OK;
        goto Cleanup;
    }

    if (((lNew < lAnchor) && (lAnchor < lLast)) ||
        ((lNew > lAnchor) && (lAnchor > lLast)))
    {
        //
        // If we flip sides around the anchor,
        // then do one side before the other
        //
        hr = SelectRange(lAnchor, lLast, lAnchor);
        if (FAILED(hr))
            goto Cleanup;

        hr = SelectRange(lAnchor, lAnchor, lNew);

        // Done
        goto Cleanup;
    }

    bUndo = (abs(lNew - lAnchor) < abs(lLast - lAnchor));

    // Skip over the option that does not need to change
    lRangeLast = lLast;
    lRangeNew = lNew;
    if (bUndo)
    {
        if (lLast < lNew)
        {
            lRangeNew--;
        }
        else
        {
            lRangeNew++;
        }
    }
    else
    {
        if (lLast < lNew)
        {
            lRangeLast++;
        }
        else
        {
            lRangeLast--;
        }
    }

    if (lRangeLast < lRangeNew)
    {
        lIndexStart = lRangeLast;
        lIndexEnd = lRangeNew;
    }
    else
    {
        lIndexStart = lRangeNew;
        lIndexEnd = lRangeLast;
    }

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_children((IDispatch**)&pItems);
    if (FAILED(hr))
        goto Cleanup;

#if DBG == 1                // For Assert Check
    hr = pItems->get_length(&cItems);
    if (FAILED(hr))
        goto Cleanup;
#endif

    Assert( (lIndexStart >= 0)      && (lIndexEnd >= 0) && 
            (lIndexStart < cItems)  && (lIndexEnd < cItems) );

    hr = GetIndex(lAnchor, &pAnchor);
    if (FAILED(hr))
        goto Cleanup;

    hr = pAnchor->GetHighlight(&bAnchorHighlight);
    if (FAILED(hr))
        goto Cleanup;

    V_VT(&var) = VT_I4;
    for (iItem = lIndexStart; iItem <= lIndexEnd; iItem++)
    {
        V_I4(&var) = iItem;
        hr = pItems->item(var, var2, &pDispatchItem);
        if (FAILED(hr))
            goto Cleanup;

        hr = pDispatchItem->QueryInterface(IID_IPrivateOption, (void**)&pOption);
        if (FAILED(hr))
            goto Cleanup;

        if (_fDragMode)
        {
            if (bUndo)
            {
                hr = pOption->SetPrevHighlight();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else
            {
                hr = pOption->SetHighlight(bAnchorHighlight);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else
        {
            hr = pOption->SetHighlight(bUndo ? VARIANT_FALSE : VARIANT_TRUE);
            if (FAILED(hr))
                goto Cleanup;
        }

        AdjustChangedRange(iItem);

        ClearInterface(&pDispatchItem);
        ClearInterface(&pOption);
    }

Cleanup:
    ReleaseInterface(pItems);
    ReleaseInterface(pDispatchItem);
    ReleaseInterface(pOption);
    ReleaseInterface(pAnchor);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DropDownSelect()
//
// Synopsis:    Puts the text from the option into the display.
//
// Arguments:   IPrivateOption *pOption - Option to select
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::DropDownSelect(IPrivateOption *pOption)
{
    HRESULT         hr;
    CComBSTR        bstr;
    IHTMLElement    *pOptionElem = NULL;

    if (!_pElemDisplay)
    {
        return S_OK;
    }

    hr = pOption->QueryInterface(IID_IHTMLElement, (void**)&pOptionElem);
    if (FAILED(hr))
        goto Cleanup;

    // Put the text from the option into the display bar
    hr = pOptionElem->get_innerHTML(&bstr);
    if (FAILED(hr))
        goto Cleanup;
    hr = _pElemDisplay->put_innerHTML(bstr);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pOptionElem);
    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TogglePopup()
//
// Synopsis:    Toggles the popup open/closed.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::TogglePopup()
{
    HRESULT         hr;
    VARIANT_BOOL    bOpen;

    Assert(_pPopup);

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (_bPopupOpen == VARIANT_TRUE)
    {
        hr = HidePopup();
        if (FAILED(hr))
            goto Cleanup;

        _bPopupOpen = VARIANT_FALSE;
    }
    else
    {
        hr = ShowPopup();
        if (FAILED(hr))
            goto Cleanup;

        _bPopupOpen = VARIANT_TRUE;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::HidePopup()
//
// Synopsis:    Hides the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::HidePopup()
{
    HRESULT         hr;     
    VARIANT_BOOL    bOpen;

    Assert(_pPopup && _pSelectInPopup );

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (bOpen)
    {
        hr = _pPopup->hide();
        if (FAILED(hr))
            goto Cleanup;

        hr = SetDisplayHighlight(TRUE);
        if (FAILED(hr))
            goto Cleanup;

        hr = RefreshFocusRect();
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ShowPopup()
//
// Synopsis:    Shows the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::ShowPopup()
{
    HRESULT             hr;
    VARIANT_BOOL        bOpen;
    CContextAccess      a(_pSite);
    VARIANT             var;
    IUnknown            *pUnk = NULL;
    long                lHeightSelect;
    CComBSTR            bstrWritingMode(_T(""));
    CComBSTR            bstrHTML;
    long                lX;
    long                lY;
    long                lWidth;

    Assert(_pPopup && _pSelectInPopup);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = SetDisplayHighlight(FALSE);
    if (FAILED(hr))
        goto Cleanup;

    hr = RefreshFocusRect();
    if (FAILED(hr))
        goto Cleanup;

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->QueryInterface(IID_IUnknown, (void **)&pUnk);
    V_VT(&var)      = VT_UNKNOWN;
    V_UNKNOWN(&var) = pUnk;

    hr = a.Elem()->get_offsetHeight(&lHeightSelect);
    if (FAILED(hr))
        goto Cleanup;

    if (_pSelectInPopup)
    {
        if (_fWritingModeTBRL)
        {
            bstrWritingMode = _T("tb-rl");
        }
        hr = _pSelectInPopup->SetWritingMode(bstrWritingMode);
        if (FAILED(hr))
            goto Cleanup;
    }

#ifdef SELECT_GETSIZE
    if (!bOpen)
    {
        long lHeight;
        long lNumOptions;

        hr = GetNumOptions(&lNumOptions);
        if (FAILED(hr))
            goto Cleanup;

        // TODO: Fix SELECT_MAXOPTIONS with correct value
        lHeight = min(SELECT_MAXOPTIONS, lNumOptions);
        lHeight *= _sizeOption.cy;
        lHeight += 2;

        if (_fWritingModeTBRL)
        {   
            hr = a.Elem()->get_offsetWidth(&lHeightSelect);
            if (FAILED(hr))
                goto Cleanup;

            lX = lHeightSelect- lHeight-_sizeOption.cy;
            lY = 0;
            lWidth = lHeight;
            lHeight = _sizeSelect.cx;
        }
        else
        {
            lX = 0;
            lY = lHeightSelect;
            lWidth = _sizeSelect.cx;
        }
        hr = _pPopup->show(lX, lY, lWidth, lHeight, &var);
        if (FAILED(hr))
            goto Cleanup;
    }
#else
    if (!bOpen)
    {
        if (_fWritingModeTBRL)
        {
            lX = lHeightSelect- lHeight-_sizeOption.cy;
            lY = 0;
            lWidth = _lPopupSize.cy;
            lHeight = _lPopupSize.cx;
        }
        else
        {
            lX = o;
            lY = lHeightSelect;
            lWidth = _lPopupSize.cx;
            lHeight = _lPopupSize.cy;
        }
        hr = _pPopup->show(lX, lY, lWidth, lHeight, &var);
        if (FAILED(hr))
            goto Cleanup;
    }
#endif

Cleanup:
 
    ReleaseInterface(pUnk);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnChangeInPopup()
//
// Synopsis:    Called when there is a change in the popup.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnChangeInPopup()
{
    HRESULT hr;
    
    hr = HidePopup();
    if (FAILED(hr))
        goto Cleanup;

    hr = SynchSelWithPopup();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SynchSelWithPopup()
//
// Synopsis:    Synchronizes the selection state between the popup
//              and the select.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SynchSelWithPopup()
{
    HRESULT hr;
    long    lIndex;
    long    lPrevIndex;

    Assert(_pSelectInPopup);

    hr = _pSelectInPopup->GetSelectedIndex(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_selectedIndex(&lPrevIndex);
    if (FAILED(hr))
        goto Cleanup;

    if (lPrevIndex != lIndex)
    {
        //
        // Only make a selection if there's a change
        //

        hr = Select(lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::OnButtonMouseDown()
//
// Synopsis:    Called when the button in the drop control should
//              go down.
//
// Arguments:   CEventObjectAccess *pEvent  Event information
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::OnButtonMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT         hr;
    VARIANT_BOOL    bOpen;

    Assert(_pPopup);

    hr = _pPopup->get_isOpen(&bOpen);
    if (FAILED(hr))
        goto Cleanup;

    if (bOpen == VARIANT_FALSE)
    {
        hr = PressButton(TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::PressButton()
//
// Synopsis:    Makes the button appear up/down.
//
// Arguments:   BOOL bDown  - TRUE for down, FALSE for up
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::PressButton(BOOL bDown)
{
    HRESULT             hr = S_OK;
    CComBSTR            bstr;
    CVariant            var;

    if (bDown)
    {
        // Down border
        bstr = _T("1 inset");

        // Set the padding to make the arrow go down/right
        V_VT(&var) = VT_I4;
        V_I4(&var) = 2;
    }
    else
    {
        // Up border
        bstr = _T("2 outset");

        // Set the padding to make the arrow go back to center
        V_VT(&var) = VT_I4;
        V_I4(&var) = 0;
    }

    hr = _pStyleButton->put_border(bstr);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pStyleButton->put_paddingTop(var);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pStyleButton->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TimerProc()
//
// Synopsis:    Callback for the scrolling timer.
//
// Arguments:   HWND  hwnd      - Window handle owning the timer
//              UINT  uMsg      - Message ID
//              UINT  idEvent   - Timer ID
//              DWORD dwTime    - Time that has passed
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID CALLBACK
CIESelectElement::TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    // If the ID does not match, then don't do anything
    if (idEvent != _iTimerID)
    {
        return;
    }

    if (_pTimerSelect)
    {
        //
        // We have a select to deal with
        //
        _pTimerSelect->HandleDownXY(_ptSavedPoint, _bSavedCtrl);
    }
    else
    {
        //
        // Someone didn't clear us, so we need to cleanup
        //
        if (KillTimer(NULL, _iTimerID))
        {
            _iTimerID = 0;
        }
    }
}
 
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetScrollTimeout()
//
// Synopsis:    Sets the scrolling timer.
//
// Arguments:   POINT pt    - Point where the mouse was
//              BOOL  bCtrl - TRUE if the CTRL key was down
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::SetScrollTimeout(POINT pt, BOOL bCtrl)
{
    if (_iTimerID)
    {
        ClearScrollTimeout();
    }

    _ptSavedPoint = pt;
    _bSavedCtrl = bCtrl;
    _pTimerSelect = this;
    _iTimerID = SetTimer(NULL, 0, SELECT_SCROLLWAIT, CIESelectElement::TimerProc);

    if (!_iTimerID)
    {
        _pTimerSelect = NULL;
        return E_FAIL;
    }
    
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ClearScrollTimeout()
//
// Synopsis:    Clears the scrolling timeout.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIESelectElement::ClearScrollTimeout()
{
    BOOL bSuccess = TRUE;

    if (_iTimerID)
    {
        bSuccess = KillTimer(NULL, _iTimerID);
        _iTimerID = 0;
        _pTimerSelect = NULL;
    }

    return bSuccess ? S_OK : E_FAIL;
}

#ifdef SELECT_TIMERVL
//+------------------------------------------------------------------
//
// Member:      CIESelectElement::InitTimerVLServices()
//
// Synopsis:    Initializes the critical section lock for the timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::InitTimerVLServices()
{
    if (_lTimerVLRef == 0)
    {
        // ISSUE: May happen more than once
        InitializeCriticalSection(&_lockTimerVL);
    }

    // Guaranteed to return 0, when _lTimerVLRef becomes 0
    // Not guaranteed to return _lTimerVLRef when nonzero (in Win95)
    // Guaranteed to return _lTimerVLRef in Win98/NT4
    InterlockedIncrement(&_lTimerVLRef);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::DeInitTimerVLServices()
//
// Synopsis:    Frees the critical section lock.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::DeInitTimerVLServices()
{
    if (InterlockedDecrement(&_lTimerVLRef) == 0)
    {
        DeleteCriticalSection(&_lockTimerVL);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::SetTimerVL()
//
// Synopsis:    Sets the VL timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::SetTimerVL()
{
    _iTimerVL = SetTimer(NULL, 0, SELECT_TIMERVLWAIT, CIESelectElement::TimerVLProc);
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::ClearTimerVL()
//
// Synopsis:    Kills the VL timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::ClearTimerVL()
{
    if (KillTimer(NULL, _iTimerVL))
    {
        _iTimerVL = 0;
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::AddSelectToTimerVLQueue()
//
// Synopsis:    Adds a select to the queue.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID
CIESelectElement::AddSelectToTimerVLQueue(CIESelectElement *pSelect)
{
    struct SELECT_TIMERVL_LINKELEM  *pElem = new struct SELECT_TIMERVL_LINKELEM;
    struct SELECT_TIMERVL_LINKELEM  *pParent;

    if (pElem)
    {
        BOOL bSetTimer;

        pElem->pNext = NULL;
        pElem->pSelect = pSelect;

        InitTimerVLServices();

        __try
        {
            EnterCriticalSection (&_lockTimerVL);

            bSetTimer = (_queueTimerVL == NULL);

            // Add to the queue
            if (_queueTimerVL == NULL)
            {
                _queueTimerVL = pElem;
            }
            else
            {
                pElem->pNext = _queueTimerVL;
                _queueTimerVL = pElem;
            }

            if (bSetTimer)
            {
                SetTimerVL();
            }
        }
        __finally
        {
            // Release ownership of the critical section
            LeaveCriticalSection (&_lockTimerVL);
        }
    }
    else
    {
        Assert(FALSE);
    }
}

//+------------------------------------------------------------------
//
// Member:      CIESelectElement::TimerVLProc()
//
// Synopsis:    Called by the timer.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
VOID CALLBACK
CIESelectElement::TimerVLProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    long    lNumRemoved = 0;
    long    lIndex;
    struct SELECT_TIMERVL_LINKELEM  *pRoot = NULL;
    struct SELECT_TIMERVL_LINKELEM  *pNode;

    if (idEvent != _iTimerVL)
        return;

    __try
    {
        EnterCriticalSection (&_lockTimerVL);

        ClearTimerVL();

        // Empty the queue
        pRoot = _queueTimerVL;
        _queueTimerVL = NULL;

    }
    __finally
    {
        // Release ownership of the critical section
        LeaveCriticalSection (&_lockTimerVL);
    }

    // Go through the nodes we retrieved
    while (pRoot)
    {
        pNode = pRoot;
        pRoot = pRoot->pNext;

        // Init the viewlink
        pNode->pSelect->InitViewLink();
        delete pNode;

        // Dealloc the reference to the timer services
        DeInitTimerVLServices();
    }
}
#endif


//+------------------------------------------------------------------------
//
// CIESelectElement::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink::GetTypeInfoCount
//              CIESelectElement::CEventSink::GetTypeInfo
//              CIESelectElement::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CIESelectElement::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CIESelectElement::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CIESelectElement::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CIESelectElement::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    long            lCookie;
    CComBSTR        bstrEvent;
    BOOL            bRefire = FALSE;

    Assert(_pParent);

    if (!pDispParams || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = eoa.Open(EOA_EVENTOBJ);
        if (FAILED(hr))
            goto Cleanup;

        hr = eoa.EventObj()->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SELECTES_POPUP)
        {
            if (!StrCmpICW(bstrEvent, L"change"))
            {
                hr = _pParent->OnChangeInPopup();
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"keydown"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyDownCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"keyup"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyUpCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"keypress"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnKeyPressedCookie;
            }
       }
        else if (_dwFlags & SELECTES_VIEWLINK)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                hr = _pParent->OnMouseDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;

                lCookie = _pParent->_lOnMouseDownCookie;
                bRefire = TRUE;
            }
            else if (!StrCmpICW(bstrEvent, L"selectstart"))
            {
                hr = _pParent->OnSelectStart(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"contextmenu"))
            {
                hr = _pParent->OnContextMenu(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"beforefocusenter"))
            {
                hr = _pParent->CancelEvent(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnMouseUpCookie;
            }
            else if (!StrCmpICW(bstrEvent, L"click"))
            {
                bRefire = TRUE;
                lCookie = _pParent->_lOnClickCookie;
            }
        }
        else if (_dwFlags & SELECTES_BUTTON)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                hr = _pParent->OnButtonMouseDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if (!StrCmpICW(bstrEvent, L"mouseout") || !StrCmpICW(bstrEvent, L"mouseup"))
            {
                hr = _pParent->PressButton(FALSE);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }
        else if (_dwFlags & SELECTES_INPOPUP)
        {
            // ISSUE: This might not be needed if popup is able to send keystrokes
            if (!StrCmpICW(bstrEvent, L"keydown"))
            {
                hr = _pParent->OnKeyDown(&eoa);
                if (FAILED(hr))
                    goto Cleanup;
            }
        }

        if (bRefire)
        {
            // Cancel bubbling to master
            hr = eoa.EventObj()->put_cancelBubble(VB_TRUE);
            if (FAILED(hr))
                goto Cleanup;

            // refire the event on master
            hr = _pParent->FireEvent(lCookie, NULL, bstrEvent);
            if (FAILED(hr))
                goto Cleanup;
        }

    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CIESelectElement::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CIESelectElement::CEventSink::CEventSink(CIESelectElement *pParent, DWORD dwFlags)
{
    _pParent = pParent;
    _dwFlags = dwFlags;
}

// ========================================================================
// CIESelectElement::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CIESelectElement::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CIESelectElement::CEventSink::AddRef(void)
{
    return ((IElementBehavior*)_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CIESelectElement::CEventSink::Release(void)
{
    return ((IElementBehavior*)_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\slidebar.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\scrllbar.cxx
//
// Contents:    Scrollbar Control
//
// Classes:     CSliderBar
//
// Interfaces:  IScrollBar
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "math.h"

#include "utils.hxx"

#include "utbutton.hxx"
#include "slidebar.hxx"

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

/////////////////////////////////////////////////////////////////////////////
//
// CSliderBar
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CSliderBar::s_propdesc[] = 
{
    {_T("max"), VT_I4, 100},
    {_T("min"), VT_I4, 0},
    {_T("unit"), VT_I4, 1},
    {_T("block"), VT_I4, 10},
    {_T("position"), VT_I4, 0},
    {_T("orientation"), VT_BSTR, 0, _T("horizontal")},

    NULL
};

enum
{
    eMax = 0,
    eMin,
    eUnit,
    eBlock,
    ePosition,
    eOrientation
};

//+------------------------------------------------------------------------
//
//  Members:    CSliderBar::CSliderBar
//              CSliderBar::~CSliderBar
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CSliderBar::CSliderBar()
{
}

CSliderBar::~CSliderBar()
{
    if (_pSinkBlockInc)
    {
        delete _pSinkBlockInc;
    }
    if (_pSinkBlockDec)
    {
        delete _pSinkBlockDec;
    }
    if (_pSinkSlider)
    {
        delete _pSinkSlider;
    }
    if (_pSinkDelayTimer)
    {
        delete _pSinkDelayTimer;
    }
    if (_pSinkRepeatTimer)
    {
        delete _pSinkRepeatTimer;
    }
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::Init()
//
// Synopsis:    Set up the scroll bar's events
//
// Arguments:   None
//
// Returns:     Success if the control is setup correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::Init()
{
    HRESULT hr = S_OK;
    CContextAccess  a(_pSite);

    CheckResult( a.Open(CA_DEFAULTS | CA_SITEOM | CA_DEFSTYLE));

    // Setup overflow

    CheckResult( a.DefStyle()->put_overflow(CComBSTR("hidden")));

    //
    // Register the scrollbar name
    //

    CheckResult( a.SiteOM()->RegisterName(_T("sliderbar")));

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONKEYDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONPROPERTYCHANGE, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));
    CheckResult( AttachEvent(EVENT_ONFOCUS, &a));
    CheckResult( AttachEvent(EVENT_ONBLUR, &a));

    // We want to be able to receive keyboard focus

    CheckResult( a.Defaults()->put_tabStop(VB_TRUE));
    CheckResult( a.Defaults()->put_viewMasterTab(VB_TRUE));

    //
    // Register the sliderbar's events
    //

	CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onscroll"), &_lOnScrollCookie));
    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onchange"), &_lOnChangeCookie));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::Detach()
{
    _pSliderThumb->Unload();

    ReleaseInterface(_pBlockInc);
    ReleaseInterface(_pBlockDec);
    ReleaseInterface(_pSliderBar);
    ReleaseInterface(_pTrack);
    ReleaseInterface(_pContainer);

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnContentReady()
//
// Synopsis:    Called when the HTML content for the control is ready.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnContentReady()
{
    HRESULT hr = S_OK;

    //
    // Cache the properties
    //

    CheckResult( ReadProperties());

    //
    // Create the button
    //

    CheckResult( BuildContainer());
    CheckResult( BuildSliderBar());
    CheckResult( BuildSliderTrack());
    CheckResult( BuildBlockDecrementer());
    CheckResult( BuildSliderThumb());
    CheckResult( BuildBlockIncrementer());

    //
    // Calculate dimensions and layout correctly
    //

    CheckResult( Layout());
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnPropertyChange()
//
// Synopsis:    Called when the scrollbar property changes.  Gives us the 
//              chance to redraw if the scrollbar is changed dynamically
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnPropertyChange(CEventObjectAccess *pEvent, BSTR propertyName)
{
    HRESULT hr = S_OK;

    CheckResult( Layout());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnMouseDown()
//
// Synopsis:    Called to handle 'onmousedown' event; 
//              Sets focus on element triggering an onfocus event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2))

    CheckResult( a.Elem2()->focus());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnMouseUp()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnKeyDown()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long                lKeyCode;

    CheckResult( pEvent->GetKeyCode(&lKeyCode));

    switch (lKeyCode)
    {
        case VK_END:            
        {
            _lCurrentPosition = _lMaxPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_HOME:
        {
            _lCurrentPosition = _lMinPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_NEXT:
        {
            _lCurIncrement = _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_PRIOR:
        {
            _lCurIncrement = - _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_DOWN:
        case VK_RIGHT:
        {
            _lCurIncrement = _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
        
        case VK_UP:
        case VK_LEFT:
        {
            _lCurIncrement = - _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnSelectStart
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnFocus
//
// Synopsis:    Called to handel 'onfocus' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnFocus(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT
CSliderBar::GetFocusRect(RECT * pRect)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    a.Open(CA_STYLE);

    CheckResult( a.Style()->get_pixelWidth(&pRect->right));
    CheckResult( a.Style()->get_pixelHeight(&pRect->bottom));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnBlur
//
// Synopsis:    Called to handel 'onblur' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildContainer()
//
// Synopsis:    Builds the scrollbar container DIV.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildContainer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;

    CComPtr<IDispatch> pDispDocLink;
    CComPtr<IHTMLDocument2> pDocLink;

    CComBSTR    bstr;

    CContextAccess a(_pSite);
    
    hr = a.Open( CA_ELEM | CA_STYLE | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelWidth(&_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelHeight(&_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetHTMLDocument(_pSite, &pDoc);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->createElement(CComBSTR("div"), &_pContainer);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pContainer->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelWidth(_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelHeight(_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_backgroundColor(CComVariant("transparent"));
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_overflow(CComBSTR("hidden"));
    if (FAILED(hr))
        goto Cleanup;


    //
    // Set up the view link
    //

    CheckResult( _pContainer->get_document(&pDispDocLink));
    CheckResult( pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**) &pDocLink));
    CheckResult( a.Defaults()->putref_viewLink(pDocLink));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::DoIncrement()
//
// Synopsis:    Increments current position by the current increment amount
//              which is set by the various unit or block incrementers.
//              Fires and event, and sets the thumb position to the new value.
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::DoIncrement()
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition += _lCurIncrement;
    
    //
    //  Don't let it go below the mininum
    //

    if(_lCurrentPosition < _lMinPosition)
    {
        _lCurrentPosition = _lMinPosition;
    }

    //
    //  Or above the maximum
    //

    else if(_lCurrentPosition > _lMaxPosition)
    {
        _lCurrentPosition = _lMaxPosition;
    }

    //
    //  Move the thumb
    //

    CheckResult( SetThumbPosition( _lCurrentPosition ));

    //
    //  If position has changed, fire an event...
    //

    if(_lOldPosition != _lCurrentPosition) 
    {

        CheckResult( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")) );

    }

Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::MouseMoveCallback()
//
// Synopsis:    Performs a sanity check on the proposed coordinate.
//              Called by the slider thumb when an attempt is made to move it
//
// Arguments:   None
//
// Returns:     true if button can be moved, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CSliderBar::MouseMoveCallback(CUtilityButton *pButton, long &x, long &y)
{
    HRESULT hr = S_OK;

    //
    // Can't extend past slider bar
    //

    long max = TrackLength() - ThumbLength();

    if(_eoOrientation == Horizontal) 
    {

        if(x < 0)
            x = 0;

        if(x > max)
            x = max;

        //
        // Snap to grid
        //

        x = (long) (floor ( (x / PixelsPerUnit()) + 0.5) * PixelsPerUnit());

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( x ));
    }

    else 
    {

        if(y < 0)
            y = 0;

        if(y > max)
            y = max;

        //
        // Snap to grid
        //

        y = (long) (floor ( (y / PixelsPerUnit()) + 0.5) * PixelsPerUnit());

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( y ));
    }


    //
    // This stuff is for performance conciderations, with three divs making up the slider
    // (track, thumb, track), moving that thumb and continuously resizng the track elements 
    // caused ragged movement.  Instead, we won't display them once the thumb starts to move, and
    // turn them back on when the thumb stops.
    //

    if(! pButton->IsMoving()) 
    {
        CheckResult( SetBlockMoverPositions());

        CheckResult( BlockDisplay(_pBlockDec, true));
        CheckResult( BlockDisplay(_pBlockInc, true));
    }
    else 
    {
        CheckResult( BlockDisplay(_pBlockDec, false));
        CheckResult( BlockDisplay(_pBlockInc, false));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::StartDelayTimer()
//
// Synopsis:    Sets up the Delay timeout and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::StartDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    //  Create a new timer sink if one doesn't exist yet
    //

    if(! _pSinkDelayTimer) 
    {

        _pSinkDelayTimer = new CEventSink(this, NULL, SLIDER_DELAY_TIMER);
        if (!_pSinkDelayTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    //
    // Setup the Delay Timer
    //

    vDispatch = _pSinkDelayTimer;
    _pSinkDelayTimer->AddRef();

    Assert( _lDelayTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setTimeout( &vDispatch, GetDelayRate(), &vLanguage, &_lDelayTimerId ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearDelayTimer()
//
// Synopsis:    Stops the delay timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::ClearDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    //
    //  Clear the delay timer
    //

    if(_lDelayTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearTimeout( _lDelayTimerId ));

        _lDelayTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnDelay()
//
// Synopsis:    Called when the Delay timeout fires.  Clears the timer,
//              increments, and then starts the Repeat interval timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::OnDelay()
{
    HRESULT hr = S_OK;

    //
    //  Clear the delay timer; start the repeat timer
    //

    CheckResult( ClearDelayTimer());
    CheckResult( DoIncrement());
    CheckResult( StartRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::StartRepeatTimer()
//
// Synopsis:    Sets up the repeat timer and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::StartRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    // Setup the Timer interval
    //

    if (! _pSinkRepeatTimer )
    {

        _pSinkRepeatTimer = new CEventSink(this, NULL, SLIDER_REPEAT_TIMER);
        if (!_pSinkRepeatTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    vDispatch = _pSinkRepeatTimer;
    _pSinkRepeatTimer->AddRef();

    Assert( _lRepeatTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setInterval( &vDispatch, GetRepeatRate(), &vLanguage, &_lRepeatTimerId ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearRepeatTimer()
//
// Synopsis:    Stops the repeat timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::ClearRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    if(_lRepeatTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearInterval( _lRepeatTimerId ));

        _lRepeatTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::OnRepeat()
//
// Synopsis:    Fires the incrementer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::OnRepeat()
{
    HRESULT hr = S_OK;

    CheckResult( DoIncrement());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::ClearTimers()
//
// Synopsis:    Stops any active timers.  Effectively, this stops repeating actions
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::ClearTimers()
{
    HRESULT hr = S_OK;

    CheckResult( ClearDelayTimer());
    CheckResult( ClearRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveStartInc()
//
// Synopsis:    Start the block increment process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveStartInc(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockInc;

    CheckResult( _pBlockInc->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockIncrement());
    CheckResult( BlockHighlight(_pBlockInc, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveStartDec()
//
// Synopsis:    Start the block decrement process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT 
CSliderBar::BlockMoveStartDec(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockDec;

    CheckResult( _pBlockDec->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockDecrement());
    CheckResult( BlockHighlight(_pBlockDec, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveSuspend()
//
// Synopsis:    Used to suspend and restart the repeater timers.  
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveSuspend(CEventObjectAccess *pEvent, IHTMLElement *pTrack)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pSrcElement;

    pEvent->Open(EOA_EVENTOBJ);

    if( _moving ) 
    {
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(! IsSameObject( pSrcElement, pTrack) )
        {
            _suspended = true;

            CheckResult( BlockHighlight(pTrack, false));
            CheckResult( ClearRepeatTimer());
        }

        else if( _suspended ) 
        {
            _suspended = false;
    
            CheckResult( BlockHighlight(pTrack, true));
            CheckResult( StartRepeatTimer());

        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveResume()
//
// Synopsis:    Resumes the repeating move functionality by restarting the timer
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveResume(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if( _moving ) 
    {
        CheckResult( StartRepeatTimer());
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockMoveEnd()
//
// Synopsis:    Shuts down the block move process buy dehighlighting the area
//              and stopping any timers
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveEnd(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    if(_pCurBlock) 
    {
        CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
        CheckResult( pElement2->releaseCapture());
    }

    CheckResult( ClearTimers());
    CheckResult( BlockHighlight( _pBlockInc, false));
    CheckResult( BlockHighlight( _pBlockDec, false));

    _moving = false;
    _suspended = false;
    _pCurBlock = NULL;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockCheck()
//
// Synopsis:    Checks to see if the mouse coordinates of the pEvent object
//              fall withing the bounding box of the current block move element.
//              If not, the repeat action is halted buy clearing the timers
//
// Arguments:   CEventObjectAccess *pEvent
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockMoveCheck(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    POINT ptClient;
    CComPtr<IHTMLRect> pRect;
    CComPtr<IHTMLElement2> pElement2;

    long top, left, right, bottom;

    if(! _pCurBlock)
        return S_OK;

    CheckResult( pEvent->GetWindowCoordinates(&ptClient));

    CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->getBoundingClientRect(&pRect));

    CheckResult( pRect->get_left(&left));
    CheckResult( pRect->get_top(&top));
    CheckResult( pRect->get_right(&right));
    CheckResult( pRect->get_bottom(&bottom));

    if(! (((ptClient.x >= left) && (ptClient.x <= right)) && 
          ((ptClient.y >= top)  && (ptClient.y <= bottom)))) 
    {
        CheckResult( BlockHighlight(_pCurBlock, false));
        CheckResult( ClearTimers());
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockDisplay()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CSliderBar::BlockDisplay(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR bstr;

    bstr       = flag ? _T("inline") : _T("none");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_display(bstr));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockHighlight()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT   
CSliderBar::BlockHighlight(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR color;

    color       = flag ? _T("transparent") : _T("transparent");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant(color)));


Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockIncrement()
//
// Synopsis:    Increments the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::BlockIncrement() 
{
    HRESULT hr = S_OK;

    _lCurIncrement = _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::BlockDecrement()
//
// Synopsis:    Decrements the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::BlockDecrement()
{
    HRESULT hr = S_OK;

    _lCurIncrement = - _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetThumbPosition()
//
// Synopsis:    Set the thumb position to the location determined by the 
//              unit
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::SetThumbPosition(long position)
{
    HRESULT hr = S_OK;

    double  pixPerUnit;

    //
    //  Update the OM
    //

    GetProps()[ePosition].Set(position); 

    //
    //  Calculate the offset of the thumb
    //

    _sliderOffset = NearestLong( (PixelsPerUnit() * (double) (position - _lMinPosition)));

    if ( _eoOrientation == Horizontal ) 
    {

        CheckResult( _pSliderThumb->SetHorizontalOffset(_sliderOffset));

    }
    else 
    {

        CheckResult( _pSliderThumb->SetVerticalOffset(_sliderOffset));

    }

    CheckResult( SetBlockMoverPositions());

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::SyncThumbPosition()
//
// Synopsis:    Essentially the inverse of SetThumbPositoin.  This function
//              sets the _lCurrentPosition from the thumb's location within 
//              the slider bar.
//
// Arguments:   x, y coordinates of thumb (relative to slider bar)
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CSliderBar::SyncThumbPosition(long pixels)
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition   = ((long) (pixels / PixelsPerUnit())) + _lMinPosition;
    _sliderOffset       = pixels;

    if(_lOldPosition != _lCurrentPosition)
    {
        CheckResult ( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")));
        CheckResult ( FireEvent( _lOnScrollCookie, NULL, CComBSTR("scroll")));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetBlockMoverPositions()
//
// Synopsis:    Sets the position of the page move zone based on slider thumb
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::SetBlockMoverPositions()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pIncStyle, pDecStyle;

    //
    //  Calculate dimensions of regions around the slider thumb
    //

    long decPosition  = 0L;
    long decLength    = _sliderOffset;

    long incPosition  = ThumbLength() + _sliderOffset;
    long incLength    = TrackLength() - ThumbLength() - _sliderOffset;

    CheckResult( _pBlockInc->get_style(&pIncStyle));
    CheckResult( _pBlockDec->get_style(&pDecStyle));

    if ( _eoOrientation == Horizontal ) 
    {
        CheckResult( pDecStyle->put_pixelLeft(decPosition));
        CheckResult( pDecStyle->put_pixelWidth(decLength));

        CheckResult( pIncStyle->put_pixelLeft(incPosition));
        CheckResult( pIncStyle->put_pixelWidth(incLength));
    }
    else 
    {
        CheckResult( pDecStyle->put_pixelTop(decPosition));
        CheckResult( pDecStyle->put_pixelHeight(decLength));

        CheckResult( pIncStyle->put_pixelTop(incPosition));
        CheckResult( pIncStyle->put_pixelHeight(incLength));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildSliderThumb()
//
// Synopsis:    Builds the slider thumb button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildSliderThumb()
{
    HRESULT hr = S_OK;
    CComVariant faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned freedom = (_eoOrientation == Vertical) ? BUTTON_MOVEABLE_Y : BUTTON_MOVEABLE_X;
    
    CheckResult( CUtilityButton::Create(this, _pSliderBar, &_pSliderThumb));

    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pSliderThumb->SetAbilities( freedom ));

    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->Set3DLightColor( v3dLightColor ));
    CheckResult( _pSliderThumb->SetHighlightColor( highlightColor ));
    CheckResult( _pSliderThumb->SetShadowColor( shadowColor ));
    CheckResult( _pSliderThumb->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pSliderThumb->SetMovedCallback((PFN_MOVED) MouseMoveCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildSliderBar()
//
// Synopsis:    Builds the slider bar which will contain a slider thumb
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::BuildSliderBar()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComBSTR    bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pSliderBar));

    CheckResult( _pSliderBar->get_style(&pStyle));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( AppendChild(_pContainer, _pSliderBar));

    _pSinkSlider = new CEventSink(this, _pSliderBar, SLIDER_SLIDER);
    if (!_pSinkSlider)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

Cleanup:

    return hr;
}



HRESULT
CSliderBar::BuildSliderTrack()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pTrack));
    CheckResult( _pTrack->get_style(&pStyle));
    
    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));
    
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( pStyle->put_border(CComBSTR("2px inset")));

    CheckResult( AppendChild(_pSliderBar, _pTrack));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildBlockIncrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page incrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------


HRESULT
CSliderBar::BuildBlockIncrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockInc));

    CheckResult( _pBlockInc->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant("transparent")));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockInc));


    _pSinkBlockInc = new CEventSink(this, _pBlockInc, SLIDER_PAGEINC);
    if (!_pSinkBlockInc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::BuildBlockDecrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page decrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------

HRESULT
CSliderBar::BuildBlockDecrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;
    CComBSTR  bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockDec));

    CheckResult( _pBlockDec->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(CComVariant("transparent")));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockDec));


    _pSinkBlockDec = new CEventSink(this, _pBlockDec, SLIDER_PAGEDEC);
    if (!_pSinkBlockDec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CSliderBar::CalcConstituentDimensions()
//
// Synopsis:    Determins the pixel dimensions of all controls that make up the scrollbar
//
// Arguments:   None
//
// Returns:     S_OK if they can be calculated
//
//-------------------------------------------------------------------



HRESULT 
CSliderBar::CalcConstituentDimensions()
{
    HRESULT hr = S_OK;

    long  totalSize;

    if (_eoOrientation == Horizontal) 
    {
        _lLength     = _width;
        _lWidth      = _height;
    }

    else if (_eoOrientation == Vertical) 
    {
        _lLength     = _height;
        _lWidth      = _width;
    }

    else 
    {
        Assert( false ); // can't happen
    }

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::SetConstituentDimensions()
//
// Synopsis:    Sets the dimensions of the controls
//
// Arguments:   None
//
// Returns:     S_OK if they can be set
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::SetConstituentDimensions()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSliderBar);
    CContextAccess i(_pBlockInc);
    CContextAccess d(_pBlockDec);
    CContextAccess t(_pTrack);

    CheckResult( a.Open( CA_STYLE ));
    CheckResult( i.Open( CA_STYLE ));
    CheckResult( d.Open( CA_STYLE ));
    CheckResult( t.Open( CA_STYLE ));

    if(_eoOrientation == Horizontal)
    {
        CheckResult( a.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( a.Style()->put_pixelWidth( TrackLength() ));

        CheckResult( i.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( i.Style()->put_pixelWidth( ThumbWidth() ));

        CheckResult( d.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( d.Style()->put_pixelWidth( ThumbWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbWidth() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbLength() ));

        CheckResult( t.Style()->put_pixelTop( TrackOffset() ));
        CheckResult( t.Style()->put_pixelHeight( TrackWidth() ));
        CheckResult( t.Style()->put_pixelWidth( TrackLength() ));
    }
    else 
    {
        CheckResult( a.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( a.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( i.Style()->put_pixelHeight( ThumbWidth() ));
        CheckResult( i.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( d.Style()->put_pixelHeight( ThumbWidth() ));
        CheckResult( d.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbLength() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbWidth() ));

        CheckResult( t.Style()->put_pixelLeft( TrackOffset() ));
        CheckResult( t.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( t.Style()->put_pixelWidth( TrackWidth() ));
    }

    CheckResult( SetThumbPosition( _lCurrentPosition ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CSliderBar::ReadProperties()
//
// Synopsis:    Reads in property values for later calculations
//
// Arguments:   None
//
// Returns:     S_OK if they can be read
//
//-------------------------------------------------------------------



HRESULT 
CSliderBar::ReadProperties()
{
    HRESULT hr = S_OK;
    BSTR orientation;

    CheckResult( get_min(&_lMinPosition));
    CheckResult( get_max(&_lMaxPosition));
    CheckResult( get_position(&_lCurrentPosition));
    CheckResult( get_unit(&_lUnitIncrement));
    CheckResult( get_block(&_lBlockIncrement));

    CheckResult( get_orientation(&orientation));

    _eoOrientation = _wcsicmp(orientation, _T("vertical")) == 0 ? Vertical : Horizontal;

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CSliderBar::Layout()
//
// Synopsis:    Laysout the scrollbar by calculating dimensions
//
// Arguments:   None
//
// Returns:     S_OK if scrollbar can be layed-out
//
//-------------------------------------------------------------------



HRESULT
CSliderBar::Layout()
{
    HRESULT hr = S_OK;

    CheckResult( CalcConstituentDimensions());
    CheckResult( SetConstituentDimensions());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
//
// Synopsis:    Scrollbar Property interigators
//
//
//-------------------------------------------------------------------




/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_min(long * pv)
{
    return GetProps()[eMin].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_min(long v)
{
    return GetProps()[eMin].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_max(long * pv)
{
    return GetProps()[eMax].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_max(long v)
{
    return GetProps()[eMax].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_position(long * pv)
{
    return GetProps()[ePosition].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_position(long v)
{
    return SetThumbPosition( v ); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_unit(long * pv)
{
    return GetProps()[eUnit].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_unit(long v)
{
    return GetProps()[eUnit].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_block(long * pv)
{
    return GetProps()[eBlock].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_block(long v)
{
    return GetProps()[eBlock].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::get_orientation(BSTR * pv)
{
    return GetProps()[eOrientation].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::put_orientation(BSTR v)
{
    return GetProps()[eOrientation].Set(v); 
}





/////////////////////////////////////////////////////////////////////////////

HRESULT
CSliderBar::GetScrollbarColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CVariant color;
    CComVariant defaultColor("scrollbar");

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_STYLE3));
    CheckResult( a.Style3()->get_scrollbarBaseColor ( &color ));

    if(color.IsEmpty() || ((V_VT(&color) == VT_BSTR) && (V_BSTR(&color) == NULL)) ) 
    {   
        return ::VariantCopy(pv, &defaultColor);
    }
    else 
    {
        return ::VariantCopy(pv, &color);
    }

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetFaceColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarFaceColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetArrowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarArrowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::Get3DLightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbar3dLightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarShadowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetHighlightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarHighlightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CSliderBar::GetDarkShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarDarkShadowColor( pv));

Cleanup:

    return hr;
}





HRESULT
CSliderBar::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;

    CheckResult( pDoc->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}




HRESULT
CSliderBar::AttachEventToSink(IHTMLElement *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;
    CComPtr<IHTMLElement2> pElem2;

    CheckResult( pElem->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));
    CheckResult( pElem2->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}



//+------------------------------------------------------------------------
//
// CSliderBar::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink::GetTypeInfoCount
//              CSliderBar::CEventSink::GetTypeInfo
//              CSliderBar::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CSliderBar::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSliderBar::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSliderBar::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CSliderBar::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    IHTMLEventObj   *pEventObj  = NULL;
    CComBSTR        bstrOn;
    CComBSTR        bstrEvent;

    Assert(_pParent);

    if (!pDispParams) // || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->cArgs == 0) 
    {
        if (_dwFlags & SLIDER_DELAY_TIMER)
        {
            CheckResult( _pParent->OnDelay() );
        }
        else if (_dwFlags & SLIDER_REPEAT_TIMER)
        {
            CheckResult( _pParent->OnRepeat() );
        }
    }

    else if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pEventObj);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEventObj->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SLIDER_PAGEDEC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartDec(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
        }
 
        else if (_dwFlags & SLIDER_PAGEINC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartInc(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
        }

        else if (_dwFlags & SLIDER_SLIDER)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->OnMouseDown(&eoa));
            }
        }
    }

Cleanup:

    ReleaseInterface(pEventObj);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSliderBar::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CSliderBar::CEventSink::CEventSink(CSliderBar *pParent, IHTMLElement *pElement, DWORD dwFlags)
{
    _pParent  = pParent;
    _pElement = pElement;
    _dwFlags  = dwFlags;
}

// ========================================================================
// CSliderBar::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CSliderBar::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSliderBar::CEventSink::AddRef(void)
{
    return ((IElementBehavior*) _pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CSliderBar::CEventSink::Release(void)
{
    return ((IElementBehavior*) _pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\spinbttn.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "spinbttn.hxx"


/////////////////////////////////////////////////////////////////////////////
//
// CSpinButton
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CSpinButton::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    eValue = 0
};

/////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Members:    CSpinButton::CSpinButton
//              CSpinButton::~CSpinButton
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CSpinButton::CSpinButton()
{
    int i;

    m_pHTMLPopup    = 0;
    m_pSink         = 0;
    _pPrimaryMarkup = 0;

    _pSinkBody     = 0;

    for (i = 0; i < 2; i++)
    {
        _apSinkElem[i] = 0;
    }
}

CSpinButton::~CSpinButton()
{
    int i;

    if (m_pSink)
        delete m_pSink;

    if (_pSinkBody)
    {
        delete _pSinkBody;
    }

    for (i = 0; i < 2; i++)
    {
        if (_apSinkElem[i])
        {
            delete _apSinkElem[i];
        }
    }
}

HRESULT
CSpinButton::Detach()
{
    if (_pPrimaryMarkup)
    {
        _pPrimaryMarkup->Release();
    }
    if (m_pHTMLPopup)
        m_pHTMLPopup->Release();

    return S_OK;
}

HRESULT
CSpinButton::Init()
{
    HRESULT         hr          = S_OK;
    BSTR            bstrEvent   = NULL;
    VARIANT_BOOL    vSuccess    = VARIANT_FALSE;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2);
    if (hr)
        goto Cleanup;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);

    if (!m_pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // we want to sink a few events.
    //

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    a.Elem2()->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }


Cleanup:
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CSpinButton::ProcOnClick (CEventSink *pSink)
{
    HRESULT hr = S_OK;
    long    lElemLeft, lElemTop, lElemWidth, lElemHeight;

    IHTMLDocument    *pDoc = NULL;

    IMarkupServices  *pMarkupSrv = NULL;
    IMarkupPointer   *pMarkupPStart = NULL;
    IMarkupPointer   *pMarkupPEnd = NULL;
    IHTMLElement     *pHtml = NULL;
    IHTMLElement     *pBody = NULL;
    IHTMLElement     *pElem = NULL;
    IHTMLElement2    *pElem2 = NULL;
    BSTR              bstrEvent   = NULL;
    VARIANT_BOOL      vSuccess    = VARIANT_FALSE;
    IDispatch        *pDocMain = NULL;
    IOleWindow       *pIOleWnd = NULL;
    HWND              hwndMain;
    RECT              rcClient;

    CContextAccess    a(_pSite);

    hr = a.Open(CA_ELEM);
    if (hr)
        goto Cleanup;

    // VARIANT         var;

    // var.vt == VT_EMPTY;


    if (pSink != m_pSink)
    {
        Assert(m_pHTMLPopup);
        if (pSink == _apSinkElem[0])
        {
            a.Elem()->put_innerText(_T("test1"));
        }
        else
        {
            a.Elem()->put_innerText(_T("test2"));
        }
        m_pHTMLPopup->hide();
        return hr;
    }

    // ISSUE: hr?
    a.Elem()->get_offsetLeft(&lElemLeft);
    a.Elem()->get_offsetTop(&lElemTop);
    a.Elem()->get_offsetWidth(&lElemWidth);
    a.Elem()->get_offsetHeight(&lElemHeight);

    // get the current main doc window location

    // ISSUE: hr?
    a.Elem()->get_document(&pDocMain);

    // get the oleWindow
    hr = pDocMain->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd);

    if (FAILED(hr))
        goto Cleanup;

    pDocMain->Release();

    // this window can be cached
    hr = pIOleWnd->GetWindow(&hwndMain);
    hr = S_OK;

    GetWindowRect(hwndMain, &rcClient);

    lElemTop    = lElemTop + lElemHeight + rcClient.top;
    lElemLeft   = lElemLeft + rcClient.left;

    pIOleWnd->Release();

    if (m_pHTMLPopup)
    {

        //
        // we have the popup
        // just make sure it shows up
        // show it modal
        //

        /*
        hr = m_pHTMLPopup->show(a.Elem(),
                                lElemLeft, lElemTop,
                                lElemWidth, 100,
                                VARIANT_TRUE);
        */

        return hr;
    }

    //
    // create a popup window
    // if there is no window yet
    //

    hr = CoCreateInstance(CLSID_HTMLPopup,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IHTMLPopup,
                              (void **) &m_pHTMLPopup);

    if (FAILED(hr))
        return hr;

    //
    // create elements in the popup doc
    //

    // hr = m_pHTMLPopup->getDoc(&pDoc);
    hr = m_pHTMLPopup->get_document(&pDoc);

    if (FAILED(hr))
        goto Cleanup;

    //
    // get the markup services interface from the doc
    // so that we can construct a markup tree
    //


    hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pMarkupSrv);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IMarkupContainer, (void **)&_pPrimaryMarkup);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPStart->MoveToContainer(_pPrimaryMarkup, TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPEnd->MoveToContainer(_pPrimaryMarkup, FALSE);
    if (FAILED(hr))
        goto Cleanup;

#define METHOD1 1

//
//  ISSUE: METHOD 2 crashes in CHtmInfo::Init
//

#ifdef  METHOD2
    hr = pMarkupSrv->ParseString(_T("<HTML><BODY><INPUT></BODY></HTML>"),
                                0,
                                &_pPrimaryMarkup, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
#endif

    //
    //  this is the prefered method of creating the content of the popup
    //

#ifdef  METHOD1
    hr = pMarkupSrv->CreateElement(TAGID_HTML, 0, &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pHtml, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement(TAGID_BODY,
                                   _T("style='border:solid 1;overflow:hidden'"),
                                   &pBody);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pHtml, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pHtml, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pBody, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=checkbox value='text1' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pBody, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd);
    if (FAILED(hr))
        goto Cleanup;

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[0] = new CEventSink (this);

    if (!_apSinkElem[0])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[0], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ReleaseInterface(pElem2);
    pElem2 = NULL;
    ReleaseInterface(pElem);
    pElem = NULL;


    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=button value='text2' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[1] = new CEventSink (this);

    if (!_apSinkElem[1])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[1], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    //
    // position the window just under the element
    // not supported due to a pdlparser problem
    //

#ifdef  METHOD3
    var.vt = VT_BSTR;
    var.bstrVal = _T("file://c:\\toto.htm");
#endif

    /*
    hr = m_pHTMLPopup->show(a.Elem(),
                            lElemLeft, lElemTop,
                            lElemWidth, 100,
                            VARIANT_TRUE);

    if (FAILED(hr))
        goto Cleanup;
    */

Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    ReleaseInterface(pElem2);
    ReleaseInterface(pElem);
    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
    ReleaseInterface(pBody);
    ReleaseInterface(pHtml);

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink::GetTypeInfoCount
//              CSpinButton::CEventSink::GetTypeInfo
//              CSpinButton::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CSpinButton::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSpinButton::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CSpinButton::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CSpinButton::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj,
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                {
                    hr = m_pParent->ProcOnClick(this);
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSpinButton::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CSpinButton::CEventSink::CEventSink (CSpinButton * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP
CSpinButton::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSpinButton::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CSpinButton::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\utbutton.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\utbutton.cxx
//
// Contents:    Utility Button
//
// Classes:     CUtilityButton
//
// Interfaces:  IUtilityButton
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "utbutton.hxx"


#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

//
//  Not used, but currently required by CBaseCtl...
//

const CBaseCtl::PROPDESC CUtilityButton::s_propdesc[] = 
{
    {_T("vestigial"), VT_BSTR},
    NULL
};

/////////////////////////////////////////////////////////////////////////////
//
// CUtilityButton
//
//  
// Synopsis:    Factory create method.  CUtilityButtons constructor is protected so that this technique should
//              be used to properly initialize the button
//
// Arguments:   Owner control, owner html element, out paramter is the created button
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CUtilityButton::Create(CBaseCtl *pOwnerCtl, IHTMLElement *pOwner, CComObject<CUtilityButton> ** ppButton)
{
    HRESULT hr = S_OK;

    CComObject<CUtilityButton> *pButton;

    CComObject<CUtilityButton>::CreateInstance(&pButton);
    if ( pButton == NULL )
        return NULL;

    hr = pButton->Init(pOwnerCtl, pOwner);
    if(FAILED(hr))
        goto Cleanup;

    *ppButton = pButton;

    return S_OK;

Cleanup:

    if(pButton)
        delete pButton;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Members:    CUtilityButton::CUtilityButton
//              CUtilityButton::~CUtilityButton
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CUtilityButton::CUtilityButton()
{
    _tx = 0;
    _ty = 0;

    _moving = false;
    _pressing = false;
    _raised = true;
    _abilities = 0;

    _pStyle = NULL;
    _pOwner = NULL;
    _pElement = NULL;

}

CUtilityButton::~CUtilityButton()
{
    ReleaseInterface(_pStyle);
    ReleaseInterface(_pFaceStyle);
    ReleaseInterface(_pOwner);
    ReleaseInterface(_pElement);
    ReleaseInterface(_pFace);
    ReleaseInterface(_pArrow);
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::Init
//
// Synopsis:    Called by factory method during initialization
//
// Arguments:   Owner control, containing html element
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::Init(CBaseCtl *pOwnerCtl, IHTMLElement *pOwner)
{
    HRESULT hr = S_OK;

    _pOwnerCtl = pOwnerCtl;

    _pOwner = pOwner;
    _pOwner->AddRef();

    CheckResult( BuildButton());
    CheckResult( RegisterEvents());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::RegisterEvents()
//
// Synopsis:    Signs up the button for events its interested in
//
// Arguments:   None
//
// Returns:     Non-S_OK on error
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::RegisterEvents()
{
    HRESULT hr = S_OK;
    
    CContextAccess  a(_pElement);

    a.Open(CA_ELEM);

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEMOVE, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEOUT, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEOVER, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::Unload()
//
// Synopsis:    Called to break down connection points.  This is necessary
//              to overcome a problem with circular reference and should be removed
//              when that is fixed.
//
// Arguments:   Names of changes property
//
// Returns:     Non-S_OK on error
//
//-------------------------------------------------------------------

HRESULT  
CUtilityButton::Unload()
{
    HRESULT hr = S_OK;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    if (_fElementEventSinkConnected)
    {
        CheckResult( _pElement->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC));
        CheckResult( pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP));
        CheckResult( pCP->Unadvise(_dwCookie));

        _fElementEventSinkConnected = FALSE;
    }

Cleanup:

    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseDown()
//
// Synopsis:    Called to handel 'onmousedown' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long clientX, clientY, left, top;

    CComPtr<IHTMLElement2> pElem2;

    CheckResult( _pElement->QueryInterface(IID_IHTMLElement2, (void **) & pElem2));

    if (IS_PRESSABLE(_abilities)) 
    {

        ShowDepressed();

        CheckResult( pElem2->setCapture());

        _pressing = true;

        if( _pfnPressed)
            CheckResult( (_pOwnerCtl->*_pfnPressed)(this));

    }

    if (IS_MOVEABLE(_abilities)) 
    {

		CheckResult( pEvent->EventObj()->get_clientX(&clientX));
		CheckResult( pEvent->EventObj()->get_clientY(&clientY));

        CheckResult( _pStyle->get_pixelTop(&top));
        CheckResult( _pStyle->get_pixelLeft(&left));

        CheckResult( pElem2->setCapture());

        _tx = clientX - left;
        _ty = clientY - top;

        _moving = true;

    }

Cleanup:
    
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseMove()
//
// Synopsis:    Called to handle 'onmousemove' event
//
// Arguments:   Event object
//
// Returns:     Success if the control is handled correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseMove(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long clientX, clientY, left, top;

    if(_moving) 
    {

        CComPtr<IHTMLStyle> pStyle;

        hr = _pElement->get_style(&pStyle);
        if( FAILED(hr))
            goto Cleanup;

        //
        //  Calculate new coordinates
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

			CheckResult( pEvent->EventObj()->get_clientX(&clientX));

            left = clientX - _tx;

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

			CheckResult( pEvent->EventObj()->get_clientY(&clientY));
			
			top  = clientY - _ty;

        }

        //
        //  Check to see if we can move
        //

        if( _pfnMoved)
            CheckResult( (_pOwnerCtl->*_pfnMoved)(this, left, top));

        //
        //  Do the move
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

            CheckResult( pStyle->put_pixelLeft(left));

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

            CheckResult( pStyle->put_pixelTop(top));

        }

    }

    if(_pressing) 
    {
        CComPtr<IHTMLElement> pSrcElement;

        CheckResult( pEvent->Open(EOA_EVENTOBJ));
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(IsSameObject(pSrcElement, _pElement) ||
           IsSameObject(pSrcElement, _pFace) ||
           IsSameObject(pSrcElement, _pArrow))
        {
            if(_raised) 
            {
                ShowDepressed();

                if( _pfnPressed)
                    CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
            }
        }
        else
        {
            if(! _raised) 
            {
                ShowRaised();

                if( _pfnPressed)
                    CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
            }
        }
    }

Cleanup:
    
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseUp()
//
// Synopsis:    Called to handel 'onmouseup' event
//
// Arguments:   Event object
//
// Returns:     Success if the control handled correctly
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElem2;
    CComPtr<IHTMLStyle> pStyle;
    POINT ptClient;

    CheckResult( _pElement->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));

    if(_pressing) 
    {

        _pressing = false;

        CheckResult( pElem2->releaseCapture());

        ShowRaised();

        if( _pfnPressed)
            CheckResult( (_pOwnerCtl->*_pfnPressed)(this));
 
    }

    if(_moving) 
    {
        _moving = false;

        CheckResult( _pElement->get_style(&pStyle));
        CheckResult( pElem2->releaseCapture());
        CheckResult( pEvent->GetWindowCoordinates(&ptClient));
    
        long left = ptClient.x - _tx;
        long top  = ptClient.y - _ty;

        //
        // Let them know we're done moving
        //

        if( _pfnMoved)
            CheckResult( (_pOwnerCtl->*_pfnMoved)(this, left, top));

        //
        //  Do the move
        //

        if( IS_MOVEABLE_X(_abilities)) 
        {

            CheckResult( pStyle->put_pixelLeft(left));

        }

        if( IS_MOVEABLE_Y(_abilities)) 
        {

            CheckResult( pStyle->put_pixelTop(top));

        }
    }


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseOver()
//
// Synopsis:    Called to handle 'onmouseover' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pElement;

	pEvent->EventObj()->get_srcElement(&pElement);

    if(IsSameObject(pElement, _pElement)) 
    {

        if( _pressing ) {
    
            return ShowDepressed();

        }

    }

    return S_OK;
}



//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnMouseDown()
//
// Synopsis:    Called to handle 'onmouseout' event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnMouseOut(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pElement;

	pEvent->EventObj()->get_srcElement(&pElement);

    if(IsSameObject(pElement, _pElement)) 
    {

        if( _pressing ) {

             return ShowRaised();

        }

    }

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnClick()
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnClick(CEventObjectAccess *pEvent)
{
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::OnSelectStart()
//
// Synopsis:    Called to handel 'OnSelectStart' event
//
// Arguments:   Event object
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDepressed()
//
// Synopsis:    Called to make the button appear depressed
//
// Arguments:   None
//
// Returns:     Success if the control is pressed.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowDepressed()
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_borderTopColor(_vShadowColor));
    CheckResult( _pStyle->put_borderLeftColor(_vShadowColor));
    CheckResult( _pStyle->put_borderBottomColor(_vShadowColor));
    CheckResult( _pStyle->put_borderRightColor(_vShadowColor));
    
    CheckResult( _pFaceStyle->put_borderTopColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderLeftColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderBottomColor(_vFaceColor));
    CheckResult( _pFaceStyle->put_borderRightColor(_vFaceColor));

    CheckResult( _pFaceStyle->put_paddingTop(CComVariant("1px")));
    CheckResult( _pFaceStyle->put_paddingLeft(CComVariant("1px")));

    _raised = false;

Cleanup:

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDepressed()
//
// Synopsis:    Called to make the button appear depressed
//
// Arguments:   None
//
// Returns:     Success if the control is pressed.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowRaised()
{
    HRESULT hr = S_OK;
    CComBSTR border;

    border = "1px solid";
    CheckResult( _pStyle->put_border(border));
    CheckResult( _pFaceStyle->put_border(border));
    
    CheckResult( _pStyle->put_borderTopColor(_v3dLightColor));
    CheckResult( _pStyle->put_borderLeftColor(_v3dLightColor));
    CheckResult( _pStyle->put_borderBottomColor(_vDarkShadowColor));
    CheckResult( _pStyle->put_borderRightColor(_vDarkShadowColor));
    
    CheckResult( _pFaceStyle->put_borderTopColor(_vHighlightColor));
    CheckResult( _pFaceStyle->put_borderLeftColor(_vHighlightColor));
    CheckResult( _pFaceStyle->put_borderBottomColor(_vShadowColor));
    CheckResult( _pFaceStyle->put_borderRightColor(_vShadowColor));

    CheckResult( _pFaceStyle->put_paddingTop(CComVariant("0px")));
    CheckResult( _pFaceStyle->put_paddingLeft(CComVariant("0px")));

    _raised = true;

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::ShowDisabled()
//
// Synopsis:    Called to make the button appear disabled
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::ShowDisabled()
{
    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::BuildButton()
//
// Synopsis:    Builds the button from html elements
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::BuildButton()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle2>    pStyle2;

    //
    // Get the document
    //

    CheckResult( _pOwner->get_document((IDispatch**) &pDoc));

    //
    // Create the button outline and get a few interfaces to use with it
    //

    CheckResult( pDoc->createElement(CComBSTR("DIV"), &_pElement));
    CheckResult( _pElement->get_style(&_pStyle));

    CheckResult( AppendChild(_pOwner, _pElement));

    CheckResult( _pStyle->put_display(CComBSTR("inline")));
    CheckResult( _pStyle->put_overflow(CComBSTR("hidden")));

    CheckResult( pDoc->createElement(CComBSTR("DIV"), &_pFace));
    CheckResult( _pFace->get_style(&_pFaceStyle));

    CheckResult( _pFaceStyle->put_display(CComBSTR("inline")));
    CheckResult( _pFaceStyle->put_overflow(CComBSTR("hidden")));

    CheckResult( AppendChild(_pElement, _pFace));



    ShowRaised();
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::BuildArrow()
//
// Synopsis:    Creates a container for an arrow character on the button face
//
// Arguments:   None
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::BuildArrow()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2>   pDoc;
    CComPtr<IHTMLStyle>       pStyle;

    CComBSTR bstr;

    //
    // Get the document, build and append element
    //

    CheckResult( _pOwner->get_document((IDispatch**) &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("font"), &_pArrow));
    CheckResult( AppendChild(_pFace, _pArrow));

    //
    //  Set up the font element (scope this stuff incase anything above fails)
    //

    CheckResult( _pArrow->get_style(&pStyle));

    bstr = _T("default");
    CheckResult( pStyle->put_cursor( bstr ));

    bstr = _T("Marlett");
    CheckResult( pStyle->put_fontFamily( bstr ));

    bstr = _T("center");
    CheckResult( pStyle->put_textAlign( bstr ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHeight()
//
// Synopsis:    Sets the height
//
// Arguments:   height
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetHeight(long height)
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_pixelHeight(height));
    CheckResult( _pFaceStyle->put_pixelHeight(max(height - 2, 0)));

    if(_pArrow) 
    {

        CheckResult( SetArrowSize());

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetWidth()
//
// Synopsis:    Sets the width
//
// Arguments:   width
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetWidth(long width)
{
    HRESULT hr = S_OK;

    CheckResult( _pStyle->put_pixelWidth(width));
    CheckResult( _pFaceStyle->put_pixelWidth( max(width - 2, 0)));

    if(_pArrow) 
    {

        CheckResult( SetArrowSize());

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHTML()
//
// Synopsis:    Sets the innerHTML
//
// Arguments:   an HTML string
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowStyle(unsigned style)
{
    HRESULT hr = S_OK;

    CComBSTR bstr;

    if(_pArrow == NULL) 
    {

        CheckResult( BuildArrow());

    }

    switch (style) 
    {
        case BUTTON_ARROW_UP:
            bstr = _T("5");
            break;
        case BUTTON_ARROW_DOWN:
            bstr = _T("6");
            break;
        case BUTTON_ARROW_LEFT:
            bstr = _T("3");
            break;
        case BUTTON_ARROW_RIGHT:
            bstr = _T("4");
            break;
        default:
            Assert(false);
            break;
    };

    CheckResult( _pArrow->put_innerText(bstr));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetArrowSize()
//
// Synopsis:    Sets the size of the arrow.  The arrow is represented by a single
//              character whose font size needs to be the min of the button width and height,
//              minus the border size.
//
// Arguments:   None
//
// Returns:     Success if the fontSize is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowSize()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pArrow);
    CContextAccess f(_pElement);

    long height, width;
    CComVariant fontSize;

    a.Open( CA_STYLE );
    f.Open( CA_STYLE );

    CheckResult( f.Style()->get_pixelWidth(&width));
    CheckResult( f.Style()->get_pixelHeight(&height));
 
    //
    //  We need to account for the 2 pixel border on both sides
    //  so subtract 2 * 2 pixels (but don't go below 0!)
    //

    fontSize = max( min(width, height) - 4, 0);

    CheckResult( a.Style()->put_fontSize(fontSize));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetArrowColor()
//
// Synopsis:    Sets the color of the character that represents the actual arrow inside of the button.
//
// Arguments:   None
//
// Returns:     Success if the color is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetArrowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLFontElement> pFont;

    if( _pArrow) 
    {
        CheckResult( _pArrow->QueryInterface( __uuidof(IHTMLFontElement), (void **) &pFont));
        CheckResult( pFont->put_color(color));
    }

Cleanup:

    return hr;
}

HRESULT    
CUtilityButton::Set3DLightColor(VARIANT color)
{
    HRESULT hr;

    CheckResult( ::VariantCopy(&_v3dLightColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pStyle->put_borderTopColor( _v3dLightColor ));
        CheckResult( _pStyle->put_borderLeftColor( _v3dLightColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetDarkShadowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vDarkShadowColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pStyle->put_borderBottomColor( _vDarkShadowColor ));
        CheckResult( _pStyle->put_borderRightColor( _vDarkShadowColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetShadowColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vShadowColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_borderBottomColor( _vShadowColor ));
        CheckResult( _pFaceStyle->put_borderRightColor( _vShadowColor ));
    }

Cleanup:

    return S_OK;
}

HRESULT    
CUtilityButton::SetHighlightColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vHighlightColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_borderTopColor( _vHighlightColor ));
        CheckResult( _pFaceStyle->put_borderLeftColor( _vHighlightColor ));
    }

Cleanup:

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetFaceColor()
//
// Synopsis:    Sets the color of the character that represents the actual arrow inside of the button.
//
// Arguments:   None
//
// Returns:     Success if the color is set correctly.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetFaceColor(VARIANT color)
{
    HRESULT hr = S_OK;

    CheckResult( ::VariantCopy(&_vFaceColor, &color));

    if(_pStyle) 
    {
        CheckResult( _pFaceStyle->put_backgroundColor(color));
    }

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetAbilities()
//
// Synopsis:    Sets the abilities attribute
//
// Arguments:   a flag
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT    
CUtilityButton::SetAbilities(unsigned abilities)
{
    HRESULT hr = S_OK;

    _abilities = abilities;

    if (IS_MOVEABLE(_abilities)) 
    {

        CComPtr<IHTMLStyle2> pStyle2;

        CheckResult( _pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
        CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    } 

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetHeight()
//
// Synopsis:    Sets the pixelOffset in the X dimension
//
// Arguments:   pixelOffset
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT   
CUtilityButton::SetHorizontalOffset(long pixelOffset)
{
    return _pStyle->put_pixelLeft(pixelOffset);
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetVerticalOffset()
//
// Synopsis:    Sets the pixelOffset in the Y dimension
//
// Arguments:   pixelOffset
//
// Returns:     Success if the control is correctly rendered.
//
//-------------------------------------------------------------------

HRESULT   
CUtilityButton::SetVerticalOffset(long pixelOffset)
{
    return _pStyle->put_pixelTop(pixelOffset);
}


//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetPressedCallback()
//
// Synopsis:    Set the pressed callback function; called by the mousedown handler
//
// Arguments:   height
//
//-------------------------------------------------------------------

HRESULT 
CUtilityButton::SetPressedCallback(PFN_PRESSED pfnPressed)
{
    _pfnPressed = pfnPressed;

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CUtilityButton::SetMovedCallback()
//
// Synopsis:    Sets the moved callback function;  called by the mousemove handler
//
// Arguments:   moved function
//
//-------------------------------------------------------------------

HRESULT
CUtilityButton::SetMovedCallback(PFN_MOVED pfnMoved)
{
    _pfnMoved = pfnMoved;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\tmpprint.cxx ===
//===============================================================
//
//  tmpprint.cxx : Implementation of the CTemplatePrinter Peer
//
//  Synposis : This class has two major responsibilities
//      1) Providing printer UI (dialogs, &c...) to a print template
//      2) Providing a way for the template document to reach the printer
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TMPPRINT_HXX_
#define X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef X_IEXTAG_H_
#define X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h> 
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"       //  For default header/footer resource
#endif

#ifndef X_UTILS_HXX_
#define X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef X_DLGS_H_
#define X_DLGS_H_
#include "dlgs.h"
#endif

#ifndef X_VRSSCAN_HXX_
#define X_VRSSCAN_HXX_
#include "vrsscan.h"
#endif

#ifndef X_WINSPOOL_H_
#define X_WINSPOOL_H_
#include "winspool.h"
#endif

#ifndef X_WINGDI_H_
#define X_WINGDI_H_
#include "wingdi.h"
#endif

#include <commctrl.h>
#include <commdlg.h>
#include <mshtmcid.h>
#include <mshtmdid.h>
#include <dispex.h>

// NB (greglett)
// We need to define this because we're building with a WINVER of 4, and this is only deifned for NT5
// Remove this as soon as the winver changes.
#define NEED_BECAUSE_COMPILED_AT_WINVER_4
#ifdef  NEED_BECAUSE_COMPILED_AT_WINVER_4
#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000
#endif

// This is defined in transform.hxx, but we can't access that as a peer.
inline int MulDivQuick(int nMultiplicand, int nMultiplier, int nDivisor)
        { Assert(nDivisor); return (!nDivisor-1) & MulDiv(nMultiplicand, nMultiplier, nDivisor); }

#define ORIENTPORTRAIT  _T("portrait")
#define ORIENTLANDSCAPE _T("landscape")

static const TCHAR *s_aachPrintArg[] = 
{
    _T("__IE_BrowseDocument"),          // PRINTARG_BROWSEDOC
    _T("__IE_PrinterCMD_DevNames"),     // PRINTARG_DEVNAMES
    _T("__IE_PrinterCMD_DevMode"),      // PRINTARG_DEVMODE
    _T("__IE_PrinterCMD_Printer"),      // PRINTARG_PRINTER
    _T("__IE_PrinterCMD_Device"),       // PRINTARG_DRIVER
    _T("__IE_PrinterCMD_Port"),         // PRINTARG_PORT
    _T("__IE_PrintType"),               // PRINTARG_TYPE
};

#define DEVCAP_COPIES       0
#define DEVCAP_COLLATE      1
#define DEVCAP_DUPLEX       2
#define DEVCAP_LAST_RETAIL  3   // Add more retail properties before this!

#ifndef DBG

#define DEVCAP_LAST             DEVCAP_LAST_RETAIL

#else

#define DEVCAP_DBG_PRINTERNAME  DEVCAP_LAST_RETAIL
#define DEVCAP_LAST             DEVCAP_LAST_RETAIL + 1

#endif

static const TCHAR *s_aachDeviceCapabilities[] = 
{
    _T("copies"),        
    _T("collate"),       
    _T("duplex"),               // Add more retail properties after this!

#if DBG == 1
    _T("printerName"),
#endif
};


//+----------------------------------------------------------------------------
//
//  Function : InitMultiByteFromWideChar
//
//  Synopsis : Allocates & creates a wide char string from a multi byte string.
//
//-----------------------------------------------------------------------------
LPSTR
InitMultiByteFromWideChar(LPCWSTR pchWide, long cchWide)
{
    long    cchMulti;
    char *  pchMulti;

    //
    // Alloc space on heap for buffer.
    //
    cchMulti = ::WideCharToMultiByte(CP_ACP, 0, pchWide, cchWide, NULL, 0, NULL, NULL);
    Assert(cchMulti > 0);

    cchMulti++;
    pchMulti = new char[cchMulti];
    if (pchMulti)
    {
        ::WideCharToMultiByte(CP_ACP, 0, pchWide, cchWide, pchMulti, cchMulti, NULL, NULL);
        pchMulti[cchMulti - 1] = '\0';
    }

    return pchMulti;
}
inline LPSTR
InitMultiByteFromWideChar(LPCWSTR pwch)
{
    return InitMultiByteFromWideChar(pwch, _tcslen(pwch));
}

//+----------------------------------------------------------------------------
//
//  Function : InitWideCharFromMultiByte
//
//  Synopsis : Allocates & creates a multibyte string from a widechar string.
//
//-----------------------------------------------------------------------------
LPWSTR
InitWideCharFromMultiByte(LPSTR pchMulti, long cchMulti)
{
    long    cchWide;
    LPWSTR  pchWide;

    //
    // Alloc space on heap for buffer.
    //
    cchWide = ::MultiByteToWideChar(CP_ACP, 0, pchMulti, cchMulti, NULL, 0);
    Assert(cchWide > 0);

    cchWide++;
    pchWide = new WCHAR[cchWide];
    if (pchWide)
    {
        ::MultiByteToWideChar(CP_ACP, 0, pchMulti, cchMulti, pchWide, cchWide);
        pchWide[cchWide - 1] = _T('\0');
    }

    return pchWide;
}
inline LPWSTR
InitWideCharFromMultiByte(LPSTR pwch)
{
    return InitWideCharFromMultiByte(pwch, strlen(pwch));
}

//+----------------------------------------------------------------------------
//
//  Function : CreateDevNames
//
//  Synopsis : Takes the three strings in a DEVNAMES structure, allocates &
//             & creates the structure as a GHND.
//
//-----------------------------------------------------------------------------
HRESULT
CreateDevNames(TCHAR *pchDriver, TCHAR *pchPrinter, TCHAR *pchPort, HGLOBAL *pDN)
{
    HRESULT hr = S_OK;
    DWORD dwLenDriver, dwLenPrinter, dwLenPort;
    DWORD nStructSize;

    Assert(pDN);

    if (!pchDriver || !pchPrinter || !pchPort)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwLenDriver  = _tcslen(pchDriver) + 1;
    dwLenPrinter = _tcslen(pchPrinter) + 1;
    dwLenPort    = _tcslen(pchPort) + 1;

    nStructSize = sizeof(DEVNAMES)
                  + ((dwLenPrinter + dwLenDriver + dwLenPort) * sizeof(TCHAR));
    (*pDN) = ::GlobalAlloc(GHND, nStructSize);

    if (!(*pDN))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    {
        DEVNAMES *pDevNames = ((DEVNAMES *) ::GlobalLock(*pDN));
        if (pDevNames)
        {
#pragma warning(disable: 4244)
            pDevNames->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
            pDevNames->wDeviceOffset = pDevNames->wDriverOffset + dwLenDriver;
            pDevNames->wOutputOffset = pDevNames->wDeviceOffset + dwLenPrinter;
#pragma warning(default: 4244)
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wDriverOffset), pchDriver);
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wDeviceOffset), pchPrinter);
            _tcscpy((((TCHAR *)pDevNames) + pDevNames->wOutputOffset), pchPort);
        }
        ::GlobalUnlock(*pDN);        
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis :  peer Interface, initialization
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr      = S_OK;
    HKEY    hKey    = NULL;

    if (!pPeerSite)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // cache our peer element
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();
    _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, (void**)&_pPeerSiteOM);

    GetDialogArguments();   // Cache the dialog arguments.

    // What order should we obtain default print settings?
    // 1. Settings passed in by our host (1a and 1b should be mutually exclusive)
    //   1a. A DEVMODE/DEVNAMES
    //   1b. A printer (and maybe a port & driver name, too)
    // 2. Read defaults from the registry
    // 3. Get the default Windows printer, if any.

    //
    // READ IN A DEVMODE/DEVNAMES
    //
    {
        VARIANT varDM;
        VARIANT varDN;
        VariantInit(&varDN);
        VariantInit(&varDM);

        // Only accept arguments in matched pair.
        if (    GetDialogArgument(&varDN, PRINTARG_DEVNAMES) == S_OK
            &&  GetDialogArgument(&varDM, PRINTARG_DEVMODE) == S_OK
            &&  V_VT(&varDN) == VT_HANDLE
            &&  V_VT(&varDM) == VT_HANDLE
            &&  V_BYREF(&varDN)
            &&  V_BYREF(&varDM) )
        {
            RemoveDialogArgument(PRINTARG_DEVNAMES);
            RemoveDialogArgument(PRINTARG_DEVMODE);
                
            _hDevNames  = V_BYREF(&varDN);  // NB We will release this!
            _hDevMode   = V_BYREF(&varDM);  // NB We will release this!
        }

        VariantClear(&varDN);
        VariantClear(&varDM);
    }

    //
    // READ IN A PRINTER/PORT/DRIVER
    //
    if (!_hDevNames)
    {
        VARIANT varPrinter;
        VARIANT varDriver;
        VARIANT varPort;

        VariantInit(&varPrinter);
        VariantInit(&varDriver);
        VariantInit(&varPort);

        Assert(!_hDevMode);

        if (    GetDialogArgument(&varPrinter, PRINTARG_PRINTER) == S_OK
            &&  V_VT(&varPrinter) == VT_BSTR
            &&  V_BSTR(&varPrinter) )
        {
            GetDialogArgument(&varDriver, PRINTARG_DRIVER);
            GetDialogArgument(&varPort, PRINTARG_PORT);

            if (g_fUnicodePlatform)
                hr = ReadDeviceUnicode(V_BSTR(&varPrinter),
                                       V_VT(&varDriver) == VT_BSTR ? V_BSTR(&varDriver) : NULL,
                                       V_VT(&varPort) == VT_BSTR ? V_BSTR(&varPort) : NULL );
            else
                hr = ReadDeviceNonUnicode(V_BSTR(&varPrinter),
                                          V_VT(&varDriver) == VT_BSTR ? V_BSTR(&varDriver) : NULL,
                                          V_VT(&varPort) == VT_BSTR ? V_BSTR(&varPort) : NULL );
        }

        VariantClear(&varPrinter);
        VariantClear(&varDriver);
        VariantClear(&varPort);
    }

    // Get these default settings from the registry, if we can
    //      1.  Header/Footer
    //      2.  Margins
    //      3.  Target device (printer)
    //      4.  Page size/Paper source information.
    if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_PAGESETUP, &hKey) == S_OK)
    {            
        ReadHeaderFooterFromRegistry(hKey);
        ReadMarginsFromRegistry(hKey);

        RegCloseKey(hKey);
    }          

    //      5.  Table of links
    if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_MAIN, &hKey) == S_OK)
    {            
        _fPrintTableOfLinks = ReadBoolFromRegistry(hKey, _T("Print_Shortcuts"));

        RegCloseKey(hKey);
    }          

    hr = GetDeviceProperties();     // Returns E_FAIL if we don't have a valid printer at this point.

    //
    // DEFAULT WINDOWS PRINTER
    //
    if (hr)
        hr = GetPrintDialogSettings(FALSE, NULL);    // Get printer defaults.

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis :  peer Interface, destruction work upon detaching from document
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Detach() 
{ 
    // Abort any currently printing document.
    if (_hDC)
    {
        ::AbortDoc(_hDC);
        ::DeleteDC(_hDC);
        _hDC = NULL;
    }
    
    // Free any cached resources.
    if (_hInstResource)
    {
        MLFreeLibrary(_hInstResource);
        _hInstResource = NULL;
    }
    if (_hInstRatings)
    {
        FreeLibrary(_hInstRatings);
        _hInstRatings = NULL;
    }
    if (_hInstComctl32)
    {
        FreeLibrary(_hInstComctl32);
        _hInstComctl32 = NULL;
    }

    ReturnPrintHandles();       // Send our print handles back to the master thread CDoc.
    if (_hDevNames)
    {
        ::GlobalFree(_hDevNames);
        _hDevNames = NULL;
    }
    if (_hDevMode)
    {
        ::GlobalFree(_hDevMode);
        _hDevMode = NULL;
    }

    // Clear any COM interfaces we currently reference
    ClearInterface( &_pevDlgArgs );
    ClearInterface( &_pPeerSite );
    ClearInterface( &_pPeerSiteOM );

    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::printPage 
//
//  Synopsis : takes the passed element and prints it on its own page
//             should be called any number of times after startDoc, and before endDoc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::printBlankPage()
{
    // No TEMPLATESECURITYCHECK() required because printPage has one.
    
    return printPage(NULL);
}

STDMETHODIMP
CTemplatePrinter::printPage(IDispatch *pElemDisp)
{
    TEMPLATESECURITYCHECK()
    
    IHTMLElementRender  *pRender = NULL;
    HRESULT hr = S_OK;

    if (!_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (::StartPage(_hDC) <= 0)
    {
    // Returns a "nonzero" value on success, "zero" on failure.
        
        DWORD dwError = GetLastError(); 
        Assert(FALSE && "error calling StartPage api");
        hr = E_FAIL;
        goto Cleanup;
    }

#ifdef DBG
    RECT rcUnprintTest;
    SIZE szResTest;
    SIZE szPage;

    szResTest.cx            = ::GetDeviceCaps(_hDC, LOGPIXELSX);
    szResTest.cy            = ::GetDeviceCaps(_hDC, LOGPIXELSY);
    szPage.cx               = ::GetDeviceCaps(_hDC, PHYSICALWIDTH);
    szPage.cy               = ::GetDeviceCaps(_hDC, PHYSICALHEIGHT);
    rcUnprintTest.left      = ::GetDeviceCaps(_hDC, PHYSICALOFFSETX);
    rcUnprintTest.top       = ::GetDeviceCaps(_hDC, PHYSICALOFFSETY);
    rcUnprintTest.right     =  szPage.cx - ::GetDeviceCaps(_hDC, HORZRES) - rcUnprintTest.left;
    rcUnprintTest.bottom    =  szPage.cy - ::GetDeviceCaps(_hDC, VERTRES) - rcUnprintTest.top;   
    Assert(     rcUnprintTest.left == _rcUnprintable.left
            &&  rcUnprintTest.right == _rcUnprintable.right
            &&  rcUnprintTest.top == _rcUnprintable.top
            &&  rcUnprintTest.bottom == _rcUnprintable.bottom );
#endif

    //  If we have been given an element, draw it to the screen.
    if (pElemDisp)
    {
        hr = pElemDisp->QueryInterface(IID_IHTMLElementRender, (void **)&pRender);
        if (hr) 
            goto Cleanup;
          
        ::SetViewportOrgEx(_hDC, -_rcUnprintable.left,-_rcUnprintable.top, NULL);

        hr = pRender->DrawToDC(_hDC);
    }

    if (::EndPage(_hDC) <= 0)
    {
        // Known issues with EndPage:
        // 1.   Win95 Fax fails the EndPage API when the "SetUpMyFax" wizard is aborted.  dwError=0.  (100092)
        DWORD dwError = GetLastError(); 
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pRender);
    if (hr)
        stopDoc();

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::startDoc
//
//  Synopsis : Gets/Inits the default printer and starts to print a document.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::startDoc(BSTR bstrTitle, VARIANT_BOOL * p)
{
    TEMPLATESECURITYCHECK()
    
    HRESULT     hr = S_OK;
    DOCINFO     docinfo;
    TCHAR       achTitle[MAX_JOBNAME];
    
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    if (    _hDC
        ||  !_hDevNames 
        ||  !_hDevMode)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    
    {
        DEVNAMES *pDevNames = ((DEVNAMES *) ::GlobalLock(_hDevNames));
        void     *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevNames && pDevMode)
        {           
            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                if (!_fUsePrinterCopyCollate)
                {
                    // Force template to do its own copies/collation (to prevent both us and the printer from doing so).
                    ((DEVMODEW *)pDevMode)->dmCollate = FALSE;
                    ((DEVMODEW *)pDevMode)->dmCopies = 1;
                }
                else
                {
                    // We might want to check if the hardware supports copy/collation
                    ((DEVMODEW *)pDevMode)->dmFields |= DM_COPIES | DM_COLLATE;
                    ((DEVMODEW *)pDevMode)->dmCollate = _fCollate;
                    ((DEVMODEW *)pDevMode)->dmCopies = _nCopies;
                }

                _hDC =  ::CreateDCW(((TCHAR *)pDevNames) + pDevNames->wDriverOffset,
                                   ((TCHAR *)pDevNames) + pDevNames->wDeviceOffset,
                                   NULL,
                                   (DEVMODEW *) pDevMode);
            }
            else
            {
                LPSTR pchDriver = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDriverOffset);
                LPSTR pchDevice = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);

                if (!_fUsePrinterCopyCollate)
                {
                    // Force template to do its own copies/collation (to prevent both us and the printer from doing so).
                    ((DEVMODEA *)pDevMode)->dmCollate = FALSE;
                    ((DEVMODEA *)pDevMode)->dmCopies = 1;
                }
                else
                {
                    // We might want to check if the hardware supports copy/collation
                    ((DEVMODEA *)pDevMode)->dmFields |= DM_COPIES | DM_COLLATE;
                    ((DEVMODEA *)pDevMode)->dmCollate = _fCollate;
                    ((DEVMODEA *)pDevMode)->dmCopies = _nCopies;
                }

                if (pchDriver && pchDevice)
                {
                    _hDC = ::CreateDCA(pchDriver,
                                       pchDevice,
                                       NULL,
                                       (DEVMODEA *)pDevMode);
                }
                if (pchDriver)
                    delete []pchDriver;
                if (pchDevice)
                    delete []pchDevice;
            }
        }
        ::GlobalUnlock(_hDevNames);
        ::GlobalUnlock(_hDevMode);

        if (!_hDC)
        {
            DWORD dwError = GetLastError();
            Assert(!"Failed to create DC!");
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    //  Fill out the DOCINFO structure
    //
    ::ZeroMemory(&docinfo,sizeof(DOCINFO));
    ::ZeroMemory(achTitle,sizeof(TCHAR) * MAX_JOBNAME);
    docinfo.cbSize      = sizeof(DOCINFO);  
    docinfo.fwType      = 0; 
   
    if (bstrTitle)
        _tcsncpy(achTitle, bstrTitle, MAX_JOBNAME - 1);
    docinfo.lpszDocName = achTitle;
    
    if (_achFileName[0])
        docinfo.lpszOutput = _achFileName;

    //
    //  Set up the document so that it can begin accepting pages
    //
    if (::StartDoc(_hDC, &docinfo) > 0)
        *p = VB_TRUE;
#ifdef DBG
    else
    {
        DWORD dwError = GetLastError(); 
        goto Cleanup;
    }
#endif

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : (ITemplatePrinter) CTemplatePrinter::endDoc
//
//  Synopsis : 'Finishes' the doc - takes pages printed via printPage and queues the job
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::stopDoc()
{   
    TEMPLATESECURITYCHECK()

    HRESULT hr = S_OK;

    if (!_hDC)
        goto Cleanup;    

    if (::EndDoc(_hDC) <=0)
    {
        DWORD dwError = GetLastError(); 
        Assert(FALSE && "error calling EndDoc API");
        hr = E_FAIL;
        goto Cleanup;
    }

    ::DeleteDC(_hDC);
    _hDC = NULL;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put framesetDocument
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_framesetDocument(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFramesetDocument);
}
STDMETHODIMP
CTemplatePrinter::put_framesetDocument(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fFramesetDocument, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printTableOfLinks
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_tableOfLinks(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintTableOfLinks);
}
STDMETHODIMP
CTemplatePrinter::put_tableOfLinks(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintTableOfLinks, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printAllLinkedDocuments
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_allLinkedDocuments(VARIANT_BOOL * p)
{
    return GetFlagSafe(p, _fPrintAllLinkedDocuments);
}
STDMETHODIMP
CTemplatePrinter::put_allLinkedDocuments(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintAllLinkedDocuments, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printFrameActive
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameActive(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameActive);
}
STDMETHODIMP
CTemplatePrinter::put_frameActive(VARIANT_BOOL v)
{
    if (!!v)
        _fFrameAsShown = FALSE;
    PUTFLAGSAFE(_fFrameActive, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put printFrameActive
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameActiveEnabled(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameActiveEnabled);
}
STDMETHODIMP
CTemplatePrinter::put_frameActiveEnabled(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fFrameActiveEnabled, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printFrameAsShown
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_frameAsShown(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fFrameAsShown);
}
STDMETHODIMP
CTemplatePrinter::put_frameAsShown(VARIANT_BOOL v)
{
    if (!!v)
        _fFrameActive = FALSE;
    PUTFLAGSAFE(_fFrameAsShown, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printSelection
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selection(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelection);
}
STDMETHODIMP
CTemplatePrinter::put_selection(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelection, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put printSelectionEnabled
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selectionEnabled(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelectionEnabled);
}
STDMETHODIMP
CTemplatePrinter::put_selectionEnabled(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelectionEnabled, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printSelectedPages
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_selectedPages(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintSelectedPages);
}
STDMETHODIMP
CTemplatePrinter::put_selectedPages(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintSelectedPages, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCurrentPage
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_currentPage(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fPrintCurrentPage);
}
STDMETHODIMP
CTemplatePrinter::put_currentPage(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fPrintCurrentPage, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCurrentPageAvail
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_currentPageAvail(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fCurrentPageAvail);
}
STDMETHODIMP
CTemplatePrinter::put_currentPageAvail(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fCurrentPageAvail, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put printCollate
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_collate(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fCollate);
}
STDMETHODIMP
CTemplatePrinter::put_collate(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fCollate, v);
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put usePrinterCopyCollate
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_usePrinterCopyCollate(VARIANT_BOOL * p)
{
    return GetFlagSafe(p,_fUsePrinterCopyCollate);
}
STDMETHODIMP
CTemplatePrinter::put_usePrinterCopyCollate(VARIANT_BOOL v)
{
    PUTFLAGSAFE(_fUsePrinterCopyCollate, v);
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get_duplex
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_duplex(VARIANT_BOOL * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = VB_FALSE;

    if (_hDevMode)
    {
        void * pDevMode = ::GlobalLock(_hDevMode);
        if (pDevMode)
        {
            // (greglett) Unicode weirdness.  DEVMMODEA on Win9x, DEVMODEW on NT.
            if (    (   g_fUnicodePlatform
                     && (((DEVMODEW *)pDevMode)->dmFields & DM_DUPLEX)
                     && ((DEVMODEW *)pDevMode)->dmDuplex != DMDUP_SIMPLEX )
                ||  (  !g_fUnicodePlatform
                     && (((DEVMODEA *)pDevMode)->dmFields & DM_DUPLEX)
                     && ((DEVMODEA *)pDevMode)->dmDuplex != DMDUP_SIMPLEX ) )
            {
                *p = VB_TRUE;
            }
            ::GlobalUnlock(_hDevMode);
        }
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put copies
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_copies(WORD * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nCopies;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_copies(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nCopies = v;

    return hr;
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put pageFrom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageFrom(WORD * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nPageFrom;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_pageFrom(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nPageFrom = v;

    return hr;
}


//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put pageTo
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageTo(WORD * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = _nPageTo;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_pageTo(WORD v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _nPageTo = v;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put marginLeft/Right/Top/Bottom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_marginLeft(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = (_rcMargin.left / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginLeft(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _rcMargin.left = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginRight(long * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        *p = (_rcMargin.right / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginRight(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        _rcMargin.right = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginTop(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Input in 1/100 inches.
        *p = (_rcMargin.top / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginTop(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (v < 0)
        hr = E_INVALIDARG;
    else
        //  Output in 1/100 inches.
        _rcMargin.top = v * 1000;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_marginBottom(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Input in 1/100 inches.
        *p = (_rcMargin.bottom / 1000);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_marginBottom(long v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (v < 0)
        hr = E_INVALIDARG;
    else
        //  Output in 1/100 inches.
        _rcMargin.bottom = v * 1000;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get pageWidth/Height
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_pageWidth(long * p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Output in 1/100 inches.
        *p = _ptPaperSize.x / 10;

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_pageHeight(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
        //  Output in 1/100 inches.
        *p = _ptPaperSize.y / 10;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::get/put orientation
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_orientation(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = NULL;
    
    if (GetOrientation() == DMORIENT_LANDSCAPE)
        *p = SysAllocString(ORIENTLANDSCAPE);
    else
        *p = SysAllocString(ORIENTPORTRAIT);

    if (!p)
        hr = E_OUTOFMEMORY;

Cleanup:    
    return hr;
}

STDMETHODIMP
CTemplatePrinter::put_orientation(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!v)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_tcsicmp(v, ORIENTPORTRAIT) == 0)
        SetOrientation(DMORIENT_PORTRAIT);
    else if (_tcsicmp(v, ORIENTLANDSCAPE) == 0)
        SetOrientation(DMORIENT_LANDSCAPE);
    else
        hr = E_INVALIDARG;

Cleanup:    
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get unprintableLeft/Top/Right/Bottom
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_unprintableLeft(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cx == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.left, 100, _szResolution.cx);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableTop(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;

    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cy == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.top, 100, _szResolution.cy);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableRight(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cx == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.right, 100, _szResolution.cx);

    return hr;
}
STDMETHODIMP
CTemplatePrinter::get_unprintableBottom(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else if (_szResolution.cy == 0)
        *p = 0;
    else
        //  Output should be in 1/100 inches, not printer pixels.
        *p = MulDivQuick(_rcUnprintable.bottom, 100, _szResolution.cy);

    return hr;
}
//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put header
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_header(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achHeader);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_header(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    TCHAR   *achTemp;

    achTemp = v;    
    if (! (_tcslen(achTemp) <= ARRAY_SIZE(_achHeader) - 1))
        hr = E_INVALIDARG;
    else
    {
        _fPersistHFToRegistry = FALSE;
        _tcscpy(_achHeader, achTemp);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::get/put footer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::get_footer(BSTR * p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achFooter);
        if (!p)
            hr = E_OUTOFMEMORY;
    }
    
    return hr;
}
STDMETHODIMP
CTemplatePrinter::put_footer(BSTR v)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT hr = S_OK;
    TCHAR   *achTemp;

    achTemp = v;
    if (! (_tcslen(achTemp) <= ARRAY_SIZE(_achFooter) - 1))
        hr = E_INVALIDARG;
    else
    {
        _fPersistHFToRegistry = FALSE;
        _tcscpy(_achFooter, achTemp);
    }
    
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter2) CTemplatePrinter::deviceSupports
//
//  Takes a BSTR indicating which property to query (supported values in the
//  defined above).
//  Returns information about that property.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::deviceSupports(BSTR bstrProperty, VARIANT * pvar)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT   hr        = S_OK;
    void     *pDevMode  = NULL;
    DEVNAMES *pDevNames = NULL;
    TCHAR    *achDevice = NULL;
    TCHAR    *achPort   = NULL;
    int i;

    if (!pvar)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VariantInit(pvar);

    pDevMode = ::GlobalLock(_hDevMode);
    pDevNames = ((DEVNAMES *) ::GlobalLock(_hDevNames));
    if (!pDevMode || !pDevNames)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    for (i = 0;
        (i < DEVCAP_LAST) && (_tcsicmp(bstrProperty, s_aachDeviceCapabilities[i]) != 0);
        i++);

    if (i >= DEVCAP_LAST)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    achDevice = ((TCHAR *)pDevNames) + (pDevNames->wDeviceOffset);
    achPort = ((TCHAR *)pDevNames) + (pDevNames->wOutputOffset);    
    switch (i)
    {
    case DEVCAP_COPIES:
        V_VT(pvar) = VT_INT;
        V_INT(pvar) = ::DeviceCapabilities(achDevice, achPort, DC_COPIES, NULL, NULL);
        break;
    case DEVCAP_COLLATE:
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = (::DeviceCapabilities(achDevice, achPort, DC_COLLATE, NULL, NULL) != 0) ? VB_TRUE : VB_FALSE;
        break;
    case DEVCAP_DUPLEX:
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = (::DeviceCapabilities(achDevice, achPort, DC_DUPLEX, NULL, NULL) != 0) ? VB_TRUE : VB_FALSE;
        break;
#if DBG==1
    case DEVCAP_DBG_PRINTERNAME:
        V_BSTR(pvar) = ::SysAllocString(achDevice);
        if (V_BSTR(pvar))
            V_VT(pvar) = VT_BSTR;
        else
            hr = E_OUTOFMEMORY;
        break;
#endif
    default:
        Assert(FALSE && "Unrecognized DEVCAP_ value.");
        break;
    }


Cleanup:    
    if (pDevNames)
        ::GlobalUnlock(_hDevNames);
    if (pDevMode)
        ::GlobalUnlock(_hDevMode);
    return hr;
}

STDMETHODIMP
CTemplatePrinter::updatePageStatus(long * p)
{    
    TEMPLATESECURITYCHECK();
    
    VARIANT              varHost;
    HRESULT              hr      = S_OK;
    IOleCommandTarget   *pioct   = NULL;
    const GUID          *pguid   = NULL;
    DWORD                nCmdId  = 0;

    VariantInit(&varHost);

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }     

    if (    GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) == S_OK
         && V_VT(&varHost) == VT_UNKNOWN
         && V_UNKNOWN(&varHost) )
    {
        VARIANT varIn;
        V_VT(&varIn) = VT_I4;
        V_I4(&varIn) = (*p > 0) ? (*p) : 0;

        hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
        if (hr)
            goto Cleanup;
        Assert(pioct);

        hr = pioct->Exec(&CGID_MSHTML, IDM_UPDATEPAGESTATUS, 0, &varIn, 0);

        hr = S_OK;      // If the host isn't listening, we'll get an OLE error.  Don't throw it to script!
    }

Cleanup:
    ReleaseInterface(pioct);
    VariantClear(&varHost);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::printNonNative
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::printNonNative(IUnknown* pDoc, VARIANT_BOOL *p)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr              = S_OK;
    IOleCommandTarget  *pioct           = NULL;
    IPrint             *pIPrint         = NULL;
    VARIANT             varOut;
    VARIANT             varIn;

    VariantInit(&varOut);

    if (!pDoc || !p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *p = VB_FALSE;

    hr = pDoc->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = IPRINT_DOCUMENT;
    hr = pioct->Exec( &CGID_MSHTML,
                      IDM_GETIPRINT,
                      NULL, 
                      &varIn, 
                      &varOut);

    if (    hr
        ||  V_VT(&varOut) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varOut))
        goto Cleanup;

    // We don't get back an IPrint collection unless it has at least one member.
    // At this point, we can claim that we should be printing, and a template does not need to.
    *p = VB_TRUE;

    hr = PrintIPrintCollection(&varOut);    

Cleanup:
    VariantClear(&varOut);
    ReleaseInterface(pioct);

    return hr;
}

STDMETHODIMP
CTemplatePrinter::printNonNativeFrames(IUnknown *pMarkup, VARIANT_BOOL fActiveFrame)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT              hr              = S_OK;
    IOleCommandTarget   *pioct           = NULL;
    VARIANT             varOut;
    VARIANT             varIn;
    VARIANT             varBrowseDoc;

    if (!pMarkup)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantInit(&varOut);
    VariantInit(&varIn);
    VariantInit(&varBrowseDoc);

    // Use the browse document if one exists - it will have the WebOC frame.
    // NB (greglett)
    // This assumes that the reference we are passed to the browse doc
    // stays good - including nested frames &c... on the browse doc while the WebOC is still
    // loaded & (if it was selected) active.
    // Yes, this may exhibit unexpected behavior if the user Prints and navigates away.
    // A better solution would be appreciated.
    if (    GetDialogArgument(&varBrowseDoc, PRINTARG_BROWSEDOC) == S_OK
        &&  V_VT(&varBrowseDoc) == VT_UNKNOWN
        &&  V_UNKNOWN(&varBrowseDoc) )
    {
        hr = V_UNKNOWN(&varBrowseDoc)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    }

    // Otherwise, use the content document
    if (!pioct)
    {
        hr = pMarkup->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
        if (hr)
            goto Cleanup;
    }

    Assert(pioct);

    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = fActiveFrame ? IPRINT_ACTIVEFRAME : IPRINT_ALLFRAMES;
    hr = pioct->Exec( &CGID_MSHTML,
                      IDM_GETIPRINT,
                      NULL, 
                      &varIn, 
                      &varOut);

    if (    hr
        ||  V_VT(&varOut) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varOut))
        goto Cleanup;

    hr = PrintIPrintCollection(&varOut);

Cleanup:
    VariantClear(&varOut);
    VariantClear(&varBrowseDoc);
    ReleaseInterface(pioct);

    return hr;
}   

HRESULT
CTemplatePrinter::PrintIPrintCollection(VARIANT * pvarIPrintAry)
{
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr             = S_OK;
    IDispatch *         pIPrintAry     = NULL;
    IPrint *            pIPrint        = NULL;
    VARIANT             varInvokeOut;
    VARIANT             varInvokeParam;
    DISPPARAMS          DispParams;
    DVTARGETDEVICE *    pTargetDevice   = NULL;
    PAGESET *           pPageSet        = NULL;
    long                cIPrint, i;
    long                lFirstPage, lPages, lLastPage;

    Assert(V_VT(pvarIPrintAry) == VT_UNKNOWN);
    Assert(V_UNKNOWN(pvarIPrintAry));

    VariantInit(&varInvokeOut);
    VariantInit(&varInvokeParam);

    hr = V_UNKNOWN(pvarIPrintAry)->QueryInterface(IID_IDispatch, (void **)&pIPrintAry);
    if (hr)
        goto Cleanup;
    Assert(pIPrintAry);

    DispParams.cNamedArgs           = 0;
    DispParams.rgdispidNamedArgs    = NULL;
    DispParams.cArgs                = 0;
    DispParams.rgvarg               = NULL;
    hr = pIPrintAry->Invoke(DISPID_IHTMLIPRINTCOLLECTION_LENGTH,
                            IID_NULL,
                            LOCALE_USER_DEFAULT,
                            DISPATCH_PROPERTYGET,
                            &DispParams,
                            &varInvokeOut,
                            NULL, NULL);
    if (    hr
        ||  V_VT(&varInvokeOut) != VT_I4
        ||  V_I4(&varInvokeOut) <= 0      )
        goto Cleanup;
    
    cIPrint = V_I4(&varInvokeOut);
    VariantClear(&varInvokeOut);

    hr = CreateIPrintParams(&pTargetDevice, &pPageSet);
    if (hr)
        goto Cleanup;

    lFirstPage = pPageSet->rgPages[0].nFromPage;        
    lLastPage  = pPageSet->rgPages[0].nToPage;

    DispParams.cArgs        = 1;
    DispParams.rgvarg       = &varInvokeParam;
    V_VT(&varInvokeParam)   = VT_I4;
    for (i = 0; i < cIPrint; i++)
    {
        V_I4(&varInvokeParam) = i;
        hr = pIPrintAry->Invoke(DISPID_IHTMLIPRINTCOLLECTION_ITEM,
                                IID_NULL,
                                LOCALE_USER_DEFAULT,
                                DISPATCH_METHOD,
                                &DispParams,
                                &varInvokeOut,
                                NULL, NULL);
        if (    hr
            ||  V_VT(&varInvokeOut) != VT_UNKNOWN
            ||  !V_UNKNOWN(&varInvokeOut))
        {
            VariantClear(&varInvokeOut);
            continue;
        }

        hr = V_UNKNOWN(&varInvokeOut)->QueryInterface(IID_IPrint, (void **)&pIPrint);
        VariantClear(&varInvokeOut);
        if (hr)
            continue;
        Assert(pIPrint);

        hr = pIPrint->Print(
                 PRINTFLAG_MAYBOTHERUSER,
                 &pTargetDevice,
                 &pPageSet,
                 NULL,
                 NULL,
                 lFirstPage,
                 &lPages,        // out
                 &lLastPage      // out
                 );

        ReleaseInterface(pIPrint);
        pIPrint = NULL;
    }
    
    hr = S_OK;


Cleanup:    
    if (pTargetDevice)
        ::CoTaskMemFree(pTargetDevice);
    if (pPageSet)
        ::CoTaskMemFree(pPageSet);

    ReleaseInterface(pIPrintAry);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::showPrintDialog, ensurePrintDialogDefaults
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::ensurePrintDialogDefaults(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    if (!p)
        return E_POINTER;

    // If we already have default printer information, use it.
    if (_hDevNames && _hDevMode)
        *p = VB_TRUE;

    // Otherwise, go get it.        
    else
        GetPrintDialogSettings(FALSE, p);

    return S_OK;
}
STDMETHODIMP
CTemplatePrinter::showPrintDialog(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    if (!p)
        return E_POINTER;

    GetPrintDialogSettings(TRUE, p);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  (ITemplatePrinter) CTemplatePrinter::showPageSetupDialog
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTemplatePrinter::showPageSetupDialog(VARIANT_BOOL *p)
{   
    TEMPLATESECURITYCHECK();
    
    HRESULT             hr;
    HWND                hWnd;
    BOOL                fMetricUnits        = FALSE;
    IHTMLEventObj2      *pEvent             = NULL;     //  To populate with dialog parameters
    IDocHostUIHandler   *pUIHandler         = NULL;
    IOleCommandTarget   *pUICommandHandler  = NULL;
    HGLOBAL             hPageSetup          = NULL;
    PAGESETUPDLG *      ppagesetupdlg       = NULL;
    VARIANT             varIn;  

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    if (_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hPageSetup = ::GlobalAlloc(GHND, sizeof(PAGESETUPDLG));
    if (!hPageSetup)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ppagesetupdlg = (PAGESETUPDLG *)::GlobalLock(hPageSetup);
    if (!ppagesetupdlg)
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = InitDialog(&hWnd, &pEvent, &pUICommandHandler);
    if (hr)
        goto Cleanup;

    {
        //  Are we using metric or British (US) for margins?
        TCHAR           achLocale[32];
        int             iLocale = 32;
        fMetricUnits = (    GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IMEASURE, achLocale, iLocale)
                        &&  achLocale[0] == TCHAR('0'));
    }

    //  Now, initialize the event's type and expandos.
    {
        BSTR bstrTemp = SysAllocString( L"pagesetup" );
        VARIANT var;

        if (bstrTemp)
        {
            pEvent->put_type( bstrTemp );
            SysFreeString(bstrTemp);
        }

        V_VT(&var) = VT_PTR;
        V_BYREF(&var) = ppagesetupdlg;
        hr = pEvent->setAttribute(_T("pagesetupStruct"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)   = VT_BSTR;        
        bstrTemp = SysAllocString(_achHeader);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("pagesetupHeader"), var, 0);
            SysFreeString(bstrTemp);
        }

        bstrTemp = SysAllocString(_achFooter);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("pagesetupFooter"), var, 0);
            SysFreeString(bstrTemp);
        }
    }

    // Fill out PAGESETUPDLG structure    
    ::ZeroMemory(ppagesetupdlg, sizeof(PAGESETUPDLG));
    ppagesetupdlg->lStructSize    = sizeof(PAGESETUPDLG);
    ppagesetupdlg->hwndOwner      = hWnd;
    ppagesetupdlg->hDevMode       = _hDevMode;
    ppagesetupdlg->hDevNames      = _hDevNames;   
    ppagesetupdlg->Flags          |= PSD_DEFAULTMINMARGINS;    

    if (_ptPaperSize.x != -1)
    {
        ppagesetupdlg->ptPaperSize = _ptPaperSize;
    }
    if (_rcMargin.left != -1)
    {
        ppagesetupdlg->Flags |= PSD_MARGINS;
        ppagesetupdlg->rtMargin = _rcMargin;

        if (fMetricUnits)
        {
            // Margins from PrintInfoBag are in 1/100000" and need to be converted to 1/100 mm.
            ppagesetupdlg->rtMargin.left   = MulDivQuick(ppagesetupdlg->rtMargin.left  , 2540, 100000);
            ppagesetupdlg->rtMargin.right  = MulDivQuick(ppagesetupdlg->rtMargin.right , 2540, 100000);
            ppagesetupdlg->rtMargin.top    = MulDivQuick(ppagesetupdlg->rtMargin.top   , 2540, 100000);
            ppagesetupdlg->rtMargin.bottom = MulDivQuick(ppagesetupdlg->rtMargin.bottom, 2540, 100000);
        }
        else
        {
            // Margins from PrintInfoBag are in 1/100000" and need to be converted to 1/1000".
            ppagesetupdlg->rtMargin.left   = ppagesetupdlg->rtMargin.left   / 100;
            ppagesetupdlg->rtMargin.right  = ppagesetupdlg->rtMargin.right  / 100; 
            ppagesetupdlg->rtMargin.top    = ppagesetupdlg->rtMargin.top    / 100;
            ppagesetupdlg->rtMargin.bottom = ppagesetupdlg->rtMargin.bottom / 100;
        }
    }
  
    CommCtrlNativeFontSupport();

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pEvent;     

    // Query host to show dialog
    if (pUICommandHandler)
    {        
        // We may be marshalling this call across threads.  RPC doesn't allow VT_PTRs to cross threads.
        // We work around this by sticking the structure into a GHND contents and pass the VT_HANDLE.
        // We then delegate to the browse document, who will obtain a copy of the GHND pointer and use that for the VT_PTR
        // the struct. (CDoc::DelegateShowPrintingDialog)
        //
        // In theory, we could detect this by looking at the __IE_uPrintFlags to see if it is flagged synchronous to avoid playing with handles.
        // The downside: as with all dialogArguments, anyone could have mucked around with the flags)
        VARIANT var;
        V_VT(&var) = VT_HANDLE;
        V_BYREF(&var) = hPageSetup;
        pEvent->setAttribute(_T("hPageSetup"), var, 0);

        // Delegate call to browse Trident
        hr = pUICommandHandler->Exec(
                NULL,                       // For Trident
                OLECMDID_SHOWPAGESETUP,
                0,
                &varIn,
                NULL);               

        pEvent->removeAttribute(_T("hPageSetup"), 0, NULL);
    }

    if (   !pUICommandHandler
        ||  hr == OLECMDERR_E_NOTSUPPORTED 
        ||  hr == OLECMDERR_E_UNKNOWNGROUP
        ||  hr == E_FAIL
        ||  hr == E_NOTIMPL )
    {      
        ClearInterface(&pUICommandHandler);

        // Create backup UI Handler
        // (greglett) Cache this - CoCreate is expensive.
        hr = CoCreateInstance(CLSID_DocHostUIHandler,
              NULL,
              CLSCTX_INPROC_SERVER,
              IID_IDocHostUIHandler,
              (void**)&pUIHandler);
        if (!pUIHandler)
            goto Cleanup;

        hr = pUIHandler->QueryInterface(IID_IOleCommandTarget,(void**)&pUICommandHandler);        
        if (!pUICommandHandler)
            goto Cleanup;
        
        hr = pUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,        // For a dochost object
                OLECMDID_SHOWPAGESETUP,
                0,
                &varIn,
                NULL);
    }

    //  If the dialog was cancelled, or there was a problem showing the dialog,

    //  do not update values.
    if (hr)
        goto Cleanup;

    *p = VB_TRUE;       //  OK was pressed.
    
    //
    //  Retrieve page setup changes from the page setup dialog structure.
    //
    _hDevMode       = ppagesetupdlg->hDevMode;
    _hDevNames      = ppagesetupdlg->hDevNames;    
    GetDeviceProperties();

    if (fMetricUnits)
    {
        // Margins from Page Setup dialog are in 1/100 mm and need to be converted to 1/100000"
        _rcMargin.left   = MulDivQuick(ppagesetupdlg->rtMargin.left  , 100000, 2540);
        _rcMargin.right  = MulDivQuick(ppagesetupdlg->rtMargin.right , 100000, 2540);
        _rcMargin.top    = MulDivQuick(ppagesetupdlg->rtMargin.top   , 100000, 2540);
        _rcMargin.bottom = MulDivQuick(ppagesetupdlg->rtMargin.bottom, 100000, 2540);
    }
    else
    {
        // Margins from Page Setup dialog are in 1/1000" and need to be converted to 1/100000"
        _rcMargin.left   = ppagesetupdlg->rtMargin.left   * 100;
        _rcMargin.right  = ppagesetupdlg->rtMargin.right  * 100;
        _rcMargin.top    = ppagesetupdlg->rtMargin.top    * 100;
        _rcMargin.bottom = ppagesetupdlg->rtMargin.bottom * 100;
    }

    // (greglett)  99% of OS's use PSD_DEFAULTMINMARGINS to restrict the margins to the printable page area.    
    // NT4SP6 without the IE shell extensions doesn't.  So, we are forced to do more work for yet another violation of the API documentation.
    // Force margins to be at least as large as the unprintable region.
    // Do we want also to display an error message if they are different? (Otherwise, we change it, and the user doesn't see it.)
    if (_rcMargin.left < MulDivQuick(_rcUnprintable.left, 100000, _szResolution.cx))
        _rcMargin.left = MulDivQuick(_rcUnprintable.left, 100000, _szResolution.cx);
    if (_rcMargin.right < MulDivQuick(_rcUnprintable.right, 100000, _szResolution.cx))
        _rcMargin.right = MulDivQuick(_rcUnprintable.right, 100000, _szResolution.cx);
    if (_rcMargin.top < MulDivQuick(_rcUnprintable.top, 100000, _szResolution.cy))
        _rcMargin.top = MulDivQuick(_rcUnprintable.top, 100000, _szResolution.cy);
    if (_rcMargin.bottom < MulDivQuick(_rcUnprintable.bottom, 100000, _szResolution.cy))
        _rcMargin.bottom = MulDivQuick(_rcUnprintable.bottom, 100000, _szResolution.cy);

    //
    //  Read in Trident specific values from the page setup dialog
    //
    {
        VARIANT var;
        TCHAR   *pchTemp;

        if (    !pEvent->getAttribute(_T("pagesetupHeader"),0,&var)
            &&  var.vt == VT_BSTR
            &&  var.bstrVal)
        {
            pchTemp = var.bstrVal;
            _tcscpy(_achHeader, pchTemp);
            SysFreeString(var.bstrVal);
        }
        else
            _achHeader[0] = _T('\0');
        
        if (    !pEvent->getAttribute(_T("pagesetupFooter"),0,&var)
            &&  var.vt == VT_BSTR
            &&  var.bstrVal)

        {
            pchTemp = var.bstrVal;
            _tcscpy(_achFooter, pchTemp);
            SysFreeString(var.bstrVal);
        }
        else
            _achFooter[0] = _T('\0');
    }

    //
    //  Persist results of the page setup dialog out to the registry.
    //
    {                
        HKEY    keyPageSetup = NULL;
        if (GetRegPrintOptionsKey(PRINTOPTSUBKEY_PAGESETUP,&keyPageSetup) == ERROR_SUCCESS)
        {
            if (_fPersistHFToRegistry)
            {
                WriteHeaderFooterToRegistry(keyPageSetup);
            }
            WriteMarginsToRegistry(keyPageSetup);            
            RegCloseKey(keyPageSetup);
        }
    }

Cleanup:
    ReleaseInterface(pEvent);
    ReleaseInterface(pUIHandler);
    ReleaseInterface(pUICommandHandler);
    if (hPageSetup)
    {
        if (ppagesetupdlg)
            ::GlobalUnlock(hPageSetup);
        ::GlobalFree(hPageSetup);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetPrintDialogSettings
//
//  Synopsis : 'Finishes' the doc - takes pages printed via printPage and queues the job
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetPrintDialogSettings(BOOL fBotherUser, VARIANT_BOOL *pvarfOKOrCancel)
{
    HRESULT             hr;
    HWND                hWnd                = NULL;
    IHTMLEventObj2      *pEvent             = NULL;     //  To populate with dialog parameters
    IDocHostUIHandler   *pUIHandler         = NULL;
    IOleCommandTarget   *pUICommandHandler  = NULL;
    HGLOBAL             hPrint              = NULL;
    PRINTDLG *          pprintdlg           = NULL;
    VARIANT             varIn;              
    int                 nFontSize;
    void                *pDevMode           = NULL;

    if (pvarfOKOrCancel)
        *pvarfOKOrCancel = VB_FALSE;

    hPrint = ::GlobalAlloc(GHND, sizeof(PRINTDLG));
    if (!hPrint)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pprintdlg = (PRINTDLG *)::GlobalLock(hPrint);
    if (!pprintdlg)
    {   
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_hDC)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = InitDialog(&hWnd, &pEvent, &pUICommandHandler, &nFontSize);
    if (hr)
        goto Cleanup;

    // PrintDlgEx (only available NT5+) fails with a NULL HWND.
    // It is likely that the DHUI that raises the dialog will use PrintDlgEx (our default DHUI in shdocvw does).
    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  hWnd == NULL )
        hWnd = GetDesktopWindow();
   
    // PrintDlgEx (only available NT5+) fails with a NULL HWND.
    // It is likely that the DHUI that raises the dialog will use PrintDlgEx (our default DHUI in shdocvw does).
    if (    g_dwPlatformID == VER_PLATFORM_WIN32_NT
        &&  hWnd == NULL )
        hWnd = GetDesktopWindow();

    //  Now, initialize the event's type and expandos.
    {
        BSTR bstrTemp = SysAllocString( L"print" );
        VARIANT var;

        if (bstrTemp)
        {
            pEvent->put_type(bstrTemp);
            SysFreeString(bstrTemp);
        }
               
        V_VT(&var)   = VT_BOOL;
        V_BOOL(&var) = AreRatingsEnabled() ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfAreRatingsEnabled"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFramesetDocument ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfRootDocumentHasFrameset"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameActive ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfActiveFrame"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameActiveEnabled ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfActiveFrameEnabled"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fFrameAsShown ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfAsShown"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintAllLinkedDocuments ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfLinked"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintSelectionEnabled ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfSelection"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = _fPrintTableOfLinks ? VB_TRUE : VB_FALSE;
        hr = pEvent->setAttribute(_T("printfShortcutTable"), var, 0);
        if (hr)
            goto Cleanup;

        V_BOOL(&var) = VB_FALSE;
        hr = pEvent->setAttribute(_T("printToFileOk"),var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)  = VT_INT;
        V_INT(&var) = nFontSize;
        hr = pEvent->setAttribute(_T("printiFontScaling"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)    = VT_PTR;
        V_BYREF(&var) = pprintdlg;
        hr = pEvent->setAttribute(_T("printStruct"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)      = VT_UNKNOWN;
        V_UNKNOWN(&var) = NULL;
        hr = pEvent->setAttribute(_T("printpBodyActiveTarget"), var, 0);
        if (hr)
            goto Cleanup;

        V_VT(&var)   = VT_BSTR;        
        bstrTemp = SysAllocString(_achFileName);
        if (bstrTemp)
        {
            V_BSTR(&var) = bstrTemp;
            hr = pEvent->setAttribute(_T("printToFileName"), var, 0);
            SysFreeString(bstrTemp);
        }
    }
           
    //
    // Initialize the PRINTDLG structure
    //
    ::ZeroMemory(pprintdlg, sizeof(PRINTDLG));
    pprintdlg->lStructSize        = sizeof(PRINTDLG);
    pprintdlg->hwndOwner          = hWnd;       
    pprintdlg->hDevMode           = _hDevMode;
    pprintdlg->hDevNames          = _hDevNames;
    pprintdlg->nCopies            = _nCopies;
    pprintdlg->nFromPage          = _nPageFrom;
    pprintdlg->nToPage            = _nPageTo;
    pprintdlg->nMinPage           = 1;
    pprintdlg->nMaxPage           = 0xffff;
    pprintdlg->Flags              |= (_fPrintSelectionEnabled ? 0 : PD_NOSELECTION);
    pprintdlg->Flags              |= (_fCollate ? PD_COLLATE : 0);
    pprintdlg->Flags              |= (_fPrintSelectedPages ? PD_PAGENUMS : 0);
    pprintdlg->Flags              |= (_fPrintToFile ? PD_PRINTTOFILE : 0);
    pprintdlg->Flags              |= (_fCurrentPageAvail ? (_fPrintCurrentPage ? PD_CURRENTPAGE : 0) : PD_NOCURRENTPAGE);

    if (!fBotherUser)
    {
        // this indicates we only want to retrieve the defaults,
        // not to bring up the dialog
        pprintdlg->hDevMode     = NULL;
        pprintdlg->hDevNames    = NULL;
        pprintdlg->Flags        |= PD_RETURNDEFAULT;
    }

    CommCtrlNativeFontSupport();
    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = pEvent;

    // Query host to show dialog
    hr = E_FAIL;
    if (    pvarfOKOrCancel         // Don't delegate on the ::Init call.  Only delegate script calls.
        &&  pUICommandHandler)
    {        
        // We may be marshalling this call across threads.  RPC doesn't allow VT_PTRs to cross threads.
        // We work around this by sticking the structure into a GHND contents and pass the VT_HANDLE.
        // We then delegate to the browse document, who will obtain a copy of the GHND pointer and use that for the VT_PTR
        // the struct. (CDoc::DelegateShowPrintingDialog)
        //
        // In theory, we could detect this by looking at the __IE_uPrintFlags to see if it is flagged synchronous to avoid playing with handles.
        // The downside: as with all dialogArguments, anyone could have mucked around with the flags)
        VARIANT var;
        V_VT(&var) = VT_HANDLE;
        V_BYREF(&var) = hPrint;
        pEvent->setAttribute(_T("hPrint"), var, 0);

        // Delegate call to browse Trident
        hr = pUICommandHandler->Exec(
                NULL,                       // For Trident
                OLECMDID_SHOWPRINT,
                0,
                &varIn,
                NULL);               

        pEvent->removeAttribute(_T("hPrint"), 0, NULL);
    }

    if (    hr == OLECMDERR_E_NOTSUPPORTED 
        ||  hr == OLECMDERR_E_UNKNOWNGROUP
        ||  hr == E_FAIL
        ||  hr == E_NOTIMPL )
    {
        ClearInterface(&pUICommandHandler);

        // Create backup UI Handler
        // (greglett) Cache this - CoCreate is expensive.
        hr = CoCreateInstance(CLSID_DocHostUIHandler,
              NULL,
              CLSCTX_INPROC_SERVER,
              IID_IDocHostUIHandler,
              (void**)&pUIHandler);
        if (!pUIHandler)
            goto Cleanup;

        hr = pUIHandler->QueryInterface(IID_IOleCommandTarget,(void**)&pUICommandHandler);        
        if (!pUICommandHandler)
            goto Cleanup;

        hr = pUICommandHandler->Exec(
                &CGID_DocHostCommandHandler,
                OLECMDID_SHOWPRINT,
                0,
                &varIn,
                NULL);

    }
      

    //  If the dialog was cancelled, or there was a problem showing the dialog,
    //  do not update values.
    if (FAILED(hr))
        goto Cleanup;

    // this can be false because either init failed for no installed printer
    //  or the user clicked cancel.
    if (hr==S_FALSE)
    {
        // Three cases:
        //   fBotherUser   *pvarfOkOrCancel
        //        1               1			fBotherUser && varfOkOrCancel  - We are being called from script.  We tried to raise a dialog, and
        //                                  failed or were cancelled - UI has been displayed in the former case.
        //        0               1         We are being called from script.  We tried to get default printer info
        //                                  and failed - this is probably because no default it set.  As we used
        //                                  to, we need to raise the dialog (despite the fBotherUser) to get enough info.
        //        0               0         We are being called from the init, with no default printer.  We will continue
        //                                  through the procedure to get defaults.
        //        1               0         Never occurs.
        Assert(!(!pvarfOKOrCancel && fBotherUser));
        if (fBotherUser)
        {
            hr = S_OK;
            goto Cleanup;
        }
        else if (pvarfOKOrCancel)
        {
            hr = GetPrintDialogSettings(TRUE, pvarfOKOrCancel);
            goto Cleanup;
        }
        // Otherwise, we need to set the default values.
        else
            hr = S_OK;
    }
    else if (pvarfOKOrCancel)
        *pvarfOKOrCancel = VB_TRUE;       //  OK was pressed.

    //
    //  Take base print dialog return values and store them.
    //
    _hDevMode               = pprintdlg->hDevMode;
    _hDevNames              = pprintdlg->hDevNames;
    _nCopies                = (fBotherUser) ? pprintdlg->nCopies : 1; // bug in printDLG
    _nPageFrom              = pprintdlg->nFromPage;
    _nPageTo                = pprintdlg->nToPage;
    _fPrintSelectedPages    = (!!(pprintdlg->Flags & PD_PAGENUMS));
    _fPrintSelection        = (!!(pprintdlg->Flags & PD_SELECTION));
    _fCollate               = (!!(pprintdlg->Flags & PD_COLLATE));
    _fPrintToFile           = (!!(pprintdlg->Flags & PD_PRINTTOFILE));
    _fPrintCurrentPage      = (!!(pprintdlg->Flags & PD_CURRENTPAGE));

    // Collate/Copy information is in both the struct and the DEVMODE.
    // The DEVMODE bits instruct the printer to do its own copy/collate information.
    // This means that only one copy of the document is uploaded to the printer/server, and the printer itself does the replication/duplex work.
    if (_hDevMode)
    {
        pDevMode  = ::GlobalLock(_hDevMode);       
        if (pDevMode)
        {
            // (greglett) DEVMODE is returned A on Win9x platforms, not W.  <sigh>
            if (g_fUnicodePlatform)
            {
                if (((DEVMODEW *)pDevMode)->dmFields & DM_COLLATE)
                    _fCollate = (((DEVMODEW *)pDevMode)->dmCollate == DMCOLLATE_TRUE) || _fCollate;
                if (    ((DEVMODEW *)pDevMode)->dmFields & DM_COPIES
                    &&  ((DEVMODEW *)pDevMode)->dmCopies > _nCopies )
                    _nCopies  = ((DEVMODEW *)pDevMode)->dmCopies;
            }
            else
            {
                if (((DEVMODEA *)pDevMode)->dmFields & DM_COLLATE)
                    _fCollate = (((DEVMODEA *)pDevMode)->dmCollate == DMCOLLATE_TRUE) || _fCollate;
                if (    ((DEVMODEA *)pDevMode)->dmFields & DM_COPIES
                    &&  ((DEVMODEA *)pDevMode)->dmCopies > _nCopies )
                    _nCopies  = ((DEVMODEA *)pDevMode)->dmCopies;
            }
            ::GlobalUnlock(_hDevMode);        
        }
    }

    GetDeviceProperties();

    //  Read in changes to the Trident specific print options.
    {
        VARIANT var;
        // Read changed values from event object
        if (!pEvent->getAttribute(_T("printfLinked"),0,&var))
        {
            Assert(var.vt == VT_BOOL);
            _fPrintAllLinkedDocuments = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfActiveFrame"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fFrameActive = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfAsShown"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fFrameAsShown = var.boolVal;
        }

        if (!pEvent->getAttribute(_T("printfShortcutTable"), 0, &var))
        {
            Assert(var.vt == VT_BOOL);
            _fPrintTableOfLinks = var.boolVal;
        }
    }

    if (_fPrintToFile)
    {
        // assume failure, treating as canceling
        VARIANT var;
        hr = S_FALSE;
    
        if (    !pEvent->getAttribute(_T("printToFileOK"), 0, &var)
            &&  var.boolVal)
        {
            if (    !pEvent->getAttribute(_T("printToFileName"), 0, &var)
                &&  var.vt == VT_BSTR)
            {                                              
                TCHAR * pchFullPath = var.bstrVal;
                _tcscpy(_achFileName, pchFullPath);
                SysFreeString(var.bstrVal);

                //  (greglett)  Code used to update Trident's default save path here. (pre 5.5)
                //  Not being internal, we can't do that anymore.
                hr = S_OK;
            }
        }

        if (hr != S_OK)
           *pvarfOKOrCancel = VB_FALSE;
    }

Cleanup:      
    ReleaseInterface(pUIHandler);
    ReleaseInterface(pUICommandHandler);
    ReleaseInterface(pEvent);
    if (hPrint)
    {
        if (pprintdlg)
            ::GlobalUnlock(hPrint);
        ::GlobalFree(hPrint);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::InitDialog
//  
//  Synopsis : Does all the COM schtick to get the appropriate interfaces to show
//             a dialog.
//
//  Parameters:  hWnd: Will try to fill with Trident's hWnd.  May return as NULL with S_OK.
//               ppEventObj2:  Will create an IHTMLEventObj2.  Must be created if S_OK is returned.
//               ppUIHandler:  Will return Trident's UI Handler.  May return NULL with S_OK.
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::InitDialog(HWND *phWnd, IHTMLEventObj2 **ppEventObj2, IOleCommandTarget **ppUIHandler, int *pnFontScale)
{
    HRESULT              hr;
    IHTMLElement        *pElement           = NULL;
    IDispatch           *pDispatch          = NULL;
    IHTMLDocument2      *pDoc               = NULL;
    IOleWindow          *pDocWin            = NULL;
    IHTMLEventObj       *pEventObj          = NULL;
    VARIANT              varHost;

    Assert(phWnd);
    Assert(ppEventObj2);
    Assert(ppUIHandler);

    VariantInit(&varHost);

    *phWnd = NULL;
    *ppEventObj2 = NULL;
    *ppUIHandler = NULL;
    if (pnFontScale)
        *pnFontScale = 2;

    if (!_pPeerSiteOM)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!phWnd || !ppEventObj2 || !ppUIHandler)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = _pPeerSite->GetElement(&pElement);
    if (hr)
        goto Cleanup;
    Assert(pElement);

    hr = pElement->get_document(&pDispatch);
    if (hr)
        goto Cleanup;
    Assert(pDispatch);

    hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void**) &pDoc);
    if (hr)
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IOleWindow, (void **)&pDocWin);
    if (!hr)
    {
        Assert(pDocWin);
        pDocWin->GetWindow(phWnd);
    }

    // Create an event object to pass to our host with the print information
    hr = _pPeerSiteOM->CreateEventObject(&pEventObj);
    if (hr)
        goto Cleanup;
    Assert(pEventObj);

    // Now get the appropriate interface to populate the event object with parameters
    // for the dialog.
    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)ppEventObj2);
    if (hr)
        goto Cleanup;
    Assert(ppEventObj2);

    //  Get the instance of the Trident Host UI browse document, if it exists.
    //  We use this to delegate to our host.
    if (   GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) == S_OK
        && V_VT(&varHost) == VT_UNKNOWN
        && V_UNKNOWN(&varHost) ) 
    {
        hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)ppUIHandler);
        Assert(*ppUIHandler);        
    }

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pDoc);    
    ReleaseInterface(pDocWin);
    ReleaseInterface(pEventObj);
    VariantClear(&varHost);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReturnPrintHandles
//
//  Synopsis : Show our print handles to the browse instance of Trident.
//
//-----------------------------------------------------------------------------
void
CTemplatePrinter::ReturnPrintHandles()
{
    HRESULT hr;
    VARIANT             varHost;
    VARIANT             varIn;
    SAFEARRAYBOUND      sabound;
    IOleCommandTarget * pioct   = NULL;
    SAFEARRAY         * psa     = NULL;
    long                lArg    = 0;

    VariantInit(&varHost);
    VariantInit(&varIn);

    if (!_hDevNames || !_hDevMode)
        goto Cleanup;   

    //
    // Get handle back to the browse document to update its print handles.
    //
    if (    GetDialogArgument(&varHost, PRINTARG_BROWSEDOC) != S_OK
        ||  V_VT(&varHost) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varHost) )
        goto Cleanup;
           
    hr = V_UNKNOWN(&varHost)->QueryInterface(IID_IOleCommandTarget, (void **)&pioct);
    if (hr)
        goto Cleanup;
    Assert(pioct);

    //
    // Create a SAFEARRAY filled with our two print handles { DEVNAMES, DEVMODE }
    //
    sabound.cElements   = 2;
    sabound.lLbound     = 0;
    psa = SafeArrayCreate(VT_HANDLE, 1, &sabound);
    if (!psa)
        goto Cleanup;

    //
    // Bundle the array in the Exec argument...
    //
    V_VT(&varIn) = VT_ARRAY | VT_HANDLE;
    V_ARRAY(&varIn) = psa;

    if (    SafeArrayPutElement(psa, &lArg, &_hDevNames) != S_OK
        ||  SafeArrayPutElement(psa, &(++lArg), &_hDevMode) != S_OK )
    {
        goto Cleanup;
    }
       
    //
    // Actually make the call, passing our handles to the browse instance
    //
    pioct->Exec( &CGID_MSHTML,
                  IDM_SETPRINTHANDLES,
                  NULL, 
                  &varIn, 
                  NULL);

Cleanup:
    VariantClear(&varIn);       // Destroys SAFEARRAY.
    VariantClear(&varHost);
    ReleaseInterface(pioct);
    return;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetDialogArgument
//
//  Synopsis : The dialogArgument on the attached print template has several important expandos.
//             This function gets the dialogArguments and caches a ptr to it.
//
//  Returens:  S_OK:    dlgArgs saved
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDialogArguments()
{
    HRESULT             hr;
    IHTMLElement        *pElement       = NULL;
    IDispatch           *pDispatch      = NULL;
    IServiceProvider    *pIDocSrvProv   = NULL;
    IHTMLDialog         *pIHTMLDialog   = NULL; 
    VARIANT              varDlgArgs;

    Assert(_pPeerSite);
    VariantInit(&varDlgArgs);

    hr = _pPeerSite->GetElement(&pElement);
    if (hr)
        goto Cleanup;
    Assert(pElement);

    hr = pElement->get_document(&pDispatch);
    if (hr)
        goto Cleanup;
    Assert(pDispatch);

    hr = pDispatch->QueryInterface(IID_IServiceProvider, (void **)&pIDocSrvProv);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDocSrvProv);
    
    hr = pIDocSrvProv->QueryService(IID_IHTMLDialog, IID_IHTMLDialog, (void**)&pIHTMLDialog);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIHTMLDialog);

    hr = pIHTMLDialog->get_dialogArguments(&varDlgArgs);
    if (hr)
        goto Cleanup;

    if (    V_VT(&varDlgArgs) != VT_UNKNOWN
        ||  !V_UNKNOWN(&varDlgArgs) )
    {
        hr = E_FAIL;    // Major badness.  This MUST be there.
        goto Cleanup;
    }

    hr = V_UNKNOWN(&varDlgArgs)->QueryInterface(IID_IHTMLEventObj2, (void**)&_pevDlgArgs);
    if (hr)
        goto Cleanup;
    Assert(_pevDlgArgs);

Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pDispatch);
    ReleaseInterface(pIDocSrvProv);
    ReleaseInterface(pIHTMLDialog);
    VariantClear(&varDlgArgs);

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::GetDialogArgument
//
//  Synopsis : The dialogArgument on the attached print template has several important expandos.
//             Function gets the expando specified by the argument enum
//
//  Returens:  S_OK:    expando obtained (might be VT_NULL or VT_EMPTY)
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDialogArgument(VARIANT *pvar, PRINTARG eArg)
{
    HRESULT              hr             = S_OK;    
    BSTR                 bstrTarget     = NULL; 

    Assert(pvar);
    Assert(eArg >= 0 && eArg < PRINTTYPE_LAST);

    // (greglett) TODO: Implement a caching system for these args.  We access some of
    //            often, and shouldn't do the (potentially) cross-thread OLE each time.

    if (!_pevDlgArgs)
        return E_FAIL;

    VariantClear(pvar);

    bstrTarget = SysAllocString(s_aachPrintArg[eArg]);
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pevDlgArgs->getAttribute(bstrTarget, 0, pvar);

Cleanup:
    SysFreeString(bstrTarget);

    return hr;        
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::RemoveDialogArgument
//
//  Synopsis : Remove the dialogArgument specified byt he argument enum.
//
//  Returens:  S_OK:    expando obtained (might be VT_NULL or VT_EMPTY)
//             E_*:     Error encounterd
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::RemoveDialogArgument(PRINTARG eArg)
{
    HRESULT              hr             = S_OK;    
    BSTR                 bstrTarget     = NULL; 
    VARIANT_BOOL         fSuccess;

    Assert(eArg >= 0 && eArg > PRINTTYPE_LAST);

    if (!_pevDlgArgs)
        return E_FAIL;

    bstrTarget = SysAllocString(s_aachPrintArg[eArg]);
    if (!bstrTarget)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pevDlgArgs->removeAttribute(bstrTarget, 0, &fSuccess);

Cleanup:
    SysFreeString(bstrTarget);

    return hr;        
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::EnsureMLLoadLibrary
//
//  Synopsis : Ensure the library with the default header/footer/margins has
//             been loaded and return it.
//
//-----------------------------------------------------------------------------
HINSTANCE
CTemplatePrinter::EnsureMLLoadLibrary()
{
    if (!_hInstResource)
    {
        _hInstResource = MLLoadLibrary(_T("shdoclc.dll"), NULL, ML_CROSSCODEPAGE);
        Assert(_hInstResource && "Resource DLL is not loaded!");
    }

    return _hInstResource;
}


//+----------------------------------------------------------------------
//
//  Function:   CTemplatePrinter::GetDefaultMargin
//
//  Purpose:    Get default values for the margin from
//                  (1) The registry
//                  (2) The resource DLL
//                  (3) Arbitrary, hard-coded values.
//
//  Parameters  keyOldValues    registry key for the margins or NULL
//              pMarginName     "margin_top", "margin_bottom", &c...
//              pMarginValue    buffer for value
//              cchMargin        length of the buffer in TCHARs
//              dwMarginConst   const for getting the margin from the resource file
//-----------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultMargin(HKEY keyOldValues, TCHAR* pMarginName, TCHAR* pMarginValue, DWORD cchMargin, DWORD dwMarginConst)
{
    HRESULT hr = E_FAIL;
    DWORD   cchLen;
    Assert(pMarginName);
    Assert(pMarginValue);
    Assert(cchMargin > 0);

    //  First try the passed registry key.
    if (keyOldValues != NULL)
    {
        hr = ReadSubkeyFromRegistry(keyOldValues, pMarginName, pMarginValue, cchMargin);
    }

    //  Next try the resource file.
    if (hr)
    {
        cchLen = ::LoadString(EnsureMLLoadLibrary(), dwMarginConst, pMarginValue, cchMargin);
        if (cchLen > 0)
            hr = ERROR_SUCCESS;
    }

    // Lastly, just do hardcoded values.
    if (hr)
    {
        cchLen = _tcslen(_T("0.750000")) + 1;
        if (cchLen <= cchMargin)
        {
            _tcscpy(pMarginValue,_T("0.750000"));
            hr = ERROR_SUCCESS;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDefaultHeaderFooter
//
//  Purpose:    Get default values for the header/footer from
//                  (1) The registry
//                  (2) The resource DLL
//                  (3) Arbitrary, hard-coded values.
//
//  Arguments:  keyOldValues       If Not Null try to read from the IE3 defaults, If NULL or the read
//                                 was not successfull, get it from the resources
//              pValueName         "header" or "footer"
//              pDefault           ptr to the default header or footer
//              cbDefault          size of the array to hold the header-footer (in TCHAR)
//              pDefaultLiteral    default value if there is no def. in resources
//
//  Returns :   None
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultHeaderFooter(HKEY keyOldValues,
                       TCHAR* pValueName,
                       TCHAR* pDefault,
                       DWORD  cchDefault,
                       DWORD  dwResourceID,
                       TCHAR* pDefaultLiteral)
{
    HRESULT hr      = E_FAIL;

    Assert(pValueName);
    Assert(pDefault);
    Assert(pDefaultLiteral);
    Assert(cchDefault > 0);

    //  Try registry for a left/right header/footer first.
    if (keyOldValues != NULL)
    {
        TCHAR   achName[32];
        TCHAR   achLeft [MAX_DEFAULTHEADFOOT] = _T("");
        TCHAR   achRight[MAX_DEFAULTHEADFOOT] = _T("");
        TCHAR   achSeparator[3]               = _T("&b");
        DWORD   cchTotal  = 0;

        _tcscpy(achName,pValueName);
        _tcscat(achName,_T("_left"));
        if (!ReadSubkeyFromRegistry(keyOldValues, achName, achLeft, MAX_DEFAULTHEADFOOT))
            cchTotal += _tcslen(achLeft);

        _tcscpy(achName,pValueName);
        _tcscat(achName,_T("_right"));
        if (!ReadSubkeyFromRegistry(keyOldValues, achName, achRight, MAX_DEFAULTHEADFOOT))
            cchTotal += _tcslen(achRight);

        if (cchTotal)
        {
            // Include the null - add it in.
            cchTotal += _tcslen(achSeparator) + 1;
            if (cchTotal <= cchDefault)
            {
                _tcscpy(pDefault,achLeft);
                _tcscat(pDefault,achSeparator);
                _tcscat(pDefault,achRight);
                hr = ERROR_SUCCESS;
            }
        }    
    }

    // Concatenate the left/right if it exists and return it.
    if (hr)
    {
        DWORD cchLen;
        cchLen = ::LoadString(EnsureMLLoadLibrary(), dwResourceID, pDefault, cchDefault);
        if (cchLen > 0)
            hr = ERROR_SUCCESS;
    }


    //  Otherwise, use the passed default value.
    if (hr)
    {
        if (_tcslen(pDefaultLiteral) + 1 <= cchDefault)
        {
            _tcscpy(pDefault, pDefaultLiteral);
            hr = ERROR_SUCCESS;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDefaultPageSetupValues
//
//  Synopsis:   Try to get the old page setup values from HKEY_LOCAL_MACHINE. If found copies them into
//              HKEY_CURRENT_USER, if not, copies the default values
//
//  Arguments:  None
//
//  Returns :   S_OK or E_FAIL
//
//  Summary :   ---
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDefaultPageSetupValues(HKEY keyExplorer,HKEY * pKeyPrintOptions)
{
    TCHAR   achDefaultHeader[MAX_DEFAULTHEADFOOT];
    TCHAR   achDefaultFooter[MAX_DEFAULTHEADFOOT];
    TCHAR   achDefaultMarginTop    [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginBottom [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginLeft   [MAX_MARGINLENGTH];
    TCHAR   achDefaultMarginRight  [MAX_MARGINLENGTH];
    HKEY    keyOldValues;
    HRESULT hr = S_OK;

    if (!pKeyPrintOptions)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Check the default machine registry values
    if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     _T("Software\\Microsoft\\Internet Explorer\\PageSetup"),0,
                     KEY_ALL_ACCESS,
                     &keyOldValues) != ERROR_SUCCESS)
    {
        keyOldValues = NULL;
    }
    
    GetDefaultHeaderFooter(keyOldValues, _T("header"), (TCHAR*)&achDefaultHeader, MAX_DEFAULTHEADFOOT, IDS_DEFAULTHEADER, _T("&w&bPage &p of &P"));
    GetDefaultHeaderFooter(keyOldValues, _T("footer"), (TCHAR*)&achDefaultFooter, MAX_DEFAULTHEADFOOT, IDS_DEFAULTFOOTER, _T("&u&b&d"));
    GetDefaultMargin(keyOldValues, _T("margin_bottom"), (TCHAR*)&achDefaultMarginBottom, MAX_MARGINLENGTH, IDS_DEFAULTMARGINBOTTOM);
    GetDefaultMargin(keyOldValues, _T("margin_top"),    (TCHAR*)&achDefaultMarginTop,    MAX_MARGINLENGTH, IDS_DEFAULTMARGINTOP);
    GetDefaultMargin(keyOldValues, _T("margin_left"),   (TCHAR*)&achDefaultMarginLeft,   MAX_MARGINLENGTH, IDS_DEFAULTMARGINLEFT);
    GetDefaultMargin(keyOldValues, _T("margin_right"),  (TCHAR*)&achDefaultMarginRight,  MAX_MARGINLENGTH, IDS_DEFAULTMARGINRIGHT);

    ::RegCloseKey(keyOldValues);
    keyOldValues = NULL;

    //  Create the new user registry key
    if (::RegCreateKeyEx(keyExplorer,
                   _T("PageSetup"),
                   0,
                   NULL,
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   NULL,
                   pKeyPrintOptions,
                   NULL) == ERROR_SUCCESS)
    {       
        //  Put our default values into registry keys.
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("header"),         achDefaultHeader);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("footer"),         achDefaultFooter);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_bottom"),  achDefaultMarginBottom);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_left"),    achDefaultMarginLeft);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_right"),   achDefaultMarginRight);
        WriteSubkeyToRegistry(*pKeyPrintOptions, _T("margin_top"),     achDefaultMarginTop);
    };

Cleanup:    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetRegPrintOptionsKey
//
//  Synopsis:   Get handle of requested key under \HKCU\Software\Microsoft\Internet Explorer
//
//  Arguments:  PrintSubKey      - subkey of printoptions root to return key for
//              pKeyPrintOptions - ptr to handle of requested key in registry
//
//  Returns :   S_OK or E_FAIL
//
//  Summary :   First it tries to get the values from "new place"
//              HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\PageSetup
//              If there is no such a key, it creates it and tries to get the values from "old place"
//              HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\PageSetup
//              If successful it copies the values into the "new place"
//              If not, it tries to get the values from the registry,
//              If no luck, it uses the hardcoded strings
//              NOTE : If the procedure returns with S_OK, it guaranties that they will be a
//              "new place" with values.
//
//----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetRegPrintOptionsKey(PRINTOPTIONS_SUBKEY PrintSubKey, HKEY * pKeyPrintOptions)
{
    HKEY     keyExplorer;
    HRESULT  hr = E_FAIL;

    if (RegOpenKeyEx(
                HKEY_CURRENT_USER,
                _T("Software\\Microsoft\\Internet Explorer"),
                0,
                KEY_ALL_ACCESS,
                &keyExplorer) == ERROR_SUCCESS)
    {
        LPTSTR szSubKey = (PrintSubKey == PRINTOPTSUBKEY_MAIN
                            ? _T("Main")
                            : _T("PageSetup"));

        if (RegOpenKeyEx(keyExplorer,
                         szSubKey,
                         0,
                         KEY_ALL_ACCESS,
                         pKeyPrintOptions) == ERROR_SUCCESS)
        {
            if (PrintSubKey == PRINTOPTSUBKEY_PAGESETUP)
            {
                //
                //  For the PageSetup key, we do some additional checks to make
                //  sure that (at least) the header and footer keys exist.
                //

                DWORD dwT;

                if (    (RegQueryValueEx(*pKeyPrintOptions, _T("header"), 0, NULL, NULL, &dwT) == ERROR_SUCCESS)
                    &&  (RegQueryValueEx(*pKeyPrintOptions, _T("footer"), 0, NULL, NULL, &dwT) == ERROR_SUCCESS))
                {
                    // the header and footer keys exist, we're fine
                    hr = S_OK;
                }
                else
                {
                    // whoops.  fall back...
                    hr = GetDefaultPageSetupValues(keyExplorer, pKeyPrintOptions);
                }
            }
            else
                hr = S_OK;
        }
        else
        {
            //  For page setup, if we don't have default values, create them.
            if (PrintSubKey == PRINTOPTSUBKEY_PAGESETUP)
            {
                hr = GetDefaultPageSetupValues(keyExplorer, pKeyPrintOptions);
            }
        }

        RegCloseKey(keyExplorer);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadBoolFromRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and returns the
//             value as a boolean.
//
//-----------------------------------------------------------------------------
BOOL
CTemplatePrinter::ReadBoolFromRegistry(HKEY hKey, TCHAR *pSubkeyName)
{
    TCHAR   achBool[MAX_DEFAULTBOOL];
    BOOL    fRet = FALSE;
    achBool[0] = '\0';

    if (!ReadSubkeyFromRegistry(hKey, pSubkeyName, achBool, MAX_DEFAULTBOOL))
    {
        fRet = !_tcsicmp(achBool, _T("yes"));
    }

    return fRet;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::AreRatingsEnabled
//
//  Synopsis : Checks MS_RATING.DLL to see if ratings are enabled.
//
//-----------------------------------------------------------------------------
BOOL
CTemplatePrinter::AreRatingsEnabled()
{
    BOOL fRet = FALSE;

    typedef HRESULT (STDAPICALLTYPE *PFN)(void);
    
    if (!_hInstRatings)
        LoadLibrary("MSRATING.DLL", &_hInstRatings);

    if (_hInstRatings)
    {
        PFN     pfn;
        pfn = (PFN) ::GetProcAddress(_hInstRatings, "RatingEnabledQuery");
        if (!pfn)
        {
            goto Cleanup;
        }

        fRet = !pfn() ? TRUE: FALSE;
    }

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::DecimalTCHARToMargin
//
//  Synopsis : Takes a decimal representation in 1" and returns a long
//             with that value in 1/100000"
//
//-----------------------------------------------------------------------------
long
CTemplatePrinter::DecimalTCHARToFixed(TCHAR* pString, int nPowersOfTen)
{
    TCHAR* p = pString;
    int    iLen = _tcslen(pString);
    int    i;
    int    j = 0;
    int    iChar = 0;
    long   nRet = 0;

    if (pString == NULL)
        goto Cleanup;

    // Clear leading whitespace
    for (i=0;i<iLen;i++,p++)
        if (*p != _T(' '))
            break;
    
    // Do the integer part    
    for (;i<iLen;i++,p++)
    {
        iChar = *p;
        if ((iChar < _T('0')) || (iChar > _T('9')))
            break;
        nRet = nRet * 10 + (iChar - _T('0'));
    }

    if (iChar == _T('.'))
    {
        // Do the decimal part.
        for (i++,p++; (i+j<iLen && j<5); j++,p++)
        {
            iChar = *p;
            if ((iChar < _T('0')) || (iChar > _T('9')))
                break;
            nRet = nRet * 10 + (iChar - _T('0'));
        }
    }
    
    //  Make sure we are in 1/100000"
    for (;j < nPowersOfTen; j++)
        nRet *= 10;

Cleanup:
    return nRet;
}

BOOL
CTemplatePrinter::CommCtrlNativeFontSupport()
{
    BOOL    fRet = FALSE;    
    typedef BOOL (APIENTRY *PFN)(LPINITCOMMONCONTROLSEX);

    if (!_hInstComctl32)
        LoadLibrary("COMCTL32.DLL", &_hInstComctl32);

    if (_hInstComctl32)
    {
        INITCOMMONCONTROLSEX icc;
        PFN     pfn;

        pfn = (PFN) ::GetProcAddress(_hInstComctl32, "InitCommonControlsEx");
        if (!pfn)
        {
            goto Cleanup;
        }

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS;        

        fRet = pfn(&icc);
    }

Cleanup:
    return fRet;
}


//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::WriteFixedToRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and writes the
//              passed value to the resulting registry key in whole units.
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::WriteFixedToRegistry(HKEY hKeyPS, const TCHAR* pValueName,LONG nMargin, int nFactor)
{
    TCHAR   achFixed[MAX_MARGINLENGTH];

    //  Convert 1/100000" units to a TCHAR representation of decimal in 1" units.
    FixedToDecimalTCHAR(nMargin, achFixed, nFactor);

    return WriteSubkeyToRegistry(hKeyPS, pValueName, achFixed);
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadFixedFromRegistry
//
//  Synopsis : Takes an open registry key and subkey name, and gets a fixed point value
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadFixedFromRegistry(HKEY hKeyPS, const TCHAR *pValueName, LONG *pFixed, int nPowersOfTen)
{
    HRESULT hr;
    TCHAR   achFixed[MAX_MARGINLENGTH];
    achFixed[0] = '\0';

    Assert(pValueName);
    Assert(pFixed);
    
    *pFixed = 0;

    hr = ReadSubkeyFromRegistry(hKeyPS, pValueName, achFixed, MAX_MARGINLENGTH);
    if (!hr)
        *pFixed = DecimalTCHARToFixed(achFixed, nPowersOfTen);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadDeviceUnicode
//
//  Synopsis : Creates device information given the printer name, 
//
//-----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadDeviceUnicode(TCHAR *pchPrinter, TCHAR *pchDriver, TCHAR *pchPort)
{
    HRESULT             hr          = S_OK;
    HANDLE              hPrinter    = NULL;
    PRINTER_INFO_2 *    pPrintInfo  = NULL;
    Assert(pchPrinter);

    if (    ::OpenPrinter(pchPrinter, &hPrinter, NULL)
        &&  hPrinter)
    {
        DWORD               nStructSize;

        if (!pchDriver || !pchPort)
        {

            ::GetPrinter(hPrinter, 2, NULL, 0, &nStructSize);
            pPrintInfo = (PRINTER_INFO_2 *) ::GlobalAlloc(GPTR, nStructSize);           
            if (!pPrintInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (!::GetPrinter(hPrinter, 2, (byte *)pPrintInfo, nStructSize, &nStructSize))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        hr = CreateDevNames(pchDriver ? pchDriver : pPrintInfo->pDriverName,
                            pchPrinter,
                            pchPort ? pchPort : pPrintInfo->pPortName,
                            &_hDevNames);
        if (hr)
            goto Cleanup;

        nStructSize = ::DocumentProperties(0, hPrinter, pchPrinter, NULL, NULL, 0);
        if (nStructSize < sizeof(DEVMODE))
        {
            Assert(!"Memory size suggested by DocumentProperties is smaller than DEVMODE");
            nStructSize = sizeof(DEVMODE);
        }

        _hDevMode = ::GlobalAlloc(GHND, nStructSize);
        if (_hDevMode)
        {
            DEVMODE *pDevMode = (DEVMODE *) ::GlobalLock(_hDevMode);

            if (pDevMode)
            {
                ::DocumentProperties(0, hPrinter, pchPrinter, pDevMode, NULL, DM_OUT_BUFFER);

                pDevMode->dmFields &= ~DM_COLLATE;
                pDevMode->dmCollate = DMCOLLATE_FALSE;

                ::GlobalUnlock(_hDevMode);
            }
            else
            {
                ::GlobalFree(_hDevMode);
                _hDevMode = NULL;
            }
        }
    }

Cleanup:
    if (hPrinter)
        ::ClosePrinter(hPrinter);        
    if (pPrintInfo)
       ::GlobalFree(pPrintInfo);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CTemplatePrinter::ReadDeviceNonUnicode
//
//  Synopsys : Because non-Unicode platforms (Win9x) don't properly implement
//             many of the printing widechar calls, they need to explicitly
//             make multibyte (A) calls.
//
//+----------------------------------------------------------------------------
HRESULT
CTemplatePrinter::ReadDeviceNonUnicode(TCHAR *pchPrinterWide, TCHAR *pchDriverWide, TCHAR *pchPortWide)
{
    HRESULT             hr                  = S_OK;
    HANDLE              hPrinter            = NULL;
    LPSTR               pchPrinter          = NULL;
    TCHAR *             pchDriverWideLocal  = NULL;
    TCHAR *             pchPortWideLocal    = NULL;
    PRINTER_INFO_2A *   pPrintInfo          = NULL;

    Assert(pchPrinterWide);
    
    pchPrinter = InitMultiByteFromWideChar(pchPrinterWide);
    if (!pchPrinter)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (    ::OpenPrinterA(pchPrinter, &hPrinter, NULL)
        &&  hPrinter    )
    {
        DWORD   nStructSize;
        
        if (!pchDriverWide || !pchPortWide)
        {
            ::GetPrinterA(hPrinter, 2, NULL, 0, &nStructSize);

            pPrintInfo = (PRINTER_INFO_2A *)::GlobalAlloc(GPTR, nStructSize);           
            if (!pPrintInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            if (!::GetPrinterA(hPrinter, 2, (byte *)pPrintInfo, nStructSize, &nStructSize))
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            pchDriverWideLocal  = InitWideCharFromMultiByte(pPrintInfo->pDriverName);
            pchPortWideLocal    = InitWideCharFromMultiByte(pPrintInfo->pPortName);
        }

        hr = CreateDevNames(pchDriverWide ? pchDriverWide : pchDriverWideLocal,
                            pchPrinterWide,
                            pchPortWide ? pchPortWide : pchPortWideLocal,
                            &_hDevNames);
        if (hr)
            goto Cleanup;

        // NB (105850) (mikhaill) -- Windows Millennium's routine DocumentPropertiesA()
        // impudently changes processor state. This happens just once after
        // reboot and cause, in particular, unmasking floating point exception flags.
        // At some later moment processor meet any suspicious condition (overflow,
        // underflow, zero-divide, precision loose, etc) in some innocent routine,
        // generates unhandled exception and eventually crashes.
        // The following fsave/frstor pair is an ugly patch that should be removed
        // after millennium bug fix.
        // Windows Millennium build versions tested: 4.90.2485, 4.90.2491.
#ifdef _M_IX86
    {
        FLOATING_SAVE_AREA fsa;
        _asm fsave fsa;
#endif //_M_IX86
        nStructSize = ::DocumentPropertiesA(0, hPrinter, pchPrinter, NULL, NULL, 0);
#ifdef _M_IX86
        _asm frstor fsa;
    }
#endif //_M_IX86
        
        if (nStructSize < sizeof(DEVMODEA))
        {
            Assert(!"Memory size suggested by DocumentProperties is smaller than DEVMODEA");
            nStructSize = sizeof(DEVMODEA);
        }

        _hDevMode = ::GlobalAlloc(GHND, nStructSize);
        if (_hDevMode)
        {
            DEVMODEA *pDevMode = (DEVMODEA *) ::GlobalLock(_hDevMode);

            if (pDevMode)
            {
                // NB (109499) same as 105850 above
                // but appeared in Windows98 (mikhaill 5/7/00)
#ifdef _M_IX86
    {
        FLOATING_SAVE_AREA fsa;
        _asm fsave fsa;
#endif //_M_IX86
                ::DocumentPropertiesA(0, hPrinter, pchPrinter, pDevMode, NULL, DM_OUT_BUFFER);
#ifdef _M_IX86
        _asm frstor fsa;
    }
#endif //_M_IX86

                pDevMode->dmFields &= ~DM_COLLATE;
                pDevMode->dmCollate = DMCOLLATE_FALSE;
                
                ::GlobalUnlock(_hDevMode);
            }
            else
            {
                ::GlobalFree(_hDevMode);
                _hDevMode = NULL;
            }
        }
    }

Cleanup:
    if (hPrinter)
        ::ClosePrinter(hPrinter);
    if (pPrintInfo)
        ::GlobalFree(pPrintInfo);
    if (pchPrinter)
        delete []pchPrinter;
    if (pchDriverWideLocal)
        delete []pchDriverWideLocal;
    if (pchPortWideLocal)
        delete []pchPortWideLocal;

    return hr;
}

//+-----------------------------------------------------------------------------
//
//  Member:     CTemplatePrinter::GetDeviceProperties
//
//  Synopsis :  Gets the relevant physical properties of the device currently specified
//              in _hDevNames and _hDevMode
//
//------------------------------------------------------------------------------
HRESULT
CTemplatePrinter::GetDeviceProperties()
{
    IHTMLElementRender  *pRender            = NULL;
    IHTMLElement        *pElement           = NULL;
    BSTR                 bstrPrinter        = NULL;
    HRESULT hr                              = E_FAIL;

    if (_hDevNames && _hDevMode)
    {
        DEVNAMES *pDevNames = ((DEVNAMES *)::GlobalLock(_hDevNames));
        void     *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevNames && pDevMode)
        {
            HDC hDC = NULL;

            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                hDC = ::CreateICW(((TCHAR *)pDevNames) + pDevNames->wDriverOffset,
                                 ((TCHAR *)pDevNames) + pDevNames->wDeviceOffset,
                                 NULL,
                                 (DEVMODEW *)pDevMode);
            }
            else
            {
                LPSTR pchDriver = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDriverOffset);
                LPSTR pchDevice = InitMultiByteFromWideChar(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);
                if (pchDriver && pchDevice)
                {
                    hDC = ::CreateICA(pchDriver,
                                      pchDevice,
                                      NULL,
                                      (DEVMODEA *)pDevMode);
                }
                if (pchDriver)
                    delete []pchDriver;
                if (pchDevice)
                    delete []pchDevice;
            }

            if (hDC)
            {                
                SIZE    szPage;
    
                //  Obtain the resolution and unprintable areas for this device.
                _szResolution.cx        = ::GetDeviceCaps(hDC, LOGPIXELSX);
                _szResolution.cy        = ::GetDeviceCaps(hDC, LOGPIXELSY);
                szPage.cx               = ::GetDeviceCaps(hDC, PHYSICALWIDTH);
                szPage.cy               = ::GetDeviceCaps(hDC, PHYSICALHEIGHT);
                _rcUnprintable.left     = ::GetDeviceCaps(hDC, PHYSICALOFFSETX);
                _rcUnprintable.top      = ::GetDeviceCaps(hDC, PHYSICALOFFSETY);
                _rcUnprintable.right    =  szPage.cx - ::GetDeviceCaps(hDC, HORZRES) - _rcUnprintable.left;
                _rcUnprintable.bottom   =  szPage.cy - ::GetDeviceCaps(hDC, VERTRES) - _rcUnprintable.top;   
                Assert(_rcUnprintable.right >= 0);
                Assert(_rcUnprintable.bottom >= 0);

                _ptPaperSize.x          = (_szResolution.cx)
                                            ? MulDivQuick(szPage.cx, 1000, _szResolution.cx)
                                            : 8500;
                _ptPaperSize.y          = (_szResolution.cy)
                                            ? MulDivQuick(szPage.cy, 1000, _szResolution.cy)
                                            : 11000;
                
                
                hr = _pPeerSite->GetElement(&pElement);
                if (!hr)
                {
                    Assert(pElement);

                    hr = pElement->QueryInterface(IID_IHTMLElementRender, (void **)&pRender);
                    if (!hr) 
                    {
                        Assert(pRender);
                        
                        bstrPrinter = ::SysAllocString(((TCHAR *)pDevNames) + pDevNames->wDeviceOffset);
                        if (bstrPrinter)
                            pRender->SetDocumentPrinter(bstrPrinter,hDC);
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }

                ::DeleteDC(hDC);
            }
        }

        ::GlobalUnlock(_hDevNames);
        ::GlobalUnlock(_hDevMode);

        hr = S_OK;
    }

    ReleaseInterface(pElement);
    ReleaseInterface(pRender);
    if (bstrPrinter)
        ::SysFreeString(bstrPrinter);
    return hr;
}

HRESULT
CTemplatePrinter::CreateIPrintParams(DVTARGETDEVICE **ppTargetDevice, PAGESET **ppPageSet)
{
    HRESULT hr = S_OK;
    DWORD   nStructSize;

    Assert(ppTargetDevice && ppPageSet);
    (*ppTargetDevice) = NULL;
    (*ppPageSet)      = NULL;

    // Create a PAGESET.
    (*ppPageSet) = (PAGESET *)::CoTaskMemAlloc(sizeof(PAGESET));
    if (!(*ppPageSet))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    ::ZeroMemory(*ppPageSet, sizeof(PAGESET));

    (*ppPageSet)->cbStruct      = sizeof(PAGESET)       ;
    (*ppPageSet)->cPageRange    = 1;
    if (_fPrintSelectedPages)
    {
        (*ppPageSet)->rgPages[0].nFromPage  = _nPageFrom;
        (*ppPageSet)->rgPages[0].nToPage    = _nPageTo;
    }
    else
    {
        (*ppPageSet)->rgPages[0].nFromPage  = 1;
        (*ppPageSet)->rgPages[0].nToPage    = PAGESET_TOLASTPAGE;
    }

    (*ppTargetDevice) = InitTargetDevice();
    if (!(*ppTargetDevice))
    {
        // Error!  Clear the PageSet structure.
        ::CoTaskMemFree(*ppPageSet);
        (*ppPageSet) = NULL;

        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}


// NB (greglett)
// Alas, Win9x returns a ASCII DEVMODE and a Unicode DEVNAMES from the dialog functions.
// The old code avoided converting the second structure, *except* to create a TARGETDEVICE for IPrint objects.
// Since we will need to do this, I have brought this function over.
// If this function works *really* well, then maybe we can always convert and get rid of all the explicit calls to
// ANSI functions above. (CreateICA, CreateDCA, OpenPrinterA, &c...).
DVTARGETDEVICE *
DevModeWFromDevModeA( DVTARGETDEVICE *ptd )
{
    // NOTE: Only the DEVMODE structure is in the wrong (ascii) format!
    DEVMODEA  *         lpdma = NULL;
    DVTARGETDEVICE *    ptdW  = NULL;

    if (!ptd || !ptd->tdExtDevmodeOffset)
        goto Cleanup;

    lpdma = (DEVMODEA *) (((BYTE *)ptd) + ptd->tdExtDevmodeOffset);

    // If the reported size is too small for our conception of a DEVMODEA, don't risk a GPF
    // in our code and bail out now.
    if ( (DWORD)lpdma->dmSize + lpdma->dmDriverExtra < offsetof(DEVMODEA, dmLogPixels) )
        goto Cleanup;

    ptdW = (DVTARGETDEVICE *)::CoTaskMemAlloc( ptd->tdSize + (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME) );

    if (ptdW)
    {
        // Copy the entire structure up to DEVMODE part.
        memcpy(ptdW, ptd, ptd->tdExtDevmodeOffset);

        // Account for the increase of the two DEVMODE unicode strings.
        ptdW->tdSize += (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);

        // Convert the devmode structure.
        {
            DEVMODEW  * lpdmw = (DEVMODEW *) (((BYTE *)ptdW) + ptdW->tdExtDevmodeOffset);
            long        nCapChar;

            // Copy the first string (CCHDEVICENAME).
            // Really, 0 indicates a conversion error.  However, we really can't do much about it other than construct a NULL string.
            if (!::MultiByteToWideChar(CP_ACP, 0, (char *)lpdma->dmDeviceName, -1,  lpdmw->dmDeviceName, CCHDEVICENAME))
            {
                lpdmw->dmDeviceName[0] = _T('\0');    
            }

            // Copy the gap between strings.
            memcpy( &lpdmw->dmSpecVersion,
                    &lpdma->dmSpecVersion,
                    offsetof(DEVMODEA, dmFormName) -
                    offsetof(DEVMODEA, dmSpecVersion) );

            // Copy the first string (CCHDEVICENAME).
            if (!::MultiByteToWideChar(CP_ACP, 0, (char *)lpdma->dmFormName, -1,  lpdmw->dmFormName, CCHFORMNAME))
            {
                lpdmw->dmFormName[0] = _T('\0');
            }


            // Copy the last part including the driver-specific DEVMODE part (dmDriverExtra).
            memcpy( &lpdmw->dmLogPixels,
                    &lpdma->dmLogPixels,
                    (DWORD)lpdma->dmSize + lpdma->dmDriverExtra -
                    offsetof(DEVMODEA, dmLogPixels) );

            // Correct the dmSize member by accounting for larger unicode strings.
            lpdmw->dmSize += (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);
        }
    }

Cleanup:
    
    return ptdW;
}

//+----------------------------------------------------------------------
//
//  Function:   InitPrintHandles
//
//  Purpose:    Allocate a DVTARGETDEVICE structure, and initialize
//              it according to the hDevMode and hDevNames.
//              Also allocated an HIC.
//
//  Note:       IMPORTANT: Note that the DEVMODE structure is not wrapped
//              on non-unicode platforms.  (See comments below for details.)
//
//  Returns:    HRESULT
//
//-----------------------------------------------------------------------
DVTARGETDEVICE *
CTemplatePrinter::InitTargetDevice()
{
    HRESULT hr = S_OK;
    LPDEVNAMES pDN = NULL;
    LPDEVMODE  pDM = NULL;
    LPDEVMODEA pDMA = NULL;
    DVTARGETDEVICE * ptd = NULL;
    WORD nMaxOffset;
    DWORD dwDevNamesSize, dwDevModeSize, dwPtdSize;
    int nNameLength;

    if (!_hDevNames || !_hDevMode)
        goto Cleanup;

    pDN = (LPDEVNAMES)::GlobalLock(_hDevNames);
    if (!pDN)
        goto Cleanup;
    if (g_fUnicodePlatform)
    {
        pDM  = (LPDEVMODE)::GlobalLock(_hDevMode);
        if (!pDM)
            goto Cleanup;
    }
    else
    {
        pDMA = (LPDEVMODEA)::GlobalLock(_hDevMode);
        if (!pDMA)
            goto Cleanup;
    }

    // IMPORTANT: We have painstakingly
    // converted only the hDevNames parameter and NOT hDevMode (NOT!!!) to have TCHAR
    // members.

    nMaxOffset = max( pDN->wDriverOffset, pDN->wDeviceOffset );
    nMaxOffset = max( nMaxOffset, pDN->wOutputOffset );
    nNameLength = _tcslen( (TCHAR *)pDN + nMaxOffset );

    // dw* are in bytes, not TCHARS

    dwDevNamesSize = sizeof(TCHAR) * ((DWORD)nMaxOffset + nNameLength + 1);
    dwDevModeSize = g_fUnicodePlatform ? ((DWORD)pDM->dmSize + pDM->dmDriverExtra)
                                       : ((DWORD)pDMA->dmSize + pDMA->dmDriverExtra);

    dwPtdSize = sizeof(DWORD) + dwDevNamesSize + dwDevModeSize;

    ptd = (DVTARGETDEVICE *)::CoTaskMemAlloc(dwPtdSize);
    if (!ptd)
        goto Cleanup;
    else
    {
        ptd->tdSize = dwPtdSize;

        // This is an ugly trick.  ptd->tdDriverNameOffset and pDN happen
        // to match up, so we just copy that plus the data in one big chunk.
        // Remember, I didn't write this -- this code is based on the OLE2 SDK.

        // Offsets are in characters, not bytes.
        memcpy( &ptd->tdDriverNameOffset, pDN, dwDevNamesSize );
        ptd->tdDriverNameOffset *= sizeof(TCHAR);
        ptd->tdDriverNameOffset += sizeof(DWORD);
        ptd->tdDeviceNameOffset *= sizeof(TCHAR);
        ptd->tdDeviceNameOffset += sizeof(DWORD);
        ptd->tdPortNameOffset *= sizeof(TCHAR);
        ptd->tdPortNameOffset += sizeof(DWORD);

        // IMPORTANT: We are not converting the DEVMODE structure back and forth
        // from ASCII to Unicode on Win9x anymore because we are not touching the
        // two strings or any other member.  Converting the DEVMODE structure can
        // be tricky because of potential and common discrepancies between the
        // value of the dmSize member and sizeof(DEVMODE).  (25155)

        if (g_fUnicodePlatform)
            memcpy((BYTE *)&ptd->tdDriverNameOffset + dwDevNamesSize, pDM, dwDevModeSize);
        else
            memcpy((BYTE *)&ptd->tdDriverNameOffset + dwDevNamesSize, pDMA, dwDevModeSize);

        ptd->tdExtDevmodeOffset = USHORT(sizeof(DWORD) + dwDevNamesSize);        

        // We must return a corrent (all WCHAR) DVTARGETDEVICEW structure.
        // Convert the nasty DEVMODEA if we've just copied it over.
        if (!g_fUnicodePlatform)
        {
            DVTARGETDEVICE *ptdOld;
            ptdOld  = ptd;
            ptd     = DevModeWFromDevModeA(ptdOld);
            ::CoTaskMemFree(ptdOld);
        }
    }

Cleanup:
    if (pDM || pDMA)
        ::GlobalUnlock(_hDevMode);
    if (pDN)
        ::GlobalUnlock(_hDevNames);

    return ptd;
}


#ifdef DBG
//
//  CTemplatePrinter Debug-Only functions
//
void
CTemplatePrinter::VerifyOrientation()
{
    // Verify that the page size reflects the current orientation bit in the DEVMODE
    // These properties should always be in sync.
    if (_hDevMode)
    {
        void *pDevMode  = ::GlobalLock(_hDevMode);
        if (pDevMode)
        {
            BOOL    fOrientationValid;
            BOOL    fLandscape; 

            // (greglett) Non-Unicode badness.  See comment at definition of _hDevMode
            if (g_fUnicodePlatform)
            {
                fOrientationValid   = !!(((DEVMODEW *)pDevMode)->dmFields & DM_ORIENTATION);
                fLandscape          = (((DEVMODEW *)pDevMode)->dmOrientation == DMORIENT_LANDSCAPE);
            }
            else
            {
                fOrientationValid   = !!(((DEVMODEA *)pDevMode)->dmFields & DM_ORIENTATION);
                fLandscape          = (((DEVMODEA *)pDevMode)->dmOrientation == DMORIENT_LANDSCAPE);
            }

            Assert(     !fOrientationValid
                    ||  fLandscape == (_ptPaperSize.x > _ptPaperSize.y)  );

            ::GlobalUnlock(_hDevMode);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\utils.cxx ===
//+------------------------------------------------------------------------
//
//  File : Utils.cxx
//
//  purpose : implementation of helpful stuff
//
//-------------------------------------------------------------------------


#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "utils.hxx"

#include <docobj.h>
#include <mshtmcid.h>
#include <mshtmhst.h>

#define BUFFEREDSTR_SIZE 1024

// VARIANT conversion interface exposed by script engines (VBScript/JScript).
EXTERN_C const GUID SID_VariantConversion = 
                { 0x1f101481, 0xbccd, 0x11d0, { 0x93, 0x36,  0x0,  0xa0,  0xc9,  0xd,  0xca,  0xa9 } };

//+------------------------------------------------------------------------
//
//  Function:   GetHTMLDocument
//
//  Synopsis:   Gets the IHTMLDocument2 interface from the client site.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetHTMLDocument(IElementBehaviorSite * pSite, IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (!ppDoc)
        return E_POINTER;

    if (pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetHTMLWindow
//
//  Synopsis:   Gets the IHTMLWindow2 interface from the client site.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetHTMLWindow(IElementBehaviorSite * pSite, IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(pSite, &pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetClientSiteWindow
//
//  Synopsis:   Gets the window handle of the client site passed in.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
GetClientSiteWindow(IElementBehaviorSite *pSite, HWND *phWnd)
{
    HRESULT hr = E_FAIL;
    IWindowForBindingUI *pWindowForBindingUI = NULL;

    if (pSite != NULL) {

        // Get IWindowForBindingUI ptr
        hr = pSite->QueryInterface(IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);

        if (FAILED(hr)) {
            IServiceProvider *pServProv;
            hr = pSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pServProv);

            if (hr == NOERROR) {
                pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                    (LPVOID *)&pWindowForBindingUI);
                pServProv->Release();
            }
        }

        if (pWindowForBindingUI) {
            pWindowForBindingUI->GetWindow(IID_IWindowForBindingUI, phWnd);
            pWindowForBindingUI->Release();
        }
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   AppendElement
//
//  Synopsis:   Appends a child to an owner
//
//-------------------------------------------------------------------------

STDMETHODIMP
AppendChild(IHTMLElement *pOwner, IHTMLElement *pChild)
{
    HRESULT hr; 

    CComPtr<IHTMLDOMNode> pOwnerNode, pChildNode;

    hr = pOwner->QueryInterface(IID_IHTMLDOMNode, (void **) &pOwnerNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pChild->QueryInterface(IID_IHTMLDOMNode, (void **) &pChildNode);
    if (FAILED(hr))
        goto Cleanup;

    hr = pOwnerNode->appendChild(pChildNode, NULL);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}


//+---------------------------------------------------------------
//
// Function:    IsSameObject
//
// Synopsis:    Checks for COM identity
//
// Arguments:   pUnkLeft, pUnkRight
//
//+---------------------------------------------------------------

BOOL
IsSameObject(IUnknown *pUnkLeft, IUnknown *pUnkRight)
{
    IUnknown *pUnk1, *pUnk2;

    if (pUnkLeft == pUnkRight)
        return TRUE;

    if (pUnkLeft == NULL || pUnkRight == NULL)
        return FALSE;

    if (SUCCEEDED(pUnkLeft->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk1)))
    {
        pUnk1->Release();
        if (pUnk1 == pUnkRight)
            return TRUE;
        if (SUCCEEDED(pUnkRight->QueryInterface(IID_IUnknown, (LPVOID *)&pUnk2)))
        {
            pUnk2->Release();
            return pUnk1 == pUnk2;
        }
    }
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}



//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::Set
//
//  Synopsis:   Initilizes a CBufferedStr
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::Set (LPCTSTR pch, UINT uiCch)
{
    HRESULT hr = S_OK;

    Free();

    if (!uiCch)
        _cchIndex = pch ? _tcslen (pch) : 0;
    else
        _cchIndex = uiCch;

    _cchBufSize = _cchIndex > BUFFEREDSTR_SIZE ? _cchIndex : BUFFEREDSTR_SIZE;
    _pchBuf = new TCHAR [ _cchBufSize ];
    if (!_pchBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pch)
    {
        _tcsncpy (_pchBuf, pch, _cchIndex);
    }

    _pchBuf[_cchIndex] = '\0';

Cleanup:
    return (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::QuickAppend
//
//  Parameters: pchNewStr   string to be added to _pchBuf
//
//  Synopsis:   Appends pNewStr into _pchBuf starting at
//              _pchBuf[uIndex].  Increments index to reference
//              new end of string.  If _pchBuf is not large enough,
//              reallocs _pchBuf and updates _cchBufSize.
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::QuickAppend (const TCHAR* pchNewStr, ULONG newLen)
{
    HRESULT hr = S_OK;

    if (!_pchBuf)
    {
        hr = Set();
        if (hr)
            goto Cleanup;
    }

    if (_cchIndex + newLen >= _cchBufSize)    // we can't fit the new string in the current buffer
    {                                         // so allocate a new buffer, and copy the old string
        _cchBufSize += (newLen > BUFFEREDSTR_SIZE) ? newLen : BUFFEREDSTR_SIZE;
        TCHAR * pchTemp = new TCHAR [ _cchBufSize ];
        if (!pchTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcsncpy (pchTemp, _pchBuf, _cchIndex);

        Free();
        _pchBuf = pchTemp;
    }

    // append the new string
    _tcsncpy (_pchBuf + _cchIndex, pchNewStr, newLen);
    _cchIndex += newLen;
    _pchBuf[_cchIndex] = '\0';

Cleanup:
    return (hr);
}
HRESULT
CBufferedStr::QuickAppend(long lValue)
{
    TCHAR   strValue[40];

#ifdef UNICODE
    return QuickAppend( _ltow(lValue, strValue, 10) );
#else
    return QuickAppend( _ltoa(lValue, strValue, 10) );
#endif
}

//+---------------------------------------------------------------------------
//
//  method : ConvertGmtTimeToString
//
//  Synopsis: This function produces a standard(?) format date, of the form
// Tue, 02 Apr 1996 02:04:57 UTC  The date format *will not* be tailored
// for the locale.  This is for cookie use and Netscape compatibility
//
//----------------------------------------------------------------------------
static const TCHAR* achMonth[] = {
    _T("Jan"),_T("Feb"),_T("Mar"),_T("Apr"),_T("May"),_T("Jun"),
        _T("Jul"),_T("Aug"),_T("Sep"),_T("Oct"),_T("Nov"),_T("Dec") 
};
static const TCHAR* achDay[] = {
    _T("Sun"), _T("Mon"),_T("Tue"),_T("Wed"),_T("Thu"),_T("Fri"),_T("Sat")
};

HRESULT 
ConvertGmtTimeToString(FILETIME Time, TCHAR * pchDateStr, DWORD cchDateStr)
{
    SYSTEMTIME SystemTime;
    CBufferedStr strBuf;

    if (cchDateStr < DATE_STR_LENGTH)
        return E_INVALIDARG;

    FileTimeToSystemTime(&Time, &SystemTime);

    strBuf.QuickAppend(achDay[SystemTime.wDayOfWeek]);
    strBuf.QuickAppend(_T(", "));
    strBuf.QuickAppend(SystemTime.wDay);
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(achMonth[SystemTime.wMonth - 1] );
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(SystemTime.wYear );
    strBuf.QuickAppend(_T(" ") );
    strBuf.QuickAppend(SystemTime.wHour );
    strBuf.QuickAppend(_T(":") );
    strBuf.QuickAppend(SystemTime.wMinute );
    strBuf.QuickAppend(_T(":") );
    strBuf.QuickAppend(SystemTime.wSecond );
    strBuf.QuickAppend(_T(" UTC") );

    if (strBuf.Length() >cchDateStr)
        return E_FAIL;

    _tcscpy(pchDateStr, strBuf);

    return S_OK;
}

HRESULT 
ParseDate(BSTR strDate, FILETIME * pftTime)
{
    HRESULT      hr = S_FALSE;
    SYSTEMTIME   stTime ={0};
    LPCTSTR      pszToken = NULL;
    BOOL         fFound;
    int          idx, cch;
    CDataListEnumerator  dle(strDate, _T(':'));

    if (!pftTime)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // get the dayOfTheWeek:  3 digits max plus comma
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 4)
        goto Cleanup;
    else
    {
        for (idx=0; idx < ARRAY_SIZE(achDay); idx++)
        {
            fFound = !_tcsnicmp( pszToken, achDay[idx], 3);
            if (fFound)
            {
                stTime.wDayOfWeek = (WORD)idx;
                break;
            }
        }

        if (!fFound)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the Day 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wDay = (WORD)_ttoi(pszToken);

    // get the Month: 3 characters
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 3)
        goto Cleanup;
    else
    {
        for (idx=0; idx < ARRAY_SIZE(achMonth); idx++)
        {
            fFound = !_tcsnicmp( pszToken, achMonth[idx], 3);
            if (fFound)
            {
                stTime.wMonth = (WORD)idx + 1;
                break;
            }
        }

        if (!fFound)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the Year 4 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 4)
        goto Cleanup;

    stTime.wYear = (WORD)_ttoi(pszToken);

    // get the Hour 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wHour = (WORD)_ttoi(pszToken);

    // get the Minute 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wMinute = (WORD)_ttoi(pszToken);

    // get the Second 2 digits max
    //--------------------------------------------------
    if (! dle.GetNext(&pszToken, &cch) || cch > 2)
        goto Cleanup;

    stTime.wSecond = (WORD)_ttoi(pszToken);

    // now we have SYSTEMTIME, lets return the FILETIME
    if (!SystemTimeToFileTime(&stTime, pftTime))
        hr = GetLastError();
    else
        hr = S_OK;

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MbcsFromUnicode
//
//  Synopsis:   Converts a string to MBCS from Unicode.
//
//  Arguments:  [pstr]  -- The buffer for the MBCS string.
//              [cch]   -- The size of the MBCS buffer, including space for
//                              NULL terminator.
//
//              [pwstr] -- The Unicode string to convert.
//              [cwch]  -- The number of characters in the Unicode string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pstr].
//
//----------------------------------------------------------------------------

int
MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    if (!pstr || cch <= 0 || !pwstr || cwch<-1)
        return 0;

    ret = WideCharToMultiByte(CP_ACP, 0, pwstr, cwch, pstr, cch, NULL, NULL);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
    }
#endif /* } */

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnicodeFromMbcs
//
//  Synopsis:   Converts a string to Unicode from MBCS.
//
//  Arguments:  [pwstr] -- The buffer for the Unicode string.
//              [cwch]  -- The size of the Unicode buffer, including space for
//                              NULL terminator.
//
//              [pstr]  -- The MBCS string to convert.
//              [cch]  -- The number of characters in the MBCS string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pwstr].
//
//----------------------------------------------------------------------------

int
UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    if (!pstr || cwch <= 0 || !pwstr || cch<-1)
        return 0;

    ret = MultiByteToWideChar(CP_ACP, 0, pstr, cch, pwstr, cwch);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
    }
#endif /* } */

    return ret;
}


//+--------------------------------------------------------------------
//
//  Function:    _tcsistr
//
//---------------------------------------------------------------------

const TCHAR * __cdecl _tcsistr (const TCHAR * tcs1,const TCHAR * tcs2)
{
    const TCHAR *cp;
    int cc,count;
    int n2Len = _tcslen ( tcs2 );
    int n1Len = _tcslen ( tcs1 );

    if ( n1Len >= n2Len )
    {
        for ( cp = tcs1, count = n1Len - n2Len; count>=0 ; cp++,count-- )
        {
            cc = CompareString(LCID_SCRIPTING,
                NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                cp, n2Len,tcs2, n2Len);
            if ( cc > 0 )
                cc-=2;
            if ( !cc )
                return cp;
        }
    }
    return NULL;
}

//+--------------------------------------------------------------------
//
//  Function:    AccessAllowed
//
//---------------------------------------------------------------------
BOOL
AccessAllowed(BSTR bstrUrl, IUnknown * pUnkSite)
{
    BOOL                fAccessAllowed = FALSE;
    HRESULT             hr;
    CComPtr<IBindHost>	pBindHost;
    CComPtr<IMoniker>	pMoniker;
    LPTSTR              pchUrl = NULL;
    BYTE                abSID1[MAX_SIZE_SECURITY_ID];
    BYTE                abSID2[MAX_SIZE_SECURITY_ID];
    DWORD               cbSID1 = ARRAY_SIZE(abSID1);
    DWORD               cbSID2 = ARRAY_SIZE(abSID2);
    CComPtr<IInternetSecurityManager>                   pSecurityManager;
    CComPtr<IInternetHostSecurityManager>               pHostSecurityManager;
    CComQIPtr<IServiceProvider, &IID_IServiceProvider>  pServiceProvider(pUnkSite);

    if (!pServiceProvider)
        goto Cleanup;

    //
    // expand url
    //

    hr = pServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&pBindHost);
    if (hr)
        goto Cleanup;

    hr = pBindHost->CreateMoniker(bstrUrl, NULL, &pMoniker, NULL);
    if (hr)
        goto Cleanup;

    hr = pMoniker->GetDisplayName(NULL, NULL, &pchUrl);
    if (hr)
        goto Cleanup;

    //
    // get security id of the url
    //

    hr = CoInternetCreateSecurityManager(NULL, &pSecurityManager, 0);
    if (hr)
        goto Cleanup;

    hr = pSecurityManager->GetSecurityId(pchUrl, abSID1, &cbSID1, NULL);
    if (hr)
        goto Cleanup;

    //
    // get security id of the document
    //

    hr = pServiceProvider->QueryService(
        IID_IInternetHostSecurityManager, IID_IInternetHostSecurityManager, (void**)&pHostSecurityManager);
    if (hr)
        goto Cleanup;

    hr = pHostSecurityManager->GetSecurityId(abSID2, &cbSID2, NULL);

    //
    // the security check itself
    //

    fAccessAllowed = (cbSID1 == cbSID2 && (0 == memcmp(abSID1, abSID2, cbSID1)));

Cleanup:
    if (pchUrl)
        CoTaskMemFree(pchUrl);

    return fAccessAllowed;
}
//+------------------------------------------------------------------------
//
//  CDataObject : Member function implmentations
//
//-------------------------------------------------------------------------
HRESULT 
CDataObject::Set (BSTR bstrValue)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BSTR;
    if (!bstrValue)
    {
        V_BSTR(&_varValue) = NULL;
        return S_OK;
    }
    else
    {
        V_BSTR(&_varValue) = SysAllocStringLen(bstrValue, SysStringLen(bstrValue));

        return (V_BSTR(&_varValue)) ? S_OK : E_OUTOFMEMORY;
    }
}

HRESULT 
CDataObject::Set (VARIANT_BOOL vBool)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BOOL;
    V_BOOL(&_varValue) = vBool;

    return S_OK;
}

HRESULT
CDataObject::Set(IDispatch * pDisp)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_DISPATCH;
    V_DISPATCH(&_varValue) = pDisp;

    if (pDisp)
        pDisp->AddRef();

    return S_OK;
}

HRESULT 
CDataObject::GetAsBSTR (BSTR * pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr) 
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstr = NULL;

    if (V_VT(&_varValue) == VT_BSTR)
    {
        *pbstr = SysAllocStringLen(V_BSTR(&_varValue), 
                                   SysStringLen(V_BSTR(&_varValue)));

        if (!*pbstr)
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    return hr;
};


HRESULT 
CDataObject::GetAsBOOL (VARIANT_BOOL * pVB)
{
    HRESULT hr = S_OK;

    if (!pVB) 
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (V_VT(&_varValue) != VT_BOOL)
    {
        *pVB = VB_FALSE;
        hr = S_FALSE;
    }
    else
    {
        *pVB =  V_BOOL(&_varValue);
    }

Cleanup:
    return hr;
};

HRESULT
CDataObject::GetAsDispatch(IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (V_VT(&_varValue)!= VT_DISPATCH)
    {
        hr = S_FALSE;
    }
    else
    {
        *ppDisp = V_DISPATCH(&_varValue);
        if (*ppDisp)
            (*ppDisp)->AddRef();
    }

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Helper Class:    CContextAccess
//                  access to behavior site, element and style
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CContextAccess::CContextAccess(IElementBehaviorSite * pSite)
{
    memset (this, 0, sizeof(*this));

    _pSite = pSite;
    _pSite->AddRef();
}

CContextAccess::CContextAccess(IHTMLElement * pElement)
{
    memset (this, 0, sizeof(*this));

    _dwAccess = CA_ELEM;

    _pElem = pElement;
    _pElem->AddRef();
}

/////////////////////////////////////////////////////////////////////////////

CContextAccess::~CContextAccess()
{
    DWORD   dw;

    ReleaseInterface (_pSite);

    // the point of this loop is to avoid doing as many ReleaseInterface-s as we have possible values in CONTEXT_ACCESS enum.
    // instead, we do as many ReleaseInterface-s as number of bits actually set in dwAccess.

    while (_dwAccess)
    {
        dw = (_dwAccess - 1) & _dwAccess;
        switch (_dwAccess - dw)
        {
        case CA_SITEOM:     _pSiteOM->Release();            break;
        case CA_SITERENDER: _pSiteRender->Release();        break;
        case CA_ELEM:       _pElem->Release();              break;
        case CA_ELEM2:      _pElem2->Release();             break;
        case CA_ELEM3:      _pElem3->Release();             break;
        case CA_STYLE:      _pStyle->Release();             break;
        case CA_STYLE2:     _pStyle2->Release();            break;
        case CA_STYLE3:     _pStyle3->Release();            break;
        case CA_DEFAULTS:   _pDefaults->Release();          break;
        case CA_DEFSTYLE:   _pDefStyle->Release();          break;
        case CA_DEFSTYLE2:  _pDefStyle2->Release();         break;
        case CA_DEFSTYLE3:  _pDefStyle3->Release();         break;
        default:            Assert (FALSE && "invalid _dwAccess");  break;
        }
        _dwAccess = dw;
    }
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CContextAccess::Open(DWORD dwAccess)
{
    HRESULT     hr = S_OK;
    DWORD       dw, dw2, dw3;

    // NOTE order of these ifs is important

    // STYLE2 or STYLE3 require us to get STYLE
    if (dwAccess & (CA_STYLE2 | CA_STYLE3))
        dwAccess |= CA_STYLE;

    // ELEM2, ELEM3, or CA_STYLE require us to get ELEM
    if (dwAccess & (CA_ELEM2 | CA_ELEM3 | CA_STYLE))
        dwAccess |= CA_ELEM;

    // DEFSTYLE2 or DEFSTYLE3 require us to get STYLE
    if (dwAccess & (CA_DEFSTYLE2 | CA_DEFSTYLE3))
        dwAccess |= CA_DEFSTYLE;

    // any DEFSTYLE require us to get PELEM
    if (dwAccess & (CA_DEFSTYLE))
        dwAccess |= CA_DEFAULTS;

    // PELEM requires us to get SITEOM
    if (dwAccess & (CA_DEFAULTS))
        dwAccess |= CA_SITEOM;

    // the point of this loop is to avoid doing as many ifs as we have possible values in CONTEXT_ACCESS enum.
    // instead, we do as many ifs as number of bits actually set in dwAccess.

    dw = dwAccess;

    while (dw)
    {
        dw2 = (dw - 1) & dw;
        dw3 = dw - dw2;
        if (0 == (dw3 & _dwAccess))
        {
            switch (dw3)
            {
            case CA_SITEOM:
                Assert (_pSite && !_pSiteOM);
                hr = _pSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&_pSiteOM);
                if (hr)
                    goto Cleanup;
                break;

            case CA_SITERENDER:
                Assert (_pSite && !_pSiteRender);
                hr = _pSite->QueryInterface(IID_IElementBehaviorSiteRender, (void**)&_pSiteRender);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM:
                Assert (_pSite && !_pElem);
                hr = _pSite->GetElement(&_pElem);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM2:
                Assert (_pElem && !_pElem2);
                hr = _pElem->QueryInterface(IID_IHTMLElement2, (void**)&_pElem2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_ELEM3:
                Assert (_pElem && !_pElem3);
                hr = _pElem->QueryInterface(IID_IHTMLElement3, (void**)&_pElem3);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE:
                Assert (_pElem && !_pStyle);
                hr = _pElem->get_style(&_pStyle);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE2:
                Assert (_pStyle && !_pStyle2);
                hr = _pStyle->QueryInterface(IID_IHTMLStyle2, (void**)&_pStyle2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_STYLE3:
                Assert (_pStyle && !_pStyle3);
                hr = _pStyle->QueryInterface(IID_IHTMLStyle3, (void**)&_pStyle3);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFAULTS:
                Assert (_pSiteOM && !_pDefaults);
                hr = _pSiteOM->GetDefaults(&_pDefaults);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE:
                Assert (_pDefaults && !_pDefStyle);
                hr = _pDefaults->get_style(&_pDefStyle);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE2:
                Assert (_pDefStyle && !_pDefStyle2);
                hr = _pDefStyle->QueryInterface(IID_IHTMLStyle2, (void**)&_pDefStyle2);
                if (hr)
                    goto Cleanup;
                break;

            case CA_DEFSTYLE3:
                Assert (_pDefStyle && !_pDefStyle3);
                hr = _pDefStyle->QueryInterface(IID_IHTMLStyle3, (void**)&_pDefStyle3);
                if (hr)
                    goto Cleanup;
                break;

            default:
                Assert (FALSE && "invalid dwAccess");
                break;
            }
        }

        dw = dw2;
    }

    _dwAccess |= dwAccess;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

#if DBG == 1

HRESULT
CContextAccess::DbgTest(IElementBehaviorSite * pSite)
{
    HRESULT     hr;

    // CA_NONE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_NONE);
        if (hr)
            goto Cleanup;
    }

    // CA_ELEM
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM);
        if (hr)
            goto Cleanup;

        a.Elem()->AddRef();
        a.Elem()->Release();
    }

    // CA_ELEM2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM2);
        if (hr)
            goto Cleanup;

        a.Elem2()->AddRef();
        a.Elem2()->Release();
    }

    // CA_ELEM3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_ELEM3);
        if (hr)
            goto Cleanup;

        a.Elem3()->AddRef();
        a.Elem3()->Release();
    }

    // CA_STYLE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE);
        if (hr)
            goto Cleanup;

        a.Style()->AddRef();
        a.Style()->Release();
    }

    // CA_STYLE2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE2);
        if (hr)
            goto Cleanup;

        a.Style2()->AddRef();
        a.Style2()->Release();
    }

    // CA_STYLE3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_STYLE3);
        if (hr)
            goto Cleanup;

        a.Style3()->AddRef();
        a.Style3()->Release();
    }

    // CA_DEFSTYLE
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE);
        if (hr)
            goto Cleanup;

        a.DefStyle()->AddRef();
        a.DefStyle()->Release();
    }

    // CA_DEFSTYLE2
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE2);
        if (hr)
            goto Cleanup;

        a.DefStyle2()->AddRef();
        a.DefStyle2()->Release();
    }

    // CA_DEFSTYLE3
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_DEFSTYLE3);
        if (hr)
            goto Cleanup;

        a.DefStyle3()->AddRef();
        a.DefStyle3()->Release();
    }

    // CA_SITEOM
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_SITEOM);
        if (hr)
            goto Cleanup;

        a.SiteOM()->AddRef();
        a.SiteOM()->Release();
    }

    // sequencing of Opens
    {
        CContextAccess  a(pSite);

        hr = a.Open(CA_SITEOM);
        if (hr)
            goto Cleanup;

        a.SiteOM()->AddRef();
        a.SiteOM()->Release();

        hr = a.Open(CA_ELEM);
        if (hr)
            goto Cleanup;

        a.Elem()->AddRef();
        a.Elem()->Release();

        hr = a.Open(CA_DEFSTYLE3);
        if (hr)
            goto Cleanup;

        a.DefStyle3()->AddRef();
        a.DefStyle3()->Release();
    }

Cleanup:
    return hr;
}

#endif

/////////////////////////////////////////////////////////////////////////////
//
// Helper Class:    CEventObjectAccess
//                  access to event object
//
/////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////

CEventObjectAccess::CEventObjectAccess(DISPPARAMS * pDispParams)
{
    memset (this, 0, sizeof(*this));
    _pDispParams = pDispParams;
}

///////////////////////////////////////////////////////////////////////////////

CEventObjectAccess::~CEventObjectAccess()
{
    ReleaseInterface (_pEventObj);
    ReleaseInterface (_pEventObj2);
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CEventObjectAccess::Open(DWORD dwAccess)
{
    HRESULT     hr = S_OK;
    VARIANT *   pvarArg;

    Assert (_pDispParams);

    if (!_pDispParams ||
        !_pDispParams->rgvarg ||
         _pDispParams->cArgs != 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pvarArg = &_pDispParams->rgvarg[0];

    if (!V_UNKNOWN(pvarArg) ||
        (VT_DISPATCH != V_VT(pvarArg) &&
         VT_UNKNOWN  != V_VT(pvarArg)))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (0 != (dwAccess & EOA_EVENTOBJ) &&
        !_pEventObj)
    {
        hr = V_UNKNOWN(pvarArg)->QueryInterface(IID_IHTMLEventObj, (void **)&_pEventObj);
        if (hr)
            goto Cleanup;
    }

    if (dwAccess & EOA_EVENTOBJ2 &&
        !_pEventObj2)
    {
        hr =  V_UNKNOWN(pvarArg)->QueryInterface(IID_IHTMLEventObj2, (void **)&_pEventObj2);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetScreenCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptScreen;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetWindowCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptClient;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetParentCoordinates(POINT * ppt)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *ppt = _EventProperties.ptElem;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetKeyCode(long * pl)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lKey;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetMouseButtons(long * pl)
{
    HRESULT hr      = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lMouseButtons;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::GetKeyboardStatus(long * pl)
{
    HRESULT hr = S_OK;

    if (!_fEventPropertiesInitialized)
    {
        hr = InitializeEventProperties();
        if (hr)
            goto Cleanup;
    }

    *pl = _EventProperties.lKeys;

Cleanup:
    return hr;
}

HRESULT
CEventObjectAccess::InitializeEventProperties()
{
    HRESULT hr = S_OK;

    VARIANT_BOOL b;

    BOOL fAltKey = FALSE;
    BOOL fCtrlKey = FALSE;
    BOOL fShiftKey = FALSE;

    BOOL    fLeft   = FALSE;
    BOOL    fRight  = FALSE;
    BOOL    fMiddle = FALSE;
    long    lMouseButtons;

    if (!_pEventObj)
    {
        hr = Open(EOA_EVENTOBJ);
        if (hr)
            goto Cleanup;
    }

    // KeyboardStatus

    hr = _pEventObj->get_altKey(&b);
    if (hr)
        goto Cleanup;
    fAltKey = (b == VARIANT_TRUE);

    hr = _pEventObj->get_ctrlKey(&b);
    if (hr)
        goto Cleanup;
    fCtrlKey = (b == VARIANT_TRUE);

    hr = _pEventObj->get_shiftKey(&b);
    if (hr)
        goto Cleanup;
    fShiftKey = (b == VARIANT_TRUE);

    _EventProperties.lKeys = (fAltKey ? EVENT_ALTKEY : 0) | (fCtrlKey ? EVENT_CTRLKEY : 0) | (fShiftKey ? EVENT_SHIFTKEY : 0);

    // MouseButtons

    hr = _pEventObj->get_button(&lMouseButtons);
    if (hr)
        goto Cleanup;

    fLeft = (lMouseButtons == 1) || (lMouseButtons == 3) || (lMouseButtons == 5) || (lMouseButtons == 7);
    fRight = (lMouseButtons == 2) || (lMouseButtons == 3) || (lMouseButtons == 6) || (lMouseButtons == 7);
    fMiddle = (lMouseButtons == 4) || (lMouseButtons == 5) || (lMouseButtons == 6) || (lMouseButtons == 7);

    _EventProperties.lMouseButtons = ( fLeft  ? EVENT_LEFTBUTTON   : 0) 
                                   | (fRight  ? EVENT_RIGHTBUTTON  : 0) 
                                   | (fMiddle ? EVENT_MIDDLEBUTTON : 0);

    // KeyCode
    
    hr = _pEventObj->get_keyCode(&_EventProperties.lKey);
    if (hr)
        goto Cleanup;

    // ParentCoordinates

    hr = _pEventObj->get_x(&_EventProperties.ptElem.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_y(&_EventProperties.ptElem.y);
    if (hr)
        goto Cleanup;

    // WindowCoordinates

    hr = _pEventObj->get_clientX(&_EventProperties.ptClient.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_clientY(&_EventProperties.ptClient.y);
    if (hr)
        goto Cleanup;

    // ScreenCoordinates

    hr = _pEventObj->get_screenX(&_EventProperties.ptScreen.x);
    if (hr)
        goto Cleanup;
    hr = _pEventObj->get_screenY(&_EventProperties.ptScreen.y);
    if (hr)
        goto Cleanup;
    
    _fEventPropertiesInitialized = TRUE;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Misc helpers
//
/////////////////////////////////////////////////////////////////////////////

void *
MemAllocClear(size_t cb)
{
    void * pv = malloc(cb);

    if (pv)
    {
        memset (pv, 0, cb);
    }

    return pv;
}

HRESULT
LoadLibrary(char *achLibraryName, HINSTANCE *hInst)
{
    DWORD       dwError;
    Assert(achLibraryName);
    Assert(hInst);
    *hInst = NULL;

    // Try to load the library using the normal mechanism.
    *hInst = ::LoadLibraryA(achLibraryName);

#ifdef WIN16
    if ( (UINT) *hInst < 32 )
        goto Error;
#endif

#if !defined(WIN16) && !defined(WINCE)
    // If that failed because the module was not be found,
    // then try to find the module in the directory we were
    // loaded from.
    if (!*hInst)
    {
        dwError = ::GetLastError();

        if (   dwError == ERROR_MOD_NOT_FOUND
            || dwError == ERROR_DLL_NOT_FOUND)
        {
            char achBuf1[MAX_PATH];
            char achBuf2[MAX_PATH];
            char *pch;

            // Get path name of this module.
            if (::GetModuleFileNameA(NULL, achBuf1, ARRAY_SIZE(achBuf1)) == 0)
                goto Error;

            // Find where the file name starts in the module path.
            if (::GetFullPathNameA(achBuf1, ARRAY_SIZE(achBuf2), achBuf2, &pch) == 0)
                goto Error;

            // Chop off the file name to get a directory name.
            *pch = 0;

            // See if there's a dll with the given name in the directory.
            if (::SearchPathA(
                    achBuf2,
                    achLibraryName,
                    NULL,
                    ARRAY_SIZE(achBuf1),
                    achBuf1,
                    NULL) != 0)
            {
                // Yes, there's a dll. Load it.
                *hInst = ::LoadLibraryExA(
                            achBuf1,
                            NULL,
                            LOAD_WITH_ALTERED_SEARCH_PATH);
            }
        }
    }
#endif // !defined(WIN16) && !defined(WINCE)

    if (!*hInst)
    {
        goto Error;
    }

    return S_OK;

Error:
    dwError = GetLastError();
    return dwError ? HRESULT_FROM_WIN32(dwError) : E_FAIL;
}

//+----------------------------------------------------------------------------
//
//  Member : AccessAllowed
//
//  Synopsis : Internal helper. this function is part of the behavior security
//      model for this tag.  We only allow layout rects to be trusted if they're
//      within a trusted dialog.
//
//-----------------------------------------------------------------------------

BOOL
TemplateAccessAllowed(IElementBehaviorSite *pISite)
{
#ifdef TEMPLATE_TESTING
    return TRUE;
#else
    HRESULT             hr;
    IHTMLElement      * pElem = NULL;
    IDispatch         * pDoc  = NULL;
    IOleCommandTarget * pioct = NULL;
    VARIANT             varRet;
    MSOCMD              msocmd;

    if (!pISite)
        return FALSE;

    VariantInit(&varRet);
    msocmd.cmdID = IDM_ISTRUSTEDDLG;
    msocmd.cmdf  = 0;

    hr = pISite->GetElement(&pElem);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->get_document(&pDoc); 
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IOleCommandTarget, (void**)&pioct);
    if (hr)
        goto Cleanup;

    hr = pioct->Exec(&CGID_MSHTML, IDM_GETPRINTTEMPLATE, NULL, NULL, &varRet);

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pDoc);
    ReleaseInterface(pioct);

    return  (hr || V_VT(&varRet) != VT_BOOL  || V_BOOL(&varRet) != VB_TRUE) ? FALSE : TRUE;
#endif
}

//------------------------------------------------------------------------------
//---------------------------------- Wrappers ----------------------------------
//------------------------------------------------------------------------------

STDAPI
SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pchPath)
{
    HMODULE hDLL = NULL;
    void *  pfnSHGetFolderPath = NULL ;

    if (g_fUseShell32InsteadOfSHFolder)
    {
        hDLL = LoadLibraryA("shell32.dll");
        if (hDLL)
        {
            pfnSHGetFolderPath = GetProcAddress(hDLL, "SHGetFolderPathA");

            if(!pfnSHGetFolderPath)
            {
                FreeLibrary(hDLL);
                hDLL = NULL;
            }
        }
    }

    if (!hDLL)
    {
        hDLL = LoadLibraryA("shfolder.dll");
        if (hDLL)
        {
            pfnSHGetFolderPath = GetProcAddress(hDLL, "SHGetFolderPathA");

            if(!pfnSHGetFolderPath)
            {
                FreeLibrary(hDLL);
                hDLL = NULL;
            }
        }

    }

    if (pfnSHGetFolderPath)
    {
        HRESULT hr = (*(HRESULT (STDAPICALLTYPE *)(HWND, int, HANDLE, DWORD, LPSTR))pfnSHGetFolderPath)
                        (hwnd, csidl, hToken, dwFlags, pchPath);

        FreeLibrary(hDLL);

        return hr;
    }

    return E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\atlutil.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLUTIL_H__
#define __ATLUTIL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#endif // __ATLUTIL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\atlbase.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef UNIX
#define MWNO_DEF_IN_TEMPLATES
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4711) // function 'function' selected for inline expansion
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <ddraw.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the _ASSERTE(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#include <stddef.h>
#include <tchar.h>
#include <malloc.h>
#include <olectl.h>
#include <winreg.h>

#define _ATL_PACKING 8
#pragma pack(push, _ATL_PACKING)

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#ifdef _DEBUG
void _cdecl AtlTrace(LPCTSTR lpszFormat, ...);
#define ATLTRACE            AtlTrace
#define ATLTRACENOTIMPL(funcname)   AtlTrace(_T("%s not implemented.\n"), funcname); return E_NOTIMPL
#else
inline void _cdecl AtlTrace(LPCTSTR , ...){}
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // ActiveX Template Library
#define _ATL_VER 0x0110 // ActiveX Template Library version 1.10

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_FORCE_LIBS
	#pragma comment(lib, "kernel32.lib")
	#pragma comment(lib, "user32.lib")
	#pragma comment(lib, "ole32.lib")
	#pragma comment(lib, "oleaut32.lib")
	#pragma comment(lib, "olepro32.lib")
	#pragma comment(lib, "uuid.lib")
	#pragma comment(lib, "advapi32.lib")
#endif // _ATL_NO_FORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
};

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

struct _ATL_OBJMAP_ENTRY; // fwd decl

struct _ATL_REGMAP_ENTRY
{
	LPCTSTR     szKey;
	LPCTSTR     szData;
};

class CComModule
{
// Operations
public:
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h);
	void Term();

	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock() {return CComGlobalsThreadModel::Decrement(&m_nLockCnt);}
	LONG GetLockCount() {return m_nLockCnt;}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInst;}
	HINSTANCE GetTypeLibInstance() {return m_hInst;}
	HINSTANCE GetRegistryResourceInstance() {return m_hInst;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex = NULL);
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE);
	HRESULT UnregisterServer();

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResource(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	#endif //_ATL_STATIC_REGISTRY

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags);
	HRESULT RevokeClassObjects();

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid,
		LPVOID* ppv);

// Attributes
public:
	HINSTANCE m_hInst;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CComGlobalsThreadModel::CriticalSection m_csTypeInfoHolder;
	CComGlobalsThreadModel::CriticalSection m_csObjMap;
};

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

inline HRESULT CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	_ASSERTE(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	_ASSERTE(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	_ASSERTE(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION
#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	_ASSERTE(lpa != NULL);
	_ASSERTE(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	_ASSERTE(lpw != NULL);
	_ASSERTE(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		AtlA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*2,\
		AtlW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); }
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline size_t ocslen(LPCOLESTR x) { return lstrlen(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); }
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#else
	inline size_t ocslen(LPCOLESTR x) { return lstrlenW(x); }
	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src)
	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
	//CharNextW doesn't work on Win95 so we use this
	inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR)(lp+1);}
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
#endif

#ifdef OLE2ANSI
	inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
	inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
	#define W2OLE W2A
	#define OLE2W A2W
	inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
	inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
	#define W2COLE W2CA
	#define OLE2CW A2CW
#else
	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA
#endif

#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	inline LPWSTR T2W(LPTSTR lp) { return lp; }
	inline LPTSTR W2T(LPWSTR lp) { return lp; }
	#define T2CA W2CA
	#define A2CT A2CW
	inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
	inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
	#define T2W A2W
	#define W2T W2A
	inline LPSTR T2A(LPTSTR lp) { return lp; }
	inline LPTSTR A2T(LPSTR lp) { return lp; }
	#define T2CW A2CW
	#define W2CT W2CA
	inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
	inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif

#ifndef _ATL_NO_OLEAUT
inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return ::SysAllocString(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {USES_CONVERSION; return ::SysAllocString(T2COLE(lp));}
	inline BSTR A2BSTR(LPCSTR lp) {USES_CONVERSION; return ::SysAllocString(A2COLE(lp));}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif
#endif  // !_ATL_NO_OLEAUT
#endif //!USES_CONVERSION

#pragma pack(pop)

#endif // __ATLBASE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\atlimpl.cpp ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLBASE_H__
	#error atlimpl.cpp requires atlbase.h to be included first
#endif

const IID IID_IRegister = {0xCC118C81,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};
const CLSID CLSID_Register = {0xCC118C85,0xB379,0x11CF,{0x84,0xE3,0x00,0xAA,0x00,0x21,0xF3,0x37}};

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComBSTR

CComBSTR& CComBSTR::operator=(const CComBSTR& src)
{
	if (m_str != src.m_str)
	{
		if (m_str)
			::SysFreeString(m_str);
		m_str = src.Copy();
	}
	return *this;
}

CComBSTR& CComBSTR::operator=(LPCOLESTR pSrc)
{
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(pSrc);
	return *this;
}

#ifndef OLE2ANSI
CComBSTR::CComBSTR(LPCSTR pSrc)
{
	USES_CONVERSION;
	m_str = ::SysAllocString(A2COLE(pSrc));
}

CComBSTR::CComBSTR(int nSize, LPCSTR sz)
{
	USES_CONVERSION;
	m_str = ::SysAllocStringLen(A2COLE(sz), nSize);
}

CComBSTR& CComBSTR::operator=(LPCSTR pSrc)
{
	USES_CONVERSION;
	if (m_str)
		::SysFreeString(m_str);

	m_str = ::SysAllocString(A2COLE(pSrc));
	return *this;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CComVariant

#ifndef OLE2ANSI
CComVariant::CComVariant(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantInit(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
}

CComVariant& CComVariant::operator=(LPCSTR lpsz)
{
	USES_CONVERSION;
	VariantClear(this);
	vt = VT_BSTR;
	bstrVal = ::SysAllocString(A2COLE(lpsz));
	return *this;
}
#endif
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

IUnknown* WINAPI _AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

IUnknown* WINAPI _AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

void WINAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
}

HRESULT WINAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

HRESULT WINAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

HRESULT AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComTypeInfoHolder

void CComTypeInfoHolder::AddRef()
{
	_Module.m_csTypeInfoHolder.Lock();
	m_dwRef++;
	_Module.m_csTypeInfoHolder.Unlock();
}

void CComTypeInfoHolder::Release()
{
	_Module.m_csTypeInfoHolder.Lock();
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	_Module.m_csTypeInfoHolder.Unlock();
}

HRESULT CComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	_Module.m_csTypeInfoHolder.Lock();
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	_Module.m_csTypeInfoHolder.Unlock();
	return hRes;
}

HRESULT CComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		pInfo->Release();
	}
	return hRes;
}

HRESULT CComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes)
{
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	_ASSERTE((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
	if (LoadString(_Module.GetResourceInstance(), nID, szDesc, 1024) == 0)
	{
		_ASSERTE(FALSE);
		lstrcpy(szDesc, _T("Unknown Error"));
	}
	AtlReportError(clsid, szDesc, iid, hRes);
	if (hRes == 0)
		hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	return hRes;
}

#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	USES_CONVERSION;
	return AtlReportError(clsid, A2CW(lpszDesc), iid, hRes);
}
#endif

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// QI implementation

#ifdef _ATL_DEBUG_QI
#define _DUMPIID(iid, name, hr) DumpIID(iid, name, hr)
#else
#define _DUMPIID(iid, name, hr) hr
#endif

HRESULT WINAPI CComObjectRoot::InternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	_ASSERTE(pThis != NULL);
	// First entry should be an offset (pFunc == 1)
	_ASSERTE(pEntries->pFunc == (_ATL_CREATORARGFUNC*)1);
#ifdef _ATL_DEBUG_QI
	LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
#endif // _ATL_DEBUG_QI
	if (ppvObject == NULL)
		return _DUMPIID(iid, pszClassName, E_POINTER);
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return _DUMPIID(iid, pszClassName, S_OK);
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == (_ATL_CREATORARGFUNC*)1) //offset
			{
				_ASSERTE(!bBlind);
				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return _DUMPIID(iid, pszClassName, S_OK);
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return _DUMPIID(iid, pszClassName, hRes);
			}
		}
		pEntries++;
	}
	return _DUMPIID(iid, pszClassName, E_NOINTERFACE);
}

#ifdef _ATL_DEBUG_QI

HRESULT CComObjectRoot::DumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	USES_CONVERSION;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType,dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	StringFromCLSID(iid, &pszGUID);
	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	// Attempt to find it in the interfaces section
	key.Open(HKEY_CLASSES_ROOT, _T("Interface"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(szName);
		goto cleanup;
	}
	// Attempt to find it in the clsid section
	key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
	if (key.Open(key, OLE2T(pszGUID)) == S_OK)
	{
		*szName = 0;
		RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
		OutputDebugString(_T("(CLSID\?\?\?) "));
		OutputDebugString(szName);
		goto cleanup;
	}
	OutputDebugString(OLE2T(pszGUID));
cleanup:
	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);
	return hr;
}
#endif

HRESULT WINAPI CComObjectRoot::_Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
	if (*pp == NULL)
	{
		_ThreadModel::CriticalSection* pcs =
			(_ThreadModel::CriticalSection*)((INT_PTR)pv + pcd->dwOffsetCS);
		pcs->Lock();
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		pcs->Unlock();
	}
	if (*pp != NULL)
		hRes = (*pp)->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	return pcd->pFunc(pv, iid, ppvObject);
}

HRESULT WINAPI CComObjectRoot::_Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	HRESULT hRes = E_NOINTERFACE;
	IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
	if (p != NULL)
		hRes = p->QueryInterface(iid, ppvObject);
	return hRes;
}

HRESULT WINAPI CComObjectRoot::_Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw)
{
	_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)(DWORD_PTR)dw;       //$WIN64 dw --> __ptr64
	void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
	return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
}

/////////////////////////////////////////////////////////////////////////////
// CComClassFactory

STDMETHODIMP CComClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
	REFIID riid, void** ppvObj)
{
	_ASSERTE(m_pfnCreateInstance != NULL);
	HRESULT hRes = E_POINTER;
	if (ppvObj != NULL)
	{
		*ppvObj = NULL;
		// can't ask for anything other than IUnknown when aggregating
		_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid));
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			hRes = CLASS_E_NOAGGREGATION;
		else
			hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	return hRes;
}

STDMETHODIMP CComClassFactory::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

STDMETHODIMP CComClassFactory2Base::LockServer(BOOL fLock)
{
	if (fLock)
		_Module.Lock();
	else
		_Module.Unlock();
	return S_OK;
}

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

CComConnectionPointBase* CComConnectionPointContainerImpl::
	FindConnPoint(REFIID riid)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		CComConnectionPointBase* pCP =
			(CComConnectionPointBase*)((INT_PTR)this+pEntry->dwOffset);
		if (InlineIsEqualGUID(riid, *pCP->GetIID()))
			return pCP;
		pEntry++;
	}
	return NULL;
}


void CComConnectionPointContainerImpl::InitCloneVector(
	CComConnectionPointBase** ppCP)
{
	const _ATL_CONNMAP_ENTRY* pEntry = GetConnMap();
	while (pEntry->dwOffset != (DWORD)-1)
	{
		*ppCP = (CComConnectionPointBase*)((INT_PTR)this+pEntry->dwOffset);
		ppCP++;
		pEntry++;
	}
}


STDMETHODIMP CComConnectionPointContainerImpl::EnumConnectionPoints(
	IEnumConnectionPoints** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComEnumConnectionPoints* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;

	// count the entries in the map
	_ATL_CONNMAP_ENTRY* pEntry = (_ATL_CONNMAP_ENTRY*)GetConnMap();
	int nCPCount=0;
	while (pEntry->dwOffset != (DWORD)-1)
	{
		nCPCount++;
		pEntry++;
	}
	_ASSERTE(nCPCount > 0);

	// allocate an initialize a vector of connection point object pointers
	CComConnectionPointBase** ppCP = (CComConnectionPointBase**)alloca(sizeof(CComConnectionPointBase*)*nCPCount);
	InitCloneVector(ppCP);

	// copy the pointers: they will AddRef this object
	HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
		(IConnectionPoint**)&ppCP[nCPCount], this, AtlFlagCopy);
	if (FAILED(hRes))
	{
		delete pEnum;
		return hRes;
	}
	hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}


STDMETHODIMP CComConnectionPointContainerImpl::FindConnectionPoint(
	REFIID riid, IConnectionPoint** ppCP)
{
	if (ppCP == NULL)
		return E_POINTER;
	*ppCP = NULL;
	HRESULT hRes = CONNECT_E_NOCONNECTION;
	CComConnectionPointBase* pCP = FindConnPoint(riid);
	if (pCP != NULL)
	{
		pCP->AddRef();
		*ppCP = pCP;
		hRes = S_OK;
	}
	return hRes;
}


BOOL CComDynamicArrayCONNECTDATA::Add(IUnknown* pUnk)
{
	if (m_nSize == 0) // no connections
	{
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		m_nSize = 1;
		return TRUE;
	}
	else if (m_nSize == 1)
	{
		//create array
		m_pCD = (CONNECTDATA*)malloc(sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		memset(m_pCD, 0, sizeof(CONNECTDATA)*_DEFAULT_VECTORLENGTH);
		m_pCD[0] = m_cd;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	int nAlloc = m_nSize*2;
	m_pCD = (CONNECTDATA*)realloc(m_pCD, sizeof(CONNECTDATA)*nAlloc);
	memset(&m_pCD[m_nSize], 0, sizeof(CONNECTDATA)*m_nSize);
	m_pCD[m_nSize].pUnk = pUnk;
	m_pCD[m_nSize].dwCookie = (DWORD)pUnk;
	m_nSize = nAlloc;
	return TRUE;
}

BOOL CComDynamicArrayCONNECTDATA::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	if (m_nSize == 1)
	{
		if (m_cd.dwCookie == dwCookie)
		{
			m_nSize = 0;
			return TRUE;
		}
		return FALSE;
	}
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionInterface(IID* piid)
{
	if (piid == NULL)
		return E_POINTER;
	*piid = *(IID*)GetIID();
	return S_OK;
}

STDMETHODIMP CComConnectionPointBase::GetConnectionPointContainer(IConnectionPointContainer** ppCPC)
{
	if (ppCPC == NULL)
		return E_POINTER;
	_ASSERTE(m_pContainer != NULL);
	*ppCPC = m_pContainer;
	m_pContainer->AddRef();
	return S_OK;
}

#endif //!_ATL_NO_CONNECTION_POINTS

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	_ASSERTE(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return (UINT)(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// Object Registry Support

static HRESULT WINAPI AtlRegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

#ifndef _ATL_NO_OLEAUT
HRESULT WINAPI CComModule::UpdateRegistryFromResource(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);
				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}

		CComVariant varRes;
		varRes.vt = VT_I2;
		varRes.iVal = (short)nResID;
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}

HRESULT WINAPI CComModule::UpdateRegistryFromResource(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CComPtr<IRegister> p;
	HRESULT hRes = CoCreateInstance(CLSID_Register, NULL,
		CLSCTX_INPROC_SERVER, IID_IRegister, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
		p->AddReplacement(CComBSTR(OLESTR("Module")), CComBSTR(szModule));
		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				_ASSERTE(NULL != pMapEntries->szData);

				CComBSTR bstrKey(pMapEntries->szKey);
				CComBSTR bstrValue(pMapEntries->szData);

				p->AddReplacement(bstrKey, bstrValue);
				pMapEntries++;
			}
		}
		CComVariant varRes(lpszRes);
		CComVariant varReg(OLESTR("REGISTRY"));
		GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
		CComBSTR bstrModule = szModule;
		if (bRegister)
		{
			hRes = p->ResourceRegister(bstrModule, varRes, varReg);
		}
		else
		{
			hRes = p->ResourceUnregister(bstrModule, varRes, varReg);
		}
	}
	return hRes;
}
#endif  // !_ATL_NO_OLEAUT

#ifdef _ATL_STATIC_REGISTRY
// Statically linking to Registry Ponent
HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes;
	varRes.vt = VT_I2;
	varRes.iVal = (short)nResID;
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}

HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	CRegObject      ro;
	CRegException   re;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
	ro.AddReplacement(OLESTR("Module"), CComBSTR(szModule));
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			_ASSERTE(NULL != pMapEntries->szData);
			ro.AddReplacement(CComBSTR(pMapEntries->szKey),
				CComBSTR(pMapEntries->szData));
			pMapEntries++;
		}
	}

	CComVariant varRes(lpszRes);
	CComVariant varReg(OLESTR("REGISTRY"));
	GetModuleFileName(_Module.GetRegistryResourceInstance(), szModule, _MAX_PATH);
	CComBSTR bstrModule = szModule;
	return (bRegister) ? ro.ResourceRegister(bstrModule, varRes, varReg, re) :
		ro.ResourceUnregister(bstrModule, varRes, varReg, re);
}
#endif // _ATL_STATIC_REGISTRY

#ifndef _ATL_NO_OLD_REGISTRY
HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

    if(lpsz == NULL) 
    {   
        if(lpOleStr)CoTaskMemFree(lpOleStr);
        return E_OUTOFMEMORY;
    }

	hRes = AtlRegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = AtlRegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"));
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					key.SetKeyValue(szLS32, szModule);
				else
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;
	key.Attach(HKEY_CLASSES_ROOT);
	key.RecurseDeleteKey(lpszProgID);
	key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID")) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}
#endif  // _ATL_NO_OLD_REGISTRY

#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

HRESULT CComModule::RegisterTypeLib(LPCTSTR lpszIndex)
{
    USES_CONVERSION;
    _ASSERTE(m_hInst != NULL);
    TCHAR szModule[_MAX_PATH+10];
    OLECHAR szDir[_MAX_PATH];
    szModule[0] = 0;
    GetModuleFileName(GetTypeLibInstance(), szModule, _MAX_PATH);
    if (lpszIndex != NULL)
        lstrcat(szModule, lpszIndex);
    ITypeLib* pTypeLib;
    LPOLESTR lpszModule = T2OLE(szModule);
    HRESULT hr = LoadTypeLib(lpszModule, &pTypeLib);
    if (!SUCCEEDED(hr))
    {
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, &pTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		ocscpy(szDir, lpszModule);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, lpszModule, szDir);
	}
	if (pTypeLib != NULL)
		pTypeLib->Release();
	return hr;
}
#endif  // !_ATL_NO_OLEAUT

/////////////////////////////////////////////////////////////////////////////
// CRegKey

LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	_ASSERTE(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	_ASSERTE(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		_ASSERTE(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	_ASSERTE((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	_ASSERTE(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifndef _ATL_NO_SECURITY

CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	m_pSD = new SECURITY_DESCRIPTOR;
	if (!m_pSD)
		return E_OUTOFMEMORY;
	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		_ASSERTE(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid;
	PSID pGroupSid;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (FAILED(hr))
		return hr;
	hr = SetOwner(pUserSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	hr = SetGroup(pGroupSid, bDefaulted);
	if (FAILED(hr))
		return hr;
	return S_OK;
}

HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (!m_pOwner)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	_ASSERTE(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (!m_pGroup)
	{
		// Insufficient memory to allocate Sid
		_ASSERTE(FALSE);
		return E_OUTOFMEMORY;
	}
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	_ASSERTE(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}

HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	return hr;
}


HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (!ptkUser)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			_ASSERTE(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (!ptkGroup)
		{
			// Insufficient memory to allocate TOKEN_USER
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid = (PSID) malloc(dwSize);
		if (!pSid)
		{
			// Insufficient memory to allocate Sid
			_ASSERTE(FALSE);
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			goto failed;
		}

		_ASSERTE(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pszRefDomain = new TCHAR[dwDomainSize];
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			if (!(m_pDACL = (PACL) malloc(pDACL->AclSize)))
				goto failed;

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			if (!(m_pSACL = (PACL) malloc(pSACL->AclSize)))
				goto failed;

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSD)
		free(m_pSD);
	return E_UNEXPECTED;
}

HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	newACL = (PACL) new BYTE[aclSize];

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID luid;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			_ASSERTE(FALSE);
			return hr;
		}
	}

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hToken, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		_ASSERTE(FALSE);
		return hr;
	}
	return S_OK;
}


#endif //_ATL_NO_SECURITY

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>

void _cdecl AtlTrace(LPCTSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	TCHAR szBuffer[512];

	nBuf = wvsprintf(szBuffer, lpszFormat, args);
	_ASSERTE(nBuf < sizeof(szBuffer));

	OutputDebugString(szBuffer);
	va_end(args);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Minimize CRT
// Specify DllMain as EntryPoint
// Turn off exception handling
// Define _ATL_MIN_CRT

#ifdef _ATL_MIN_CRT
/////////////////////////////////////////////////////////////////////////////
// Heap Allocation

#ifndef _DEBUG

#ifndef _ATL_NO_FLTUSED
extern "C" const int _fltused = 0;
#endif

#ifndef USE_IERT
void* __cdecl malloc(size_t n)
{
	if (_Module.m_hHeap == NULL)
	{
		_Module.m_hHeap = HeapCreate(0, 0, 0);
		if (_Module.m_hHeap == NULL)
			return NULL;
	}
	_ASSERTE(_Module.m_hHeap != NULL);

#ifdef _MALLOC_ZEROINIT
	void* p = HeapAlloc(_Module.m_hHeap, 0, n);
	if (p != NULL)
		memset(p, 0, n);
	return p;
#else
	return HeapAlloc(_Module.m_hHeap, 0, n);
#endif
}

void* __cdecl calloc(size_t n, size_t s)
{
#ifdef _MALLOC_ZEROINIT
	return malloc(n * s);
#else
	void* p = malloc(n * s);
	if (p != NULL)
		memset(p, 0, n * s);
	return p;
#endif
}

void __cdecl free(void* p)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	if (p != NULL)
		HeapFree(_Module.m_hHeap, 0, p);
}
#endif // USE_IERT

#if 0
void* __cdecl realloc(void* p, size_t n)
{
	_ASSERTE(_Module.m_hHeap != NULL);
	return (p == NULL) ? malloc(n) : HeapReAlloc(_Module.m_hHeap, 0, p, n);
}
#endif

#endif  //_DEBUG

#if !defined(_DEBUG) || defined(USE_IERT)

#ifndef _MERGE_PROXYSTUB
int __cdecl _purecall()
{
#if DBG==1
	DebugBreak();
#endif // DBG
	return 0;
}
#endif  // !_MERGE_PROXYSTUB

void* __cdecl operator new(size_t n)
{
	return malloc(n);
}

void __cdecl operator delete(void* p)
{
	free(p);
}
#endif //!defined(_DEBUG) || defined(USE_IERT)

#endif //_ATL_MIN_CRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\userdata.cxx ===
//===============================================================
//
//  userdata.cxx : Implementation of the CPersistUserData Peer
//
//  Synposis : this class is repsponsible for handling the "generic"
//      persistence of author data in the expanded cookie cahce
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

// Static data members

// User name related
TCHAR CPersistUserData::s_rgchUserData[] = TEXT("userdata");

// This global string will store the string userdata:username@. This is useful is several 
// situations and we want to avoid computing this over and over again. 
TCHAR CPersistUserData::s_rgchCacheUrlPrefix[ARRAY_SIZE(s_rgchUserData) + 1 /* for : */ +  MAX_PATH + 1 /* for @ */];
DWORD CPersistUserData::s_cchCacheUrlPrefix = 0;
BOOL  CPersistUserData::s_bCheckedUserName = FALSE;
BOOL  CPersistUserData::s_bCacheUrlPrefixRet = FALSE;


// cache container related
HRESULT CPersistUserData::s_hrCacheContainer;
BOOL  CPersistUserData::s_bCheckedCacheContainer = FALSE;

// Values below are the default ones used if not administrator provided override is seen.
// These values are in Kilo Bytes. 

// Initialize with hard-coded values if not admin limit specified.
DWORD CPersistUserData::s_rgdwDomainLimit[URLZONE_UNTRUSTED + 1] = 
        { 1024, 10240, 1024, 1024, 640 };
DWORD CPersistUserData::s_dwUnkZoneDomainLimit = 640;

DWORD CPersistUserData::s_rgdwDocLimit[URLZONE_UNTRUSTED + 1] = 
        { 128, 512, 128, 128, 64 };
DWORD CPersistUserData::s_dwUnkZoneDocLimit = 64;


// Critical sections for synchronization.

CRITICAL_SECTION CPersistUserData::s_csCacheUrlPrefix;
CRITICAL_SECTION CPersistUserData::s_csCacheContainer;
CRITICAL_SECTION CPersistUserData::s_csSiteTable;

CSiteTable * CPersistUserData::s_pSiteTable = NULL; 

DWORD CPersistUserData::s_dwClusterSizeMinusOne;
DWORD CPersistUserData::s_dwClusterSizeMask;
                     
// Registry location and keys to read the admin specified values from
#define KEY_PERSISTENCE     TEXT("Software\\Policies\\microsoft\\Internet Explorer\\Persistence")
#define VALUE_DOCUMENTLIMIT      TEXT("DocumentLimit")
#define VALUE_DOMAINLIMIT   TEXT("DomainLimit")

// Some character definitions which are useful in this file
const TCHAR chSLASH = TEXT('/');
const TCHAR chBACKSLASH = TEXT('\\');
const TCHAR chAT = TEXT('@');
const TCHAR chCOLON = TEXT(':');
// Character at the begining of a Unicode file.
const WCHAR wchLEADUNICODEFILE = 0xFEFF ;

const TCHAR rgchAnyUser[] = TEXT("anyuser");
const CHAR rgchRelAppData[] = "Microsoft\\Internet Explorer\\UserData";
const CHAR rgchRelCookies[] = "..\\UserData";

#ifndef unix
const CHAR schDIR_SEPERATOR = '\\';
#else
const CHAR schDIR_SEPERATOR = '/';
#endif

//+----------------------------------------------------------------------------
//
//  member : CPersistUserData::~CPersistUserData
//
//-----------------------------------------------------------------------------

CPersistUserData::~CPersistUserData()
{
    ClearInterface(&_pPeerSite);
    ClearInterface(&_pPeerSiteOM);
    ClearOMInterfaces();
}

//+----------------------------------------------------------------------------
//
//  Member : GlobalInit  (static)
//
//  Synopsis : this method is called once a DLL attach time to init static variables.
//
//-----------------------------------------------------------------------------
BOOL CPersistUserData::GlobalInit()
{
    // Initialize the critical sections we use.
    InitializeCriticalSection(&s_csCacheUrlPrefix);
    InitializeCriticalSection(&s_csCacheContainer);
    InitializeCriticalSection(&s_csSiteTable);

    // Read out admin specified limits if any.
    DWORD   dwLimit;
    DWORD   dwSize = sizeof(dwLimit);
    DWORD   dwType;
    HUSKEY  huskey = NULL;

    if ((SHRegOpenUSKey(KEY_PERSISTENCE, KEY_QUERY_VALUE, NULL, &huskey, FALSE)) == NOERROR)
    {
        // Should be more than enough to represent a zone id as a string.
        TCHAR rgchZone[10];

        for ( int i = 0 ; i < ARRAY_SIZE(s_rgdwDomainLimit) ; i++ )
        {
            HUSKEY husZoneKey = NULL;
            wnsprintf(rgchZone, ARRAY_SIZE(rgchZone), TEXT("%d"), i);

            if (SHRegOpenUSKey(rgchZone,  KEY_QUERY_VALUE, huskey, &husZoneKey, FALSE) == NOERROR)
            {  
                if ( (SHRegQueryUSValue(husZoneKey, VALUE_DOMAINLIMIT, &dwType, 
                                &dwLimit, &dwSize, FALSE, NULL, 0) == NOERROR) && 
                  
                      (dwType == REG_DWORD)
                    )
                {
                    s_rgdwDomainLimit[i] = dwLimit;
                }
                dwSize = sizeof(dwLimit);

                if ( (SHRegQueryUSValue(husZoneKey, VALUE_DOCUMENTLIMIT, &dwType, 
                                &dwLimit, &dwSize, FALSE, NULL, 0) == NOERROR) && 
                  
                      (dwType == REG_DWORD)
                    )
                {
                    s_rgdwDocLimit[i] = dwLimit;
                }
                SHRegCloseUSKey(husZoneKey);
            }

            dwSize = sizeof(dwLimit);
        }
    }

    if (huskey)
    {
        SHRegCloseUSKey(huskey);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member : GlobalUninit  (static)
//
//  Synopsis : this method is called at DLL detach time to uninit static variables.
//
//-----------------------------------------------------------------------------

BOOL CPersistUserData::GlobalUninit( )
{
    DeleteSiteTable();
    DeleteCriticalSection(&s_csCacheUrlPrefix);
    DeleteCriticalSection(&s_csCacheContainer);
    DeleteCriticalSection(&s_csSiteTable);
    return TRUE;
}
        
    
//+----------------------------------------------------------------------------
//
//  Member : Init
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::Init(IElementBehaviorSite * pPeerSite)
{
    if (!pPeerSite)
        return E_INVALIDARG;

    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();


    return _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, 
                                         (void**)&_pPeerSiteOM);
}

//+----------------------------------------------------------------------------
//
//  Member : Notify
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+-----------------------------------------------------------------------
//
//  Member : ClearOMInterfaces ()
//
//  Synopsis : this helper function is called after the Save/Load persistenceCache
//      operations are finished, and is responsible for freeing up any of hte OM 
//      interfaces that were cached.
//
//------------------------------------------------------------------------
void
CPersistUserData::ClearOMInterfaces()
{
    ClearInterface(&_pRoot);
    ClearInterface(&_pInnerXMLDoc);
}

//+----------------------------------------------------------------
//
// Member : initXMLCache
//
//  Synopsis : Helper function, this is responsible for cocreateing the 
//      XML object and initializing it for use.
//              the fReset flag indicates that the contents of teh xmlCache 
//      should be cleared  It is assumed in this case that the cache already exists
//
//-----------------------------------------------------------------
HRESULT
CPersistUserData::initXMLCache(BOOL fReset/*=false*/)
{
    HRESULT             hr = S_OK;
    BSTR                bstrStub = NULL;
    VARIANT_BOOL        vtbCleanThisUp;
    IObjectSafety     * pObjSafe = NULL;

    if (!fReset)
    {
        // are we already initialized?
        if (_pInnerXMLDoc && _fCoCreateTried)
            goto Cleanup;

        // protect against expensive retries if over network
        _fCoCreateTried = true;  

        hr = CoCreateInstance(CLSID_DOMDocument,
                                  0,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IXMLDOMDocument,
                                  (void **)&_pInnerXMLDoc);

        if (hr)
            goto Cleanup;

        hr = _pInnerXMLDoc->QueryInterface(IID_IObjectSafety, 
                                           (void **)&pObjSafe);
        if (hr)
            goto ErrorCase;

        hr = pObjSafe->SetInterfaceSafetyOptions( IID_NULL, 
                                                  INTERFACE_USES_SECURITY_MANAGER, 
                                                  INTERFACE_USES_SECURITY_MANAGER);
        if (hr)
            goto ErrorCase;
    }

    // one last error check
    if (_pInnerXMLDoc)
    {
        // now create some XML tree
        bstrStub = SysAllocString(L"<ROOTSTUB />");
        if (bstrStub )
        {
            hr = _pInnerXMLDoc->loadXML(bstrStub, &vtbCleanThisUp);
            SysFreeString( bstrStub );
            if (hr)
                goto ErrorCase;
        }

        // TODO: we no longer need to really cache the _pRoot, why not
        hr = _pInnerXMLDoc->get_documentElement( &_pRoot);
        if (hr)
            goto ErrorCase;
    }


Cleanup:
    ReleaseInterface(pObjSafe);

    if (hr == S_FALSE)
        hr = S_OK;
    return hr ;

ErrorCase:
    ClearInterface(&_pInnerXMLDoc);
    goto Cleanup;
}

//+----------------------------------------------------------------
//
//  Member : SecureDomainAndPath
//
//  synopsis : this helper function is responsisble for the domain
//      and path level security when a user wants to save or load a 
//      store.
//          We use the security manager if possible so that HTA's
//      are handled properly.
//          This will return a substring of the pstrFileName, if the
//      user explicitly specified a store.  
//      The logic of this function is basically:
//          if pstrFileName is only a name return TRUE (and use the DirPath)
//          else { extract the store from pstrFileName
//                 compare the Name's path to the DirPath via domain et al
//                      using the security manager
//                 if that passes, then do a path comparison, since the 
//                      security mgr only handles domains
//
//    valid formats for pstrFileName:
//      Foo
//      userdata:foo
//      file://c:/temp/foo
//      userdata:file://c:/temp/foo
//+----------------------------------------------------------------
BOOL
CPersistUserData::SecureDomainAndPath(LPOLESTR pstrFileName,
                                      LPOLESTR *ppstrStore,
                                      LPOLESTR *ppstrPath,
                                      LPOLESTR *ppstrName)
{
    BOOL               fRet = FALSE;
    DWORD              cchPath; 
    LPTSTR             pszPath = NULL, pStore = NULL;
    LPOLESTR           pstrDirPath  = NULL;
    IHTMLElement     * pPeerElement   = NULL;
    IInternetSecurityManager * pSecMgr = NULL;
    DWORD              dwPolicy = 0;
    DWORD              dwZone = URLZONE_INVALID;

    if (!pstrFileName)
        goto Cleanup;

    Assert(ppstrStore && ppstrPath && ppstrName);

    *ppstrStore = *ppstrPath = *ppstrName = NULL;

    // get the doc's path
    if (FAILED(GetDirPath(&pstrDirPath)))
        goto Cleanup;

    Assert(pstrDirPath != NULL);

    // Only allow userdata saves and loads from supported schemes. 
    if (!IsSchemeAllowed(pstrDirPath))
        goto Cleanup;

    // pull the store off the front
    //-----------------------------------------------
    pStore = _tcschr(pstrFileName, _T(':'));
    if (pStore)
    {
        // we found one, if the next character is a / or a \
        //   then the format must be scheme://  otherwise
        //   userdata:http:// or store:file://c:\temp  is assumed
        //-------------------------------------------------
        if ( pStore[1]  != chSLASH && pStore[1] != chBACKSLASH)
        {
            long cchStore = (long)(pStore - pstrFileName);

            // copy the 'store:' over to the out parameter,
            // advance the Name to 
            (*ppstrStore) = new TCHAR [cchStore+1];
            if (!*ppstrStore)
                goto Cleanup;
                
            memcpy(*ppstrStore, pstrFileName, cchStore);
            (*ppstrStore)[cchStore] = _T('\0');
            pstrFileName = pStore +1;
        }
    }
    
    // first determine if the pstrFileName is just a name or 
    // a fully specified path. if there is a slash, then its
    // fully specified.
    //------------------------------------------------------
    if (!_tcschr(pstrFileName, _T('\\')) && 
        !_tcschr(pstrFileName, _T('/')))
    {
        long cchName = (_tcslen(pstrFileName)+1);
        cchPath = (_tcslen(pstrDirPath)+1);

        *ppstrName = new TCHAR [cchName];
        *ppstrPath = new TCHAR [cchPath];
        if (!*ppstrName || !*ppstrPath)
            goto Cleanup;
            
        memcpy(*ppstrName, pstrFileName, cchName*sizeof(TCHAR));
        memcpy(*ppstrPath, pstrDirPath, cchPath*sizeof(TCHAR));

        fRet = TRUE;
        // Fall through and make sure that the zone policy for pstrDirPath 
        // allows us to do userdata operations.
    }

    if (FAILED(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0)))
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (FAILED(pSecMgr->MapUrlToZone(pstrDirPath, &dwZone, 0)))
    {
        fRet = FALSE;
        goto Cleanup;
    }

    SetZone(dwZone);
                            
    if ( FAILED(pSecMgr->ProcessUrlAction(pstrDirPath,
                                URLACTION_HTML_USERDATA_SAVE,
                                (BYTE *)&dwPolicy,
                                sizeof(dwPolicy),
                                NULL,
                                0,
                                PUAF_NOUI,
                                0))
            ||
          (GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
        )
    {
        fRet = FALSE;
        goto Cleanup;
    }

    // If fRet is TRUE it implies that the filename was a relative path.
    // In this case we don't need to do further checks, we can return 
    // success at this point.
    if (fRet)
        goto Cleanup;

    // at this point the store is pulled of the front (if it was specified);
    // the pstrFileName is ready to be domain and path compared for security
    //
    // do security mgr (domain) test first
    // ---------------------------------------------------------------------
    {
        TCHAR  achURL[INTERNET_MAX_URL_LENGTH];
        BYTE   abSID1[MAX_SIZE_SECURITY_ID];
        BYTE   abSID2[MAX_SIZE_SECURITY_ID];
        DWORD  cbSID1 = ARRAY_SIZE(abSID1);
        DWORD  cbSID2 = ARRAY_SIZE(abSID2);
        DWORD  dwSize;


        // Unescape the URL of the name. (be safe)
        //------------------------------------------
        if (FAILED(CoInternetParseUrl(pstrFileName, PARSE_ENCODE, 0, achURL, 
                                      ARRAY_SIZE(achURL), &dwSize, 0)))
            goto Cleanup;

        if (FAILED(pSecMgr->GetSecurityId(pstrDirPath, (LPBYTE)&abSID1, &cbSID1, 0)))
            goto Cleanup;

        if (FAILED(pSecMgr->GetSecurityId(achURL, (LPBYTE)&abSID2, &cbSID2, 0)))
            goto Cleanup;

        // compare the security ID's
        if (cbSID1 != cbSID2 || (0 != memcmp(abSID1, abSID2, cbSID1)))
            goto Cleanup;
    }

    // at this point, we know that the domains match so we now need to
    // make sure that if there are paths, then they follow the rules:
    //    if dirPath is "a\b\c"  then the Name path
    // can be :  "\a\b\c\d\name" or "\a\b\name or a\name"
    // but NOT : "\g\name"  or "a\f\name" or "a\b\f\name"
    //----------------------------------------------------------------

    URL_COMPONENTS ucFile, ucDoc;
    memset(&ucFile, 0, sizeof(ucFile));
    memset(&ucDoc, 0, sizeof(ucDoc));

    ucFile.dwStructSize = sizeof(ucFile);
    ucFile.lpszUrlPath = NULL; 
    ucFile.dwUrlPathLength = 1;

    ucDoc.dwStructSize = sizeof(ucDoc);
    ucDoc.lpszUrlPath = NULL; 
    ucDoc.dwUrlPathLength = 1;

    if (!InternetCrackUrl(pstrFileName, 0, 0, &ucFile))
        goto Cleanup;

    if (!InternetCrackUrl(pstrDirPath, 0, 0, &ucDoc))
        goto Cleanup;

    // Strip off the document from the filepath.
    // because the doc path came from DirPath() I know
    // that it has no trailing name or slash
    cchPath = ucFile.dwUrlPathLength;
    pszPath = ucFile.lpszUrlPath;

    for (;cchPath > 0; cchPath--) 
    {
        if ( pszPath[cchPath - 1]  == chSLASH || pszPath[cchPath - 1] == chBACKSLASH)
        {
            cchPath--;  // Skip over the /
            break;
        }
    }

    // yes, this changes the passed in string... SO DON"T change cchPath or
    // add a "goto Cleanup" in the following block of code.
    {
        TCHAR  chReplace = pszPath[cchPath];
        pszPath[cchPath] = _T('\0'); // chop into 2 parts

        // now, one of the two paths better be a substring of the other 
        //  how do we do this case - insensitive?
        //--------------------------------------------------------------------
        if (_tcsistr(ucDoc.lpszUrlPath, pszPath) ||
            _tcsistr(pszPath, ucDoc.lpszUrlPath))
        {
            // we have a valid name!!! 
            fRet = TRUE;

            // extract the File Name
            long cch = (ucFile.dwUrlPathLength- cchPath);
            *ppstrName = new TCHAR [cch];
            if (!*ppstrName)
            {
                fRet = FALSE;
                goto Cleanup;
            }
            
            memcpy(*ppstrName, (LPTSTR)&(pszPath[cchPath+1]), cch*sizeof(TCHAR));

            // and the path
            cch = (1+cchPath);
            *ppstrPath = new TCHAR [cch];
            memcpy(*ppstrPath, pszPath, cch*sizeof(TCHAR));
        }
        pszPath[cchPath] = chReplace;
    }


Cleanup:
    delete [] pstrDirPath;
    ReleaseInterface( pPeerElement );
    ReleaseInterface( pSecMgr );
    return fRet;
}

//+----------------------------------------------------------------
//
// Member: IsSchemeAllowed
// Synopsis: Given the directory path of the document trying to save the 
//           userdata object determines if the scheme (i.e. protocol) it uses
//           is supported. 
//------------------------------------------------------------------

BOOL CPersistUserData::IsSchemeAllowed(LPCOLESTR pStrDirPath)
{
    PARSEDURL pu;
    BOOL fRet = FALSE;

    pu.cbSize = sizeof(pu);
    HRESULT hr = ParseURL(pStrDirPath, &pu);

    if (hr == S_OK)
    {
        switch(pu.nScheme)
        {
            case URL_SCHEME_MAILTO:
            case URL_SCHEME_NEWS:
            case URL_SCHEME_NNTP:
            case URL_SCHEME_TELNET:
            case URL_SCHEME_WAIS:
            case URL_SCHEME_SNEWS:
            case URL_SCHEME_SHELL:
            case URL_SCHEME_JAVASCRIPT:
            case URL_SCHEME_VBSCRIPT:
            case URL_SCHEME_ABOUT:
            case URL_SCHEME_MK:
                fRet = FALSE;
                break;
            default:
                fRet = TRUE;
                break;
        }
    }

    return fRet;
}

//+----------------------------------------------------------------
//
// Member : GetDirPath
//
// Synopsis :  Helper function to figures out the directory which the current doc lives in
//          For example if the doc URL is http://www.foo.com/bar/goo/abc.htm?x=y
//          This function will extract out http://www.foo.com/bar/goo
//          
//-----------------------------------------------------------------

HRESULT 
CPersistUserData::GetDirPath(LPOLESTR *ppDirPath)
{
    HRESULT          hr;
    IHTMLElement   * pPeerElement   = NULL;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    BSTR             bstrURL = NULL;
    LPOLESTR         pStr = NULL;

    if (ppDirPath == NULL)
    {
        hr = E_POINTER;
        return hr;
    }

    _pPeerSite->GetElement(&pPeerElement);
    Assert(pPeerElement != NULL);

    if ((hr = pPeerElement->get_document(&pdispBrowseDoc)) != S_OK)
        goto cleanup;

    if ((hr = pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                        (void**)&pBrowseDoc)) != S_OK)
        goto cleanup;

    if ((hr = pBrowseDoc->get_URL(&bstrURL)) != S_OK)
        goto cleanup;
    
    URL_COMPONENTS uc;
    memset(&uc, 0, sizeof(uc));

    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = NULL;
    uc.dwSchemeLength = 1;      // let's us get the scheme back.
    uc.lpszHostName = NULL;
    uc.dwHostNameLength = 1;
    uc.lpszUrlPath = NULL;
    uc.dwUrlPathLength = 1;
    // Important: even though we don't care about the extra info
    // we have to ask for it. If we don't InternetCrackUrl returns everything
    // after the HostName as the urlPath. We don't want the query string or the 
    // fragment in our dwUrlPathLength.

    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 1;

    if (!InternetCrackUrl(bstrURL, 0, 0, &uc))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // Allocate enough memory for the whole URL. 
    DWORD dwStrLen;

    dwStrLen = lstrlen(bstrURL) + 1;

    pStr = new WCHAR[dwStrLen];

    if (pStr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Strip off the document from the path. 
    DWORD cchPath; 
    LPTSTR pszPath;

    cchPath = uc.dwUrlPathLength;
    pszPath = uc.lpszUrlPath;

    for (;cchPath > 0; cchPath--) 
    {
        if ( pszPath[cchPath - 1]  == chSLASH  || pszPath[cchPath - 1] == chBACKSLASH)
        {
            cchPath--;  // Skip over the /
            break;
        }
    }

    if (uc.dwUrlPathLength && !cchPath)
    {
        // this case can only happen when there is no path. e.g. http://server/document.htm
        // we can't just use 0 for cchPath since InternetCreateUrl won't properly remove
        // the document name.  so let cchPath=1, and point to the "/" this will allow ICU to
        // create the url properly without the name.
        cchPath = 1;
    }

    uc.dwUrlPathLength = cchPath;
    // When creating the path we don't want the extra info to be included in the 
    // URL.
    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 0;

    if (!InternetCreateUrl(&uc, 0, pStr, &dwStrLen))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // It is important that we do this so that www%20foo%20com and www.foo.com are 
    // treated as the same site. 
    hr = UrlUnescape(pStr, NULL, 0, URL_UNESCAPE_INPLACE);
    if (hr != S_OK)
        goto cleanup;
    
    *ppDirPath = pStr;
    pStr = NULL;    // So we don't free it...
    hr = S_OK;

cleanup:

    ReleaseInterface(pPeerElement);
    ReleaseInterface(pdispBrowseDoc);
    ReleaseInterface(pBrowseDoc);
    SysFreeString(bstrURL);
    delete [] pStr;
        
    return hr;
}

//+----------------------------------------------------------------
//
// Member : save
//
//-----------------------------------------------------------------
STDMETHODIMP 
CPersistUserData::save(BSTR  bstrName)
{
    HRESULT       hr = S_OK;
    BSTR          bstrValue = NULL;
    DWORD         cbDataLen = 0;
    LPOLESTR      pstrCacheStore = NULL;
    LPOLESTR      pstrCachePath  = NULL;
    LPOLESTR      pstrCacheName  = NULL;
    

    // verify parameters
    //---------------------------------------
    if (!bstrName || !SysStringLen(bstrName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pInnerXMLDoc || !_pRoot)
        goto Cleanup;

    // do a security check between the DirPath() and the bstrName 
    // the user provided.  This bool test also returns the various store
    // names
    //---------------------------------------------------------
    if (!SecureDomainAndPath(bstrName, 
                             &pstrCacheStore, 
                             &pstrCachePath, 
                             &pstrCacheName))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // security test passed. prepare the data
    // get the text of the XML document and
    // load the variant 
    //-----------------------------------------------------------
    hr = _pInnerXMLDoc->get_xml( &bstrValue);
    if (hr)
        goto Cleanup;

    // now convert the data to an appendable/useable format
    cbDataLen = SysStringLen(bstrValue) * sizeof(WCHAR);

    // If there was no explicit store, or explictly "userdata"
    // then pass this off to the userData store.  otherwise
    // (for future implementions) pass this off to the appropriate
    // storage mechanism.
    //
    //   TODO - change this API to take a IPersist<something>
    //   interface rather than a string/byte pointer.  This will make
    //   it more general and veratile for the future.
    //------------------------------------------------------------
    if (!pstrCacheStore || !_tcscmp(pstrCacheStore, s_rgchUserData) )
    {
        hr = SaveUserData(pstrCachePath, 
                          pstrCacheName, 
                          bstrValue, 
                          cbDataLen, 
                          _ftExpires, 
                          UDF_BSTR); 
    }
    // else
    //  save to alternative store: NYI

Cleanup:
    delete [] pstrCacheStore;
    delete [] pstrCacheName;
    delete [] pstrCachePath;
    SysFreeString(bstrValue);

    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::load
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::load (BSTR strName)
{
    HRESULT        hr = S_OK;
    BSTR           strData = NULL;
    DWORD          dwSize = 0;
    LPOLESTR       pstrCacheStore = NULL;
    LPOLESTR       pstrCachePath  = NULL;
    LPOLESTR       pstrCacheName  = NULL;
    VARIANT_BOOL   vtbCleanThisUp;

    if (!strName || !SysStringLen(strName))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // do a security check between the DirPath() and the bstrName 
    // the user provided.  This bool test also returns the various store
    // names
    //---------------------------------------------------------
    if (!SecureDomainAndPath(strName, 
                             &pstrCacheStore, 
                             &pstrCachePath, 
                             &pstrCacheName))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // If there was no explicit store, or explictly "userdata"
    // then pass this off to the userData store.  otherwise
    // (for future implementions) pass this off to the appropriate
    // storage mechanism.
    //
    //   TODO - change this API to take a IPersist<something>
    //   interface rather than a string/byte pointer.  This will make
    //   it more general and veratile for the future.
    //------------------------------------------------------------
    if (!pstrCacheStore || !_tcscmp(pstrCacheStore, s_rgchUserData) )
    {
        // If the UDF_BSTR flag is specified we get back a BSTR in 
        hr = LoadUserData(pstrCachePath, 
                          pstrCacheName, 
                          (LPVOID *)&strData, 
                          &dwSize, 
                          UDF_BSTR);
    }
    // else
    //     load from alternate store : NYI 

    if (hr)  // Couldn't read the data.
        goto Cleanup;

    ClearInterface(&_pRoot);
    hr = _pInnerXMLDoc->loadXML(strData, &vtbCleanThisUp);
    if (hr)
        goto Cleanup;

    hr = _pInnerXMLDoc->get_documentElement( &_pRoot );

Cleanup:
    if (hr)
    {
        // If the document didn't exist return an empty document.
        if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
             hr == S_FALSE )
            hr = S_OK;

        // we need to make sure that there is a usable cache 
        // coming out of this function.  Even if we were unable 
        // to loadit
        initXMLCache(true);
    }
    delete [] pstrCacheStore;
    delete [] pstrCacheName;
    delete [] pstrCachePath;
    SysFreeString(strData);

    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::get_xmlDocument
//
//  Synopsis:   IHTMLUserData OM proeprty implementation. this is the default 
//                  property for this object, and as such it exposes the XMLOM
//                  of the user data.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::get_XMLDocument (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    if (_pInnerXMLDoc)
        hr = _pInnerXMLDoc->QueryInterface(IID_IDispatch, (void**)ppDisp);

Cleanup:
    return hr ;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::getAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistUserData::getAttribute (BSTR strName, VARIANT * pvarValue )
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantClear(pvarValue);

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->getAttribute(strName, pvarValue);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::setAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::setAttribute (BSTR strName, VARIANT varValue)
{
    HRESULT  hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // save this value as an attribute on the root.
    if (_pRoot)
    {
        VARIANT * pvar;
        CVariant cvarTemp;

        if ((V_VT(&varValue)==VT_BSTR) || 
             V_VT(&varValue)==(VT_BYREF|VT_BSTR))
        {
            pvar = (V_VT(&varValue) & VT_BYREF) ?
                    V_VARIANTREF(&varValue) : &varValue;
        }
        else if ((V_VT(&varValue)==VT_BOOL ||
                 V_VT(&varValue)==(VT_BYREF|VT_BOOL)))
        {
            // sadly, do our own bool conversion...
            VARIANT_BOOL vbFlag = (V_VT(&varValue)==VT_BOOL) ?
                                   V_BOOL(&varValue) :
                                   V_BOOL( V_VARIANTREF(&varValue) );

            V_VT(&cvarTemp) = VT_BSTR;
            V_BSTR(&cvarTemp) = vbFlag ? SysAllocString(L"true") :
                                         SysAllocString(L"false");

            pvar = & cvarTemp;
        }
        else
        {
            pvar = &varValue;

            hr = VariantChangeTypeEx(pvar, pvar, LCID_SCRIPTING, 0, VT_BSTR);
            if (hr)
                goto Cleanup;
        }

        hr = _pRoot->setAttribute(strName, *pvar);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}



//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::removeAttribute
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

STDMETHODIMP
CPersistUserData::removeAttribute (BSTR strName)
{
    HRESULT hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = initXMLCache();
    if (hr)
        goto Cleanup;

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->removeAttribute(strName);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//+--------------------------------------------------------------------------
//
//  Member : get_expires
//
//  Synopsis : returns the expiration time of the currently loaded data store
//      If there is not expiration time set, it returns an null string.
//
//---------------------------------------------------------------------------
HRESULT
CPersistUserData::get_expires(BSTR * pstrDate)
{
    HRESULT  hr = S_OK;
    FILETIME ftZero = {0};

    if (!pstrDate)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pstrDate = NULL;

    // only set the return string if there is a non-zero time set
    if (CompareFileTime(&ftZero, &_ftExpires) != 0)
    {
        TCHAR    achDate[DATE_STR_LENGTH];

        hr = ConvertGmtTimeToString(_ftExpires, 
                                    (LPTSTR)&achDate, 
                                    DATE_STR_LENGTH);

        (*pstrDate) = SysAllocString(achDate);
        if (!*pstrDate)
            hr = E_OUTOFMEMORY;
    }

Cleanup:
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member : put_expires
//
//  Synopsis : set the expiration time to be used when the current data store
//      is saved.  If the save method is not called, this has no real effect
//              The date string passed in is expected in GMT format just like
//      other script dates.  Specifically, this uses the same format as cookies
//      which is the format returned by the Date.toGMTString() script call.
//      e.g. "Tue, 02 Apr 1996 02:04:57 UTC"
//
//---------------------------------------------------------------------------
HRESULT
CPersistUserData::put_expires(BSTR bstrDate)
{
    HRESULT   hr;
    FILETIME  ftTemp;

    if (!bstrDate)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = ParseDate(bstrDate, &ftTemp);
    // S_FALSE means that ere  was a parse error
    if (hr ==S_FALSE)
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        _ftExpires = ftTemp;

Cleanup:
    return hr;
}

//============================================================================
//
// Private members of CPersistData to help with the persistence
//
//============================================================================
//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::LoadUserData
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//  If UDF_BSTR is passed the size is the number of bytes in the string, 
//          excluding the null terminator
//
//---------------------------------------------------------------------------

HRESULT 
CPersistUserData::LoadUserData(
    LPCOLESTR pwzDirPath, 
    LPCOLESTR pwzName, 
    LPVOID *ppData, 
    LPDWORD pdwSize, 
    DWORD dwFlags
    )
{
    HRESULT hr = E_UNEXPECTED;
    LPTSTR pszCacheUrl = NULL;
    DWORD dwError;
    BYTE *buffer = NULL;
    BYTE * pOutBuffer = NULL;
    FILETIME ftZero = {0};

    HANDLE hUrlCacheStream = NULL;

    if (pdwSize == NULL)
    {
        hr = E_POINTER;
        goto cleanup;
    }

    if ((hr = EnsureCacheContainer()) != S_OK)
        return hr;

    // Get the cache url for this document. 
    if ((hr = GetCacheUrlFromDirPath(pwzDirPath, pwzName, &pszCacheUrl)) != S_OK)
    {
        goto cleanup;
    }
    
    Assert(pszCacheUrl != NULL);

    // Now try to retreive the information from the cache.
    LPINTERNET_CACHE_ENTRY_INFO pICEI;
    DWORD cbICEI;

    cbICEI = sizeof(INTERNET_CACHE_ENTRY_INFO) + MAX_PATH /* for the path */ + 1024 /* for URL dir */;
    buffer = new BYTE[cbICEI];
    pICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
    
    if (pICEI == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    
    DWORD dwBufSize;
    dwBufSize = cbICEI;

    hUrlCacheStream = NULL;          
    if ((hUrlCacheStream = RetrieveUrlCacheEntryStream(pszCacheUrl, pICEI, &dwBufSize, FALSE,0)) == NULL)
    {

        dwError = ::GetLastError();
        // Try with more memory if the buffer was insufficient.
        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            // If we failed because of insufficient buffer, dwBufSize 
            // better be bigger than the original buffer.
            Assert(dwBufSize > cbICEI);

            delete [] buffer;
            cbICEI = dwBufSize;
            buffer = new BYTE[cbICEI];
            pICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
            if (!pICEI)
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            if ((hUrlCacheStream = RetrieveUrlCacheEntryStream(pszCacheUrl, pICEI, &dwBufSize, FALSE,0)) == NULL)
                dwError = ::GetLastError();
            else
                dwError = NOERROR;
        }

        if (dwError != NOERROR)
        {
            // Try to nuke it so it doesn't bother us in the future.
            hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }
    }

    Assert(hUrlCacheStream != NULL);

    FILETIME currTime;
    GetSystemTimeAsFileTime(&currTime);

    if ((CompareFileTime(&ftZero, &(pICEI->ExpireTime)) != 0) && // ExpireTime is not zero
        (CompareFileTime(&currTime, &(pICEI->ExpireTime))  > 0)  //currentTime is not beyond expired time.
       ) 
    {
        // It is okay to delete the entry even though we have a handle open to it. 
        // the file will get destroyed once we release the handle. 
        DeleteUrlCacheEntry(pszCacheUrl);

#if 0  //  ISSUE: TODO:- sanjays - The logic below is incorrect and needs to be fixed. 
        // To ensure correctness at this point we should delete the sizeof the
        // document from the quota
        LPTSTR pszSite;
        DWORD cchSite;
        if (CreateSiteTable() == S_OK && 
            GetSiteFromCacheUrl(pszCacheUrl, &pszSite, &cchSite) == S_OK)
        {
            pszSite[cchSite] = 0;
            ModifySitesSpaceUsage(pszSite, -(int)RealDiskUsage(pICEI->dwSizeLow));
        }
#endif
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto cleanup;
    }

    DWORD dwOutBufSize;

    dwOutBufSize = pICEI->dwSizeLow;

    // Caller is not interested in the buffer, just wants to the know the amount of 
    // memory required.

    if (ppData == NULL)
    {
        *pdwSize = dwOutBufSize;
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto cleanup;
    } 

    DWORD dwStreamPosition;
    dwStreamPosition = 0;

    // Allocate memory to read in the buffer. 
    if (dwFlags & UDF_BSTR)
    {
        // If we are retrieving a BSTR, we better have an even number of bytes in the stream.
        Assert((dwOutBufSize & 0x1) == 0x0);

        // Since BSTR's are stored as Unicode files they have the lead unicode bytes 
        // We should skip over these and real the actual data.
        DWORD dwLeadCharSize = sizeof(OLECHAR);
        OLECHAR wchLead;

        if (!ReadUrlCacheEntryStream(hUrlCacheStream, 0, &wchLead, &dwLeadCharSize, 0))
        {
            dwError = ::GetLastError();
            hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }

        // the first two bytes should be the lead unicode file character.
        Assert(wchLead == wchLEADUNICODEFILE);

        dwOutBufSize -= sizeof(OLECHAR);
        dwStreamPosition += sizeof(OLECHAR);
            
        DWORD cch = (dwOutBufSize/sizeof(OLECHAR)); 
        pOutBuffer = (BYTE *) SysAllocStringLen(NULL, cch);
        // SysAllocStringLen will null terminate the string;
    }           
    else
    {
        pOutBuffer = new BYTE[dwOutBufSize];
    }

    if (pOutBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (!ReadUrlCacheEntryStream(hUrlCacheStream, dwStreamPosition, pOutBuffer, &dwOutBufSize, 0))
    {
        dwError = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto cleanup;
    }

    // set the pICEI->ExpireTime to the local value to support get_expires.
    if (CompareFileTime(&ftZero, &(pICEI->ExpireTime)) != 0)
    {
        _ftExpires = pICEI->ExpireTime;
    }

    *ppData = (LPVOID)pOutBuffer;
    *pdwSize = dwOutBufSize;
    pOutBuffer = NULL;
    hr = S_OK;

cleanup:

    delete [] pszCacheUrl;
    delete [] buffer;
    delete [] pOutBuffer;

    if (hUrlCacheStream != NULL)
        UnlockUrlCacheEntryStream(hUrlCacheStream, 0);

    return hr;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistUserData::SaveUserData
//
//  Synopsis:   IHTMLUserData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT 
CPersistUserData::SaveUserData(
    LPCOLESTR pwzDirPath, 
    LPCOLESTR pwzName, 
    LPVOID pData, 
    DWORD dwSize, 
    FILETIME ftExpire, 
    DWORD dwFlags 
    )
{
    // Do Parameter validation.
    HRESULT hr;
    DWORD dwError = NOERROR;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTSTR pszCacheUrl = NULL;
    FILETIME ftZero = { 0 };
    BOOL fAddLeadUnicodeChar = (dwFlags & UDF_BSTR) ? TRUE : FALSE;
     
    if ((hr = EnsureCacheContainer()) != S_OK)
        return hr;

    // make sure we have created the site table which tracks the amount of memory
    // allocated by each site.
    if ((hr = CreateSiteTable()) != S_OK)
        return hr;

    if ((hr = GetCacheUrlFromDirPath(pwzDirPath, pwzName, &pszCacheUrl)) != S_OK)
    {
        return hr;
    }

    // dwOldSize is the size of the document we will be overwriting by saving
    // this document.
    DWORD dwOldDiskUsage = 0;
    DWORD dwDiskUsage = RealDiskUsage(dwSize + (fAddLeadUnicodeChar ? sizeof(WCHAR) : 0));
    
    if ((hr = EnforceStorageLimits(pwzDirPath, pszCacheUrl, dwDiskUsage, &dwOldDiskUsage, TRUE)) != S_OK)
    {
        delete [] pszCacheUrl;
        return hr;
    }

    Assert(pszCacheUrl != NULL);

    TCHAR achFileName[MAX_PATH];

    // Convert the string that we send in to a url name    
    if (!CreateUrlCacheEntry(pszCacheUrl,
                            0,
                            TEXT("xml"),
                            achFileName,
                            0))
    {
        dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    hFile = CreateFile(
            achFileName,
            GENERIC_WRITE,
            0,  // no sharing.
            NULL,
            TRUNCATE_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
            
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    DWORD dwBytesWritten;
    dwBytesWritten = 0;

    // Need to add lead character to indicate a Unicode file.
    if ( fAddLeadUnicodeChar )
    {
        if ( !WriteFile(hFile, (LPVOID) &wchLEADUNICODEFILE, sizeof(WCHAR), &dwBytesWritten, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CloseHandle(hFile);
            goto cleanup;
        } 
    }
    
    if (!WriteFile(hFile, pData, dwSize, &dwBytesWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CloseHandle(hFile);
        goto cleanup;
    }

    // We must close the handle before commiting the cache entry. 
    // If we don't some of the file system api's fail on Win95 and
    // consequently the CommitUrlCacheEntry fails as well. 
    CloseHandle(hFile);     

    if (!CommitUrlCacheEntry(pszCacheUrl,
                             achFileName,
                             ftExpire,
                             ftZero,
                             NORMAL_CACHE_ENTRY,
                             NULL,
                             0,
                             NULL,
                             0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = S_OK;
    }

cleanup:
    // EnforceStorageLimits assumes this store will succeed and updates the size usage
    // Since we didn't we should undo that now.
    if (hr != S_OK)
    {
        // In this case we have to get the site string and undo the changes
        // we made earlier in EnforceStorageLimits.
        LPTSTR pszSite;
        DWORD cchSite;
        if (GetSiteFromCacheUrl(pszCacheUrl, &pszSite, &cchSite) == S_OK)
        {
            pszSite[cchSite] = 0;
            ModifySitesSpaceUsage(pszSite, (int)dwOldDiskUsage - dwDiskUsage);
        }
    }

    delete [] pszCacheUrl;

    return hr ;
}




HRESULT CPersistUserData::GetCacheUrlFromDirPath(LPCOLESTR pwzDirPath, LPCOLESTR pwzFileName, LPTSTR * ppszCacheUrl)
{
    if (pwzDirPath == NULL)
    {
        return E_POINTER;
    }

    if (pwzFileName == NULL)
        pwzFileName = TEXT("_default");
    
    LPCTSTR pszCacheUrlPrefix;
    DWORD cchCacheUrlPrefix ; 

    // IMPORTANT: Do not free the memory returned by GetCacheUrlPrefix.
    if (!GetCacheUrlPrefix(&pszCacheUrlPrefix, &cchCacheUrlPrefix))
    {
        Assert(FALSE);
        return E_FAIL;
    }


    LPTSTR pszUrl;

    HRESULT hr = S_OK;


    // The length of the string remaining to be processed.
    DWORD cch = lstrlen(pwzDirPath);
    // If the path includes the trailing / ignore it for now, we will add it back when composing the URL.
    if (cch > 0 && (pwzDirPath[cch - 1] == chSLASH || pwzDirPath[cch - 1] == chBACKSLASH))
        cch-- ; 

    DWORD cchFileName = lstrlen(pwzFileName);

       
    // The fake URL name we produce is of the form
    // For https://www.microsoft.com/foobar  and document name 'default'
    // userdata:sanjays@https@www.microsoft.com/foobar/default
    
    // First figure out the constituent parts. 
    LPCOLESTR pszScan;

    PARSEDURL pu;
    pu.cbSize = sizeof(pu);
    
    hr = ParseURL(pwzDirPath, &pu);
    
    if (hr == S_OK)
    {
        pszScan = pu.pszSuffix;
        cch -= (DWORD)(pszScan - pwzDirPath);    // we processed the scheme: part of the string.
    }
    else
        return hr;

    // Now skip over any / or \'s till we get to the begining of the host name.
    while (*pszScan == chSLASH || *pszScan == chBACKSLASH)
    {
        *pszScan++;
        cch--;
    }
    
    // This implies the directory path passed in was bogus

    if (*pszScan == 0)
        return E_INVALIDARG;

    DWORD numChars = cchCacheUrlPrefix; // For "userdata:sanjays@" NULL terminator will be used for the ':'
    numChars += pu.cchProtocol + 1 /* for scheme followed by @ */ ;
    numChars += cch + 1;            /* for hostname and path followed by / */
    numChars += cchFileName + 1;  /* filename and the  NULL terminator */ ;
    
                       
    LPTSTR pszCacheUrl = new TCHAR[numChars];

    if (pszCacheUrl == NULL)
        return E_OUTOFMEMORY;
    else
        *ppszCacheUrl = pszCacheUrl;          


    memcpy(pszCacheUrl, pszCacheUrlPrefix, sizeof(TCHAR) * cchCacheUrlPrefix);
    pszCacheUrl += cchCacheUrlPrefix;
    memcpy(pszCacheUrl, pu.pszProtocol, sizeof(TCHAR) * pu.cchProtocol);
    pszCacheUrl += pu.cchProtocol;
    *pszCacheUrl++ = chAT; 
    memcpy(pszCacheUrl, pszScan, sizeof(TCHAR) * cch);
    pszCacheUrl += cch;
    *pszCacheUrl++ = chSLASH;
    memcpy(pszCacheUrl, pwzFileName, sizeof(TCHAR) * (cchFileName + 1));

    return S_OK;
}


// Returns a string of the form userdata:username@. This string is used as a prefix
// on all userdata cache items stored on behalf of this user.
// The caller should not free the memory returned here. 
// If no user name is found ( could happen on Win9x system with no logon it uses the 
// string "anyuser" for the username. 

BOOL CPersistUserData::GetCacheUrlPrefix(LPCTSTR * ppszCacheUrlPrefix, DWORD *pcchCacheUrlPrefix)
{
    BOOL bRet;

    EnterCriticalSection(&s_csCacheUrlPrefix);

    if (s_bCheckedUserName)
    {
        bRet = s_bCacheUrlPrefixRet;
    }            
    else
    {
        TCHAR rgchUserName[MAX_PATH];
        DWORD cchUserNameLen = ARRAY_SIZE(rgchUserName);

        if (!::GetUserName(rgchUserName, &cchUserNameLen))
        {
            DWORD dwError = GetLastError();
            Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
            // Just user the string anyuser
            cchUserNameLen = lstrlen(rgchAnyUser);
            memcpy(rgchUserName, rgchAnyUser, (cchUserNameLen + 1) * sizeof(TCHAR));
            bRet = TRUE;
        }
        else
        {
            bRet = TRUE;
            cchUserNameLen--;  // Includes the count for null termination
        }
            
        // If we succeed we should calculate the cache url prefix as well.
        // Create a string of the form userdata:username@ 

        if (bRet)
        {
            LPTSTR psz = s_rgchCacheUrlPrefix;
            memcpy(psz, s_rgchUserData, sizeof(TCHAR) * (ARRAY_SIZE(s_rgchUserData) - 1));
            psz += (ARRAY_SIZE(s_rgchUserData) - 1);
            *psz++ = chCOLON;
            memcpy(psz, rgchUserName, sizeof(TCHAR) * cchUserNameLen);
            psz += cchUserNameLen;
            *psz++ = chAT;
            *psz = 0;
            s_cchCacheUrlPrefix = (DWORD) (psz - s_rgchCacheUrlPrefix);
        }

    }

    s_bCheckedUserName = TRUE;
    s_bCacheUrlPrefixRet = bRet;
    if (bRet)
    {
        *ppszCacheUrlPrefix = s_rgchCacheUrlPrefix;
        *pcchCacheUrlPrefix = s_cchCacheUrlPrefix;
    }


    LeaveCriticalSection(&s_csCacheUrlPrefix);

    return bRet;
}

// This is an ANSI function in an otherwise unicode world. 
// This is because Unicode versions of the cache folder functions used here 
// are not supported and return ERROR_NOT_IMPLEMENTED

HRESULT CPersistUserData::EnsureCacheContainer()
{                                            
    CHAR achUserData[] = "UserData";
    HRESULT hr = S_OK;
    DWORD dwError = NOERROR;
    CHAR rgchPath[MAX_PATH]; 
    LPCSTR pszDirPath = NULL;
    LPCSTR pszRelPath = NULL;
    BYTE buffer[sizeof(INTERNET_CACHE_CONFIG_INFOA) + sizeof(INTERNET_CACHE_CONFIG_PATH_ENTRYA)];
    INTERNET_CACHE_CONFIG_INFOA *pCacheConfigInfo = (INTERNET_CACHE_CONFIG_INFOA *)buffer;
    DWORD dwBufSize = sizeof(buffer);

    EnterCriticalSection(&s_csCacheContainer);

    if (s_bCheckedCacheContainer)
    {   
        hr = s_hrCacheContainer;
        goto cleanup;

    }
                
    // If SHGetFolderPathA is available and works, try to get the "Application
    // Data" folder.
    if (SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, rgchPath))
    {
       // We will create the cache container under the appdata folder.
       pszDirPath = rgchPath;
       pszRelPath = rgchRelAppData;
    }
    else if (GetUrlCacheConfigInfoA(pCacheConfigInfo, &dwBufSize, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        // In this case we will create the cache container in the same directory
        // as cookies.
        pszDirPath = pCacheConfigInfo->CachePaths[0].CachePath;
        pszRelPath = rgchRelCookies;
    }
    else
    {
        Assert(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        Assert(pCacheConfigInfo->dwNumCachePaths == 1);     

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;                     
    }

    // Compose the path for the directory. Combine the dirpath and relative path
    // to get the location of the userdata folder.
    if (PathCombineA(rgchPath, pszDirPath, pszRelPath) == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // Now try to create the cache entry. 
    if (!CreateUrlCacheContainerA(
                achUserData,
                achUserData,
                rgchPath,
                1000,
                0, 
                (INTERNET_CACHE_CONTAINER_NODESKTOPINIT 
                ),
                NULL,
                NULL)
        )
    {
        // If this was because the cache already existed we are okay. 
        dwError = GetLastError();
        
        if (dwError != ERROR_ALREADY_EXISTS)
            hr = HRESULT_FROM_WIN32(dwError);
    }           

    // Figure out the cluster size information for the disk that the cache container
    // will live on.
    // The directory name lives in rgchPath, we will clobber it to create a string
    // which just has the device part.
    if (rgchPath[0] != chSLASH && rgchPath[0] != chBACKSLASH)
    {
        // Dir path is of the from c:\..... We just need the c:\ part.
        rgchPath[3] = 0;
    }
    else
    {
         // Dir path is of the form \\foo\bar\.... 
        // In this case we pass the name passed to GetDiskSpace is the whole string
        DWORD dwLen = lstrlenA(rgchPath);
        if (dwLen + 1 < ARRAY_SIZE(rgchPath))
        {
            rgchPath[dwLen] = schDIR_SEPERATOR;
            rgchPath[dwLen + 1] = '\0';
        }
    }

    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    DWORD dwClusterSize;
    if (GetDiskFreeSpaceA(rgchPath, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
    {
        s_dwClusterSizeMinusOne = dwSectorsPerCluster * dwBytesPerSector - 1;
        s_dwClusterSizeMask     = ~s_dwClusterSizeMinusOne;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

cleanup:

    s_bCheckedCacheContainer = TRUE;
    s_hrCacheContainer = hr;

    LeaveCriticalSection(&s_csCacheContainer);
    return hr;
}                        

// Adds iSizeDelta to the amount of space taken by this site. 
// Creates a new entry if non-exists to date. 

HRESULT CPersistUserData::ModifySitesSpaceUsage(LPCTSTR pszKey, int iSizeDelta)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&s_csSiteTable);

    Assert(s_pSiteTable);

    if (s_pSiteTable != NULL)
    {
        DWORD dwSpace;

        if (!s_pSiteTable->Lookup(pszKey, dwSpace))
            dwSpace = 0;

        if (iSizeDelta < 0 && (-iSizeDelta  > (int)dwSpace))
        {
            // Our quota is going to be set to a number less than zero.
            // Assert but recover by setting space usage to zero.
            Assert(FALSE);
            dwSpace = 0;                   
        }
        else
             dwSpace += iSizeDelta;


        hr = s_pSiteTable->SetAt(pszKey, dwSpace);
    }
    else
        hr = E_FAIL;
                  
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}

// Helper function to get the site string given a cache URL name. 
//  arguments
//      pszCacheUrl [in] - Cache Url for which we want the site URL.
//      *ppszBegPos [out[ - will contain the pointer where the site begins.
//      *pcch = number of characters in the site name. 
// Returns
//          S_OK if entry is for current user, the two out arguments are valid in this case.
//          S_FALSE if entry is for a different user.
//          E_* on failure

HRESULT CPersistUserData::GetSiteFromCacheUrl(LPCTSTR pszCacheUrl, LPTSTR * ppszBegPos, DWORD *pcch)
{
    LPCTSTR pszCacheUrlPrefix;
    DWORD cchCacheUrlPrefix ; 

    if (pszCacheUrl == NULL)
        return E_INVALIDARG;    

    // IMPORTANT: Do not free the memory returned by GetCacheUrlPrefix.
    if (!GetCacheUrlPrefix(&pszCacheUrlPrefix, &cchCacheUrlPrefix))
    {
        Assert(FALSE);
        return E_FAIL;
    }
    
    if (StrCmpNI(pszCacheUrl, pszCacheUrlPrefix, cchCacheUrlPrefix) == 0)
    {
        LPCTSTR psz = pszCacheUrl + cchCacheUrlPrefix;

        // At this point psz points to the begining of the protocol. 
        // Everything from this point to the first / or \ is what we use
        // to track the site name.

        LPCTSTR pszEnd = psz;
        while (*pszEnd != 0 && *pszEnd != chSLASH && *pszEnd != chBACKSLASH)
            pszEnd++;

        Assert(*pszEnd != 0);
        if (*pszEnd == 0)
            return E_INVALIDARG;
        
        *ppszBegPos = (LPTSTR)psz;
        *pcch = (DWORD)(pszEnd - psz);
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

        
        
// Create the Site Table and populate it.
#define CACHE_ENTRY_BUFFER_SIZE (sizeof(INTERNET_CACHE_ENTRY_INFO) \
                                 + MAX_PATH * sizeof(TCHAR)\
                                 + INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))

HRESULT CPersistUserData::CreateSiteTable( )
{           
    HRESULT hr = S_OK;

    // First grab the critical section so no else tries to do this at
    // the same time.
    EnterCriticalSection(&s_csSiteTable);

    if (s_pSiteTable == NULL)
    {
        s_pSiteTable = new CSiteTable();
        if (s_pSiteTable == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }


        // Now iterate over the cache container and populate the entries
        // in the table.
        BYTE buffer[CACHE_ENTRY_BUFFER_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO lpICEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
        DWORD dwBufSize = CACHE_ENTRY_BUFFER_SIZE;

        lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

        HANDLE hEnum = FindFirstUrlCacheEntry(
                           TEXT("userdata:"),
                           lpICEI,
                           &dwBufSize
                           );

        if (hEnum == NULL)
        {
            DWORD dwError = GetLastError();
            // If this assert fires the
            // assumption that our buffer size is 
            // big enough is getting violated. 
            // Either up the limit or change to use
            // a dynamic allocation where we retry the
            // call
            Assert(dwError != ERROR_INSUFFICIENT_BUFFER);

            // If we can't get an enumerator because the container is empty we are 
            // fine.
            if (dwError == ERROR_NO_MORE_ITEMS)
                hr = S_OK;
            else
                hr = HRESULT_FROM_WIN32(dwError);
            goto cleanup;
        }

        // make sure the entry has not expired.
        FILETIME ftZero = {0};
        FILETIME currTime;
        GetSystemTimeAsFileTime(&currTime);

        do 
        {
            // The URL name we created is of the form.
            // userdata:username@http:www.microsoft.com/foobar/default

            if (lpICEI->lpszSourceUrlName != NULL)
            {
                DWORD cchSite; 
                LPTSTR pszSite;

                if ((CompareFileTime(&ftZero, &(lpICEI->ExpireTime)) != 0) && // ExpireTime is not zero
                    (CompareFileTime(&currTime, &(lpICEI->ExpireTime))  > 0)  //currentTime is beyond expires time.
                   ) 
                {
                    // TODO : Is it okay to delete the cache entry while we are still enumerating it.
                    DeleteUrlCacheEntry(lpICEI->lpszSourceUrlName);
                }
                else
                {
                    hr = GetSiteFromCacheUrl(lpICEI->lpszSourceUrlName, &pszSite, &cchSite);
                    if (hr == S_FALSE)
                    {
                        // This implies that the document does not belong to this user.
                        // Continue on to the next entry.
                        hr = S_OK;
                        continue;
                    }
                    else if (FAILED(hr))
                    {
                        break;
                    }
                                

                    // If we reach here the document belongs to this user. 

                    // Null terminate the site string. We are not interested
                    // in the parts beyond the site name for tracking memory
                    // usage
                    pszSite[cchSite] = 0;

                    // We don't support userdata files beyond 4GB
                    Assert(lpICEI->dwSizeHigh == 0);

                    hr = ModifySitesSpaceUsage(pszSite, RealDiskUsage(lpICEI->dwSizeLow));

                    // Only reasonable way in which this function could fail is if it out of memory.
                    // In that case we will just return failure from the API.
                    if (hr != S_OK)
                        break;
                }
            }            
            // Previous call might have modified these values.
            // Re-init to the actual sizes of the buffers.
            dwBufSize = CACHE_ENTRY_BUFFER_SIZE;
            lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

        } while (FindNextUrlCacheEntry(hEnum, lpICEI, &dwBufSize));

        FindCloseUrlCache(hEnum);
    }

cleanup:
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}


HRESULT CPersistUserData::DeleteSiteTable()
{
    HRESULT hr = S_OK;

    // Destroy the site table object. It should clean up all the allocated memory.
    EnterCriticalSection(&s_csSiteTable);
    delete s_pSiteTable;
    s_pSiteTable = NULL;
    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}


// This function enforces the storage limit for a given site.
// Arguments :
//      pwzDirPath - URL of the HTML document storing the data.
//      pszCacheUrl - corresponding cache URL of the document. 
//      dwDiskUsage - disk space used by the userdata file to be stored.
//      *pdwOldDiskUsage - disk usage of the document being overwritten if the save is done.
//      bModify - if this flag is TRUE, the function will change the size usage
//          of this site to reflect the saving of this document. 

HRESULT CPersistUserData::EnforceStorageLimits(
    LPCOLESTR /* pwzDirPath */, 
    LPCTSTR pszCacheUrl, 
    DWORD dwDiskUsage,
    DWORD* pdwOldDiskUsage,
    BOOL bModify
    )
{
    HRESULT hr = S_OK;

    LPTSTR pszBegSite;
    DWORD cchSite;
    LPTSTR pszSite;
    DWORD dwDomainLimit;
    DWORD dwDocLimit;
    DWORD dwZone = URLZONE_INVALID;

    dwZone = GetZone();
    Assert(ARRAY_SIZE(s_rgdwDomainLimit) == ARRAY_SIZE(s_rgdwDocLimit));

    if (dwZone < ARRAY_SIZE(s_rgdwDomainLimit))
    {
        dwDomainLimit = s_rgdwDomainLimit[dwZone];
        dwDocLimit = s_rgdwDocLimit[dwZone];
    }
    else
    {
        dwDomainLimit = s_dwUnkZoneDomainLimit;
        dwDocLimit = s_dwUnkZoneDocLimit;
    }

    if (dwDiskUsage > (dwDocLimit * 1024))
        return HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);

    

    // First get the site string we will use as a key to save this sites space usage.
    hr = GetSiteFromCacheUrl(pszCacheUrl, &pszBegSite, &cchSite);

    if (hr == S_OK)     
    {
        // Copy the string into our own buffer and         
        pszSite = (LPTSTR) _alloca((cchSite + 1) * sizeof(TCHAR));
       
        memcpy(pszSite, pszBegSite, cchSite * sizeof(TCHAR));
        pszSite[cchSite] = 0;
    }                              
    else if (hr == S_FALSE)
    {
        // This implies that we are being asked to check the storage limit for a user
        // who is not the current user. We don't support this currently.
        hr = E_INVALIDARG;
    }

    if (hr != S_OK)
        return hr;

    // Now figure ouf the size of the document in the cache.
    BYTE buffer[CACHE_ENTRY_BUFFER_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO lpICEI = (LPINTERNET_CACHE_ENTRY_INFO) buffer;
    DWORD dwBufSize = CACHE_ENTRY_BUFFER_SIZE;

    lpICEI->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

    DWORD dwOldDiskUsage = 0;

    if (GetUrlCacheEntryInfo(pszCacheUrl, lpICEI, &dwBufSize))
    {
        // Found an old entry. get the size of the document. 
        Assert(lpICEI->dwSizeHigh == 0);

        dwOldDiskUsage = RealDiskUsage(lpICEI->dwSizeLow);
    }
    else
    {
        DWORD dwError = GetLastError();

        // We have allocated a big enough buffer. The call 
        // should not return not enough memory
        Assert(dwError != ERROR_INSUFFICIENT_BUFFER);
        if (dwError == ERROR_FILE_NOT_FOUND)
            dwOldDiskUsage = 0;
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
            return hr;
        }
    }

    int iSizeDelta = (int)(dwDiskUsage - dwOldDiskUsage);

    EnterCriticalSection(&s_csSiteTable);
    if (iSizeDelta > 0)
    {
        DWORD dwCurrentSize;

        // We are increasng the size allocation. Check if we have enough space.
        if (!s_pSiteTable->Lookup(pszSite, dwCurrentSize))
            dwCurrentSize = 0;

        dwCurrentSize += iSizeDelta;
        if (dwCurrentSize > (dwDomainLimit * 1024) )
        {
            // We might want to define a new error such as E_QUOTAEXCEEDED here.
            hr = HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);
        }
    }

    if (pdwOldDiskUsage)
        *pdwOldDiskUsage = dwOldDiskUsage;

    if (hr == S_OK && bModify && iSizeDelta != 0)
    {
        hr = ModifySitesSpaceUsage(pszSite, iSizeDelta);
    }

    LeaveCriticalSection(&s_csSiteTable);

    return hr;
}

           

    
// CSiteTable is a helper class we use to keep track of the amount of allocations per-site. 
// This is used to decide if the site is exceeding it's quota when a new document is being 
// saved.
// It seems like a much simpler approach would be to enumerate the entries in the container
// when the site is trying to write a new document. However the cache enumeration API's don't allow
// for filtering based on sitename. Since we are forced to enumerate all the documents
// we remember the current amount of memory allocated by each site.
CSiteTable::CSiteTable(int nTableSize)
{
    m_pHashTable = NULL;
    m_nHashTableSize = nTableSize;
    m_nCount = 0;
}

CSiteTable::~CSiteTable()
{
    RemoveAll();
}

inline UINT CSiteTable::HashKey(LPCTSTR key) const
{
    UINT nHash = 0;            

    while (*key)
        nHash = (nHash<<5) + nHash + *key++;

    return nHash;
}


HRESULT CSiteTable::InitHashTable()
{
    Assert(m_nCount == 0);
    Assert(m_nHashTableSize > 0);
    
    m_pHashTable = new CAssoc*[m_nHashTableSize];
    if (m_pHashTable == NULL)
        return E_OUTOFMEMORY;

    memset(m_pHashTable, 0, sizeof(CAssoc*) * m_nHashTableSize);
    
    return S_OK;
}

// Change the hash table to the new size, This is an expensive
// operation but is done infrequently. 

HRESULT CSiteTable::ChangeHashTableSize(int nHashSize)
{
    Assert(nHashSize != 0);

    if (m_pHashTable == NULL)
    {
        // Easy we are done
        m_nHashTableSize = nHashSize;
        return S_OK;
    }

    // Allocate an alternate hash table.
    CAssoc **pNewHashTable = new CAssoc*[nHashSize];
    if (pNewHashTable == NULL)
        return E_OUTOFMEMORY;

    memset(pNewHashTable, 0, sizeof(CAssoc *) * nHashSize);

    // Loop over the entries in the current hash table and 
    // add them to the new hash table.
    for (UINT nHash = 0 ; nHash < m_nHashTableSize ; nHash++)
    {
        CAssoc *pAssoc = m_pHashTable[nHash];
        while (pAssoc != NULL)
        {
            UINT nNewHash = HashKey(pAssoc->pStr) % nHashSize;
            CAssoc * pAssocCurrent = pAssoc; 
            pAssoc = pAssoc->pNext;

            pAssocCurrent->pNext = pNewHashTable[nNewHash];
            pNewHashTable[nNewHash] = pAssocCurrent;
        }
    }

    delete [] m_pHashTable;
    m_pHashTable = pNewHashTable;
    return S_OK;
}

void CSiteTable::RemoveAll()
{
    if (m_pHashTable != NULL)
    {
        for (UINT nHash = 0 ; nHash < m_nHashTableSize; nHash++)
        { 
           CAssoc *pAssoc = m_pHashTable[nHash];
           while (pAssoc != NULL)
           {
                LocalFree(pAssoc->pStr);
                CAssoc * pAssocDel = pAssoc;
                pAssoc = pAssoc->pNext;
                delete pAssocDel;
           }
        }
        delete [] m_pHashTable;
        m_pHashTable = NULL;
    }
    m_nCount = 0;
}

CSiteTable::CAssoc *
CSiteTable::GetAssocAt(LPCTSTR key, UINT &nHash) const
{
    nHash = HashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    CAssoc *pAssoc;
    for (pAssoc = m_pHashTable[nHash] ;
         pAssoc != NULL;
         pAssoc = pAssoc->pNext
        )
    {
        if (StrCmpI(key, pAssoc->pStr) == 0)
            return pAssoc;
    
    }
    
    return NULL;
}

BOOL CSiteTable::Lookup(LPCTSTR key, DWORD &rdw) const
{
    UINT nHash;
    CAssoc *pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;   // not in table.
    rdw = pAssoc->dwValue;
    return TRUE;

}

HRESULT CSiteTable::SetAt(LPCTSTR key, DWORD dwValue)
{
    UINT nHash;

    CAssoc *pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        HRESULT hr = S_OK;
        if (m_pHashTable == NULL)
        {
            hr = InitHashTable();
        }
        else if (m_nHashTableSize * 2 <= m_nCount)
        { 
            // If we have twice as many sites as entries in 
            // the hash table we will grow the size

            // If this doesn't suceed we still have a 
            // hash table of the previous size. 
            // We will attempt to use that.
            if (ChangeHashTableSize(m_nHashTableSize * 2) == S_OK)
                nHash = HashKey(key) % m_nHashTableSize;   //recalculate the hash value. 
        }
        
        if (hr != S_OK)
            return hr;

        pAssoc = new CAssoc();
        if (pAssoc == NULL)
            return E_OUTOFMEMORY;

        pAssoc->pStr = StrDup(key);
        if (pAssoc->pStr == NULL)
        {
            delete pAssoc;
            return E_OUTOFMEMORY;
        }

        //. Put into the hash table.
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
        m_nCount++;
    }
    pAssoc->dwValue = dwValue;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\atlcom.h ===
// This is a part of the ActiveX Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// ActiveX Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// ActiveX Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

#define MWNO_DEF_IN_TEMPLATES

#ifdef _DEBUG
#define RELEASE_AND_DESTROY() ULONG l = InternalRelease();if (l == 0) delete this; return l
#else
#define RELEASE_AND_DESTROY() if (InternalRelease() == 0) delete this; return 0
#endif

#define offsetofclass(base, derived) ((DWORD)(DWORD_PTR)((base*)((derived*)8))-8)

#ifndef _SYS_GUID_OPERATORS_
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#if defined(_MAC) || defined(BIG_ENDIAN)
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);
#ifndef OLE2ANSI
HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);
#endif
HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID,
	const IID& iid = GUID_NULL, HRESULT hRes = 0);


#ifndef _ATL_NO_OLEAUT
/////////////////////////////////////////////////////////////////////////////
// CComBSTR
class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	CComBSTR(int nSize, LPCOLESTR sz = NULL)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	CComBSTR& operator=(const CComBSTR& src);
	CComBSTR& operator=(LPCOLESTR pSrc);
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc);
	CComBSTR& operator=(LPCSTR pSrc);
	CComBSTR(int nSize, LPCSTR sz = NULL);
#endif
	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	void Attach(BSTR src)
	{
		if (m_str != src)
		{
			::SysFreeString(m_str);
			m_str = src;
		}
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	BOOL operator!()
	{
		return (m_str == NULL) ? TRUE : FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
public:
	CComVariant() {VariantInit(this);}
	~CComVariant() {VariantClear(this);}
	CComVariant(VARIANT& var)
	{
		VariantInit(this);
		VariantCopy(this, &var);
	}
	CComVariant(LPCOLESTR lpsz)
	{
		VariantInit(this);
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpsz);
	}
#ifndef OLE2ANSI
	CComVariant(LPCSTR lpsz);
#endif
	CComVariant(const CComVariant& var)
	{
		VariantInit(this);
		VariantCopy(this, (VARIANT*)&var);
	}
	CComVariant& operator=(const CComVariant& var)
	{
		VariantCopy(this, (VARIANT*)&var);
		return *this;
	}
	CComVariant& operator=(VARIANT& var)
	{
		VariantCopy(this, &var);
		return *this;
	}
	CComVariant& operator=(LPCOLESTR lpsz)
	{
		VariantClear(this);
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpsz);
		return *this;
	}
#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpsz);
#endif
};
#endif  // !_ATL_NO_OLEAUT

#ifndef _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor

class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

#endif // _ATL_NO_SECURITY

/////////////////////////////////////////////////////////////////////////////
// Connection point helpers
//

HRESULT AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IRegister
//

EXTERN_C const IID IID_IRegister;
EXTERN_C const CLSID CLSID_Register;

interface IRegister : public IDispatch
{
	public:
	virtual HRESULT STDMETHODCALLTYPE AddReplacement(
		/* [in] */ BSTR key,
		/* [in] */ BSTR item) = 0;

	virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;

	virtual HRESULT STDMETHODCALLTYPE ResourceRegister(
		/* [in] */ BSTR fileName,
		/* [in] */ VARIANT ID,
		/* [in] */ VARIANT type) = 0;

	virtual HRESULT STDMETHODCALLTYPE ResourceUnregister(
		/* [in] */ BSTR fileName,
		/* [in] */ VARIANT ID,
		/* [in] */ VARIANT type) = 0;

	virtual HRESULT STDMETHODCALLTYPE FileRegister(
		/* [in] */ BSTR fileName) = 0;

	virtual HRESULT STDMETHODCALLTYPE FileUnregister(
		/* [in] */ BSTR fileName) = 0;

	virtual HRESULT STDMETHODCALLTYPE StringRegister(
		/* [in] */ BSTR data) = 0;

	virtual HRESULT STDMETHODCALLTYPE StringUnregister(
		/* [in] */ BSTR data) = 0;

	virtual HRESULT STDMETHODCALLTYPE AddKey(
		/* [in] */ BSTR keyName) = 0;

	virtual HRESULT STDMETHODCALLTYPE DeleteKey(
		/* [in] */ BSTR keyName) = 0;

	virtual HRESULT STDMETHODCALLTYPE AddKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [in] */ VARIANT value) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [retval][out] */ VARIANT __RPC_FAR *value) = 0;

	virtual HRESULT STDMETHODCALLTYPE SetKeyValue(
		/* [in] */ BSTR keyName,
		/* [in] */ BSTR valueName,
		/* [in] */ VARIANT value) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Smart OLE pointers provide automatic AddRef/Release
// CComPtr<IFoo> p;

IUnknown* WINAPI _AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
IUnknown* WINAPI _AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr() {p=NULL;}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr() {if (p) p->Release();}
	void Release() {if (p) p->Release(); p=NULL;}
	operator T*() {return (T*)p;}
	T& operator*() {_ASSERTE(p!=NULL); return *p; }
	T** operator&() { _ASSERTE(p==NULL); return &p; }
	T* operator->() { _ASSERTE(p!=NULL); return p; }
	T* operator=(T* lp){return (T*)_AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)_AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	T* p;
};

//Note: CComQIPtr<IUnknown, &IID_IUnknown> is not meaningful
//      Use CComPtr<IUnknown>
template <class T, const IID* piid>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr() {p=NULL;}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	// If you get an error that this member is already defined, you are probably
	// using a CComQIPtr<IUnknown, &IID_IUnknown>.  This is not necessary.
	// Use CComPtr<IUnknown>
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr() {if (p) p->Release();}
	void Release() {if (p) p->Release(); p=NULL;}
	operator T*() {return p;}
	T& operator*() {_ASSERTE(p!=NULL); return *p; }
	T** operator&() {_ASSERTE(p==NULL); return &p; }
	T* operator->() {_ASSERTE(p!=NULL); return p; }
	T* operator=(T* lp){return (T*)_AtlComPtrAssign((IUnknown**)&p, lp);}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)_AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)_AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}
	T* p;
};

void WINAPI AtlFreeMarshalStream(IStream* pStream);
HRESULT WINAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
HRESULT WINAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID*)
	{
		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		if (pv == NULL)
			hRes = T1::CreateInstance(NULL, riid, ppv);
		else
			hRes = T2::CreateInstance(pv, riid, ppv);
		return hRes;
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject<x> >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject<x> >, CComCreator< CComAggObject<x> > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject<x> > > _CreatorClass;

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	DWORD dwOffsetCS;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar, DWORD dwCS>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar, DWORD dwCS>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar, dwCS>::data = {dwVar, dwCS, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		_ASSERTE(*ppv == NULL);
		_ASSERTE(pv != NULL);
		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
	}
};

template <class T>
class CComCachedTearOffCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		_ASSERTE(pv != NULL);
		T::_OwnerClass* pOwner = (T::_OwnerClass*)pv;
		_ASSERTE(*ppv == NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		CComCachedTearOffObject<T>* p = NULL;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		ATLTRY(p = new CComCachedTearOffObject<T>(pOwner->GetControllingUnknown(), pOwner))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

#ifdef _ATL_DEBUG_QI
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG_QI

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public:\
	typedef x _ComMapClass;\
	IUnknown* GetUnknown() { _ASSERTE(_GetEntries()->pFunc == (_ATL_CREATORARGFUNC*)1); \
			return (IUnknown*)((INT_PTR)this+_GetEntries()->dw); } \
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject)\
	{return InternalQueryInterface(this, _GetEntries(), iid, ppvObject);}\
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() {\
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#define COM_INTERFACE_ENTRY(x)\
	{&IID_##x, \
	offsetofclass(x, _ComMapClass), \
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&IID_##x,\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(DWORD)((x*)(x2*)((_ComMapClass*)8))-8,\
	(_ATL_CREATORARGFUNC*)1},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD)&_CComCreatorData<\
		CComCreator<CComTearOffObject<x, _ComMapClass> >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk, cs)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComCachedTearOffCreator< x >,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	(DWORD)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid, cs)\
	{&iid,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid, cs)\
	{NULL,\
	(DWORD)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD)offsetof(_ComMapClass, punk),\
		(DWORD)offsetof(_ComMapClass, cs)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#ifdef _ATL_DEBUG_QI
#define END_COM_MAP()   {NULL, 0, 0}};\
	return &_entries[1];}
#else
#define END_COM_MAP()   {NULL, 0, 0}};\
	return _entries;}
#endif // _ATL_DEBUG_QI

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		CComPtr<IUnknown> p;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		return hRes;
	}
	IUnknown* pCF;
	DWORD dwRegister;
};


#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, &class::UpdateRegistry, &class::_ClassFactoryCreatorClass::CreateInstance, &class::_CreatorClass::CreateInstance, NULL, 0},

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRoot
{
public:
	typedef CComObjectThreadModel _ThreadModel;
	CComObjectRoot()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}

	ULONG InternalAddRef()
	{
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}
	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* entries, REFIID iid, void** ppvObject);
//Outer funcs
	ULONG OuterAddRef() {return m_pOuterUnknown->AddRef();}
	ULONG OuterRelease() {return m_pOuterUnknown->Release();}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{return m_pOuterUnknown->QueryInterface(iid, ppvObject);}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease() {_ASSERTE(m_dwRef == 0);}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()

#ifdef _ATL_DEBUG_QI
	static HRESULT DumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG_QI

	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD dw);
	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD dw);

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

#if defined(_WINDLL) | defined(_USRDLL) | defined(_ATL_DLL_SERVER)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)


#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

// Statically linking to Registry Ponent
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Must have included atl\ponent\register\static\statreg.cpp and statreg.h
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResourceS(_T(#x), bRegister);\
	}

#define DECLARE_STATIC_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResourceS(x, bRegister);\
	}
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner>
class CComTearOffObjectBase : public CComObjectRoot
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject(){m_dwRef = 1L; FinalRelease(); _Module.Unlock();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
	_ASSERTE(pp != NULL);
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached(){m_dwRef = 1L; FinalRelease();}
	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock() {m_dwRef = 1L; FinalRelease();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack() {FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {_ASSERTE(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){_ASSERTE(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{_ASSERTE(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

//Base is the user's class that derives from CComTearOffObjectBase and whatever
//interfaces the user wants to support on the object
//Owner is the class of object that Base is a tear-off for
template <class Base, class Owner>
class CComTearOffObject : public Base
{
public:
	typedef Base _BaseClass;
	CComTearOffObject(void* p)
	{
		m_pOwner = reinterpret_cast<CComObject<Owner>*>(p);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject(){m_dwRef = 1L; FinalRelease(); m_pOwner->Release();}

	//If InternalAddRef or InteralRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		if (InlineIsEqualUnknown(iid) ||
			FAILED(_InternalQueryInterface(iid, ppvObject)))
		{
			return m_pOwner->QueryInterface(iid, ppvObject);
		}
		return S_OK;
	}
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return OuterQueryInterface(iid, ppvObject);}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown() {return m_pOuterUnknown;}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject : public IUnknown, public CComObjectRoot
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{_Module.Lock();}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct() {CComObjectRoot::FinalConstruct(); return m_contained.FinalConstruct();}
	void FinalRelease() {CComObjectRoot::FinalRelease(); m_contained.FinalRelease();}
	// Set refcount to 1 to protect destruction
	~CComAggObject(){m_dwRef = 1L; FinalRelease(); _Module.Unlock();}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

template <class contained>
class CComCachedTearOffObject : public IUnknown, public CComObjectRoot
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv, contained::_OwnerClass* pOwner) : m_contained(pv)
	{
		_ASSERTE(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pOwner);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct() {CComObjectRoot::FinalConstruct(); return m_contained.FinalConstruct();}
	void FinalRelease() {CComObjectRoot::FinalRelease(); m_contained.FinalRelease();}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject(){m_dwRef = 1L; FinalRelease();}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		RELEASE_AND_DESTROY();
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory : public IClassFactory, public CComObjectRoot
{
public:
	// This typedef is because class factories are globally held
	typedef CComGlobalsThreadModel _ThreadModel;
BEGIN_COM_MAP(CComClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj);
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

class CComClassFactory2Base : public IClassFactory2, public CComObjectRoot
{
public:
	// This typedef is because class factories are globally held
	typedef CComGlobalsThreadModel _ThreadModel;
BEGIN_COM_MAP(CComClassFactory2Base)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock);
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : public CComClassFactory2Base, license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		_ASSERTE(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
};

template <class T, const CLSID* pclsid>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), nID, iid, hRes);}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);}
#endif
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

#ifndef MWNO_DEF_IN_TEMPLATES
template <class T, const IID* piid, const GUID* plibid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <class T, const IID* piid, const GUID* plibid, WORD wMajor,
WORD wMinor, class tihclass>
#endif
class CComDualImpl : public T
{
public:
	typedef tihclass _tihclass;
	CComDualImpl() {_tih.AddRef();}
	~CComDualImpl() {_tih.Release();}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{*pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};
#ifndef MWNO_DEF_IN_TEMPLATES
template <class T, const IID* piid, const GUID* plibid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <class T, const IID* piid, const GUID* plibid, WORD wMajor,
WORD wMinor, class tihclass>
#endif
CComDualImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
CComDualImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0};

#ifndef MWNO_DEF_IN_TEMPLATES
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor, WORD wMinor, class tihclass >
#endif
class CComProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;
	CComProvideClassInfo2Impl() {_tih.AddRef();}
	~CComProvideClassInfo2Impl() {_tih.Release();}

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};

#ifndef MWNO_DEF_IN_TEMPLATES
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
#else
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid,
WORD wMajor , WORD wMinor , class tihclass >
#endif
CComProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
CComProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// CISupportErrorInfo

template <const IID* piid>
class CComISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)\
	{return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static void copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T));}
	static void init(T*) {}
	static void destroy(T*) {}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<VARIANT>
{
public:
	static void copy(VARIANT* p1, VARIANT* p2) {VariantCopy(p1, p2);}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<LPOLESTR>
{
public:
	static void copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		ocscpy(*p1,*p2);
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<OLEVERB>
{
public:
	static void copy(OLEVERB* p1, OLEVERB* p2)
	{
		*p1 = *p2;
		if (p1->lpszVerbName == NULL)
			return;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		ocscpy(p1->lpszVerbName,p2->lpszVerbName);
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class _Copy<CONNECTDATA>
{
public:
	static void copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static void copy(T** p1, T** p2)
	{*p1 = *p2;if (*p1) (*p1)->AddRef();}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0; m_pUnk = NULL;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	IUnknown* m_pUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
	if (m_pUnk)
		m_pUnk->Release();
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	while(nMin--)
		Copy::copy(rgelt++, m_iter++);
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(ULONG celt)
{
	m_iter += celt;
	if (m_iter < m_end)
		return S_OK;
	m_iter = m_end;
	return S_FALSE;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		_class* p = NULL;
		ATLTRY(p = new _class)
		if (p == NULL)
		{
			*ppEnum = NULL;
			hRes = E_OUTOFMEMORY;
		}
		else
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_pUnk);
			if (FAILED(hRes))
				delete p;
			else
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
				if (FAILED(hRes))
					delete p;
			}
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		_ASSERTE(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[end-begin])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			Copy::copy(m_iter++, i);
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_pUnk = pUnk;
	if (m_pUnk)
		m_pUnk->AddRef();
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy>
class CComEnum : public CComEnumImpl<Base, piid, T, Copy>, public CComObjectRoot
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	virtual const _ATL_CONNMAP_ENTRY* GetConnMap()\
		{ return _StaticGetConnMap(); }\
	static const _ATL_CONNMAP_ENTRY* _StaticGetConnMap() {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(member){offsetof(_atl_conn_classtype, member)-\
	offsetofclass(IConnectionPointContainer, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD)-1} }; return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComStaticArrayCONNECTDATA
{
public:
	CComStaticArrayCONNECTDATA()
	{
		memset(m_arr, 0, sizeof(CONNECTDATA)*nMaxSize);
		m_pCurr = &m_arr[0];
	}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin() {return &m_arr[0];}
	CONNECTDATA* end() {return &m_arr[nMaxSize];}
protected:
	CONNECTDATA m_arr[nMaxSize];
	CONNECTDATA* m_pCurr;
};

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Add(IUnknown* pUnk)
{
	for (CONNECTDATA* p = begin();p<end();p++)
	{
		if (p->pUnk == NULL)
		{
			p->pUnk = pUnk;
			p->dwCookie = (DWORD)pUnk;
			return TRUE;
		}
	}
	return FALSE;
}

template <unsigned int nMaxSize>
inline BOOL CComStaticArrayCONNECTDATA<nMaxSize>::Remove(DWORD dwCookie)
{
	CONNECTDATA* p;
	for (p=begin();p<end();p++)
	{
		if (p->dwCookie == dwCookie)
		{
			p->pUnk = NULL;
			p->dwCookie = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

#if _MSC_VER >= 1100 && defined(__BOOL_DEFINED)
template <>
#endif
class CComStaticArrayCONNECTDATA<1>
{
public:
	CComStaticArrayCONNECTDATA() {m_cd.pUnk = NULL; m_cd.dwCookie = 0;}
	BOOL Add(IUnknown* pUnk)
	{
		if (m_cd.pUnk != NULL)
			return FALSE;
		m_cd.pUnk = pUnk;
		m_cd.dwCookie = (DWORD)pUnk;
		return TRUE;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != m_cd.dwCookie)
			return FALSE;
		m_cd.pUnk = NULL;
		m_cd.dwCookie = 0;
		return TRUE;
	}
	CONNECTDATA* begin() {return &m_cd;}
	CONNECTDATA* end() {return (&m_cd)+1;}
protected:
	CONNECTDATA m_cd;
};

class CComDynamicArrayCONNECTDATA
{
public:
	CComDynamicArrayCONNECTDATA()
	{
		m_nSize = 0;
		m_pCD = NULL;
	}

	~CComDynamicArrayCONNECTDATA() {free(m_pCD);}
	BOOL Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	CONNECTDATA* begin() {return (m_nSize < 2) ? &m_cd : m_pCD;}
	CONNECTDATA* end() {return (m_nSize < 2) ? (&m_cd)+m_nSize : &m_pCD[m_nSize];}
protected:
	CONNECTDATA* m_pCD;
	CONNECTDATA m_cd;
	int m_nSize;
};

class CComConnectionPointBase : public IConnectionPoint, public CComObjectRoot
{
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPointBase(IConnectionPointContainer* pCont, const IID* piid)
	{
		m_pContainer = pCont;
		m_piid = piid;
	}

	BEGIN_COM_MAP(CComConnectionPointBase)
		COM_INTERFACE_ENTRY(IConnectionPoint)
	END_COM_MAP()

	//Connection point lifetimes are determined by the container
	STDMETHOD_(ULONG, AddRef)() {_ASSERTE(m_pContainer != NULL); return m_pContainer->AddRef();}
	STDMETHOD_(ULONG, Release)(){_ASSERTE(m_pContainer != NULL); return m_pContainer->Release();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}

	STDMETHOD(GetConnectionInterface)(IID* piid);
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC);

	const IID* GetIID() {return m_piid;}
	void Lock() {m_sec.Lock();}
	void Unlock() {m_sec.Unlock();}
protected:
	const IID* m_piid;
	_ThreadModel::AutoCriticalSection m_sec;
	IConnectionPointContainer* m_pContainer;
	friend class CComConnectionPointContainerImpl;
};

class CComConnectionPointContainerImpl; // fwd decl

template <class CDV = CComDynamicArrayCONNECTDATA>
class CComConnectionPoint : public CComConnectionPointBase
{
	typedef CDV _CDV;
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
public:
	CComConnectionPoint(IConnectionPointContainer* pCont, const IID* piid) :
		CComConnectionPointBase(pCont, piid) {}

	// interface methods
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);

	_CDV m_vec;
	friend class CComConnectionPointContainerImpl;
};

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
	m_sec.Lock();
	if (SUCCEEDED(pUnkSink->QueryInterface(*m_piid, (void**)&p)))
	{
		*pdwCookie = (DWORD)p;
		hRes = m_vec.Add(p) ? S_OK : CONNECT_E_ADVISELIMIT;
		if (hRes != S_OK)
		{
			*pdwCookie = 0;
			p->Release();
		}
	}
	else
		hRes = CONNECT_E_CANNOTCONNECT;
	m_sec.Unlock();
	return hRes;
}

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::Unadvise(DWORD dwCookie)
{
	m_sec.Lock();
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	IUnknown* p = (IUnknown*) dwCookie;
	m_sec.Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class CDV = CComDynamicArrayCONNECTDATA>
STDMETHODIMP CComConnectionPoint<CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	m_sec.Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()])
	if (pcd == NULL)
	{
		delete pEnum;
		m_sec.Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (CONNECTDATA* p = m_vec.begin();p<m_vec.end();p++)
	{
		if (p->pUnk != NULL)
		{
			p->pUnk->AddRef();
			*pend++ = *p;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	m_sec.Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}


class CComConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:

	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum);
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP);

protected:
	virtual const _ATL_CONNMAP_ENTRY* GetConnMap() = 0;
	CComConnectionPointBase* FindConnPoint(REFIID riid);
	void InitCloneVector(CComConnectionPointBase** ppCP);
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComModule

//Although these functions are big, they are only used once in a module
//so we should make them inline.

inline void CComModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	m_pObjMap = p;
	m_hInst = h;
	m_nLockCnt=0L;
	m_hHeap = NULL;
	m_csTypeInfoHolder.Init();
	m_csObjMap.Init();
}

inline HRESULT CComModule::RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry++;
	}
	return hRes;
}

inline HRESULT CComModule::RevokeClassObjects()
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry++;
	}
	return hRes;
}

inline HRESULT CComModule::GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	while (pEntry->pclsid != NULL)
	{
		if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				m_csObjMap.Lock();
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				m_csObjMap.Unlock();
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry++;
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

inline void CComModule::Term()
{
	_ASSERTE(m_hInst != NULL);
	if (m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry++;
		}
	}
	m_csTypeInfoHolder.Term();
	m_csObjMap.Term();
	if (m_hHeap != NULL)
		HeapDestroy(m_hHeap);
}

inline HRESULT CComModule::RegisterServer(BOOL bRegTypeLib)
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL)
	{
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
		pEntry++;
	}
// KENSY: Remove dependency on OLEAUT
#if 0
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = RegisterTypeLib();
#else
        if (bRegTypeLib)
            return E_FAIL;
#endif	
	return hRes;
}

inline HRESULT CComModule::UnregisterServer()
{
	_ASSERTE(m_hInst != NULL);
	_ASSERTE(m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	while (pEntry->pclsid != NULL)
	{
		pEntry->pfnUpdateRegistry(FALSE); //unregister
		pEntry++;
	}
	return S_OK;
}

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\apis.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cdithtbl.h"
#include "cddsurf.h"

// Get rid of "unused formal parameters warning"
#pragma warning(disable : 4100)

STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap, 
   IUnknown* pUnknownEventSink )
{
   USES_CONVERSION;
   HRESULT hResult;
   CComPtr< IStream > pSniffedStream;
   UINT nFormat;
   TCHAR szMIMEType[64];
   LPCOLESTR pszMIMETypeO;
   CComPtr< IMapMIMEToCLSID > pActualMap;
   CComPtr< IImageDecodeFilter > pFilter;
   CComPtr< IImageDecodeEventSink > pEventSink;
   CLSID clsid;
   int nChars;
    
   if( pStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pUnknownEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

    pUnknownEventSink->QueryInterface(IID_IImageDecodeEventSink,
        (void **)&pEventSink);

    if (pEventSink == NULL)
        return E_INVALIDARG;
        
   if( pMap == NULL )
   {
      hResult = CoCreateInstance( CLSID_CoMapMIMEToCLSID, NULL, 
         CLSCTX_INPROC_SERVER, IID_IMapMIMEToCLSID, (void**)&pActualMap );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }
   else
   {
      pActualMap = pMap;
   }

   hResult = SniffStream( pStream, &nFormat, &pSniffedStream );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   nChars = GetClipboardFormatName( nFormat, szMIMEType, 63 );
   if( nChars == 0 )
   {
      return( E_FAIL );
   }
   if( nChars > 60 )
   {
      return( E_FAIL );
   }

   pszMIMETypeO = T2COLE( szMIMEType );
   hResult = pActualMap->MapMIMEToCLSID( pszMIMETypeO, &clsid );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }
   if( hResult == S_FALSE )
   {
      return( E_FAIL );
   }

   hResult = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, 
      IID_IImageDecodeFilter, (void**)&pFilter );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   hResult = pFilter->Initialize( pEventSink );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   hResult = pFilter->Process( pSniffedStream );

   pFilter->Terminate( hResult );

   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap )
{
   if( ppMap == NULL )
   {
      return( E_POINTER );
   }

   return( CoCreateInstance( CLSID_CoMapMIMEToCLSID, NULL, 
      CLSCTX_INPROC_SERVER, IID_IMapMIMEToCLSID, (void**)ppMap ) );
}

STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable, ULONG cbTable)
{
#ifndef MINSUPPORT
    CDitherTable *pDitherTable;
    HRESULT hr;
    
    if (pRGBColors == NULL)
        return E_POINTER;

    if (pInvTable == NULL)
        return E_POINTER;

    if (nColors > 256)
        return E_INVALIDARG;

    if (cbTable != 32768)
        return E_INVALIDARG;


    pDitherTable = new CDitherTable;
    if (pDitherTable == NULL)
        return E_OUTOFMEMORY;

    hr = pDitherTable->SetColors(nColors, pRGBColors);
    if (SUCCEEDED(hr))
        memcpy(pInvTable, pDitherTable->m_abInverseMap, 32768);

    delete pDitherTable;
    
    return hr;
#else
    return E_NOTIMPL;
#endif    
}

#ifdef MINSUPPORT

HRESULT DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
    return E_NOTIMPL;
}

#endif

STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface)
{
#ifndef MINSUPPORT
    if (hbmDib == NULL)
        return E_INVALIDARG;

    if (ppSurface == NULL)
        return E_POINTER;

    *ppSurface = (IDirectDrawSurface *)(new CDDrawWrapper(hbmDib));

    return *ppSurface ? S_OK : E_OUTOFMEMORY;
#else
    return E_NOTIMPL;
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\align.h ===
inline ULONG AlignLong( ULONG nSrc )
{
   return( (nSrc+3)&(~0x3) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cddsurf.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "ddraw.h"
#include "cddsurf.h"

// Get rid of "synonyms" warning
#pragma warning(disable : 4097)

// Get rid of "unused formal parameters warning"
#pragma warning(disable : 4100)

#undef  DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

DEFINE_GUID( IID_IDirectDrawPalette,		0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

const RGBQUAD     g_rgbBgColor = { 0xFF, 0xFF, 0xFF, 0 };
const RGBQUAD     g_rgbFgColor = { 0x00, 0x00, 0x00, 0 };

const PALETTEENTRY g_peVga[16] =
{
    { 0x00, 0x00, 0x00, 0x00 }, // Black
    { 0x80, 0x00, 0x00, 0x00 }, // Dark red
    { 0x00, 0x80, 0x00, 0x00 }, // Dark green
    { 0x80, 0x80, 0x00, 0x00 }, // Dark yellow
    { 0x00, 0x00, 0x80, 0x00 }, // Dark blue
    { 0x80, 0x00, 0x80, 0x00 }, // Dark purple
    { 0x00, 0x80, 0x80, 0x00 }, // Dark aqua
    { 0xC0, 0xC0, 0xC0, 0x00 }, // Light grey
    { 0x80, 0x80, 0x80, 0x00 }, // Dark grey
    { 0xFF, 0x00, 0x00, 0x00 }, // Light red
    { 0x00, 0xFF, 0x00, 0x00 }, // Light green
    { 0xFF, 0xFF, 0x00, 0x00 }, // Light yellow
    { 0x00, 0x00, 0xFF, 0x00 }, // Light blue
    { 0xFF, 0x00, 0xFF, 0x00 }, // Light purple
    { 0x00, 0xFF, 0xFF, 0x00 }, // Light aqua
    { 0xFF, 0xFF, 0xFF, 0x00 }  // White
};

#define Verify(x) (x)

LONG g_lSecondaryObjCount = 0;

#define DecrementSecondaryObjectCount( idCaller ) DecrementSecondaryObjectCount_Actual()

inline void
DecrementSecondaryObjectCount_Actual()
{
    InterlockedDecrement(&g_lSecondaryObjCount);
}

#define IncrementSecondaryObjectCount( idCaller ) IncrementSecondaryObjectCount_Actual()

inline void
IncrementSecondaryObjectCount_Actual()
{
    Verify(InterlockedIncrement(&g_lSecondaryObjCount) > 0);
}

CBaseFT::CBaseFT(CRITICAL_SECTION * pcs)
{
    _ulRefs     = 1;
    _ulAllRefs  = 1;
    _pcs        = pcs;
    IncrementSecondaryObjectCount(10);
}

CBaseFT::~CBaseFT()
{
    DecrementSecondaryObjectCount(10);
}

void CBaseFT::Passivate()
{
}

ULONG CBaseFT::Release()
{
    ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulRefs);

    if (ulRefs == 0)
    {
        Passivate();
        SubRelease();
    }

    return(ulRefs);
}

ULONG CBaseFT::SubRelease()
{
    ULONG ulRefs = (ULONG)InterlockedDecrement((LONG *)&_ulAllRefs);

    if (ulRefs == 0)
    {
        delete this;
    }

    return(ulRefs);
}

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe,
    UINT uCount)
{
    while (uCount--)
    {
        prgb->rgbRed   = ppe->peRed;
        prgb->rgbGreen = ppe->peGreen;
        prgb->rgbBlue  = ppe->peBlue;
        prgb->rgbReserved = 0;

        prgb++;
        ppe++;
    }
}


void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

#define MASK565_0   0x0000F800
#define MASK565_1   0x000007E0
#define MASK565_2   0x0000001F

HBITMAP ImgCreateDib(LONG xWid, LONG yHei, BOOL fPal, int cBitsPerPix,
    int cEnt, PALETTEENTRY * ppe, BYTE ** ppbBits, int * pcbRow)
{
    struct {
        BITMAPINFOHEADER bmih;
        union {
            RGBQUAD argb[256];
            WORD aw[256];
            DWORD adw[3];
        } u;
    } bmi;
    int i;

    if (cBitsPerPix != 8)
        fPal = FALSE;

    bmi.bmih.biSize          = sizeof(BITMAPINFOHEADER);
    bmi.bmih.biWidth         = xWid;
    bmi.bmih.biHeight        = yHei;
    bmi.bmih.biPlanes        = 1;
    bmi.bmih.biBitCount      = (WORD)((cBitsPerPix == 15) ? 16 : cBitsPerPix);
    bmi.bmih.biCompression   = (cBitsPerPix == 16) ? BI_BITFIELDS : BI_RGB;
    bmi.bmih.biSizeImage     = 0;
    bmi.bmih.biXPelsPerMeter = 0;
    bmi.bmih.biYPelsPerMeter = 0;
    bmi.bmih.biClrUsed       = 0;
    bmi.bmih.biClrImportant  = 0;

    if (cBitsPerPix == 1)
    {
        bmi.bmih.biClrUsed = 2;

        if (cEnt > 2)
            cEnt = 2;

        if (cEnt > 0)
        {
            bmi.bmih.biClrImportant = cEnt;
            CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
        }
        else
        {
            bmi.u.argb[0] = g_rgbBgColor;
            bmi.u.argb[1] = g_rgbFgColor;
        }
    }
    else if (cBitsPerPix == 4)
    {
        bmi.bmih.biClrUsed = 16;

        if (cEnt > 16)
            cEnt = 16;

        if (cEnt > 0)
        {
            bmi.bmih.biClrImportant = cEnt;
            CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
        }
        else
        {
            bmi.bmih.biClrImportant = 16;
            CopyColorsFromPaletteEntries(bmi.u.argb, g_peVga, 16);
        }
    }
    else if (cBitsPerPix == 8)
    {
        if (fPal)
        {
            bmi.bmih.biClrUsed = 256;

            for (i = 0; i < 256; ++i)
                bmi.u.aw[i] = (WORD)i;
        }
        else
        {
            if (cEnt > 0 && cEnt < 256)
            {
                bmi.bmih.biClrUsed = cEnt;
                bmi.bmih.biClrImportant = cEnt;
            }
            else
                bmi.bmih.biClrUsed = 256;

            if (cEnt && ppe)
            {
                CopyColorsFromPaletteEntries(bmi.u.argb, ppe, cEnt);
            }
        }
    }
    else if (cBitsPerPix == 16)
    {
        bmi.u.adw[0] = MASK565_0;
        bmi.u.adw[1] = MASK565_1;
        bmi.u.adw[2] = MASK565_2;
    }

    return ImgCreateDibFromInfo((BITMAPINFO *)&bmi, fPal ? DIB_PAL_COLORS : DIB_RGB_COLORS, ppbBits, pcbRow);
}


HBITMAP ImgCreateDibFromInfo(BITMAPINFO * pbmi, UINT wUsage, BYTE ** ppbBits, int * pcbRow)
{
    HDC 	hdcMem = NULL;
    HBITMAP	hbm = NULL;
    BYTE * 	pbBits;
    int 	cbRow;
    LONG    xWid, yHei;
    int 	cBitsPerPix;

    xWid = pbmi->bmiHeader.biWidth;
    yHei = pbmi->bmiHeader.biHeight;
    cBitsPerPix = pbmi->bmiHeader.biBitCount;
    
	cbRow = ((xWid * cBitsPerPix + 31) & ~31) / 8;

    if (pcbRow)
    {
        *pcbRow = cbRow;
    }

    hdcMem = CreateCompatibleDC(NULL);

    if (hdcMem == NULL)
        goto Cleanup;

    hbm = CreateDIBSection(hdcMem, pbmi, wUsage, (void **)&pbBits, NULL, 0);

    if (hbm && ppbBits)
    {
        *ppbBits = pbBits;
    }

Cleanup:
    if (hdcMem)
        DeleteDC(hdcMem);

    return(hbm);
}

CDDrawWrapper::CDDrawWrapper(HBITMAP hbmDib)
{
    m_hbmDib = hbmDib;
    GetObject(hbmDib, sizeof(DIBSECTION), &m_dsSurface);
    m_lPitch = ((m_dsSurface.dsBmih.biWidth * m_dsSurface.dsBmih.biBitCount + 31) & ~31) / 8;
    if (m_dsSurface.dsBmih.biHeight > 0)
    {
        m_pbBits = (BYTE *)m_dsSurface.dsBm.bmBits + (m_dsSurface.dsBm.bmHeight - 1) * m_lPitch;
        m_lPitch = -m_lPitch;
    }
    else
    {
        m_pbBits = (BYTE *)m_dsSurface.dsBm.bmBits;
    }

    // left, top already 0
    m_rcSurface.right = m_dsSurface.dsBm.bmWidth;
    m_rcSurface.bottom = m_dsSurface.dsBm.bmHeight;

    // initialize transparent index to -1
    m_ddColorKey.dwColorSpaceLowValue = m_ddColorKey.dwColorSpaceHighValue = (DWORD)-1;
}

CDDrawWrapper::~CDDrawWrapper()
{
}

STDMETHODIMP
CDDrawWrapper::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IDirectDrawSurface)
        *ppv = (IUnknown *)(IDirectDrawSurface *)this;
    else if (riid == IID_IDirectDrawPalette)
        *ppv = (IUnknown *)(IDirectDrawPalette *)this;
    else if (riid == IID_IUnknown)
        *ppv = (IUnknown *)(IDirectDrawSurface *)this;
    else    
        *ppv = NULL;

    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return(S_OK);
    }
    else
    {
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG)
CDDrawWrapper::AddRef()
{
    return(super::AddRef());
}

STDMETHODIMP_(ULONG)
CDDrawWrapper::Release()
{
    return(super::Release());
}

STDMETHODIMP CDDrawWrapper::GetColorKey(DWORD dw, LPDDCOLORKEY lpKey)
{
    if (dw != DDCKEY_SRCBLT)
        return E_INVALIDARG;

    if (lpKey == NULL)
        return E_POINTER;

    memcpy(lpKey, &m_ddColorKey, sizeof(DDCOLORKEY));

    return S_OK;
}

STDMETHODIMP CDDrawWrapper::GetPalette(LPDIRECTDRAWPALETTE FAR* ppPal)
{
    if (ppPal == NULL)
        return E_POINTER;
        
    // Return interface to set color table if DIB section has one
    
    if (m_dsSurface.dsBmih.biBitCount <= 8)
    {
        *ppPal = (LPDIRECTDRAWPALETTE)this;
        ((LPUNKNOWN)*ppPal)->AddRef();
        return S_OK;
    }
    else
    {
        *ppPal = NULL;
        return E_NOINTERFACE;
    }
}


STDMETHODIMP CDDrawWrapper::SetColorKey(DWORD dwFlags, LPDDCOLORKEY pDDColorKey)
{
    if (dwFlags != DDCKEY_SRCBLT)
        return E_INVALIDARG;

    if (pDDColorKey == NULL)
        return E_POINTER;

    memcpy(&m_ddColorKey, pDDColorKey, sizeof(DDCOLORKEY));

    return S_OK;
}

STDMETHODIMP CDDrawWrapper::SetEntries(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    RGBQUAD argb[256];
    DWORD nColors = (DWORD)(1 << m_dsSurface.dsBmih.biBitCount);
    UINT nColorsSet;
    HDC hdc;
    HBITMAP hbm;
    
    if (dwFlags)
        return E_INVALIDARG;

    if (dwStart >= nColors || dwStart + dwCount > nColors)
        return E_INVALIDARG;

    if (pEntries == NULL)
        return E_POINTER;

    CopyColorsFromPaletteEntries(argb, pEntries, dwCount);
    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbm = (HBITMAP)SelectObject(hdc, m_hbmDib);
        nColorsSet = SetDIBColorTable(hdc, (UINT)dwStart, (UINT)dwCount, argb);
        SelectObject(hdc, hbm);
        DeleteDC(hdc);
    }
    else
        nColorsSet = 0;
    
    return nColorsSet ? S_OK : E_FAIL;
}

STDMETHODIMP CDDrawWrapper::GetEntries(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    RGBQUAD argb[256];
    DWORD nColors = (DWORD)(1 << m_dsSurface.dsBmih.biBitCount);
    UINT nColorsGet;
    HDC hdc;
    HBITMAP hbm;
    
    if (dwFlags)
        return E_INVALIDARG;

    if (dwStart >= nColors || dwStart + dwCount > nColors)
        return E_INVALIDARG;

    if (pEntries == NULL)
        return E_POINTER;

    hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        hbm = (HBITMAP)SelectObject(hdc, m_hbmDib);
        nColorsGet = GetDIBColorTable(hdc, (UINT)dwStart, (UINT)dwCount, argb);
        SelectObject(hdc, hbm);
        DeleteDC(hdc);
    }
    else
        return E_FAIL;

    if (nColorsGet)
        CopyPaletteEntriesFromColors(pEntries, argb, dwCount);

    return nColorsGet ? S_OK : E_FAIL;
}


STDMETHODIMP CDDrawWrapper::Lock(LPRECT pRect, LPDDSURFACEDESC pSurfaceDesc, DWORD dwFlags, HANDLE hEvent)
{
    RECT    rcClip;
    
    if (pRect == NULL || pSurfaceDesc == NULL)
        return E_POINTER;

    if (pSurfaceDesc->dwSize != sizeof(DDSURFACEDESC))
        return E_INVALIDARG;

    if (hEvent)
        return E_INVALIDARG;

    IntersectRect(&rcClip, pRect, &m_rcSurface);
    if (!EqualRect(&rcClip, pRect))
        return E_INVALIDARG;
        
    pSurfaceDesc->dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH;
    pSurfaceDesc->dwWidth = m_dsSurface.dsBm.bmWidth;
    pSurfaceDesc->dwHeight = m_dsSurface.dsBm.bmHeight;
    pSurfaceDesc->lPitch = m_lPitch;

    pSurfaceDesc->lpSurface = (LPVOID)(m_pbBits 
                                + pRect->top * m_lPitch 
                                + ((pRect->left * m_dsSurface.dsBmih.biBitCount) / 8));
     
    return S_OK;
}


STDMETHODIMP CDDrawWrapper::Unlock(LPVOID pBits)
{
    return S_OK;
}

// The remainder of these methods are not needed by the plugin filters

STDMETHODIMP CDDrawWrapper::AddAttachedSurface(LPDIRECTDRAWSURFACE lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::AddOverlayDirtyRect(LPRECT lprc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Blt(LPRECT lprcDest, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dw, LPDDBLTFX lpfx)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::BltBatch(LPDDBLTBATCH lpBlt, DWORD dwCount, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::BltFast(DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dwTrans)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::DeleteAttachedSurface(DWORD dwFlags, LPDIRECTDRAWSURFACE lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::EnumAttachedSurfaces(LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::EnumOverlayZOrders(DWORD dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Flip(LPDIRECTDRAWSURFACE lpdds, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetAttachedSurface(LPDDSCAPS lpCaps, LPDIRECTDRAWSURFACE FAR * lpdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetBltStatus(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetCaps(LPDDSCAPS lpCaps)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetClipper(LPDIRECTDRAWCLIPPER FAR* lpClipper)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetDC(HDC FAR * lphdc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetFlipStatus(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetOverlayPosition(LPLONG lpl1, LPLONG lpl2)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetPixelFormat(LPDDPIXELFORMAT pPixelFormat)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetSurfaceDesc(LPDDSURFACEDESC pSurfaceDesc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Initialize(LPDIRECTDRAW pDD, LPDDSURFACEDESC pSurfaceDesc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::IsLost()
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::ReleaseDC(HDC hdc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Restore()
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetClipper(LPDIRECTDRAWCLIPPER pClipper)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetOverlayPosition(LONG x, LONG y)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::SetPalette(LPDIRECTDRAWPALETTE pDDPal)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlay(LPRECT prc, LPDIRECTDRAWSURFACE pdds, LPRECT prc2, DWORD dw, LPDDOVERLAYFX pfx)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlayDisplay(DWORD dw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::UpdateOverlayZOrder(DWORD dw, LPDIRECTDRAWSURFACE pdds)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::GetCaps(LPDWORD lpdw)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDDrawWrapper::Initialize(LPDIRECTDRAW lpdd, DWORD dwCount, LPPALETTEENTRY pEntries)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cdith8.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "imgutil.h"
#include "cdithtbl.h"
#include "dithers.h"
#include "cdith8.h"
#include "align.h"
#include "cddsurf.h"
//#include <icapexp.h>

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe, UINT uCount);

CDitherTable* CDitherToRGB8::s_apTableCache[MAX_DITHERTABLE_CACHE_SIZE];
ULONG CDitherToRGB8::s_nCacheSize;
CRITICAL_SECTION CDitherToRGB8::s_csCache;

void CDitherToRGB8::InitTableCache()
{
   ULONG iTable;

   InitializeCriticalSection( &s_csCache );

   s_nCacheSize = 0;
   for( iTable = 0; iTable < MAX_DITHERTABLE_CACHE_SIZE; iTable++ )
   {
      s_apTableCache[iTable] = NULL;
   }
}

void CDitherToRGB8::CleanupTableCache()
{
   ULONG iTable;

   EnterCriticalSection( &s_csCache );
   for( iTable = 0; iTable < s_nCacheSize; iTable++ )
   {
      _ASSERTE( s_apTableCache[iTable]->m_nRefCount == 0 );
      delete s_apTableCache[iTable];
      s_apTableCache[iTable] = NULL;
   }
   s_nCacheSize = 0;
   LeaveCriticalSection( &s_csCache );

   DeleteCriticalSection( &s_csCache );
}

CDitherToRGB8::CDitherToRGB8() :
   m_dwEvents( 0 ),
   m_iScanLine( 0 ),
   m_bProgressiveDither( FALSE ),
   m_pErrBuf( NULL ),
   m_pErrBuf1( NULL ),
   m_pErrBuf2( NULL ),
   m_pTable( NULL ),
   m_pbBits( NULL ),
   m_hbmDestDib( NULL )
{
}

CDitherToRGB8::~CDitherToRGB8()
{
    if (m_pTable)
        m_pTable->m_nRefCount--;

    if (m_hbmDestDib)
        DeleteObject(m_hbmDestDib);   
}

STDMETHODIMP CDitherToRGB8::GetSurface( LONG nWidth, LONG nHeight, 
   REFGUID bfid, ULONG nPasses, DWORD dwHints, IUnknown** ppSurface )
{
    HRESULT hResult;
    CComPtr< IUnknown > pDestSurface;

    if (ppSurface != NULL)
        *ppSurface = NULL;
      
    if ((nWidth <= 0) || (nHeight <= 0))
        return E_INVALIDARG;
        
    if (ppSurface == NULL)
        return E_POINTER;

    if (IsEqualGUID(bfid, BFID_RGB_24))
    {
        m_eSrcFormat = RGB24;
        m_nBitsPerPixel = 24;
    }
    else if (IsEqualGUID(bfid, BFID_INDEXED_RGB_8))
    {
        m_eSrcFormat = RGB8;
        m_nBitsPerPixel = 8;
    }
    else
        return E_NOINTERFACE;

    m_nWidth = nWidth;
    m_nHeight = nHeight;

    if ((dwHints & IMGDECODE_HINT_TOPDOWN) && 
        (dwHints & IMGDECODE_HINT_FULLWIDTH) &&
        (m_dwEvents & IMGDECODE_EVENT_PROGRESS))
        m_bProgressiveDither = TRUE;
    else
        m_bProgressiveDither = FALSE;

    m_pErrBuf = new ERRBUF[(m_nWidth+2)*2];
    if (m_pErrBuf == NULL)
      return E_OUTOFMEMORY;

    m_pErrBuf1 = &m_pErrBuf[1];
    m_pErrBuf2 = &m_pErrBuf[m_nWidth+3];

    memset(m_pErrBuf, 0, sizeof( ERRBUF )*(m_nWidth+2)*2);

    hResult = m_pEventSink->GetSurface(m_nWidth, m_nHeight, BFID_INDEXED_RGB_8,
        nPasses, dwHints, &pDestSurface);
    if (FAILED(hResult))
        return( hResult );

    hResult = pDestSurface->QueryInterface(IID_IDirectDrawSurface, 
                                            (void **)&m_pDestSurface);
    if (FAILED(hResult))
        return hResult;
    
    m_hbmDestDib = ImgCreateDib(m_nWidth, -LONG(m_nHeight), FALSE, m_nBitsPerPixel, 0, NULL, 
                        &m_pbBits, (int *)&m_nPitch);
    if (m_hbmDestDib == NULL)
        return E_OUTOFMEMORY;

    hResult = CreateDDrawSurfaceOnDIB(m_hbmDestDib, &m_pSurface);
    if (FAILED(hResult))
        return hResult;
        
    *ppSurface = (IUnknown *)m_pSurface;
    (*ppSurface)->AddRef();

    return S_OK;
}

STDMETHODIMP CDitherToRGB8::OnBeginDecode( DWORD* pdwEvents, ULONG* pnFormats,
   GUID** ppFormats )
{
   HRESULT hResult;
   GUID* pFormats;
   ULONG nFormats;
   ULONG iFormat;
   BOOL bFound;

   if( pdwEvents != NULL )
   {
      *pdwEvents = 0;
   }
   if( pnFormats != NULL )
   {
      *pnFormats = 0;
   }
   if( ppFormats != NULL )
   {
      *pnFormats = NULL;
   }
   if( pdwEvents == NULL )
   {
      return( E_POINTER );
   }
   if( pnFormats == NULL )
   {
      return( E_POINTER );
   }
   if( ppFormats == NULL )
   {
      return( E_POINTER );
   }

   hResult = m_pEventSink->OnBeginDecode( &m_dwEvents, &nFormats, &pFormats );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   bFound = FALSE;
   for( iFormat = 0; (iFormat < nFormats) && !bFound; iFormat++ )
   {
      if( IsEqualGUID( pFormats[iFormat], BFID_INDEXED_RGB_8 ) )
      {
         bFound = TRUE;
      }
   }
   CoTaskMemFree( pFormats );
   if( !bFound )
   {
      return( E_FAIL );
   }

   *ppFormats = (GUID*)CoTaskMemAlloc( 3*sizeof( GUID ) );
   if( *ppFormats == NULL )
   {
      return( E_OUTOFMEMORY );
   }
   *pnFormats = 3;
   (*ppFormats)[0] = BFID_GRAY_8;
   (*ppFormats)[1] = BFID_RGB_24;
   (*ppFormats)[2] = BFID_INDEXED_RGB_8;

   *pdwEvents = m_dwEvents|IMGDECODE_EVENT_BITSCOMPLETE|
      IMGDECODE_EVENT_PALETTE;

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnBitsComplete()
{
   HRESULT hResult;

   hResult = DitherFull();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   if( m_dwEvents & IMGDECODE_EVENT_BITSCOMPLETE )
   {
      hResult = m_pEventSink->OnBitsComplete();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnDecodeComplete( HRESULT hrStatus )
{
   HRESULT hResult;

   delete m_pErrBuf;
   m_pErrBuf = NULL;
   m_pErrBuf1 = NULL;
   m_pErrBuf2 = NULL;

	// Propagate the transparency information if necessary
	
	if (m_pSurface && m_pDestSurface)
	{
	    DDCOLORKEY  ddKey;

	    if (SUCCEEDED(m_pSurface->GetColorKey(DDCKEY_SRCBLT, &ddKey)))
	        m_pDestSurface->SetColorKey(DDCKEY_SRCBLT, &ddKey);
	}
		
   if( m_pSurface != NULL )
   {
      m_pSurface.Release();
   }
   if( m_pDestSurface != NULL )
   {
      m_pDestSurface.Release();
   }

   hResult = m_pEventSink->OnDecodeComplete( hrStatus );
   m_pEventSink.Release();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::OnPalette()
{
    HRESULT hResult;
    CComPtr< IDirectDrawPalette > pPalette;
    PALETTEENTRY ape[256];

    if (m_eSrcFormat == RGB8)
    {
        hResult = m_pSurface->GetPalette(&pPalette);
        if (FAILED(hResult))
            return hResult;

        hResult = pPalette->GetEntries(0, 0, 256, ape);
        if (FAILED(hResult))
            return hResult;

        CopyColorsFromPaletteEntries(m_argbSrcColors, ape, 256);
    }

    if (m_dwEvents & IMGDECODE_EVENT_PALETTE)
    {
        hResult = m_pEventSink->OnPalette();
        if (FAILED(hResult))
        {
            return hResult;
        }
    }

    return S_OK;
}

STDMETHODIMP CDitherToRGB8::OnProgress( RECT* pBounds, BOOL bComplete )
{
   HRESULT hResult;

   if( pBounds == NULL )
   {
      return( E_INVALIDARG );
   }

   if( m_bProgressiveDither && bComplete )
   {
      hResult = DitherBand( pBounds );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }
   else
   {
      hResult = ConvertBlock( pBounds );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   if( m_dwEvents & IMGDECODE_EVENT_PROGRESS )
   {
      hResult = m_pEventSink->OnProgress( pBounds, bComplete );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::SetDestColorTable( ULONG nColors, 
   const RGBQUAD* prgbColors )
{
   ULONG iTable;
   HRESULT hResult;

   if( (nColors == 0) || (nColors > 256) )
   {
      return( E_INVALIDARG );
   }
   if( prgbColors == NULL )
   {
      return( E_INVALIDARG );
   }

   EnterCriticalSection( &s_csCache );

   if( m_pTable != NULL )
   {
      // Release whatever table we've got already
      m_pTable->m_nRefCount--;
      m_pTable = NULL;
   }

   // See if we can find the requested table in the cache
   for( iTable = 0; (iTable < s_nCacheSize) && (m_pTable == NULL); iTable++ )
   {
      if( s_apTableCache[iTable]->Match( nColors, prgbColors ) )
      {
         m_pTable = s_apTableCache[iTable];
         m_pTable->m_nRefCount++;
      }
   }

   if( m_pTable == NULL )
   {
      if( s_nCacheSize < MAX_DITHERTABLE_CACHE_SIZE )
      {
         m_pTable = new CDitherTable;
         if( m_pTable == NULL )
         {
            LeaveCriticalSection( &s_csCache );
            return( E_OUTOFMEMORY );
         }
         hResult = m_pTable->SetColors( nColors, prgbColors );
         if( FAILED( hResult ) )
         {
            LeaveCriticalSection( &s_csCache );
            m_pTable = NULL;
            return( hResult );
         }

         // Add a new cache entry
         m_pTable->m_nRefCount++;
         s_apTableCache[s_nCacheSize] = m_pTable;
         s_nCacheSize++;
      }
      else
      {
         // Find a cache entry to replace.
         for( iTable = 0; (iTable < s_nCacheSize) && (m_pTable == NULL); 
            iTable++ )
         {
            if( s_apTableCache[iTable]->m_nRefCount == 0 )
            {
               m_pTable = s_apTableCache[iTable];
               hResult = m_pTable->SetColors( nColors, prgbColors );
               if( FAILED( hResult ) )
               {
                  LeaveCriticalSection( &s_csCache );
                  m_pTable = NULL;
                  return( hResult );
               }
               m_pTable->m_nRefCount++;
            }
         }
      }
   }

   _ASSERTE( m_pTable != NULL );

   LeaveCriticalSection( &s_csCache );

   return( S_OK );
}

STDMETHODIMP CDitherToRGB8::SetEventSink( IImageDecodeEventSink* pEventSink )
{
   if( pEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pEventSink = pEventSink;

   return( S_OK );
}

HRESULT CDitherToRGB8::ConvertBlock( RECT* pBounds )
{
    HRESULT hResult;
    void* pSrcBits;
    void* pDestBits;
    LONG nSrcPitch;
    LONG nDestPitch;
    DDSURFACEDESC ddsd;

    _ASSERTE( pBounds->left == 0 );
    _ASSERTE( pBounds->right == LONG( m_nWidth ) );

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
        return hResult;

    pSrcBits = ddsd.lpSurface;
    nSrcPitch = ddsd.lPitch;

    hResult = m_pDestSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
    {
        m_pSurface->Unlock(pSrcBits);
        return hResult;
    }

    pDestBits = ddsd.lpSurface;
    nDestPitch = ddsd.lPitch;
    
    switch( m_eSrcFormat )
    {
        case RGB24:
            Convert24to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, 
                    nSrcPitch, m_pTable->m_abInverseMap, pBounds->left, 
                    pBounds->right-pBounds->left, pBounds->top, 
                    pBounds->bottom-pBounds->top );
            break;

        case RGB8:
            Convert8to8( LPBYTE( pDestBits ), LPBYTE( pSrcBits ), nDestPitch, 
                    nSrcPitch, m_argbSrcColors, m_pTable->m_abInverseMap, pBounds->left, 
                    pBounds->right-pBounds->left, pBounds->top, 
                    pBounds->bottom-pBounds->top );
            break;

        default:
            return E_FAIL;
            break;
    }

    m_pDestSurface->Unlock(pDestBits);
    m_pSurface->Unlock(pSrcBits);

    return S_OK;
}

HRESULT CDitherToRGB8::DitherBand( RECT* pBounds )
{
    HRESULT hResult;
    void* pSrcBits;
    void* pDestBits;
    LONG nSrcPitch;
    LONG nDestPitch;
    LONG lDestTrans = -1;
    LONG lSrcTrans = -1;
    DDSURFACEDESC ddsd;
    DDCOLORKEY ddColorKey;

    _ASSERTE( pBounds->left == 0 );
    _ASSERTE( pBounds->right == LONG( m_nWidth ) );

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
        return hResult;

    pSrcBits = ddsd.lpSurface;
    nSrcPitch = ddsd.lPitch;

    hResult = m_pDestSurface->Lock(pBounds, &ddsd, 0, 0);
    if (FAILED(hResult))
    {
        m_pSurface->Unlock(pSrcBits);
        return hResult;
    }

    pDestBits = ddsd.lpSurface;
    nDestPitch = ddsd.lPitch;

    switch (m_eSrcFormat)
    {    
        case RGB24:
            Dith24to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, 
                nSrcPitch, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                pBounds->top, pBounds->bottom-pBounds->top);
            break;

        case RGB8:
            if (SUCCEEDED(m_pSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)))
                lSrcTrans = ddColorKey.dwColorSpaceLowValue;

            if (SUCCEEDED(m_pDestSurface->GetColorKey(DDCKEY_SRCBLT, &ddColorKey)))
                lDestTrans = ddColorKey.dwColorSpaceLowValue;

            // preserve the transparent index if necessary
            if (lSrcTrans >= 0 && lDestTrans == -1)
            {
                lDestTrans = lSrcTrans;
            }

            if (lSrcTrans == -1 || lDestTrans == -1)
            {
                Dith8to8(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, nSrcPitch,
                    m_argbSrcColors, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                    m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                    pBounds->top, pBounds->bottom-pBounds->top);
            }
            else
            {
                Dith8to8t(LPBYTE(pDestBits), LPBYTE(pSrcBits), nDestPitch, nSrcPitch,
                    m_argbSrcColors, m_pTable->m_argbColors, m_pTable->m_abInverseMap, 
                    m_pErrBuf1, m_pErrBuf2, pBounds->left, pBounds->right-pBounds->left, 
                    pBounds->top, pBounds->bottom-pBounds->top, (BYTE)lDestTrans, (BYTE)lSrcTrans);
            }
            break;

        default:
            return E_FAIL;
    }

    m_pDestSurface->Unlock(pDestBits);
    m_pSurface->Unlock(pSrcBits);

    return S_OK;
}

HRESULT CDitherToRGB8::DitherFull()
{
    HRESULT hResult;
    RECT rect;

    rect.left = 0;
    rect.top = 0;
    rect.right = m_nWidth;
    rect.bottom = m_nHeight;

    hResult = DitherBand(&rect);
    if (FAILED(hResult))
        return hResult;

    return S_OK;
}

HRESULT DitherTo8( BYTE * pDestBits, LONG nDestPitch, 
                   BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                   RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                   BYTE * pbDestInvMap,
                   LONG x, LONG y, LONG cx, LONG cy,
                   LONG lDestTrans, LONG lSrcTrans)
{
   ERRBUF* m_pErrBuf;
   ERRBUF* m_pErrBuf1;
   ERRBUF* m_pErrBuf2;

//    StartCAPAll();
    
    HRESULT hr = S_OK;

    m_pErrBuf = new ERRBUF[(cx+2)*2];
    if (m_pErrBuf == NULL)
    {
        return( E_OUTOFMEMORY );
    }

    m_pErrBuf1 = &m_pErrBuf[1];
    m_pErrBuf2 = &m_pErrBuf[cx+3];

    memset(m_pErrBuf, 0, sizeof( ERRBUF )*(cx+2)*2);

    if (bfidSrc == BFID_RGB_24)
    {
        Dith24to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch, 
            prgbDestColors, pbDestInvMap, 
            m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
    }
    else if (bfidSrc == BFID_RGB_8)
    {
        if (lDestTrans == -1 || lSrcTrans == -1)
        {
            Dith8to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
        }
        else
        {
            Dith8to8t( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy, (BYTE)lDestTrans, (BYTE)lSrcTrans );
        }
    }
    else
    {
        hr = E_FAIL;
    }

   delete m_pErrBuf;

//    StopCAPAll();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cddsurf.h ===
#define DECLARE_MEMCLEAR_NEW_DELETE \
    void * __cdecl operator new(size_t cb) { void *pv = malloc(cb); if (pv) ZeroMemory(pv, cb); return pv; } \
    void __cdecl operator delete(void * pv) { free(pv); }

class CVoid
{
};

class CBaseFT : public CVoid
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE

    ULONG               AddRef()               { return((ULONG)InterlockedIncrement((LONG *)&_ulRefs)); }
    ULONG               Release();
    ULONG               SubAddRef()            { return((ULONG)InterlockedIncrement((LONG *)&_ulAllRefs)); }
    ULONG               SubRelease();
    CRITICAL_SECTION *  GetPcs() { return(_pcs); }
    void                SetPcs(CRITICAL_SECTION *pcs) { _pcs = pcs; }
    ULONG               GetRefs()              { return(_ulRefs); }
    ULONG               GetAllRefs()           { return(_ulAllRefs); }

    void                EnterCriticalSection() { if (_pcs) ::EnterCriticalSection(_pcs); }
    void                LeaveCriticalSection() { if (_pcs) ::LeaveCriticalSection(_pcs); }

protected:

                        CBaseFT(CRITICAL_SECTION * pcs = NULL);
    virtual            ~CBaseFT();
    virtual void        Passivate();
    ULONG               InterlockedRelease()   { return((ULONG)InterlockedDecrement((LONG *)&_ulRefs)); }

private:

    CRITICAL_SECTION *  _pcs;
    ULONG               _ulRefs;
    ULONG               _ulAllRefs;
};


class CDDrawWrapper : public CBaseFT, public IDirectDrawSurface, public IDirectDrawPalette
{
    typedef CBaseFT super;
    
public:
    CDDrawWrapper(HBITMAP hbmDib);
    ~CDDrawWrapper();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    // IDirectDrawSurface
    STDMETHOD(AddAttachedSurface)(LPDIRECTDRAWSURFACE lpdds);
    STDMETHOD(AddOverlayDirtyRect)(LPRECT lprc);
    STDMETHOD(Blt)(LPRECT lprcDest, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dw, LPDDBLTFX lpfx);
    STDMETHOD(BltBatch)(LPDDBLTBATCH lpBlt, DWORD dwCount, DWORD dwFlags);
    STDMETHOD(BltFast)(DWORD dwX, DWORD dwY, LPDIRECTDRAWSURFACE lpdds, LPRECT lprcSrc, DWORD dwTrans);
    STDMETHOD(DeleteAttachedSurface)(DWORD dwFlags, LPDIRECTDRAWSURFACE lpdds);
    STDMETHOD(EnumAttachedSurfaces)(LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn);
    STDMETHOD(EnumOverlayZOrders)(DWORD dwFlags, LPVOID lpContext, LPDDENUMSURFACESCALLBACK lpfn);
    STDMETHOD(Flip)(LPDIRECTDRAWSURFACE lpdds, DWORD dwFlags);
    STDMETHOD(GetAttachedSurface)(LPDDSCAPS lpCaps, LPDIRECTDRAWSURFACE FAR * lpdds);
    STDMETHOD(GetBltStatus)(DWORD dw);
    STDMETHOD(GetCaps)(LPDDSCAPS lpCaps);
    STDMETHOD(GetClipper)(LPDIRECTDRAWCLIPPER FAR* lpClipper);
    STDMETHOD(GetColorKey)(DWORD dw, LPDDCOLORKEY lpKey);
    STDMETHOD(GetDC)(HDC FAR * lphdc);
    STDMETHOD(GetFlipStatus)(DWORD dw);
    STDMETHOD(GetOverlayPosition)(LPLONG lpl1, LPLONG lpl2);
    STDMETHOD(GetPalette)(LPDIRECTDRAWPALETTE FAR* ppPal);
    STDMETHOD(GetPixelFormat)(LPDDPIXELFORMAT pPixelFormat);
    STDMETHOD(GetSurfaceDesc)(LPDDSURFACEDESC pSurfaceDesc);
    STDMETHOD(Initialize)(LPDIRECTDRAW pDD, LPDDSURFACEDESC pSurfaceDesc);
    STDMETHOD(IsLost)();
    STDMETHOD(Lock)(LPRECT pRect, LPDDSURFACEDESC pSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
    STDMETHOD(ReleaseDC)(HDC hdc);
    STDMETHOD(Restore)();
    STDMETHOD(SetClipper)(LPDIRECTDRAWCLIPPER pClipper);
    STDMETHOD(SetColorKey)(DWORD dwFlags, LPDDCOLORKEY pDDColorKey);
    STDMETHOD(SetOverlayPosition)(LONG x, LONG y);
    STDMETHOD(SetPalette)(LPDIRECTDRAWPALETTE pDDPal);
    STDMETHOD(Unlock)(LPVOID pBits);
    STDMETHOD(UpdateOverlay)(LPRECT prc, LPDIRECTDRAWSURFACE pdds, LPRECT prc2, DWORD dw, LPDDOVERLAYFX pfx);
    STDMETHOD(UpdateOverlayDisplay)(DWORD dw);
    STDMETHOD(UpdateOverlayZOrder)(DWORD dw, LPDIRECTDRAWSURFACE pdds);

    // IDirectDrawPalette
    STDMETHOD(SetEntries)(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries);
    STDMETHOD(GetCaps)(LPDWORD lpdw);
    STDMETHOD(GetEntries)(DWORD dwFlags, DWORD dwStart, DWORD dwCount, LPPALETTEENTRY pEntries);
    STDMETHOD(Initialize)(LPDIRECTDRAW lpdd, DWORD dwCount, LPPALETTEENTRY pEntries);

protected:
    HBITMAP         m_hbmDib;
    DIBSECTION      m_dsSurface;
    DDCOLORKEY      m_ddColorKey;
    LONG            m_lPitch;
    RECT            m_rcSurface;
    BYTE *          m_pbBits;
};

HBITMAP ImgCreateDib(LONG xWid, LONG yHei, BOOL fPal, int cBitsPerPix,
    int cEnt, PALETTEENTRY * ppe, BYTE ** ppbBits, int * pcbRow);
HBITMAP ImgCreateDibFromInfo(BITMAPINFO * pbmi, UINT wUsage, BYTE ** ppbBits, int * pcbRow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cdithtbl.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cdithtbl.h"

CDitherTable::CDitherTable() :
   m_nColors( 0 ),
   m_nRefCount( 0 ),
   m_pnDistanceBuffer( NULL )
{
}

CDitherTable::~CDitherTable()
{
}

BOOL CDitherTable::Match( ULONG nColors, const RGBQUAD* prgbColors )
{
   if( m_nColors != nColors )
   {
      return( FALSE );
   }

   if( memcmp( m_argbColors, prgbColors, m_nColors*sizeof( RGBQUAD ) ) != 0 )
   {
      return( FALSE );
   }

   return( TRUE );
}

HRESULT CDitherTable::SetColors( ULONG nColors, const RGBQUAD* prgbColors )
{
   HRESULT hResult;

   m_nColors = nColors;
   memcpy( m_argbColors, prgbColors, m_nColors*sizeof( RGBQUAD ) );

   hResult = BuildInverseMap();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}
/*
void CDitherTable::BuildInverseMap()
{
   ULONG r;
   ULONG g;
   ULONG b;
   ULONG iColor;
   ULONG iMapEntry;
   int nMinDistance;
   int nDistance;
   int nRedDistance;
   int nBlueDistance;
   int nGreenDistance;

   iMapEntry = 0;
   for( r = 0; r < 32; r++ )
   {
      for( g = 0; g < 32; g++ )
      {
         for( b = 0; b < 32; b++ )
         {
            nMinDistance = 1000000;
            for( iColor = 0; iColor < m_nColors; iColor++ )
            {
               nRedDistance = m_argbColors[iColor].rgbRed-((r<<3)+(r>>2));
               nGreenDistance = m_argbColors[iColor].rgbGreen-((g<<3)+(g>>2));
               nBlueDistance = m_argbColors[iColor].rgbBlue-((b<<3)+(b>>2));
               nDistance = (nRedDistance*nRedDistance)+(nGreenDistance*
                  nGreenDistance)+(nBlueDistance*nBlueDistance);
               if( nDistance < nMinDistance )
               {
                  nMinDistance = nDistance;
                  m_abInverseMap[iMapEntry] = BYTE( iColor );
               }
            }
            iMapEntry++;
         }
      }
   }
}
*/

HRESULT CDitherTable::BuildInverseMap()
{
   _ASSERTE( m_pnDistanceBuffer == NULL );

   m_pnDistanceBuffer = new ULONG[32768];
   if( m_pnDistanceBuffer == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   inv_cmap( m_nColors, m_argbColors, 5, m_pnDistanceBuffer, m_abInverseMap );

   delete m_pnDistanceBuffer;
   m_pnDistanceBuffer = NULL;

   return( S_OK );
}

/*****************************************************************
 * TAG( inv_cmap )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:
 * 	colors:		Number of colors in the forward colormap.
 * 	colormap:	The forward colormap.
 * 	bits:		Number of quantization bits.  The inverse
 * 			colormap will have (2^bits)^3 entries.
 * 	dist_buf:	An array of (2^bits)^3 long integers to be
 * 			used as scratch space.
 * Outputs:
 * 	rgbmap:		The output inverse colormap.  The entry
 * 			rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 * 			is the colormap entry that is closest to the
 * 			(quantized) color (r,g,b).
 * Assumptions:
 * 	Quantization is performed by right shift (low order bits are
 * 	truncated).  Thus, the distance to a quantized color is
 * 	actually measured to the color at the center of the cell
 * 	(i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 * 	Uses a "distance buffer" algorithm:
 * 	The distance from each representative in the forward color map
 * 	to each point in the rgb space is computed.  If it is less
 * 	than the distance currently stored in dist_buf, then the
 * 	corresponding entry in rgbmap is replaced with the current
 * 	representative (and the dist_buf entry is replaced with the
 * 	new distance).
 *
 * 	The distance computation uses an efficient incremental formulation.
 *
 * 	Distances are computed "outward" from each color.  If the
 * 	colors are evenly distributed in color space, the expected
 * 	number of cells visited for color I is N^3/I.
 * 	Thus, the complexity of the algorithm is O(log(K) N^3),
 * 	where K = colors, and N = 2^bits.
 */

/*
 * Here's the idea:  scan from the "center" of each cell "out"
 * until we hit the "edge" of the cell -- that is, the point
 * at which some other color is closer -- and stop.  In 1-D,
 * this is simple:
 * 	for i := here to max do
 * 		if closer then buffer[i] = this color
 * 		else break
 * 	repeat above loop with i := here-1 to min by -1
 *
 * In 2-D, it's trickier, because along a "scan-line", the
 * region might start "after" the "center" point.  A picture
 * might clarify:
 *		 |    ...
 *               | ...	.
 *              ...    	.
 *           ... |      .
 *          .    +     	.
 *           .          .
 *            .         .
 *             .........
 *
 * The + marks the "center" of the above region.  On the top 2
 * lines, the region "begins" to the right of the "center".
 *
 * Thus, we need a loop like this:
 * 	detect := false
 * 	for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			if !detect then
 * 				here = i
 * 				detect = true
 * 		else
 * 			if detect then
 * 				break
 * 				
 * Repeat the above loop with i := here-1 to min by -1.  Note that
 * the "detect" value should not be reinitialized.  If it was
 * "true", and center is not inside the cell, then none of the
 * cell lies to the left and this loop should exit
 * immediately.
 *
 * The outer loops are similar, except that the "closer" test
 * is replaced by a call to the "next in" loop; its "detect"
 * value serves as the test.  (No assignment to the buffer is
 * done, either.)
 *
 * Each time an outer loop starts, the "here", "min", and
 * "max" values of the next inner loop should be
 * re-initialized to the center of the cell, 0, and cube size,
 * respectively.  Otherwise, these values will carry over from
 * one "call" to the inner loop to the next.  This tracks the
 * edges of the cell and minimizes the number of
 * "unproductive" comparisons that must be made.
 *
 * Finally, the inner-most loop can have the "if !detect"
 * optimized out of it by splitting it into two loops: one
 * that finds the first color value on the scan line that is
 * in this cell, and a second that fills the cell until
 * another one is closer:
 *  	if !detect then	    {needed for "down" loop}
 * 	    for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			detect := true
 * 			break
 *	for i := i+1 to max do
 *		if closer then
 * 			buffer[..., i] := this color
 * 		else
 * 			break
 *
 * In this implementation, each level will require the
 * following variables.  Variables labelled (l) are local to each
 * procedure.  The ? should be replaced with r, g, or b:
 *  	cdist:	    	The distance at the starting point.
 * 	?center:	The value of this component of the color
 *  	c?inc:	    	The initial increment at the ?center position.
 * 	?stride:	The amount to add to the buffer
 * 			pointers (dp and rgbp) to get to the
 * 			"next row".
 * 	min(l):		The "low edge" of the cell, init to 0
 * 	max(l):		The "high edge" of the cell, init to
 * 			colormax-1
 * 	detect(l):    	True if this row has changed some
 * 	    	    	buffer entries.
 *  	i(l): 	    	The index for this row.
 *  	?xx:	    	The accumulated increment value.
 *  	
 *  	here(l):    	The starting index for this color.  The
 *  	    	    	following variables are associated with here,
 *  	    	    	in the sense that they must be updated if here
 *  	    	    	is changed.
 *  	?dist:	    	The current distance for this level.  The
 *  	    	    	value of dist from the previous level (g or r,
 *  	    	    	for level b or g) initializes dist on this
 *  	    	    	level.  Thus gdist is associated with here(b)).
 *  	?inc:	    	The initial increment for the row.
 *
 *  	?dp:	    	Pointer into the distance buffer.  The value
 *  	    	    	from the previous level initializes this level.
 *  	?rgbp:	    	Pointer into the rgb buffer.  The value
 *  	    	    	from the previous level initializes this level.
 * 
 * The blue and green levels modify 'here-associated' variables (dp,
 * rgbp, dist) on the green and red levels, respectively, when here is
 * changed.
 */

/* Track minimum and maximum. */
#define MINMAX_TRACK

void CDitherTable::inv_cmap(int colors, RGBQUAD *colormap, int bits,
        ULONG* dist_buf, BYTE* rgbmap )
{
    int nbits = 8 - bits;

    colormax = 1 << bits;
    x = 1 << nbits;
    xsqr = 1 << (2 * nbits);

    /* Compute "strides" for accessing the arrays. */
    gstride = (int) colormax;
    rstride = (int) (colormax * colormax);

    maxfill( dist_buf, colormax );

    for ( cindex = 0; cindex < colors; cindex++ )
    {
        /* The caller can force certain colors in the output space to be
         * omitted by setting a nonzero value for the color's 'x' component.
         * This will produce a map that never refers to those colors.
         * -francish, 2/16/96
         */
        if (!colormap[cindex].rgbReserved)
        {
            /*
             * Distance formula is
             * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
             *
             * Because of quantization, we will measure from the center of
             * each quantized "cube", so blue distance is
             * 	(blue + x/2 - map[2])^2,
             * where x = 2^(8 - bits).
             * The step size is x, so the blue increment is
             * 	2*x*blue - 2*x*map[2] + 2*x^2
             *
             * Now, b in the code below is actually blue/x, so our
             * increment will be 2*(b*x^2 + x^2 - x*map[2]).  For
             * efficiency, we will maintain this quantity in a separate variable
             * that will be updated incrementally by adding 2*x^2 each time.
             */
            /* The initial position is the cell containing the colormap
             * entry.  We get this by quantizing the colormap values.
             */
            rcenter = colormap[cindex].rgbRed >> nbits;
            gcenter = colormap[cindex].rgbGreen >> nbits;
            bcenter = colormap[cindex].rgbBlue >> nbits;
    
            rdist = colormap[cindex].rgbRed - (rcenter * x + x/2);
            gdist = colormap[cindex].rgbGreen - (gcenter * x + x/2);
            cdist = colormap[cindex].rgbBlue - (bcenter * x + x/2);
            cdist = rdist*rdist + gdist*gdist + cdist*cdist;
    
            crinc = 2 * ((rcenter + 1) * xsqr - (colormap[cindex].rgbRed*x));
            cginc = 2 * ((gcenter + 1) * xsqr - (colormap[cindex].rgbGreen*x));
            cbinc = 2 * ((bcenter + 1) * xsqr - (colormap[cindex].rgbBlue*x));
    
            /* Array starting points. */
            cdp = dist_buf + rcenter * rstride + gcenter * gstride + bcenter;
            crgbp = rgbmap + rcenter * rstride + gcenter * gstride + bcenter;
    
            (void)redloop();
        }
    }
}

/* redloop -- loop up and down from red center. */
int CDitherTable::redloop()
{
    int detect;
    int r;
    int first;
    long txsqr = xsqr + xsqr;

    detect = 0;

    /* Basic loop up. */
    for ( r = rcenter, rdist = cdist, rxx = crinc,
	  rdp = cdp, rrgbp = crgbp, first = 1;
	  r < (int) colormax;
	  r++, rdp += rstride, rrgbp += rstride,
	  rdist += rxx, rxx += txsqr, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }
    
    /* Basic loop down. */
    for ( r = rcenter - 1, rxx = crinc - txsqr, rdist = cdist - rxx,
	  rdp = cdp - rstride, rrgbp = crgbp - rstride, first = 1;
	  r >= 0;
	  r--, rdp -= rstride, rrgbp -= rstride,
	  rxx -= txsqr, rdist -= rxx, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }
    
    return detect;
}

#undef min
#undef max
#define here greenloop_here
#define min greenloop_min
#define max greenloop_max
#define prevmin greenloop_prevmin
#define prevmax greenloop_prevmax

/* greenloop -- loop up and down from green center. */
int CDitherTable::greenloop( int restart )
{
    int detect;
    int g;
    int first;
    long txsqr = xsqr + xsqr;
#ifdef MINMAX_TRACK
    int thismax, thismin;
#endif

    if ( restart )
    {
	here = gcenter;
	min = 0;
	max = (int) colormax - 1;
	ginc = cginc;
#ifdef MINMAX_TRACK
	prevmax = 0;
	prevmin = (int) colormax;
#endif
    }

#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif
    detect = 0;

    /* Basic loop up. */
    for ( g = here, gcdist = gdist = rdist, gxx = ginc,
	  gcdp = gdp = rdp, gcrgbp = grgbp = rrgbp, first = 1;
	  g <= max;
	  g++, gdp += gstride, gcdp += gstride, grgbp += gstride, gcrgbp += gstride,
	  gdist += gxx, gcdist += gxx, gxx += txsqr, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here and associated data! */
		if ( g > here )
		{
		    here = g;
		    rdp = gcdp;
		    rrgbp = gcrgbp;
		    rdist = gcdist;
		    ginc = gxx;
#ifdef MINMAX_TRACK
		    thismin = here;
#endif
		}
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismax = g - 1;
#endif
	    break;
	}
    }
    
    /* Basic loop down. */
    for ( g = here - 1, gxx = ginc - txsqr, gcdist = gdist = rdist - gxx,
	  gcdp = gdp = rdp - gstride, gcrgbp = grgbp = rrgbp - gstride,
	  first = 1;
	  g >= min;
	  g--, gdp -= gstride, gcdp -= gstride, grgbp -= gstride, gcrgbp -= gstride,
	  gxx -= txsqr, gdist -= gxx, gcdist -= gxx, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here! */
		here = g;
		rdp = gcdp;
		rrgbp = gcrgbp;
		rdist = gcdist;
		ginc = gxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismin = g + 1;
#endif
	    break;
	}
    }
    
#ifdef MINMAX_TRACK
    /* If we saw something, update the edge trackers.  For now, only
     * tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( detect )
    {
	if ( thismax < prevmax )
	    max = thismax;

	prevmax = thismax;

	if ( thismin > prevmin )
	    min = thismin;

	prevmin = thismin;
    }
#endif

    return detect;
}

#undef min
#undef max
#undef here
#undef prevmin
#undef prevmax
#define here blueloop_here
#define min blueloop_min
#define max blueloop_max
#define prevmin blueloop_prevmin
#define prevmax blueloop_prevmax

/* blueloop -- loop up and down from blue center. */
int CDitherTable::blueloop( int restart )
{
    int detect;
    register ULONG* dp;
    register BYTE* rgbp;
    register long bdist, bxx;
    register int b, i = cindex;
    register long txsqr = xsqr + xsqr;
    register int lim;
#ifdef MINMAX_TRACK
    int thismin, thismax;
#endif /* MINMAX_TRACK */

    if ( restart )
    {
	here = bcenter;
	min = 0;
	max = (int) colormax - 1;
	binc = cbinc;
#ifdef MINMAX_TRACK
	prevmin = (int) colormax;
	prevmax = 0;
#endif /* MINMAX_TRACK */
    }

    detect = 0;
#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif

    /* Basic loop up. */
    /* First loop just finds first applicable cell. */
    for ( b = here, bdist = gdist, bxx = binc, dp = gdp, rgbp = grgbp, lim = max;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    /* Remember new 'here' and associated data! */
	    if ( b > here )
	    {
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismin = here;
#endif
	    }
	    detect = 1;
	    break;
	}
    }
    /* Second loop fills in a run of closer cells. */
    for ( ;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismax = b - 1;
#endif
	    break;
	}
    }
    
    /* Basic loop down. */
    /* Do initializations here, since the 'find' loop might not get
     * executed. 
     */
    lim = min;
    b = here - 1;
    bxx = binc - txsqr;
    bdist = gdist - bxx;
    dp = gdp - 1;
    rgbp = grgbp - 1;
    /* The 'find' loop is executed only if we didn't already find
     * something.
     */
    if ( !detect )
	for ( ;
	      b >= lim;
	      b--, dp--, rgbp--,
	      bxx -= txsqr, bdist -= bxx )
	{
            if ( *dp > (DWORD)bdist )
	    {
		/* Remember here! */
		/* No test for b against here necessary because b <
		 * here by definition.
		 */
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
		break;
	    }
	}
    /* The 'update' loop. */
    for ( ;
	  b >= lim;
	  b--, dp--, rgbp--,
	  bxx -= txsqr, bdist -= bxx )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismin = b + 1;
#endif
	    break;
	}
    }


	/* If we saw something, update the edge trackers. */
#ifdef MINMAX_TRACK
    if ( detect )
    {
	/* Only tracks edges that are "shrinking" (min increasing, max
	 * decreasing.
	 */
	if ( thismax < prevmax )
	    max = thismax;

	if ( thismin > prevmin )
	    min = thismin;
    
	/* Remember the min and max values. */
	prevmax = thismax;
	prevmin = thismin;
    }
#endif /* MINMAX_TRACK */

    return detect;
}

void CDitherTable::maxfill( ULONG* buffer, long side)
{
    register unsigned long maxv = (unsigned long)~0L;
    register long i;
    register ULONG* bp;

    (void)side;

    for ( i = colormax * colormax * colormax, bp = buffer;
	  i > 0;
	  i--, bp++ )
	*bp = maxv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cdithtbl.h ===
class CDitherTable
{
   friend class CDitherToRGB8;

public:
   CDitherTable();
   ~CDitherTable();

   BOOL Match( ULONG nColors, const RGBQUAD* prgbColors );
   HRESULT SetColors( ULONG nColors, const RGBQUAD* prgbColors );

protected:
   HRESULT BuildInverseMap();

   void inv_cmap( int colors, RGBQUAD *colormap, int bits, ULONG* dist_buf, 
      BYTE* rgbmap );
   int redloop();
   int greenloop( int restart );
   int blueloop( int restart );
   void maxfill( ULONG* buffer, long side );

public:
   BYTE m_abInverseMap[32768];

protected:
   ULONG m_nRefCount;
   ULONG m_nColors;
   RGBQUAD m_argbColors[256];
   ULONG* m_pnDistanceBuffer;

// Vars that were global in the original code
   int bcenter, gcenter, rcenter;
   long gdist, rdist, cdist;
   long cbinc, cginc, crinc;
   ULONG* gdp;
   ULONG* rdp;
   ULONG* cdp;
   BYTE* grgbp;
   BYTE* rrgbp;
   BYTE* crgbp;
   int gstride, rstride;
   long x, xsqr, colormax;
   int cindex;

// Static locals from the original redloop().  Good coding at its finest.
   long rxx;

// Static locals from the original greenloop()
   int greenloop_here;
   int greenloop_min;
   int greenloop_max;
   int greenloop_prevmin;
   int greenloop_prevmax;
   long ginc;
   long gxx;
   long gcdist;
   ULONG* gcdp;
   BYTE* gcrgbp;

// Static locals from the original blueloop()
   int blueloop_here;
   int blueloop_min;
   int blueloop_max;
   int blueloop_prevmin;
   int blueloop_prevmax;
   long binc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cmapmime.h ===
HRESULT InitDefaultMappings();
void CleanupDefaultMappings();

class CMapStringToCLSID
{
public:
   CMapStringToCLSID();  // Default constructor
   ~CMapStringToCLSID();  // Destructor

   const CLSID& GetCLSID() const;
   DWORD GetMapMode() const;
   LPCTSTR GetString() const;
   HRESULT InitFromKey( HKEY hKey, LPCTSTR pszKeyName );
   void SetCLSID( REFGUID clsid );
   void SetMapMode( DWORD dwMapMode );
   HRESULT SetString( LPCTSTR pszString );

protected:
   char m_achSignature[4];

public:
   CMapStringToCLSID* m_pNext;

protected:
   LPTSTR m_pszString;
   CLSID m_clsid;
   DWORD m_dwMapMode;
};

class CMapMIMEToCLSID :
   public IMapMIMEToCLSID,
   public CComObjectRoot,
   public CComCoClass< CMapMIMEToCLSID, &CLSID_CoMapMIMEToCLSID >
{
public:
   CMapMIMEToCLSID();  // Default constructor
   ~CMapMIMEToCLSID();  // Destructor

   BEGIN_COM_MAP( CMapMIMEToCLSID )
      COM_INTERFACE_ENTRY( IMapMIMEToCLSID )
   END_COM_MAP()


   DECLARE_REGISTRY( CMapMIMEToCLSID, _T( "ImgUtil.CoMapMIMEToCLSID.1" ),
      _T( "ImgUtil.CoMapMIMEToCLSID" ), IDS_COMAPMIMETOCLSID_DESC,
      THREADFLAGS_BOTH )


//   DECLARE_NO_REGISTRY()

// IMapMIMEToCLSID
public:
   STDMETHOD( EnableDefaultMappings )( BOOL bEnable );
   STDMETHOD( MapMIMEToCLSID )( LPCOLESTR pszMIMEType, GUID* pCLSID );
   STDMETHOD( SetMapping )( LPCOLESTR pszMIMEType, DWORD dwMapMode, 
      REFGUID clsid );

protected:
   CMapStringToCLSID* AddMapping( LPCTSTR pszMIMEType );
   void DeleteMapping( LPCTSTR pszMIMEType );
   CMapStringToCLSID* FindMapping( LPCTSTR pszMIMEType );

protected:
   ULONG m_nMappings;
   BOOL m_bEnableDefaultMappings;
   CMapStringToCLSID* m_pMappings;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cdith8.h ===
const ULONG MAX_DITHERTABLE_CACHE_SIZE = 4;

class CDitherToRGB8 :
   public IImageDecodeEventSink,
   public IDithererImpl,
   public CComObjectRoot,
   public CComCoClass< CDitherToRGB8, &CLSID_CoDitherToRGB8 >
{
public:
   CDitherToRGB8();
   ~CDitherToRGB8();

   BEGIN_COM_MAP( CDitherToRGB8 )
      COM_INTERFACE_ENTRY( IImageDecodeEventSink )
      COM_INTERFACE_ENTRY( IDithererImpl )
   END_COM_MAP()


   DECLARE_REGISTRY( CDitherToRGB8, _T( "ImgUtil.CoDitherToRGB8.1" ),
      _T( "ImgUtil.CoDitherToRGB8" ), IDS_CODITHERTORGB8_DESC, 
      THREADFLAGS_BOTH );


//   DECLARE_NO_REGISTRY()

// IImageDecodeEventSink
public:
   STDMETHOD( GetSurface )( LONG nWidth, LONG nHeight, REFGUID bfid, 
      ULONG nPasses, DWORD dwHints, IUnknown** ppSurface );
   STDMETHOD( OnBeginDecode )( DWORD* pdwEvents, ULONG* pnFormats, 
      GUID** ppFormats );
   STDMETHOD( OnBitsComplete )();
   STDMETHOD( OnDecodeComplete )( HRESULT hrStatus );
   STDMETHOD( OnPalette )();
   STDMETHOD( OnProgress )( RECT* pBounds, BOOL bComplete );

// IDithererImpl
public: 
   STDMETHOD( SetDestColorTable )( ULONG nColors, const RGBQUAD* prgbColors );
   STDMETHOD( SetEventSink )( IImageDecodeEventSink* pEventSink );
public:
   static void InitTableCache();
   static void CleanupTableCache();

protected:
   HRESULT ConvertBlock( RECT* pBounds );
   HRESULT DitherBand( RECT* pBounds );
   HRESULT DitherFull();

protected:
   static CDitherTable* s_apTableCache[MAX_DITHERTABLE_CACHE_SIZE];
   static ULONG s_nCacheSize;
   static CRITICAL_SECTION s_csCache;

protected:
   typedef enum _ESrcFormat
   {
      RGB24,
      RGB8
   } ESrcFormat;

   CComPtr< IImageDecodeEventSink > m_pEventSink;
   CComPtr< IDirectDrawSurface > m_pDestSurface;
   CComPtr< IDirectDrawSurface > m_pSurface;
   BYTE *m_pbBits;
   DWORD m_dwEvents;
   ULONG m_nWidth;
   ULONG m_nHeight;
   ULONG m_nPitch;
   ULONG m_nBitsPerPixel;
   BOOL m_bProgressiveDither;
   ESrcFormat m_eSrcFormat;
   ULONG m_iScanLine;
   HBITMAP m_hbmDestDib;
   ERRBUF* m_pErrBuf;
   ERRBUF* m_pErrBuf1;
   ERRBUF* m_pErrBuf2;
   CDitherTable* m_pTable;
   RGBQUAD m_argbSrcColors[256];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cmapmime.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "resource.h"
#include "cmapmime.h"

CMapStringToCLSID* g_pDefaultMappings = NULL;
BOOL g_bDefaultMappingsInitialized = FALSE;
CRITICAL_SECTION g_csDefaultMappings;
const LPCTSTR MIME_DATABASE_ROOT = _T( "MIME\\Database\\Content Type" );

int UNICODEstrlen(LPCTSTR psz)
{
    const TCHAR *p;

    for (p = psz; *p; ++p)
        ;

    return (int)(p - psz);
}

HRESULT InitDefaultMappings()
{
   HRESULT hResult;
   LONG nResult;
   HKEY hKey;
   ULONG iSubkey;
   HKEY hSubkey;
   BOOL bDone;
   ULONG nNameLength;
   TCHAR szKeyName[MAX_PATH+1];
   CMapStringToCLSID* pMapping;
   FILETIME time;

   InitializeCriticalSection( &g_csDefaultMappings );
   
   nResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, MIME_DATABASE_ROOT, 0, KEY_READ,
      &hKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   iSubkey = 0;
   bDone = FALSE;
   while( !bDone )
   {
      nNameLength = sizeof( szKeyName )/sizeof( *szKeyName );
      nResult = RegEnumKeyEx( hKey, iSubkey, szKeyName, &nNameLength, NULL, 
         NULL, NULL, &time );
      if( (nResult != ERROR_SUCCESS) && (nResult != ERROR_NO_MORE_ITEMS) )
      {
         RegCloseKey( hKey );
         return( E_FAIL );
      }
      if( nResult == ERROR_SUCCESS )
      {
         nResult = RegOpenKeyEx( hKey, szKeyName, 0, KEY_READ, &hSubkey );
         if( nResult != ERROR_SUCCESS )
         {
            RegCloseKey( hKey );
            return( E_FAIL );
         }

         pMapping = new CMapStringToCLSID;
         if( pMapping == NULL )
         {
            return( E_OUTOFMEMORY );
         }
         hResult = pMapping->InitFromKey( hSubkey, szKeyName );
         if( SUCCEEDED( hResult ) )
         {
            pMapping->m_pNext = g_pDefaultMappings;
            g_pDefaultMappings = pMapping;
         }
         else
         {
            delete pMapping;
         }

         RegCloseKey( hSubkey );
      }
      else
      {
         bDone = TRUE;
      }

      iSubkey++;
   }

   return( S_OK );
}

void CleanupDefaultMappings()
{
   CMapStringToCLSID* pKill;

   EnterCriticalSection( &g_csDefaultMappings );

   while( g_pDefaultMappings != NULL )
   {
      pKill = g_pDefaultMappings;
      g_pDefaultMappings = g_pDefaultMappings->m_pNext;
      delete pKill;
   }

   LeaveCriticalSection( &g_csDefaultMappings );

   DeleteCriticalSection( &g_csDefaultMappings );
}

static HRESULT DefaultMapMIMEToCLSID( LPCTSTR pszMIMEType, CLSID* pCLSID )
{
   CMapStringToCLSID* pTrav;
   BOOL bFound;

   _ASSERTE( pszMIMEType != NULL );
   _ASSERTE( pCLSID != NULL );

   *pCLSID = CLSID_NULL;

   EnterCriticalSection( &g_csDefaultMappings );

   bFound = FALSE;
   pTrav = g_pDefaultMappings;
   while( (pTrav != NULL) && !bFound )
   {
      if( lstrcmp( pszMIMEType, pTrav->GetString() ) == 0 )
      {
         *pCLSID = pTrav->GetCLSID();
         bFound = TRUE;
      }
      pTrav = pTrav->m_pNext;
   }

   LeaveCriticalSection( &g_csDefaultMappings );

   if( IsEqualCLSID( *pCLSID, CLSID_NULL ) )
   {
      return( S_FALSE );
   }
   else
   {
      return( S_OK );
   }
}

CMapStringToCLSID::CMapStringToCLSID() :
   m_pNext( NULL ),
   m_pszString( NULL ),
   m_clsid( CLSID_NULL ),
   m_dwMapMode( MAPMIME_DEFAULT )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMapStringToCLSID::~CMapStringToCLSID()
{
   delete m_pszString;
}

const CLSID& CMapStringToCLSID::GetCLSID() const
{
   return( m_clsid );
}

DWORD CMapStringToCLSID::GetMapMode() const
{
   return( m_dwMapMode );
}

LPCTSTR CMapStringToCLSID::GetString() const
{
   _ASSERTE( m_pszString != NULL );

   return( m_pszString );
}

HRESULT CMapStringToCLSID::InitFromKey( HKEY hKey, LPCTSTR pszKeyName )
{
   LONG nResult;
   HRESULT hResult;
   DWORD dwValueType;
   BYTE* pData;
   ULONG nBytes = 0;
   CLSID clsid;
   USES_CONVERSION;

   nResult = RegQueryValueEx( hKey, _T( "Image Filter CLSID" ), NULL, 
      &dwValueType, NULL, &nBytes );
   if( (nResult != ERROR_SUCCESS) || (dwValueType != REG_SZ) || nBytes > 8192 )
   {
      return( E_FAIL );
   }
   pData = LPBYTE( _alloca( nBytes ) );

   nResult = RegQueryValueEx( hKey, _T( "Image Filter CLSID" ), NULL, 
      &dwValueType, pData, &nBytes );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   hResult = SetString( pszKeyName );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   CLSIDFromString( T2OLE( LPTSTR( pData ) ), &clsid );
   SetCLSID( clsid );

   return( S_OK );
}

void CMapStringToCLSID::SetCLSID( REFGUID clsid )
{
   m_clsid = clsid;
}

void CMapStringToCLSID::SetMapMode( DWORD dwMapMode )
{
   m_dwMapMode = dwMapMode;
}

HRESULT CMapStringToCLSID::SetString( LPCTSTR pszString )
{
   _ASSERTE( m_pszString == NULL );

   m_pszString = new TCHAR[UNICODEstrlen( pszString )+1];
   if( m_pszString == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   lstrcpy( m_pszString, pszString );

   return( S_OK );
}

CMapMIMEToCLSID::CMapMIMEToCLSID() :
   m_nMappings( 0 ),
   m_pMappings( NULL ),
   m_bEnableDefaultMappings( TRUE )
{
}

CMapMIMEToCLSID::~CMapMIMEToCLSID()
{
   CMapStringToCLSID* pKill;

   while( m_pMappings != NULL )
   {
      pKill = m_pMappings;
      m_pMappings = m_pMappings->m_pNext;
      delete pKill;
   }
}

CMapStringToCLSID* CMapMIMEToCLSID::FindMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;

   pMapping = m_pMappings;
   while( pMapping != NULL )
   {
      if( lstrcmp( pMapping->GetString(), pszMIMEType ) == 0 )
      {
         return( pMapping );
      }
      pMapping = pMapping->m_pNext;
   }

   return( NULL );
}

CMapStringToCLSID* CMapMIMEToCLSID::AddMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;
   HRESULT hResult;

   pMapping = new CMapStringToCLSID;
   if( pMapping == NULL )
   {
      return( NULL );
   }
   
   hResult = pMapping->SetString( pszMIMEType );
   if( FAILED( hResult ) )
   {
      delete pMapping;
      return( NULL );
   }

   pMapping->m_pNext = m_pMappings;
   m_pMappings = pMapping;
   m_nMappings++;

   return( pMapping );
}

void CMapMIMEToCLSID::DeleteMapping( LPCTSTR pszMIMEType )
{
   CMapStringToCLSID* pMapping;
   CMapStringToCLSID* pFollow;

   pFollow = NULL;
   pMapping = m_pMappings;
   while( pMapping != NULL )
   {
      if( lstrcmp( pMapping->GetString(), pszMIMEType ) == 0 )
      {
         if( pFollow == NULL )
         {
            m_pMappings = pMapping->m_pNext;
         }
         else
         {
            pFollow->m_pNext = pMapping->m_pNext;
         }
         delete pMapping;
         m_nMappings--;
         return;
      }
      pFollow = pMapping;
      pMapping = pMapping->m_pNext;
   }
}

STDMETHODIMP CMapMIMEToCLSID::SetMapping( LPCOLESTR pszMIMEType, 
   DWORD dwMapMode, REFGUID clsid )
{
   USES_CONVERSION;
   CMapStringToCLSID* pMapping;
   LPCTSTR pszMIMETypeT;

   if( pszMIMEType == NULL )
   {
      return( E_INVALIDARG );
   }
   if( dwMapMode > MAPMIME_DEFAULT_ALWAYS )
   {
      return( E_INVALIDARG );
   }

   pszMIMETypeT = OLE2CT( pszMIMEType );

   if( dwMapMode == MAPMIME_DEFAULT )
   {
      DeleteMapping( pszMIMETypeT );
   }
   else
   {
      pMapping = FindMapping( pszMIMETypeT );
      if( pMapping == NULL )
      {
         pMapping = AddMapping( pszMIMETypeT );
         if( pMapping == NULL )
         {
            return( E_OUTOFMEMORY );
         }
      }
      pMapping->SetMapMode( dwMapMode );
      if( dwMapMode == MAPMIME_CLSID )
      {
         pMapping->SetCLSID( clsid );
      }
   }

   return( S_OK );
}

STDMETHODIMP CMapMIMEToCLSID::EnableDefaultMappings( BOOL bEnable )
{
   m_bEnableDefaultMappings = bEnable;

   return( S_OK );
}

STDMETHODIMP CMapMIMEToCLSID::MapMIMEToCLSID( LPCOLESTR pszMIMEType, 
   GUID* pCLSID )
{
   USES_CONVERSION;
   LPCTSTR pszMIMETypeT;
   DWORD dwMapMode;
   GUID clsid = CLSID_NULL;
   CMapStringToCLSID* pMapping;
   HRESULT hResult;

   if( pCLSID != NULL )
   {
      *pCLSID = CLSID_NULL;
   }
   if( pszMIMEType == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pCLSID == NULL )
   {
      return( E_POINTER );
   }

   pszMIMETypeT = OLE2CT( pszMIMEType );

   pMapping = FindMapping( pszMIMETypeT );
   if( pMapping != NULL )
   {
      dwMapMode = pMapping->GetMapMode();
      if( dwMapMode == MAPMIME_CLSID )
      {
         clsid = pMapping->GetCLSID();
      }
   }
   else
   {
      dwMapMode = MAPMIME_DEFAULT;
   }

   switch( dwMapMode )
   {
   case MAPMIME_DEFAULT:
      if( m_bEnableDefaultMappings )
      {
         hResult = DefaultMapMIMEToCLSID( pszMIMETypeT, &clsid );
      }
      else
      {
         hResult = S_FALSE;
      }
      break;

   case MAPMIME_DEFAULT_ALWAYS:
      hResult = DefaultMapMIMEToCLSID( pszMIMETypeT, &clsid );
      break;

   case MAPMIME_CLSID:
      hResult = S_OK;
      break;

   case MAPMIME_DISABLE:
      hResult = S_FALSE;
      break;

   default:
      _ASSERT( FALSE );
      hResult = E_FAIL;
      break;
   }

   if( hResult == S_OK )
   {
      *pCLSID = clsid;
   }

   return( hResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cmimeid.h ===
class CMIMEBitMatcher
{
public:
   CMIMEBitMatcher();  // Default constructor
   ~CMIMEBitMatcher();  // Destructor

   HRESULT InitFromBinary( const BYTE* pData, ULONG nBytes, 
      ULONG* pnBytesToMatch );
   HRESULT Match( const BYTE* pBytes, ULONG nBytes ) const;

protected:
   char m_achSignature[4];

public:
   CMIMEBitMatcher* m_pNext;

protected:
   ULONG m_nOffset;
   ULONG m_nBytes;
   BYTE* m_pMask;
   BYTE* m_pData;
};

class CMIMEType
{
public:
   CMIMEType();  // Default constructor
   ~CMIMEType();  // Destructor

   UINT GetClipboardFormat() const;
   HRESULT InitFromKey( HKEY hKey, LPCTSTR pszName, ULONG* pnMaxBytes );
   HRESULT Match( const BYTE* pBytes, ULONG nBytes ) const;

protected:
   char m_achSignature[4];

public:
   CMIMEType* m_pNext;

protected:
   UINT m_nClipboardFormat;
   CMIMEBitMatcher* m_lpBitMatchers;
   ULONG m_nMaxBytes;
};

class CMIMEIdentifier
{
public:
   CMIMEIdentifier();  // Default constructor
   ~CMIMEIdentifier();  // Destructor

   ULONG GetMaxBytes() const;
   HRESULT Identify( const BYTE* pbBytes, ULONG nBytes, UINT* pnFormat );
   HRESULT IdentifyStream( ISniffStream* pSniffStream, 
      UINT* pnClipboardFormat );
   HRESULT InitFromRegistry();

protected:
   char m_achSignature[4];

protected:
   ULONG m_nMaxBytes;
   CMIMEType* m_lpTypes;
};

void InitMIMEIdentifier();
void CleanupMIMEIdentifier();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\cmimeid.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "cmimeid.h"

static CRITICAL_SECTION g_csMIMEIdentifier;
static CMIMEIdentifier* g_pMIMEIdentifier = NULL;

void InitMIMEIdentifier()
{
   InitializeCriticalSection( &g_csMIMEIdentifier );
}

void CleanupMIMEIdentifier()
{
    DeleteCriticalSection(&g_csMIMEIdentifier);
}


STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes )
{
   HRESULT hResult;

   if( pnMaxBytes != NULL )
   {
      *pnMaxBytes = 0;
   }
   if( pnMaxBytes == NULL )
   {
      return( E_POINTER );
   }

   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   *pnMaxBytes = g_pMIMEIdentifier->GetMaxBytes();

   LeaveCriticalSection( &g_csMIMEIdentifier );

   return( S_OK );
}

STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
   HRESULT hResult;
  
   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pbBytes == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   hResult = g_pMIMEIdentifier->Identify( pbBytes, nBytes, pnFormat );
   LeaveCriticalSection( &g_csMIMEIdentifier );

   return( hResult );
}

STDAPI SniffStream( IStream* pInStream, UINT* pnFormat, 
   IStream** ppOutStream )
{
   HRESULT hResult;
   HRESULT hIDResult;
   CComPtr< ISniffStream > pSniffStream;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( ppOutStream != NULL )
   {
      *ppOutStream = NULL;
   }

   if( pInStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }
   if( ppOutStream == NULL )
   {
      return( E_POINTER );
   }

   hResult = pInStream->QueryInterface( IID_ISniffStream, 
      (void**)&pSniffStream );
   if( FAILED( hResult ) && (hResult != E_NOINTERFACE) )
   {
      return( hResult );
   }

   if( hResult == E_NOINTERFACE )
   {
      hResult = CoCreateInstance( CLSID_CoSniffStream, NULL, 
         CLSCTX_INPROC_SERVER, IID_ISniffStream, (void**)&pSniffStream );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }

      hResult = pSniffStream->Init( pInStream );
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }


   EnterCriticalSection( &g_csMIMEIdentifier );
   if( g_pMIMEIdentifier == NULL )
   {
      g_pMIMEIdentifier = new CMIMEIdentifier;
      hResult = g_pMIMEIdentifier->InitFromRegistry();
      if( FAILED( hResult ) )
      {
         delete g_pMIMEIdentifier;
         g_pMIMEIdentifier = NULL;
         LeaveCriticalSection( &g_csMIMEIdentifier );
         return( hResult );
      }
   }

   hIDResult = g_pMIMEIdentifier->IdentifyStream( pSniffStream, pnFormat );
   LeaveCriticalSection( &g_csMIMEIdentifier );
   if( FAILED( hIDResult ) )
   {
      return( hIDResult );
   }

   hResult = pSniffStream->QueryInterface( IID_IStream, (void**)ppOutStream );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( hIDResult );
}

const LPCTSTR MIME_DATABASE_ROOT = _T( "MIME\\Database\\Content Type" );

CMIMEBitMatcher::CMIMEBitMatcher() :
   m_pNext( NULL ),
   m_nOffset( 0 ),
   m_nBytes( 0 ),
   m_pMask( NULL ),
   m_pData( NULL )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEBitMatcher::~CMIMEBitMatcher()
{
   delete m_pMask;
   delete m_pData;
}

HRESULT CMIMEBitMatcher::InitFromBinary( const BYTE* pData, ULONG nBytes,
   ULONG* pnBytesToMatch )
{
   const BYTE* pTrav;
#ifdef BIG_ENDIAN
   BYTE pTravBig[4];
#endif

   _ASSERTE( pData != NULL );
   _ASSERTE( pnBytesToMatch != NULL );

   if( nBytes <= sizeof( ULONG ) )
   {
      return( E_FAIL );
   }

   pTrav = pData;
#ifdef BIG_ENDIAN
   pTravBig[0] = pTrav[3];
   pTravBig[1] = pTrav[2];
   pTravBig[2] = pTrav[1];
   pTravBig[3] = pTrav[0];
   m_nBytes = *(ULONG*)pTravBig;
#else
   m_nBytes = *(const ULONG*)(pTrav);
#endif   

   pTrav += sizeof( ULONG );

   if( nBytes != (2*m_nBytes)+sizeof( ULONG ) )
   {
      return( E_FAIL );
   }

   m_pMask = new BYTE[m_nBytes];
   if( m_pMask == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   m_pData = new BYTE[m_nBytes];
   if( m_pData == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   memcpy( m_pMask, pTrav, m_nBytes );
   pTrav += m_nBytes;
   memcpy( m_pData, pTrav, m_nBytes );

   *pnBytesToMatch = m_nBytes;

   return( S_OK );
}

HRESULT CMIMEBitMatcher::Match( const BYTE* pBytes, ULONG nBytes ) const
{
   ULONG iByte;
   ULONG nBytesToMatch;

   _ASSERTE( m_nBytes > 0 );

   nBytesToMatch = min( nBytes, m_nBytes );
   for( iByte = 0; iByte < nBytesToMatch; iByte++ )
   {
      if( (pBytes[iByte]&m_pMask[iByte]) != m_pData[iByte] )
      {
         // The bits definitely don't match
         return( S_FALSE );
      }
   }

   if( nBytes < m_nBytes )
   {
      // We could have a match, but we need more data to be sure.
      return( E_PENDING );
   }

   // We have a match
   return( S_OK );
}


CMIMEType::CMIMEType() :
   m_pNext( NULL ),
   m_nClipboardFormat( 0 ),
   m_lpBitMatchers( NULL ),
   m_nMaxBytes( 0 )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEType::~CMIMEType()
{
   CMIMEBitMatcher* pBitMatcher;

   while( m_lpBitMatchers != NULL )
   {
      pBitMatcher = m_lpBitMatchers;
      m_lpBitMatchers = m_lpBitMatchers->m_pNext;
      delete pBitMatcher;
   }
}

UINT CMIMEType::GetClipboardFormat() const
{
   return( m_nClipboardFormat );
}

HRESULT CMIMEType::InitFromKey( HKEY hKey, LPCTSTR pszName, ULONG* pnMaxBytes )
{
   LONG nResult;
   HRESULT hResult;
   HKEY hBitsKey;
   DWORD dwValueType;
   BYTE* pData;
   ULONG nBytes = 0;
   ULONG nBytesToMatch;
   CMIMEBitMatcher* pBitMatcher;

   _ASSERTE( hKey != NULL );
   _ASSERTE( pszName != NULL );
   _ASSERTE( pnMaxBytes != NULL );

   nResult = RegOpenKeyEx( hKey, _T( "Bits" ), 0, KEY_READ, &hBitsKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   nResult = RegQueryValueEx( hBitsKey, _T( "0" ), NULL, &dwValueType, NULL,
      &nBytes );
   if( (nResult != ERROR_SUCCESS) || (dwValueType != REG_BINARY) || nBytes > 8192 )
   {
      RegCloseKey( hBitsKey );
      return( E_FAIL );
   }
   pData = LPBYTE( _alloca( nBytes ) );

   nResult = RegQueryValueEx( hBitsKey, _T( "0" ), NULL, &dwValueType, pData,
      &nBytes );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   RegCloseKey( hBitsKey );

   pBitMatcher = new CMIMEBitMatcher;
   if( pBitMatcher == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   hResult = pBitMatcher->InitFromBinary( pData, nBytes, &nBytesToMatch );
   if( FAILED( hResult ) )
   {
      delete pBitMatcher;
      return( hResult );
   }

   m_nMaxBytes = max( m_nMaxBytes, nBytesToMatch );

   m_lpBitMatchers = pBitMatcher;

   m_nClipboardFormat = RegisterClipboardFormat( pszName );
   if( m_nClipboardFormat == 0 )
   {
      return( E_FAIL );
   }

   *pnMaxBytes = m_nMaxBytes;

   return( S_OK );
}

HRESULT CMIMEType::Match( const BYTE* pBytes, ULONG nBytes ) const
{
   HRESULT hResult;
   HRESULT hResultSoFar;
   CMIMEBitMatcher* pBitMatcher;

   _ASSERTE( pBytes != NULL );
   _ASSERTE( m_nClipboardFormat != 0 );
   _ASSERTE( m_lpBitMatchers != NULL );

   hResultSoFar = S_FALSE;
   for( pBitMatcher = m_lpBitMatchers; pBitMatcher != NULL; pBitMatcher =
      pBitMatcher->m_pNext )
   {
      hResult = pBitMatcher->Match( pBytes, nBytes );
      switch( hResult )
      {
      case S_OK:
         return( S_OK );
         break;

      case E_PENDING:
         hResultSoFar = E_PENDING;
         break;

      case S_FALSE:
         break;

      default:
         return( hResult );
         break;
      }
   }

   return( hResultSoFar );
}


CMIMEIdentifier::CMIMEIdentifier() :
   m_lpTypes( NULL ),
   m_nMaxBytes( 0 )
{
   memcpy( m_achSignature, "NoLK", 4 );
}

CMIMEIdentifier::~CMIMEIdentifier()
{
   CMIMEType* pType;

   while( m_lpTypes != NULL )
   {
      pType = m_lpTypes;
      m_lpTypes = m_lpTypes->m_pNext;
      delete pType;
   }
}

ULONG CMIMEIdentifier::GetMaxBytes() const
{
   return( m_nMaxBytes );
}

HRESULT CMIMEIdentifier::Identify( const BYTE* pbBytes, ULONG nBytes, 
   UINT* pnFormat )
{
   HRESULT hResultSoFar;
   CMIMEType* pType;
   HRESULT hResult;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pbBytes == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   hResultSoFar = S_FALSE;
   for( pType = m_lpTypes; pType != NULL; pType = pType->m_pNext )
   {
      hResult = pType->Match( pbBytes, nBytes );
      switch( hResult )
      {
      case S_OK:
         *pnFormat = pType->GetClipboardFormat();
         return( S_OK );
         break;

      case E_PENDING:
         hResultSoFar = E_PENDING;
         break;

      case S_FALSE:
         break;

      default:
         return( hResult );
         break;
      }
   }

   return( hResultSoFar );
}

HRESULT CMIMEIdentifier::IdentifyStream( ISniffStream* pSniffStream, 
   UINT* pnFormat )
{
   HRESULT hResult;
   HRESULT hPeekResult;
   BYTE* pbBytes;
   ULONG nBytesRead;
   UINT nFormat;

   if( pnFormat != NULL )
   {
      *pnFormat = 0;
   }
   if( pSniffStream == NULL )
   {
      return( E_INVALIDARG );
   }
   if( pnFormat == NULL )
   {
      return( E_POINTER );
   }

   pbBytes = LPBYTE( _alloca( m_nMaxBytes ) );
   hPeekResult = pSniffStream->Peek( pbBytes, m_nMaxBytes, &nBytesRead );
   if( FAILED( hPeekResult ) && (hPeekResult != E_PENDING) )
   {
      return( hPeekResult );
   }

   hResult = Identify( pbBytes, nBytesRead, &nFormat );
   if( hResult == S_OK )
   {
      *pnFormat = nFormat;
   }
   if( (hResult == E_PENDING) && (hPeekResult == S_FALSE) )
   {
      return( S_FALSE );
   }

   return( hResult );
}

HRESULT CMIMEIdentifier::InitFromRegistry()
{
   LONG nResult;
   HKEY hKey;
   ULONG iSubkey;
   HKEY hSubkey;
   TCHAR szKeyName[MAX_PATH+1];
   ULONG nNameLength;
   FILETIME time;
   BOOL bDone;
   CMIMEType* pType;
   HRESULT hResult;
   ULONG nMaxBytes;

   if( m_lpTypes != NULL )
   {
      return( E_FAIL );
   }

   nResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, MIME_DATABASE_ROOT, 0, KEY_READ,
      &hKey );
   if( nResult != ERROR_SUCCESS )
   {
      return( E_FAIL );
   }

   iSubkey = 0;
   bDone = FALSE;
   while( !bDone )
   {
      nNameLength = sizeof( szKeyName )/sizeof( *szKeyName );
      nResult = RegEnumKeyEx( hKey, iSubkey, szKeyName, &nNameLength, NULL, 
         NULL, NULL, &time );
      if( (nResult != ERROR_SUCCESS) && (nResult != ERROR_NO_MORE_ITEMS) )
      {
         RegCloseKey( hKey );
         return( E_FAIL );
      }
      if( nResult == ERROR_SUCCESS )
      {
         nResult = RegOpenKeyEx( hKey, szKeyName, 0, KEY_READ, &hSubkey );
         if( nResult != ERROR_SUCCESS )
         {
            RegCloseKey( hKey );
            return( E_FAIL );
         }

         pType = new CMIMEType;
         if( pType == NULL )
         {
            return( E_OUTOFMEMORY );
         }
         hResult = pType->InitFromKey( hSubkey, szKeyName, &nMaxBytes );
         if( SUCCEEDED( hResult ) )
         {
            m_nMaxBytes = max( m_nMaxBytes, nMaxBytes );
            pType->m_pNext = m_lpTypes;
            m_lpTypes = pType;
         }
         else
         {
            delete pType;
         }

         RegCloseKey( hSubkey );
      }
      else
      {
         bDone = TRUE;
      }

      iSubkey++;
   }

   return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\csnfstrm.h ===
class CSniffStream :
   public IStream,
   public ISniffStream,
   public CComObjectRoot,
   public CComCoClass< CSniffStream, &CLSID_CoSniffStream >
{
public:
   CSniffStream();  // Default constructor
   ~CSniffStream();  // Destructor

   BEGIN_COM_MAP( CSniffStream )
      COM_INTERFACE_ENTRY( IStream )
      COM_INTERFACE_ENTRY( ISniffStream )
   END_COM_MAP()


   DECLARE_REGISTRY( CSniffStream, _T( "ImgUtil.CoSniffStream.1" ),
      _T( "ImgUtil.CoSniffStream" ), IDS_COSNIFFSTREAM_DESC, 
      THREADFLAGS_BOTH );


//   DECLARE_NO_REGISTRY()

// IStream
public:
   STDMETHOD( Clone )( IStream** ppStream );
   STDMETHOD( Commit )( DWORD dwFlags );
   STDMETHOD( CopyTo )( IStream* pStream, ULARGE_INTEGER nBytes, 
      ULARGE_INTEGER* pnBytesRead, ULARGE_INTEGER* pnBytesWritten );
   STDMETHOD( LockRegion )( ULARGE_INTEGER iOffset, ULARGE_INTEGER nBytes,
      DWORD dwLockType );
   STDMETHOD( Read )( void* pBuffer, ULONG nBytes, ULONG* pnBytesRead );
   STDMETHOD( Revert )();
   STDMETHOD( Seek )( LARGE_INTEGER nDisplacement, DWORD dwOrigin, 
      ULARGE_INTEGER* piNewPosition );
   STDMETHOD( SetSize )( ULARGE_INTEGER nNewSize );
   STDMETHOD( Stat )( STATSTG* pStatStg, DWORD dwFlags );
   STDMETHOD( UnlockRegion )( ULARGE_INTEGER iOffset, ULARGE_INTEGER nBytes,
      DWORD dwLockType );
   STDMETHOD( Write )( const void* pBuffer, ULONG nBytes, 
      ULONG* pnBytesWritten );

// ISniffStream
public:
   STDMETHOD( Init )( IStream* pStream );
   STDMETHOD( Peek )( void* pBuffer, ULONG nBytes, ULONG* pnBytesRead );

protected:
   CComPtr< IStream > m_pStream;
   BYTE* m_pbBuffer;
   ULONG m_nBufferSize;
   ULONG m_nValidBytes;
   ULONG m_iNextFreeByte;
   ULONG m_iOffset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\csnfstrm.cpp ===
#include "stdafx.h"
#include "imgutil.h"
#include "resource.h"
#include "csnfstrm.h"

CSniffStream::CSniffStream() :
   m_pbBuffer( NULL ),
   m_iOffset( 0 ),
   m_nBufferSize( 0 ),
   m_nValidBytes( 0 ),
   m_iNextFreeByte( 0 )
{
}

CSniffStream::~CSniffStream()
{
   delete m_pbBuffer;
}

STDMETHODIMP CSniffStream::Clone( IStream** ppStream )
{
   if( ppStream == NULL )
   {
      return( E_POINTER );
   }

   *ppStream = NULL;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Commit( DWORD dwFlags )
{
   (void)dwFlags;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::CopyTo( IStream* pStream, ULARGE_INTEGER nBytes,
   ULARGE_INTEGER* pnBytesRead, ULARGE_INTEGER* pnBytesWritten )
{
   (void)pStream;
   (void)nBytes;
   (void)pnBytesRead;
   (void)pnBytesWritten;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::LockRegion( ULARGE_INTEGER iOffset, 
   ULARGE_INTEGER nBytes, DWORD dwLockType )
{
   (void)iOffset;
   (void)nBytes;
   (void)dwLockType;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Read( void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesRead )
{
   ULONG nBytesToRead = 0;
   ULONG nBytesLeft;
   ULONG nBytesRead;
   BYTE* pbBuffer;
   HRESULT hResult;

   if( pnBytesRead != NULL )
   {
      *pnBytesRead = 0;
   }

   if( pBuffer == NULL )
   {
      return( E_POINTER );
   }

   if( nBytes == 0 )
   {
      return( E_INVALIDARG );
   }

   pbBuffer = LPBYTE( pBuffer );
   nBytesLeft = nBytes;
   if( m_pbBuffer != NULL )
   {
      _ASSERTE( m_nValidBytes > 0 );

      nBytesToRead = min( nBytesLeft, m_nValidBytes );
      memcpy( pbBuffer, &m_pbBuffer[m_iOffset], nBytesToRead );
      nBytesLeft -= nBytesToRead;
      if( pnBytesRead != NULL )
      {
         *pnBytesRead += nBytesToRead;
      }
      m_nValidBytes -= nBytesToRead;
      pbBuffer += nBytesToRead;
      m_iOffset += nBytesToRead;
      if( m_nValidBytes == 0 )
      {
         delete m_pbBuffer;
         m_pbBuffer = NULL;
         m_nValidBytes = 0;
         m_iNextFreeByte = 0;
         m_iOffset = 0;
         m_nBufferSize = 0;
      }
   }

   if( nBytesLeft == 0 )
   {
      return( S_OK );
   }

   _ASSERTE( m_pbBuffer == NULL );
   hResult = m_pStream->Read( pbBuffer, nBytesLeft, &nBytesRead );
   if( hResult == S_OK && pnBytesRead != NULL )
   {
      *pnBytesRead += nBytesRead;
   }

   return( hResult );
}

STDMETHODIMP CSniffStream::Revert()
{
   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Seek( LARGE_INTEGER nDisplacement, DWORD dwOrigin,
   ULARGE_INTEGER* piNewPosition )
{
   (void)nDisplacement;
   (void)dwOrigin;
   (void)piNewPosition;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::SetSize( ULARGE_INTEGER nNewSize )
{
   (void)nNewSize;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Stat( STATSTG* pStatStg, DWORD dwFlags )
{
   (void)pStatStg;
   (void)dwFlags;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::UnlockRegion( ULARGE_INTEGER iOffset, 
   ULARGE_INTEGER nBytes, DWORD dwLockType )
{
   (void)iOffset;
   (void)nBytes;
   (void)dwLockType;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Write( const void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesWritten )
{
   (void)pBuffer;
   (void)nBytes;
   (void)pnBytesWritten;

   return( E_NOTIMPL );
}

STDMETHODIMP CSniffStream::Init( IStream* pStream )
{
   if( pStream == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pStream = pStream;

   return( S_OK );
}

STDMETHODIMP CSniffStream::Peek( void* pBuffer, ULONG nBytes, 
   ULONG* pnBytesRead )
{
   BYTE* pbNewBuffer;
   HRESULT hResult;
   ULONG nBytesToRead;
   ULONG nBytesRead;

   if( pnBytesRead != NULL )
   {
      *pnBytesRead = 0;
   }

   if( pBuffer == NULL )
   {
      return( E_POINTER );
   }
   if( nBytes == 0 )
   {
      return( E_INVALIDARG );
   }

   hResult = S_OK;

   if( nBytes > m_nValidBytes )
   {
      // We have to read from the stream

      if( nBytes > (m_nBufferSize-m_iOffset) )
      {
         // We need more buffer space
         pbNewBuffer = new BYTE[nBytes];
         if( pbNewBuffer == NULL )
         {
            return( E_OUTOFMEMORY );
         }

         if( m_pbBuffer != NULL )
         {
            memcpy( pbNewBuffer, &m_pbBuffer[m_iOffset], m_nValidBytes );
         }
         delete m_pbBuffer;
         m_pbBuffer = pbNewBuffer;

         m_nBufferSize = nBytes;
         m_iOffset = 0;
         m_iNextFreeByte = m_nValidBytes;
      }

      hResult = m_pStream->Read( &m_pbBuffer[m_iNextFreeByte], 
         nBytes-m_nValidBytes, &nBytesRead );
      m_iNextFreeByte += nBytesRead;
      m_nValidBytes += nBytesRead;
   }

   // Copy as much as we can from our buffer
   nBytesToRead = min( nBytes, m_nValidBytes );
   if( nBytesToRead > 0 )
   {
      memcpy( pBuffer, &m_pbBuffer[m_iOffset], nBytesToRead );
      if( pnBytesRead != NULL )
      {
         *pnBytesRead += nBytesToRead;
      }
   }

   if( nBytesToRead == nBytes )
   {
      return( S_OK );
   }
   else
   {
      return( hResult );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#ifdef UNIX
#include "include/dlldata.c"
#include "include/imgutil_p.c"
#else
#include "include\dlldata.c"
#include "include\imgutil_p.c"
#endif

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#else
// We have to put something here to keep the compiler from bitching
static int g_foo;
#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\dithers.h ===
#ifndef _DITHERS_H
#define _DITHERS_H

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

typedef struct
{
    int r, g, b;

} ERRBUF;

__inline size_t ErrbufBytes(size_t pels)
{
    return (pels + 2) * sizeof(ERRBUF);
}

///////////////////////////////////////////////////////////////////////////////

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight );

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap,
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, 
   int cy );

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN);

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy);

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN);

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy);

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, 
   int nHeight );

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy);

///////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif // _DITHERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\include\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\dithers.cpp ===
#include "stdafx.h"
#include "dithers.h"

#ifndef _DEBUG
#define INLINE  __inline
#else
#define INLINE
#endif

//-----------------------------------------------------------------------------
// helpers
//-----------------------------------------------------------------------------

const BYTE g_abClamp[] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,
47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,
69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,
90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,
109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,
143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,
194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,
211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,
228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,
245,246,247,248,249,250,251,252,253,254,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255
};

INLINE UINT Clamp8(int z)
{
#ifdef _DEBUG
    UINT t = (z & 0xff00) ? (0xff & ~(z >> 16)) : z;

    if (t != g_abClamp[z + 128])
        DebugBreak();
#endif

    return g_abClamp[z + 128];
}

INLINE WORD rgb555(BYTE r, BYTE g, BYTE b)
{
    return( WORD( ((((WORD)(r) << 5) | (WORD)(g)) << 5) | (WORD)(b) ) );
}

//-----------------------------------------------------------------------------
// Halftoning stuff
//-----------------------------------------------------------------------------
//
// This table is used to halftone from 8 to 5 bpp.  Typically, 16 bit
// halftoning code will map an 8 bit value to a 5 bit value, map it back to
// 8 bits, compute some error, and use a halftone table to adjust the 5 bit
// value for the error.  This array is a concatenation of 8 different 8-to-5
// tables that include the error factoring in their mapping.  It is used with
// the halftoning table below, which gives indices to each of the mapping
// tables within the array.   Given the correct table pointer for a pixel,
// callers can perform a single lookup per color component in this table to get
// a halftoned 5 bit component.
//
#pragma data_seg(".text", "CODE")
BYTE aHT16Data[] =
{
      0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
      5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
      7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
      9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
     11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
     13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
     15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
     17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
     19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
     21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
     23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
     25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
     27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28,
     29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 31,
      0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  3,
      3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,
      5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  7,
      7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,
      9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10, 11,
     11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13,
     13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15,
     15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17,
     17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19,
     19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21,
     21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23,
     23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25,
     25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27,
     27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29,
     29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31,
     31, 31, 31, 31, 31, 31
};
UINT aHT16Heads[4][4] =
{
    262, 256, 261,   0,
    258, 260, 257, 259,
    261,   0, 262, 256,
    257, 259, 258, 260,
};
#pragma data_seg()

INLINE UINT *
Get555HalftoneRow(UINT y)
{
    return aHT16Heads[y % 4];
}

INLINE BYTE *
Get555HalftoneTable(UINT *row, UINT x)
{
    return aHT16Data + row[x % 4];
}

//-----------------------------------------------------------------------------
// Rounding stuff
//-----------------------------------------------------------------------------
//
// round an 8bit value to a 5bit value with good distribution
//
#if 0   // not presently used
#pragma data_seg(".text", "CODE")
BYTE aRound8to5[] = {
      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
      2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,
      4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,
      6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,
      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10,
     10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
     12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
     14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
     16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19,
     19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
     21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23,
     23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
     25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
     27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
     29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
};
#pragma data_seg()
#endif  // not presently used

//
// complement of table above
//
#pragma data_seg(".text", "CODE")
BYTE aRound5to8[] = {
      0,  8, 16, 25, 33, 41, 49, 58, 66, 74, 82, 90, 99,107,115,123,
    132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255,
};
#pragma data_seg()

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void SwapError(ERRBUF **a, ERRBUF **b)
{
    ERRBUF *te;

    te = *a;
    *a = *b;
    *b = te;
}

INLINE void ZeroError(ERRBUF *err, size_t pels)
{
    ZeroMemory(err - 1, ErrbufBytes(pels));
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8()                                              8bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Uses the 16bpp color as a lookup into an inverse mapping
// table to pick the output color for the pixel.  Uses the destination color
// table entry to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8(BYTE *dst, const BYTE *src, const RGBQUAD *colorsIN,
    const RGBQUAD *colorsOUT, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colorsIN + *src;

        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScan8to8( BYTE* pbDest, const BYTE* pbSrc, 
   const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = prgbColors[*pbSrc].rgbRed;
      g = prgbColors[*pbSrc].rgbGreen;
      b = prgbColors[*pbSrc].rgbBlue;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan8to8( pbDest, pbSrc, prgbColors, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

INLINE void DithScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const RGBQUAD* prgbColors, const BYTE* pbMap, ERRBUF* pCurrentError,
   ERRBUF* pNextError, UINT x, UINT xl, UINT y )
{
   BYTE bSrc;
   BYTE bDest;
    UINT* pRow = Get555HalftoneRow( y );

    for(; x < xl; pbSrc++, x++ )
    {
        const RGBQUAD* prgbChosen;
        BYTE* pbTable;
        int r;
        int g;
        int b;

        bSrc = *pbSrc;
        r = Clamp8( (int)bSrc + pCurrentError->r/16 );
        g= Clamp8( (int)bSrc + pCurrentError->g/16 );
        b = Clamp8( (int)bSrc + pCurrentError->b/16 );
        pCurrentError++;

        pbTable = Get555HalftoneTable( pRow, x );
        bDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
         prgbChosen = prgbColors+bDest;
         *pbDest = bDest;
         pbDest++;

        r -= (int)prgbChosen->rgbRed;
        (pNextError+1)->r += r * 1;
        (pNextError-1)->r += r * 3;
        (pNextError)->r += r * 5;
        (pCurrentError)->r += r * 7;

        g -= (int)prgbChosen->rgbGreen;
        (pNextError+1)->g += g * 1;
        (pNextError-1)->g += g * 3;
        (pNextError)->g += g * 5;
        (pCurrentError)->g += g * 7;

        b -= (int)prgbChosen->rgbBlue;
        (pNextError+1)->b += b * 1;
        (pNextError-1)->b += b * 3;
        (pNextError)->b += b * 5;
        (pCurrentError)->b += b * 7;

        pNextError++;
    }
}

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, 
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to8( pbDest, pbSrc, prgbColors, pbMap, pCurrentError, 
           pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE g;

   for (; x < xl; pbSrc++, x++ )
   {
      g = *pbSrc;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[g], pbTable[g], pbTable[g] )];
   }
}

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScanGray8to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8t()                           8bpp to 8bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to8.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8t(BYTE *dst, const BYTE *src,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    BYTE indexTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = indexTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colorsIN + index;
        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8t(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y, indexTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16()                                            8bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Remaps this color to 24bpp to compute and accumulates
// error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colors + *src;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16(dst, src, colors, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16t()                         8bpp to 16bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to16.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16t(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    WORD wColorTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src ++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = wColorTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colors + index;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16t(dst, src, colors, cur_err, nxt_err, x, cx, y,
            wColorTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to8()                                            24bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to8(BYTE *dst, const BYTE *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScan24to8( BYTE* pbDest, const BYTE* pbSrc, 
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow;
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   pRow = Get555HalftoneRow( y );

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = pbSrc[2];
      g = pbSrc[1];
      b = pbSrc[0];

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan24to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to16()                                          24bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Remaps this color to 24bpp to compute and accumulates error for
// neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to16(WORD *dst, const BYTE *src, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to16(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if DBG==1

#ifdef _DEBUG
#undef _DEBUG
#endif

#define _DEBUG
#pragma message( "Debug Build" )
#else
#ifndef UNIX
// IEUNIX -- _ATL_MIN_CRT just includes a new operator new()... which is a royal pain.
// we don't need to try to minimize the CRT anyhow, so just can it
#define _ATL_MIN_CRT
#endif // IEUNIX
#pragma message( "Release Build" )
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ocmm.h>

#ifdef UNIX
#include <ddraw.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\imgutil.cpp ===
// BitmapSurfaces.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      Modify the custom build rule for BitmapSurfaces.idl by adding the following
//      files to the Outputs.  You can select all of the .IDL files by
//      expanding each project and holding Ctrl while clicking on each of them.
//          BitmapSurfaces_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f BitmapSurfacesps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "atlimpl.cpp"
#include <advpub.h>
#include "initguid.h"
#include "imgutil.h"
#include "csnfstrm.h"
#include "cmimeid.h"
#include "cmapmime.h"
#include "cdithtbl.h"
#include "dithers.h"
#include "cdith8.h"
#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP( ObjectMap )
   OBJECT_ENTRY( CLSID_CoSniffStream, CSniffStream )
   OBJECT_ENTRY( CLSID_CoMapMIMEToCLSID, CMapMIMEToCLSID )
#ifndef MINSUPPORT
   OBJECT_ENTRY( CLSID_CoDitherToRGB8, CDitherToRGB8 )
#endif
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitMIMEIdentifier();
        InitDefaultMappings();
#ifndef MINSUPPORT
        CDitherToRGB8::InitTableCache();
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
   {
#ifndef MINSUPPORT
      CDitherToRGB8::CleanupTableCache();
#endif
      CleanupMIMEIdentifier();
      CleanupDefaultMappings();
      _Module.Term();
   }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
   return( _Module.GetClassObject(rclsid, riid, ppv) );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI ie3_DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI ie3_DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}

static HINSTANCE hAdvPackLib;

REGINSTALL GetRegInstallFn(void)
{
    hAdvPackLib = LoadLibraryA("advpack.dll");
    if (!hAdvPackLib)
        return NULL;

    return (REGINSTALL)GetProcAddress(hAdvPackLib, achREGINSTALL);
}

inline void UnloadAdvPack(void)
{
    FreeLibrary(hAdvPackLib);
}

STDAPI ie4_DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    if (pfnReg == NULL)
        return E_FAIL;
        
    // Delete any old registration entries, then add the new ones.
    hr = (*pfnReg)(_Module.GetResourceInstance(), "UnReg", NULL);
    if (SUCCEEDED(hr))
        hr = (*pfnReg)(_Module.GetResourceInstance(), "Reg", NULL);

    UnloadAdvPack();
    
    return hr;
}

STDAPI
ie4_DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    HRESULT hr;
    
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    if (pfnReg == NULL)
        return E_FAIL;

    hr = (*pfnReg)( _Module.GetResourceInstance(), "UnReg", NULL);

    UnloadAdvPack();

    return hr;
}

STDAPI DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllRegisterServer();
    else
        return ie3_DllRegisterServer();
}

STDAPI
DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllUnregisterServer();
    else
        return ie3_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by imgutil.rc
//

#define IDS_COBITMAPSURFACE_DESC        1
#define IDS_COSNIFFSTREAM_DESC          4
#define IDS_COMAPMIMETOCLSID_DESC       5
#define IDS_CODITHERTORGB8_DESC         8


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\imgutil\daytona\makefile.inc ===
MIDL= $(DEVTOOLS)\midl.exe

BitmapSurfaces.h: ..\BitmapSurfaces.idl

.idl.h:
   $(MIDL) $*.idl /h $*.h /tlb $*.tlb

..\imgutil.rc : ..\selfreg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\cpngfilt.cpp ===
#include "stdafx.h"
#include "pngfilt.h"
#include "resource.h"
#include "cpngfilt.h"
#include "scanline.h"
#include <math.h>

#include "pngcrc.cpp"

#undef  DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID( IID_IDirectDrawSurface,		0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,
0x20,0xAF,0x0B,0xE5,0x60 );

#ifdef _DEBUG
static ULONG g_nPNGTraceLevel = 1;
static void _cdecl FakeTrace( LPCTSTR pszFormat, ... )
{
   (void)pszFormat;
}
#define PNGTRACE1 ((g_nPNGTraceLevel >= 1) ? AtlTrace : FakeTrace)
#define PNGTRACE ATLTRACE
#else
#define PNGTRACE1 ATLTRACE
#define PNGTRACE ATLTRACE
#endif

// Gamma correction table for sRGB, assuming a file gamma of 1.0

#define	VIEWING_GAMMA	1.125
#define	DISPLAY_GAMMA	2.2

#define	MAXFBVAL	255

BYTE gamma10[256] = {
      0, 15, 21, 26, 30, 34, 37, 41, 43, 46, 49, 51, 53, 56, 58, 60,
     62, 64, 66, 68, 69, 71, 73, 75, 76, 78, 79, 81, 82, 84, 85, 87,
     88, 90, 91, 92, 94, 95, 96, 98, 99,100,101,103,104,105,106,107,
    109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,135,136,137,138,139,140,
    141,142,143,144,145,145,146,147,148,149,150,151,151,152,153,154,
    155,156,156,157,158,159,160,160,161,162,163,164,164,165,166,167,
    167,168,169,170,170,171,172,173,173,174,175,176,176,177,178,179,
    179,180,181,181,182,183,184,184,185,186,186,187,188,188,189,190,
    190,191,192,192,193,194,194,195,196,196,197,198,198,199,200,200,
    201,202,202,203,203,204,205,205,206,207,207,208,208,209,210,210,
    211,212,212,213,213,214,215,215,216,216,217,218,218,219,219,220,
    221,221,222,222,223,223,224,225,225,226,226,227,228,228,229,229,
    230,230,231,231,232,233,233,234,234,235,235,236,236,237,238,238,
    239,239,240,240,241,241,242,242,243,244,244,245,245,246,246,247,
    247,248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,
};

#ifdef BIG_ENDIAN
#define my_ntohl(x) (x)
inline DWORD endianConverter( DWORD dwSrc )
{
   return( ((dwSrc&0xff)<<24)+((dwSrc&0xff00)<<8)+((dwSrc&0xff0000)>>8)+
      ((dwSrc&0xff000000)>>24) );
}
#else
inline DWORD my_ntohl( DWORD dwSrc )
{
   return( ((dwSrc&0xff)<<24)+((dwSrc&0xff00)<<8)+((dwSrc&0xff0000)>>8)+
      ((dwSrc&0xff000000)>>24) );
}
#endif

void FixByteOrder( PNGCHUNKHEADER* pChunkHeader )
{
   pChunkHeader->nDataLength = my_ntohl( pChunkHeader->nDataLength );
}

void FixByteOrder( PNGIHDRDATA* pIHDR )
{
   pIHDR->nWidth = my_ntohl( pIHDR->nWidth );
   pIHDR->nHeight = my_ntohl( pIHDR->nHeight );
}

void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

/////////////////////////////////////////////////////////////////////////////
//

CPNGFilter::CPNGFilter() :
   m_eInternalState( ISTATE_READFILEHEADER ),
   m_nBytesLeftInCurrentTask( 0 ),
   m_nDataBytesRead( 0 ),
   m_iAppend( 0 ),
   m_pStream( NULL ),
   m_bFinishedIDAT( FALSE ),
   m_nBytesInScanLine( 0 ),
   m_iScanLine( 0 ),
   m_iFirstStaleScanLine( 0 ),
   m_bExpandPixels( FALSE ),
   m_pbScanLine( NULL ),
   m_pbPrevScanLine( NULL ),
   m_pfnCopyScanLine( NULL ),
   m_dwChunksEncountered( 0 ),
   m_iBackgroundIndex( 0 ),
   m_bSurfaceUsesAlpha( FALSE ),
   m_bConvertAlpha( FALSE ),
   m_nFormats( 0 ),
   m_pFormats( NULL ),
   m_nTransparentColors( 0 )
{
   m_rgbBackground.rgbRed = 0;
   m_rgbBackground.rgbGreen = 0;
   m_rgbBackground.rgbBlue = 0;
   m_rgbBackground.rgbReserved = 0;

    for (int i = 0; i < 256; ++i)
        m_abTrans[i] = (BYTE)i;

    memcpy(m_abGamma, m_abTrans, sizeof(m_abTrans));
}

CPNGFilter::~CPNGFilter()
{
   if( m_pFormats != NULL )
   {
      CoTaskMemFree( m_pFormats );
   }
   delete m_pbPrevScanLine;
   delete m_pbScanLine;
}

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray1[1] =
{
   CopyScanLineGray1ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray2[1] =
{
   CopyScanLineGray2ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray4[1] =
{
   CopyScanLineGray4ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray8[1] =
{
   CopyScanLineGray8ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGray16[1] =
{
   CopyScanLineGray16ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGB24[1] =
{
   CopyScanLineRGB24ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGB48[1] =
{
   CopyScanLineRGB48ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex1[1] =
{
   CopyScanLineIndex1ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex2[1] =
{
   CopyScanLineIndex2ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex4[1] =
{
   CopyScanLineIndex4ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineIndex8[1] =
{
   CopyScanLineIndex8ToIndex8
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGrayA16[2] =
{
   CopyScanLineGrayA16ToBGRA32,
   CopyScanLineGrayA16ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineGrayA32[2] =
{
   CopyScanLineGrayA32ToBGRA32,
   CopyScanLineGrayA32ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGBA32[2] =
{
   CopyScanLineRGBA32ToBGRA32,
   CopyScanLineRGBA32ToBGR24
};

const PNGCOPYSCANLINEPROC g_apfnCopyScanLineRGBA64[2] =
{
   CopyScanLineRGBA64ToBGRA32,
   CopyScanLineRGBA64ToBGR24
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineBGR24[1] =
{
    DuplicateScanLineBGR24
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineIndex8[1] =
{
    DuplicateScanLineIndex8
};

const PNGDUPLICATESCANLINEPROC g_apfnDuplicateScanLineAlphaSrc[2] =
{
    DuplicateScanLineARGB32,
    DuplicateScanLineBGR24
};

const GUID g_TargetGuidsForAlphaSrcs[2] =
{
    // BFID_RGBA_32
    { 0x773c9ac0, 0x3274, 0x11d0, { 0xb7, 0x24, 0x00, 0xaa, 0x00, 0x6c, 0x1a, 0x1 } },
    // BFID_RGB_24
    { 0xe436eb7d, 0x524f, 0x11ce, { 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70 } }
};

const PNG_FORMAT_INFO CPNGFilter::s_aFormatInfo[15] =
{
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray1, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray2, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray4, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray8, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineGray16, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineRGB24, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_RGB_24, g_apfnCopyScanLineRGB48, g_apfnDuplicateScanLineBGR24 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex1, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex2, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex4, g_apfnDuplicateScanLineIndex8 },
   { 1, &BFID_INDEXED_RGB_8, g_apfnCopyScanLineIndex8, g_apfnDuplicateScanLineIndex8 },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineGrayA16, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineGrayA32, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineRGBA32, g_apfnDuplicateScanLineAlphaSrc },
   { 2, g_TargetGuidsForAlphaSrcs, g_apfnCopyScanLineRGBA64, g_apfnDuplicateScanLineAlphaSrc }
};

HRESULT CPNGFilter::ChooseDestinationFormat( GUID* pBFID )
{
   ULONG iPossibleFormat;
   ULONG iAcceptableFormat;
   const PNG_FORMAT_INFO* pFormatInfo;
   BOOL bFound;
   ULONG iChosenFormat;

   _ASSERTE( pBFID != NULL );

   *pBFID = GUID_NULL;

   pFormatInfo = &s_aFormatInfo[m_eSrcFormat];

   bFound = FALSE;
   iChosenFormat = 0;
   for( iAcceptableFormat = 0; (iAcceptableFormat < m_nFormats) && !bFound;
      iAcceptableFormat++ )
   {
      for( iPossibleFormat = 0; iPossibleFormat <
         pFormatInfo->nPossibleFormats; iPossibleFormat++ )
      {
         if( IsEqualGUID(m_pFormats[iAcceptableFormat],
             pFormatInfo->pPossibleFormats[iPossibleFormat] ) )
         {
            iChosenFormat = iPossibleFormat;
            bFound = TRUE;
         }
      }
   }
   if( !bFound )
   {
      return( E_FAIL );
   }

   m_pfnCopyScanLine = pFormatInfo->ppfnCopyScanLineProcs[iChosenFormat];
   m_pfnDuplicateScanLine = pFormatInfo->ppfnDuplicateScanLineProcs[iChosenFormat];
   *pBFID = pFormatInfo->pPossibleFormats[iChosenFormat];

   return( S_OK );
}

HRESULT CPNGFilter::LockBits(RECT *prcBounds, DWORD dwLockFlags, void **ppBits, long *pPitch)
{
    HRESULT hResult;
    DDSURFACEDESC   ddsd;

    (dwLockFlags);

    ddsd.dwSize = sizeof(ddsd);
    hResult = m_pDDrawSurface->Lock(prcBounds, &ddsd, DDLOCK_WAIT | DDLOCK_SURFACEMEMORYPTR, NULL);
    if (FAILED(hResult))
        return hResult;

    *ppBits = ddsd.lpSurface;
    *pPitch = ddsd.lPitch;

    return S_OK;
}

HRESULT CPNGFilter::UnlockBits(RECT *prcBounds, void *pBits)
{
    (prcBounds);

    return m_pDDrawSurface->Unlock(pBits);
}


HRESULT CPNGFilter::FireGetSurfaceEvent()
{
    HRESULT hResult;
    GUID bfid;
    CComPtr < IUnknown > pSurface;

    _ASSERTE( m_pEventSink != NULL );
    _ASSERTE( m_pDDrawSurface == NULL );

    m_bConvertAlpha = FALSE;
    m_bSurfaceUsesAlpha = FALSE;

    hResult = ChooseDestinationFormat(&bfid);
    if (FAILED(hResult))
    {
        return(hResult);
    }

    hResult = m_pEventSink->GetSurface(m_pngIHDR.nWidth, m_pngIHDR.nHeight,
        bfid, m_nPasses, IMGDECODE_HINT_TOPDOWN|IMGDECODE_HINT_FULLWIDTH,
        &pSurface);
    if (FAILED(hResult))
    {
        return( hResult);
    }

    hResult = pSurface->QueryInterface(IID_IDirectDrawSurface, (void **)&m_pDDrawSurface);

    if (FAILED(hResult))
        return(hResult);

    return (S_OK);
}

// Send an OnProgress event to the event sink (if it has requested progress
// notifications).
HRESULT CPNGFilter::FireOnProgressEvent()
{
   HRESULT hResult;
   RECT rect;

   if( !(m_dwEvents & IMGDECODE_EVENT_PROGRESS) )
   {
      return( S_OK );
   }

   PNGTRACE1(_T("Pass: %d\n"), m_iPass );

   rect.left = 0;
   rect.top = m_iFirstStaleScanLine;
   rect.right = m_pngIHDR.nWidth;
   rect.bottom = min( m_iScanLine, m_pngIHDR.nHeight );
   hResult = m_pEventSink->OnProgress( &rect, TRUE );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_iFirstStaleScanLine = m_iScanLine;

   return( S_OK );
}


///////////////////////////////////////////////////////////////////////////////
// PNG scan line filtering routines

void CPNGFilter::NoneFilterScanLine()
{
}

void CPNGFilter::SubFilterScanLine()
{
   BYTE* pbByte;
   ULONG iByte;
   ULONG nSrcByte;

   pbByte = m_pbScanLine+1+m_nBPP;
   for( iByte = m_nBPP; iByte < m_nBytesInScanLine; iByte++ )
   {
      nSrcByte = *pbByte;
      nSrcByte += *(pbByte-m_nBPP);
      *pbByte = BYTE( nSrcByte );
      pbByte++;
   }
}

void CPNGFilter::UpFilterScanLine()
{
   ULONG iByte;

   if( m_iScanLineInPass == 0 )
   {
      // Unfiltering the top scan line is a NOP
      return;
   }

   for( iByte = 1; iByte <= m_nBytesInScanLine; iByte++ )
   {
      m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
         m_pbPrevScanLine[iByte] );
   }
}

void CPNGFilter::AverageFilterScanLine()
{
   ULONG iByte;
   ULONG nSum;

   if( m_iScanLineInPass == 0 )
   {
      // No prior scan line.  Skip the first m_nBPP bytes, since they are not
      // affected by the filter
      for( iByte = m_nBPP+1; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
            (m_pbScanLine[iByte-m_nBPP]/2) );
      }
   }
   else
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+
            (m_pbPrevScanLine[iByte]/2) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         nSum = m_pbScanLine[iByte-m_nBPP]+m_pbPrevScanLine[iByte];
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+(nSum/2) );
      }
   }
}

static inline int Abs( int n )
{
   if( n > 0 )
   {
      return( n );
   }
   else
   {
      return( -n );
   }
}

BYTE PaethPredictor( BYTE a, BYTE b, BYTE c )
{
   int p;
   int pa;
   int pb;
   int pc;

   p = int( a )+int( b )-int( c );
   pa = Abs( p-a );
   pb = Abs( p-b );
   pc = Abs( p-c );

   if( (pa <= pb) && (pa <= pc) )
   {
      return( a );
   }
   if( pb <= pc )
   {
      return( b );
   }
   return( c );
}

void CPNGFilter::PaethFilterScanLine()
{
   ULONG iByte;

   if( m_iScanLineInPass == 0 )
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor( 0, 0,
            0 ) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor(
            m_pbScanLine[iByte-m_nBPP], 0, 0 ) );
      }
   }
   else
   {
      for( iByte = 1; iByte <= m_nBPP; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor( 0,
            m_pbPrevScanLine[iByte], 0 ) );
      }
      for( ; iByte <= m_nBytesInScanLine; iByte++ )
      {
         m_pbScanLine[iByte] = BYTE( m_pbScanLine[iByte]+PaethPredictor(
            m_pbScanLine[iByte-m_nBPP], m_pbPrevScanLine[iByte],
            m_pbPrevScanLine[iByte-m_nBPP] ) );
      }
   }
}

// Update a CRC accumulator with new data bytes
DWORD UpdateCRC( DWORD dwInitialCRC, const BYTE* pbData, ULONG nCount )
{
   DWORD dwCRC;
   ULONG iByte;

   dwCRC = dwInitialCRC;
   for( iByte = 0; iByte < nCount; iByte++ )
   {
      dwCRC = g_adwCRCTable[(dwCRC^pbData[iByte])&0xff]^(dwCRC>>8);
   }

   return( dwCRC );
}

HRESULT CPNGFilter::NextState()
{
   switch( m_eInternalState )
   {
   case ISTATE_READFILEHEADER:
      m_eInternalState = ISTATE_READCHUNKHEADER;
      break;

   case ISTATE_READCHUNKHEADER:
      if( m_pngChunkHeader.dwChunkType == PNG_CHUNK_IDAT )
      {
        if (!(m_dwChunksEncountered & CHUNK_BKGD))
            m_eInternalState = ISTATE_CHOOSEBKGD;
        else
            m_eInternalState = ISTATE_READIDATDATA;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKDATA;
      }
      break;

    case ISTATE_CHOOSEBKGD:
        m_eInternalState = ISTATE_READIDATDATA;
        break;

   case ISTATE_READCHUNKDATA:
   
      if (m_bSkipData)
      {
         m_eInternalState = ISTATE_EATDATA;
      }
      else switch( m_pngChunkHeader.dwChunkType )
      {
      case PNG_CHUNK_BKGD:
         m_eInternalState = ISTATE_PROCESSBKGD;
         break;

      case PNG_CHUNK_IHDR:
         m_eInternalState = ISTATE_PROCESSIHDR;
         break;

      case PNG_CHUNK_TRNS:
         m_eInternalState = ISTATE_PROCESSTRNS;
         break;

      case PNG_CHUNK_GAMA:
         m_eInternalState = ISTATE_PROCESSGAMA;
         break;

      case PNG_CHUNK_PLTE:
         m_eInternalState = ISTATE_PROCESSPLTE;
         break;

      case PNG_CHUNK_IEND:
         m_eInternalState = ISTATE_PROCESSIEND;
         break;

      case PNG_CHUNK_IDAT:
         _ASSERT( FALSE );
         // fallthrough
         
      default:
         m_eInternalState = ISTATE_EATDATA;
         break;
      }

      break;

   case ISTATE_PROCESSBKGD:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_PROCESSIHDR:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_PROCESSIEND:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

   case ISTATE_EATDATA:
      if( m_nDataBytesRead != m_pngChunkHeader.nDataLength )
      {
         m_eInternalState = ISTATE_READCHUNKDATA;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKCRC;
      }
      break;

   case ISTATE_READCHUNKCRC:
      if( m_dwChunksEncountered & CHUNK_IEND )
      {
         m_eInternalState = ISTATE_DONE;
      }
      else
      {
         m_eInternalState = ISTATE_READCHUNKHEADER;
      }
      break;

   case ISTATE_READIDATDATA:
      if( m_nDataBytesRead < m_pngChunkHeader.nDataLength )
      {
         m_eInternalState = ISTATE_READIDATDATA;
      }
      else
      {
         _ASSERTE( m_nDataBytesRead == m_pngChunkHeader.nDataLength );
         m_eInternalState = ISTATE_READCHUNKCRC;
      }
      break;

   case ISTATE_PROCESSPLTE:
      m_eInternalState = ISTATE_READCHUNKCRC;
      break;

    case ISTATE_PROCESSTRNS:
        m_eInternalState = ISTATE_READCHUNKCRC;
        break;

    case ISTATE_PROCESSGAMA:
        m_eInternalState = ISTATE_READCHUNKCRC;
        break;

   case ISTATE_DONE:
      m_eInternalState = ISTATE_DONE;
      break;

   default:
      PNGTRACE(_T("Unknown state\n"));
      _ASSERT( FALSE );
      break;
   }

   m_nBytesLeftInCurrentTask = 0;

   return( S_OK );
}

// Process a PNG background color chunk.
HRESULT CPNGFilter::ProcessBKGD()
{
   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE(_T("Missing IHDR\n"));
      return( E_FAIL );
   }
   if( m_dwChunksEncountered & CHUNK_BKGD )
   {
      PNGTRACE(_T("Multiple bKGD chunks\n"));
      return( E_FAIL );
   }
   if( m_dwChunksEncountered & (CHUNK_IDAT|CHUNK_IEND) )
   {
      PNGTRACE(_T("Invalid bKGD placement\n"));
      return( E_FAIL );
   }
   if( m_bPalette && !(m_dwChunksEncountered & CHUNK_PLTE) )
   {
      PNGTRACE(_T("bKGD before PLTE in indexed-color image\n"));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= (CHUNK_BKGD|CHUNK_POSTPLTE);

   switch( m_pngIHDR.bColorType )
   {
   case PNG_COLORTYPE_INDEXED:
      if( m_pngChunkHeader.nDataLength != 1 )
      {
         PNGTRACE(_T("Invalid bKGD size\n"));
         return( E_FAIL );
      }
      m_iBackgroundIndex = m_abData[0];
      if( m_iBackgroundIndex >= m_nColors )
      {
         PNGTRACE(_T("Invalid palette index in bKGD\n"));
         return( E_FAIL );
      }
      break;

   case PNG_COLORTYPE_RGB:
   case PNG_COLORTYPE_RGBA:
      if( m_pngChunkHeader.nDataLength != 6 )
      {
         PNGTRACE(_T("Invalid bKGD size\n"));
         return( E_FAIL );
      }
      if( m_pngIHDR.nBitDepth == 8 )
      {
         m_frgbBackground.fRed = float( m_abData[1]/255.0 );
         m_frgbBackground.fGreen = float( m_abData[3]/255.0 );
         m_frgbBackground.fBlue = float( m_abData[5]/255.0 );
      }
      else
      {
         m_frgbBackground.fRed = float( ((m_abData[0]<<8)+m_abData[1] )/
            65535.0 );
         m_frgbBackground.fGreen = float( ((m_abData[2]<<8)+m_abData[3] )/
            65535.0 );
         m_frgbBackground.fBlue = float( ((m_abData[4]<<8)+m_abData[5] )/
            65535.0 );
      }
      break;

   case PNG_COLORTYPE_GRAY:
   case PNG_COLORTYPE_GRAYA:
      if( m_pngChunkHeader.nDataLength != 2 )
      {
         PNGTRACE(_T("Invalid bKGD size\n"));
         return( E_FAIL );
      }
      m_frgbBackground.fRed = float( ((m_abData[0]<<8)+m_abData[1])&
         ((0x01<<m_pngIHDR.nBitDepth)-1) );
      m_frgbBackground.fRed /= float( (0x01<<m_pngIHDR.nBitDepth)-1 );
      m_frgbBackground.fGreen = m_frgbBackground.fRed;
      m_frgbBackground.fBlue = m_frgbBackground.fRed;
      break;

   default:
      _ASSERT( FALSE );
      break;
   }

   m_rgbBackground.rgbRed = BYTE( m_frgbBackground.fRed*255.0 );
   m_rgbBackground.rgbGreen = BYTE( m_frgbBackground.fGreen*255.0 );
   m_rgbBackground.rgbBlue = BYTE( m_frgbBackground.fBlue*255.0 );
   m_rgbBackground.rgbReserved = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ChooseBKGD()
{
   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE(_T("Missing IHDR\n"));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_BKGD )
   {
      PNGTRACE(_T("Multiple bKGD chunks\n"));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= (CHUNK_BKGD|CHUNK_POSTPLTE);

    // Since the image doesn't specify a background color we have to
    // choose one.  Since the image target isn't known we'll use the
    // button face color for lack of anything better...

    *((DWORD *)&m_rgbBackground) = (GetSysColor(COLOR_BTNFACE) & 0x00FFFFFF);
    m_frgbBackground.fRed = float( m_rgbBackground.rgbRed/255.0 );
    m_frgbBackground.fGreen = float( m_rgbBackground.rgbGreen/255.0 );
    m_frgbBackground.fBlue = float( m_rgbBackground.rgbBlue/255.0 );

   return S_OK;
}

// Get ready to read the image data
HRESULT CPNGFilter::BeginImage()
{
    LPDIRECTDRAWPALETTE pDDPalette;
    PALETTEENTRY        ape[256];
    HRESULT hResult;
    BYTE *pby;
    int i;

    // Nothing to do if there's no palette
    if (!m_bPalette)
        return S_OK;

    if (!(m_dwChunksEncountered & CHUNK_PLTE))
    {
        PNGTRACE(_T("No PLTE chunk found for indexed color image\n"));
        return (E_FAIL);
    }


    // TRICK: This applies gamma to the rgbReserved field as well
    //        but this field is always 0, and gamma correction of
    //        0 is always 0, so this safe.
    pby = (BYTE *)m_argbColors;
    for (i = m_nColors * 4; i ; --i, ++pby)
        *pby = m_abGamma[*pby];

	hResult = m_pDDrawSurface->GetPalette(&pDDPalette);
	if (SUCCEEDED(hResult))
    {
        CopyPaletteEntriesFromColors(ape, m_argbColors, m_nColors);
		pDDPalette->SetEntries(0, 0, m_nColors, ape);
		pDDPalette->Release();
    }
		
    if (m_dwEvents & IMGDECODE_EVENT_PALETTE)
    {
        hResult = m_pEventSink->OnPalette();
        if (FAILED(hResult))
        {
            return (hResult);
        }
    }

   return (S_OK);
}

// Process the PNG end-of-stream chunk
HRESULT CPNGFilter::ProcessIEND()
{
   if( !(m_dwChunksEncountered & CHUNK_LASTIDAT) )
   {
      PNGTRACE(_T("Invalid IEND placement\n"));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= CHUNK_IEND;

   if( m_pngChunkHeader.nDataLength > 0 )
   {
      PNGTRACE(_T("Invalid IEND chunk length\n"));
      return( E_FAIL );
   }

   return( S_OK );
}

HRESULT CPNGFilter::DetermineSourceFormat()
{
   switch( m_pngIHDR.bColorType )
   {
   case PNG_COLORTYPE_RGB:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_RGB_24;
         break;

      case 16:
         m_eSrcFormat = SRC_RGB_48;
         break;

      default:
         PNGTRACE(_T("Invalid bit depth %d for RGB image\n"), 
            m_pngIHDR.nBitDepth );
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*3;
      break;

   case PNG_COLORTYPE_RGBA:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_RGBA_32;
         break;

      case 16:
         m_eSrcFormat = SRC_RGBA_64;
         break;

      default:
         PNGTRACE(_T("Invalid bit depth %d for RGBA image\n"), 
            m_pngIHDR.nBitDepth );
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*4;
      break;

   case PNG_COLORTYPE_INDEXED:
      switch( m_pngIHDR.nBitDepth )
      {
      case 1:
         m_eSrcFormat = SRC_INDEXED_RGB_1;
         break;

      case 2:
         m_eSrcFormat = SRC_INDEXED_RGB_2;
         break;

      case 4:
         m_eSrcFormat = SRC_INDEXED_RGB_4;
         break;

      case 8:
         m_eSrcFormat = SRC_INDEXED_RGB_8;
         break;

      default:
         PNGTRACE(_T("Invalid bit depth %d for indexed-color image\n"),
            m_pngIHDR.nBitDepth );
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth;
      break;

   case PNG_COLORTYPE_GRAY:
      switch( m_pngIHDR.nBitDepth )
      {
      case 1:
         m_eSrcFormat = SRC_GRAY_1;
         break;

      case 2:
         m_eSrcFormat = SRC_GRAY_2;
         break;

      case 4:
         m_eSrcFormat = SRC_GRAY_4;
         break;

      case 8:
         m_eSrcFormat = SRC_GRAY_8;
         break;

      case 16:
         m_eSrcFormat = SRC_GRAY_16;
         break;

      default:
         PNGTRACE(_T("Invalid bit depth %d for grayscale image\n"),
            m_pngIHDR.nBitDepth );
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth;
      break;

   case PNG_COLORTYPE_GRAYA:
      switch( m_pngIHDR.nBitDepth )
      {
      case 8:
         m_eSrcFormat = SRC_GRAYA_16;
         break;

      case 16:
         m_eSrcFormat = SRC_GRAYA_32;
         break;

      default:
         PNGTRACE(_T("Invalid bit depth %d for grayscale/alpha image\n"),
            m_pngIHDR.nBitDepth );
         return( E_FAIL );
         break;
      }
      m_nBitsPerPixel = m_pngIHDR.nBitDepth*2;
      break;

   default:
      PNGTRACE(_T("Invalid color type %d\n"), m_pngIHDR.bColorType );
      return( E_FAIL );
      break;
   }

   return( S_OK );
}

// Process the PNG image header chunk
HRESULT CPNGFilter::ProcessIHDR()
{
   PNGIHDRDATA* pIHDR;
   HRESULT hResult;
   int nError;

   if( m_dwChunksEncountered != 0 )
   {
      PNGTRACE(_T("Multiple IHDR chunks\n"));
      return( E_FAIL );
   }

   m_dwChunksEncountered |= CHUNK_IHDR;

   pIHDR = (PNGIHDRDATA*)m_abData;
   FixByteOrder( pIHDR );
   memcpy( &m_pngIHDR, pIHDR, sizeof( m_pngIHDR ) );

   PNGTRACE1(_T("%dx%dx%d\n"), m_pngIHDR.nWidth, m_pngIHDR.nHeight, 
      m_pngIHDR.nBitDepth );

   if( (m_pngIHDR.nWidth == 0) || (m_pngIHDR.nHeight == 0) )
   {
      PNGTRACE(_T("Invalid image size\n"));
      return( E_FAIL );
   }

   m_bPalette = m_pngIHDR.bColorType & PNG_COLORTYPE_PALETTE_MASK;
   m_bColor = m_pngIHDR.bColorType & PNG_COLORTYPE_COLOR_MASK;
   m_bAlpha = m_pngIHDR.bColorType & PNG_COLORTYPE_ALPHA_MASK;

   hResult = DetermineSourceFormat();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }
   m_nBytesInScanLine = ((m_pngIHDR.nWidth*m_nBitsPerPixel)+7)/8;
   m_nBPP = max( 1, m_nBytesInScanLine/m_pngIHDR.nWidth );

   m_pbPrevScanLine = new BYTE[m_nBytesInScanLine+1];
   if( m_pbPrevScanLine == NULL )
   {
      return( E_OUTOFMEMORY );
   }
   m_pbScanLine = new BYTE[m_nBytesInScanLine+1];
   if( m_pbScanLine == NULL )
   {
      return( E_OUTOFMEMORY );
   }

   switch( m_pngIHDR.bCompressionMethod )
   {
   case PNG_COMPRESSION_DEFLATE32K:
      m_zlibStream.zalloc = NULL;
      m_zlibStream.zfree = NULL;
      m_zlibStream.opaque = NULL;
      nError = inflateInit( &m_zlibStream );
      if( nError != Z_OK )
      {
         return( E_OUTOFMEMORY );
      }
      break;

   default:
      PNGTRACE(_T("Unknown compression method %x\n"),
         m_pngIHDR.bCompressionMethod );
      return( E_FAIL );
      break;
   }
   if( m_pngIHDR.bFilterMethod != PNG_FILTER_ADAPTIVE )
   {
      PNGTRACE(_T("Unknown filter method %x\n"), m_pngIHDR.bFilterMethod );
      return( E_FAIL );
   }

   switch( m_pngIHDR.bInterlaceMethod )
   {
   case PNG_INTERLACE_NONE:
      PNGTRACE1(_T("Image is not interlaced\n"));
      m_nPasses = 1;
      m_pInterlaceInfo = s_aInterlaceInfoNone;
      m_bExpandPixels = FALSE;
      break;

   case PNG_INTERLACE_ADAM7:
      PNGTRACE1(_T("Image is Adam7 interlaced\n"));
      m_nPasses = 7;
      m_pInterlaceInfo = s_aInterlaceInfoAdam7;
      if( m_dwEvents & IMGDECODE_EVENT_PROGRESS )
      {
         m_bExpandPixels = TRUE;
      }
      else
      {
         // Don't bother expanding the pixels if the event sink doesn't care
         // about progress messages.
         m_bExpandPixels = FALSE;
      }
      break;

   default:
      PNGTRACE(_T("Unknown interlace method %d\n"), m_pngIHDR.bInterlaceMethod );
      return( E_FAIL );
      break;
   }
   m_iPass = 0;
   BeginPass( m_iPass );

   if( m_bPalette )
   {
      PNGTRACE1(_T("Palette used\n"));
   }
   if( m_bColor )
   {
      PNGTRACE1(_T("Color used\n"));
   }
   if( m_bAlpha )
   {
      PNGTRACE1(_T("Alpha channel used\n"));
   }

   hResult = FireGetSurfaceEvent();
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ProcessPLTE()
{
   ULONG iColor;
   ULONG iByte;

   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE(_T("Missing IHDR\n"));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_PLTE )
   {
      PNGTRACE(_T("Multiple PLTE chunks\n"));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & (CHUNK_POSTPLTE|CHUNK_IDAT|CHUNK_IEND) )
   {
      PNGTRACE(_T("Invalid PLTE placement\n"));
      return( E_FAIL );
   }

   if( !m_bColor )
   {
      PNGTRACE( _T("Palettes not allowed for grayscale images - ignoring\n" ));
      return( S_OK );
   }

   m_dwChunksEncountered |= CHUNK_PLTE;

   if( m_pngChunkHeader.nDataLength == 0 )
   {
      return( E_FAIL );
   }
   if( m_bPalette )
   {
      // Image requires a palette
      if( m_pngChunkHeader.nDataLength > (1U<<m_pngIHDR.nBitDepth)*3 )
      {
         return( E_FAIL );
      }
   }
   else
   {
      if( m_pngChunkHeader.nDataLength > 256*3 )
      {
         return( E_FAIL );
      }
   }
   if( m_pngChunkHeader.nDataLength%3 != 0 )
   {
      return( E_FAIL );
   }

   m_nColors = m_pngChunkHeader.nDataLength/3;

   iByte = 0;
   for( iColor = 0; iColor < m_nColors; iColor++ )
   {
      m_argbColors[iColor].rgbRed = m_abData[iByte];
      m_argbColors[iColor].rgbGreen = m_abData[iByte+1];
      m_argbColors[iColor].rgbBlue = m_abData[iByte+2];
//      ATLTRACE( "Palette[%x] = (%x, %x, %x)\n", iColor, m_abData[iByte],
//         m_abData[iByte+1], m_abData[iByte+2] );
      iByte += 3;
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::ProcessTRNS()
{
    WORD    *pw = (WORD *)m_abData;
    RGBQUAD trans;
    int     byShiftCnt;
    ULONG   i;
    HRESULT hResult;
    DDCOLORKEY  ddKey;

    // TRNS chunk must precede first IDAT chunk and must follow the
    // PLTE chunk (if any).
    if ((m_dwChunksEncountered & CHUNK_IDAT)
        || (m_bPalette && (~m_dwChunksEncountered & CHUNK_PLTE)))
    {
        PNGTRACE(_T("Invalid TRNS placement\n"));
        return (E_FAIL);
    }

    m_dwChunksEncountered |= CHUNK_TRNS;


    switch (m_pngIHDR.bColorType)
    {
        case PNG_COLORTYPE_RGB:
        case PNG_COLORTYPE_GRAY:
            // ISSUE: we really should preserve the full 16-bit values
            // for proper transparent calculation but our main client,
            // MSHTML, doesn't preserve the RGB values at 16-bit resolution
            // either so it doesn't matter.

            byShiftCnt = (m_eSrcFormat == SRC_RGB_48) ? 8 : 0;
            trans.rgbRed   = (BYTE)(my_ntohl(pw[0]) >> byShiftCnt);
            trans.rgbReserved = 0;

            if (m_pngIHDR.bColorType == PNG_COLORTYPE_GRAY)
            {
                trans.rgbGreen = trans.rgbBlue = trans.rgbRed;
            }
            else
            {
                trans.rgbGreen = (BYTE)(my_ntohl(pw[1]) >> byShiftCnt);
                trans.rgbBlue  = (BYTE)(my_ntohl(pw[2]) >> byShiftCnt);
            }

            m_nTransparentColors = 1;
            m_dwTransKey = *((DWORD *)&trans);
            break;

        case PNG_COLORTYPE_INDEXED:
            // Fill in m_abTrans.  Remember this is filled with
            // the identity map in the constructor...
            for (i = 0; i < m_pngChunkHeader.nDataLength; ++i)
            {
                if (m_abData[i] != 0xff)
                {
                    if (m_nTransparentColors++)
                    {
                        // collapse transparent index to first level seen
                        m_abTrans[i] = (BYTE)m_dwTransKey;
                    }
                    else
                    {
                        // first transparent index seen
                        m_dwTransKey = i;
                        m_abTrans[i] = (BYTE)i;
                    }
                }
            }
            break;

        default:
            PNGTRACE( _T("Color type %d doesn't allow tRNS chunk\n"), m_pngIHDR.bColorType );
            return E_FAIL;
    }

    // Tell the surface what the transparent index is


    ddKey.dwColorSpaceLowValue = m_dwTransKey;
    ddKey.dwColorSpaceHighValue = m_dwTransKey;
    hResult = m_pDDrawSurface->SetColorKey(DDCKEY_SRCBLT, &ddKey);

    return (S_OK);
}

HRESULT CPNGFilter::ProcessGAMA()
{
	double	gbright, gcvideo, file_gamma, max_sample, final_gamma;
	ULONG   ulGamma;
	int     i, iGamma;
	
    // GAMA chunk must precede first IDAT chunk
    if (m_dwChunksEncountered & CHUNK_IDAT)
    {
        PNGTRACE(_T("Invalid GAMA placement\n"));
        return (E_FAIL);
    }

    m_dwChunksEncountered |= CHUNK_GAMA;

    // Get the file gamma and compute table if it's not 1.0

    ulGamma = my_ntohl(*((ULONG *)m_abData));
    max_sample = 255;

    // use our precomputed table if possible

    if (ulGamma == 100000)
    {
        memcpy(m_abGamma, gamma10, sizeof(gamma10));
    }
    else
    {
        file_gamma = ulGamma / 100000.0;

        final_gamma = (VIEWING_GAMMA / (file_gamma * DISPLAY_GAMMA));

	    for (i = 0; i < 256; ++i)
	    {
		    gbright = (double)i / max_sample;
		    gcvideo = pow(gbright, final_gamma);
		    iGamma = (int)(gcvideo * MAXFBVAL + 0.5);
		    m_abGamma[i] = (iGamma > 255) ? (BYTE)255 : (BYTE)iGamma;
	    }
	}

   return (S_OK);
}

HRESULT CPNGFilter::ReadChunkCRC()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = 4;
   }
   pBuffer = LPBYTE( &m_dwChunkCRC )+4-m_nBytesLeftInCurrentTask;
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   m_dwChunkCRC = my_ntohl( m_dwChunkCRC );

   if( m_dwChunkCRC != ~m_dwCRC )
   {
      PNGTRACE(_T("Bad CRC\n"));
      return( E_FAIL );
   }

   if( m_pngChunkHeader.dwChunkType == PNG_CHUNK_IEND )
   {
      PNGTRACE1(_T("Finished IEND chunk\n"));
   }

   return( S_OK );
}

HRESULT CPNGFilter::ReadChunkData()
{
   HRESULT hResult = S_OK;
   ULONG nBytesToRead;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      if( m_pngChunkHeader.nDataLength == 0 )
      {
         return( S_OK );
      }

      m_iAppend = 0;
      m_nDataBytesRead = 0;
      m_nBytesLeftInCurrentTask = m_pngChunkHeader.nDataLength;
   }

   if (m_nBytesLeftInCurrentTask > PNG_BUFFER_SIZE - m_iAppend)
   {
      // We should have already previously decided to skip too-long data
      _ASSERTE(m_bSkipData);
      m_bSkipData = TRUE;
   }

   while (m_nBytesLeftInCurrentTask && hResult == S_OK)
   {
      pBuffer = &m_abData[m_iAppend];
      
      _ASSERTE(!m_nBytesLeftInCurrentTask || m_iAppend < PNG_BUFFER_SIZE);
      
      nBytesToRead = min(PNG_BUFFER_SIZE - m_iAppend, m_nBytesLeftInCurrentTask);
      
      hResult = m_pStream->Read( pBuffer, nBytesToRead,
         &nBytesRead );
      m_nBytesLeftInCurrentTask -= nBytesRead;
      m_nDataBytesRead += nBytesRead;
      m_iAppend += nBytesRead;
      m_dwCRC = UpdateCRC( m_dwCRC, pBuffer, nBytesRead );
      
     // If we're just skipping data, reset starting point
     if (m_bSkipData)
        m_iAppend = 0;
   }
      
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   return( S_OK );
}

const PNG_INTERLACE_INFO CPNGFilter::s_aInterlaceInfoNone[1] =
{
   {
      1, 1, 1, 1, 0, 0,
      { 0, 1, 2, 3, 4, 5, 6, 7 },
      { 0, 1, 2, 3, 4, 5, 6, 7 }
   }
};

const PNG_INTERLACE_INFO CPNGFilter::s_aInterlaceInfoAdam7[7] =
{
   {
      8, 8, 8, 8, 0, 0,
      { 0, 1, 1, 1, 1, 1, 1, 1 },
      { 0, 1, 1, 1, 1, 1, 1, 1 }
   },
   {
      8, 8, 4, 8, 4, 0,
      { 0, 0, 0, 0, 0, 1, 1, 1 },
      { 0, 1, 1, 1, 1, 1, 1, 1 }
   },
   {
      4, 8, 4, 4, 0, 4,
      { 0, 1, 1, 1, 1, 2, 2, 2 },
      { 0, 0, 0, 0, 0, 1, 1, 1 }
   },
   {
      4, 4, 2, 4, 2, 0,
      { 0, 0, 0, 1, 1, 1, 1, 2 },
      { 0, 1, 1, 1, 1, 2, 2, 2 }
   },
   {
      2, 4, 2, 2, 0, 2,
      { 0, 1, 1, 2, 2, 3, 3, 4 },
      { 0, 0, 0, 1, 1, 1, 1, 2 }
   },
   {
      2, 2, 1, 2, 1, 0,
      { 0, 0, 1, 1, 2, 2, 3, 3 },
      { 0, 1, 1, 2, 2, 3, 3, 4 }
   },
   {
      1, 2, 1, 1, 0, 1,
      { 0, 1, 2, 3, 4, 5, 6, 7 },
      { 0, 0, 1, 1, 2, 2, 3, 3 }
   }
};

BOOL CPNGFilter::BeginPass( ULONG iPass )
{
   const PNG_INTERLACE_INFO* pInfo;
   ULONG iRightEdgeOfLastPixel;

   _ASSERTE( iPass < m_nPasses );

   pInfo = &m_pInterlaceInfo[iPass];

   m_nDeltaX = pInfo->nDeltaX;
   m_nDeltaY = pInfo->nDeltaY;
   m_iFirstX = pInfo->iFirstX;
   m_iScanLine = pInfo->iFirstY;
   m_nPixelsInScanLine = ((m_pngIHDR.nWidth/8)*(8/m_nDeltaX))+
      pInfo->anPixelsInPartialBlock[m_pngIHDR.nWidth%8];
   m_nBytesInScanLine = (m_nBitsPerPixel*m_nPixelsInScanLine+7)/8;
   m_nScanLinesInPass = ((m_pngIHDR.nHeight/8)*(8/m_nDeltaY))+
      pInfo->anScanLinesInPartialBlock[m_pngIHDR.nHeight%8];
   m_iScanLineInPass = 0;
   m_iFirstStaleScanLine = 0;
   if( m_bExpandPixels )
   {
      m_nPixelWidth = pInfo->nPixelWidth;
      m_nPixelHeight = pInfo->nPixelHeight;
      iRightEdgeOfLastPixel = m_iFirstX+((m_nPixelsInScanLine-1)*m_nDeltaX)+
         m_nPixelWidth;
      if( iRightEdgeOfLastPixel > m_pngIHDR.nWidth )
      {
         // The last pixel in the scan line is a partial pixel
         m_nPartialPixelWidth = m_nPixelWidth-(iRightEdgeOfLastPixel-
            m_pngIHDR.nWidth);
         m_nFullPixelsInScanLine = m_nPixelsInScanLine-1;
      }
      else
      {
         m_nPartialPixelWidth = 0;
         m_nFullPixelsInScanLine = m_nPixelsInScanLine;
      }
   }
   else
   {
      m_nPixelWidth = 1;
      m_nPixelHeight = 1;
      m_nPartialPixelWidth = 0;
   }

   PNGTRACE1(_T("Pass %d.  %d pixels in scan line\n"), iPass, 
      m_nPixelsInScanLine );

   m_zlibStream.next_out = m_pbScanLine;
   m_zlibStream.avail_out = m_nBytesInScanLine+1;
   if( (m_nPixelsInScanLine == 0) || (m_nScanLinesInPass == 0) )
   {
      return( TRUE );
   }

   return( FALSE );
}

HRESULT CPNGFilter::NextPass()
{
   BOOL bEmpty;

   bEmpty = FALSE;
   do
   {
      m_iPass++;
      if( m_iPass < m_nPasses )
      {
         bEmpty = BeginPass( m_iPass );
      }
   } while( (m_iPass < m_nPasses) && bEmpty );

   if( m_iPass >= m_nPasses )
   {
      return( S_FALSE );
   }

   return( S_OK );
}

HRESULT CPNGFilter::NextScanLine()
{
   HRESULT hResult;
   BYTE* pbTemp;

   _ASSERTE( m_zlibStream.avail_out == 0 );

   m_iScanLine += m_nDeltaY;
   m_iScanLineInPass++;
   if( m_iScanLineInPass >= m_nScanLinesInPass )
   {
      // We're done with this pass
      hResult = FireOnProgressEvent();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }

      hResult = NextPass();

      return( hResult );
   }
   else if( ((m_iScanLine-m_iFirstStaleScanLine)/m_nDeltaY) >= 16 )
   {
      hResult = FireOnProgressEvent();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   pbTemp = m_pbScanLine;
   m_pbScanLine = m_pbPrevScanLine;
   m_pbPrevScanLine = pbTemp;

   m_zlibStream.avail_out = m_nBytesInScanLine+1;
   m_zlibStream.next_out = m_pbScanLine;

   return( S_OK );
}

HRESULT CPNGFilter::ReadIDATData()
{
   HRESULT hResult;
   ULONG nBytesToRead;
   ULONG nBytesRead;
   int nError;

   if( !(m_dwChunksEncountered & CHUNK_IHDR) )
   {
      PNGTRACE(_T("Missing IHDR\n"));
      return( E_FAIL );
   }

   if( m_dwChunksEncountered & CHUNK_LASTIDAT )
   {
      PNGTRACE(_T("Extra IDAT chunk\n"));
      return( E_FAIL );
   }

   if( !(m_dwChunksEncountered & CHUNK_IDAT) )
   {
      // This is the first IDAT chunk.  Initialize the surface.
      hResult = BeginImage();
      if( FAILED( hResult ) )
      {
         return( hResult );
      }
   }

   m_dwChunksEncountered |= CHUNK_IDAT;

   nBytesToRead = min( m_pngChunkHeader.nDataLength-m_nDataBytesRead,
      PNG_BUFFER_SIZE );

   hResult = m_pStream->Read( m_abData, nBytesToRead, &nBytesRead );
   m_nDataBytesRead += nBytesRead;
   m_dwCRC = UpdateCRC( m_dwCRC, m_abData, nBytesRead );
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   case E_PENDING:
      if( nBytesRead == 0 )
      {
         return( E_PENDING );
      }
      break;

   default:
      return( hResult );
      break;
   }

   m_zlibStream.next_in = m_abData;
   m_zlibStream.avail_in = nBytesRead;

   do
   {
      nError = inflate( &m_zlibStream, Z_PARTIAL_FLUSH );
      if( (nError == Z_OK) || (nError == Z_STREAM_END) )
      {
         if( m_zlibStream.avail_out == 0 )
         {
            switch( m_pbScanLine[0] )
            {
            case 0:
               NoneFilterScanLine();
               break;

            case 1:
               SubFilterScanLine();
               break;

            case 2:
               UpFilterScanLine();
               break;

            case 3:
               AverageFilterScanLine();
               break;

            case 4:
               PaethFilterScanLine();
               break;

            default:
               _ASSERT( FALSE );
               break;
            }
            hResult = WriteScanLine();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }

            hResult = NextScanLine();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }
         }
         else
         {
            _ASSERTE( m_zlibStream.avail_in == 0 );
         }
      }
      else
      {
         return( E_FAIL );
      }

      if( nError == Z_STREAM_END )
      {
         if( m_nDataBytesRead < m_pngChunkHeader.nDataLength )
         {
            PNGTRACE(_T("Extra IDAT data\n"));
            return( E_FAIL );
         }
         m_dwChunksEncountered |= CHUNK_LASTIDAT;
         m_bFinishedIDAT = TRUE;
         inflateEnd( &m_zlibStream );

         if( m_dwEvents & IMGDECODE_EVENT_BITSCOMPLETE )
         {
            hResult = m_pEventSink->OnBitsComplete();
            if( FAILED( hResult ) )
            {
               return( hResult );
            }
         }
      }
   } while( (nError == Z_OK) && (m_zlibStream.avail_in > 0) );

   return( S_OK );
}

HRESULT CPNGFilter::ReadChunkHeader()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = sizeof( m_pngChunkHeader );
   }

   pBuffer = LPBYTE( &m_pngChunkHeader )+sizeof( m_pngChunkHeader )-
      m_nBytesLeftInCurrentTask;
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   FixByteOrder( &m_pngChunkHeader );

   m_dwCRC = UpdateCRC( 0xffffffff, LPBYTE( &m_pngChunkHeader.dwChunkType ),
      sizeof( m_pngChunkHeader.dwChunkType ) );

   #ifdef BIG_ENDIAN
      m_pngChunkHeader.dwChunkType = endianConverter(m_pngChunkHeader.dwChunkType);
   #endif

   m_nDataBytesRead = 0;
   m_bSkipData = FALSE;

   PNGTRACE1(_T("Chunk type: %c%c%c%c\n"), m_pngChunkHeader.dwChunkType&0xff,
      (m_pngChunkHeader.dwChunkType>>8)&0xff,
      (m_pngChunkHeader.dwChunkType>>16)&0xff,
      (m_pngChunkHeader.dwChunkType>>24)&0xff );
   PNGTRACE1(_T("Data length: %d\n"), m_pngChunkHeader.nDataLength );

   if( !(m_pngChunkHeader.dwChunkType & PNG_CHUNK_ANCILLARY) )
   {
      switch( m_pngChunkHeader.dwChunkType )
      {
      case PNG_CHUNK_IHDR:
      case PNG_CHUNK_PLTE:
      case PNG_CHUNK_IEND:
      
         // If m_pngChunkHeader.nDataLength > 4096 on an critical non-IDAT chunk,
         // we can't decode it, so fail.
          
         if (m_pngChunkHeader.nDataLength > PNG_BUFFER_SIZE)
         {
            PNGTRACE(_T("Critical chunk too long\n"));
            return( E_FAIL );
         }
            
         break;
         
      case PNG_CHUNK_IDAT:
      
         break;

      default:
         PNGTRACE(_T("Unknown critical chunk\n"));
         return( E_FAIL );
         break;
      }
   }
   else
   {
      // If m_pngChunkHeader.nDataLength > 4096 on an ancillary chunk,
      // set a flag so we discard the data
      
      if (m_pngChunkHeader.nDataLength > PNG_BUFFER_SIZE)
      {
         PNGTRACE(_T("Discarding ancillary chunk that is too long\n"));
         m_bSkipData = TRUE;
      }
   }

   return( S_OK );
}

static const BYTE g_abPNGHeader[8] = { 137, 80, 78, 71, 13, 10, 26, 10 };

HRESULT CPNGFilter::ReadFileHeader()
{
   HRESULT hResult;
   ULONG nBytesRead;
   BYTE* pBuffer;

   if( m_nBytesLeftInCurrentTask == 0 )
   {
      m_nBytesLeftInCurrentTask = 8;
   }

   pBuffer = &m_abData[m_iAppend];
   hResult = m_pStream->Read( pBuffer, m_nBytesLeftInCurrentTask,
      &nBytesRead );
   m_nBytesLeftInCurrentTask -= nBytesRead;
   switch( hResult )
   {
   case S_OK:
      break;

   case S_FALSE:
      return( E_FAIL );
      break;

   default:
      return( hResult );
      break;
   }

   if( memcmp( m_abData, g_abPNGHeader, 8 ) == 0 )
   {
      PNGTRACE1(_T("File is a PNG image\n"));
   }
   else
   {
      PNGTRACE(_T("File is not a PNG image\n"));
      return( E_FAIL );
   }

   m_iAppend = 0;

   return( S_OK );
}

HRESULT CPNGFilter::EatData()
{
   m_iAppend = 0;

   return( S_OK );
}


///////////////////////////////////////////////////////////////////////////////
// IImageDecodeFilter methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPNGFilter::Initialize( IImageDecodeEventSink* pEventSink )
{
   HRESULT hResult;

   if( pEventSink == NULL )
   {
      return( E_INVALIDARG );
   }

   m_pEventSink = pEventSink;

   hResult = m_pEventSink->OnBeginDecode( &m_dwEvents, &m_nFormats,
      &m_pFormats );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   return( S_OK );
}

STDMETHODIMP CPNGFilter::Process( IStream* pStream )
{
   HRESULT hResult;
   BYTE bData;
   ULONG nBytesRead;

   // We have to do this every time.  We don't AddRef, since we don't hold onto
   // the stream.
   m_pStream = pStream;

   do
   {
      switch( m_eInternalState )
      {
      case ISTATE_READFILEHEADER:
         hResult = ReadFileHeader();
         break;

      case ISTATE_READCHUNKHEADER:
         hResult = ReadChunkHeader();
         break;

      case ISTATE_READCHUNKDATA:
         hResult = ReadChunkData();
         break;

      case ISTATE_READIDATDATA:
         hResult = ReadIDATData();
         break;

      case ISTATE_READCHUNKCRC:
         hResult = ReadChunkCRC();
         break;

      case ISTATE_EATDATA:
         hResult = EatData();
         break;

      case ISTATE_PROCESSBKGD:
         hResult = ProcessBKGD();
         break;

        case ISTATE_CHOOSEBKGD:
            hResult = ChooseBKGD();
            break;

        case ISTATE_PROCESSTRNS:
            hResult = ProcessTRNS();
            break;

        case ISTATE_PROCESSGAMA:
            hResult = ProcessGAMA();
            break;

      case ISTATE_PROCESSIEND:
         hResult = ProcessIEND();
         break;

      case ISTATE_PROCESSIHDR:
         hResult = ProcessIHDR();
         break;

      case ISTATE_PROCESSPLTE:
         hResult = ProcessPLTE();
         break;

      case ISTATE_DONE:
         hResult = m_pStream->Read( &bData, 1, &nBytesRead );
         if (hResult == S_OK && nBytesRead == 0)
            hResult = S_FALSE;
         break;

      default:
         PNGTRACE(_T("Unknown state\n"));
         _ASSERT( FALSE );
         hResult = E_UNEXPECTED;
         break;
      }
      if( hResult == S_OK )
      {
         NextState();
      }
   } while( hResult == S_OK );

   m_pStream = NULL;

   return( hResult );
}

STDMETHODIMP CPNGFilter::Terminate( HRESULT hrStatus )
{
   PNGTRACE1(_T("Image decode terminated.  Status: %x\n"), hrStatus );

    if (m_pDDrawSurface != NULL)
    {
        m_pDDrawSurface.Release();
    }

   if( m_pEventSink != NULL )
   {
      m_pEventSink->OnDecodeComplete( hrStatus );
      m_pEventSink.Release();
   }

   return( S_OK );
}

HRESULT CPNGFilter::WriteScanLine()
{
   ULONG nPixelHeight;
   ULONG iScanLine;
   RECT rect;
   HRESULT hResult;
   void* pBits = NULL;
   LONG nPitch;

   nPixelHeight = min( m_nPixelHeight, m_pngIHDR.nHeight-m_iScanLine );
   if (nPixelHeight < 1)
       return S_OK;
   rect.left = m_iFirstX;
   rect.top = m_iScanLine;
   rect.right = m_pngIHDR.nWidth;
   rect.bottom = m_iScanLine+nPixelHeight;
   hResult = LockBits( &rect, SURFACE_LOCK_EXCLUSIVE, &pBits,
      &nPitch );
   if( FAILED( hResult ) )
   {
      return( hResult );
   }

   m_pfnCopyScanLine( pBits, &m_pbScanLine[1], m_nPixelsInScanLine, m_nDeltaX,
      &m_frgbBackground, m_bPalette ? m_abTrans : m_abGamma);
   if( m_bExpandPixels )
   {
      for( iScanLine = 0; iScanLine < nPixelHeight; iScanLine++ )
      {
         m_pfnDuplicateScanLine( pBits, m_nDeltaX, m_nFullPixelsInScanLine,
            m_nPixelWidth, m_nPartialPixelWidth );
      }
   }

   UnlockBits( &rect, pBits );

   return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\pngcrc.cpp ===
static DWORD g_adwCRCTable[256] =
{
   0x0,
   0x77073096,
   0xee0e612c,
   0x990951ba,
   0x76dc419,
   0x706af48f,
   0xe963a535,
   0x9e6495a3,
   0xedb8832,
   0x79dcb8a4,
   0xe0d5e91e,
   0x97d2d988,
   0x9b64c2b,
   0x7eb17cbd,
   0xe7b82d07,
   0x90bf1d91,
   0x1db71064,
   0x6ab020f2,
   0xf3b97148,
   0x84be41de,
   0x1adad47d,
   0x6ddde4eb,
   0xf4d4b551,
   0x83d385c7,
   0x136c9856,
   0x646ba8c0,
   0xfd62f97a,
   0x8a65c9ec,
   0x14015c4f,
   0x63066cd9,
   0xfa0f3d63,
   0x8d080df5,
   0x3b6e20c8,
   0x4c69105e,
   0xd56041e4,
   0xa2677172,
   0x3c03e4d1,
   0x4b04d447,
   0xd20d85fd,
   0xa50ab56b,
   0x35b5a8fa,
   0x42b2986c,
   0xdbbbc9d6,
   0xacbcf940,
   0x32d86ce3,
   0x45df5c75,
   0xdcd60dcf,
   0xabd13d59,
   0x26d930ac,
   0x51de003a,
   0xc8d75180,
   0xbfd06116,
   0x21b4f4b5,
   0x56b3c423,
   0xcfba9599,
   0xb8bda50f,
   0x2802b89e,
   0x5f058808,
   0xc60cd9b2,
   0xb10be924,
   0x2f6f7c87,
   0x58684c11,
   0xc1611dab,
   0xb6662d3d,
   0x76dc4190,
   0x1db7106,
   0x98d220bc,
   0xefd5102a,
   0x71b18589,
   0x6b6b51f,
   0x9fbfe4a5,
   0xe8b8d433,
   0x7807c9a2,
   0xf00f934,
   0x9609a88e,
   0xe10e9818,
   0x7f6a0dbb,
   0x86d3d2d,
   0x91646c97,
   0xe6635c01,
   0x6b6b51f4,
   0x1c6c6162,
   0x856530d8,
   0xf262004e,
   0x6c0695ed,
   0x1b01a57b,
   0x8208f4c1,
   0xf50fc457,
   0x65b0d9c6,
   0x12b7e950,
   0x8bbeb8ea,
   0xfcb9887c,
   0x62dd1ddf,
   0x15da2d49,
   0x8cd37cf3,
   0xfbd44c65,
   0x4db26158,
   0x3ab551ce,
   0xa3bc0074,
   0xd4bb30e2,
   0x4adfa541,
   0x3dd895d7,
   0xa4d1c46d,
   0xd3d6f4fb,
   0x4369e96a,
   0x346ed9fc,
   0xad678846,
   0xda60b8d0,
   0x44042d73,
   0x33031de5,
   0xaa0a4c5f,
   0xdd0d7cc9,
   0x5005713c,
   0x270241aa,
   0xbe0b1010,
   0xc90c2086,
   0x5768b525,
   0x206f85b3,
   0xb966d409,
   0xce61e49f,
   0x5edef90e,
   0x29d9c998,
   0xb0d09822,
   0xc7d7a8b4,
   0x59b33d17,
   0x2eb40d81,
   0xb7bd5c3b,
   0xc0ba6cad,
   0xedb88320,
   0x9abfb3b6,
   0x3b6e20c,
   0x74b1d29a,
   0xead54739,
   0x9dd277af,
   0x4db2615,
   0x73dc1683,
   0xe3630b12,
   0x94643b84,
   0xd6d6a3e,
   0x7a6a5aa8,
   0xe40ecf0b,
   0x9309ff9d,
   0xa00ae27,
   0x7d079eb1,
   0xf00f9344,
   0x8708a3d2,
   0x1e01f268,
   0x6906c2fe,
   0xf762575d,
   0x806567cb,
   0x196c3671,
   0x6e6b06e7,
   0xfed41b76,
   0x89d32be0,
   0x10da7a5a,
   0x67dd4acc,
   0xf9b9df6f,
   0x8ebeeff9,
   0x17b7be43,
   0x60b08ed5,
   0xd6d6a3e8,
   0xa1d1937e,
   0x38d8c2c4,
   0x4fdff252,
   0xd1bb67f1,
   0xa6bc5767,
   0x3fb506dd,
   0x48b2364b,
   0xd80d2bda,
   0xaf0a1b4c,
   0x36034af6,
   0x41047a60,
   0xdf60efc3,
   0xa867df55,
   0x316e8eef,
   0x4669be79,
   0xcb61b38c,
   0xbc66831a,
   0x256fd2a0,
   0x5268e236,
   0xcc0c7795,
   0xbb0b4703,
   0x220216b9,
   0x5505262f,
   0xc5ba3bbe,
   0xb2bd0b28,
   0x2bb45a92,
   0x5cb36a04,
   0xc2d7ffa7,
   0xb5d0cf31,
   0x2cd99e8b,
   0x5bdeae1d,
   0x9b64c2b0,
   0xec63f226,
   0x756aa39c,
   0x26d930a,
   0x9c0906a9,
   0xeb0e363f,
   0x72076785,
   0x5005713,
   0x95bf4a82,
   0xe2b87a14,
   0x7bb12bae,
   0xcb61b38,
   0x92d28e9b,
   0xe5d5be0d,
   0x7cdcefb7,
   0xbdbdf21,
   0x86d3d2d4,
   0xf1d4e242,
   0x68ddb3f8,
   0x1fda836e,
   0x81be16cd,
   0xf6b9265b,
   0x6fb077e1,
   0x18b74777,
   0x88085ae6,
   0xff0f6a70,
   0x66063bca,
   0x11010b5c,
   0x8f659eff,
   0xf862ae69,
   0x616bffd3,
   0x166ccf45,
   0xa00ae278,
   0xd70dd2ee,
   0x4e048354,
   0x3903b3c2,
   0xa7672661,
   0xd06016f7,
   0x4969474d,
   0x3e6e77db,
   0xaed16a4a,
   0xd9d65adc,
   0x40df0b66,
   0x37d83bf0,
   0xa9bcae53,
   0xdebb9ec5,
   0x47b2cf7f,
   0x30b5ffe9,
   0xbdbdf21c,
   0xcabac28a,
   0x53b39330,
   0x24b4a3a6,
   0xbad03605,
   0xcdd70693,
   0x54de5729,
   0x23d967bf,
   0xb3667a2e,
   0xc4614ab8,
   0x5d681b02,
   0x2a6f2b94,
   0xb40bbe37,
   0xc30c8ea1,
   0x5a05df1b,
   0x2d02ef8d
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PNGFilt.rc
//
#define IDS_COPNGFILTER_DESC            1
#define IDR_COPNGFILTER_REG             201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\cpngfilt.h ===
#ifndef UNIX
#pragma pack( push, PNG )
#pragma pack( 1 )
#endif

typedef struct _PNGCHUNKHEADER
{
   ULONG nDataLength;
   DWORD dwChunkType;
} PNGCHUNKHEADER;

typedef struct _PNGIHDRDATA
{
   ULONG nWidth;
   ULONG nHeight;
   BYTE nBitDepth;
   BYTE bColorType;
   BYTE bCompressionMethod;
   BYTE bFilterMethod;
   BYTE bInterlaceMethod;
} PNGIHDRDATA;

#ifndef UNIX
#pragma pack( pop, PNG )
#endif

typedef struct _PNG_INTERLACE_INFO
{
   ULONG nDeltaX;
   ULONG nDeltaY;
   ULONG nPixelWidth;
   ULONG nPixelHeight;
   ULONG iFirstX;
   ULONG iFirstY;
   BYTE anPixelsInPartialBlock[8];
   BYTE anScanLinesInPartialBlock[8];
} PNG_INTERLACE_INFO;

typedef struct _FLOATRGB
{
   float fRed;
   float fGreen;
   float fBlue;
} FLOATRGB;

typedef void (*PNGCOPYSCANLINEPROC)( void* pDest, const void* pSrc, 
   ULONG nPixels, ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, 
   BYTE* pXlate );
typedef void (*PNGDUPLICATESCANLINEPROC)( void* pScanLine, ULONG nDeltaX,
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth );

typedef struct _PNG_FORMAT_INFO
{
   ULONG nPossibleFormats;
   const GUID* pPossibleFormats;
   const PNGCOPYSCANLINEPROC* ppfnCopyScanLineProcs;
   const PNGDUPLICATESCANLINEPROC* ppfnDuplicateScanLineProcs;
} PNG_FORMAT_INFO;

#define PNGCHUNK( a, b, c, d ) \
   (MAKELONG( MAKEWORD( (a), (b) ), MAKEWORD( (c), (d) ) ))

const DWORD PNG_CHUNK_IHDR = PNGCHUNK( 'I', 'H', 'D', 'R' );
const DWORD PNG_CHUNK_IEND = PNGCHUNK( 'I', 'E', 'N', 'D' );
const DWORD PNG_CHUNK_IDAT = PNGCHUNK( 'I', 'D', 'A', 'T' );
const DWORD PNG_CHUNK_PLTE = PNGCHUNK( 'P', 'L', 'T', 'E' );
const DWORD PNG_CHUNK_BKGD = PNGCHUNK( 'b', 'K', 'G', 'D' );
const DWORD PNG_CHUNK_TRNS = PNGCHUNK( 't', 'R', 'N', 'S' );
const DWORD PNG_CHUNK_GAMA = PNGCHUNK( 'g', 'A', 'M', 'A' );

const DWORD PNG_CHUNK_ANCILLARY = 0x00000020;

const BYTE PNG_COMPRESSION_DEFLATE32K = 0;
const BYTE PNG_FILTER_ADAPTIVE = 0;
const BYTE PNG_INTERLACE_NONE = 0;
const BYTE PNG_INTERLACE_ADAM7 = 1;

const ULONG PNG_BUFFER_SIZE = 4096;

const DWORD CHUNK_IHDR = 0x01;
const DWORD CHUNK_PLTE = 0x02;
const DWORD CHUNK_POSTPLTE = 0x04;
const DWORD CHUNK_IDAT = 0x08;
const DWORD CHUNK_LASTIDAT = 0x10;
const DWORD CHUNK_IEND = 0x20;
const DWORD CHUNK_BKGD = 0x40;
const DWORD CHUNK_TRNS = 0x80;
const DWORD CHUNK_GAMA = 0x100;

const BYTE PNG_COLORTYPE_PALETTE_MASK = 0x01;
const BYTE PNG_COLORTYPE_COLOR_MASK = 0x02;
const BYTE PNG_COLORTYPE_ALPHA_MASK = 0x04;
const BYTE PNG_COLORTYPE_INDEXED = PNG_COLORTYPE_PALETTE_MASK|
   PNG_COLORTYPE_COLOR_MASK;
const BYTE PNG_COLORTYPE_RGB = PNG_COLORTYPE_COLOR_MASK;
const BYTE PNG_COLORTYPE_GRAY = 0x00;
const BYTE PNG_COLORTYPE_RGBA = PNG_COLORTYPE_COLOR_MASK|
   PNG_COLORTYPE_ALPHA_MASK;
const BYTE PNG_COLORTYPE_GRAYA = PNG_COLORTYPE_ALPHA_MASK;

class CPNGFilter : 
   public IImageDecodeFilter,
	public CComObjectRoot,
	public CComCoClass< CPNGFilter, &CLSID_CoPNGFilter >
{
public:
	CPNGFilter();
   ~CPNGFilter();

   BEGIN_COM_MAP( CPNGFilter )
	   COM_INTERFACE_ENTRY( IImageDecodeFilter )
   END_COM_MAP()

   DECLARE_NOT_AGGREGATABLE( CPNGFilter )  
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

   DECLARE_REGISTRY( CPNGFilter, _T( "PNGFilter.CoPNGFilter.1" ), 
      _T( "PNGFilter.CoPNGFilter" ), IDS_COPNGFILTER_DESC, THREADFLAGS_BOTH )

//   DECLARE_NO_REGISTRY()

// IImageDecodeFilter
public:
   STDMETHOD( Initialize )( IImageDecodeEventSink* pEventSink );
   STDMETHOD( Process )( IStream* pStream );
   STDMETHOD( Terminate )( HRESULT hrStatus );

protected:
   HRESULT BeginImage();
   HRESULT ChooseDestinationFormat( GUID* pBFID );
   HRESULT DetermineSourceFormat();
   HRESULT EatData();
   HRESULT FireGetSurfaceEvent();
   HRESULT FireOnProgressEvent();
   HRESULT NextState();
   HRESULT OutputBytes( const BYTE* pData, ULONG nBytes );
   HRESULT ChooseBKGD();
   HRESULT ProcessBKGD();
   HRESULT ProcessIDAT();
   HRESULT ProcessIEND();
   HRESULT ProcessIHDR();
   HRESULT ProcessPLTE();
   HRESULT ProcessTRNS();
   HRESULT ProcessGAMA();
   HRESULT ReadChunkHeader();
   HRESULT ReadChunkData();
   HRESULT ReadChunkCRC();
   HRESULT ReadFileHeader();
   HRESULT ReadIDATData();
   HRESULT NextPass();
   HRESULT NextScanLine();
   BOOL BeginPass( ULONG iPass );
   HRESULT WriteScanLine();

    HRESULT LockBits(RECT *prcBounds, DWORD dwLockFlags, void **ppBits, long *pPitch);
    HRESULT UnlockBits(RECT *prcBounds, void *pBits);

   void NoneFilterScanLine();
   void SubFilterScanLine();
   void UpFilterScanLine();
   void AverageFilterScanLine();
   void PaethFilterScanLine();

protected:
   static const PNG_INTERLACE_INFO s_aInterlaceInfoNone[1];
   static const PNG_INTERLACE_INFO s_aInterlaceInfoAdam7[7];
   static const PNG_FORMAT_INFO s_aFormatInfo[15];

protected:
   typedef enum _EInternalState
   {
      ISTATE_READFILEHEADER,
      ISTATE_READCHUNKHEADER,
      ISTATE_READCHUNKDATA,
      ISTATE_READIDATDATA,
      ISTATE_READCHUNKCRC,
      ISTATE_PROCESSIHDR,
      ISTATE_PROCESSIEND,
      ISTATE_PROCESSPLTE,
      ISTATE_PROCESSBKGD,
      ISTATE_PROCESSTRNS,
      ISTATE_PROCESSGAMA,
      ISTATE_CHOOSEBKGD,
      ISTATE_EATDATA,
      ISTATE_DONE
   } EInternalState;
   typedef enum _ESrcFormat
   {
      SRC_GRAY_1,
      SRC_GRAY_2,
      SRC_GRAY_4,
      SRC_GRAY_8,
      SRC_GRAY_16,
      SRC_RGB_24,
      SRC_RGB_48,
      SRC_INDEXED_RGB_1,
      SRC_INDEXED_RGB_2,
      SRC_INDEXED_RGB_4,
      SRC_INDEXED_RGB_8,
      SRC_GRAYA_16,
      SRC_GRAYA_32,
      SRC_RGBA_32,
      SRC_RGBA_64
   } ESrcFormat;

   EInternalState m_eInternalState;  // State of decode state machine
   DWORD m_dwEvents;  // Events the event sink wants to receive
   PNGCOPYSCANLINEPROC m_pfnCopyScanLine;
   PNGDUPLICATESCANLINEPROC m_pfnDuplicateScanLine;
   const PNG_INTERLACE_INFO* m_pInterlaceInfo;
   ULONG m_nFormats;  // Number of formats the event sink supports
   GUID* m_pFormats;  // Formats supported by the event sink
   BOOL m_bPalette;  // Does image use a palette?
   BOOL m_bColor;  // Does image use color?
   BOOL m_bAlpha;  // Does image have an alpha channel
   BOOL m_bSurfaceUsesAlpha;
   BOOL m_bConvertAlpha;
   BOOL m_bSkipData;
   ESrcFormat m_eSrcFormat;  // Source pixel format
   DWORD m_dwCRC;  // CRC accumulator
   DWORD m_dwChunkCRC;  // Stored CRC of current chunk
   ULONG m_nColors;  // Number of colors in palette
   ULONG m_iBackgroundIndex;  // Index of background color
   RGBQUAD m_rgbBackground;  // Background color
   FLOATRGB m_frgbBackground;  // Floating-point background color
   DWORD  m_dwTransKey;      // Transparent color key (RGB or indexed
   ULONG    m_nTransparentColors;   // # transparent indices
   IStream* m_pStream;  // Source stream
   CComPtr< IImageDecodeEventSink > m_pEventSink;  // Event sink
   PNGCHUNKHEADER m_pngChunkHeader;  // Header of current chunk
   PNGIHDRDATA m_pngIHDR;  // IHDR chunk
   DWORD m_dwChunksEncountered;  // CHUNK_* flags for what chunks have been
      // encountered in the image stream so far
   CComPtr< IDirectDrawSurface > m_pDDrawSurface;
   BOOL m_bFinishedIDAT;  // Have we finished the IDAT section?
   ULONG m_nBytesLeftInCurrentTask;  // Bytes remaining before we switch to a
      // new state
   ULONG m_nDataBytesRead;  // Bytes of chunk data read
   ULONG m_iAppend;  // Where to append data in buffer
   BYTE* m_pbScanLine;  // Current decoded scan line (including filter byte)
   BYTE* m_pbPrevScanLine;  // Previous decoded scan line
   ULONG m_iPass;  // Current pass
   ULONG m_nPasses;  // Number of passes
   ULONG m_nBytesInScanLine;  // Number of bytes in one scan line
   ULONG m_nPixelsInScanLine;  // Number of pixels in one scan line
   ULONG m_nBitsPerPixel;  // Bits per pixel in source image
   BOOL m_bExpandPixels;  // Expand interlaced pixels?
   ULONG m_iScanLine;  // Current scan line
   ULONG m_nScanLinesInPass;  // Number of scan lines in current pass
   ULONG m_iScanLineInPass;  // Current scan line in pass
   ULONG m_iFirstStaleScanLine;  // First scan line whose progress has not been
      // reported
   ULONG m_nBPP;  // Bytes per pixel
   ULONG m_nDeltaX;  // Horizontal distance between pixels
   ULONG m_nDeltaY;  // Vertical distance between pixels
   ULONG m_nPixelWidth;  // Width of a pixel
   ULONG m_nPixelHeight;  // Height of a pixel
   ULONG m_iFirstX;  // Horizontal position of first pixel in scan line
   ULONG m_iFirstY;  // Vertical position of first scan line in pass
   ULONG m_nFullPixelsInScanLine;
   ULONG m_nPartialPixelWidth;
   z_stream m_zlibStream;  // ZLib data
   BYTE m_abData[PNG_BUFFER_SIZE];  // Data buffer
   BYTE m_abTrans[256];     // table to collapse multiple transparent indices
   BYTE m_abGamma[256];     // gamma correction table
   RGBQUAD m_argbColors[256];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\scanline.cpp ===
#include "stdafx.h"
#include "pngfilt.h"
#include "resource.h"
#include "cpngfilt.h"
#include "scanline.h"

void DuplicateScanLineARGB32( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bAlpha;
   BYTE bRed;
   BYTE bGreen;
   BYTE bBlue;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bAlpha = pbSrcPixel[4];
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+4;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         pbDestPixel[3] = bAlpha;
         
         pbDestPixel += 4;
      }

      pbSrcPixel += 4*nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bAlpha = pbSrcPixel[3];
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+4;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         pbDestPixel[3] = bAlpha;
      
         pbDestPixel += 4;
      }
   }
}

void DuplicateScanLineBGR24( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bRed;
   BYTE bGreen;
   BYTE bBlue;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+3;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
         
         pbDestPixel += 3;
      }

      pbSrcPixel += 3*nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bRed = pbSrcPixel[2];
      bGreen = pbSrcPixel[1];
      bBlue = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+3;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bBlue;
         pbDestPixel[1] = bGreen;
         pbDestPixel[2] = bRed;
      
         pbDestPixel += 3;
      }
   }
}

void DuplicateScanLineIndex8( void* pScanLine, ULONG nDeltaX, 
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth )
{
   BYTE* pbSrcPixel;
   BYTE* pbDestPixel;
   ULONG iSrcPixel;
   ULONG iDestPixel;
   BYTE bIndex;

   pbSrcPixel = LPBYTE( pScanLine );
   
   for( iSrcPixel = 0; iSrcPixel < nFullPixels; iSrcPixel++ )
   {
      bIndex = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+1;

      for( iDestPixel = 1; iDestPixel < nFullPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bIndex;
         
         pbDestPixel++;
      }

      pbSrcPixel += nDeltaX;
   }

   if( nPartialPixelWidth > 0 )
   {
      bIndex = pbSrcPixel[0];
      pbDestPixel = pbSrcPixel+1;

      for( iDestPixel = 1; iDestPixel < nPartialPixelWidth; iDestPixel++ )
      {
         pbDestPixel[0] = bIndex;
      
         pbDestPixel++;
      }
   }
}

const float RECIP65535 = 1.0f/65535.0f;
const float RECIP255 = 1.0f/255.0f;

void CopyScanLineRGBA64ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrcRed;
   float fSrcGreen;
   float fSrcBlue;
   float fDestRed;
   float fDestGreen;
   float fDestBlue;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = ((pbSrc[6]<<8)+pbSrc[7])*RECIP65535;
      fInverseAlpha = 1.0f-fAlpha;

      fSrcRed = ((pbSrc[0]<<8)+pbSrc[1])*RECIP65535;
      fSrcGreen = ((pbSrc[2]<<8)+pbSrc[3])*RECIP65535;
      fSrcBlue = ((pbSrc[4]<<8)+pbSrc[5])*RECIP65535;

      fDestRed = (fAlpha*fSrcRed)+(fInverseAlpha*pfrgbBackground->fRed);
      fDestGreen = (fAlpha*fSrcGreen)+(fInverseAlpha*pfrgbBackground->fGreen);
      fDestBlue = (fAlpha*fSrcBlue)+(fInverseAlpha*pfrgbBackground->fBlue);

      pbDest[0] = pXlate[BYTE(fDestBlue*255.0f)];
      pbDest[1] = pXlate[BYTE(fDestGreen*255.0f)];
      pbDest[2] = pXlate[BYTE(fDestRed*255.0f)];

      pbSrc += 8;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrcRed;
   float fSrcGreen;
   float fSrcBlue;
   float fDestRed;
   float fDestGreen;
   float fDestBlue;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = pbSrc[3]*RECIP255;
      fInverseAlpha = 1.0f-fAlpha;

      fSrcRed = pbSrc[0]*RECIP255;
      fSrcGreen = pbSrc[1]*RECIP255;
      fSrcBlue = pbSrc[2]*RECIP255;

      fDestRed = (fAlpha*fSrcRed)+(fInverseAlpha*pfrgbBackground->fRed);
      fDestGreen = (fAlpha*fSrcGreen)+(fInverseAlpha*pfrgbBackground->fGreen);
      fDestBlue = (fAlpha*fSrcBlue)+(fInverseAlpha*pfrgbBackground->fBlue);

      pbDest[0] = pXlate[BYTE(fDestBlue*255.0f)];
      pbDest[1] = pXlate[BYTE(fDestGreen*255.0f)];
      pbDest[2] = pXlate[BYTE(fDestRed*255.0f)];

      pbSrc += 4;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrc;
   float fDest;
   BYTE bDest;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = ((pbSrc[2]<<8)+pbSrc[3])*RECIP65535;
      fInverseAlpha = 1.0f-fAlpha;

      fSrc = ((pbSrc[0]<<8)+pbSrc[1])*RECIP65535;

      fDest = (fAlpha*fSrc)+(fInverseAlpha*pfrgbBackground->fRed);
      bDest = pXlate[BYTE(fDest*255.0f)];

      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbSrc += 4;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;
   float fAlpha;
   float fInverseAlpha;
   float fSrc;
   float fDest;
   BYTE bDest;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      fAlpha = pbSrc[1]*RECIP255;
      fInverseAlpha = 1.0f-fAlpha;

      fSrc = pbSrc[0]*RECIP255;

      fDest = (fAlpha*fSrc)+(fInverseAlpha*pfrgbBackground->fRed);
      bDest = pXlate[BYTE(fDest*255.0f)];

      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbSrc += 2;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA64ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[4]];
      pbDest[1] = pXlate[pbSrc[2]];
      pbDest[2] = pXlate[pbSrc[0]];
      pbDest[3] = pbSrc[6]; // alpha not gamma corrected

      pbSrc += 8;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineRGB48ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[4]];
      pbDest[1] = pXlate[pbSrc[2]];
      pbDest[2] = pXlate[pbSrc[0]];

      pbSrc += 6;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineRGBA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[2]];
      pbDest[1] = pXlate[pbSrc[1]];
      pbDest[2] = pXlate[pbSrc[0]];
      pbDest[3] = pbSrc[3]; // alpha not gamma corrected

      pbSrc += 4;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineRGB24ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[2]];
      pbDest[1] = pXlate[pbSrc[1]];
      pbDest[2] = pXlate[pbSrc[0]];

      pbSrc += 3;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      pbDest[3] = pbSrc[2]; // alpha not gamma corrected

      pbSrc += 4;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineGray16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      
      pbSrc += 2;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGrayA16ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      pbDest[3] = pbSrc[1];

      pbSrc += 2;
      pbDest += 4*nDeltaXDest;
   }
}

void CopyScanLineGray8ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      pbDest[1] = pbDest[0];
      pbDest[2] = pbDest[0];
      
      pbSrc++;
      pbDest += 3*nDeltaXDest;
   }
}

void CopyScanLineGray8ToGray8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      
      pbSrc++;
      pbDest += nDeltaXDest;
   }
}

static inline BYTE Expand4To8( ULONG nIntensity )
{
   return( BYTE( nIntensity+(nIntensity<<4) ) );
}

void CopyScanLineGray4ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPair;
   ULONG nPairs;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;
    
   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nPairs = nPixels/2;
   for( iPair = 0; iPair < nPairs; iPair++ )
   {
      bSrc = pbSrc[0];
      bDest = pXlate[BYTE((bSrc & 0xf0) + ((bSrc & 0xf0) >> 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbDest += 3*nDeltaXDest;

      bDest = pXlate[BYTE((bSrc & 0x0f) + ((bSrc & 0x0f) << 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;

      pbDest += 3*nDeltaXDest;
      pbSrc++;
   }

   if( (nPixels%2) > 0 )
   {
      bSrc = pbSrc[0];
      bDest = pXlate[BYTE((bSrc & 0xf0) + ((bSrc & 0xf0) >> 4))];
      pbDest[0] = bDest;
      pbDest[1] = bDest;
      pbDest[2] = bDest;
   }
}

static BYTE g_abExpand2To8[4] = { 0, 85, 170, 255 };

static inline BYTE Expand2To8( ULONG nIntensity )
{
   return( g_abExpand2To8[nIntensity] );
}

void CopyScanLineGray2ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iQuad;
   ULONG nQuads;
   ULONG iPixel;
   ULONG nShift;
   ULONG nExtraPixels;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nQuads = nPixels/4;
   for( iQuad = 0; iQuad < nQuads; iQuad++ )
   {
      bSrc = pbSrc[0];
      nShift = 6;
      for( iPixel = 0; iPixel < 4; iPixel++ )
      {
         bDest = pXlate[Expand2To8((bSrc >> nShift) & 0x03)];
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift -= 2;
         pbDest += 3*nDeltaXDest;
      }

      pbSrc++;
   }

   nExtraPixels = nPixels%4;
   if( nExtraPixels > 0 )
   {
      nShift = 6;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         bDest = pXlate[Expand2To8((bSrc >> nShift) & 0x03)];
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift -= 2;
         pbDest += 3*nDeltaXDest;
      }
   }
}

static BYTE g_abExpand1To8[2] = { 0, 255 };

static inline BYTE Expand1To8( ULONG nIntensity )
{
   return( g_abExpand1To8[nIntensity] );
}

void CopyScanLineGray1ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iOctet;
   ULONG nOctets;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;
   BYTE bDest;

   (void)pfrgbBackground;
    (void)pXlate;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nOctets = nPixels/8;
   for( iOctet = 0; iOctet < nOctets; iOctet++ )
   {
      bSrc = pbSrc[0];
      nShift = 7;
      for( iPixel = 0; iPixel < 8; iPixel++ )
      {
         bDest = Expand1To8( (bSrc>>nShift)&0x01 );
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift--;
         pbDest += 3*nDeltaXDest;
      }
      
      pbSrc++;
   }

   nExtraPixels = nPixels%8;
   if( nExtraPixels > 0 )
   {
      nShift = 7;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         bDest = Expand1To8( (bSrc>>nShift)&0x01 );
         pbDest[0] = bDest;
         pbDest[1] = bDest;
         pbDest[2] = bDest;

         nShift--;
         pbDest += 3*nDeltaXDest;
      }
   }
}

void CopyScanLineIndex8ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPixel;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );

   for( iPixel = 0; iPixel < nPixels; iPixel++ )
   {
      pbDest[0] = pXlate[pbSrc[0]];
      
      pbSrc++;
      pbDest += nDeltaXDest;
   }
}

void CopyScanLineIndex4ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iPair;
   ULONG nPairs;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nPairs = nPixels/2;
   for( iPair = 0; iPair < nPairs; iPair++ )
   {
      bSrc = pbSrc[0];
      pbDest[0] = pXlate[BYTE((bSrc >> 4) & 0x0f)];
      pbDest[nDeltaXDest] = pXlate[BYTE(bSrc & 0x0f)];
      
      pbSrc++;
      pbDest += 2*nDeltaXDest;
   }

   if( (nPixels%2) > 0 )
   {
      pbDest[0] = pXlate[BYTE((pbSrc[0] >> 4) & 0x0f)];
   }
}

void CopyScanLineIndex2ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate )
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iQuad;
   ULONG nQuads;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nQuads = nPixels/4;
   for( iQuad = 0; iQuad < nQuads; iQuad++ )
   {
      bSrc = pbSrc[0];
      pbDest[0] = pXlate[BYTE((bSrc>>6) & 0x03)];
      pbDest[nDeltaXDest] = pXlate[BYTE((bSrc >> 4) & 0x03)];
      pbDest[2*nDeltaXDest] = pXlate[BYTE((bSrc >> 2) & 0x03)];
      pbDest[3*nDeltaXDest] = pXlate[BYTE(bSrc & 0x03)];
      
      pbSrc++;
      pbDest += 4*nDeltaXDest;
   }

   nExtraPixels = nPixels%4;
   if( nExtraPixels > 0 )
   {
      nShift = 6;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc >> nShift) & 0x03)];
         nShift -= 2;
         pbDest += nDeltaXDest;
      }
   }
}

void CopyScanLineIndex1ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE *pXlate)
{
   const BYTE* pbSrc;
   BYTE* pbDest;
   ULONG iOctet;
   ULONG nOctets;
   ULONG nShift;
   ULONG nExtraPixels;
   ULONG iPixel;
   BYTE bSrc;

   (void)pfrgbBackground;

   pbSrc = (const BYTE*)pSrc;
   pbDest = LPBYTE( pDest );
   nOctets = nPixels/8;
   for( iOctet = 0; iOctet < nOctets; iOctet++ )
   {
      bSrc = pbSrc[0];
      nShift = 7;
      for( iPixel = 0; iPixel < 8; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc>>nShift) &0x01)]; 
         nShift--;
         pbDest += nDeltaXDest;
      }
      
      pbSrc++;
   }

   nExtraPixels = nPixels%8;
   if( nExtraPixels > 0 )
   {
      nShift = 7;
      bSrc = pbSrc[0];
      for( iPixel = 0; iPixel < nExtraPixels; iPixel++ )
      {
         pbDest[0] = pXlate[BYTE((bSrc>>nShift) &0x01)]; 
         nShift--;
         pbDest += nDeltaXDest;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\daytona\makefile.inc ===
..\pngfilt.rc : ..\selfreg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\pngfilt.cpp ===
// PNGFilter.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f WMFFilterps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <atlimpl.cpp>
#include "initguid.h"
#include "pngfilt.h"
#include "cpngfilt.h"
#include <advpub.h>

#define IID_DEFINED
#ifdef UNIX
#  include "pngfilt.ic"
#else
#  include "pngfilt_i.c"
#endif

#pragma warning( disable: 4505 )

HRESULT WriteMIMEKeys(LPCTSTR lpszCLSID, LPTSTR lpszMIME, int nBytes, BYTE * pbID);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoPNGFilter, CPNGFilter)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
   {
		_Module.Term();
   }

	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

BYTE byPNGID[] = {   0x08, 0x00, 0x00, 0x00,                    // length
                     0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,   // mask
                     0x89,0x50,0x4E,0x47,0x0D,0x0A,0x1A,0x0A    // data
                   };


STDAPI ie3_DllRegisterServer(void)
{
    HRESULT hr;
	// registers object, typelib and all interfaces in typelib
	hr = _Module.RegisterServer(FALSE);
    if (FAILED(hr))
        return hr;

    hr = WriteMIMEKeys(_T("{A3CCEDF7-2DE2-11D0-86F4-00A0C913F750}"), _T("image/png"), sizeof(byPNGID), byPNGID);
    if (FAILED(hr))
        return hr;

    hr = WriteMIMEKeys(_T("{A3CCEDF7-2DE2-11D0-86F4-00A0C913F750}"), _T("image/x-png"), sizeof(byPNGID), byPNGID);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI ie3_DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

TCHAR szDatabase[] = _T("MIME\\Database\\Content Type\\");
TCHAR szBits[] = _T("Bits");

HRESULT WriteMIMEKeys(LPCTSTR lpszCLSID, LPTSTR lpszMIME, int nBytes, BYTE * pbID)
{
    TCHAR szBuf[MAX_PATH];
    HKEY hkey, hkey2;
    DWORD dw;

    lstrcpy(szBuf, szDatabase);
    lstrcat(szBuf, lpszMIME);

    RegCreateKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, NULL, 0, KEY_WRITE, NULL, &hkey, &dw);
    if (hkey)
    {
        RegSetValueEx(hkey, _T("Image Filter CLSID"), 0, REG_SZ, (LPBYTE)lpszCLSID, lstrlen(lpszCLSID)+1);

        RegCreateKeyEx(hkey, szBits, 0, NULL, 0, KEY_WRITE, NULL, &hkey2, &dw);
        if (hkey2)
        {
            RegSetValueEx(hkey2, _T("0"), 0, REG_BINARY, pbID, nBytes);
            RegCloseKey(hkey2);
        }
        RegCloseKey(hkey);
    }

    return S_OK;
}

static HINSTANCE hAdvPackLib;

REGINSTALL GetRegInstallFn(void)
{
    hAdvPackLib = LoadLibraryA("advpack.dll");
    if (!hAdvPackLib)
		return NULL;

    return (REGINSTALL)GetProcAddress(hAdvPackLib, achREGINSTALL);
}

inline void UnloadAdvPack(void)
{
    FreeLibrary(hAdvPackLib);
}

STDAPI ie4_DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
	HRESULT hr;

	if (pfnReg == NULL)
		return E_FAIL;
		
    // Delete any old registration entries, then add the new ones.
    hr = (*pfnReg)(_Module.GetResourceInstance(), "UnReg", NULL);
    if (SUCCEEDED(hr))
    	hr = (*pfnReg)(_Module.GetResourceInstance(), "Reg", NULL);

    UnloadAdvPack();
	
    return hr;
}

STDAPI
ie4_DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
	HRESULT hr;
	
	if (pfnReg == NULL)
		return E_FAIL;

    hr = (*pfnReg)( _Module.GetResourceInstance(), "UnReg", NULL);

    UnloadAdvPack();

    return hr;
}

STDAPI DllRegisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllRegisterServer();
    else
        return ie3_DllRegisterServer();
}

STDAPI
DllUnregisterServer(void)
{
    REGINSTALL pfnReg = GetRegInstallFn();
    UnloadAdvPack();

    if (pfnReg)
        return ie4_DllUnregisterServer();
    else
        return ie3_DllUnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\scanline.h ===
void DuplicateScanLineARGB32( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth );
void DuplicateScanLineBGR24( void* pScanLine, ULONG nDeltaX, ULONG nFullPixels, 
   ULONG nFullPixelWidth, ULONG nPartialPixelWidth );
void DuplicateScanLineIndex8( void* pScanLine, ULONG nDeltaX, 
   ULONG nFullPixels, ULONG nFullPixelWidth, ULONG nPartialPixelWidth );

void CopyScanLineRGBA64ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGBA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA32ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineRGBA64ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGB48ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGBA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineRGB24ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineGrayA32ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray16ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGrayA16ToBGRA32( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray8ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray8ToGray8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray4ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray2ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineGray1ToBGR24( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );

void CopyScanLineIndex8ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex4ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex2ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
void CopyScanLineIndex1ToIndex8( void* pDest, const void* pSrc, ULONG nPixels,
   ULONG nDeltaXDest, const FLOATRGB* pfrgbBackground, BYTE* pXlate );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef UNIX
#define _ATL_MIN_CRT
#endif

#define _ATL_NO_FLTUSED
#define _MERGE_PROXYSTUB
#define USE_IERT

#if DBG
#if !defined(_DEBUG)
#define _DEBUG
#endif /* !_DEBUG */
#define _ATL_NO_DEBUG_CRT   // Don't use ATL CRT stuff.  As a result, we need to define our own ASSERTE per altbase.h

#define _ASSERTE(expr) \
{ \
    if(!(expr)) \
    { \
        TCHAR sz[256]; \
        wsprintf(sz, TEXT("ASSERT PNGFILT: %s %d %s\n"), __FILE__, __LINE__, TEXT(#expr)); \
        OutputDebugString(sz); \
        DebugBreak(); \
    } \
} \

#define _ASSERT(expr) \
{ \
    if(!(expr)) \
    { \
        TCHAR sz[256]; \
        wsprintf(sz, TEXT("ASSERT PNGFILT: %s %d\n"), __FILE__, __LINE__); \
        OutputDebugString(sz); \
        DebugBreak(); \
    } \
} \

#else
#define _ASSERTE(expr) ((void)0)
#define _ASSERT(expr) ((void)0)
#endif

#include <ddraw.h>
#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"

#include "imgutil.h"

extern "C" {
#ifdef UNIX
#  include "zlib.h"
#else
   // zlib is centralized in root/public/internal/base/inc
#  include "zlib.h"
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\imgfilt\pngfilt\include\makefile.inc ===
MIDL= midl.exe

.idl.h:
   $(MIDL) $? /h $(*B).H /tlb ..\Daytona\$(O)\$(*B).tlb /I$(INCLUDES) /iid $(*B).ic

.SUFFIXES: .idl .h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\base.cxx ===
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       base.cxx
//
//  Contents:   CBase implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include "typenav.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

// This files is generated from the pdlparse /G to produce the table of handlers
// and the handler functions themselves.
#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_NCACHE_HXX_
#define X_NCACHE_HXX_
#include "ncache.hxx"
#endif

// Include headers from that PDLParser generated for DISPIDs and IHTMLDocument2
#include "document.h"
#include "window.h"

#pragma warning(disable: 4189)  /* local variable is initialized but not referenced */
#pragma warning(disable: 4701)  /* local variable may be used without having been initialized */
#include <funcsig.cxx>

EXTERN_C const GUID CLSID_HTMLWindow2;

#ifdef COMPLUS_SHIM
#include <funcND.cpp>

#endif	// COMPLUS_SHIM

#pragma warning(default: 4701)
#pragma warning(default: 4189)

DeclareTag(tagOleAutomation, "OleAuto", "Enable OLE automation Invoke");
DeclareTag(tagInvokeTrace, "OleAuto", "Trace custom invoke calls (slow...)");
DeclareTag(tagDisableLockAR, "Lock", "Disable AddRef/Release in locks")

PerfDbgExtern(tagPerfWatch)

MtDefine(CFunctionPointer, ObjectModel, "CFunctionPointer")
MtDefine(CBaseFireEventAry_pv, Locals, "CBase::FireEvent stack ptr array")
MtDefine(CBaseFireTypeAry_pv, Locals, "CBase::FireType stack data array")
MtDefine(CBaseFirePropertyNotify_pv, Locals, "CBase::FirePropertyNotify ptr array")
MtDefine(CDispParams, ObjectModel, "CDispParms")
MtDefine(CDispParams_rgvarg, CDispParams, "CDispParams::rgvarg")
MtDefine(CDispParams_rgdispidNamedArgs, CDispParams, "CDispParams::rgdispidNamedArgs")

const IID * const g_apIID_IDispatchEx[] = { &IID_IDispatchEx, &IID_IDispatch, NULL };
extern BOOL g_fInVizAct2000;


BEGIN_TEAROFF_TABLE(CBase, IDispatchEx)
    //  IDispatch methods
    TEAROFF_METHOD(CBase, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(CBase, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(CBase, GetIDsOfNames, getidsofnames, (REFIID riid,
                                   LPOLESTR *prgpsz,
                                   UINT cpsz,
                                   LCID lcid,
                                   DISPID *prgid))
    TEAROFF_METHOD(CBase, Invoke, invoke, (DISPID dispidMember,
                            REFIID riid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS * pdispparams,
                            VARIANT * pvarResult,
                            EXCEPINFO * pexcepinfo,
                            UINT * puArgErr))

    TEAROFF_METHOD(CBase, GetDispID, getdispid, (BSTR bstrName,
                               DWORD grfdex,
                               DISPID *pid))

    TEAROFF_METHOD(CBase, InvokeEx, invokeex, (DISPID id,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdp,
                        VARIANT *pvarRes,
                        EXCEPINFO *pei,
                        IServiceProvider *pSrvProvider)) 
            
    TEAROFF_METHOD(CBase, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(CBase, DeleteMemberByDispID, deletememberbydispid, (DISPID id))    
    TEAROFF_METHOD(CBase, GetMemberProperties, getmemberproperties, (DISPID id,
                                         DWORD grfdexFetch,
                                         DWORD *pgrfdex))
    TEAROFF_METHOD(CBase, GetMemberName, getmembername, (DISPID id,
                                   BSTR *pbstrName))
    TEAROFF_METHOD(CBase, GetNextDispID, getnextdispid, (DWORD grfdex,
                                   DISPID id,
                                   DISPID *pid))
    TEAROFF_METHOD(CBase, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CBase, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CBase, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CBase, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CBase, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CBase, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, ISupportErrorInfo)
    TEAROFF_METHOD(CBase, InterfaceSupportsErrorInfo, interfacesupportserrorinfo, (REFIID iid))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, IOleCommandTarget)
    TEAROFF_METHOD(CBase, QueryStatus, querystatus, (GUID * pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT * pcmdtext))
    TEAROFF_METHOD(CBase, Exec, exec, (GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG * pvarargIn, VARIANTARG * pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CBase, ISpecifyPropertyPages)
    TEAROFF_METHOD(CBase, GetPages, getpages, (CAUUID * pPages))
END_TEAROFF_TABLE()


BEGIN_TEAROFF_TABLE(CBase, IObjectIdentity)
    TEAROFF_METHOD(CBase, IsEqualObject, isequalobject, (IUnknown*))
END_TEAROFF_TABLE()


// NOTE: Tearoff table for CFunctionPointer IDispatchEx located in types.hdl
// is included in element.cxx for other tearoff tables.

HRESULT
CFunctionPointer::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);

HRESULT
CFunctionPointer::InvokeEx(DISPID id,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pdp,
                           VARIANT *pvarRes,
                           EXCEPINFO *pei,
                           IServiceProvider *pSrvProvider)
{
    HRESULT hr = S_OK;
    COmWindowProxy *pWindow = _pThis->IsPassivated() ? NULL : _pThis->Proxy();

    if (pSrvProvider && pWindow)
    {
        IDispatch *pCaller = NULL;
        hr = THR(GetCallerIDispatch(pSrvProvider, &pCaller));
        if (FAILED(hr))
        {            
            goto Cleanup;
        }

        if (!pCaller || !pWindow->AccessAllowed(pCaller))
            hr = E_ACCESSDENIED;

        ReleaseInterface(pCaller);
    }
    
    if (hr)
    {
        goto Cleanup;
    }

    // Value property on the function object returns the name of the function.
    if (id == DISPID_VALUE && !(wFlags & DISPATCH_METHOD))
    {
        TCHAR       pchFuncName[255];

        if (pvarRes)
        {
            PROPERTYDESC   *pDesc;
            WORD            wEntry;
            WORD            wIIDIndex;

            V_VT(pvarRes) = VT_BSTR;

            hr = _pThis->FindPropDescFromDispID(_dispid, (PROPERTYDESC **)&pDesc, &wEntry, &wIIDIndex);
            if (!hr)
            {
                Format(0, &pchFuncName, 255, _T("\nfunction <0s>() {\n    [native code]\n}\n"),
                       pDesc->pstrExposedName ? pDesc->pstrExposedName :
                                                pDesc->pstrName);
                if (!hr)
                {
                    hr = FormsAllocString(pchFuncName, &V_BSTR(pvarRes));
                }
            }

            // Any error return null string.
            if (hr)
                V_BSTR(pvarRes) = NULL;
        }

        hr = S_OK;
    }
    else
    {
        hr = _pThis->InvokeEx(_dispid, lcid, wFlags, pdp, pvarRes, pei, pSrvProvider);
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CDispParams::Create, public
//
//  Synopsis:   Allocated argument and named argument arrays.
//              Initial values are VT_NULL for argument array
//              and DISPID_UNKNOWN for named argument array.
//
//----------------------------------------------------------------
HRESULT
CDispParams::Create (DISPPARAMS *pOrgDispParams)
{
    HRESULT     hr = S_OK;
    UINT        i;

    // Nothing should exist yet.
    if (rgvarg || rgdispidNamedArgs)
    {
        hr = E_FAIL;
        goto Error;
    }

    if (cArgs + cNamedArgs)
    {
        rgvarg = new(Mt(CDispParams_rgvarg)) VARIANTARG[cArgs + cNamedArgs];
        if (!rgvarg)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        // cArgs is now total count of args including named args.
        cArgs = cArgs + cNamedArgs;

        // Initialize all parameters to VT_NULL.
        for (i = 0; i < cArgs; i++)
        {
            rgvarg[i].vt = VT_NULL;
        }

        // Any arguments to copy over?
        if (pOrgDispParams->cArgs)
        {
            if (cArgs >= pOrgDispParams->cArgs)
            {
                UINT    iStartIndex;

                iStartIndex = cArgs - pOrgDispParams->cArgs;

                if (cArgs >= iStartIndex + pOrgDispParams->cArgs)
                {
                    memcpy(&rgvarg[iStartIndex],
                           pOrgDispParams->rgvarg,
                           sizeof(VARIANTARG) * pOrgDispParams->cArgs);
                }
            }
            else
            {
                hr = E_UNEXPECTED;
                goto Cleanup;
            }
        }

        if (cNamedArgs)
        {
            rgdispidNamedArgs = new(Mt(CDispParams_rgdispidNamedArgs)) DISPID[cNamedArgs];
            if (!rgdispidNamedArgs)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            // Initialize all named args to the unknown dispid.
            for (i = 0; i < cNamedArgs; i++)
            {
                rgdispidNamedArgs[i] = DISPID_UNKNOWN;
            }

            if (pOrgDispParams->cNamedArgs)
            {
                if (cNamedArgs >= pOrgDispParams->cNamedArgs)
                {
                    UINT    iStartIndex;

                    iStartIndex = cNamedArgs - pOrgDispParams->cNamedArgs;
                    if (cNamedArgs >= (iStartIndex + pOrgDispParams->cNamedArgs))
                    {
                        memcpy(&rgdispidNamedArgs[iStartIndex],
                               pOrgDispParams->rgdispidNamedArgs,
                               sizeof(VARIANTARG) * pOrgDispParams->cNamedArgs);

                    }
                }
                else
                {
                    hr = E_UNEXPECTED;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    delete [] rgvarg;
    delete [] rgdispidNamedArgs;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CDispParams::MoveArgsToDispParams, public
//
//  Synopsis:   Move arguments from arguments array to pOutDispParams.
//              Notice, I said move not copy so both this
//              object and the pOutDispParams hold the identical
//              VARIANTS.  So be careful to only release these
//              variants ONCE.  The fFromEnd parameter specifies
//              how the arguments are moved from our rgvar array.
//
//----------------------------------------------------------------
HRESULT
CDispParams::MoveArgsToDispParams (DISPPARAMS *pOutDispParams, UINT cNumArgs, BOOL fFromEnd /*= TRUE*/)
{
    HRESULT hr = S_OK;
    UINT     iStartIndex;

    if (rgvarg && cNumArgs)
    {
        if (cArgs >= cNumArgs && pOutDispParams->cArgs >= cNumArgs)
        {
            iStartIndex = fFromEnd ? cArgs - cNumArgs : 0;

            memcpy(pOutDispParams->rgvarg,
                   &rgvarg[iStartIndex],
                   sizeof(VARIANTARG) * cNumArgs);
            goto Cleanup;
        }

        hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDispParams::ReleaseVariants, public
//
//  Synopsis:   Release any variants in out arguments array.
//              Again, if the values were moved (exist in 2
//              places) be careful you may have just screwed
//              yourself.
//
//----------------------------------------------------------------
void
CDispParams::ReleaseVariants ()
{
    for (UINT i = 0; i < cArgs; i++)
        VariantClear(rgvarg + i);
}


//+---------------------------------------------------------------
//
//  Member:     CBaseCF::CreateInstance, public
//
//  Synopsis:   Method of IClassFactory interface.
//
//----------------------------------------------------------------

STDMETHODIMP
CBaseCF::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID iid,
    void **ppv)
{
    HRESULT     hr;                         
    CBase       *pBase  = NULL;
    IUnknown    *pUnk;

    CEnsureThreadState ets;
    hr = ets._hr;
    if (FAILED(hr))
        goto Error;

    if (pUnkOuter && iid != IID_IUnknown)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Initialize the class
    // (Ensure only one thread performs initialization)

    if (_pfnInitClass)
    {
        LOCK_GLOBALS;

        if (_pfnInitClass)
        {
            hr = (*_pfnInitClass)();
            if (hr)
                goto Error;

            _pfnInitClass = NULL;
        }
    }

    // Create the object in two steps.  The first
    // step calls the constructor.

    pBase = (*_pfnCreate)(pUnkOuter);
    if (!pBase)
        goto MemoryError;

    // Check whether aggregation is supported by the object.

    if (pUnkOuter && pBase->PunkOuter() != pUnkOuter)
    {
        hr = CLASS_E_NOAGGREGATION;
        goto Error;
    }

    // Call the second step initialization.

    hr = pBase->Init();
    if (hr)
        goto Error;

    pUnk = pBase->PunkInner();

    if (pUnkOuter)
    {
        *ppv = pUnk;
    }
    else
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();
    }

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    *ppv = NULL;
    if (pBase)
        pBase->PrivateRelease();
    goto Cleanup;
}

//+---------------------------------------------------------------
//
//  Member:     CBaseLockCF::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface.
//             
//              Allows client to lock thread state.
//
//----------------------------------------------------------------

STDMETHODIMP
CBaseLockCF::LockServer (BOOL fLock)
{
    HRESULT hr;

#ifdef OBJCNTCHK
    DWORD dwObjCnt;
#endif

    if (fLock)
    {
        CEnsureThreadState ets;
        hr = ets._hr;
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        TLS(dll.cLockServer) += 1;
        IncrementObjectCount(&dwObjCnt);
    }
    else
    {
        THREADSTATE * pts = GetThreadState();
#ifdef OBJCNTCHK
        dwObjCnt = GetCurrentThreadId();

        if (!pts)
        {
#if DBG==1
            AssertSz(0, "CBaseLockCF::LockServer(FALSE) called but there is no thread state");
#else
            F3DebugBreak();
#endif
            hr = E_FAIL;
        }
        else if (pts->dll.cLockServer <= 0)
        {
#if DBG==1
            AssertSz(0, "CBaseLockCF::LockServer(FALSE) called too many times on this thread");
#else
            F3DebugBreak();
#endif
            hr = E_FAIL;
        }
        else
#endif
        {
            hr = S_OK;
            if (pts)
            {
                (pts->dll.cLockServer) -= 1;
                DecrementObjectCount(&dwObjCnt);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CBase::CBase, public
//
//  Synopsis:   Constructor.
//
//----------------------------------------------------------------

#if DBG == 1
ULONG CBase::s_ulLastSSN = 0;
#endif

CBase::CBase()
{
    _pAA = NULL;

    IncrementSecondaryObjectCount( 0 );
    _ulRefs = 1;
    _ulAllRefsAndFlags = 1 << BRF_FLAGS_SHIFT;

#if DBG == 1
    _ulSSN = ++s_ulLastSSN;
    MemSetName((this, "SSN=%d", _ulSSN));
#endif
#ifdef OBJCNTCHK
    _dwTidDbg = GetCurrentThreadId();
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CBaseCheckThread
//
//  Synopsis:   Verifies that the current thread is the same as the one this
//              object was created on.
//
//----------------------------------------------------------------------------

#ifdef OBJCNTCHK

void
CBase::CBaseCheckThread()
{
    if (_dwTidDbg != GetCurrentThreadId())
    {
        char ach[512];
        wsprintfA(ach, "Attempt to access CBase object on the wrong thread.  The object was "
                 "created on thread 0x%08lX; attemping access on thread 0x%08lX.",
                 _dwTidDbg, GetCurrentThreadId());
#if DBG==1
        AssertSz(0, ach);
#else
        F3DebugBreak();
#endif
    }
}

#endif

//+---------------------------------------------------------------------------
//
//  Member:     CBase::Init 
//
//  Synopsis:   Nothing happens.
//
//----------------------------------------------------------------------------

HRESULT
CBase::Init()
{
    //
    // Assert that the cpi classdesc is setup correctly.  It should either
    // be NULL or have at least two entries.  The second entry can be
    // CPI_ENTRY_NULL.
    //

    Assert(!BaseDesc()->_pcpi || BaseDesc()->_pcpi[0].piid);
            
    return S_OK;
}

CBase::~CBase()
{
    CBaseCheckThread();

    Assert("Ref count messed up in derived dtor?" &&
            (GetRefs()       == ULREF_IN_DESTRUCTOR || GetRefs()       == 1) &&
            (GetObjectRefs() == ULREF_IN_DESTRUCTOR || GetObjectRefs() == 1));

    Assert(!IsPassivating() && IsPassivated() && IsDestructing() || GetRefs() == 1 && GetObjectRefs() == 1);

    Assert(_pAA == NULL);

    Assert( ! GWHasPostedMethod( this ) );

    DecrementSecondaryObjectCount(0);
}


//+---------------------------------------------------------------
//
//  Member:     CBase::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//---------------------------------------------------------------

void
CBase::Passivate()
{
    CBaseCheckThread();

    Assert("CBase::Passivate called unexpectedly or refcnt "
            "messed up in derived Passivate" &&
            (GetObjectRefs() == ULREF_IN_DESTRUCTOR || GetRefs() == 1));
    Assert( IsPassivating() && !IsPassivated() && !IsDestructing() || GetRefs() == 1 && GetObjectRefs() == 1 );

    //
    // The attr array destructor will free up any stuff left inside it.
    // This includes anyone sinking events or prop notifies from us.
    //
    // WARNING!!!  Be very careful to not delete the _pAA anywhere but
    // here - CStyle and its children do not manage their AAs, so _pAA
    // is changed to NULL in their Passivate() (before CBase::Passivate()
    // is called).  If you want _pAA to be destroyed elsewhere, consider
    // the CStyle case carefully.  -CWilso
    //
    
    delete _pAA;
    _pAA = NULL;

    // Mark that we got to this point.
    _ulAllRefsAndFlags |= BRF_PASSIVATED;
}

//+---------------------------------------------------------------
//
//  member: CBase ::IsEqualObject
//
//  synopsis : default IObjectIdentity implementation.
//
//----------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CBase::IsEqualObject(IUnknown * pUnk)
{
    HRESULT    hr = E_POINTER;
    IUnknown * pUnkThis = NULL;
    IUnknown * pUnkTarget=NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IUnknown, (void**)&pUnkThis));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IUnknown, (void**)&pUnkTarget));
    if (hr)
        goto Cleanup;

    hr = (pUnkTarget == pUnkThis) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pUnkThis);
    ReleaseInterface(pUnkTarget);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateQueryInterface, IPrivateUnknown
//
//---------------------------------------------------------------

HRESULT CBase::PrivateQueryInterface(REFIID iid, void **ppvObj)
{
#if DBG==1
    // If we ever get to CBase::PrivateQueryInterface with an IID of one of the
    // non-stacked interfaces then the most derived class needs to handle this
    // IID in it's PrivateQueryInterface.
    for (int i = 0; i++; i < MAX_IIDS)
    {
        if (IsEqualIID(iid, *(_IIDTable[i])))
            break;
    }            

    Assert("Non stack interface not handled in PrivateQueryInterface" && DispNonDualDIID(iid) || i < MAX_IIDS); 
#endif

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


#if DBG == 1
BOOL        g_fDisableBaseTrace;
BOOL        g_fDisableBaseSubTrace;
CBase *     g_pBaseTrace;
CBase *     g_pSubBaseTrace;
ULONG       g_ulSSNTrace = 0xFFFFFFFF;
ULONG       g_ulSSNSubTrace = 0xFFFFFFFF;
#endif


//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateAddRef, IPrivateUnknown
//
//---------------------------------------------------------------

#if DBG==1 || defined(OBJCNTCHK)
ULONG CBase::PrivateAddRef()
{
    CBaseCheckThread();

    Assert("CBase::PrivateAddRef called after CBase::Passivate." &&
            _ulRefs != 0);

    _ulRefs += 1;

#if DBG==1
    if (!g_fDisableBaseTrace && (this == g_pBaseTrace || _ulSSN == g_ulSSNTrace))
    {
        TraceTag((0, "base %x AR %d", this, _ulRefs));
        TraceCallers(0, 0, 12);
    }

    return _ulRefs;
#else
    return 0;
#endif
}
#endif

//+---------------------------------------------------------------
//
//  Member:     CBase::PrivateRelease, IPrivateUnknown
//
//---------------------------------------------------------------

ULONG CBase::PrivateRelease()
{
    CBaseCheckThread();

    ULONG ulRefs = --_ulRefs;

#if DBG==1
    if (!g_fDisableBaseTrace && (this == g_pBaseTrace || _ulSSN == g_ulSSNTrace))
    {
        TraceTag((0, "base %x Rel %d", this, ulRefs));
        TraceCallers(0, 0, 12);
    }
#endif

    AssertSz( ulRefs != 0 || !(IsPassivating() || IsPassivated()), 
        "Bouncing off of zero ref counts in CBase::PrivateRelease" );

    if (ulRefs == 0 && !IsPassivating() && !IsPassivated())
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefsAndFlags |= BRF_PASSIVATING;
        Passivate();
        AssertSz(_ulRefs == ULREF_IN_DESTRUCTOR, "Unexpected refcnt on return from CBase::Passivate");
        AssertSz( IsPassivated(), "Derived Passivate didn't call super::Passivate");
        _ulRefs = 0;
        _ulAllRefsAndFlags &= ~BRF_PASSIVATING;

        SubRelease();
    }

    return ulRefs;
}

#if DBG == 1

ULONG CBase::SubAddRef( )
{
    CBaseCheckThread();

    if (!g_fDisableBaseTrace && 
        !g_fDisableBaseSubTrace && (
            this == g_pBaseTrace || 
            this == g_pSubBaseTrace ||
            _ulSSN == g_ulSSNTrace ||
            _ulSSN == g_ulSSNSubTrace))
    {
        TraceTag((0, "base %x SubAR %d", this, GetRefs() + 1));
        TraceCallers(0, 0, 12);
    }
    return _ulAllRefsAndFlags += 1 << BRF_FLAGS_SHIFT;
}

#endif

//+---------------------------------------------------------------
//
//  Member:     CBase::SubRelease
//
//---------------------------------------------------------------

ULONG CBase::SubRelease()
{
    CBaseCheckThread();

#if DBG==1
    ULONG ulAllRefsPrev = GetRefs();

    if (!g_fDisableBaseTrace &&
        !g_fDisableBaseSubTrace && (
            this == g_pBaseTrace || 
            this == g_pSubBaseTrace ||
            _ulSSN == g_ulSSNTrace ||
            _ulSSN == g_ulSSNSubTrace))
    {
        TraceTag((0, "base %x SubRel %d", this, ulAllRefsPrev - 1));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ulAllRefsPrev > 0 );
    _ulAllRefsAndFlags -= 1 << BRF_FLAGS_SHIFT;
    if (GetRefs() == 0)
    {
        Assert( !IsPassivating() && IsPassivated() && !IsDestructing() );

        _ulAllRefsAndFlags = (ULREF_IN_DESTRUCTOR << BRF_FLAGS_SHIFT) | BRF_PASSIVATED | BRF_DESTRUCTING;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

#if DBG==1
    return ulAllRefsPrev - 1;
#else
    return 0;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::CLock::CLock
//
//  Synopsis:   Lock resources in CBase object.
//
//-------------------------------------------------------------------------

CBase::CLock::CLock(CBase *pBase)
{
#if DBG==1
    g_fDisableBaseTrace = TRUE;
#endif

    _pBase = pBase;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pBase->PunkOuter()->AddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::~CLock
//
//  Synopsis:   Unlock resources in CBase object.
//
//-------------------------------------------------------------------------

CBase::CLock::~CLock()
{
#if DBG==1
    g_fDisableBaseTrace = TRUE;
#endif

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pBase->PunkOuter()->Release();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::QueryService
//
//  Synopsis:   Get service from host.  Derived classes should override.
//
//  Arguments:  guidService     id of service
//              iid             id of interface on service
//              ppv             the service
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CBase::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    if ( ppv )
        *ppv = NULL;
    RRETURN(E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::GetPages, ISpecifyPropertyPages
//
//  Synopsis:   Specifies the property pages supported by this object.
//
//  Arguments:  pPages  CLSID's for the pages are returned via a counted array
//
//  Returns:    HRESULT
//
//  Notes:      The array of CLSIDs is divided into two groups, each group
//              ending in a NULL pointer. The first group of CLSIDs is used
//              for when we are in run-mode (browse mode), and the second for
//              when we are in edit mode.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CBase::GetPages(CAUUID * pPages)
{
#ifdef NO_PROPERTY_PAGE
    pPages->pElems = NULL;
    pPages->cElems = 0;
    return S_OK;
#else
    int         i, c;
    int         iStart;
    BOOL        fDesign = DesignMode();
    const CLSID * const * apclsid = BaseDesc()->_apclsidPages;

    pPages->pElems = NULL;
    pPages->cElems = 0;

    if (apclsid)
    {
        if (fDesign)
        {   
            for (c = 0; apclsid[c]; c++)
                ;

            iStart = c + 1;
        }
        else
        {
            iStart = 0;
        }

        for (i = iStart; apclsid[i]; i++)
            ;

        c = i - iStart;

        if (c != 0)
        {
            pPages->pElems = (GUID *) CoTaskMemAlloc(c * sizeof(CLSID));
            if (!pPages->pElems)
            {
                pPages->cElems = 0;
                RRETURN(E_OUTOFMEMORY);
            }

            for (i = iStart; i < iStart + c; i++)
            {
                memcpy(pPages->pElems + i - iStart,
                       apclsid[i],
                       sizeof(CLSID));
            }
            pPages->cElems = c;
        }
    }

    return S_OK;
#endif // NO_PROPERTY_PAGE
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::HasPages
//
//  Synopsis:   Checks if any property pages are supported by this object.
//
//  Returns:    BOOL
//
//  Notes:      The array of CLSIDs is divided into two groups, each group
//              ending in a NULL pointer. The first group of CLSIDs is used
//              for when we are in run-mode (browse mode), and the second for
//              when we are in edit mode.
//
//-------------------------------------------------------------------------

BOOL
CBase::HasPages()
{
#ifdef NO_PROPERTY_PAGE
    return FALSE;
#else
    int         i = 0;
    const CLSID * const * apclsid = BaseDesc()->_apclsidPages;


    if (!apclsid)
        return FALSE;

    if (DesignMode())
    {   
        for (; apclsid[i]; i++)
            ;

        i++;
    }

    return (apclsid[i] != NULL);
#endif // NO_PROPERTY_PAGE
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetClassInfo, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the control's coclass typeinfo.
//
//  Arguments:  ppTI    Resulting typeinfo.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetClassInfo(ITypeInfo ** ppTI)
{
    RRETURN(THR(LoadF3TypeInfo(*BaseDesc()->_pclsid, ppTI)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetGUID, IProvideMultipleClassInfo
//
//  Synopsis:   Returns some type of requested guid
//
//  Arguments:  dwGuidKind      The type of guid requested
//              pGUID           Resultant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetGUID(DWORD dwGuidKind, GUID *pGUID)
{
    if (!pGUID)
        RRETURN(E_INVALIDARG);

    *pGUID = g_Zero.guid;

    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID= (BaseDesc()->_pcpi) ? 
                    *(BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) :
                    IID_NULL;
        return S_OK;
    }

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//  Synopsis:   Returns the count of type infos on this object
//
//  Arguments:  pcti    Resultant of count of ti's.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetMultiTypeInfoCount(ULONG *pcti)
{
    HRESULT hr = S_OK;

    if (!pcti)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // The default is we support one typeinfo
    *pcti = 1;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetAggMultiTypeInfoCount
//
//  Synopsis:   Helper for aggregators for IProvideMultipleClassInfo
//
//  Arguments:  pcti    Resultant of count of ti's.
//              pUnkAgg The aggregate IUnknown
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBase::GetAggMultiTypeInfoCount(ULONG *pcti, IUnknown *pUnkAgg)
{
    HRESULT                     hr = S_OK;
    IProvideMultipleClassInfo * pPMCI = NULL;

    if (!pcti)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pcti = 0;

    if (pUnkAgg)
    {
        // Determine how many ITypeInfos are available from the contained object
        hr = THR_NOTRACE(pUnkAgg->QueryInterface(
                IID_IProvideMultipleClassInfo,
                (void **)&pPMCI));
        if (hr)
        {
            //
            // Aggregate does not support MCI, just give it one TI.
            //

            *pcti = 1;
        }
        else
        {
            hr = THR(pPMCI->GetMultiTypeInfoCount(pcti));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Finally append our own TI
    //

    (*pcti)++;
    hr = S_OK;

Cleanup:
    ReleaseInterface(pPMCI);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetInfoOfIndex, IProvideMultipleClassInfo
//
//  Synopsis:   Get info on the type-info of some index
//
//  Arguments:  iti         Index of type info
//              dwFlags
//              pptiCoClass
//              pdwTIFlags
//              pcdispidReserved
//              piidPrimary
//              piidSource
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::GetInfoOfIndex(
        ULONG iTI,
        DWORD dwFlags,
        ITypeInfo** ppTICoClass,
        DWORD* pdwTIFlags,
        ULONG* pcdispidReserved,
        IID* piidPrimary,
        IID* piidSource)
{
    HRESULT             hr = S_OK;

    if (ppTICoClass)
        *ppTICoClass = NULL;
    if (pdwTIFlags)
        *pdwTIFlags = 0;
    if (pcdispidReserved)
        *pcdispidReserved = 0;
    if (piidPrimary)
        *piidPrimary = IID_NULL;
    if (piidSource)
        *piidSource = IID_NULL;

    if (((dwFlags & MULTICLASSINFO_GETTYPEINFO) && !ppTICoClass)                ||
        ((dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS) && !pcdispidReserved) ||
        ((dwFlags & MULTICLASSINFO_GETIIDPRIMARY) && !piidPrimary)              ||
        ((dwFlags & MULTICLASSINFO_GETIIDSOURCE) && !piidSource))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (iTI != 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        hr = THR(GetClassInfo(ppTICoClass));
        if (hr)
            goto Cleanup;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        //
        // NOTE: (anandra) For our default objects, the reserved
        // dispids have been verified in the code.  Other aggregators
        // will need to ensure this or implement their own.
        //
        
        *pcdispidReserved = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = (BaseDesc()->_piidDispinterface) ?
                            *(BaseDesc()->_piidDispinterface) : 
                            IID_NULL;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = (BaseDesc()->_pcpi && 
                       BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) ? 
                        *(BaseDesc()->_pcpi[CPI_OFFSET_PRIMARYDISPEVENT].piid) :
                        IID_NULL;
    }

    if (pdwTIFlags)
    {
        *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:GetAggInfoOfIndex
//
//  Synopsis:   Helper for getting info on the type-info of some index
//              on an aggregator
//
//  Arguments:  iti         Index of type info
//              dwFlags
//              pptiCoClass
//              pdwTIFlags
//              pcdispidReserved
//              piidPrimary
//              piidSource
//              pUnkAgg
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBase::GetAggInfoOfIndex(
            ULONG iTI,
            DWORD dwFlags,
            ITypeInfo** ppTICoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource,
            IUnknown *pUnkAgg)
{
    IProvideMultipleClassInfo * pPMCI = NULL;
    IProvideClassInfo *         pPCI = NULL;
    ITypeInfo *                 pTICoClass = NULL;
    HRESULT                     hr = S_OK;

    if (iTI == 0)
    {
        // Call default implementation
        hr = THR(CBase::GetInfoOfIndex(
                iTI,
                dwFlags,
                ppTICoClass,
                pdwTIFlags,
                pcdispidReserved,
                piidPrimary,
                piidSource));
    }
    else
    {
        //
        // If the aggregate supports multiple ITypeInfos, pass the request on
        // (Decrement the index by one to account for our extender ITypeInfo)
        //

        hr = THR_NOTRACE(pUnkAgg->QueryInterface(
                IID_IProvideMultipleClassInfo,
                (void **)&pPMCI));
        if (!hr)
        {
            hr = THR(pPMCI->GetInfoOfIndex(iTI - 1,
                                           dwFlags,
                                           ppTICoClass,
                                           pdwTIFlags,
                                           pcdispidReserved,
                                           piidPrimary,
                                           piidSource));
        }
        else if (iTI != 1)
        {
            // If the caller requested an ITypeInfo for something other
            // than the us or that of the immediate aggregate and the
            // aggregate does not support multiple ITypeInfos, it is an error
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            //
            // If the aggregate does not support multiple ITypeInfos and the
            // request is for the aggregate's ITypeInfo, return it
            // using traditional methods
            //

            if (pdwTIFlags)
            {
                *pdwTIFlags = TIFLAGS_EXTENDDISPATCHONLY;
            }

            if (dwFlags & (MULTICLASSINFO_GETTYPEINFO   |
                           MULTICLASSINFO_GETIIDPRIMARY |
                           MULTICLASSINFO_GETIIDSOURCE))
            {
                hr = THR(pUnkAgg->QueryInterface(
                        IID_IProvideClassInfo,
                        (void **)&pPCI));
                if (hr)
                    goto Cleanup;

                if (!ppTICoClass)
                    ppTICoClass = &pTICoClass;

                hr = THR(pPCI->GetClassInfo(ppTICoClass));
                if (hr)
                    goto Cleanup;

                if ((dwFlags & MULTICLASSINFO_GETIIDPRIMARY) ||
                    (dwFlags & MULTICLASSINFO_GETIIDSOURCE))
                {
                    hr = THR(GetTypeInfoFromCoClass(
                                *ppTICoClass,
                                (dwFlags & MULTICLASSINFO_GETIIDPRIMARY
                                        ? FALSE
                                        : TRUE),
                                NULL,
                                (dwFlags & MULTICLASSINFO_GETIIDPRIMARY
                                        ? piidPrimary
                                        : piidSource)));
                    if (hr)
                        goto Cleanup;
                }
            }
        }
    }

    hr = S_OK;

Cleanup:
    ReleaseInterface(pPMCI);
    ReleaseInterface(pPCI);
    ReleaseInterface(pTICoClass);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase:InterfaceSupportsErrorInfo, ISupportErrorInfo
//
//  Synopsis:   Return true if given interface supports error info.
//
//  Arguments:  iid the interface
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBase::InterfaceSupportsErrorInfo(REFIID iid)
{
    const CLASSDESC * pcd;

    pcd = BaseDesc();
    return (pcd->_piidDispinterface &&
            *pcd->_piidDispinterface == iid) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CBase::GetClassID, IPersist
//
//  Synopsis:   Method of IPersist interface
//
//  Returns:    HRESULT
//
//---------------------------------------------------------------

STDMETHODIMP
CBase::GetClassID(LPCLSID pclsid)
{
    *pclsid = *BaseDesc()->_pclsid;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::InvokeDispatchWithThis
//
//  Synopsis:   invokes pDisp adding IUnknown of this
//              named parameter to args list
//
//---------------------------------------------------------------

HRESULT
CBase::InvokeDispatchWithThis (
    IDispatch *     pDisp,
    VARIANT *       pExtraArg,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider,
    IDispatch *     pdispThis) 
{
    HRESULT         hr;
    IDispatchEx  *  pDEX = NULL;
    DISPPARAMS *    pPassedParams = pdispparams;
    IDispatch *     pdispThisLocal = NULL;
    CDispParams     dispParams((pExtraArg ? pdispparams->cArgs + 1 : pdispparams->cArgs),
                                pdispparams->cNamedArgs + 1);

    hr = THR_NOTRACE(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDEX));
    // Does the object support IDispatchEx then we'll need to pass
    // the this pointer of this object
    if (!hr)
    {
        if (!pdispThis)
        {
            hr = THR(PrivateQueryInterface(IID_IDispatch, (void **)&pdispThisLocal));
            if (hr)
                goto Cleanup;

            pdispThis = pdispThisLocal;
        }

        hr = dispParams.Create(pdispparams);
        if (hr)
            goto Cleanup;

        // Create the named this parameter
        Assert(dispParams.cNamedArgs > 0);
        V_VT(&dispParams.rgvarg[0]) = VT_DISPATCH;
        V_UNKNOWN(&dispParams.rgvarg[0]) = pdispThis;
        dispParams.rgdispidNamedArgs[0] = DISPID_THIS;

        if (pExtraArg)
        {
            UINT     uIdx = dispParams.cArgs - 1;

            memcpy(&(dispParams.rgvarg[uIdx]), pExtraArg, sizeof(VARIANT));
        }

        pPassedParams = &dispParams;
    }

    //
    // Call the function
    //
    hr = pDEX ? THR(pDEX->InvokeEx(DISPID_VALUE,
                                 lcid,
                                 wFlags,
                                 pPassedParams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider))         :
                THR(pDisp->Invoke(DISPID_VALUE,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pPassedParams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));

    // If we had to pass the this parameter and we had more than
    // 1 parameter then copy the orginal back over (the args could have
    // been byref).
    if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
    {
        hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);
    ReleaseInterface(pdispThisLocal);

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CBase::InvokeDispatchExtraParam
//
//  Synopsis:   invokes pDisp adding pExtraParam as the last
//              parameter to args list
//
//---------------------------------------------------------------

HRESULT
CBase::InvokeDispatchExtraParam (
    IDispatch *     pDisp,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider,
    VARIANT        *pExtraParam) 
{
    HRESULT         hr;
    IDispatchEx  *  pDEX = NULL;
    DISPPARAMS *    pPassedParams = pdispparams;
    CDispParams     dispParams(pdispparams->cArgs, 1);

    Assert(pdispparams->cNamedArgs == 0);

    IGNORE_HR(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDEX));

    hr = dispParams.Create(pdispparams);
    if (hr)
        goto Cleanup;

    // Add the extra parameter
    dispParams.cNamedArgs = 0;
    delete [] dispParams.rgdispidNamedArgs;
    dispParams.rgdispidNamedArgs = 0;

    // Move the extra parameter.
    memcpy(&dispParams.rgvarg[0], pExtraParam, sizeof(VARIANTARG));

    pPassedParams = &dispParams;

    //
    // Call the function
    //
    hr = pDEX ? THR_NOTRACE(pDEX->InvokeEx(DISPID_VALUE,
                                 lcid,
                                 wFlags,
                                 pPassedParams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider))         :
                THR_NOTRACE(pDisp->Invoke(DISPID_VALUE,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pPassedParams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));

    // If we had to pass the this parameter and we had more than
    // 1 parameter then copy the orginal back over (the args could have
    // been byref).
    if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
    {
        hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs - 1);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pDEX);

    RRETURN (hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::Invoke(
        DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS * pdispparams,
        VARIANT * pvarResult,
        EXCEPINFO * pexcepinfo,
        UINT *)
{
    HRESULT         hr;
    IDispatchEx    *pDispEx;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->InvokeEx(dispidMember, lcid, wFlags, pdispparams,pvarResult, pexcepinfo, NULL);
        ReleaseInterface(pDispEx);
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetIDsOfNames(REFIID riid,
                     LPOLESTR *  rgszNames,
                     UINT,
                     LCID,
                     DISPID *    rgdispid)
{
    HRESULT         hr;
    IDispatchEx    *pDispEx;
    BSTR            bstrName = NULL;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    if (rgszNames[0] == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispEx));
    if (hr)
    {
        // Object doesn't support IDispatchEx use CBase::InvokeEx
        hr = THR(FormsAllocString(rgszNames[0], &bstrName));
        if (hr)
            goto Cleanup;

        hr = GetDispID(bstrName, fdexFromGetIdsOfNames, rgdispid);
    }
    else
    {
        // Object supports IDispatchEx call InvokeEx thru it's v-table.
        hr = pDispEx->GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid);
        ReleaseInterface(pDispEx);
    }

Cleanup:
    FormsFreeString(bstrName);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:   GetArgsActual
//
//  Synopsis:   helper
//
//--------------------------------------------------------------------------

LONG GetArgsActual(DISPPARAMS * pdispparams)
{
    LONG cArgsActual;
    // If the parameters passed in has the named DISPID_THIS paramter, then we
    // don't want to include this parameter in the total number of parameter
    // count.  This named parameter is an additional parameter tacked on by the
    // script engine to handle scoping rules.
    cArgsActual = pdispparams->cArgs;
    if (pdispparams->cNamedArgs && *pdispparams->rgdispidNamedArgs == DISPID_THIS)
    {
        cArgsActual--;  // Don't include DISPID_THIS in argument count.
    }

    return cArgsActual;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::InvokeAA
//
//  Synopsis:   helper
//
//--------------------------------------------------------------------------

HRESULT
CBase::InvokeAA(
    DISPID              dispidMember,
    CAttrValue::AATYPE  aaType,
    LCID                lcid,
    WORD                wFlags,
    DISPPARAMS *        pdispparams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pexcepinfo,
    IServiceProvider *  pSrvProvider,
    BOOL                fIsExpando)
{
    HRESULT     hr = DISP_E_MEMBERNOTFOUND;
    LONG        cArgsActual = GetArgsActual(pdispparams);

    if ((cArgsActual == 0) && (wFlags & DISPATCH_PROPERTYGET))
    {
        if (pvarResult)
        {
            hr = GetVariantAt(FindAAIndex(dispidMember, aaType),
                                pvarResult, /* fAllowNullVariant = */FALSE);
            if (!hr)
                goto Cleanup;
        }
    }
    else if (wFlags & DISPATCH_PROPERTYPUT)
    {
        if (pdispparams && cArgsActual == 1)
        {
            // This path here is only for expandos - tree sync and undo for
            // normal attributes goes through a different path
            BOOL    fTreeSync = FALSE;
            BOOL    fCreateUndo = !g_fInVizAct2000 && QueryCreateUndo( TRUE, FALSE, &fTreeSync );
            AAINDEX aaIdx = FindAAIndex(dispidMember, aaType);

            // HACK (JHarding): VizAct 2000 gets confused if we undo expandos, so we have to disable it for them (99897)

            // Get the old value before it's set
            if( fTreeSync || fCreateUndo )
            {
                CVariant vtOld;

                VariantInit( &vtOld );

                if( aaIdx != AA_IDX_UNKNOWN )
                    IGNORE_HR( GetVariantAt( aaIdx, &vtOld, TRUE ) );
                else
                    V_VT(&vtOld) = VT_NULL;

                if( fTreeSync )
                {
                    IGNORE_HR( LogAttributeChange( dispidMember, &vtOld, pdispparams->rgvarg ) );
                }

                if( fCreateUndo )
                {
                    IGNORE_HR( CreatePropChangeUndo( dispidMember, &vtOld, NULL ) );
                }
            }

            if (aaIdx == AA_IDX_UNKNOWN)
            {
                hr = AddVariant(dispidMember,
                                pdispparams->rgvarg,
                                aaType);
                if (fIsExpando)
                {
                    hr = THR(UpdateDomAttrCollection(FALSE, dispidMember));
                    if (hr)
                        goto Cleanup;
                }
            }
            else
            {
                hr = ChangeVariantAt(aaIdx, pdispparams->rgvarg);
            }
            if (hr)
                goto Cleanup;

            hr = OnPropertyChange(dispidMember, 0);
            goto Cleanup;
        }
        else
        {
            // Missing value to set.
            hr = DISP_E_BADPARAMCOUNT;
            goto Cleanup;
        }
    }

    // If the wFlags was marked as a Get/Method and the get failed then try
    // this as a method invoke.  Of if the wFlags was only a method invoke
    // then the hr is set to DISP_E_MEMBERNOTFOUND at the entry ExpandoInvoke.
    if (hr && (wFlags & DISPATCH_METHOD))
    {
        AAINDEX aaidx = FindAAIndex(dispidMember, aaType);
        if (AA_IDX_UNKNOWN == aaidx)
        {
            if (pvarResult)
            {
                VariantClear(pvarResult);
                pvarResult->vt = VT_NULL;
                hr = S_OK;
            }
        }
        else
        {
            IDispatch * pDisp = NULL;
        
            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (!hr && pDisp)
            {
                hr = THR(InvokeDispatchWithThis(
                    pDisp,
                    NULL,
                    IID_NULL,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
                ReleaseInterface(pDisp);
           }
        }
    }
    else
    {
        hr = DISP_E_MEMBERNOTFOUND;
    }

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::ContextInvokeEx, IDispatchEx
//
//  Synopsis:   Real implementation of InvokeEx.  Uses context passed
//              in for actual calls
//
//--------------------------------------------------------------------------

STDMETHODIMP CBase::ContextInvokeEx(DISPID dispidMember,
                                    LCID lcid,
                                    WORD wFlags,
                                    DISPPARAMS * pdispparams,
                                    VARIANT * pvarResult,
                                    EXCEPINFO * pexcepinfo,
                                    IServiceProvider *pSrvProvider,
                                    IUnknown *pUnkContext)
{
    PerfDbgLog(tagPerfWatch, this, "+CBase::ContextInvokeEx");
    HRESULT         hr = S_OK;
    long            cArgsActual = GetArgsActual(pdispparams);
    DISPPARAMS     *pOldDispParams = NULL;
    CDispParams     dpMissingArgs;

    ITypeInfo * pTI = NULL;
    IUnknown *  pUnk = NULL;

    // clear the per thread EI object to check again after custom Invoke to see if 
    // it was set from a prop\method on failure
    IErrorInfo *pErrorInfo = NULL;

#if DBG == 1
    IErrorInfo *pErrorInfoDbg = NULL;
    hr = GetErrorInfo(0, &pErrorInfoDbg);
    if (!hr)
    {
        Assert(pErrorInfoDbg);
        ::SetErrorInfo(NULL, pErrorInfoDbg);
    }
#endif

    //
    // Handle special performance critical dispids without loading typeinfo.
    //

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_ENABLED:
        case DISPID_VALID:
            if (pvarResult == NULL)
            {
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                RRETURN(E_INVALIDARG);
            }

            V_VT(pvarResult) = VT_BOOL;
            switch (dispidMember)
            {
            case DISPID_ENABLED:
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                return THR_NOTRACE(GetEnabled(&V_BOOL(pvarResult)));

            case DISPID_VALID:
                PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");
                return THR_NOTRACE(GetValid(&V_BOOL(pvarResult)));

            default:
                Assert(0 && "Logic error");
                break;
            }
            break;

        case DISPID_UNKNOWN:
            // Special case handling if we ever have a condition were
            // something can't be found but the invoke caller expect us
            // to return data (pvarResult) then instead of returning the
            // error DISP_EMEMBERNOTFOUND we'll return DISPID_UNKNOWN with
            // a hr result of S_OK (inn GetIDsOfNamesEx) when the Invoke
            // is called and if we ever get a DISPID_UNKNOWN we'll simply
            // return VT_NULL.  This will JavaScript to compare the result
            // to null and VBScript to detect isnull()
            if (pvarResult)
            {
                VariantClear(pvarResult);
                pvarResult->vt = VT_NULL;
                hr = S_OK;
                goto Cleanup;
            }
            break;

        default:
            break;
        }
    }

    // Are we an expando?
    if (IsExpandoDISPID ( dispidMember ) )
    {

ExpandoInvoke:
        hr = THR(InvokeAA (dispidMember, CAttrValue::AA_Expando,
                lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider, TRUE));

    }
    else
    {
        PROPERTYDESC_METHOD   *pDesc;
        WORD                   wEntry;
        WORD                   wIIDIndex;

#if DBG == 1
        if (IsTagEnabled(tagOleAutomation))
        {
            goto OLEInvoke;
        }
#endif

        // Can we find the properydesc for this dispid, if so then use our
        // custom invoke.
        hr = FindPropDescFromDispID(dispidMember, (PROPERTYDESC **)&pDesc, &wEntry, &wIIDIndex);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }
        else
        {
            CustomHandler   pHandler;
            IDispatch      *pDisp;
            CVariant        varTemp;

#if DBG == 1
            if (IsTagEnabled(tagInvokeTrace))
            {
                OutputDebugString(_T("Invoke: "));
                OutputDebugString((pDesc->a.pstrExposedName) ? pDesc->a.pstrExposedName :
                                                               pDesc->a.pstrName);
                OutputDebugString(_T("\r\n"));
            }
#endif  // Output what's happening.

            if (!pvarResult)
            {
                pvarResult = &varTemp;
            }

            Assert(pDesc);

            if ((cArgsActual == 0)                              &&
                (wFlags & DISPATCH_PROPERTYGET)                 &&
                (pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet))
            {
                // If the property supports both get/set then the vtable offset
                // in the propdesc is for the set adding sizeof(void*) gets us to the get
                // property function.
                if (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet)
                {
                    wEntry += sizeof(void*);
                }
                goto CustomInvoke;
            }
            else if ((cArgsActual == 1)                         &&
                     (wFlags & DISPATCH_PROPERTYPUT)            &&
                     (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))
            {
                goto CustomInvoke;
            }
            // object put or get value property of an object?
            else if ((wFlags & DISPATCH_PROPERTYPUT ||
                      wFlags & DISPATCH_PROPERTYGET)                &&
                     pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)
            {
                if (cArgsActual > 0 && 
                    (pDesc->b.wInvFunc == IDX_G_IDispatchp ||
                     pDesc->b.wInvFunc == IDX_GS_IDispatchp))
                {
                    // Possible indexed collection access
                    CVariant    varTmp;

                    // Must be QI not PrivateQI, location, navigator, etc. are wrapped
                    // we must delegate to the wrappers.  If the index into the IIDTable
                    // is zero then the wEntry is on the primary default interface otherwise
                    // use the interface in the IIDTable.
                    hr = pUnkContext->QueryInterface(_IIDTable[wIIDIndex] 
                                                     ? *_IIDTable[wIIDIndex] 
                                                     : *BaseDesc()->_piidDispinterface,
                                               (void **) &pDisp);
                    if (hr)
                        goto Cleanup;

                    // If the property is both a get/set then adjust offset to
                    // point to the get property function.
                    if (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet)
                    {
                        wEntry += sizeof(void*);
                    }

                    hr = G_IDispatchp(this,
                                      pSrvProvider,
                                      pDisp,
                                      wEntry,
                                      (PROPERTYDESC_BASIC_ABSTRACT *)pDesc,
                                      wFlags,
                                      NULL,
                                      &varTmp);
                    if (!hr)
                    {
                        if (V_VT(&varTmp) == VT_DISPATCH)
                        {
                            IDispatch  *pDisp = V_DISPATCH(&varTmp);

        				    IDispatchEx *pDispEx;

                            if ( !pDisp )
                            {
                                hr = DISP_E_MEMBERNOTFOUND;
                            }
                            else
                            {
                                hr = pDisp->QueryInterface ( IID_IDispatchEx, (void **)&pDispEx );
                                if ( !hr )
                                {
                                    hr = pDispEx->InvokeEx(DISPID_VALUE,
                                        lcid, wFlags, pdispparams,
                                        pvarResult,pexcepinfo,pSrvProvider);
                                    ReleaseInterface(pDispEx);
                                    SetErrorInfo(hr);
                                }
                                else
                                {
                                    hr = pDisp->Invoke(DISPID_VALUE,
        				                IID_NULL,lcid,wFlags,pdispparams,
                        				pvarResult,pexcepinfo,NULL);
                                    SetErrorInfo(hr);
                                }                            
                                if (FAILED(hr))
                                {
                                    GetErrorInfo(0, &pErrorInfo);
                                    Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
                                }
                            }
                        }
                        else
                        {
                            hr = DISP_E_NOTACOLLECTION;
                        }
                    }

                    ReleaseInterface(pDisp);

                    goto Cleanup2;
                }
            }
            else if (wFlags & DISPATCH_METHOD)
            {
                // Check if method and args are at least minimum #.  Note, I
                // longer check the maximum count, JavaScript (Navigator)
                // ignores any arguments greater than max and we will as well.
                // So we wont check:
                //
                //   cArgsActual <= pDesc->d   // #args <= max # of args?
                //
                if (!((pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)    ||
                       (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))      &&
                    cArgsActual >= pDesc->e)      // #args >= required minimum args?
                {
                    // It's a method invocation.
                    goto CustomInvoke;
                }
                // Check to see if scriptlet flag is on.
                else if (pDesc->b.dwPPFlags & PROPPARAM_SCRIPTLET)
                {
                    hr = DISP_E_MEMBERNOTFOUND;
                    
                    // Invoke with dispid this, it's a property.
                    AAINDEX aaidx = FindAAIndex(dispidMember, CAttrValue::AA_Internal);
                    if (AA_IDX_UNKNOWN != aaidx)
                    {
                        IDispatch * pDisp = NULL;
                        
                        hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
                        if (!hr && pDisp)
                        {
                            hr = THR(InvokeDispatchWithThis(
                                pDisp,
                                NULL,
                                IID_NULL,
                                lcid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                pSrvProvider));
                            ReleaseInterface(pDisp);
                            if (FAILED(hr))
                            {
                                GetErrorInfo(0, &pErrorInfo);
                                Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
                            }
                         }
                    }
                    goto Cleanup;
                }
                else if (!((pDesc->b.dwPPFlags & PROPPARAM_INVOKEGet)    ||
                           (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))      &&
                    cArgsActual < pDesc->e)      // #args < less than minimum args?
                {
                    // Construct null parameters for each missing parameter.
                    dpMissingArgs.Initialize(pDesc->e, pdispparams->cNamedArgs);

                    hr = dpMissingArgs.Create(pdispparams);
                    if (hr)
                        goto Cleanup;

                    pOldDispParams = pdispparams;
                    pdispparams = &dpMissingArgs;

                    // It's a method invocation.
                    goto CustomInvoke;
                }
            }
            else if ((cArgsActual == 1)                  &&
                     (wFlags & DISPATCH_PROPERTYPUTREF)         &&
                     (pDesc->b.dwPPFlags & PROPPARAM_INVOKESet))
            {
                // Passing argument by reference. 
                goto CustomInvoke;
            }
            else if ((wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE &&
                pvarResult != NULL && cArgsActual == 0 )
            {
                // PROPGET For default property
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }
            // Accessing a method w/o arguments (e.g, document.open;).  This
            // would invoke the open as a get property which we'll return as
            // undefined.  Nav3 would do nothing but error if alert(doc.open)
            // we'll return undefined.
            else if (wFlags & DISPATCH_PROPERTYGET &&
                     ((pDesc->b.dwPPFlags & PROPPARAM_INVOKESet) == 0))
            {
                // Compute open expando and get the expando value.
                DISPID  dispIDExpando;
                TCHAR  *pName = const_cast <TCHAR *> (pDesc->a.pstrExposedName ?
                                                pDesc->a.pstrExposedName :
                                                pDesc->a.pstrName);

                // Compute the expando dispid.
                hr = GetExpandoDispID(pName, &dispIDExpando, fdexNameCaseSensitive);
                if (!hr)
                {
                    // Found the expando so get the expando value.
                    dispidMember = dispIDExpando;
                    goto ExpandoInvoke;
                }
                else
                {
                    // Create the CFunctionPointer object and store it in the
                    // attrArray.
                    AAINDEX     aIdx;

                    aIdx = FindAAIndex(dispidMember, CAttrValue::AA_Attribute);
                    if (aIdx == AA_IDX_UNKNOWN)
                    {
                        V_DISPATCH(pvarResult) = (IDispatch *)new CFunctionPointer(this, dispidMember);

                        hr = V_DISPATCH(pvarResult) ?
                                    AddDispatchObject(dispidMember,
                                                      V_DISPATCH(pvarResult),
                                                      CAttrValue::AA_Attribute)
                                    : E_OUTOFMEMORY;
                    }
                    else
                    {
                        // Object already exist.
                        hr = GetDispatchObjectAt(aIdx, &V_DISPATCH(pvarResult));
                    }

                    V_VT(pvarResult) = VT_DISPATCH;

                    // Any error then cleanup the any objects created?
                    if (hr)
                    {
                        VariantClear(pvarResult);
                        V_VT(pvarResult) = VT_NULL;

                        // No expando/function object, return undefined.
                        hr = S_OK;
                    }

                    goto Cleanup;
                }            
            }

            // Catch all error for anything not customed invoked.
            hr = E_NOTIMPL;
            goto Cleanup;

CustomInvoke:
#if 0
if (StrCmpIC(_T("parent"), pDesc->a.pstrExposedName ?
                            pDesc->a.pstrExposedName :
                            pDesc->a.pstrName) == 0)
    DebugBreak(); 
#endif
            pHandler = _HandlerTable[pDesc->b.wInvFunc];
            if (!pHandler)
            {
                hr = DISP_E_MEMBERNOTFOUND;
                goto Cleanup;
            }

            // Must be QI not PrivateQI, location, navigator, etc. are wrapped
            // we must delegate to the wrappers.  If the index into the IIDTable
            // is zero then the wEntry is on the primary default interface otherwise
            // use the interface in the IIDTable.
            hr = pUnkContext->QueryInterface(_IIDTable[wIIDIndex] 
                                                ? *_IIDTable[wIIDIndex] 
                                                : *BaseDesc()->_piidDispinterface,
                                             (void **) &pDisp);
            if (hr)
                goto Cleanup;

            // Before we Invoke, cache the Invoke Context in the Attr Array. Store it for the duration of the
            // Invoke so that we can establish script context

            // Can optimize this by knowing what dispids need to know this info
            // Adding it into the attr array automaticaly AddRef's it
            if ( pSrvProvider )
                AddUnknownObject ( DISPID_INTERNAL_INVOKECONTEXT, pSrvProvider, CAttrValue::AA_Internal );

            hr = (*pHandler)(this, pSrvProvider, pDisp, wEntry, (PROPERTYDESC_BASIC_ABSTRACT *)pDesc, wFlags, pdispparams, pvarResult);

            if (FAILED(hr))
            {
                GetErrorInfo(0, &pErrorInfo);
                Assert(pErrorInfo && (!pErrorInfoDbg || (pErrorInfoDbg != pErrorInfo)) && "Property or Method did not SetErrorInfo");
            }

            // Did we make a method call where we fabricated arguments which were
            // missing?
            if (pOldDispParams)
            {
                // Yes, so move the args back to original dispparams and reset
                // out dispparam pointers.
                HRESULT hr1 = dpMissingArgs.MoveArgsToDispParams(pOldDispParams, pOldDispParams->cArgs);

                pdispparams = pOldDispParams;
                pOldDispParams = NULL;

                if (FAILED(hr1))
                {
                    if (hr == S_OK)
                        hr = hr1;

                    goto Cleanup;
                }
            }

            if ( pSrvProvider )
                FindAAIndexAndDelete ( DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal );
            

            ReleaseInterface(pDisp);
        }

#if DBG==1
        goto Cleanup;

OLEInvoke:
        // Problem, so use ITypeInfo::Invoke
        hr = GetTypeInfo(0, lcid, &pTI);
        if (hr)
            goto Cleanup;

        hr = pUnkContext->QueryInterface(
                            *BaseDesc()->_piidDispinterface,
                            (void **) &pUnk);
        if (hr)
            goto Cleanup;

        hr = pTI->Invoke(
                    pUnk,
                    dispidMember,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
#endif
    }

Cleanup:
    // Nav support for coercing object ptrs to Strings
    if ( hr == DISP_E_MEMBERNOTFOUND && (wFlags & DISPATCH_PROPERTYGET) && dispidMember == DISPID_VALUE &&
                pvarResult != NULL && cArgsActual == 0)
    {
        V_VT(pvarResult) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("[object]"),&V_BSTR(pvarResult) ) );
    }

Cleanup2:
    if (hr == S_OK && pvarResult &&
        V_VT(pvarResult) == VT_DISPATCH &&
        V_DISPATCH(pvarResult))
    {
        IDispatch *pdisptemp = V_DISPATCH(pvarResult);
        hr = pdisptemp->QueryInterface(IID_IDispatch, (LPVOID*)&V_DISPATCH(pvarResult));
        ReleaseInterface(pdisptemp);
    }

    if (FAILED(hr) && pexcepinfo)
    {
        pexcepinfo->wCode = 0;
        pexcepinfo->scode = hr;
        if (pErrorInfo)
        {
            pErrorInfo->GetSource(&(pexcepinfo->bstrSource));
            pErrorInfo->GetDescription(&(pexcepinfo->bstrDescription));
            pErrorInfo->GetHelpFile(&(pexcepinfo->bstrHelpFile));
            pErrorInfo->GetHelpContext(&(pexcepinfo->dwHelpContext));
            hr = DISP_E_EXCEPTION;
        }
    }

#if DBG==1    
    ReleaseInterface(pErrorInfoDbg);
#endif

    ReleaseInterface(pErrorInfo);
    ReleaseInterface(pTI);
    ReleaseInterface(pUnk);

    PerfDbgLog(tagPerfWatch, this, "-CBase::ContextInvokeEx");

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetDispID, IDispatchEx
//
//  Synopsis:   Delegates to ITypeInfo::GetIDsOfName first if this calls fails
//              then check if the name exist in the propertyDesc array and then
//              the expando list (don't do yet).  If the name doesn't exist in
//              any of those list then create an expando property if grfdex
//              parameter says to and return the dispid of the new expando.
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetDispID(BSTR bstrName,
                 DWORD grfdex,
                 DISPID *pid)
{
    HRESULT     hr;
    BOOL fRestricted = FALSE;

    PerfDbgLog1(tagPerfWatch, this, "+CBase::GetDispID (%ls)", bstrName);

    if (!pid)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    hr = CBase::GetInternalDispID(bstrName, pid, grfdex, NULL, NULL, &fRestricted);
    if (fRestricted)
    {
        Assert(DISP_E_UNKNOWNNAME == hr);
        goto Cleanup;
    }

    if (!hr)
    {
        // We found the name, however we'll need to check if the name is a method
        // if so then the builtin method could have been overriden.  So check
        // the attr array for this expando.
        PROPERTYDESC_METHOD    *pDesc;
        WORD                    wEntry;
        WORD                    wIIDIndex;

        hr = FindPropDescFromDispID(*pid,
                                    (PROPERTYDESC **)&pDesc,
                                    &wEntry,
                                    &wIIDIndex);
        if (!hr)
        {
            // Accessing a method, could have changed so it might be expando.
            if ((pDesc->b.dwPPFlags & PROPPARAM_INVOKESet) == 0)
            {
                DISPID  dispIDExpando;

                // Compute the expando dispid.
                hr = GetExpandoDispID(bstrName, &dispIDExpando, grfdex);
                if (!hr)
                {
                    if ((*GetAttrArray())->FindAAIndex(dispIDExpando,
                                                       CAttrValue::AA_Expando) != AA_IDX_UNKNOWN)
                    {
                        // Found the expando so get the expando value.
                        *pid = dispIDExpando;
                    }
                }
            }
        }

        hr = S_OK;
        goto Cleanup;
    }

    // Try expandos
    hr = GetExpandoDispID(bstrName, pid, grfdex);
    if (hr == S_FALSE)
    {
        // If we're returning false then the rgdispid is DISPID_UNKNOWN expando
        // wasn't found but it wasn't added either we'll return VT_NULL on the
        // invoke.
        Assert(*pid == DISPID_UNKNOWN);
        hr = S_OK;
    }
#if DBG == 1
    else if (hr == S_OK)
    {
        if (IsTagEnabled(tagInvokeTrace))
        {
            OutputDebugString(_T("NamesEx expando: "));
            OutputDebugString(bstrName);
            OutputDebugString(_T("\r\n"));
        }
    }
#endif  // Output what's happening.

Cleanup:
    PerfDbgLog1(tagPerfWatch, this, "-CBase::GetDispID (%ls)", bstrName);
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::DeleteMemberByName(BSTR psz,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
CBase::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


HRESULT
CBase::GetMemberName(DISPID id, BSTR *pbstrName)
{
    LPCTSTR pszName = NULL;
    PROPERTYDESC *pPropDesc;
    const TCHAR *pstr;
    DISPID expDispid;

    if (!pbstrName)
        return E_INVALIDARG;

    *pbstrName = NULL;
    
    if (IsExpandoDISPID(id, &expDispid))
    {
        GetExpandoName(expDispid, &pszName);
        FormsAllocString(pszName, pbstrName);
    }
    else
    {
        if (FindPropDescFromDispID(id, &pPropDesc, NULL, NULL))
            goto Cleanup;

        pstr = pPropDesc->pstrExposedName ?
                                 pPropDesc->pstrExposedName :
                                 pPropDesc->pstrName;

        FormsAllocString(pstr, pbstrName);
    }

Cleanup:
    return *pbstrName ? S_OK : DISP_E_MEMBERNOTFOUND;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetNextDispID, IDispatchEx
//
//  Synopsis:   Loop through all property entries in ITypeInfo then enumerate
//              through all expando properties.  Any DISPID handed out here
//              must stay constant (GetDispID should hand out the
//              same).  This routines enumerates regular properties and expando.
//
//  Results:
//              S_OK        - returns next DISPID
//              S_FALSE     - enumeration is done
//              E_nnnn      - call failed.
//--------------------------------------------------------------------------

HRESULT
CBase::GetNextDispID(DWORD grfdex,
                     DISPID id,
                     DISPID *prgid)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    hr = GetInternalNextDispID(grfdex, id, prgid, &bstr);
    FormsFreeString( bstr );
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetNameSpaceParent, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


HRESULT
CBase::GetInternalDispID(BSTR           bstrName,
                         DISPID       * pid,
                         DWORD          grfdex, 
                         IDispatch    * pDisp /*= NULL*/,
                         IDispatchEx  * pDispEx /*= NULL*/,
                         BOOL         * pfRestricted /*= NULL*/)
{
    HRESULT                     hr = DISP_E_UNKNOWNNAME;
    const VTABLEDESC           *pVTblDesc;

    pVTblDesc = FindVTableEntryForName (bstrName, 
                                        (!!(grfdex & fdexNameCaseSensitive)));

    if (pVTblDesc)
    {
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);  // Property Description
        Assert(pPropDesc);

        if (pPropDesc->GetPPFlags() & PROPPARAM_RESTRICTED)
        {
            if (pfRestricted)
                *pfRestricted = TRUE;

            goto Cleanup;
        }

        // Variable name usage on a method?
        if ((!!(grfdex & fdexNameEnsure)) &&
            ((pPropDesc->GetPPFlags() & PROPPARAM_INVOKEGet) ||
            (pPropDesc->GetPPFlags() & PROPPARAM_INVOKESet)) == 0)
        {
            // Yes, so if we've got a function here then error we
            // want this as an expando.
            goto Cleanup;
        }
        else
        {
            // Either it's a real method wanted or we're working on a
            // property.
            *pid = pPropDesc->GetDispid();

            if (!_pAA)
            {
                _pAA = new CAttrArray;
                // If new doesn't succeed then no cache is used.
            }

            // Set cache of last found DISPID and vtable desc this cache is
            // used by custom invoke to eliminate search.
            if (_pAA)
            {
                _pAA->SetGINCache(*pid, pVTblDesc);
            }

            hr = S_OK;
            goto Cleanup;           // We're done we can leave now.
        }
    }

    // They better both not be set.
    Assert(!(pDisp && pDispEx));

    // Is there another typeinfo we should look at?
    if (pDisp || pDispEx)
    {
        if (pDispEx) 
        {
            hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, 
                                                grfdex, 
                                                pid));
        }
        else if (pDisp)
        {
            // If control is IDispatch then no case sensitive match.
            ITypeInfo   *pTI = NULL;

            hr = THR(pDisp->GetTypeInfo(0, g_lcidUserDefault, &pTI));
            if (!hr)
            {
                hr = THR_NOTRACE(MatchExactGetIDsOfNames(pTI,
                                                         IID_NULL,
                                                         &bstrName,
                                                         1,
                                                         0,
                                                         pid,
                                                         !!(grfdex & fdexNameCaseSensitive)));
            }

            // We'll enter here if we didn't have a typelib or if
            // MatchExactGetIDsOfNames failed.
            if (hr)
            {
                // Do it the hardway no typelib at all or the typelib didn't
                // expose the prop/metho so lets try it this way.
                hr = THR_NOTRACE(pDisp->GetIDsOfNames(IID_NULL,
                                                      &bstrName,
                                                      1,
                                                      0,
                                                      pid));
            }

            ReleaseInterface(pTI);
        }
    }

Cleanup:
    RRETURN(hr);
}



HRESULT
#ifdef VSTUDIO7
CBase::GetExpandoDispID(LPOLESTR pchName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
#else
CBase::GetExpandoDispID(BSTR bstrName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
#endif //VSTUDIO7
{
#ifdef VSTUDIO7
    return GetExpandoDISPID(pchName, pid, grfdex, pAA);
#else
    return GetExpandoDISPID(bstrName, pid, grfdex, pAA);
#endif //VSTUDIO7
}

HRESULT
CBase::GetExpandoDISPID(LPTSTR pchName, DISPID *pid, DWORD grfdex, CAttrArray *pAA /* = NULL */)
{
    HRESULT         hr = S_OK;
    CAtomTable     *pat;
    BOOL            fCaseSensitive = (grfdex & fdexNameCaseSensitive) != 0;
    LONG            lIndex;
    LONG            lId;
    BOOL            fFound = FALSE;
    BOOL            fStartFromIndex = FALSE;

    // Assume failure.
    *pid = DISPID_UNKNOWN;
    hr = DISP_E_UNKNOWNNAME;

    // If pAA is not specified or is NULL use the calss memeber value
    if(!pAA) pAA = _pAA;

    // Look in Expando for this property.
    pat = GetAtomTable();
    if(!pat)
        goto Cleanup;

    lIndex = -1;
    do
    {
        lIndex++;

        // The first time search is initiated, fStartFromIndex should be FALSE
        // After the first try, fStartFromIndex should/can be set to TRUE.
        hr = THR_NOTRACE(pat->GetAtomFromName(pchName, &lIndex, &lId, fCaseSensitive, fStartFromIndex));

        fStartFromIndex = TRUE;

        if (!hr)
        {
            *pid = lId;
            Assert(lId >= 0);

            // Make it an expando range.
            *pid += DISPID_EXPANDO_BASE;
            // Outside of range then we've got too many expandos.
            if (*pid > DISPID_EXPANDO_MAX)
            {
                *pid = DISPID_UNKNOWN;
                hr = DISP_E_UNKNOWNNAME;
                goto Cleanup;
            }

            // Verify that this expando truly does exist, a name in the atom
            // table doesn't guarantee that the name is expando.  Consider the
            // case of a named element.  During the event firing the implicit
            // this is the element which when called thru GetDispID will
            // find that name in this routine and assume that it was expando
            // unless we verify that the attrArray for this element truly has
            // this expando.
            if (FindAAIndex(*pid, CAttrValue::AA_Expando, AA_IDX_UNKNOWN, FALSE, pAA) != AA_IDX_UNKNOWN)
            {
                // It's an expando...we found it
                fFound = TRUE;
            }
            else
            {
                // Check if it could be an ActiveX expando?
                DISPID  dispIDactX;

                // remapped to ActiveX expando?
                dispIDactX = (*pid - DISPID_EXPANDO_BASE) + DISPID_ACTIVEX_EXPANDO_BASE;
                // Too many activeX expandos?
                if (dispIDactX <= DISPID_ACTIVEX_EXPANDO_MAX)
                {
                    if (FindAAIndex(dispIDactX, CAttrValue::AA_Expando, AA_IDX_UNKNOWN, FALSE, pAA) != AA_IDX_UNKNOWN)
                    {
                        fFound = TRUE;
                    }
                }
            }
        }
        // Atom tables are alway built case sensitive so if we did not found the name
        //  when doing a case insensitive search that may be because there different
        //  spellings of the same name in the atom table. We need to try them all
    } while(!fCaseSensitive && !fFound && hr == S_OK);

    if(!fFound)
    {
        if((grfdex & fdexNameEnsure) != 0)
        {
            // Add expando.
            hr = AddExpando(pchName, pid);
        }
        else
        {
    // NOTE: ***TLL*** VT_NULL handling wont happen unless we can return S_OK here.
    //         temporary work around to allow foo() to return not defined.
            // Don't error just return success, however the
            // dispid returned is DISPID_UNKNOWN. CBase::Invoke
            // will take care of r-value case to return a
            // VT_NULL for l-value an error will occur.
            hr = DISP_E_UNKNOWNNAME;
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CBase::GetInternalNextDispID(DWORD grfdex,
                             DISPID id,
                             DISPID *prgid,
                             BSTR *prgbstr,
                             IDispatch *pDisp /* = NULL */)
{
    HRESULT hr = S_FALSE;

    // check the outgoing parameters.
    if (prgid == NULL || prgbstr == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // set to the same as lastid
    *prgid = id;
    *prgbstr = NULL;

    if (IsExpandoDISPID(id))
    {
        goto ExpandoRange;
    }

    // Try to get element properties
    if (!pDisp || (pDisp && ((id & 0xFFFF0000) == DISPID_XOBJ_BASE || id == DISPID_STARTENUM)))
    {
        hr = NextProperty(id, prgbstr, prgid);

        // If we found some properties in NextProperty then we want to start
        // enumerating properties in the activeX control starting at the beginning.
        // The function NextProperty will return S_FALSE and *prgid == id if the
        // last property from NextProperty is id otherwise *prgid == DISPID_UNKNOWN.
        if (hr == S_FALSE && pDisp && *prgid == id)
        {
            id = DISPID_STARTENUM;
        }
    }

    // If we didn't get the current dispid asked for then try the pDisp typeinfo
    // if that was passed.
    if (hr == S_FALSE && pDisp)
    {
        IDispatchEx *pDispEx = NULL;

        hr = THR(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx));
        if (S_OK == hr && pDispEx)
        {
            hr = THR(pDispEx->GetNextDispID(grfdex, id, prgid));
            ReleaseInterface(pDispEx);
        }
        else
            hr = NextTypeInfoProperty(pDisp, id, prgbstr, prgid);
    }

    // If we still don't have a current dispid asked for then try the expandos.
    if (hr == S_FALSE)
    {
        id = DISPID_STARTENUM;

ExpandoRange:
        hr = GetNextDispIDExpando(id, prgbstr, prgid);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);

}


HRESULT
CBase::NextTypeInfoProperty(
            IDispatch *pDisp,
            DISPID id,
            BSTR *pbstrName,
            DISPID *pid)
{
    HRESULT         hr = S_OK;
    ITypeInfo      *pTI = NULL;
    CTypeInfoNav    tin;
    BOOL            ffound = FALSE;

    *pid = DISPID_UNKNOWN;

    // TODO:    ***TLL*** Need optimization to have a special range for the
    //          object tag properties/attributes so we can ignore traversing
    //          activeX control properties and jump right to the CBase
    //          enumeration of expando or object tag/properties.

    if (pDisp)
    {
        // Loop thru ActiveX properties.
        hr = tin.InitIDispatch(pDisp, &pTI, 0);
        if (hr)
        {
            if (E_NOTIMPL == hr)
            {
                hr = S_FALSE;
            }
            goto Cleanup;
        }

        while ((hr = tin.Next()) == S_OK)
        {
            VARDESC    *pVar;
            FUNCDESC   *pFunc;

            if ((pVar = tin.getVarD()) != NULL)
            {
                if (!ffound)
                {
                    // Match or enumerating at beginning.
                    ffound = (pVar->memid == id) || (id == DISPID_STARTENUM);
                    if (ffound)
                    {
                        continue;
                    }
                }
                else
                {
                    // fill in the outgoing parameters
                    *pid = pVar->memid;
                    break;
                }
            }
            else if ((pFunc = tin.getFuncD()) != NULL)
            {
                if (!ffound)
                {
                    // Match or enumerating at beginning.
                    ffound = (pFunc->memid == id) || (id == DISPID_STARTENUM);
                    if (ffound)
                    {
                        continue;
                    }
                }
                else
                {
                    // Is the next a property get/put?
                    if ((pFunc->invkind == INVOKE_PROPERTYGET) ||
                        (pFunc->invkind == INVOKE_PROPERTYPUT))
                    {
                        // Might be 2 properties get/put
                        if (pFunc->memid != id)
                        {
                            // fill in the outgoing parameters
                            *pid = pFunc->memid;
                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }
                    else
                    {
                        // No, continue until we find a property.
                        continue;
                    }
                }
            }
        }

        // If we succeede on getting a property from ITypeInfo then get the name.
        if (!hr && *pid != DISPID_UNKNOWN && pbstrName)
        {
            UINT         cNames;

            hr = pTI->GetNames(*pid, pbstrName, 1, &cNames);
            if (hr)
                goto Cleanup;

            Assert(cNames == 1);
            goto Cleanup;   // Everything is okay just return.
        }
        else
        {
            if (hr && *pid == DISPID_UNKNOWN)
            {
                // Nothing more to find.
                hr = S_FALSE;
            }
        }
    }

Cleanup:
    ReleaseInterface(pTI);

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::AddExpando, helper
//
//  Synopsis:   Add an expando property to the attr array.
//
//  Results:    S_OK        - return dispid of found name
//              E_          - unable to add expando
//
//--------------------------------------------------------------------------

HRESULT
CBase::AddExpando (LPOLESTR pszExpandoName, DISPID *pdispID)
{
    HRESULT             hr;
    CAtomTable         *pat;
    BOOL                fExpando;

    pat = GetAtomTable(&fExpando);
    if (!pat || !fExpando)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = pat->AddNameToAtomTable(pszExpandoName, pdispID);
    if (hr)
        goto Cleanup;

    // Make it an expando range.
    *pdispID += DISPID_EXPANDO_BASE;
    if (*pdispID > DISPID_EXPANDO_MAX)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        *pdispID = DISPID_UNKNOWN;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::SetExpando, helper
//
//  Synopsis:   Set an expando property to the attr array.
//
//--------------------------------------------------------------------------

HRESULT
CBase::SetExpando(LPOLESTR pszExpandoName, VARIANT * pvarPropertyValue)
{
    HRESULT hr;
    DISPID dispIDExpando;
    AAINDEX aaIdx;

    hr = AddExpando(pszExpandoName, &dispIDExpando);
    if (hr)
        goto Cleanup;

    aaIdx = FindAAIndex(dispIDExpando, CAttrValue::AA_Expando);
    if (aaIdx == AA_IDX_UNKNOWN)
        hr = AddVariant(dispIDExpando, pvarPropertyValue, CAttrValue::AA_Expando);
    else
        hr = ChangeVariantAt(aaIdx, pvarPropertyValue);

Cleanup:
    RRETURN(hr);
}


HRESULT
CBase::GetNextDispIDExpando(DISPID currDispID, BSTR *pStrNextName, DISPID *pNextDispID)
{
    HRESULT     hr = S_FALSE;
    AAINDEX     aaNextIdx;

    // Assumption at this point is that expandos are always unique.  Multiple
    // DISPIDs for AA_Expando is not valid.  If the currDispID is 0 then get
    // first occurrance otherwise get the next attribute after the currDispID.

    // Are we looking to return a name if so then currDispID needs to be
    // valid.
    if (currDispID == DISPID_STARTENUM)
    {
        // We need index of first expando.
        aaNextIdx = FindAAIndex(DISPID_UNKNOWN, CAttrValue::AA_Expando);
    }
    else
    {
        // Get index of current dispid.
        aaNextIdx = FindAAIndex(currDispID, CAttrValue::AA_Expando, AA_IDX_UNKNOWN);
        // Compute next expando.
        aaNextIdx = FindAAIndex(DISPID_UNKNOWN, CAttrValue::AA_Expando, aaNextIdx);
    }

    *pNextDispID = GetDispIDAt(aaNextIdx);

    if (*pNextDispID != DISPID_UNKNOWN)
    {
        // Look in Expando for this property.
        CAtomTable     *pat;
        LPCTSTR         pch = NULL;
        DISPID          didOffset;

        pat = GetAtomTable();
        if (!pat)
            goto Cleanup;

        // Compute which kind of expando it is ActiveX or element.
        didOffset = (*pNextDispID >= DISPID_ACTIVEX_EXPANDO_BASE &&
                     *pNextDispID <= DISPID_ACTIVEX_EXPANDO_MAX ) ?
                            DISPID_ACTIVEX_EXPANDO_BASE :
                            DISPID_EXPANDO_BASE;

        hr = THR_NOTRACE(pat->GetNameFromAtom(
                        *pNextDispID - didOffset, &pch));
        if (hr)
            goto Cleanup;

        if (pStrNextName)
        {
            hr = FormsAllocString(pch, pStrNextName);
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // End of expando.
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT CBase::GetExpandoName ( DISPID expandoDISPID, LPCTSTR *lpPropName )
{
    HRESULT hr;

    Assert ( expandoDISPID >= DISPID_EXPANDO_BASE );

    // Get the name associated with the expando DISPID
    CAtomTable *pat = GetAtomTable();

    if (!pat)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }
    // When we put the dispid in the attr array we offset it by the expando base
    hr = THR(pat->GetNameFromAtom ( expandoDISPID-DISPID_EXPANDO_BASE, lpPropName ));
Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::NextProperty, helper
//
//  Synopsis:   Loop through all property entries in ITypeInfo then enumerate
//              through all expando properties.  Any DISPID handed out here
//              must stay constant (GetIDsOfNamesEx should hand out the
//              same).  This routines enumerates regular properties and expando.
//
//  Results:
//              S_OK        - returns next DISPID after currDispID
//              S_FALSE     - enumeration is done
//              E_nnnn      - call failed.
//--------------------------------------------------------------------------

HRESULT
CBase::NextProperty (DISPID currDispID, BSTR *pStrNextName, DISPID *pNextDispID)
{
    HRESULT     hr = S_FALSE;

    Assert(pNextDispID);

    // Initialize to not found.  If result is S_FALSE and pNextDispID is
    // currDispID then the last known item was a property found in this routine,
    // however there isn't another property after this one.  If pNextDispID is
    // DISPID_UNKNOWN then the last known property wasn't fetched from this
    // routine.  This is important for activex controls so we know when to ask
    // for first property versus next property.
    *pNextDispID = DISPID_UNKNOWN;

    if (IsExpandoDISPID(currDispID))
    {
        goto Cleanup;
    }

    // Enumerate thru attributes and properties.
    if (pStrNextName)
    {
        BOOL                    fPropertyFound = FALSE;
        DWORD                   dwppFlags;
        CPtrBagVTableAggregate::CIterator vTableAggregateIterator(GetStringTableAggregate());

        for (vTableAggregateIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableAggregateIterator.End(); vTableAggregateIterator.Next())
        {
            const VTABLEDESC       *pVTblDesc;
            const PROPERTYDESC     *ppropdesc;

            pVTblDesc = vTableAggregateIterator.Item();

            ppropdesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
            Assert(ppropdesc);

            dwppFlags = ppropdesc->GetPPFlags();

            // Only iterate over properties and items which are not hidden.
            if ((dwppFlags & (PROPPARAM_INVOKEGet | PROPPARAM_INVOKESet)) == 0 ||
                (dwppFlags & PROPPARAM_HIDDEN))
                 continue;

            // Get the first property.
            if (currDispID == DISPID_STARTENUM)
            {
                fPropertyFound = TRUE;
            }
            else if (currDispID == ppropdesc->GetDispid())
            {
                // Found a match get the next property.
                fPropertyFound = TRUE;
                *pNextDispID = currDispID;  // Signal we found last one now we
                                            // we need to look for next property.
                 continue;
            }

            // Look at this propertydesc?
            if (fPropertyFound)
            {
                // Yes, we're either the first one or this is the dispid we're
                // looking for.

                const TCHAR * pstr = ppropdesc->pstrExposedName ?
                                         ppropdesc->pstrExposedName :
                                         ppropdesc->pstrName;

                // If property has a leading underscore then don't display.
                if (pstr[0] == _T('_'))
                    continue;

                // allocate the result string
                *pStrNextName = SysAllocString(pstr);
                if (*pStrNextName == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                // We're returning this ID.
                *pNextDispID = ppropdesc->GetDispid();

                hr = S_OK;
                break;
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

AAINDEX
CBase::FindNextAttach(int idx, DISPID dispID)
{
    AAINDEX     aaidx = AA_IDX_UNKNOWN;
    int         cAttachEvts = 0;

    for (;;)
    {
        aaidx = FindNextAAIndex(dispID, CAttrValue::AA_AttachEvent, aaidx);
        if (aaidx == AA_IDX_UNKNOWN || idx == cAttachEvts)
            break;

        cAttachEvts++;
    };

    return aaidx;
}


HRESULT 
CBase::FindEventName(ITypeInfo *pTISrc, DISPID dispid, BSTR *pBSTR)
{
    int         ievt;
    int         cbEvents;
    UINT        cbstr;
    HRESULT     hr;
    FUNCDESC   *pFDesc = NULL;
    TYPEATTR   *pTAttr = NULL;

    Assert(pTISrc);
    Assert(pBSTR);

    *pBSTR = NULL;

    hr = pTISrc->GetTypeAttr(&pTAttr);
    if (hr)
        goto Cleanup;

    if (pTAttr->typekind != TKIND_DISPATCH)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // Total events.
    cbEvents = pTAttr->cFuncs;
    if (cbEvents == 0)
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // Populate the event table.
    for (ievt = 0; ievt < cbEvents; ++ievt)
    {
        hr = pTISrc->GetFuncDesc(ievt, &pFDesc);
        if (hr)
            goto Cleanup;

        // Did we find the event that fired?
        if (dispid == pFDesc->memid)
        {
            // Yes, so return the name.
            hr = pTISrc->GetNames(dispid, pBSTR, 1, &cbstr);
            goto Cleanup;
        }

        pTISrc->ReleaseFuncDesc(pFDesc);
        pFDesc = NULL;
    }

    hr = S_OK;

Cleanup:
    if (pFDesc)
        pTISrc->ReleaseFuncDesc(pFDesc);
    if (pTAttr)
        pTISrc->ReleaseTypeAttr(pTAttr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEvent, public
//
//  Synopsis:   Fires an event out the primary dispatch event connection point
//              and using the corresponding code pointers living in attr array
//
//  Arguments:  dispidEvent     Dispid of the event to fire
//              dispidProp      Dispid of property where event func is stored
//              pvarResult      Where to store the return value
//              pdispparams     Parameters for Invoke
//              pexcepinfo      Any exception info
//              puArgErr        Error argument
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

enum EVENTTYPE {
    EVENTTYPE_EMPTY = 0,
    EVENTTYPE_OLDSTYLE = 1,
    EVENTTYPE_VBHOOKUP = 2
};

enum EVENT_TYPE { VB_EVENTS, CPC_EVENTS };

HRESULT 
CBase::InvokeEvent(
    DISPID dispidEvent, 
    DISPID dispidProp, 
    IDispatch *pEventObject,
    VARIANT *pvarResult, 
    DISPPARAMS *pdispparams/* = NULL*/,
    EXCEPINFO *pexcepinfo/* = NULL*/,
    UINT *puArgErr/* = NULL*/,
    ITypeInfo *pTIEventSrc/* = NULL*/,
    IDispatch * pdispThis/* = NULL*/)
{
    AAINDEX                         aaidx;
    HRESULT                         hr = S_OK;
    IDispatch *                     pDisp = NULL;
    CVariant                        Var;
    CStackPtrAry<IDispatch *, 2>    arySinks(Mt(CBaseFireEventAry_pv));
    CStackDataAry<WORD, 2>          arySinkType(Mt(CBaseFireTypeAry_pv)); 
    long                            i;
    VARIANT                         varEO;                  // Don't release.
    VARIANT                        *pVarEventObject;
    CDispParams                     dispParams;
    BOOL                            f_CPCEvents = FALSE;
    EVENT_TYPE                      whichEventType;
    CExcepInfo                      ei;
    UINT                            uArgErr;
    DISPPARAMS                      dp = {NULL, NULL, 0, 0};

    if (!pdispparams)
        pdispparams = &dp;

    if (!pexcepinfo)
        pexcepinfo = &ei;

    if (!puArgErr)
        puArgErr = &uArgErr;

    if (pvarResult)
    {
        VariantInit(pvarResult);
    }
    
    //
    //
    // First fire off any properties bound to this event.
    //

    if (dispidProp != DISPID_UNKNOWN)   // Skip property events
    {
        aaidx = FindAAIndex(dispidProp, CAttrValue::AA_Internal);
        if (AA_IDX_UNKNOWN != aaidx)
        {
            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (!hr && pDisp)
            {
                CAttrValue *pAV = GetAttrValueAt(aaidx);

                pVarEventObject = NULL;

                if (pAV)
                {
                    // If not old style event, and we have an eventObject and we're not firing the onError
                    // event which already has arguments then prepare to pass the event object as an
                    // argument.
                    if (!pAV->IsOldEventStyle() && pEventObject && dispidProp != DISPID_EVPROP_ONERROR)
                    {
                        V_VT(&varEO) = VT_DISPATCH;
                        V_DISPATCH(&varEO) = pEventObject;
                        pVarEventObject = &varEO;;
                    }
                }            

                hr = THR(InvokeDispatchWithThis(
                    pDisp,
                    pVarEventObject,
                    IID_NULL,
                    g_lcidUserDefault,
                    DISPATCH_METHOD,
                    pdispparams,
                    &Var,
                    pexcepinfo,
                    NULL,
                    pdispThis));

                ClearInterface(&pDisp);
        
                if (pvarResult)
                {
                    hr = THR(VariantCopy(pvarResult, &Var));
                    if (hr)
                        goto Cleanup;
                }
            }
        }

        // Fire any attach events.
        IGNORE_HR(InvokeAttachEvents(dispidProp, pdispparams, pvarResult, this, pexcepinfo, puArgErr, pEventObject));
    }

    //
    // Now fire off to anyone listening through the normal connection
    // points.  Remember that these are also just stored in the attr
    // array with a special internal dispid.
    //

    aaidx = AA_IDX_UNKNOWN;
    
    for (;;)
    {
        CAttrValue  *pAV;

        aaidx = FindNextAAIndex(
            DISPID_A_EVENTSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        Assert(!pDisp);

        pAV = GetAttrValueAt(aaidx);
        if (pAV)
        {
            if (OK(FetchObject(pAV, VT_UNKNOWN, (void **)&pDisp)) && pDisp)
            {
                WORD    wET;

                hr = THR(arySinks.Append(pDisp));
                if (hr)
                    goto Cleanup;

                wET  = pAV->IsOldEventStyle() ? EVENTTYPE_OLDSTYLE : EVENTTYPE_EMPTY;
                wET |= pAV->IsTridentSink()   ? EVENTTYPE_VBHOOKUP : EVENTTYPE_EMPTY;

                hr = THR(arySinkType.AppendIndirect(&wET, NULL));
                if (hr)
                    goto Cleanup;

                // Upon success arySinks takes over the ref of pDisp
                pDisp = NULL;
            }
        }
    }

    whichEventType = VB_EVENTS;

NextEventSet:

    for (i = 0; i < arySinks.Size(); i++)
    {
        DISPPARAMS *pPassedParams;

        VariantClear(&Var);
        
        // If not old style event, and we have an eventObject and we're not firing the onError
        // event which already has arguments then prepare to pass the event object as an
        // argument.
        if ((!(arySinkType[i] & EVENTTYPE_OLDSTYLE)) && pEventObject && dispidProp != DISPID_EVPROP_ONERROR)
        {
            // Only compute this once.
            if (dispParams.cArgs == 0)
            {
                UINT     uIdx;

                // Fix up pdispparam
                dispParams.Initialize(pdispparams->cArgs + 1, pdispparams->cNamedArgs);
                
                hr = dispParams.Create(pdispparams);
                if (hr)
                    goto Cleanup;

                // Now dispParams.cArgs is > 0.
                uIdx = dispParams.cArgs - 1;

                V_VT(&varEO) = VT_DISPATCH;
                V_DISPATCH(&varEO) = pEventObject;

                memcpy(&(dispParams.rgvarg[uIdx]), &varEO, sizeof(VARIANT));
            }

            pPassedParams = &dispParams;
        }
        else
            pPassedParams = pdispparams;

        if (arySinkType[i] & EVENTTYPE_VBHOOKUP)
        {
            // Are we firing VB_EVENTS?
            if (whichEventType == VB_EVENTS)
            {
                // Yes, so fire the event.
                PROPERTYDESC      *pDesc;
                ITridentEventSink *pTriSink = (ITridentEventSink *)(arySinks[i]);

                if (!FindPropDescFromDispID(dispidProp, (PROPERTYDESC **)&pDesc, NULL, NULL))
                {
                    LPCOLESTR pEventString = (LPCOLESTR)(pDesc->pstrExposedName ? pDesc->pstrExposedName
                                                                      : pDesc->pstrName);
                    IGNORE_HR(pTriSink->FireEvent(pEventString, pPassedParams, &Var, pexcepinfo));
                }
                else if (pTIEventSrc)
                {
                    BSTR    eventName;

                    hr = FindEventName(pTIEventSrc, dispidEvent, &eventName);

                    if (hr == S_OK && eventName)
                    {
                        // ActiveX events don't pass the eventObject argument.
                        IGNORE_HR(pTriSink->FireEvent(eventName, pdispparams, &Var, pexcepinfo));
                    }

                    FormsFreeString(eventName);
                }
            }
        }
        else
        {
            // Firing CPC events yet?
            if (whichEventType == CPC_EVENTS)
            {
                IGNORE_HR(arySinks[i]->Invoke(dispidEvent,
                                              IID_NULL,
                                              g_lcidUserDefault,
                                              DISPATCH_METHOD,
                                              pPassedParams,
                                              &Var,
                                              pexcepinfo,
                                              puArgErr));
            }
            else
            {
                // No, just flag we got some CPC events to fire.
                f_CPCEvents = TRUE;
            }
        }

        // If we had to pass the this parameter and we had more than
        // 1 parameter then copy the orginal back over (the args could have
        // been byref).
        if (pPassedParams != pdispparams && pPassedParams->cArgs > 1)
        {
            hr = dispParams.MoveArgsToDispParams(pdispparams, pdispparams->cArgs);
            if (hr)
                goto Cleanup;
        }

        //
        // Copy return value into pvarResult if there was one.
        //

        if (pvarResult && V_VT(&Var) != VT_EMPTY)
        {
            hr = THR(VariantCopy(pvarResult, &Var));
            if (hr)
                goto Cleanup;
        }
    }

    // Any CPC events?
    if (f_CPCEvents && whichEventType == VB_EVENTS)
    {
        // Yes, and we just finished VB Events so fire all CPC events.
        whichEventType = CPC_EVENTS;
        f_CPCEvents = FALSE;
        goto NextEventSet;
    }

    Assert((whichEventType == CPC_EVENTS && !f_CPCEvents) || whichEventType == VB_EVENTS);

Cleanup:
    ReleaseInterface(pDisp);
    arySinks.ReleaseAll();
    
    RRETURN(hr);
}


HRESULT 
CBase::InvokeAttachEvents(
    DISPID          dispidProp, 
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    CBase *         pDocAccessObject,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr,
    IDispatch      *pEventObj)
{
    int                             iNextIdx;
    IDispatch                      *pDisp = NULL;
    CVariant                        Var;
    AAINDEX                         aaidx;
    HRESULT                         hr = S_OK;
    VARIANT                         varEventObj;
    EXCEPINFO                       excepinfo;
    UINT                            uArgErr;
    CStackPtrAry<IDispatch *, 2>    arySinks(Mt(CBaseFireEventAry_pv));
    DISPPARAMS                      dp = {NULL, NULL, 0, 0};

    if (!pDocAccessObject)
        pDocAccessObject = this;

    if (!pdispparams)
        pdispparams = &dp;

    if (!pexcepinfo)
        pexcepinfo = &excepinfo;

    if (!puArgErr)
        puArgErr = &uArgErr;

    if (dispidProp != DISPID_UNKNOWN)   // Skip property events
    {
        // Fire all functions hooked via attachEvent.
        iNextIdx = 0;

        for (;;)
        {
            aaidx = FindNextAttach(iNextIdx, dispidProp);
            if (aaidx == AA_IDX_UNKNOWN)
                break;

            hr = THR(GetDispatchObjectAt(aaidx, &pDisp));
            if (hr)
                goto Cleanup;

            hr = THR(arySinks.Append(pDisp));
            if (hr)
                goto Cleanup;

            iNextIdx++;
        }

        V_DISPATCH(&varEventObj) = pEventObj;
        V_VT(&varEventObj) = VT_DISPATCH;

        // Fire the events:
        for (int i = 0; i < arySinks.Size(); i++)
        {
            if (arySinks[i])
            {
                hr = THR_NOTRACE(InvokeDispatchExtraParam(
                    arySinks[i],
                    IID_NULL,
                    g_lcidUserDefault,
                    DISPATCH_METHOD,
                    pdispparams,
                    &Var,
                    pexcepinfo,
                    NULL,
                    &varEventObj));

                if (pvarResult && V_VT(&Var) != VT_EMPTY)
                {
                    hr = THR(VariantCopy(pvarResult, &Var));
                    if (hr)
                        goto Cleanup;
                }
            }

            Var.Clear();
        }
    }

Cleanup:
    arySinks.ReleaseAll();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::FireEventV, public
//
//  Synopsis:   Fires an event out the primary dispatch event connection point
//              and using the corresponding code pointers living in attr array
//
//  Arguments:  [dispidEvent]  -- DISPID of event to fire
//              [dispidProp]   -- dispid of property where event ptr is stored
//              [pfRetVal]     -- Resultant boolean return value
//              [pbTypes]      -- Pointer to array giving the types of params
//              [...]          -- variable # of Parameters
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::FireEventV(
    DISPID          dispidEvent,
    DISPID          dispidProp,
    IDispatch    *  pEventObject,
    VARIANT_BOOL *  pfRetVal,
    const BYTE *    pbTypes,
    ...)
{
    HRESULT         hr;
    DISPPARAMS      dp;
    VARIANTARG      av[EVENTPARAMS_MAX];
    CExcepInfo      ei;
    UINT            uArgErr;
    va_list         valParms;
    CVariant        Var;

    va_start(valParms, pbTypes);

    dp.rgvarg = av;
    CParamsToDispParams(&dp, pbTypes, valParms);

    hr = THR(InvokeEvent(dispidEvent, dispidProp, pEventObject, &Var, &dp, &ei, &uArgErr));
    va_end(valParms);

    if (pfRetVal != NULL)
    {
        if (V_VT(&Var) == VT_BOOL) 
            *pfRetVal = V_BOOL(&Var);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::FirePropertyNotify, public
//
//----------------------------------------------------------------------------

HRESULT
CBase::FirePropertyNotify(DISPID dispid, BOOL fOnChanged)
{
    IPropertyNotifySink *   pPNS = NULL;
    HRESULT                 hr = S_OK;
    AAINDEX                 aaidx = AA_IDX_UNKNOWN;
    CStackPtrAry<IPropertyNotifySink *, 2>  arySinks(Mt(CBaseFirePropertyNotify_pv));
    long                    i;

    //
    // Take sinks local first, and then fire to avoid reentrancy problems.
    //
    
    for (;;)
    {
        aaidx = FindNextAAIndex(
            DISPID_A_PROPNOTIFYSINK, 
            CAttrValue::AA_Internal, 
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        Assert(!pPNS);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pPNS)) && pPNS)
        {
            hr = THR(arySinks.Append(pPNS));
            if (hr)
                goto Cleanup;

            pPNS = NULL;   // arySinks has taken over ref.
        }
    }

    for (i = 0; i < arySinks.Size(); i++)
    {
        if (fOnChanged)
        {
            IGNORE_HR(arySinks[i]->OnChanged(dispid));
        }
        else
        {
            hr = THR_NOTRACE(arySinks[i]->OnRequestEdit(dispid));
            if (!hr)
            {
                //
                // Somebody doesn't want the change.
                //
                break;
            }
        }
    }
    
Cleanup:
    ReleaseInterface(pPNS);
    arySinks.ReleaseAll();
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetEnabled
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = VB_TRUE;
    return DISP_E_MEMBERNOTFOUND;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetValid
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CBase::GetValid(VARIANT_BOOL * pfValid)
{
    if (!pfValid)
        RRETURN(E_INVALIDARG);

    *pfValid = VB_TRUE;
    return DISP_E_MEMBERNOTFOUND;
}


////////////////////////////////////////////////////////////////////////////////
//
//  AttrArray helpers:
//
////////////////////////////////////////////////////////////////////////////////


AAINDEX
CBase::FindAAType(CAttrValue::AATYPE aaType, AAINDEX lastIndex)
{
    AAINDEX newIdx = AA_IDX_UNKNOWN;

    if (_pAA)
    {
        int nPos;

        if (lastIndex == AA_IDX_UNKNOWN)
        {
            nPos = 0;
        }
        else
        {
            nPos = ++lastIndex;
        }

        while (nPos < _pAA->Size())
        {
            CAttrValue *pAV = (CAttrValue *)(*_pAA) + nPos;
            // Logical & so we can find more than one type
            if (pAV->AAType() == aaType)
            {
                newIdx = (AAINDEX)nPos;
                break;
            }
            else
            {
                nPos++;
            }
        }
    }
    return newIdx;
}


BOOL
CBase::DidFindAAIndexAndDelete (DISPID dispID, CAttrValue::AATYPE aaType)
{
    BOOL    fRetValue = TRUE;
    AAINDEX aaidx;

    aaidx = FindAAIndex (dispID, aaType);

    if (AA_IDX_UNKNOWN != aaidx)
        DeleteAt (aaidx);
    else
        fRetValue = FALSE;

    return fRetValue;
}


//+------------------------------------------------------------------------
//
//  Member:     CBase::FindNextAAIndex
//
//  Synopsis:   Find next AAIndex with given dispid and aatype
//
//  Arguments:  dispid      Dispid to look for
//              aatype      AAType to look for
//              paaIdx      The aaindex of the last entry, if AA_IDX_UNKNOWN
//                          will return the 
//
//-------------------------------------------------------------------------

AAINDEX
CBase::FindNextAAIndex(
    DISPID              dispid, 
    CAttrValue::AATYPE  aaType, 
    AAINDEX             aaIndex)
{
    CAttrValue *    pAV;

    if (AA_IDX_UNKNOWN == aaIndex)
    {
        return FindAAIndex(dispid, aaType, AA_IDX_UNKNOWN, TRUE);
    }

    aaIndex++;
    if (!_pAA || aaIndex >= (ULONG)_pAA->Size())
        return AA_IDX_UNKNOWN;

    pAV = _pAA->FindAt(aaIndex);
    if (!pAV || pAV->GetDISPID() != dispid || pAV->GetAAType() != aaType)
        return AA_IDX_UNKNOWN;

    return aaIndex;
}


HRESULT
CBase::GetStringAt(AAINDEX aaIdx, LPCTSTR *ppStr)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppStr);

    *ppStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            *ppStr = pAV->GetLPWSTR();
            hr = S_OK;
        }
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

HRESULT
CBase::GetIntoBSTRAt(AAINDEX aaIdx, BSTR *pbStr )
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(pbStr);

    *pbStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            hr = S_OK;
            switch ( pAV->GetAVType() )
            {
            case VT_LPWSTR:
                hr = THR(FormsAllocString ( pAV->GetLPWSTR(), pbStr ));
                break;

            default:
                {
                    VARIANT varDest;
                    VariantInit(&varDest);
                    VARIANT varSrc;
                    VariantInit(&varSrc);

                    pAV->GetAsVariantNC(&varSrc);
                    hr = THR(VariantChangeTypeSpecial ( &varDest, &varSrc, VT_BSTR ));
                    if ( hr )
                    {
                        VariantClear ( &varDest );
                        if ( hr == DISP_E_TYPEMISMATCH )
                            hr = S_FALSE;
                        goto Cleanup;
                    }
                    *pbStr = V_BSTR ( &varDest );
                }
                break;
            }
        }
    }
Cleanup:
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::GetIntoStringAt(AAINDEX aaIdx, BSTR *pbStr, LPCTSTR *ppStr)
{
    HRESULT             hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppStr);
    Assert (pbStr);

    *ppStr = NULL;
    *pbStr = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
            hr = pAV->GetIntoString( pbStr, ppStr );
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::GetPointerAt(AAINDEX aaIdx, void **ppv)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppv);

    *ppv = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            *ppv = pAV->GetPointer();
            hr = S_OK;
        }
    }

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

HRESULT
CBase::GetVariantAt(AAINDEX aaIdx, VARIANT *pVar, BOOL fAllowNullVariant)
{
    HRESULT             hr = S_OK;
    const CAttrValue   * pAV;

    Assert(pVar);

    // Don't have an attr array or attr value will return
    // NULL variant.  Note, this will result in the return result
    // being a null.

    // Any attr array?
    if (_pAA &&  ( ( pAV = _pAA->FindAt(aaIdx) ) != NULL ) )
    {
        hr = pAV->GetIntoVariant(pVar);
        if (hr && fAllowNullVariant)
        {
            pVar->vt = VT_NULL;
        }
    }
    else
    {
        if (fAllowNullVariant)
        {
            pVar->vt = VT_NULL;
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }

    RRETURN(hr);
}


HRESULT
CBase::FetchObject(CAttrValue *pAV, VARTYPE vt, void **ppvoid)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;

    Assert(ppvoid);

    // Found AttrValue?
    if (pAV)
    {
        if (pAV->GetAVType() == vt && vt == VT_UNKNOWN)
        {
            *ppvoid = (void *)pAV->GetUnknown();
            if (*ppvoid)
                pAV->GetUnknown()->AddRef();
        }
        else if (pAV->GetAVType() == vt && vt == VT_DISPATCH)
        {
            *ppvoid = (void *)pAV->GetDispatch();
            if (*ppvoid)
                pAV->GetDispatch()->AddRef();
        }

        hr = S_OK;
    }

    RRETURN(hr);
}


HRESULT
CBase::GetObjectAt(AAINDEX aaIdx, VARTYPE vt, void **ppvoid)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(ppvoid);

    // Don't have an attr array or attr value will return
    // NULL IUnknown *.
    *ppvoid = NULL;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        hr = FetchObject(pAV, vt, ppvoid);
    }

    RRETURN(hr);
}

#ifdef _WIN64
HRESULT
CBase::GetCookieAt(AAINDEX aaIdx, DWORD * pdwCookie)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    Assert(pdwCookie);

    // Don't have an attr array or attr value will return
    // NULL IUnknown *.
    *pdwCookie = 0;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        if (pAV)
        {
            *pdwCookie = pAV->GetCookie();
            hr = S_OK;
        }
    }

    RRETURN(hr);
}

HRESULT
CBase::SetCookieAt(AAINDEX aaIdx, DWORD dwCookie)
{
    HRESULT       hr = DISP_E_MEMBERNOTFOUND;
    CAttrValue   *pAV;

    // Any attr array?
    if (_pAA)
    {
        pAV = _pAA->FindAt(aaIdx);
        if (pAV)
        {
            pAV->SetCookie(dwCookie);
            hr = S_OK;
        }
    }

    RRETURN(hr);
}
#endif

CAttrValue::AATYPE
CBase::GetAAtypeAt(AAINDEX aaIdx)
{
    CAttrValue::AATYPE aaType = CAttrValue::AA_Undefined;

    // Any attr array?
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            aaType = pAV->GetAAType();
        }
    }

    return aaType;
}

UINT
CBase::GetVariantTypeAt(AAINDEX aaIdx)
{
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            return pAV->GetAVType();
        }
    }

    return VT_EMPTY;
}


HRESULT
CBase::AddSimple(DISPID dispID, DWORD dwSimple, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddAttrArray(DISPID dispID,
                  CAttrArray *pAttrArray,
                  CAttrValue::AATYPE aaType )
{
    VARIANT varNew;

    varNew.vt = CAttrValue::VT_ATTRARRAY;
    varNew.byref = pAttrArray;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddString(DISPID dispID, LPCTSTR pch, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddPointer(DISPID dispID, void *pValue, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_PTR;
    varNew.byref = pValue;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}

HRESULT
CBase::AddBSTR (DISPID dispID, LPCTSTR pch, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;
    HRESULT hr;

    varNew.vt = VT_BSTR;
    hr = THR(FormsAllocString ( pch, &V_BSTR(&varNew) ));
    if ( hr )
        goto Cleanup;

    hr = THR(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
    if ( hr )
    {
        FormsFreeString ( V_BSTR(&varNew) );
    }
Cleanup:
    RRETURN(hr);
}

HRESULT
CBase::AddVariant(DISPID dispID, VARIANT *pVar, CAttrValue::AATYPE aaType)
{
    RRETURN(CAttrArray::Set(&_pAA, dispID, pVar, NULL, aaType));
}


HRESULT
CBase::AddUnknownObject(DISPID dispID, IUnknown *pUnk, CAttrValue::AATYPE aaType)
{
    VARIANT varNew;

    varNew.vt = VT_UNKNOWN;

    varNew.punkVal = pUnk;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType));
}


//+---------------------------------------------------------------------------------
//
//  Member:     CBase::AddUnknownObjectMultiple
//
//  Synopsis:   Add an object to the attr array allowing for multiple
//              entries at this dispid.
//
//----------------------------------------------------------------------------------

HRESULT
CBase::AddUnknownObjectMultiple(
    DISPID dispID, 
    IUnknown *pUnk, 
    CAttrValue::AATYPE aaType,
    CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT var;
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pUnk;
    
    RRETURN(CAttrArray::Set(&_pAA, dispID, &var, NULL, aaType, wFlags, TRUE));
}


//+---------------------------------------------------------------------------------
//
//  Member:     CBase::AddDispatchObjectMultiple
//
//  Synopsis:   Add an object to the attr array allowing for multiple
//              entries at this dispid.
//
//----------------------------------------------------------------------------------

HRESULT
CBase::AddDispatchObjectMultiple(
    DISPID dispID, 
    IDispatch *pDisp, 
    CAttrValue::AATYPE aaType,
    CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT var;
    
    V_VT(&var) = VT_DISPATCH;
    V_UNKNOWN(&var) = pDisp;
    
    RRETURN(CAttrArray::Set(&_pAA, dispID, &var, NULL, aaType, wFlags, TRUE));
}


HRESULT
CBase::AddDispatchObject(DISPID dispID,
                         IDispatch *pDisp,
                         CAttrValue::AATYPE aaType,
                         CAttrValue::AAExtraBits wFlags/* = CAttrValue::AA_Extra_Empty*/)
{
    VARIANT varNew;

    varNew.vt = VT_DISPATCH;
    varNew.pdispVal = pDisp;

    RRETURN(CAttrArray::Set(&_pAA, dispID, &varNew, NULL, aaType, wFlags));
}


HRESULT
CBase::StoreEventsToHook(InlineEvts *pInlineEvts)
{
    HRESULT     hr = S_OK;
    CAttrValue *pAAHeader;

    if (!_pAA)
    {
        _pAA = new CAttrArray;
        if (!_pAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    pAAHeader = _pAA->EnsureHeader();
    if (pAAHeader)
    {
        pAAHeader->SetEventsToHook(pInlineEvts);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


InlineEvts *
CBase::GetEventsToHook()
{
    InlineEvts     *pEvts = NULL;
    CAttrValue     *pAAHeader;

    if (_pAA)
    {
        pAAHeader = _pAA->EnsureHeader(FALSE);
        if (pAAHeader)
        {
            pEvts = pAAHeader->GetEventsToHook();
        }
    }

    return pEvts;
}


HRESULT
CBase::ChangeSimpleAt(AAINDEX aaIdx, DWORD dwSimple)
{
    VARIANT varNew;

    varNew.vt = VT_I4;
    varNew.lVal = (long)dwSimple;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeStringAt(AAINDEX aaIdx, LPCTSTR pch)
{
    VARIANT varNew;

    varNew.vt = VT_LPWSTR;
    varNew.byref = (LPVOID)pch;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeUnknownObjectAt(AAINDEX aaIdx, IUnknown *pUnk)
{
    VARIANT varNew;

    varNew.vt = VT_UNKNOWN;
    varNew.punkVal = pUnk;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeDispatchObjectAt(AAINDEX aaIdx, IDispatch *pDisp)
{
    VARIANT varNew;

    varNew.vt = VT_DISPATCH;
    varNew.pdispVal = pDisp;

    RRETURN(_pAA ? _pAA->SetAt(aaIdx, &varNew) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeVariantAt(AAINDEX aaIdx, VARIANT *pVar)
{
    RRETURN(_pAA ? _pAA->SetAt(aaIdx, pVar) : DISP_E_MEMBERNOTFOUND);
}


HRESULT
CBase::ChangeAATypeAt(AAINDEX aaIdx, CAttrValue::AATYPE aaType)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;

    // Any attr array?
    if (_pAA)
    {
        CAttrValue     *pAV;

        pAV = _pAA->FindAt(aaIdx);
        // Found AttrValue?
        if (pAV)
        {
            pAV->SetAAType ( aaType );
            hr = S_OK;
        }
    }

    RRETURN(hr);
}

const VTABLEDESC *
CBase::FindVTableEntryForName (LPCTSTR szName, BOOL fCaseSensitive, WORD *pVTblOffset)
{
    const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate();
    const VTABLEDESC *pVTableDesc = NULL;

    if(pStringTableAggregate)
    {
        // Retrieve the VTableDesc
        if(fCaseSensitive)
        {
            pVTableDesc = pStringTableAggregate->GetCs(szName, VTABLEDESC_BELONGSTOOM);
        }
        else
        {
            pVTableDesc = pStringTableAggregate->GetCi(szName, VTABLEDESC_BELONGSTOOM);
        }
    }
    return pVTableDesc;
}


#define GETMEMBER_CASE_SENSITIVE    0x00000001
#define GETMEMBER_AS_SOURCE         0x00000002
#define GETMEMBER_ABSOLUTE          0x00000004

HRESULT STDMETHODCALLTYPE
CBase::getAttribute(BSTR bstrPropertyName, LONG lFlags, VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DISPID dispID;
    DISPPARAMS dp = g_Zero.dispparams;
    CVariant varNULL(VT_NULL);
    PROPERTYDESC *propDesc = NULL;
    IDispatchEx *pDEX = NULL;

    if ( !bstrPropertyName || !pvarPropertyValue )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pvarPropertyValue->vt = VT_NULL;

    hr = THR(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX ));
    if ( hr )
        goto Cleanup;

    hr = pDEX->GetDispID(bstrPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                fdexNameCaseSensitive : 0,
                         &dispID);
    if ( hr )
        goto Cleanup;

    // If we're asked for the SaveAs value - our best guess is to grab the attr array value. This won't
    // always work - but it's the best we can do!
    if ( lFlags & GETMEMBER_AS_SOURCE || lFlags & GETMEMBER_ABSOLUTE )
    {
        // Here we pretty much do what we do at Save time. The only difference is we don't do the GetBaseObject call
        // so certain re-directed properties won't work - e.g. the BODY onXXX properties
        if (IsExpandoDISPID(dispID, &dispID))
        {
            hr = GetIntoBSTRAt ( FindAAIndex ( dispID, CAttrValue::AA_Expando ),
                &V_BSTR(pvarPropertyValue) );
        }
        else
        {
            // Try the Unknown value first...
            hr = GetIntoBSTRAt ( FindAAIndex ( dispID, CAttrValue::AA_UnknownAttr ),
                &V_BSTR(pvarPropertyValue) );
            if ( hr == DISP_E_MEMBERNOTFOUND )
            {
                // No Unknown - try getting the attribute as it would be saved
                hr = FindPropDescFromDispID ( dispID, &propDesc, NULL, NULL );
                Assert(propDesc);
                if (!hr && propDesc->pfnHandleProperty)
                {
                    if (propDesc->pfnHandleProperty) 
                    {
                        hr = propDesc->HandleGetIntoAutomationVARIANT(this, pvarPropertyValue);

                        // This flag only works for URL properties we want to
                        // return the fully expanded URL.

                        if (lFlags & GETMEMBER_ABSOLUTE &&
#ifdef _MAC
                            propDesc->pfnHandleProperty == &PROPERTYDESC::HandleUrlProperty &&
#else
                            propDesc->pfnHandleProperty == PROPERTYDESC::HandleUrlProperty &&
#endif
                            !hr)
                        {
                            hr = ExpandedRelativeUrlInVariant(pvarPropertyValue);
                        }

                        goto Cleanup;
                    }
                    else
                        hr = DISP_E_UNKNOWNNAME;
                }
            }
        }
        
        if (!hr)
        {
            pvarPropertyValue->vt = VT_BSTR;
        }
    }
    else
    {
        // Need to check for an unknown first, because the regular get_'s will return
        // a default. No point in doing this if we're looking at an expando
        if (!IsExpandoDISPID(dispID))
        {
            hr = GetIntoBSTRAt(FindAAIndex(dispID, CAttrValue::AA_UnknownAttr),
                               &V_BSTR(pvarPropertyValue));
            // If this worked - we're done.
            if (!hr)
            {
                pvarPropertyValue->vt = VT_BSTR;
                goto Cleanup;
            }
        } 

        // See if we can get a regular property or expando
        hr = THR(pDEX->InvokeEx(dispID,
                                g_lcidUserDefault,
                                DISPATCH_PROPERTYGET,
                                &dp,
                                pvarPropertyValue,
                                NULL,
                                NULL));
    }


Cleanup:
    ReleaseInterface ( pDEX );
    if ( hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
    {
        // Couldn't find property - return a Null rather than an error
        hr = S_OK;
    }
    RRETURN ( SetErrorInfo ( hr ) );
}


HRESULT STDMETHODCALLTYPE
CBase::removeAttribute(BSTR strPropertyName, LONG lFlags, VARIANT_BOOL *pfSuccess)
{
    DISPID dispID;
    IDispatchEx *pDEX = NULL;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    if (THR_NOTRACE(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX )))
        goto Cleanup;

    if (THR_NOTRACE(pDEX->GetDispID(strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                                    fdexNameCaseSensitive : 0, &dispID)))
        goto Cleanup;

    if (!removeAttributeDispid(dispID))
        goto Cleanup;

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    ReleaseInterface ( pDEX );

    RRETURN ( SetErrorInfo ( S_OK ) );
}

// HACKHACK: part of the hack below we need to access these symbols
EXTERN_C const PROPERTYDESC_NUMPROP s_propdescCTableCellrowSpan;
EXTERN_C const PROPERTYDESC_NUMPROP s_propdescCTableCellcolSpan;

BOOL
CBase::removeAttributeDispid(DISPID dispid, const PROPERTYDESC *pPropDesc /*=NULL*/)
{
    AAINDEX aaIx;
    BOOL fExpando;
    CVariant varNULL(VT_NULL);

    if( pPropDesc )
    {
        Assert( pPropDesc->GetDispid() == dispid );
    }

    fExpando = IsExpandoDISPID( dispid );

    // make sure we have a prop desc
    if (!fExpando && !pPropDesc)
    {
        if (dispid == STDPROPID_XOBJ_STYLE)
        {
            pPropDesc = (PROPERTYDESC *)&s_propdescCElementstyle_Str;
        }
        else
        {
            const VTABLEDESC * pVtDesc = _pAA->FindInGINCache(dispid);
            AssertSz(pVtDesc, "And I thought we were guaranteed to get a nonzero VTABLEDESC because of a recent call to GetDisp");
            Assert(pVtDesc->pPropDesc);

            pPropDesc = pVtDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
            Assert(pPropDesc);
        }
    }

    // find aaIx
    if(dispid != STDPROPID_XOBJ_STYLE)
    {
        aaIx = FindAAIndex ( dispid, fExpando ?
                CAttrValue::AA_Expando :
                CAttrValue::AA_Attribute);
        if (aaIx == AA_IDX_UNKNOWN)
            return FALSE;
    }
    else
    {
        // We cannot delete the inline style object. It is created "on demand".
        // We need to remove it's attrarray that stored on the element.
        aaIx = FindAAIndex ( DISPID_INTERNAL_INLINESTYLEAA, CAttrValue::AA_AttrArray );

        if (aaIx == AA_IDX_UNKNOWN)
            return FALSE;

        CBase *pStyle = NULL;
        GetPointerAt(FindAAIndex(DISPID_INTERNAL_CSTYLEPTRCACHE,CAttrValue::AA_Internal), (void **)&pStyle);
        if (pStyle)
            pStyle->SetAttrArray(NULL);
    }


#ifndef NO_EDIT
    {
        BOOL fTreeSync = FALSE;
        BOOL fCreateUndo = (!fExpando || !g_fInVizAct2000) && QueryCreateUndo(TRUE, FALSE, &fTreeSync);

        // HACK (JHarding): VizAct 2000 gets confused if we undo expandos, so we have to disable it for them (99897)

        if( fCreateUndo || fTreeSync )
        {
            HRESULT     hr;
            CVariant    varOld;
            IDispatch * pDisp = NULL;

            hr = THR(PunkOuter()->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp));
            if (hr)
                goto UndoCleanup;

            // HACKHACK: (jbeda) Hack in response to IE6 bug # 29479.
            //           get_[row|col]Span and put_[row|col]Span are not
            //           symmetric.
            if (pPropDesc
                && (    pPropDesc == &(s_propdescCTableCellrowSpan.a)
                    ||  pPropDesc == &(s_propdescCTableCellcolSpan.a)))
            {
                PROPERTYDESC_NUMPROP *pnumprop = (PROPERTYDESC_NUMPROP*)pPropDesc;
                V_VT(&varOld) = pnumprop->b.vt;
                hr = THR(pnumprop->b.GetNumberProperty(&V_I4(&varOld), this, CVOID_CAST(GetAttrArray())));
                if (hr)
                    goto UndoCleanup;
            }
            else
            {

                hr = THR(GetDispProp(
                               pDisp,
                               dispid,
                               g_lcidUserDefault,
                               &varOld));
                if (hr)
                    goto UndoCleanup;
            }

            if( fTreeSync )
            {
                LogAttributeChange( dispid, &varOld, NULL );
            }

            if( fCreateUndo )
            {
                hr = THR(CreatePropChangeUndo(dispid, &varOld, NULL));
            }
            // Else CVariant destructor cleans up varOld

UndoCleanup:
            ReleaseInterface( pDisp ); 
        }
    }
#endif // NO_EDIT

    if (fExpando)
    {
        IGNORE_HR(UpdateDomAttrCollection(TRUE, dispid));

        // Etherize the DOM expando attr node if present.
        RemoveDOMAttrNode(dispid);
    }

    DeleteAt(aaIx);

    if ( !fExpando )
    {
        CLock Lock (this); // For OnPropertyChange

        // Need to fire a property change event
        if (THR(OnPropertyChange(dispid, pPropDesc->GetdwFlags())))
            return FALSE;
    }

    return TRUE;
}


HRESULT STDMETHODCALLTYPE
CBase::setAttribute(BSTR strPropertyName, VARIANT varPropertyValue, LONG lFlags)
{
    HRESULT hr;
    DISPID dispID;
    DISPPARAMS dp;
    EXCEPINFO   excepinfo;
    UINT uArgError;
    DISPID  dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    CVariant varNULL(VT_NULL);
    IDispatchEx *pDEX = NULL;
    VARIANT *pVar;

    // Implementation leverages the existing Invoke mechanism

    InitEXCEPINFO(&excepinfo);

    if ( !strPropertyName  )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(PrivateQueryInterface ( IID_IDispatchEx, (void**)&pDEX ));
    if ( hr )
        goto Cleanup;

    hr = THR ( pDEX->GetDispID (strPropertyName, lFlags & GETMEMBER_CASE_SENSITIVE ?
                                    fdexNameCaseSensitive | fdexNameEnsure: fdexNameEnsure, &dispID) );
    if ( hr )
        goto Cleanup;

    pVar = V_ISBYREF(&varPropertyValue) ? V_VARIANTREF(&varPropertyValue) :
                                          &varPropertyValue;

    dp.rgvarg = pVar;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;

    // See if it's accepted as a regular property or expando
    hr = THR ( pDEX->Invoke ( dispID,
                              IID_NULL,
                              g_lcidUserDefault,
                              DISPATCH_PROPERTYPUT,
                              &dp,
                              NULL,
                              &excepinfo,
                              &uArgError ) );

    if ( hr )
    {
        // Failed to parse .. make an unknown
        CVariant varBSTR;
        const PROPERTYDESC *ppropdesc;
        const BASICPROPPARAMS *bpp;

        CLock Lock (this); // For OnPropertyChange

        ppropdesc = FindPropDescForName ( strPropertyName );
        if ( !ppropdesc )
            goto Cleanup;

        // It seems sensible to only allow string values for unknowns so we can always
        // persist them.
        // Try to see if it parses as a valid value
        // Coerce it to a string...
        hr = THR(VariantChangeTypeSpecial ( &varBSTR, pVar, VT_BSTR, NULL, VARIANT_NOVALUEPROP ));
        if ( hr )
            goto Cleanup;

        // Add it as an unknown (invalid) value
        // SetString with fIsUnkown set to TRUE
        hr = CAttrArray::SetString ( &_pAA, ppropdesc,
            (LPTSTR)varBSTR.bstrVal, TRUE );
        if ( hr )
            goto Cleanup;

        bpp = (const BASICPROPPARAMS*)(ppropdesc+1);

        // Need to fire a property change event
        hr = THR(OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)ppropdesc));
    }

Cleanup:
    ReleaseInterface ( pDEX );
    FreeEXCEPINFO(&excepinfo);
    RRETURN ( SetErrorInfo ( hr ) );
}


BOOL
CBase::IsExpandoDISPID (DISPID dispid, DISPID *pOLESiteExpando /*= NULL*/)
{
    DISPID  tmpDispID;

    if (!pOLESiteExpando)
        pOLESiteExpando = &tmpDispID;

    if (dispid >= DISPID_EXPANDO_BASE &&
        dispid <= DISPID_EXPANDO_MAX)
    {
         *pOLESiteExpando = dispid;
    }
    else if (dispid >= DISPID_ACTIVEX_EXPANDO_BASE &&
             dispid <= DISPID_ACTIVEX_EXPANDO_MAX)
    {
        *pOLESiteExpando = (dispid - DISPID_ACTIVEX_EXPANDO_BASE) + DISPID_EXPANDO_BASE;
    }
    else
    {
        *pOLESiteExpando = dispid;
        return FALSE;
    }

    return TRUE;
}


HRESULT
CBase::toString(BSTR *bstrString)
{
    HRESULT    hr;
    DISPPARAMS dp = g_Zero.dispparams;
    CVariant   var;

    if ( !bstrString)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *bstrString = NULL;

     hr = THR ( Invoke ( DISPID_VALUE, IID_NULL, g_lcidUserDefault,
            DISPATCH_PROPERTYGET,  &dp, &var, NULL, NULL ) );
    if(hr)
        goto Cleanup;

    hr = var.CoerceVariantArg(VT_BSTR);
    if(hr)
        goto Cleanup;

    *bstrString = V_BSTR(&var);
    // Don't allow deletion of the BSTR
    V_VT(&var) = VT_EMPTY;
     
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

const CPtrBagVTableAggregate * 
CBase::GetStringTableAggregate(const CLASSDESC * pBaseDesc /*= NULL*/ ) 
{ 
    if (!pBaseDesc)
        pBaseDesc = BaseDesc();

    if ( pBaseDesc && pBaseDesc->_apHdlDesc ) 
        return pBaseDesc->_apHdlDesc->pStringTableAggregate;
    else
        return NULL;
}

template < UINT nway2pwr > class CNCache;
typedef CNCache < 3 >   C8Cache;


//+---------------------------------------------------------------
//
//  Member:     FindPropDescFromDispID (private)
//
//  Synopsis:   Find a PROPERTYDESC based on the dispid.
//
//  Arguments:  dispidMember    - PROPERTY/METHOD to find
//              ppDesc          - PROPERTYDESC/METHODDESC found
//              pwEntry         - Byte offset in v-table of virtual function
//
//  Returns:    S_OK            everything is fine
//              E_INVALIDARG    ppDesc is NULL
//              S_FALSE         dispidMember not found in PROPDESC array
//--------------------------------------------------------------------------

#define AUTOMATION_VTBL_ENTRIES   7     // Includes IUnknown + IDispatch functions

HRESULT
CBase::FindPropDescFromDispID(DISPID dispidMember, PROPERTYDESC **ppDesc, WORD *pwEntry, WORD *pwIIDIndex)
{
    HRESULT                     hr = S_OK;
    const VTABLEDESC           *pVTblDesc;
    C8Cache *                   pCache = NULL;
    const CBase::CLASSDESC *    pBaseDesc = NULL;
    WHEN_DBG(BOOL               fVerify = TRUE);

    if (!ppDesc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDesc = NULL;
    if (pwEntry)
        *pwEntry = 0;
    if (pwIIDIndex)
        *pwIIDIndex = 0;

    // Check cache before we try a linear search?
    pVTblDesc = _pAA ? _pAA->FindInGINCache(dispidMember) : NULL;


    // If that Didn't work, try the TLS hash/cache
    if (!pVTblDesc)
    {
        CHtPvPv *           pht = &TLS(htVTblDescDispIDCaches);

        pBaseDesc = BaseDesc();
        Assert( pBaseDesc );

        pCache = (C8Cache*)pht->Lookup( (void*)pBaseDesc );
        if (pCache)
        {
            if (pCache->Lookup( (DWORD_PTR)dispidMember, (DWORD_PTR*)&pVTblDesc ))
            {
                // set pCache to NULL so we don't try to cache again.
                pCache = NULL;
                goto Found;
            }
        }
        else
        {
            pCache = new C8Cache((DWORD_PTR)DISPID_UNKNOWN, 0x0);
            if (pCache)
            {
                HRESULT hr2 = pht->Insert( (void*)pBaseDesc, pCache );
                if (hr2)
                {
                    delete pCache;
                    pCache = NULL;
                }
            }
        }
    }

    if (!pVTblDesc)
    {
        WHEN_DBG(fVerify = FALSE);

        const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate(pBaseDesc);
        if(pStringTableAggregate)
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(pStringTableAggregate);
            const VTABLEDESC  *pVTblDescIter;
        
            for (vTableIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableIterator.End(); vTableIterator.Next())
            {
                const PROPERTYDESC *pPropDesc;

                pVTblDescIter = vTableIterator.Item();
                Assert(pVTblDescIter);

                pPropDesc = pVTblDescIter->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
                Assert(pPropDesc);

                if (dispidMember == pPropDesc->GetDispid())
                {
                    pVTblDesc = pVTblDescIter;

                    goto Found;
                }
            } // vTableIter loop
        } // pStringTableAggregate if
    }

Found:

#if DBG==1
    // We only do the verify if we used one of the caches (GINcache or hash/cache)
    if (fVerify)
    {
        const VTABLEDESC           *pVTblDescVerify = NULL;

        const CPtrBagVTableAggregate *pStringTableAggregate = GetStringTableAggregate(pBaseDesc);
        if(pStringTableAggregate)
        {
            CPtrBagVTableAggregate::CIterator vTableIterator(pStringTableAggregate);
            const VTABLEDESC  *pVTblDescIter;
        
            for (vTableIterator.Start(VTABLEDESC_BELONGSTOOM); !vTableIterator.End(); vTableIterator.Next())
            {
                const PROPERTYDESC *pPropDesc;

                pVTblDescIter = vTableIterator.Item();
                Assert(pVTblDescIter);

                pPropDesc = pVTblDescIter->FastGetPropDesc(VTABLEDESC_BELONGSTOOM);
                Assert(pPropDesc);

                if (dispidMember == pPropDesc->GetDispid())
                {
                    pVTblDescVerify = pVTblDescIter;
                    break;
                }
            } // vTableIter loop
        } // pStringTableAggregate if

        Assert( pVTblDescVerify == pVTblDesc );
    }
#endif


    if (pVTblDesc)
    {
        *ppDesc = const_cast<PROPERTYDESC *>(pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOOM));
        Assert(ppDesc);

        if (pwIIDIndex) 
            *pwIIDIndex = (USHORT)pVTblDesc->uVTblEntry >> 8;
        if (pwEntry)
            *pwEntry = ((pVTblDesc->uVTblEntry & 0xff) + AUTOMATION_VTBL_ENTRIES) * sizeof(void *);  // Adjust for IDispatch methods
    }
    else
    {
        hr = S_FALSE;
    }

    // Add to the cache -- even if we didn't find it!
    if (pCache)
        pCache->Cache( (DWORD_PTR)dispidMember, (DWORD_PTR)pVTblDesc );

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DeinitVTblDescDispIDCaches
//
//  Synopsis:   Clean up htVTblDescDispIDCaches
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void DeinitVTblDescDispIDCaches(THREADSTATE *pts)
{
    Assert(pts);

    C8Cache *   p8Cache;
    UINT        iIndex;

    for (p8Cache = (C8Cache *)(pts->htVTblDescDispIDCaches.GetFirstEntry(&iIndex)); 
         p8Cache;
         p8Cache = (C8Cache *)(pts->htVTblDescDispIDCaches.GetNextEntry(&iIndex)))
    {
        delete p8Cache;
    }

    pts->htVTblDescDispIDCaches.ReInit();
}

//+---------------------------------------------------------------------------------
//
//  Member:     DefaultMembers
//
//  Synopsis:   sets all class members defined in pdl as members (not attr array)
//              to default value specified in pdl
//
//----------------------------------------------------------------------------------

HRESULT
CBase::DefaultMembers()
{
    HRESULT hr = S_OK;
    CPtrBagVTableAggregate::CIterator vTableIterator(GetStringTableAggregate());
        
    for (vTableIterator.Start(VTABLEDESC_BELONGSTOPARSE); !vTableIterator.End(); vTableIterator.Next())
    {
        const VTABLEDESC *pVTblDesc = vTableIterator.Item();
        const PROPERTYDESC *pPropDesc = pVTblDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
        Assert(pPropDesc);

        const BASICPROPPARAMS *pbpp = (BASICPROPPARAMS *)(pPropDesc + 1);

        if (!(pbpp->dwPPFlags & PROPPARAM_ATTRARRAY))
        {
            hr = pPropDesc->Default(this);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN (hr);
}



const ENUMDESC g_enumdescFalseTrue = 
{ 2, 3, {
    { _T("False"),0},
    { _T("True"),-1},
} };


//+---------------------------------------------------------------------------------
//  Member:     GetEnumDescFromDispID - Helper for IPerPropertyBrowsing
//
//  Synopsis:   Returns the enumdesc for given property. It also returns an enumDesk
//                  for booleans
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetEnumDescFromDispID(DISPID dispID, const ENUMDESC **ppEnumDesc)
{
    PROPERTYDESC  * pPropDesc;
    HRESULT         hr;

    // Get the propertydesc by property dispid
    hr = THR(FindPropDescFromDispID(dispID, &pPropDesc, NULL, NULL));
    if(hr)
    {
        if(hr == S_FALSE)
            hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Check if the property is a boolean
    if(pPropDesc->GetBasicPropParams()->wInvFunc == IDX_GS_VARIANTBOOL || 
       pPropDesc->GetBasicPropParams()->wInvFunc == IDX_G_VARIANTBOOL)
    {
        // we have a boolean, return the special enumDesc for Booleans
        *ppEnumDesc = &g_enumdescFalseTrue;
    }
    else
    {    
         // Get the enumDesc
        *ppEnumDesc =  pPropDesc->GetEnumDescriptor();
        if(!(*ppEnumDesc) || !(*ppEnumDesc)->cEnums)
        {
            // No enum description and the property is not boolean, we need to fail
            hr = E_NOTIMPL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetDisplayString
//
//  Synopsis:   Returns the value of the property as a string
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetDisplayString(DISPID dispID, BSTR *pBstr)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    AAINDEX          idx;
    CAttrValue     * pAV = NULL;
    
    if(!pBstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pBstr = NULL;

    idx = FindAAIndex(dispID, CAttrValue::AA_Attribute);
    if(idx == AA_IDX_UNKNOWN)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if(_pAA)
    {
        pAV = _pAA->FindAt(idx);
    }

    if(!pAV)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    // Return the corresponding enum string
    hr = THR(pEnumDesc->StringFromEnum(pAV->GetLong(), pBstr));
    if(hr)
        goto Cleanup;
  
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::MapPropertyToPage
//
//  Synopsis:   We do not support this call
//--------------------------------------------------------------------------------

HRESULT 
CBase::MapPropertyToPage(DISPID dispID, CLSID *pClsid)
{
    if(pClsid)
        *pClsid = CLSID_NULL;
    RRETURN(SetErrorInfo(PERPROP_E_NOPAGEAVAILABLE));
}


//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetPredefinedStrings
//
//  Synopsis:   Returns a counted array of strings (LPOLESTR pointers) listing the
//                description of the allowable values that the specified property
//                can accept.
//              dispID - the property to use
//              pCaStringsOut - counted array of the possible property values
//              pCaCookiesOut - counted array of cookies that allow to get the
//                 associated string by calling GetPredefinedValue
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetPredefinedStrings(DISPID dispID, CALPOLESTR  *pCaStringsOut, CADWORD *pCaCookiesOut)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    BSTR           * pStrings = NULL;
    DWORD          * pCookies = NULL;
    LPOLESTR         szName;
    TCHAR          * tchName;
    int              nEnums = 0;
    int              nIndex = 0;
    
    if(!pCaStringsOut || !pCaCookiesOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    nEnums = pEnumDesc ->cEnums;

    // Allocate the memory for the array of strings    
    pStrings = (BSTR *)CoTaskMemAlloc(sizeof(BSTR) * nEnums);
    if(!pStrings)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Allocate memory for the array of cookies
    pCookies = (DWORD *)CoTaskMemAlloc(sizeof(DWORD) * nEnums);
    if(!pCookies)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Fill the arrays. We use enum indexes as cookies, so it is faster to look
    //  the string up using the cookies later
    for(nIndex = 0; nIndex < nEnums; nIndex++)
    {
        pCookies[nIndex] = nIndex;
        // For enums get the value from the enumdesc
        tchName = pEnumDesc->aenumpairs[nIndex].pszName;
        if(!(*tchName))
            tchName = _T("not set");

        hr = THR(TaskAllocString(tchName, &szName));
        if(hr)
            goto Cleanup;
        pStrings[nIndex] = szName;
    }
    
    // Set the number of values into the return structures
    pCaStringsOut->cElems = pCaCookiesOut->cElems = nEnums;
    // Set the array pointers
    pCaStringsOut->pElems = pStrings;
    pCaCookiesOut->pElems = pCookies;

Cleanup:
    if(hr)
    {   
        for(int i = 0; i < nIndex; i++)
            TaskFreeString(pStrings[i]);
        CoTaskMemFree(pStrings);
        CoTaskMemFree(pCookies);
    }

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}



//+---------------------------------------------------------------------------------
//  Member:     IPerPropertyBrowsing::GetPredefinedValue
//
//  Synopsis:   Returns a Variant containing the value of a property identified with 
//                dispID that is associated with a predefined string (enum) name
//                as returned from GetPredefinedStrings
//              dispID - the property to use
//              dwCookie - the value from GetPredefinedStrings
//              pVarOut - the return value
//--------------------------------------------------------------------------------

HRESULT 
CBase::GetPredefinedValue(DISPID dispID, DWORD dwCookie, VARIANT *pVarOut)
{
    HRESULT          hr;
    const ENUMDESC * pEnumDesc;
    int              nEnums;
    
    if(!pVarOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(GetEnumDescFromDispID(dispID, &pEnumDesc));
    if(hr)
        goto Cleanup;

    nEnums = pEnumDesc ->cEnums;

    if(dwCookie >= (DWORD)nEnums)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(&g_enumdescFalseTrue != pEnumDesc)
    {
        // Return string values for enums
        hr = THR(FormsAllocString(pEnumDesc->aenumpairs[dwCookie].pszName, &V_BSTR(pVarOut)));
        if(hr)
            goto Cleanup;
        V_VT(pVarOut) = VT_BSTR;
    }
    else
    {
        // For booleans return a VARIANT_BOOL
        Assert(dwCookie == 0 || dwCookie == 1);
        V_BOOL(pVarOut) = pEnumDesc->aenumpairs[dwCookie].iVal;
        V_VT(pVarOut) = VT_BOOL;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+-------------------------------------------------------------------------
//
//  Method:     MatchExactGetIDsOfNames, (exported helper used by shdocvw)
//
//  Synopsis:   Loop through all property entries in ITypeInfo does a case
//              sensitive match (GetIDsofNames is case insensitive).
//
//  Results:    S_OK                - return dispid of found name
//              DISP_E_UNKNOWNNAME  - name not found
//
//--------------------------------------------------------------------------
STDAPI
MatchExactGetIDsOfNames(ITypeInfo *pTI,
                        REFIID riid,
                        LPOLESTR *rgszNames,
                        UINT cNames,
                        LCID lcid,
                        DISPID *rgdispid,
                        BOOL fCaseSensitive)
{
    HRESULT         hr = S_OK;
    CTypeInfoNav    tin;
    STRINGCOMPAREFN pfnCompareString;

    if (cNames == 0)
        goto Cleanup;

    if (!IsEqualIID(riid, IID_NULL) || !pTI || !rgszNames || !rgdispid)
        RRETURN(E_INVALIDARG);

    pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpI;

    rgdispid[0] = DISPID_UNKNOWN;

    // Loop thru properties.
    hr = tin.InitITypeInfo(pTI);
    while ((hr = tin.Next()) == S_OK)
    {
        VARDESC        *pVar;
        FUNCDESC       *pFunc;
        DISPID          memid = DISPID_UNKNOWN;

        if ((pVar = tin.getVarD()) != NULL)
        {
            memid = pVar->memid;
        }
        else if ((pFunc = tin.getFuncD()) != NULL)
        {
            memid = pFunc->memid;
        }

        // Got a property?
        if (memid != DISPID_UNKNOWN)
        {
            BSTR            bstrName;
            unsigned int    cNameRet;

            // Get the name.
            hr = THR(pTI->GetNames(memid, &bstrName, 1, &cNameRet));
            if (hr)
                break;

            if (cNameRet == 1)
            {
                // Does it match?
                if (pfnCompareString(rgszNames[0], bstrName) == 0)
                {
                    rgdispid[0] = memid;
                    SysFreeString(bstrName);
                    break;
                }

                SysFreeString(bstrName);
           }
        }
    }

Cleanup:
    if (hr || rgdispid[0] == DISPID_UNKNOWN)
        hr = DISP_E_UNKNOWNNAME;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     attachEvent
//
//  Synopsis:   Adds an AA_AttachEvent entry to attrarray to support multi-
//              casting of onNNNNN events.
//
//--------------------------------------------------------------------------

HRESULT
CBase::attachEvent(BSTR bstrEvent, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    HRESULT         hr = S_OK;
    DISPID          dispid;
    IDispatchEx *   pDEXMe = NULL;
    
    if (!pDisp || !bstrEvent || IsPassivating())
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDEXMe));
    if (hr)
        goto Cleanup;
        
    //
    // TODO: (anandra) Always being case sensitive here.  Need to
    // check for VBS and be insensitive then.
    //
    
    hr = THR_NOTRACE(pDEXMe->GetDispID(bstrEvent, fdexNameCaseSensitive | fdexNameEnsure, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(AddDispatchObjectMultiple(dispid,
                                       pDisp,
                                       CAttrValue::AA_AttachEvent,
                                       CAttrValue::AA_Extra_OldEventStyle));

    // let opp know that an event was attached.
    IGNORE_HR(OnPropertyChange(DISPID_EVPROP_ONATTACHEVENT, 0));

Cleanup:
    if (pResult)
    {
        *pResult = hr ? VARIANT_FALSE : VARIANT_TRUE;
    }
    ReleaseInterface(pDEXMe);
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     detachEvent
//
//  Synopsis:   Loops through all AA_AttachEvent entries in the attrarray
//              and removes first entry who's COM identity is the same as
//              the pDisp passed in.
//
//--------------------------------------------------------------------------

HRESULT
CBase::detachEvent(BSTR bstrEvent, IDispatch *pDisp)
{
    AAINDEX         aaidx = AA_IDX_UNKNOWN;
    DISPID          dispid;
    IDispatch *     pThisDisp = NULL;
    HRESULT         hr = S_OK;
    IDispatchEx *   pDEXMe = NULL;
    
    if (!pDisp || !bstrEvent)
        goto Cleanup;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatchEx, (void **)&pDEXMe));
    if (hr)
        goto Cleanup;
        
    //
    // TODO: (anandra) Always being case sensitive here.  Need to
    // check for VBS and be insensitive then.
    //
    
    hr = THR_NOTRACE(pDEXMe->GetDispID(bstrEvent, fdexNameCaseSensitive, &dispid));
    if (hr)
        goto Cleanup;

    // Find event that has this function pointer.
    for (;;)
    {
        aaidx = FindNextAAIndex(dispid, CAttrValue::AA_AttachEvent, aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        ClearInterface(&pThisDisp);
        if (GetDispatchObjectAt(aaidx, &pThisDisp))
            continue;

        if (IsSameObject(pDisp, pThisDisp))
            break;
    };

    // Found item to delete?
    if (aaidx != AA_IDX_UNKNOWN)
    {
        DeleteAt(aaidx);
    }

Cleanup:
    ReleaseInterface(pThisDisp);
    ReleaseInterface(pDEXMe);
    RRETURN(SetErrorInfo(S_OK));
}


EVENTINFO::~EVENTINFO()
{
    delete _pParam ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\baseerr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseerr.cxx
//
//  Contents:   CBase error utilties implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfo
//
//  Synopsis:
//
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfo(HRESULT hr)
{
    PreSetErrorInfo();

    if (FAILED(hr))
    {
        ClearErrorInfo();
        CloseErrorInfo(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPGet
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoPGet(HRESULT hr, DISPID dispid)
{
    // No PreSetErrorInfo call needed on read-only operations.

    if (FAILED(hr))
    {
        ClearErrorInfo();
        CloseErrorInfoPGet(hr, dispid);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPSet
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoPSet(HRESULT hr, DISPID dispid)
{
    PreSetErrorInfo();

    if (FAILED(hr))
    {
        if (hr == E_INVALIDARG)
        {
            hr = CTL_E_INVALIDPROPERTYVALUE;
        }
        ClearErrorInfo();
        CloseErrorInfoPSet(hr, dispid);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::CloseErrorInfo
//
//  Synopsis:
//
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseErrorInfo(HRESULT hr)
{
    if (FAILED(hr))
    {
        Assert(BaseDesc()->_pclsid );
        ::CloseErrorInfo(hr, (BaseDesc()->_pclsid ? *BaseDesc()->_pclsid : 
                                                    CLSID_NULL));
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::CloseErrorInfo
//
//  Specific method for automation calls
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseErrorInfo(HRESULT hr, DISPID dispid, INVOKEKIND invkind)
{
    CErrorInfo *pEI;

    if (OK(hr))
        return hr;

    if ((pEI = GetErrorInfo()) != NULL)
    {
        pEI->_invkind = invkind;
        pEI->_dispidInvoke = dispid;
        if ( BaseDesc()->_piidDispinterface )
        {
            pEI -> _iidInvoke = *BaseDesc()->_piidDispinterface;
        }
        else
        {
            // rgardner If we don't have an IID what do we
            // do????
            return S_FALSE;
        }
    }

    return CloseErrorInfo(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfo
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfo(HRESULT hr, DISPID dispid, INVOKEKIND invkind, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if(ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfo(hr, dispid, invkind);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoBadValue
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfoBadValue(DISPID dispid, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if (ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfoPSet(E_INVALIDARG, dispid);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoPBadValue
//
//----------------------------------------------------------------------------

HRESULT __cdecl
CBase::SetErrorInfoPBadValue(DISPID dispid, UINT ids, ...)
{
    PreSetErrorInfo();

    va_list arg;
    CErrorInfo *pEI;

    ClearErrorInfo();

    if (ids && (pEI = GetErrorInfo()) != NULL)
    {
        va_start(arg, ids);
        pEI->SetTextV(EPART_SOLUTION, ids, &arg);
        va_end(arg);
    }

    return CloseErrorInfoPSet(CTL_E_INVALIDPROPERTYVALUE, dispid);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::SetErrorInfoInvalidArg
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetErrorInfoInvalidArg()
{
    PreSetErrorInfo();

    ClearErrorInfo();
    return CloseErrorInfo(E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\inc\dxtpriv.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\basemso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       src\core\cdbase\basemso.cxx
//
//  Contents:   Implementation of IOleCommandTarget
//
//  Classes:    CBase
//
//  Functions:
//
//  History:    12-Sep-95   JuliaC    Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRIVCID_H_
#define X_PRIVCID_H_
#include "privcid.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_DWNNOT_H_
#define X_DWNNOT_H_
#include "dwnnot.h"
#endif

DeclareTag(tagMsoCommandTarget, "IOleCommandTarget", "IOleCommandTarget methods in CBase")


//+-------------------------------------------------------------------------
//
//  IOleCommandTarget implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CBase::IsCmdGroupSupported, static
//
//  Synopsis:   Determine if the given command group is supported.
//
//--------------------------------------------------------------------------

BOOL
CBase::IsCmdGroupSupported(const GUID *pguidCmdGroup)
{
    return pguidCmdGroup == NULL || *pguidCmdGroup == CGID_MSHTML ||
            *pguidCmdGroup == CGID_ShellDocView || 
            *pguidCmdGroup == CGID_IWebBrowserPriv ||
            *pguidCmdGroup == CGID_ShortCut ||
            *pguidCmdGroup == CGID_Explorer ||
            *pguidCmdGroup == CGID_DownloadHost;
}

// The following enum is defined by classic MSHTML
enum 
{
    HTMLID_FIND         = 1,
    HTMLID_VIEWSOURCE   = 2,
    HTMLID_OPTIONS      = 3,
    NAMELESS_ENUM_Last_Enum
};


struct MAP 
{ 
    short idm; 
    USHORT usCmdID; 
};

static MAP amapCommandSet95[] =
{
    IDM_OPEN, OLECMDID_OPEN,
    IDM_NEW, OLECMDID_NEW,
    IDM_SAVE, OLECMDID_SAVE,
    IDM_SAVEAS, OLECMDID_SAVEAS,
    IDM_SAVECOPYAS, OLECMDID_SAVECOPYAS,
    IDM_PRINT, OLECMDID_PRINT,
    IDM_PRINTPREVIEW, OLECMDID_PRINTPREVIEW,
    IDM_SHOWPRINT, OLECMDID_SHOWPRINT,
    IDM_SHOWPAGESETUP, OLECMDID_SHOWPAGESETUP,
    IDM_PAGESETUP, OLECMDID_PAGESETUP,
    IDM_SETPRINTTEMPLATE, OLECMDID_SETPRINTTEMPLATE,
    IDM_GETPRINTTEMPLATE, OLECMDID_GETPRINTTEMPLATE,
    IDM_SPELL, OLECMDID_SPELL,
    IDM_PROPERTIES, OLECMDID_PROPERTIES,
    IDM_CUT, OLECMDID_CUT,
    IDM_COPY, OLECMDID_COPY,
    IDM_PASTE, OLECMDID_PASTE,
    IDM_PASTESPECIAL, OLECMDID_PASTESPECIAL,
    IDM_UNDO, OLECMDID_UNDO,
    IDM_REDO, OLECMDID_REDO,
    IDM_SELECTALL, OLECMDID_SELECTALL,
    IDM_CLEARSELECTION, OLECMDID_CLEARSELECTION,
    IDM_STOP, OLECMDID_STOP,
    IDM_REFRESH, OLECMDID_REFRESH,
    IDM_STOPDOWNLOAD, OLECMDID_STOPDOWNLOAD,
    IDM_ENABLE_INTERACTION, OLECMDID_ENABLE_INTERACTION,
    OLECMDID_ONUNLOAD, OLECMDID_ONUNLOAD,
    IDM_INFOVIEW_ZOOM, OLECMDID_ZOOM,
    IDM_INFOVIEW_GETZOOMRANGE, OLECMDID_GETZOOMRANGE,
    OLECMDID_DONTDOWNLOADCSS, OLECMDID_DONTDOWNLOADCSS,
    IDM_DELETE, OLECMDID_DELETE

};

static MAP amapPersistence[] =
{
    IDM_ONPERSISTSHORTCUT,     CMDID_INTSHORTCUTCREATE,
    IDM_SAVEASTHICKET,         CMDID_SAVEASTHICKET,
};

static MAP amapDownloadHost[] =
{
    IDM_DWNH_SETDOWNLOAD,      DWNHCMDID_SETDOWNLOADNOTIFY,
};

static MAP amapShellDocView[] =
{
    IDM_SHDV_FINALTITLEAVAIL,  SHDVID_FINALTITLEAVAIL,
    IDM_SHDV_MIMECSETMENUOPEN, SHDVID_MIMECSETMENUOPEN,
    IDM_SHDV_FONTMENUOPEN,     SHDVID_FONTMENUOPEN,
    IDM_SHDV_PRINTFRAME,       SHDVID_PRINTFRAME,
    IDM_SHDV_PUTOFFLINE,       SHDVID_PUTOFFLINE,
    IDM_SHDV_GOBACK,           SHDVID_GOBACK,
    IDM_SHDV_GOFORWARD,        SHDVID_GOFORWARD,
    IDM_SHDV_CANGOBACK,        SHDVID_CANGOBACK,
    IDM_SHDV_CANGOFORWARD,     SHDVID_CANGOFORWARD,
    IDM_SHDV_CANSUPPORTPICS,   SHDVID_CANSUPPORTPICS,
    IDM_SHDV_CANDEACTIVATENOW, SHDVID_CANDEACTIVATENOW,
    IDM_SHDV_DEACTIVATEMENOW,  SHDVID_DEACTIVATEMENOW,
    IDM_SHDV_NODEACTIVATENOW,  SHDVID_NODEACTIVATENOW,
    IDM_SHDV_SETPENDINGURL,    SHDVID_SETPENDINGURL,
    IDM_SHDV_ISDRAGSOURCE,     SHDVID_ISDRAGSOURCE,
    IDM_SHDV_DOCFAMILYCHARSET, SHDVID_DOCFAMILYCHARSET,
    IDM_SHDV_DOCCHARSET,       SHDVID_DOCCHARSET,
    IDM_SHDV_GETMIMECSETMENU,  SHDVID_GETMIMECSETMENU,
    IDM_SHDV_GETFONTMENU,      SHDVID_GETFONTMENU,
    IDM_SHDV_GETDOCDIRMENU,    SHDVID_GETDOCDIRMENU,
    IDM_SHDV_CANDOCOLORSCHANGE,SHDVID_CANDOCOLORSCHANGE,
    IDM_SHDV_ONCOLORSCHANGE,   SHDVID_ONCOLORSCHANGE,
    IDM_SHDV_ADDMENUEXTENSIONS,SHDVID_ADDMENUEXTENSIONS, // Context Menu Extensions
    IDM_SHDV_PAGEFROMPOSTDATA, SHDVID_PAGEFROMPOSTDATA,
    IDM_SHDV_WINDOWOPEN,       SHDVID_WINDOWOPEN,
};

static MAP amapExplorer[] =
{
    IDM_GETFRAMEZONE,     SBCMDID_MIXEDZONE, 
};

static MAP amapClassicMSHTML[] =
{
    IDM_FIND,                  HTMLID_FIND,
    IDM_VIEWSOURCE,            HTMLID_VIEWSOURCE,
    IDM_OPTIONS,               HTMLID_OPTIONS,
};


//+-------------------------------------------------------------------------
//
//  Method:     CBase::IDMFromCmdID, static
//
//  Synopsis:   Compute menu item identifier from command set and command id.
//
//--------------------------------------------------------------------------

int
CBase::IDMFromCmdID(const GUID *pguidCmdGroup, ULONG ulCmdID)
{
    MAP *pmap;
    int  cmap;

    if (pguidCmdGroup == NULL)
    {
        pmap = amapCommandSet95;
        cmap = ARRAY_SIZE(amapCommandSet95);
    }
    else if (*pguidCmdGroup == CGID_MSHTML)
    {

        // Command identifiers in the Forms3 command set map
        // directly to menu item identifiers.
        return ulCmdID;

    }
    else if (*pguidCmdGroup == CGID_ShellDocView)
    {
        pmap = amapShellDocView;
        cmap = ARRAY_SIZE(amapShellDocView);
    }
    else if (*pguidCmdGroup == CGID_IWebBrowserPriv)
    {
        pmap = amapClassicMSHTML;
        cmap = ARRAY_SIZE(amapClassicMSHTML);
    }
    else if (*pguidCmdGroup == CGID_Explorer)
    {
        pmap = amapExplorer;
        cmap = ARRAY_SIZE(amapExplorer);
    }
    else if (*pguidCmdGroup == CGID_ShortCut)
    {
        pmap = amapPersistence;
        cmap = ARRAY_SIZE(amapPersistence);
    }
    else if (*pguidCmdGroup == CGID_DownloadHost)
    {
        pmap = amapDownloadHost;
        cmap = ARRAY_SIZE(amapDownloadHost);
    }
    else
    {
        return IDM_UNKNOWN;
    }

    for (; --cmap >= 0; pmap++)
    {
        if (pmap->usCmdID == ulCmdID)
            return pmap->idm;
    }

    return IDM_UNKNOWN;
}


//+-------------------------------------------------------------------------
//
//  Method:     OLECMDIDFromIDM
//
//  Synopsis:   Compute standard command id from an idm.
//
//--------------------------------------------------------------------------

BOOL
OLECMDIDFromIDM(int idm, ULONG *pulCmdID)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(amapCommandSet95); i++)
    {
        if (amapCommandSet95[i].idm == idm)
        {
            *pulCmdID = amapCommandSet95[i].usCmdID;
            return TRUE;
        }
    }

    return FALSE;
}


// Table used to to translate command names to command IDs and get command value return types
// Notice that the last element defines the default cmdID and vt returned when the item is not found

// *******
// NOTE: If you add a command that is clipboard related and should be checked by the security
// manager, make sure to add to the inclusion list in CMarkup::AllowClipboardAccess.
// *******

const CBase::CMDINFOSTRUCT CBase::cmdTable[] =
{
        _T("AutoDetect"),           IDM_AUTODETECT,
        _T("CreateBookmark"),       IDM_BOOKMARK,
        _T("CreateLink"),           IDM_HYPERLINK,
        _T("InsertImage"),          IDM_IMAGE,
        _T("Bold"),                 IDM_BOLD,
        _T("TristateBold"),         IDM_TRISTATEBOLD,
        _T("BrowseMode"),           IDM_BROWSEMODE,
        _T("EditMode"),             IDM_EDITMODE,
        _T("InsertButton"),         IDM_BUTTON,
        _T("InsertIFrame"),         IDM_IFRAME,
        _T("InsertInputButton"),    IDM_INSINPUTBUTTON,
        _T("InsertInputCheckbox"),  IDM_CHECKBOX,
        _T("InsertInputImage"),     IDM_INSINPUTIMAGE,
        _T("InsertInputRadio"),     IDM_RADIOBUTTON,
        _T("InsertInputText"),      IDM_TEXTBOX,
        _T("InsertSelectDropdown"), IDM_DROPDOWNBOX,
        _T("InsertSelectListbox"),  IDM_LISTBOX,
        _T("InsertTextArea"),       IDM_TEXTAREA,
#ifdef NEVER        
        _T("InsertHtmlArea"),       IDM_HTMLAREA,
#endif        
        _T("Italic"),               IDM_ITALIC,
        _T("TristateItalic"),       IDM_TRISTATEITALIC,
        _T("SizeToControl"),        IDM_SIZETOCONTROL,
        _T("SizeToControlHeight"),  IDM_SIZETOCONTROLHEIGHT,
        _T("SizeToControlWidth"),   IDM_SIZETOCONTROLWIDTH,
        _T("Underline"),            IDM_UNDERLINE,
        _T("TristateUnderline"),    IDM_TRISTATEUNDERLINE,
        _T("Copy"),                 IDM_COPY,
        _T("Cut"),                  IDM_CUT,
        _T("Delete"),               IDM_DELETE,
        _T("Print"),                IDM_EXECPRINT,
        _T("JustifyCenter"),        IDM_JUSTIFYCENTER,
        _T("JustifyFull"),          IDM_JUSTIFYFULL,
        _T("JustifyLeft"),          IDM_JUSTIFYLEFT,
        _T("JustifyRight"),         IDM_JUSTIFYRIGHT,
        _T("JustifyNone"),          IDM_JUSTIFYNONE,
        _T("Paste"),                IDM_PASTE,
        _T("PlayImage"),            IDM_DYNSRCPLAY,
        _T("StopImage"),            IDM_DYNSRCSTOP,
        _T("InsertInputReset"),     IDM_INSINPUTRESET,
        _T("InsertInputSubmit"),    IDM_INSINPUTSUBMIT,
        _T("InsertInputFileUpload"),IDM_INSINPUTUPLOAD,
        _T("InsertFieldset"),       IDM_INSFIELDSET,
        _T("Unselect"),             IDM_CLEARSELECTION,
        _T("BackColor"),            IDM_BACKCOLOR,
        _T("ForeColor"),            IDM_FORECOLOR,
        _T("FontName"),             IDM_FONTNAME,
        _T("FontSize"),             IDM_FONTSIZE,
        _T("GetBlockFormats"),      IDM_GETBLOCKFMTS,
        _T("FormatBlock"),          IDM_BLOCKFMT,
        _T("Indent"),               IDM_INDENT,
        _T("InsertMarquee"),        IDM_MARQUEE,
        _T("InsertOrderedList"),    IDM_ORDERLIST,
        _T("InsertParagraph"),      IDM_PARAGRAPH,
        _T("InsertUnorderedList"),  IDM_UNORDERLIST,
        _T("Outdent"),              IDM_OUTDENT,
        _T("UIOutdent"),            IDM_UI_OUTDENT,
        _T("Redo"),                 IDM_REDO,
        _T("Refresh"),              IDM_REFRESH,
        _T("RemoveParaFormat"),     IDM_REMOVEPARAFORMAT,
        _T("RemoveFormat"),         IDM_REMOVEFORMAT,
        _T("SelectAll"),            IDM_SELECTALL,
        _T("StrikeThrough"),        IDM_STRIKETHROUGH,
        _T("Subscript"),            IDM_SUBSCRIPT,            
        _T("Superscript"),          IDM_SUPERSCRIPT,
        _T("Undo"),                 IDM_UNDO,
        _T("Unlink"),               IDM_UNLINK,
        _T("InsertHorizontalRule"), IDM_HORIZONTALLINE,
        _T("UnBookmark"),           IDM_UNBOOKMARK,
        _T("OverWrite"),            IDM_OVERWRITE,
        _T("InsertInputPassword"),  IDM_INSINPUTPASSWORD,
        _T("InsertInputHidden"),    IDM_INSINPUTHIDDEN,
        _T("DirLTR"),               IDM_DIRLTR,
        _T("DirRTL"),               IDM_DIRRTL,
        _T("BlockDirLTR"),          IDM_BLOCKDIRLTR,
        _T("BlockDirRTL"),          IDM_BLOCKDIRRTL,
        _T("InlineDirLTR"),         IDM_INLINEDIRLTR,
        _T("InlineDirRTL"),         IDM_INLINEDIRRTL,
        _T("SaveAs"),               IDM_SAVEAS,
        _T("Open"),                 IDM_OPEN,
        _T("Stop"),                 IDM_STOP,
        _T("MultipleSelection"),    IDM_MULTIPLESELECTION,
        _T("2D-Position"),          IDM_2D_POSITION,
        _T("AbsolutePosition"),     IDM_ABSOLUTE_POSITION,
        _T("LiveResize"),           IDM_LIVERESIZE,
        _T("KeepSelection"),        IDM_KEEPSELECTION,
        _T("RespectVisibilityInDesign"), IDM_RESPECTVISIBILITY_INDESIGN,
        _T("UnloadDocument"), IDM_UNLOADDOCUMENT,
        _T("ClearAuthenticationCache"), IDM_CLEARAUTHENTICATIONCACHE,
        NULL,                       0
};

// Translates command name into command ID. If the command is not found and the
//  command string starts with a digit the command number is used.
HRESULT 
CBase::CmdIDFromCmdName(BSTR bstrCmdName, ULONG *pcmdValue)
{
    int     i;
    HRESULT hr=S_OK;

    Assert(pcmdValue != NULL);
    *pcmdValue = 0;

    if(FormsIsEmptyString(bstrCmdName))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    i = 0;
    while(cmdTable[i].cmdName != NULL)
    {
        if(StrCmpIC(cmdTable[i].cmdName, bstrCmdName) == 0)
        {
            break;
        }
        i++;
    }
    if(cmdTable[i].cmdName != NULL)
    {
        // The command name was found, use the value from the table
        *pcmdValue = cmdTable[i].cmdID;
        if(*pcmdValue == 0)
            hr = E_INVALIDARG;
    }
    else
    {
        hr = E_INVALIDARG;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandSupported(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    ULONG           uCmdId;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = CmdIDFromCmdName(bstrCmdId, &uCmdId);
    if(hr == S_OK)
    {
        *pfRet = VB_TRUE;
    }
    else if(hr == E_INVALIDARG)
    {
        *pfRet = VB_FALSE;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandEnabled(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

   if(dwFlags == MSOCMDSTATE_NINCHED ||
      dwFlags == MSOCMDSTATE_UP || dwFlags == MSOCMDSTATE_DOWN)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandState(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

   if(dwFlags == MSOCMDSTATE_DOWN)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandIndeterm(const BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT         hr = S_OK;
    DWORD           dwFlags;

    if(pfRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfRet = VB_FALSE;

    hr = THR(QueryCommandHelper(bstrCmdId, &dwFlags, NULL));
    if(hr)
        goto Cleanup;

    if(dwFlags == MSOCMDSTATE_NINCHED)
    {
        *pfRet = VB_TRUE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandText(const BSTR bstrCmdId, BSTR *pcmdText)
{
    HRESULT     hr = S_OK;

    if(pcmdText == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pcmdText = NULL;

    hr = THR(QueryCommandHelper(bstrCmdId, NULL, pcmdText));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------

HRESULT
CBase::queryCommandValue(const BSTR bstrCmdId, VARIANT *pvarRet)
{
    HRESULT     hr = S_OK;
    DWORD       dwCmdId;

    if(pvarRet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantClear(pvarRet);
    if(hr)
        goto Cleanup;

    // Convert the command ID from string to number
    hr = THR(CmdIDFromCmdName(bstrCmdId, &dwCmdId));
    if(hr)
        goto Cleanup;

    // Set the appropriate variant type
    V_VT(pvarRet) = GetExpectedCmdValueType(dwCmdId);

    // Call QueryStatus instead of exec if the expected return value is boolean
    if(V_VT(pvarRet) == VT_BOOL)
    {
        MSOCMD msocmd;
        
        msocmd.cmdID = dwCmdId;
        msocmd.cmdf  = 0;

        hr = THR(QueryStatus(const_cast < GUID * > ( & CGID_MSHTML ),
                        1, &msocmd, NULL));
        if (hr)
            goto Cleanup;

        V_BOOL(pvarRet) = (msocmd.cmdf == MSOCMDSTATE_NINCHED || msocmd.cmdf == MSOCMDSTATE_DOWN)
                        ? VB_TRUE : VB_FALSE;
    }
    else
    {
        // Use exec to get the string on integer value

        // If GetExpectedCmdValueType returned a VT_BSTR we need to null out the value
        // VariantClear wont do that.  If the pvarRet passed in the VariantClear
        // the bstrVal would be bogus.
        V_BSTR(pvarRet) = NULL;

        hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                                ,dwCmdId, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, pvarRet));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member:     queryCommandHelper
//
//  Synopsis:   This function is called by QueryCommandXXX functions and does the
//              command ID conversions and returns the flags or the text for given
//              command. Only one of the return parameters must be not NULL.
//
//  Returns:    S_OK if the value is returned
//----------------------------------------------------------------------------

struct MSOCMDTEXT_WITH_TEXT
{
    MSOCMDTEXT   header;
    WCHAR        text[FORMS_BUFLEN];
};

HRESULT
CBase::QueryCommandHelper(const BSTR bstrCmdId, DWORD *cmdf, BSTR *pcmdText)
{
    HRESULT                 hr = S_OK;
    MSOCMD                  msocmd;
    MSOCMDTEXT_WITH_TEXT    msocmdtext;

    Assert((cmdf == NULL && pcmdText != NULL) || (cmdf != NULL && pcmdText == NULL));

    // initialize the values so in case of error we return a NULL pointer
    if(pcmdText != NULL)
    {
        *pcmdText = NULL;
    }
    else
    {
        *cmdf = 0L;
    }

    // Fill the command structure converting the command ID from string to number
    hr = CmdIDFromCmdName(bstrCmdId, &(msocmd.cmdID));
    if(hr)
        goto Cleanup;
    msocmd.cmdf  = 0;

    if(pcmdText != NULL)
    {
        msocmdtext.header.cmdtextf = MSOCMDTEXTF_NAME;
        msocmdtext.header.cwBuf    = FORMS_BUFLEN;
        msocmdtext.header.cwActual = 0;
    }
    else
    {
        msocmdtext.header.cmdtextf = MSOCMDTEXTF_NONE;
        msocmdtext.header.cwBuf    = 0;
        msocmdtext.header.cwActual = 0;
    }

    hr = THR(QueryStatus(const_cast < GUID * > ( & CGID_MSHTML ),
                    1, &msocmd, (MSOCMDTEXT *)&msocmdtext));
    if (hr)
        goto Cleanup;

    if(pcmdText != NULL)
    {
        // Ignore the  msocmd value, just return the text
        if(msocmdtext.header.cwActual > 0)
        {
             // Allocate the return string
            *pcmdText = SysAllocString(msocmdtext.header.rgwz);
            if(*pcmdText == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }
    else
    {
        // return the flags
        *cmdf = msocmd.cmdf;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     execCommand
//
//  Synopsis:   Executes given command
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CBase::execCommand(const BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT value)
{
    DWORD     dwCmdOpt;
    DWORD     dwCmdId;
    VARIANT * pValue = NULL;
    HRESULT   hr;
    
    // Translate the "show UI" flag into appropriate option
    dwCmdOpt = (showUI == VB_FALSE) 
            ? MSOCMDEXECOPT_DONTPROMPTUSER 
            : MSOCMDEXECOPT_PROMPTUSER;

    // Convert the command ID from string to number
    hr = THR_NOTRACE(CmdIDFromCmdName(bstrCmdId, &dwCmdId));
    if(hr)
        goto Cleanup;

    pValue = (V_VT(&value) == (VT_BYREF | VT_VARIANT)) ?
        V_VARIANTREF(&value) : &value;

    // Some functions do not check for empty or error type variants
    if (V_VT(pValue) == VT_ERROR || V_VT(pValue) == VT_EMPTY)
    {
        pValue = NULL;
    }

    hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                            ,dwCmdId, dwCmdOpt, pValue, NULL));

Cleanup:
    RRETURN(hr);
 }


//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------

HRESULT
CBase::execCommandShowHelp(const BSTR bstrCmdId)
{
    HRESULT   hr;
    DWORD     dwCmdId;

    // Convert the command ID from string to number
    hr = CmdIDFromCmdName(bstrCmdId, &dwCmdId);
    if(hr)
        goto Cleanup;

    hr = THR(Exec(const_cast < GUID * > ( & CGID_MSHTML )
                    , dwCmdId, MSOCMDEXECOPT_SHOWHELP, NULL, NULL));

Cleanup:
    RRETURN(hr);
}



// Returns the expected VARIANT type of the command value (like VT_BSTR for font name)
VARTYPE CBase::GetExpectedCmdValueType(ULONG uCmdID)
{
    // We do not need to set the pvarOut, except for IDM_FONTSIZE. But we still
    // use this logic to determine if we need to use the queryStatus or exec
    // to get the command value

    switch (uCmdID)
    {
        case IDM_FONTSIZE:
        case IDM_FORECOLOR:
        case IDM_BACKCOLOR:
            return VT_I4;

        case IDM_BLOCKFMT:
        case IDM_FONTNAME:
            return VT_BSTR;

        case IDM_GETBLOCKFMTS:
            return VT_ARRAY;           
    }

    return VT_BOOL;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecSetGetProperty and 
//              CBase::ExecSetGetKnownProp
//
//  Synopsis:   Helper functions for Exec(), it Set/Get a property for
//              control. pvarargIn, pvarargOut can both not NULL. they both
//              call CBase:: ExecSetGetHelper for the invoke logic.
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecSetGetProperty(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        UINT            uPropName,      // property name
        VARTYPE         vt)             // Parameter type
{
    HRESULT         hr = S_OK;
    IDispatch *     pDispatch = NULL;
    DISPID          dispid;

    // Invalid parameters
    if (!pvarargIn && !pvarargOut)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // try to turn the uPropName into a dispid for the property
    hr = THR_NOTRACE(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    // call the helper to do the work
    hr = THR_NOTRACE(ExecSetGetHelper(pvarargIn, pvarargOut, pDispatch, dispid, vt));

Cleanup:
    ReleaseInterface(pDispatch);
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}

HRESULT
CBase::ExecSetGetKnownProp(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        DISPID          dispidProp, 
        VARTYPE         vt)             // Parameter type
{
    HRESULT hr = S_OK;
    IDispatch *     pDispatch = NULL;

    // Invalid parameters?
    if (!pvarargIn && !pvarargOut)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // now get the IDispatch for *this*
    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatch, (void **)&pDispatch));
    if (hr)
        goto Cleanup;

    // now call the helper to do the work
    hr = THR_NOTRACE(ExecSetGetHelper(pvarargIn, pvarargOut, pDispatch, dispidProp, vt));

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}


HRESULT
CBase::ExecSetGetHelper(
        VARIANTARG *    pvarargIn,      // In parameter
        VARIANTARG *    pvarargOut,     // Out parameter
        IDispatch  *    pDispatch,      // the IDispatch for *this*
        DISPID          dispid,         // the property dispid
        VARTYPE         vt)             // Parameter type
{
    HRESULT      hr  =S_OK;
    DISPPARAMS   dp = g_Zero.dispparams;         // initialized be zero.
    DISPID       dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.

    // Set property
    if (pvarargIn)
    {
        // Fill in dp
        dp.rgvarg = pvarargIn;
        dp.rgdispidNamedArgs = &dispidPut;
        dp.cArgs = 1;
        dp.cNamedArgs = 1;

        hr = THR_NOTRACE(pDispatch->Invoke(
                dispid,
                IID_NULL,
                NULL,
                DISPATCH_PROPERTYPUT,
                &dp,
                NULL,
                NULL,
                NULL));

        if (hr)
            goto Cleanup;
    }

    // Get property
    if (pvarargOut)
    {
        // Get property requires different dp
        dp = g_Zero.dispparams;

        hr = THR_NOTRACE(pDispatch->Invoke(
                dispid,
                IID_NULL,
                NULL,
                DISPATCH_PROPERTYGET,
                &dp,
                pvarargOut,
                NULL,
                NULL));

        if (hr)
        {
            //
            // (EricVas) - This is a hack to prevent the member
            // not found from trickling up, causing a nasty message box to
            // appear
            //

            hr = OLECMDERR_E_DISABLED;

            goto Cleanup;
        }

        // Update the VT if necessary
        V_VT(pvarargOut) = vt;
    }

Cleanup:
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecToggleCmd
//
//  Synopsis:   Helper function for exec(). It is used for cmdidBold,
//              cmdidItalic, cmdidUnderline. It always toggle property
//              value.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecToggleCmd(UINT uPropName)       // Dipatch ID for command
{
    HRESULT         hr ;
    IDispatch *     pDispatch = NULL;
    DISPPARAMS      dp = g_Zero.dispparams;         // initialized be zero.
    DISPID          dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    VARIANT         var;
    DISPID          dispid;

    hr = THR(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    VariantInit(&var);
    V_VT(&var) = VT_BOOL;

    // Get property value
    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYGET,
            &dp,
            &var,
            NULL,
            NULL));
    if (hr)
        goto Cleanup;

    // Toggle property value
    V_BOOL(&var) = !V_BOOL(&var);

    // Fill in dp
    dp.rgvarg = &var;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;

    // Set new property value
    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL));

Cleanup:
    ReleaseInterface(pDispatch);
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::QueryStatusProperty
//
//  Synopsis:   Helper function for QueryStatus(), it determines if a control
//              supports a property by checking whether you can get property. .
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::QueryStatusProperty(
        MSOCMD *    pCmd,
        UINT        uPropName,
        VARTYPE     vt)
{
    HRESULT         hr;
    IDispatch *     pDispatch = NULL;
    CVariant        var;
    DISPPARAMS      dp = g_Zero.dispparams;         // initialized be zero.
    DISPID          dispid;

    hr = THR_NOTRACE(GetDispatchForProp(uPropName, &pDispatch, &dispid));
    if (hr)
        goto Cleanup;

    V_VT(&var) = vt;

    hr = THR_NOTRACE(pDispatch->Invoke(
            dispid,
            IID_NULL,
            NULL,
            DISPATCH_PROPERTYGET,
            &dp,
            &var,
            NULL,
            NULL));

Cleanup:
    if(!hr)
    {
        if(V_VT(&var) == VT_BOOL && V_BOOL(&var) == VB_TRUE)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
        else
            pCmd->cmdf = MSOCMDSTATE_UP;
    }
    if (DISP_E_UNKNOWNNAME == hr)
        hr = OLECMDERR_E_NOTSUPPORTED; // we listen for this error code
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::ExecSetPropertyCmd
//
//  Synopsis:   Helper function for Exec(), It is used for SpecialEffect
//              Commands, Justify (TextAlign). For these commands, there are
//              not input parameter.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------
HRESULT
CBase::ExecSetPropertyCmd(UINT uPropName, DWORD value)
{
    VARIANT     var;

    VariantInit(&var);
    V_VT(&var) = VT_I4;
    V_I4(&var) = value;

    return THR_NOTRACE(ExecSetGetProperty(&var, NULL, uPropName, VT_I4));
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetDispatchForProp
//
//  Synopsis:   Helper function for flavours of Exec()-s and QueryStatus()-es
//
//--------------------------------------------------------------------------

HRESULT
CBase::GetDispatchForProp(UINT uPropName, IDispatch ** ppDisp, DISPID * pdispid)
{
    HRESULT     hr;
    TCHAR       achPropName[64];
    LPTSTR      pchPropName = achPropName;
    int         nLoadStringRes;

    *ppDisp = NULL;

    hr = THR_NOTRACE(PrivateQueryInterface(IID_IDispatch, (void **)ppDisp));
    if (hr)
        goto Cleanup;

    nLoadStringRes = LoadString(GetResourceHInst(), uPropName, achPropName, ARRAY_SIZE(achPropName));
    if (0 == nLoadStringRes)
    {
        hr = THR(GetLastWin32Error());
        Assert (!OK(hr));
        goto Cleanup;
    }

    hr = THR_NOTRACE((*ppDisp)->GetIDsOfNames(IID_NULL, &pchPropName, 1, g_lcidUserDefault, pdispid));

Cleanup:
    if (hr)
        ClearInterface (ppDisp);

    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
// Method:      CTQueryStatus
//
// Synopsis:    Call IOleCommandTarget::QueryStatus on an object.
//
//--------------------------------------------------------------------------

HRESULT
CTQueryStatus(
        IUnknown *pUnk,
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    IOleCommandTarget * pCommandTarget;
    HRESULT             hr;

    if (!pUnk)
    {
        Assert(0);
        RRETURN(E_FAIL);
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(
            IID_IOleCommandTarget,
            (void**) &pCommandTarget));

    if (!hr)
    {
        hr = THR_NOTRACE(pCommandTarget->QueryStatus(
                pguidCmdGroup,
                cCmds,
                rgCmds,
                pcmdtext));
        pCommandTarget->Release();
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
// Method: CTExec
//
// Synopsis:    Call IOleCommandTarget::Exec on an object.
//
//--------------------------------------------------------------------------

HRESULT
CTExec(
        IUnknown *pUnk,
        const GUID * pguidCmdGroup,
        DWORD  nCmdID,
        DWORD  nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    IOleCommandTarget * pCommandTarget;
    HRESULT             hr;

    if (!pUnk)
    {
        Assert(0);
        RRETURN(E_FAIL);
    }

    hr = THR_NOTRACE(pUnk->QueryInterface(
            IID_IOleCommandTarget,
            (void**) &pCommandTarget));

    if (!hr)
    {
        hr = THR_NOTRACE(pCommandTarget->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
        pCommandTarget->Release();
    }

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\ipobj2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:       src\core\cdbase\ipobj2.cxx
//
//  Contents:   Implementation of IOleInPlaceObjectWindowless
//
//  Classes:    CServer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SERVER_HXX_
#define X_SERVER_HXX_
#include "server.hxx"
#endif

MtDefine(CDropTarget, ObjectModel, "CDropTarget")


// IDropTarget methods

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragEnter, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragEnter (
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    HRESULT hr = S_OK;

    if (pIDataSource==NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //  DragLeave will not always be called, since we bubble up to
    //    our container's DragEnter if we decide we don't like the
    //    data object offered.  As a result, we need to clear any
    //    pointers hanging around from the last drag-drop. (chrisz)

    ReplaceInterface(&_pInPlace->_pDataObj, pIDataSource);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragOver, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DragLeave, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DragLeave(BOOL fDrop)
{
    ClearInterface(&_pInPlace->_pDataObj);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Drop, IDropTarget
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Drop(
    IDataObject * pDataObject,
    DWORD grfKeyState,
    POINTL pt,
    DWORD * pdwEffect)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:   CDropTarget::CDropTarget
//
//  Synopsis: Point to CServer for D&D Method delegation
//
//----------------------------------------------------------------------------

CDropTarget::CDropTarget(CServer * pServer)
{
    _pServer = pServer;
    _ulRef = 1;
    pServer->SubAddRef();

    MemSetName((this, "CDropTarget _pServer=%08x", pServer));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDropTarget::~CDropTarget
//
//  Synopsis:
//
//-----------------------------------------------------------------------------

CDropTarget::~CDropTarget()
{

}

//+----------------------------------------------------------------------------
//
//  Member:     CDropTarget::QueryInterface
//
//  Synopsis:   Returns only IDropTarget and IUnknown interfaces. Does not
//              delegate QI calss to pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::QueryInterface (REFIID riid, void ** ppv)
{

    if( IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        *ppv = (IDropTarget *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;

}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::AddRef
//
//  Synopsis:   AddRefs the parent server
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDropTarget::AddRef()
{
    _pServer->SubAddRef();
    return ++_ulRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::Release
//
//  Synopsis:   Releases the parent server
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDropTarget::Release()
{
    _pServer->SubRelease();

    if (0 == --_ulRef)
    {
        delete this;
        return 0;
    }

    return _ulRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragEnter
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragEnter(
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    return _pServer->DragEnter(pIDataSource, grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragOver
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    return _pServer->DragOver (grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::DragLeave
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::DragLeave()
{
    return _pServer->DragLeave(FALSE);      // fDrop is FALSE
}

//+---------------------------------------------------------------------------
//
//  Member:     CDropTarget::Drop
//
//  Synopsis:   Delegates to _pServer
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDropTarget::Drop(
        IDataObject * pIDataSource,
        DWORD grfKeyState,
        POINTL pt,
        DWORD * pdwEffect)
{
    return _pServer->Drop(pIDataSource, grfKeyState, pt, pdwEffect);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDropTarget
//
//  Synopsis:   returns IDropTarget interface.
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDropTarget(IDropTarget ** ppDropTarget)
{
    HRESULT hr;

    if (!ServerDesc()->TestFlag(SERVERDESC_SUPPORT_DRAG_DROP))
    {
        *ppDropTarget = NULL;
        hr = E_NOTIMPL;
    }
    else
    {
        *ppDropTarget = new CDropTarget(this);
        hr =*ppDropTarget ? S_OK : E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\cache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cache.cxx
//
//  Contents:   CServer implmentation of IOleCache2
//
//  Classes:    CServer
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CServerEnumCacheAry, Locals, "CServer::EnumCache CDataAry<STATDATA>")
MtDefine(CServerEnumCacheAry_pv, CServerEnumCacheAry, "CServer::EnumCache CDataAry<STATDATA>::_pv")
DECLARE_CDataAry(CServerEnumCacheAry, STATDATA, Mt(CServerEnumCacheAry), Mt(CServerEnumCacheAry_pv))

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureCache, public
//
//  Synopsis:   Initializes the cache object by creating the default data
//              cache and initializing its storage if necessary.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::EnsureCache()
{
    HRESULT hr;

    //
    // Return immediatly if already initialized.
    //

    if (_pCache)
        return S_OK;

    hr = THR(CreateDataCache(NULL, CLSID_NULL, IID_IOleCache2,
            (void **)&_pCache));
    if (hr)
        goto Error;

    hr = THR(_pCache->QueryInterface(IID_IPersistStorage,
            (void **)&_pPStgCache));
    if (hr)
        goto Error;

    // QUESTION: Is it ok to ignore erros from pDefPstg methods called below?
    // If so, then use IGNORE_HR macro.

    if (_state >= OS_LOADED)
    {
        if (_pStg)
        {
            if (_fInitNewed)
            {
                _pPStgCache->InitNew(_pStg);
            }
            else
            {
                _pPStgCache->Load(_pStg);
                //
                // REVIEW - We fail if our container does a QI for IOleCache[2]
                // after calling Save() but before SaveCompleted().
                //
                if (_fNoScribble)
                {
                    TraceTag((tagError, "Attempt to QI for IOleCache(2) "
                                   "after a call to Save but before calling "
                                   "SaveCompleted!"));
                    TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
                    hr = E_UNEXPECTED;
                    goto Error;
                }
            }
        }
        else if (_fHandsOff)
        {
            //
            // REVIEW - The Ctrl object is in Hands-Off state.  A QI for
            // IOleCache[2] is illegal at this time.
            //
            TraceTag((tagError, "Attempt to QI for IOleCache(2) "
                           "after a call to HandsOffStorage but before calling "
                           "SaveCompleted!"));
            TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
            hr = E_UNEXPECTED;
            goto Error;
        }
        else
        {
            //  The control is using IPersistStreamInit which means we can't
            //  persist the cache data.  We have chosen to fail in this case,
            //  since the cache is not useful.
            //
            TraceTag((
                    tagError,
                    "Attempt to QI for IOleCache(2) on an "
                    "object which is being stored using IPersistStreamInit!"));
            TraceTag((tagError, "Fatal: Returning E_UNEXPECTED."));
            hr = E_UNEXPECTED;
            goto Error;
        }
    }

    hr = THR(_pCache->QueryInterface(IID_IViewObject2,
            (LPVOID*)&_pViewObjectCache));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    ClearInterface(&_pCache);
    ClearInterface(&_pPStgCache);
    ClearInterface(&_pViewObjectCache);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Cache, IOleCache
//
//  Synopsis:   Caches data
//
//  Arguments:  [petc]          -- Format to cache
//              [advf]          -- Cache flags
//              [pdwConnection] -- Place to put connection id.
//
//  Returns:    HRESULT
//
//  Notes:      As a DLL server, we normally do implicit caching of all our
//              data types.  The only exceptions are for the icon aspect and
//              if the ADVFCACHE_FORCEBUILTIN flag is specified.  Note that
//              the cache will not be persistent unless the container saves
//              us using a storage (as opposed to a stream).
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Cache(FORMATETC *petc, DWORD advf, DWORD *pdwConnection)
{
    HRESULT hr;

    if (petc == NULL)
        RRETURN(E_INVALIDARG);

    if (petc->lindex != -1)
        RRETURN(DV_E_LINDEX);

    if (pdwConnection)
        *pdwConnection = 0;

    if ((petc->cfFormat == 0) ||
        (FindCompatibleFormat(ServerDesc()->_pGetFmtTable,
                              ServerDesc()->_cGetFmtTable,
                              *petc) != -1))
    {
        if ((advf & ADVFCACHE_FORCEBUILTIN) ||
            (petc->dwAspect == DVASPECT_ICON))
        {
            hr = THR(EnsureCache());
            if (hr)
                goto Cleanup;

             hr = THR(_pCache->Cache(petc, advf, pdwConnection));
        }
        else
        {
            // Implicit data type, so we return S_OK with a connection ID of
            // zero.
            hr = S_OK;
        }
    }
    else
    {
        //
        // Not a recognized format.
        //

        hr = DV_E_CLIPFORMAT;
    }

Cleanup:
    RRETURN2(hr, CACHE_S_FORMATETC_NOTSUPPORTED, CACHE_S_SAMECACHE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::Uncache, IOleCache
//
//  Synopsis:   Uncaches a previously cached data type
//
//  Arguments:  [dwConnection] -- Connection ID returned from call to ::Cache
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::Uncache(DWORD dwConnection)
{
    HRESULT hr;

    if (dwConnection == 0)     // They're uncaching an implicit data type.
        return S_OK;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->Uncache(dwConnection));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnumCache, IOleCache
//
//  Synopsis:   Enumerates current cache nodes, including implicitely cached
//              data (which is pretty much everything).
//
//  Arguments:  [ppenumSTATDATA] -- Place to put enumerator
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::EnumCache(IEnumSTATDATA **ppenumSTATDATA)
{
    //
    // Due to the format of the GetFmtTable in the class descriptor, we
    // have to do some extra work here...
    //
    LPENUMSTATDATA          penum;
    const FORMATETC *       petc;
    STATDATA                statdata;
    int                     i;
    HRESULT                 hr;
    CServerEnumCacheAry *   pAryStat;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    pAryStat = new CServerEnumCacheAry;
    if (!pAryStat)
        RRETURN(E_OUTOFMEMORY);

    petc = ServerDesc()->_pGetFmtTable;

    statdata.advf   = 0;
    statdata.pAdvSink = NULL;
    statdata.dwConnection = 0;

    //
    // First, build our array of supported (implicitly cached) formats...
    //
    for (i = 0; i < ServerDesc()->_cGetFmtTable; i++)
    {
        statdata.formatetc = petc[i];

        pAryStat->AppendIndirect(&statdata);
    }

    //
    // Next, determine which formats are explictely cached and update the
    // info on them.
    //

    if (_pCache &&
            SUCCEEDED(_pCache->EnumCache(&penum)) && (penum != NULL))
    {
        while (penum->Next(1, &statdata, NULL) == S_OK)
        {
            for (i=0; i < pAryStat->Size(); i++)
            {
                if (statdata.formatetc.dwAspect == (*pAryStat)[i].formatetc.dwAspect)
                {
                    (*pAryStat)[i].advf = statdata.advf;
                    (*pAryStat)[i].dwConnection = statdata.dwConnection;
                }
            }

            CoTaskMemFree(statdata.formatetc.ptd);
            if (statdata.pAdvSink)
                statdata.pAdvSink->Release();
        }
        penum->Release();
    }

    //
    // The enumerator created during this call will delete pAryStat when
    // appropriate.
    //

    hr = THR(pAryStat->EnumElements(IID_IEnumSTATDATA,
            (LPVOID*)ppenumSTATDATA,
            FALSE, FALSE, TRUE));

    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    delete pAryStat;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::InitCache, public
//
//  Synopsis:   Initializes the cache.
//
//  Arguments:  [pDataObject] -- Data object to initialize from
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::InitCache(IDataObject *pDataObject)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->InitCache(pDataObject));

Cleanup:
    RRETURN1(hr, CACHE_S_SOMECACHES_NOTUPDATED);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetData, IOleObject
//
//  Synopsis:   Sets the data in the cache for a particlar data format.
//
//  Arguments:  [pformatetc] -- Format description
//              [pmedium]    -- Data
//              [fRelease]   -- If TRUE, pmedium will be released
//
//  Returns:    HRESULT
//
//  Notes:      We only allow the DVASPECT_ICON data to be set using this
//              method. All the other formats are implicitely cached.
//
//              Note that this function is renamed for SetData to SetDataCache
//              to avoid conflicts with IDataObject::SetData
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::SetDataCache(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    //
    // The only data we allow a caller to set is the icon
    //
    if (pformatetc->dwAspect == DVASPECT_ICON)
    {
        hr = THR(_pCache->SetData(pformatetc, pmedium, fRelease));
    }
    else
    {
        hr = THR(QueryGetData(pformatetc));

        if (SUCCEEDED(hr) && fRelease)
        {
            ReleaseStgMedium(pmedium);
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::UpdateCache, IOleCache
//
//  Synopsis:   Updates the cache. Delegated to the default cache impl.
//
//  Arguments:  [pDataObject] -- Object to use for updating data
//              [grfUpdf]     -- Update flags
//              [pReserved]   -- Reserved
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::UpdateCache(LPDATAOBJECT pDataObject,
                       DWORD grfUpdf,
                       LPVOID pReserved)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->UpdateCache(pDataObject, grfUpdf, pReserved));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::DiscardCache, public
//
//  Synopsis:   Discards the cache. Delegated to the default cache impl.
//
//  Arguments:  [dwDiscardOptions] -- Discard flags
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::DiscardCache(DWORD dwDiscardOptions)
{
    HRESULT hr;

    hr = THR(EnsureCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCache->DiscardCache(dwDiscardOptions));

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\baseprop.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseprop.cxx
//
//  Contents:   CBase property setting utilities.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif // X_CBUFSTR_HXX_

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif


#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

MtDefine(StripCRLF, Utilities, "StripCRLF *ppDest")
size_t ValidStyleUrl(TCHAR *pch);
// forward reference decl's: local helper function
static HRESULT StripCRLF(TCHAR *pSrc, TCHAR **pCstrDest);

/* flag values */
#define FL_UNSIGNED   1       /* wcstoul called */
#define FL_NEG        2       /* negative sign found */
#define FL_OVERFLOW   4       /* overflow occured */
#define FL_READDIGIT  8       /* we've read at least one correct digit */

BOOL ContainsUrl(TCHAR* pch);
extern BOOL  IsCompositeUrl(CStr *pcstr, int startAt = 0);

static const TCHAR strURLBeg[] = _T("url(");

static HRESULT RTCCONV PropertyStringToLong (
        LPCTSTR nptr,
        TCHAR **endptr,
        int ibase,
        int flags,
        unsigned long *plNumber );


#define GET_CUSTOM_VALUE() ( GetInvalidDefault() - 1) 
#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

HRESULT
BASICPROPPARAMS::GetCustomString(void * pObject, CStr *pstr, BOOL * pfValuePresent ) const
{
    
    BOOL  fDummy;
    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    LPCTSTR lpStr;

    Assert( dwPPFlags & PROPPARAM_CUSTOMENUM);
    *pfValuePresent = (*(CAttrArray**)pObject)->FindString ( (((PROPERTYDESC*)this) -1)->GetDispid(),
                                                            &lpStr, 
                                                            CAttrValue::AA_CustomProperty );
                                                            
    if ( *pfValuePresent )
    {
        pstr->Set ( lpStr );
    }

    return S_OK;
}

HRESULT
BASICPROPPARAMS::GetAvString (void * pObject, const void * pvParams, CStr *pstr, BOOL * pfValuePresent ) const
{
    HRESULT hr = S_OK;
    LPCTSTR lpStr;
    BOOL  fDummy;

    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    Assert(pstr);


    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        *pfValuePresent = CAttrArray::FindString ( *(CAttrArray**)pObject, ((PROPERTYDESC*)this) -1, &lpStr );
        // String pointer will be set to a default if not present
        pstr->Set ( lpStr );
    }
    else
    {
        //Stored as offset from a struct
        CStr *pstoredstr = (CStr *)(  (BYTE *)pObject + *(DWORD *)pvParams  );
        pstr -> Set ( (LPTSTR)*pstoredstr ); 
        *pfValuePresent = TRUE;
    }
    RRETURN(hr);
}

DWORD
BASICPROPPARAMS::GetAvNumber (void * pObject, const void * pvParams,
    UINT uNumBytes, BOOL * pfValuePresent  ) const
{
    DWORD dwValue;
    BOOL  fDummy;

    if (!pfValuePresent)
        pfValuePresent = &fDummy;

    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        *pfValuePresent = CAttrArray::FindSimple ( *(CAttrArray**)pObject, ((PROPERTYDESC*)this) -1, &dwValue  );
    }
    else
    {
        //Stored as offset from a struct
        BYTE *pbValue = (BYTE *)pObject + *(DWORD *)pvParams;
        dwValue = (DWORD)GetNumberOfSize( (void*) pbValue, uNumBytes);
        *pfValuePresent = TRUE;
    }
    return dwValue;
}


HRESULT
BASICPROPPARAMS::SetAvNumber ( void *pObject, DWORD dwNumber, const void *pvParams,
    UINT uNumberBytes, WORD wFlags /*=0*/ ) const
{
    HRESULT hr = S_OK;

    if (dwPPFlags & PROPPARAM_ATTRARRAY)
    {
        hr = CAttrArray::SetSimple ( (CAttrArray**)pObject,
            ((PROPERTYDESC*)this) -1, dwNumber, wFlags );
    }
    else
    {
        BYTE *pbData = (BYTE *)pObject + *(DWORD *)pvParams;
        SetNumberOfSize ( (void *)pbData, uNumberBytes, dwNumber );
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   GetGetSetMf
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------
typedef HRESULT (BUGCALL CVoid::* PFN_ARBITRARYPROPGET) ( ... );
typedef HRESULT (BUGCALL CVoid::* PFN_ARBITRARYPROPSET) ( ... );

// ===========================  New generic handlers and helpers  =============================


inline HRESULT StringToLong( LPTSTR pch, long * pl)
{
    // Skip a leading '+' that would otherwise cause a
    // convert failure
//    RRETURN(VarI4FromStr(pch, LOCALE_SYSTEM_DEFAULT, 0, pl));
    *pl = _tcstol(pch, 0, 0);
    return S_OK;
}

inline HRESULT WriteText (IStream * pStm, TCHAR * pch)
{
    if (pch)
        return pStm->Write(pch, _tcslen(pch)*sizeof(TCHAR), 0);
    else
        return S_OK;
}

inline HRESULT WriteTextLen (IStream * pStm, TCHAR * pch, int nLen)
{
    return pStm->Write(pch, nLen*sizeof(TCHAR), 0);
}

inline HRESULT WriteTextCStr(CStreamWriteBuff * pStmWrBuff, CStr * pstr, BOOL fAlwaysQuote, BOOL fNeverQuote )
{
    UINT u;

    if ((u = pstr->Length()) != 0)
    {
        if ( fNeverQuote )
            RRETURN(pStmWrBuff->Write( *pstr ));
        else
            RRETURN(pStmWrBuff->WriteQuotedText(*pstr, fAlwaysQuote));
    }
    else
    {
        if ( !fNeverQuote )
            RRETURN(WriteText(pStmWrBuff, _T("\"\"")));
    }
    return S_OK;
}

inline HRESULT WriteTextLong(IStream * pStm, long l)
{
    TCHAR ach[20];

    HRESULT hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), l);
    if (hr)
        goto Cleanup;

    hr = pStm->Write(ach, _tcslen(ach)*sizeof(TCHAR), 0);
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Function:   GetGetMethodPtr
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------

void
BASICPROPPARAMS::GetGetMethodP (const void * pvParams, void * pfn) const
{
    Assert(!(dwPPFlags & PROPPARAM_MEMBER));
    Assert(dwPPFlags & PROPPARAM_GETMFHandler);
    Assert(dwPPFlags & PROPPARAM_SETMFHandler);

    memcpy(pfn, pvParams, sizeof(PFN_ARBITRARYPROPGET));
}


//+---------------------------------------------------------------
//
//  Function:   GetSetMethodptr
//
//  Synopsis:   Helper for getting get/set pointer to member functions
//
//----------------------------------------------------------------

void
BASICPROPPARAMS::GetSetMethodP (const void * pvParams, void * pfn) const
{
    Assert(!(dwPPFlags & PROPPARAM_MEMBER));
    Assert(dwPPFlags & PROPPARAM_GETMFHandler);
    Assert(dwPPFlags & PROPPARAM_SETMFHandler);

    memcpy(pfn, (BYTE *)pvParams + sizeof(PFN_ARBITRARYPROPGET), sizeof(PFN_ARBITRARYPROPSET));
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetColorProperty, public
//
//  Synopsis:   Helper for setting color valued properties
//
//----------------------------------------------------------------



HRESULT
BASICPROPPARAMS::GetColorProperty(VARIANT * pVar, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    if(!pVar)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        VariantInit(pVar);
        V_VT(pVar) = VT_BSTR;
        hr = THR( GetColor(pSubObject,  &(pVar->bstrVal)) );
    }

    RRETURN(pObject->SetErrorInfoPGet(hr, dispid));
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::SetColorProperty, public
//
//  Synopsis:   Helper for setting color valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetColorProperty(VARIANT var, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    CBase::CLock    Lock(pObject);
    HRESULT         hr=S_OK;
    DWORD           dwOldValue;
    CColorValue     cvValue;
    CVariant        *v = (CVariant *)&var;

    // check for shorts to keep vbscript happy and other VT_U* and VT_UI* types to keep C programmer's happy.
    // vbscript interprets values between 0x8000 and 0xFFFF in hex as a short!, jscript doesn't
    if (v->CoerceNumericToI4())
    {
        DWORD dwRGB = V_I4(v);

        // if -ve value or highbyte!=0x00, ignore (NS compat)
        if (dwRGB & CColorValue::MASK_FLAG)
            goto Cleanup;
        
        // flip RRGGBB to BBGGRR to be in CColorValue format
        cvValue.SetFromRGB(dwRGB);
    }
    else if (V_VT(&var) == VT_BSTR)
    {
// Removed 4/24/97 because "" clearing a color is a useful feature.  -CWilso
// if NULL or empty string, ignore (NS compat)
//        if (!(V_BSTR(&var)) || !*(V_BSTR(&var)))
//            goto Cleanup;

        hr = cvValue.FromString((LPTSTR)(V_BSTR(&var)), FALSE, ( dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY ) );
    }
    else
        goto Cleanup;   // if invalid type, ignore

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetColor( pSubObject, & dwOldValue );
    if (hr)
        goto Cleanup;

    if ( dwOldValue == (DWORD)cvValue.GetRawValue() )
    {
        // No change - ignore it
        hr = S_OK;
        goto Cleanup;
    }

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CStr    strOldColor;
            CVariant varOldColor;
            BOOL    fOldPresent;

            hr = THR( GetColor( pSubObject, &strOldColor, FALSE, &fOldPresent ) );

            if (hr)
                goto Cleanup;

            if (fOldPresent)
            {
                V_VT(&varOldColor) = VT_BSTR;
                hr = THR( strOldColor.AllocBSTR( &V_BSTR(&varOldColor) ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOldColor) = VT_NULL;
            }

            if( fTreeSync )
            {
                pObject->LogAttributeChange( dispid, &varOldColor, &var );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(dispid, &varOldColor, NULL));
        
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOldColor
        }
    }
#endif // NO_EDIT

    hr = THR( SetColor( pSubObject, cvValue.GetRawValue(), wFlags ) );
    if (hr)
        goto Cleanup;

    hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    if (hr)
    {
        IGNORE_HR(SetColor(pSubObject, dwOldValue, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:

    RRETURN1(pObject->SetErrorInfoPSet(hr, dispid), E_INVALIDARG);
}

//+---------------------------------------------------------------
//
//  Function:   SetString
//
//  Synopsis:   Helper for setting string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetString(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr;

    if (dwPPFlags & PROPPARAM_SETMFHandler)
    {
        PFN_CSTRPROPSET pmfSet;
        CStr szString;
        szString.Set ( pch );

        GetSetMethodP(this + 1, &pmfSet );

        hr = CALL_METHOD(pObject,pmfSet,( &szString));
    }
    else
    {

        if (dwPPFlags & PROPPARAM_ATTRARRAY)
        {            
            hr = THR( CAttrArray::SetString ( (CAttrArray**) (void*) pObject,
                    (PROPERTYDESC*)this - 1, pch, FALSE, wFlags ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            //Stored as offset from a struct
            CStr *pcstr;
            pcstr = (CStr *) (  (BYTE *)pObject + *(DWORD *)(this + 1)  );
            hr = THR( pcstr->Set(pch) );
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Function:   GetString
//
//  Synopsis:   Helper for getting string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetString(CVoid * pObject, CStr * pcstr, BOOL *pfValuePresent) const
{
    HRESULT hr = S_OK;

    if (dwPPFlags & PROPPARAM_GETMFHandler)
    {
        PFN_CSTRPROPGET pmfGet;

        GetGetMethodP(this + 1, &pmfGet);

        // Get Method fn prototype takes a BSTR ptr
        //
        hr = CALL_METHOD(pObject,pmfGet,( pcstr ));
        if (pfValuePresent)
            *pfValuePresent = TRUE;
    }
    else
    {
        hr = GetAvString (pObject,this + 1,  pcstr, pfValuePresent);
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------
//
//  Member:     SetStringProperty, public
//
//  Synopsis:   Helper for setting string values properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetStringProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    CBase::CLock    Lock(pObject);
    HRESULT         hr;
    CStr            cstrOld;
    BOOL            fOldPresent;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetString(pSubObject, &cstrOld, &fOldPresent);
    if (hr)
        goto Cleanup;

    // HACK! HACK! HACK! (MohanB) In order to fix #64710 at this very late
    // stage in IE5, I am putting in this hack to specifically check for
    // DISPID_CElement_id. For IE6, we should not fire onpropertychange for any
    // property (INCLUDING non-string type properties!) if the value of the
    // property has not been modified.

    // Quit if the value has not been modified
    if (    fOldPresent
        &&  DISPID_IHTMLELEMENT_ID == dispid
        &&  0 == _tcscmp(cstrOld, bstrNew)
       )
    {
        goto Cleanup;
    }

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CVariant varOld;

            if (fOldPresent)
            {
                V_VT(&varOld) = VT_BSTR;
                if( wFlags & CAttrValue::AA_Extra_UrlEnclosed )
                {
                    CBufferedStr szBufSt;

                    szBufSt.Set(_T("url(\""));
                    szBufSt.QuickAppend(cstrOld);
                    szBufSt.QuickAppend(_T("\")"), 2);

                    hr = THR( FormsAllocString( szBufSt, &(V_BSTR(&varOld)) ) );
                }
                else
                    hr = THR( cstrOld.AllocBSTR( &V_BSTR(&varOld) ) );
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOld) = VT_NULL;
            }

            if( fTreeSync )
            {
                VARIANT    varNew;
                CBufferedStr szBufSt;

                V_VT( &varNew ) = VT_LPWSTR;
                if( wFlags & CAttrValue::AA_Extra_UrlEnclosed )
                {
                    szBufSt.Set(_T("url(\""));
                    szBufSt.QuickAppend(bstrNew);
                    szBufSt.QuickAppend(_T("\")"));
                    varNew.byref = szBufSt;
                }
                else
                    varNew.byref = bstrNew;

                pObject->LogAttributeChange( dispid, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(dispid, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    hr = THR(SetString(pSubObject, (TCHAR *)bstrNew, wFlags));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    if (hr)
    {
        IGNORE_HR(SetString(pSubObject, (TCHAR *)cstrOld, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPSet(hr, dispid));
}

const PROPERTYDESC *HDLDESC::FindPropDescForName ( LPCTSTR szName, BOOL fCaseSensitive, long *pidx ) const
{
    const PROPERTYDESC *pfoundHash = NULL;
    if(pidx)
        *pidx = -1;

    if(pStringTableAggregate)
    {
        const VTABLEDESC *pVTableDesc;

        if(fCaseSensitive)
        {
            pVTableDesc = pStringTableAggregate->GetCs(szName, VTABLEDESC_BELONGSTOPARSE);
        }
        else    
        {
            pVTableDesc = pStringTableAggregate->GetCi(szName, VTABLEDESC_BELONGSTOPARSE);            
        }

        // Return only PropDescs which "belong" to the parser
        if(pVTableDesc)
        {
            pfoundHash = pVTableDesc->FastGetPropDesc(VTABLEDESC_BELONGSTOPARSE);
            Assert(pfoundHash);

            if(pidx)
                *pidx = pVTableDesc->GetParserIndex();
        }
    }
    return pfoundHash;
}

HRESULT ENUMDESC::EnumFromString ( LPCTSTR pStr, long *plValue, BOOL fCaseSensitive ) const
{   
    int i;
    HRESULT hr = S_OK;              
    STRINGCOMPAREFN pfnCompareString = fCaseSensitive ? StrCmpC : StrCmpIC;

    if (!pStr)
        pStr = _T("");

    for (i = cEnums - 1; i >= 0; i--)
    {
        if (!( pfnCompareString ( pStr, aenumpairs[i].pszName) ) )
        {
            *plValue = aenumpairs[i].iVal;
            break;
        }
    }

    if (i < 0)
    {
        hr = E_INVALIDARG;
    }

    RRETURN1(hr, E_INVALIDARG);
}

HRESULT ENUMDESC::StringFromEnum ( long lValue, BSTR *pbstr ) const
{
    int     i;
    HRESULT hr = E_INVALIDARG;

    for (i = 0; i < cEnums; i++)
    {
        if ( aenumpairs[i].iVal == lValue )
        {
            hr = THR(FormsAllocString( aenumpairs[i].pszName, pbstr ));
            break;
        }
    }
    RRETURN1(hr,E_INVALIDARG);
}


LPCTSTR ENUMDESC::StringPtrFromEnum ( long lValue ) const
{
    int     i;

    for (i = 0; i < cEnums; i++)
    {
        if ( aenumpairs[i].iVal == lValue )
        {
            return( aenumpairs[i].pszName );
        }
    }
    return( NULL );
}


HRESULT
NUMPROPPARAMS::SetEnumStringProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    HRESULT hr = E_INVALIDARG;
    CBase::CLock    Lock(pObject);
    long lNewValue,lOldValue;
    BOOL fOldPresent;
    TCHAR* pchCustom = NULL;
    
    hr = GetNumber(pObject, pSubObject, &lOldValue, &fOldPresent);
    if ( hr )
        goto Cleanup;

    hr = LookupEnumString ( this, (LPTSTR)bstrNew, &lNewValue );
    if ( hr )
    {    
        if ( this->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM )
        {
            //
            // TODO - move all URL parsing code to the custom cursor class.
            //
            TCHAR* pv = bstrNew;
            if ( ContainsUrl ( (TCHAR*) pv ))
            {
                int nLenIn = ValidStyleUrl((TCHAR*) pv);
                if ( nLenIn > 0 )
                {
                    TCHAR *pch = (TCHAR*) pv;
                    TCHAR *psz = pch+4;
                    TCHAR *quote = NULL;
                    TCHAR *pszEnd;
                    TCHAR terminator;

                    while ( _istspace( *psz ) )
                        psz++;
                    if ( *psz == _T('\'') || *psz == _T('"') )
                    {
                        quote = psz++;
                    }
                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                    pszEnd = pch + nLenIn - 1;
                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                        pszEnd--;
                    if ( quote && ( *pszEnd == *quote ) )
                        pszEnd--;
                    terminator = *(pszEnd+1);
                    *(pszEnd+1) = _T('\0');

                    pchCustom = psz;
                }
                else
                {
                    pchCustom =(TCHAR*) pv;
                }
            }
            else
                pchCustom = (TCHAR*) pv;
        }
        else
            goto Cleanup;

    }
    else
    {
        if ( lNewValue == lOldValue )
            goto Cleanup;

        hr = ValidateNumberProperty( &lNewValue, pObject);
        if (hr)
            goto Cleanup;
    }
    
#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );

        if ( fCreateUndo || fTreeSync )
        {
            CVariant      varOld;

            if (fOldPresent)
            {
                ENUMDESC *    pEnumDesc;
                const TCHAR * pchOldValue;

                if ( bpp.dwPPFlags & PROPPARAM_ANUMBER )
                {
                    pEnumDesc = *(ENUMDESC **)((BYTE *)(this+1)+ sizeof(DWORD_PTR));
                }
                else
                {
                    pEnumDesc = (ENUMDESC *) lMax;
                }

                pchOldValue = pEnumDesc->StringPtrFromEnum( lOldValue );

                V_VT(&varOld) = VT_BSTR;
                hr = FormsAllocString(pchOldValue, &V_BSTR(&varOld));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                V_VT(&varOld) = VT_NULL;
            }
        
            if( fTreeSync )
            {
                VARIANT    varNew;

                // NOTE: Someone (maybe editing) is cheating here - 
                // bstrNew is NOT a real bstr. 
                varNew.vt = VT_LPWSTR;
                varNew.byref = bstrNew;

                pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
            }
        
            if( fCreateUndo )
            {
                hr = THR( pObject->CreatePropChangeUndo( bpp.dispid, &varOld, NULL ) );
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT
    
    if ( ! pchCustom )
    {
        hr = SetNumber(pObject, pSubObject, lNewValue, wFlags );
        if (hr)
            goto Cleanup;
    }
    else
    {
        const PROPERTYDESC* pDesc = GetPropertyDesc();
        lNewValue = pDesc->GetInvalidDefault() - 1; 
        
        hr = SetCustomNumber( pObject, pSubObject, lNewValue, wFlags,pchCustom );
    }
    
    hr = THR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    CHECK_HEAP();

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}

HRESULT
NUMPROPPARAMS::GetEnumStringProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;
    VARIANT varValue;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)this)-1;

    if(!pbstr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pSubObject)
    {
        pSubObject = pObject;
    }


	hr = THR(ppdPropDesc->HandleNumProperty( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT<<16), 
        (void *)&varValue, pObject, pSubObject ));
    if ( !hr )
        *pbstr = V_BSTR(&varValue);

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}

//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetStringProperty, public
//
//  Synopsis:   Helper for setting string valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetStringProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    if(!pbstr)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CStr    cstr;

        // CONSIDER: (anandra) Possibly have a helper here that returns
        // a bstr to avoid two allocations.
        hr = THR(GetString(pSubObject, &cstr));
        if (hr)
            goto Cleanup;
        hr = THR(cstr.AllocBSTR(pbstr));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, dispid));
}


//+---------------------------------------------------------------
//
//  Function:   SetUrl
//
//  Synopsis:   Helper for setting url string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetUrl(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr = S_OK;
    TCHAR   *pstrNoCRLF=NULL;

    hr = THR(StripCRLF(pch, &pstrNoCRLF));
    if (hr)
        goto Cleanup;

    hr =THR(SetString(pObject, pstrNoCRLF, wFlags));

Cleanup:
    if (pstrNoCRLF)
        MemFree(pstrNoCRLF);

    RRETURN( hr );
}

//+---------------------------------------------------------------
//
//  Member:     SetUrlProperty, public
//
//  Synopsis:   Helper for setting url-string values properties
//     strip off CR/LF and call setString
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetUrlProperty(BSTR bstrNew, CBase * pObject, CVoid * pSubObject, WORD wFlags) const
{
    HRESULT   hr=S_OK;
    TCHAR    *pstrNoCRLF=NULL;

    hr = THR(StripCRLF((TCHAR*)bstrNew, &pstrNoCRLF));
    if (hr)
        goto Cleanup;

    // SetStringProperty calls Set ErrorInfoPSet
    hr = THR(SetStringProperty(pstrNoCRLF, pObject, pSubObject, wFlags));

Cleanup:
    if (pstrNoCRLF)
        MemFree(pstrNoCRLF);

    RRETURN(pObject->SetErrorInfoPSet(hr, dispid));
}

//+---------------------------------------------------------------
//
//  Function:   GetUrl
//
//  Synopsis:   Helper for getting url-string value
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetUrl(CVoid * pObject, CStr * pcstr) const
{
    RRETURN( GetString(pObject, pcstr) );
}


//+---------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetUrlProperty, public
//
//  Synopsis:   Helper for setting url string valued properties
//
//----------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetUrlProperty(BSTR *pbstr, CBase * pObject, CVoid * pSubObject) const
{
    // SetString does the SetErrorInfoPGet
    RRETURN( GetStringProperty(pbstr, pObject, pSubObject));
}

//+---------------------------------------------------------------
//
//  Function:   GetNumber
//
//  Synopsis:   Helper for getting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::GetNumber (CBase * pObject, CVoid * pSubObject, long * plNum, BOOL *pfValuePresent) const
{
    HRESULT hr = S_OK;

    if (bpp.dwPPFlags & PROPPARAM_GETMFHandler)
    {
        PFN_NUMPROPGET pmfGet;

        bpp.GetGetMethodP(this + 1, &pmfGet);

        hr = CALL_METHOD((CVoid*)(void*)pObject,pmfGet,(plNum));
        if (pfValuePresent)
            *pfValuePresent = TRUE;
    }
    else
    {
        *plNum = bpp.GetAvNumber ( pSubObject, this + 1, cbMember, pfValuePresent );
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   SetCustomNumber
//
//  Synopsis:   Helper for setting custom number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetCustomNumber (CBase * pObject, CVoid * pSubObject, long lNum, WORD wFlags, TCHAR* pchCustom /*=NULL*/) const
{
    HRESULT hr = S_OK;

    hr = THR( bpp.SetAvNumber (pSubObject, (DWORD)lNum, this + 1, cbMember, wFlags ) );
    if ( hr )
        goto Cleanup;
        
    hr = THR( bpp.SetString( pSubObject, pchCustom, wFlags ));
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   SetNumber
//
//  Synopsis:   Helper for setting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetNumber (CBase * pObject, CVoid * pSubObject, long lNum, WORD wFlags ) const
{
    HRESULT hr = S_OK;

    if (bpp.dwPPFlags & PROPPARAM_SETMFHandler)
    {
        PFN_NUMPROPSET pmfSet;

        bpp.GetSetMethodP(this + 1, &pmfSet);

        hr = CALL_METHOD((CVoid*)(void*)pObject,pmfSet,(lNum));
    }
    else
    {
        hr = THR( bpp.SetAvNumber (pSubObject, (DWORD)lNum, this + 1, cbMember, wFlags) );
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     ValidateNumberProperty, public
//
//  Synopsis:   Helper for testing the validity of numeric properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::ValidateNumberProperty(long *lArg, CBase * pObject ) const
{
    long lMinValue = 0, lMaxValue = LONG_MAX;
    HRESULT hr = S_OK;
    int ids = 0;
    const PROPERTYDESC *pPropDesc = (const PROPERTYDESC *)this -1;

    if (vt == VT_BOOL || vt == VT_BOOL4)
        return S_OK;

    // Check validity of input argument
    if ( bpp.dwPPFlags & PROPPARAM_UNITVALUE )
    {
        CUnitValue uv;
        uv.SetRawValue ( *lArg );
        hr = uv.IsValid( pPropDesc );
        if ( hr )
        {
            if (bpp.dwPPFlags & PROPPARAM_MINOUT)
            {
                // set value to min;
                *lArg = lMin;
                hr = S_OK;
            }
            else
            {
                    //otherwise return error, i.e. set to default
                ids = IDS_ES_ENTER_PROPER_VALUE;
            }
        }
        goto Cleanup;
    }

    if ( ( ( bpp.dwPPFlags & PROPPARAM_ENUM )  && ( bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        || !(bpp.dwPPFlags & PROPPARAM_ENUM) )
    {
        lMinValue = lMin; lMaxValue = lMax;
        if( (*lArg < lMinValue || *lArg > lMaxValue) && 
            *lArg != (long)pPropDesc->GetNotPresentDefault() &&
            *lArg != (long)pPropDesc->GetInvalidDefault() )
        {
            if (lMaxValue != LONG_MAX)
            {
                ids = IDS_ES_ENTER_VALUE_IN_RANGE;
            }
            else if (lMinValue == 0)
            {
                ids = IDS_ES_ENTER_VALUE_GE_ZERO;
            }
            else if (lMinValue == 1)
            {
                ids = IDS_ES_ENTER_VALUE_GT_ZERO;
            }
            else
            {
                ids = IDS_ES_ENTER_VALUE_IN_RANGE;
            }
            hr = E_INVALIDARG;
        }
        else
        {
            // inside of range
            goto Cleanup;
        }
    }

    // We have 3 scenarios to check for :-
    // 1) Just a number validate w min & max
    // 2) Just an emum validated w pEnumDesc
    // 3) A number w. min & max & one or more enum values

    // If we've got a number OR enum type, first check the
    if ( bpp.dwPPFlags & PROPPARAM_ENUM )
    {
        ENUMDESC *pEnumDesc = pPropDesc->GetEnumDescriptor();

        Assert(pEnumDesc);

        // dwMask represent a mask allowing or rejecting values 0 to 31
        if(*lArg >= 0 && *lArg < 32 )
        {
            if (!((pEnumDesc -> dwMask >> (DWORD)*lArg) & 1))
            {
                if ( !hr )
                {
                    ids = IDS_ES_ENTER_PROPER_VALUE;
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = S_OK;
            }
        }
        else
        {
            // If it's not in the mask, look for the value in the array
            WORD i;

            for ( i = 0 ; i < pEnumDesc -> cEnums ; i++ )
            {
                if ( pEnumDesc -> aenumpairs [ i ].iVal == *lArg )
                {
                    break;
                }
            }
            if ( i == pEnumDesc -> cEnums )
            {
                if ( !hr )
                {
                    ids = IDS_ES_ENTER_PROPER_VALUE;
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                hr = S_OK;
            }
        }
    }

Cleanup:
    if ( hr && ids == IDS_ES_ENTER_PROPER_VALUE )
    {
        RRETURN1 ( pObject->SetErrorInfoPBadValue ( bpp.dispid, ids ), E_INVALIDARG );
    }
    else if ( hr )
    {
        RRETURN1 (pObject->SetErrorInfoPBadValue(
                    bpp.dispid,
                    ids,
                    lMinValue,
                    lMaxValue ),E_INVALIDARG );
    }
    else
        return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::GetNumberProperty, public
//
//  Synopsis:   Helper for getting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::GetNumberProperty(void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr;
    long num;

    if(!pv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetNumber(pObject, pSubObject, &num);
    if (hr)
        goto Cleanup;

    SetNumberOfType(pv, VARENUM(vt), num);

Cleanup:
    RRETURN(pObject->SetErrorInfoPGet(hr, bpp.dispid));
}


//+---------------------------------------------------------------
//
//  Member:     SetNumberProperty, public
//
//  Synopsis:   Helper for setting number values properties
//
//----------------------------------------------------------------

HRESULT
NUMPROPPARAMS::SetNumberProperty(long lValueNew, CBase * pObject, CVoid * pSubObject, BOOL fValidate /* = TRUE */, WORD wFlags ) const
{
    CBase::CLock    Lock(pObject);
    HRESULT     hr;
    long        lValueOld;
    BOOL        fOldPresent;
    BOOL        fRuntimeStyle = (CAttrValue::AA_Extra_RuntimeStyle == wFlags);

    //
    // Get the current value of the property
    //
    if (!pSubObject)
    {
        pSubObject = pObject;
    }

    hr = GetNumber(pObject, pSubObject, &lValueOld, &fOldPresent);
    if (hr)
        goto Cleanup;

    //
    // Validate the old value, just for kicks...
    //

    //
    // If the old and new values are the same and the old value was actually set,
    // then git out of here
    //

    if (lValueNew == lValueOld && (fOldPresent || !fRuntimeStyle))
        goto Cleanup;

    //
    // Make sure the new value is OK
    //

    if ( fValidate )
    {
        // Validate using propdesc encoded parser rules 
        hr = THR(ValidateNumberProperty(&lValueNew, pObject ));
        if (hr)
            return hr;  // Error info set in validate
    }

    //
    // Create the undo thing-a-ma-jig
    //

#ifndef NO_EDIT
    {
        BOOL fTreeSync;
        BOOL fCreateUndo = pObject->QueryCreateUndo( TRUE, FALSE, &fTreeSync );
 
        if ( fCreateUndo || fTreeSync )
        {
            CVariant  varOld;
            TCHAR     achValueOld[30];

            // Handle CUnitValues as BSTRs, everything else as plain numbers.

            if ( !fOldPresent )
            {
                V_VT(&varOld) = VT_NULL;
            }

#if defined(_MAC)
            else if ( GetPropertyDesc()->pfnHandleProperty ==
                 &PROPERTYDESC::HandleUnitValueProperty )
#else
            else if ( GetPropertyDesc()->pfnHandleProperty ==
                 PROPERTYDESC::HandleUnitValueProperty )
#endif
            {
                CUnitValue uv;

                uv.SetRawValue( lValueOld );

                if (uv.IsNull())
                {
                    V_VT(&varOld) = VT_BSTR;
                }
                else
                {
                    hr = uv.FormatBuffer( achValueOld, ARRAY_SIZE( achValueOld ),
                                          GetPropertyDesc() );
                    if ( hr )
                        goto Cleanup;

                    V_VT(&varOld) = VT_BSTR;
                    hr = FormsAllocString(achValueOld, &V_BSTR(&varOld));
                    if (hr)
                        goto Cleanup;
                }
            }
            else if ( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
            {
                ENUMDESC * pEnumDesc = GetPropertyDesc()->GetEnumDescriptor();

                Assert( pEnumDesc );

                V_VT(&varOld) = VT_BSTR;
                hr = THR( FormsAllocString( pEnumDesc->StringPtrFromEnum( lValueOld ), &V_BSTR(&varOld) ) );
                if( hr )
                    goto Cleanup;
            }
            else
            {
                AssertSz( vt == VT_I4 || vt == VT_I2 || vt == VT_BOOL || vt == VT_BOOL4, "Bad vt" );

                V_VT(&varOld) = vt;
                V_I4(&varOld) = lValueOld;
            }

            if( fTreeSync )
            {
                VARIANT    varNew;
                TCHAR      achValueNew[30];

                // UnitValues need to be converted to BSTR's.
                if( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleUnitValueProperty )
                {
                    CUnitValue uv( lValueNew );

                    if( SUCCEEDED( uv.FormatBuffer( achValueNew, ARRAY_SIZE( achValueNew ), GetPropertyDesc() ) ) )
                    {
                        varNew.vt = VT_LPWSTR;
                        varNew.byref = achValueNew;
                        pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                    }
                }
                else if( GetPropertyDesc()->pfnHandleProperty == PROPERTYDESC::HandleEnumProperty )
                {
                    ENUMDESC * pEnumDesc = GetPropertyDesc()->GetEnumDescriptor();

                    Assert( pEnumDesc );

                    varNew.vt = VT_LPWSTR;
                    varNew.byref = (void *)( const_cast<TCHAR *>( pEnumDesc->StringPtrFromEnum( lValueNew ) ) );
                    pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                }
                else
                {
                    V_VT( &varNew ) = VT_I4;
                    V_I4( &varNew ) = lValueNew;

                    pObject->LogAttributeChange( bpp.dispid, &varOld, &varNew );
                }
            }
        
            if( fCreateUndo )
            {
                hr = THR(pObject->CreatePropChangeUndo(bpp.dispid, &varOld, NULL));
                if (hr)
                    goto Cleanup;
            }
            // Else CVariant destructor cleans up varOld
        }
    }
#endif // NO_EDIT

    //
    // Stuff the new value in
    //

    hr = THR(SetNumber(pObject, pSubObject, lValueNew, wFlags));
    if (hr)
        goto Cleanup;

    //
    // Tell everybody about the new value
    //

    hr = THR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));

    //
    // If anybody complained, then revert
    //

    if (hr)
    {
        IGNORE_HR(SetNumber(pObject, pSubObject, lValueOld, wFlags));
        IGNORE_HR(pObject->OnPropertyChange(bpp.dispid, bpp.dwFlags, (PROPERTYDESC *)GetPropertyDesc()));
    }

Cleanup:
    RRETURN(pObject->SetErrorInfoPSet(hr, bpp.dispid));
}




HRESULT BUGCALL
PROPERTYDESC::HandleUnitValueProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK,hr2;
    const NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(this + 1);
    const BASICPROPPARAMS *bpp = (BASICPROPPARAMS *)ppp;
    CVariant varDest;
    LONG lNewValue;
    long lTemp = 0;
    BOOL fValidated = FALSE;

    // The code in this fn assumes that the address of the object
    // is the address of the long value
    if (ISSET(dwOpCode))
    {
        CUnitValue uvValue;
        uvValue.SetDefaultValue();
        LPCTSTR pStr = (TCHAR *)pv;

        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...

        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
FromString:
            if ( pStr == NULL || !pStr[0] )
            {
                lNewValue = GetNotPresentDefault();
            }
            else
            {
                hr = uvValue.FromString ( pStr, this, dwOpCode & HANDLEPROP_STRICTCSS1 );
                if ( !hr )
                {
                    lNewValue = uvValue.GetRawValue ();
                    if ( !(dwOpCode & HANDLEPROP_DONTVALIDATE ) )
                        hr = uvValue.IsValid( this );
                }

                if ( hr == E_INVALIDARG )
                {
                    // If in strict css1 ignore invalid values
                    if (dwOpCode & HANDLEPROP_STRICTCSS1)
                        goto Cleanup;

                    // Ignore invalid values when parsing a stylesheet
                    if(IsStyleSheetProperty())
                        goto Cleanup;

                    lNewValue = GetInvalidDefault();
                }
                else if ( hr )
                {
                    goto Cleanup;
                }
            }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;
            fValidated = TRUE;
            pv = &lNewValue;
            break;
                                             
        case PROPTYPE_VARIANT:
            {
                VARIANT *pVar = (VARIANT *)pv;

                switch ( pVar -> vt )
                {
                default:
                    hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pVar, VT_BSTR);
                    if (hr)
                        goto Cleanup;

                    pVar = &varDest;

                    // Fall thru to VT_BSTR code below

                case VT_BSTR:
                    pStr = pVar -> bstrVal;
                    goto FromString;

                case VT_NULL:
                    lNewValue = 0;
                    break;

                }
                pv = &lNewValue;
            }
            break;

        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }

        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            // Set default Value from propdesc
            hr = ppp->SetNumber(pObject, pSubObject,
                (long)ulTagNotPresentDefault, wFlags );
            goto Cleanup;


        case HANDLEPROP_AUTOMATION:
            if ( hr )
                goto Cleanup;

			// The unit value handler can be called directly through automation
			// This is pretty unique - we usualy have a helper fn
            hr = HandleNumProperty(SETPROPTYPE(dwOpCode, PROPTYPE_EMPTY),
				pv, pObject, pSubObject);
            if (hr)
                goto Cleanup;
			break;

        case HANDLEPROP_VALUE:
            if ( !fValidated )
            {
                // We need to preserve an existing error code if there is one
                hr2 = ppp->ValidateNumberProperty((long *)pv, pObject);
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            hr2 = ppp->SetNumber(pObject, pSubObject, *(long *)pv, wFlags);
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }

            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }

            break;
        }
        RRETURN1(hr, E_INVALIDARG);
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            hr = ppp->GetNumberProperty(&lTemp, pObject, pSubObject);
            if ( hr )
                goto Cleanup;
            // Coerce to type
            {
                BSTR *pbstr = (BSTR *)pv;

                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    // pv points to a VARIANT
                    VariantInit ( (VARIANT *)pv );
                    V_VT ( (VARIANT *)pv ) = VT_BSTR;
                    pbstr = &V_BSTR((VARIANT *)pv);
                    // intentional fall-through
                case PROPTYPE_BSTR:
                    {
                        TCHAR cValue [ 30 ];


                        CUnitValue uvThis;
                        uvThis.SetRawValue ( lTemp );

                        if ( uvThis.IsNull() )
                        {
                            // Return an empty BSTR
                            hr = FormsAllocString( g_Zero.ach, pbstr );
                        }
                        else
                        {
                            hr = uvThis.FormatBuffer ( (LPTSTR)cValue, (UINT)ARRAY_SIZE ( cValue ), this );
                            if ( hr )
                                goto Cleanup;

                            hr = THR(FormsAllocString( cValue, pbstr ));
                        }
                    }
                    break;

                    default:
                        *(long *)pv = lTemp;
                        break;
                }
            }
            goto Cleanup;
            break;

        case HANDLEPROP_VALUE:
            {
                CUnitValue uvValue;

                // get raw value
                hr = ppp->GetNumber(pObject, pSubObject, (long *)&uvValue);

                if (PROPTYPE(dwOpCode) == VT_VARIANT)
                {
                    ((VARIANT *)pv)->vt = VT_I4;
                    ((VARIANT *)pv)->lVal = uvValue.GetUnitValue();
                }
                else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
                {
                    TCHAR cValue [ 30 ];

                    hr = uvValue.FormatBuffer ( (LPTSTR)cValue, (UINT)ARRAY_SIZE ( cValue ), this );
                    if ( hr )
                        goto Cleanup;

                    hr = THR( FormsAllocString( cValue, (BSTR *)pv ) );
                }
                else
                {
                    Assert(PROPTYPE(dwOpCode) == 0);
                    *(long *)pv = uvValue.GetUnitValue();
                }
            }
            goto Cleanup;

        case HANDLEPROP_COMPARE:
            hr = ppp->GetNumber(pObject, pSubObject, &lTemp);
            if (hr)
                goto Cleanup;
            // if inherited and not set, return S_OK
            hr = ( lTemp == *(long *)pv ) ? S_OK : S_FALSE;
            RRETURN1 (hr, S_FALSE);
            break;

        case HANDLEPROP_STREAM:
            {
            // Get value into an IStream
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);

            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;

            CUnitValue uvValue;
            uvValue.SetRawValue ( lNewValue );

            hr = uvValue.Persist ( (IStream *)pv, this );

            goto Cleanup;
            }
            break;

        }
    }
    // Let the basic numproperty handler handle all other cases
    hr = HandleNumProperty ( dwOpCode, pv, pObject, pSubObject );
Cleanup:
    RRETURN1(hr, E_INVALIDARG);
}


HRESULT LookupEnumString ( const NUMPROPPARAMS *ppp, LPCTSTR pStr, long *plNewValue )
{
    HRESULT hr = S_OK;
    PROPERTYDESC *ppdPropDesc = ((PROPERTYDESC *)ppp)-1;
    ENUMDESC *pEnumDesc = ppdPropDesc->GetEnumDescriptor();
        
    if (pEnumDesc == NULL)
    {
        RRETURN(E_INVALIDARG);
    }
    
    // ### v-gsrir - Modified the 3rd parameter to result in a 
    // Bool instead of a DWORD - which was resulting in the parameter
    // being taken as 0 always.
    hr = pEnumDesc->EnumFromString ( pStr, plNewValue,( 
        ppp->bpp.dwPPFlags & PROPPARAM_CASESENSITIVE ) ? TRUE:FALSE);

    if ( hr == E_INVALIDARG )
    {
        if ( ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER )
        {
            // Not one of the enums, is it a number??
            hr = ttol_with_error( pStr, plNewValue);
        }
    }
    RRETURN(hr);
}

// Don't call this function outside of automation - loads oleaut!
HRESULT LookupStringFromEnum( const NUMPROPPARAMS *ppp, BSTR *pbstr, long lValue )
{
    ENUMDESC *pEnumDesc;

    Assert( (ppp->bpp.dwPPFlags&PROPPARAM_ENUM) && "Can't convert a non-enum to an enum string!" );

    if ( ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER )
    {
        pEnumDesc = *(ENUMDESC **)((BYTE *)(ppp+1)+ sizeof(DWORD_PTR));
    }
    else
    {
        pEnumDesc = (ENUMDESC *) ppp->lMax;
    }

    RRETURN1( pEnumDesc->StringFromEnum( lValue, pbstr ), S_FALSE );
}

BOOL 
PROPERTYDESC::IsBOOLProperty ( void ) const
{                        
    return  ( pfnHandleProperty == &PROPERTYDESC::HandleNumProperty &&
        ((NUMPROPPARAMS *)(this + 1))-> vt == VT_BOOL  ) ? TRUE : FALSE;
}

//
// Determine if a custom url property is a "composite" url
//
// if it isn't we add back a url('...') around the property
// if it is - we leave it alone.
// 
HRESULT 
UnMungeCustomUrl( CStr* pcstrUrlOrig, CStr* pcstrResult )
{
    HRESULT hr;
    
    if ( ! IsCompositeUrl ( pcstrUrlOrig ))
    {
        CStr cstrEnd;
    
        IFC( pcstrResult->Set(_T("url('")));
        IFC( cstrEnd.Set(_T("')")));            
        IFC( pcstrResult->Append( *pcstrUrlOrig ));
        IFC( pcstrResult->Append( cstrEnd ));        
    }
    else
    {
        IFC( pcstrResult->Set( *pcstrUrlOrig ));
    }
    
Cleanup:
    RRETURN ( hr );
}

//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleNumProperty, public
//
//  Synopsis:   Helper for getting/setting number value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleNumProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT             hr = S_OK, hr2;
    const NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(this + 1);
    const BASICPROPPARAMS *bpp = (BASICPROPPARAMS *)ppp;
    VARIANT             varDest;
    LONG                lNewValue, lTemp = 0;
    CStreamWriteBuff    *pStmWrBuff;
    VARIANT             *pVariant;
    VARIANT             varTemp;
    varDest.vt = VT_EMPTY;
    TCHAR*              pchCustom = NULL ;
    
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            // If the parameter is a BOOL, the presence of the value sets the value
            if ( ppp -> vt == VT_BOOL )
            {
                // For an OLE BOOL -1 == True
                lNewValue = -1;
            }
            else
            {
SetFromString:
                LPTSTR pStr = (TCHAR *)pv;
                hr = S_OK;
                if ( pStr == NULL || !pStr[0] )
                {
                    // Just have Tag=, set to not assigned value
                    lNewValue = GetNotPresentDefault();
                }
                else
                {                
                    if ( !(ppp->bpp.dwPPFlags & PROPPARAM_ENUM) )
                    {
                        hr = ttol_with_error( pStr, &lNewValue);
                    }
                    else
                    {
                        // enum string, look it up
                        hr = LookupEnumString ( ppp, pStr, &lNewValue );
                    }
                    if ( hr )
                    {
                        //
                        // For custom Enum's we'll currently treat these as strings.
                        //
                        if (  ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM )
                        {
                            //
                            // TODO - move all URL parsing code to the custom cursor class.
                            //
                            
                            //
                            // TODO - expand propdesc to include a generic "custom" 
                            // identifier. Like is done for defaults.
                            // currently the only CustomENUM type is cursor
                            // but if we want to expand this - we need to expand this mechanism
                            //
                            // For now - just make custom type be invalidDefault - 1
                            // 
                            Assert( ppp->bpp.dispid == DISPID_A_CURSOR );
                            
                            lNewValue = GET_CUSTOM_VALUE() ; 
                            
                            if ( ContainsUrl ( (TCHAR*) pv ))
                            {
                                int nLenIn = ValidStyleUrl((TCHAR*) pv);
                                if ( nLenIn > 0 )
                                {
                                    TCHAR *pch = (TCHAR*) pv;
                                    TCHAR *psz = pch+4;
                                    TCHAR *quote = NULL;
                                    TCHAR *pszEnd;
                                    TCHAR terminator;

                                    dwOpCode |= HANDLEPROP_URLENCLOSE;

                                    while ( _istspace( *psz ) )
                                        psz++;
                                    if ( *psz == _T('\'') || *psz == _T('"') )
                                    {
                                        quote = psz++;
                                    }
                                    nLenIn--;   // Skip back over the ')' character - we know there is one, because ValidStyleUrl passed this string.
                                    pszEnd = pch + nLenIn - 1;
                                    while ( _istspace( *pszEnd ) && ( pszEnd > psz ) )
                                        pszEnd--;
                                    if ( quote && ( *pszEnd == *quote ) )
                                        pszEnd--;
                                    terminator = *(pszEnd+1);
                                    *(pszEnd+1) = _T('\0');

                                    pchCustom = psz;
                                }
                                else
                                {
                                    pchCustom =(TCHAR*) pv;
                                }
                            }
                            else
                            {
                                lNewValue = GetInvalidDefault();
                            }
                        }
                        else
                            lNewValue = GetInvalidDefault();
                    }
                }
            }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;
            pv = &lNewValue;
            break;

        case PROPTYPE_VARIANT:        
            if ( pv == NULL )
            {
                // Just have Tag=, ignore it
                return S_OK;
            }
            VariantInit ( &varDest );
            if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
            {          
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv, VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
                // Send it through the String handler
                goto SetFromString;
            }
            else
            {            
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv, VT_I4);
                if (hr)
                    goto Cleanup;
                pv = &V_I4(&varDest);
            }
            break;
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        if ( dwOpCode & HANDLEPROP_RUNTIMESTYLE )
            wFlags |= CAttrValue::AA_Extra_RuntimeStyle;
            
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
        
            // We need to preserve an existing hr
            hr2 = ppp->ValidateNumberProperty((long *)pv, pObject);
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }

            hr2 = !pchCustom ? ppp->SetNumber(pObject, pSubObject, *(long *)pv, wFlags) :
                               ppp->SetCustomNumber( pObject, pSubObject,*(long*)pv, wFlags, pchCustom );
            if ( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }

            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(bpp->dispid, bpp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            break;
            
        case HANDLEPROP_AUTOMATION:
        
            if ( hr )
                goto Cleanup;
            hr = ppp->SetNumberProperty(*(long *)pv, pObject, pSubObject,
                dwOpCode & HANDLEPROP_DONTVALIDATE ? FALSE : TRUE, wFlags );
            break;

        case HANDLEPROP_DEFAULT:
        
            Assert(pv == NULL);
            hr = !pchCustom ? ppp->SetNumber(pObject, pSubObject,(long)ulTagNotPresentDefault, wFlags) :
                              ppp->SetCustomNumber( pObject, pSubObject,(long)ulTagNotPresentDefault, wFlags, pchCustom );
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {        
        BOOL fFoundString = FALSE;
        CStr cstrCustom; 
        
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            hr = ppp->GetNumberProperty( &lTemp, pObject, pSubObject);
            if ( hr )
                goto Cleanup;
        
            if (  ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM && 
                 (unsigned) lTemp == GET_CUSTOM_VALUE() )
            {                
                fFoundString = TRUE;
                hr = THR( ppp->bpp.GetCustomString(  pSubObject, & cstrCustom ));
            }
            else
            {
                hr = ppp->GetNumberProperty( &lTemp, pObject, pSubObject);
                if ( hr )
                    goto Cleanup;            
            }         
            
            switch(PROPTYPE(dwOpCode))
            {
                case PROPTYPE_VARIANT:
                    pVariant = (VARIANT *)pv;
                    VariantInit ( pVariant );
                    if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
                    {
                        if ( ! fFoundString )
                        {
                            hr = LookupStringFromEnum( ppp, &V_BSTR(pVariant), lTemp );
                            if ( !hr )
                            {
                                V_VT( pVariant ) = VT_BSTR;
                            }
                            else
                            {
                                if ( hr != E_INVALIDARG)
                                    goto Cleanup;

                                hr = S_OK;
                            }
                        }
                        else
                        {
                            BSTR bstrCustom;
                            CStr cstrUnMunged;
                            hr = THR( UnMungeCustomUrl( & cstrCustom, & cstrUnMunged ));
                            if ( hr )
                                goto Cleanup;
                                
                            cstrUnMunged.AllocBSTR( & bstrCustom );

                            V_VT( pVariant ) = VT_BSTR;
                            V_BSTR( pVariant ) = bstrCustom;
                        }
                    }
                    if ( V_VT ( pVariant ) == VT_EMPTY )
                    {
                        V_VT ( pVariant ) = VT_I4;
                        V_I4 ( pVariant ) = lTemp;
                    }
                    break;

                case PROPTYPE_BSTR:
                    *((BSTR *)pv) = NULL;
                    if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
                    {
                        if ( ! ( (ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM) &&
                                  fFoundString ) )
                        {                   
                            hr = LookupStringFromEnum( ppp, (BSTR *)pv, lTemp );
                        }
                        else
                        {                            
                            CStr cstrEnd;
                            IFC( UnMungeCustomUrl( &cstrCustom, & cstrEnd ));
                            
                            IFC( cstrEnd.AllocBSTR( (BSTR*) pv  ));                            
                        }
                    }
                    else
                    {
                        TCHAR szNumber[33];
                        hr = THR( Format(0, szNumber, 32, _T("<0d>"), lTemp ) );
                        if ( hr == S_OK )
                            hr = FormsAllocString( szNumber, (BSTR *)pv );
                    }
                    break;

                default:
                    *(long *)pv = lTemp;
                    break;
            }
            break;

        case HANDLEPROP_STREAM:
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;
            pStmWrBuff = (CStreamWriteBuff *)pv;
            // If it's one of the enums, save out the enum string
            if ( ppp->bpp.dwPPFlags & PROPPARAM_ENUM )
            {
                if ( ppp->bpp.dwPPFlags & PROPPARAM_CUSTOMENUM && 
                     (unsigned) lNewValue == GET_CUSTOM_VALUE() )
                {
                    CStr    cstr, cstrResult;
                    
                    hr = THR( ppp->bpp.GetCustomString( pSubObject, & cstr ));
                    if ( hr )
                        goto Cleanup;
                    
                    IFC( UnMungeCustomUrl( & cstr, & cstrResult ));
                            
                    hr = pStmWrBuff->WriteQuotedText( (LPTSTR) cstrResult, FALSE);
                    if ( hr )
                        goto Cleanup;                    

                    goto Cleanup;                        
                }
                
                INT i;
                ENUMDESC *pEnumDesc = GetEnumDescriptor();
                // until the binary persistance we assume text save
                for (i = pEnumDesc->cEnums - 1; i >= 0; i--)
                {
                    if (lNewValue == pEnumDesc->aenumpairs[i].iVal)
                    {
                        hr = pStmWrBuff->WriteQuotedText(pEnumDesc->aenumpairs[i].pszName, FALSE);
                        goto Cleanup;
                    }
                }
            }
            // Either don't have an enum array or wasn't one of the enum values
            hr = WriteTextLong(pStmWrBuff, lNewValue);
            break;

        case HANDLEPROP_VALUE:
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if ( hr )
                goto Cleanup;
            switch (PROPTYPE(dwOpCode))
            {
            case VT_VARIANT:
                {
                ENUMDESC *pEnumDesc = GetEnumDescriptor();
                if ( pEnumDesc )
                {
                    hr = pEnumDesc->StringFromEnum ( lNewValue, &V_BSTR((VARIANT *)pv) );
                    if ( !hr )
                    {
                        ((VARIANT *)pv)->vt = VT_BSTR;
                        goto Cleanup;
                    }
                }

                // if the Numeric prop is boolean...
                if (GetNumPropParams()->vt == VT_BOOL)
                {
                    ((VARIANT *)pv)->boolVal = (VARIANT_BOOL)lNewValue;
                    ((VARIANT *)pv)->vt = VT_BOOL;
                    break;
                }

                // Either mixed enum/integer or plain integer return I4
                ((VARIANT *)pv)->lVal = lNewValue;
                ((VARIANT *)pv)->vt = VT_I4;
                }
                break;

            case VT_BSTR:
                {
                    ENUMDESC *pEnumDesc = GetEnumDescriptor();
                    if ( pEnumDesc )
                    {
                        hr = pEnumDesc->StringFromEnum ( lNewValue, (BSTR *)pv );
                        if ( !hr )
                        {
                            goto Cleanup;
                        }
                    }
                    // Either mixed enum/integer or plain integer return BSTR
                    varTemp.lVal = lNewValue;
                    varTemp.vt = VT_I4;   
                    hr = VariantChangeTypeSpecial ( &varTemp, &varTemp, VT_BSTR );
                    *(BSTR *)pv = V_BSTR(&varTemp);
                }
                break;

            default:
                Assert(PROPTYPE(dwOpCode) == 0);
                *(long *)pv = lNewValue;
                break;
            }
            break;

        case HANDLEPROP_COMPARE:
            hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
            if (hr)
                goto Cleanup;
            hr = ( lNewValue == *(long *)pv ) ? S_OK : S_FALSE;
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }

    RRETURN1(hr, E_INVALIDARG);
}

BOOL
ContainsUrl(TCHAR* pch)
{
    size_t i;
    size_t iSize = ARRAY_SIZE(strURLBeg) - 1;
    
    size_t nLen = pch ? _tcslen(pch) : 0 ;

    if ( nLen < iSize )
        return FALSE;
        
    for( i = 0; 
         i< nLen -  iSize ; 
         i++,pch++ )
    {
        if (0==_tcsnicmp(pch, iSize, strURLBeg, iSize))
        {
            return TRUE;
        }        
    }
    return FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleStringProperty, public
//
//  Synopsis:   Helper for getting/setting string value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (CStr in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------


HRESULT
PROPERTYDESC::HandleStringProperty(DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;
        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        if ( dwOpCode & HANDLEPROP_URLENCLOSE )
            wFlags |= CAttrValue::AA_Extra_UrlEnclosed;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            pv = (void *)ulTagNotPresentDefault;

            if (!pv)
                goto Cleanup;       // zero string

            // fall thru
        case HANDLEPROP_VALUE:
            hr = ppp->SetString(pSubObject, (TCHAR *)pv, wFlags);
            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr = THR(pObject->OnPropertyChange(ppp->dispid, ppp->dwFlags, (PROPERTYDESC *)this));
                if (hr)
                    goto Cleanup;
            }
            break;
        case HANDLEPROP_AUTOMATION:
            hr = ppp->SetStringProperty( (TCHAR *)pv, pObject, pSubObject, wFlags );
            break;
        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            {
                BSTR bstr;
                hr = ppp->GetStringProperty( &bstr, pObject, pSubObject );
                if(hr)
                    goto Cleanup;
                switch(PROPTYPE(dwOpCode))
                {
                case PROPTYPE_VARIANT:
                    V_VT((VARIANTARG *)pv) = VT_BSTR;
                    V_BSTR((VARIANTARG *)pv) = bstr;
                    break;
                case PROPTYPE_BSTR:
                    *(BSTR *)pv = bstr;
                    break;
                default:
                    Assert( "Wrong type for property!" );
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }

            }
            break;

        case HANDLEPROP_STREAM:
            {
                CStr cstr;

                // until the binary persistance we assume text save
                Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = WriteTextCStr((CStreamWriteBuff *)pv, &cstr, FALSE, ( ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY ) );
            }
            break;
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                CStr cstr;

                // PERF: istvanc this is bad, we allocate the string twice
                // we need a new API which allocates the BSTR directly
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = cstr.AllocBSTR(&((VARIANT *)pv)->bstrVal);
                if (hr)
                    goto Cleanup;

                ((VARIANT *)pv)->vt = VT_BSTR;
            }
            else if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                CStr cstr;

                // PERF: istvanc this is bad, we allocate the string twice
                // we need a new API which allocates the BSTR directly
                hr = ppp->GetString(pSubObject, &cstr);
                if (hr)
                    goto Cleanup;

                hr = cstr.AllocBSTR((BSTR *)pv);
            }
            else
            {
                Assert(PROPTYPE(dwOpCode) == 0);
                hr = ppp->GetString(pSubObject, (CStr *)pv);
            }
            break;
        case HANDLEPROP_COMPARE:
            {
                CStr cstr;
                hr = ppp->GetString ( pSubObject, &cstr );
                if ( hr )
                    goto Cleanup;
                LPTSTR lpThisString = (LPTSTR) cstr;
                if (lpThisString == NULL || *(TCHAR**)pv == NULL)
                {
                    hr = ( lpThisString == NULL &&  *(TCHAR**)pv == NULL ) ? S_OK : S_FALSE;
                }
                else
                {
                    hr = _tcsicmp(lpThisString, *(TCHAR**)pv) ? S_FALSE : S_OK;
                }
            }
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleEnumProperty, public
//
//  Synopsis:   Helper for getting/setting enum value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (long in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleEnumProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr;
    NUMPROPPARAMS * ppp = (NUMPROPPARAMS *)(this + 1);
    long lNewValue;

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        Assert(ppp->bpp.dwPPFlags & PROPPARAM_ENUM);
    }
    else if (OPCODE(dwOpCode) == HANDLEPROP_STREAM)
    {
        RRETURN1 ( HandleNumProperty ( dwOpCode,
            pv, pObject, pSubObject ), E_INVALIDARG );
    }
    else if (OPCODE(dwOpCode) == HANDLEPROP_COMPARE)
    {
        hr = ppp->GetNumber(pObject, pSubObject, &lNewValue);
        if (hr)
            goto Cleanup;
        // if inherited and not set, return S_OK
        hr = ( lNewValue == *(long *)pv ) ? S_OK : S_FALSE;
        RRETURN1(hr, S_FALSE);
    }

    hr = HandleNumProperty(dwOpCode, pv, pObject, pSubObject);

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------
//
//  Member:     PROPERTYDESC::HandleColorProperty, public
//
//  Synopsis:   Helper for getting/setting enum value properties
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (OLE_COLOR in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//----------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleColorProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK,hr2;
    BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);
    VARIANT     varDest;
    DWORD       dwNewValue;
    CColorValue cvValue;
    LPTSTR pStr;

    // just to be a little paranoid
    Assert(sizeof(OLE_COLOR) == 4);
    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        VariantInit(&varDest);
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            V_VT(&varDest) = VT_BSTR;
            V_BSTR(&varDest) = (BSTR)pv;
            break;
        case PROPTYPE_VARIANT:
            if ( pv == NULL )
            {
                // Just have Tag=, ignore it
                return S_OK;
            }
            break;
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }
        WORD wFlags = 0;
        if ( dwOpCode & HANDLEPROP_IMPORTANT )
            wFlags |= CAttrValue::AA_Extra_Important;
        if ( dwOpCode & HANDLEPROP_IMPLIED )
            wFlags |= CAttrValue::AA_Extra_Implied;
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
            pStr = (LPTSTR)pv;
            if ( pStr == NULL || !pStr[0] )
            {
                if ( IsNotPresentAsDefaultSet() || !UseNotAssignedValue() )
                    cvValue = *(CColorValue *)&ulTagNotPresentDefault;
                else
                    cvValue = *(CColorValue *)&ulTagNotAssignedDefault;
            }
            else
            {
                hr = cvValue.FromString(pStr, dwOpCode & HANDLEPROP_STRICTCSS1, (ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY));
                if (hr || S_OK != cvValue.IsValid())
                {
                    if ( IsInvalidAsNoAssignSet() && UseNotAssignedValue() )
                        cvValue = *(CColorValue *)&ulTagNotAssignedDefault;
                    else
                        cvValue = *(CColorValue *)&ulTagNotPresentDefault;
                }
           }
            // If we're just sniffing for a good parse - don't set up a default
            if ( hr && ISSAMPLING( dwOpCode ) )
                goto Cleanup;

            // if asp string, we need to store the original string itself as an unknown attr
            // skip leading white space.
            while (pStr && *pStr && _istspace(*pStr))
                pStr++;

            if (pStr && (*pStr == _T('<')) && (*(pStr+1) == _T('%')))
                hr = E_INVALIDARG;
 
            // We need to preserve the hr if there is one
            hr2 = ppp->SetColor(pSubObject, cvValue.GetRawValue(), wFlags );
            if (hr2)
            {
                hr = hr2;
                goto Cleanup;
            }
            
            if (dwOpCode & HANDLEPROP_MERGE)
            {
                hr2 = THR(pObject->OnPropertyChange(ppp->dispid, ppp->dwFlags, (PROPERTYDESC *)this));
                if (hr2)
                {
                    hr = hr2;
                    goto Cleanup;
                }
            }
            break;

        case HANDLEPROP_AUTOMATION:
            if (PROPTYPE(dwOpCode)==PROPTYPE_LPWSTR)
                hr = ppp->SetColorProperty( varDest, pObject, pSubObject, wFlags);
            else
                hr = ppp->SetColorProperty( *(VARIANT *)pv, pObject, pSubObject, wFlags);
            break;

        case HANDLEPROP_DEFAULT:
            Assert(pv == NULL);
            // CColorValue is initialized to VALUE_UNDEF.
            hr = ppp->SetColor(pSubObject, *(DWORD *)&ulTagNotPresentDefault, wFlags);
            break;
        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_AUTOMATION:
            {
                // this code path results from OM access. OM color's are 
                // always returned in Pound6 format.
                // make sure there is a subObject

                if (!pSubObject)
                    pSubObject = pObject;

                // get the dw Color value
                V_VT(&varDest) = VT_BSTR;
		V_BSTR(&varDest) = NULL;
                ppp->GetColor(pSubObject, &(V_BSTR(&varDest)), !(ppp->dwPPFlags & PROPPARAM_STYLESHEET_PROPERTY) );

                // Coerce to type to return
                switch(PROPTYPE(dwOpCode))
                {
                    case PROPTYPE_VARIANT:
                        VariantInit ( (VARIANT *)pv );
                        V_VT ( (VARIANT *)pv ) = VT_BSTR;
                        V_BSTR((VARIANT *)pv) = V_BSTR(&varDest);
                        break;
                    default:
                        *(BSTR *)pv = V_BSTR(&varDest);
                }
                hr = S_OK;
            }
            break;
        case HANDLEPROP_STREAM:
            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetColor(pSubObject, &dwNewValue);
            if (hr)
                goto Cleanup;
            cvValue = dwNewValue;

            hr = cvValue.Persist( (IStream *)pv, this );
            break;
        case HANDLEPROP_VALUE:
            if (PROPTYPE(dwOpCode) == PROPTYPE_VARIANT)
            {
                ((VARIANT *)pv)->vt = VT_UI4;
                hr = ppp->GetColor(pSubObject, &((VARIANT *)pv)->ulVal);
            }
            else
            if (PROPTYPE(dwOpCode) == PROPTYPE_BSTR)
            {
                hr = ppp->GetColorProperty(&varDest, pObject, pSubObject);
                if (hr)
                    goto Cleanup;
                *(BSTR *)pv = V_BSTR(&varDest);
            }
            else
            {
                Assert(PROPTYPE(dwOpCode) == 0);
                hr = ppp->GetColor(pSubObject, (DWORD *)pv);
            }
            break;
        case HANDLEPROP_COMPARE:
            hr = ppp->GetColor(pSubObject, &dwNewValue);
            if (hr)
                goto Cleanup;
            // if inherited and not set, return S_OK
            hr = dwNewValue == *(DWORD *)pv ? S_OK : S_FALSE;
            RRETURN1(hr,S_FALSE);
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}

//+---------------------------------------------------------------------------
//  Member: HandleUrlProperty
//
//  Synopsis : Handler for Getting/setting Url typed properties
//              pretty much, the only thing this needs to do is strip out CR/LF;s and 
//                  call the HandleStringProperty
//
//  Arguments:  dwOpCode        -- encodes the incoming type (PROPTYPE_FLAG) in the upper WORD and
//                                 the opcode in the lower WORD (HANDLERPROP_FLAGS)
//                                 PROPTYPE_EMPTY means the 'native' type (OLE_COLOR in this case)
//              pv              -- points to the 'media' the value is stored for the get and set
//              pObject         -- object owns the property
//              pSubObject      -- subobject storing the property (could be the main object)
//
//+---------------------------------------------------------------------------
HRESULT
PROPERTYDESC::HandleUrlProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT hr = S_OK;
    TCHAR   *pstrNoCRLF=NULL;
    VARIANT     varDest;

    varDest.vt = VT_EMPTY;
    if ISSET(dwOpCode)
    {
        // First handle the storage type
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...
        switch(PROPTYPE(dwOpCode))
        {
        case PROPTYPE_LPWSTR:
            break;
        case PROPTYPE_VARIANT:
            if (V_VT((VARIANT *)pv) == VT_BSTR)
            {
                pv = (void *)V_BSTR((VARIANT *)pv);
            }
            else
            {
                hr = VariantChangeTypeSpecial(&varDest, (VARIANT *)pv,  VT_BSTR);
                if (hr)
                    goto Cleanup;
                pv = V_BSTR(&varDest);
            }
        default:
            Assert(PROPTYPE(dwOpCode) == 0);    // assumed native long
        }

        //then handle the operation
        switch(OPCODE(dwOpCode))
        {
            case HANDLEPROP_VALUE:
            case HANDLEPROP_DEFAULT:
                hr =THR(StripCRLF((TCHAR *)pv, &pstrNoCRLF));
                if (hr)
                    goto Cleanup;

                hr = THR(HandleStringProperty( dwOpCode, (void *)pstrNoCRLF, pObject, pSubObject));
    
                if (pstrNoCRLF)
                    MemFree(pstrNoCRLF);
                goto Cleanup;
                break;
        }
    }
    else
    {   // NOTE: This code should not be necessary - it forces us to always quote URLs when
        // persisting.  It is here to circumvent an Athena bug (IEv4.1 RAID #20953) - CWilso
        if(ISSTREAM(dwOpCode))
        {   // Have to make sure we quote URLs when persisting.
            CStr cstr;
            BASICPROPPARAMS * ppp = (BASICPROPPARAMS *)(this + 1);

            // until the binary persistance we assume text save
            Assert(PROPTYPE(dwOpCode) == PROPTYPE_LPWSTR);
            hr = ppp->GetString(pSubObject, &cstr);
            if (hr)
                goto Cleanup;

            hr = WriteTextCStr((CStreamWriteBuff *)pv, &cstr, TRUE, FALSE );
            goto Cleanup;
        }
    }

    hr = THR(HandleStringProperty( dwOpCode, pv, pObject, pSubObject));

Cleanup:
    if (varDest.vt != VT_EMPTY)
    {
        VariantClear(&varDest);
    }
    if ( OPCODE(dwOpCode)== HANDLEPROP_COMPARE )
        RRETURN1( hr, S_FALSE );
    else
        RRETURN1( hr, E_INVALIDARG );
}


const CUnitValue::TypeDesc CUnitValue::TypeNames[] =
{
    { _T("null"), UNIT_NULLVALUE,       SHIFTOFFSET_NULLVALUE    , SCALEMULT_NULLVALUE     }, // Never used
    { _T("pt"),   UNIT_POINT,           SHIFTOFFSET_POINT        , SCALEMULT_POINT         },
    { _T("pc"),   UNIT_PICA,            SHIFTOFFSET_PICA         , SCALEMULT_PICA          },
    { _T("in"),   UNIT_INCH,            SHIFTOFFSET_INCH         , SCALEMULT_INCH          },
    { _T("cm"),   UNIT_CM,              SHIFTOFFSET_CM           , SCALEMULT_CM            },
    { _T("mm"),   UNIT_MM,              SHIFTOFFSET_MM           , SCALEMULT_MM            }, // Chosen to match HIMETRIC
    { _T("em"),   UNIT_EM,              SHIFTOFFSET_EM           , SCALEMULT_EM            },
    { _T("ex"),   UNIT_EX,              SHIFTOFFSET_EX           , SCALEMULT_EX            },
    { _T("px"),   UNIT_PIXELS,          SHIFTOFFSET_PIXELS       , SCALEMULT_PIXELS        },
    { _T("%"),    UNIT_PERCENT,         SHIFTOFFSET_PERCENT      , SCALEMULT_PERCENT       },
    { _T("*"),    UNIT_TIMESRELATIVE,   SHIFTOFFSET_TIMESRELATIVE, SCALEMULT_TIMESRELATIVE },
    { _T("float"),UNIT_FLOAT,           SHIFTOFFSET_FLOAT        , SCALEMULT_FLOAT         },
};

#define LOCAL_BUF_COUNT   (pdlLength + 1)

HRESULT
CUnitValue::NumberFromString ( LPCTSTR pStr, const PROPERTYDESC *pPropDesc, BOOL fStrictCSS1 )
{
    BOOL fIsSigned = FALSE;
    long lNewValue = 0;
    LPCTSTR pStartPoint = NULL;
    UNITVALUETYPE uvt = UNIT_INTEGER;
    WORD i,j,k;
    HRESULT hr = S_OK;
    TCHAR tcValue [ LOCAL_BUF_COUNT ];  
    WORD wShift;
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);
    long lExponent = 0;
    BOOL fNegativeExponent = FALSE;

    enum ParseState
    {
        Starting,
        AfterPoint,
        AfterE,
        InExponent,
        InTypeSpecifier,
        ParseState_Last_enum
    } State = Starting;

    UINT uNumChars =0;
    UINT uPrefixDigits = 0;
    BOOL fSeenDigit = FALSE;
    BOOL fSeenAfterPointDigit = FALSE;
    BOOL fSeenTypeSpecifier = FALSE;

    // Find the unit specifier
    for ( i = 0 ; uNumChars < LOCAL_BUF_COUNT ; i++ )
    {
        switch ( State )
        {
        case Starting:
            if ( i == 0 && ( pStr [ i ] == _T('-') || pStr [ i ] == _T('+')  ) )
            {
                tcValue [ uNumChars++ ] = pStr [ i ]; uPrefixDigits++;
                fIsSigned = TRUE;
            }
            else if ( !_istdigit ( pStr [ i ] ) )
            {
                if ( pStr [ i ] == _T('.') )
                {
                    State = AfterPoint;
                }
                else if ( pStr[ i ] == _T('\0') || pStr[ i ] == _T('\"')  ||pStr[ i ] == _T('\'') )
                {
                    goto Convert;
                }
                else
                {
                    // such up white space, and treat whatevers left as the type
                    if (fStrictCSS1 && _istspace(pStr[i]))
                    {
                        /* (gschneid) In strict mode if we encounter here a space we MUST have 
                         * seen everything in this line because spaces are not allowed between
                         * number and unit specifier in a measure. E.g. 100px is valid but not
                         * 100 px. We do NOT necessarily need a unit specifier. E.g. in line-height
                         * or in zoom. For example "zoom: 3" means 3 times zoom.
                         * Again, it might be valid iff we have parsed everything except white spaces. 
                         * This is checked at the end of the function.
                         */

                        // We skip white spaces.
                        while (_istspace(pStr[i]))
                            i++;

                        if (pStr[i] == _T('\0'))
                        {                        
                            // If we are at the end of the string we are fine because there is no unit
                            // specifier. 
                            goto Convert;
                        }
                        else
                        {
                            // There is another character, i.e. we have a situation like "100 px".
                            // Because we are under strict css we bail out.
                            hr = E_INVALIDARG;
                            goto Cleanup;
                        }
                    }
                        
                    while ( _istspace ( pStr [ i ] ) )
                        i++;
                    
                    pStartPoint = pStr + i;
                    State = ( pStr [ i ] == _T('e') || pStr [ i ] == _T('E') ) ? AfterE : InTypeSpecifier;
                }
            }
            else
            {
                fSeenDigit = TRUE;
                tcValue [ uNumChars++ ] = pStr [ i ]; uPrefixDigits++;
            }
            break;


        case AfterPoint:
            if ( !_istdigit ( pStr [ i ] ) )
            {
                if (fStrictCSS1 && !fSeenAfterPointDigit)
                {
                    /* 
                     * Under strict css there must be a digit after the period. E.g. 1.px is not
                     * allowed. See CSS2 Spec, D.2 Lexical Scanner.
                     * Here we are after the period and have not seen a digit and therefore have
                     * an invalid specification.
                     */
                    hr = E_INVALIDARG;
                    goto Cleanup;
                }
                     
                if (fStrictCSS1 && _istspace(pStr[i]))
                {
                    /* (gschneid) In strict mode if we encounter here a space we MUST have 
                     * seen everything in this line because spaces are not allowed between
                     * number and unit specifier in a measure. E.g. 1.333px is valid but not
                     * 1.333 px. We do NOT necessarily need a unit specifier. E.g. in line-height
                     * or in zoom. For example "zoom: 3.0" means 3.0 times zoom.
                     * Again, it might be valid iff we have parsed everything except white spaces. 
                     * This is checked at the end of the function.
                     */

                    // We skip white spaces.
                    while (_istspace(pStr[i]))
                        i++;

                    if (pStr[i] == _T('\0'))
                    {                        
                        // If we are at the end of the string we are fine because there is no unit
                        // specifier. 
                        goto Convert;
                    }
                    else
                    {
                        // There is another character, i.e. we have a situation like "100 px".
                        // Because we are under strict css we bail out.
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                }

                if ( pStr [ i ] == _T('\0') )
                {
                    goto Convert;
                }
                else if ( !_istspace ( pStr [ i ] ) )
                {
                    pStartPoint = pStr + i;
                    State = ( pStr [ i ] == _T('e') || pStr [ i ] == _T('E') ) ? AfterE : InTypeSpecifier;
                }
            }
            else
            {
                fSeenDigit = TRUE;
                fSeenAfterPointDigit = TRUE;
                tcValue [ uNumChars++ ] = pStr [ i ];
            }
            break;

        case AfterE:
            if ( pStr [ i ] == _T('-') || pStr [ i ] == _T('+')  ||
                 _istdigit ( pStr [ i ] ) )
            {   // Looks like scientific notation to me.
                if ( _istdigit ( pStr [ i ] ) )
                    lExponent = pStr [ i ] - _T('0');
                else if ( pStr [ i ] == _T('-') )
                    fNegativeExponent = TRUE;
                State = InExponent;
                break;
            }
            // Otherwise, this must just be a regular old "em" or "en" type specifier-
            // Set the state and let's drop back into this switch with the same char...
            State = InTypeSpecifier;
            i--;
            break;

        case InExponent:
            if ( _istdigit ( pStr [ i ] ) )
            {
                lExponent *= 10;
                lExponent += pStr [ i ] - _T('0');
                break;
            }
            while ( _istspace ( pStr [ i ] ) )
                i++;
            if ( pStr [ i ] == _T('\0') )
                goto Convert;
            State = InTypeSpecifier;    // otherwise, fall through to type handler
            pStartPoint = pStr + i;

        case InTypeSpecifier:
            if ( _istspace ( pStr [ i ] ) )
            {
                if ( pPropDesc->IsStyleSheetProperty() )
                {
                    // In style sheets this checks that there is nothing after the unit specifier.
                    while ( _istspace ( pStr [ i ] ) )
                        i++;
                    if ( pStr [ i ] != _T('\0') )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                }
                goto CompareTypeNames;
            }
            if ( pStr [ i ] == _T('\0') )
            {
CompareTypeNames:
                for ( j = 0 ; j < ARRAY_SIZE ( TypeNames ) ; j++ )
                {
                    if ( TypeNames[ j ].pszName )
                    {
                        int iLen = _tcslen( TypeNames[ j ].pszName );

                        if ( _tcsnipre( TypeNames [ j ].pszName, iLen, pStartPoint, -1 ) )
                        {
                            if ( pPropDesc->IsStyleSheetProperty() )
                            {
                                if ( pStartPoint[ iLen ] && !_istspace( pStartPoint[ iLen ] ) )
                                    continue;
                            }
                            break;
                        }
                    }
                }
                if ( j == ARRAY_SIZE ( TypeNames ) )
                {
                    if ( ( ppp -> bpp.dwPPFlags & PP_UV_UNITFONT ) == PP_UV_UNITFONT )
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    }
                    // In strict css1 mode invalid unit specifiers are invalid; in comp mode we just ignore them (and therefore assume later px)
                    if (fStrictCSS1)
                    {
                        hr = E_INVALIDARG;
                        goto Cleanup;
                    } 
                    else
                    {
                        goto Convert;
                    }
                }
                uvt = TypeNames [ j ].uvt;
                fSeenTypeSpecifier = TRUE;
                goto Convert;
            }
            break;
        }
    }

Convert:

    if ( !fSeenDigit && uvt != UNIT_TIMESRELATIVE )
    {
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            long lEnum;
            hr = LookupEnumString ( ppp, (LPTSTR)pStr, &lEnum );
            if ( hr == S_OK )
            {
                SetValue ( lEnum, UNIT_ENUM );
                goto Cleanup;
            }
        }

        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( fIsSigned && uvt == UNIT_INTEGER && ( ( ppp->bpp.dwPPFlags & PP_UV_UNITFONT ) != PP_UV_UNITFONT ) )
    {
        uvt = UNIT_RELATIVE;
    }


    // If the validation for this attribute does not require that we distinguish
    // between integer and relative, just store integer

    // Currently the only legal relative type is a Font size, if this changes either
    // add a separte PROPPARAM_ or do something else
    if ( uvt == UNIT_RELATIVE && !(ppp -> bpp.dwPPFlags & PROPPARAM_FONTSIZE ))
    {
        uvt = UNIT_INTEGER;
    }

    // If a unit was supplied that is not valid for this propdesc,
    // drop back to the default (pixels if no notpresent and notassigned defaults)
    if ( ( IsScalerUnit ( uvt ) && !(ppp -> bpp.dwPPFlags & PROPPARAM_LENGTH ) ) ||
        ( uvt == UNIT_PERCENT && !(ppp -> bpp.dwPPFlags & PROPPARAM_PERCENTAGE ) ) ||
        ( uvt == UNIT_TIMESRELATIVE && !(ppp -> bpp.dwPPFlags & PROPPARAM_TIMESRELATIVE ) ) ||
        ( ( uvt == UNIT_INTEGER ) && !(ppp -> bpp.dwPPFlags & PROPPARAM_FONTSIZE ) ) )
    {   // If no units where specified and a default unit is specified, use it
        if ( ( uvt != UNIT_INTEGER ) && pPropDesc->IsStyleSheetProperty() ) // Stylesheet unit values only:
        {   // We'll default unadorned numbers to "px", but we won't change "100%" to "100px" if percent is not allowed.
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        CUnitValue uv;
        uv.SetRawValue ( (long)pPropDesc -> ulTagNotPresentDefault );
        uvt = uv.GetUnitType();
        if ( uvt == UNIT_NULLVALUE )
        {
            uv.SetRawValue ( (long)pPropDesc -> ulTagNotAssignedDefault );
            uvt = uv.GetUnitType();
            if ( uvt == UNIT_NULLVALUE )
                uvt = UNIT_PIXELS;
        }
    }

    // Check the various types, don't do the shift for the various types
    switch ( uvt )
    {
    case UNIT_INTEGER:
    case UNIT_RELATIVE:
    case UNIT_ENUM:
        wShift = 0;
        break;

    default:
        wShift = TypeNames [ uvt ].wShiftOffset;
        break;
    }

    if ( lExponent && !fNegativeExponent && ( ( uPrefixDigits + wShift ) < uNumChars ) )
    {
        long lAdditionalShift = uNumChars - ( uPrefixDigits + wShift );
        if ( lAdditionalShift > lExponent )
            lAdditionalShift = lExponent;
        wShift += (WORD)lAdditionalShift;
        lExponent -= lAdditionalShift;
    }
    // uPrefixDigits tells us how may characters there are before the point;
    // Assume we're always shifting to the right of the point
    k = (uPrefixDigits + wShift < LOCAL_BUF_COUNT) ? uPrefixDigits + wShift : LOCAL_BUF_COUNT - 1;
    tcValue [ k ] = _T('\0');
    for ( j = (WORD)uNumChars; j < k ; j++ )
    {
        tcValue [ j ] = _T('0');
    }

    // Skip leading zeros, they confuse StringToLong
    for ( pStartPoint = tcValue ; *pStartPoint == _T('0') && *(pStartPoint+1) != _T('\0') ; pStartPoint++ );

    if (*pStartPoint)
    {
        hr = ttol_with_error( pStartPoint, &lNewValue);
        // returns LONG_MIN or LONG_MIN on overflow
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else if (uvt != UNIT_TIMESRELATIVE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((uvt == UNIT_TIMESRELATIVE) && (lNewValue == 0))
    {
        lNewValue = 1 * TypeNames[UNIT_TIMESRELATIVE].wScaleMult;
    }

    if ( fNegativeExponent )
    {
        while ( lNewValue && lExponent-- > 0 )
            lNewValue /= 10;
    }
    else
    {
        while ( lExponent-- > 0 )
        {
            if ( lNewValue > LONG_MAX/10 )
            {
                lNewValue = LONG_MAX;
                break;
            }
            lNewValue *= 10;
        }
    }

    // iff in strict css1 mode AND there was NO unit specifier THEN we only have a legal specification
    // iff either the specified value is 0 or we specify line-height (According to CSS1 spec a line-height 
    // spec without a unit specifier means that <line-height> := <specfied value> * <font-size>. For a 0 value 
    // no unit specifier is need according to CSS1).
    // By the way: Invalid unit specifiers are NOT allowed. See above in the section where the unit (type)
    // specifier is parsed.
    if (fStrictCSS1 && !fSeenTypeSpecifier && lNewValue) 
    {
        DISPID dispid = ppp->GetPropertyDesc()->GetDispid();
        // we are not looking at a lineheight or zoom spec.
        // !!!! When adding new attributes this NEEDS MAINTAINANCE. The straight forward solution would be to add
        // !!!! a flag to the property parameters to be able to specify that no unit specifier is needed.
        if ((dispid != DISPID_A_LINEHEIGHT) && (dispid != DISPID_A_ZOOM))
        { 
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    SetValue ( lNewValue, uvt );

Cleanup:
    RRETURN1 ( hr, E_INVALIDARG );
}

long 
CUnitValue::SetValue ( long lVal, UNITVALUETYPE uvt ) 
{
    if ( lVal > (LONG_MAX>>NUM_TYPEBITS ))
        lVal = LONG_MAX>>NUM_TYPEBITS;
    else if ( lVal < (LONG_MIN>>NUM_TYPEBITS) )
        lVal = LONG_MIN>>NUM_TYPEBITS;
    return _lValue = (lVal << NUM_TYPEBITS) | uvt; 
}


HRESULT
CUnitValue::Persist (
    IStream *pStream,
    const PROPERTYDESC *pPropDesc ) const
{
    TCHAR   cBuffer [ 30 ];
    int     iBufSize = ARRAY_SIZE ( cBuffer );
    LPTSTR  pBuffer = (LPTSTR)&cBuffer;
    HRESULT hr;
    UNITVALUETYPE   uvt = GetUnitType();

    if (uvt==UNIT_PERCENT )
    {
        *pBuffer++ = _T('\"');
        iBufSize--;
    }

    hr = FormatBuffer ( pBuffer, iBufSize, pPropDesc );
    if ( hr )
        goto Cleanup;

    // and finally the close quotes
    if (uvt==UNIT_PERCENT )
        _tcscat(cBuffer, _T("\""));

    hr = WriteText ( pStream, cBuffer );

Cleanup:
    RRETURN ( hr );
}


// We usually do not append default unit types to the string we return. Setting fAlwaysAppendUnit
//   to true forces the unit to be always appended to the number
HRESULT
CUnitValue::FormatBuffer ( LPTSTR szBuffer, UINT uMaxLen, 
                        const PROPERTYDESC *pPropDesc, BOOL fAlwaysAppendUnit /*= FALSE */) const
{
    HRESULT         hr = S_OK;
    UNITVALUETYPE   uvt = GetUnitType();
    long            lUnitValue = GetUnitValue();
    TCHAR           ach[20 ];
    int             nLen,i,nOutLen = 0;
    BOOL            fAppend = TRUE;

    switch ( uvt )
    {
    case UNIT_ENUM:
        {
            ENUMDESC *pEnumDesc;
            LPCTSTR pcszEnum;

            Assert( ( ((NUMPROPPARAMS *)(pPropDesc + 1))->bpp.dwPPFlags & PROPPARAM_ENUM ) && "Not an enum property!" );

            hr = E_INVALIDARG;
            pEnumDesc = pPropDesc->GetEnumDescriptor();
            if ( pEnumDesc )
            {
                pcszEnum = pEnumDesc->StringPtrFromEnum( lUnitValue );
                if ( pcszEnum )
                {
                    _tcsncpy( szBuffer, pcszEnum, uMaxLen );
                    szBuffer[ uMaxLen - 1 ] = _T('\0');
                    hr = S_OK;
                }
            }
        }
        break;

    case UNIT_INTEGER:
        hr = Format(0, szBuffer, uMaxLen, _T("<0d>"), lUnitValue);
        break;

    case UNIT_RELATIVE:
        if ( lUnitValue >= 0 )
        {
            szBuffer [ nOutLen++ ] = _T('+');
        }
        hr = Format(0, szBuffer+nOutLen, uMaxLen-nOutLen, _T("<0d>"), lUnitValue);
        break;

    case UNIT_NULLVALUE:
        // TODO: Need to chage save code to NOT comapre the lDefault directly
        // But to go through the handler
        szBuffer[0] = 0;
        hr = S_OK;
        break;

    case UNIT_TIMESRELATIVE:
        _tcscpy ( szBuffer, TypeNames [ uvt ].pszName );
        hr = Format(0, szBuffer+_tcslen ( szBuffer ), uMaxLen-_tcslen ( szBuffer ),
            _T("<0d>"), lUnitValue);
        break;

    default:
        hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), lUnitValue);
        if ( hr )
            goto Cleanup;

        nLen = _tcslen ( ach );

        LPTSTR pStr = ach;

        if ( ach [ 0 ] == _T('-') )
        {
            szBuffer [ nOutLen++ ] = _T('-');
            pStr++; nLen--;
        }

        if ( nLen > TypeNames [ uvt ].wShiftOffset )
        {
            for ( i = 0 ; i < ( nLen - TypeNames [ uvt ].wShiftOffset ) ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
            szBuffer [ nOutLen++ ] = _T('.');
            for ( i = 0 ; i < TypeNames [ uvt ].wShiftOffset ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
        }
        else
        {
            szBuffer [ nOutLen++ ] = _T('0');
            szBuffer [ nOutLen++ ] = _T('.');
            for ( i = 0 ; i < ( TypeNames [ uvt ].wShiftOffset - nLen ) ; i++ )
            {
                szBuffer [ nOutLen++ ] = _T('0');
            }
            for ( i = 0 ; i < nLen ; i++ )
            {
                szBuffer [ nOutLen++ ] = *pStr++;
            }
        }

        // Strip trailing 0 digits. If there's at least one trailing digit put a point
        for ( i = nOutLen-1 ; ; i-- )
        {
            if ( szBuffer [ i ] == _T('.') )
            {
                nOutLen--;
                break;
            }
            else if ( szBuffer [ i ] == _T('0') )
            {
                nOutLen--;
            }
            else
            {
                break;
            }
        }

        // Append the type prefix, unless it's the default and not forced
        if(uvt == UNIT_FLOAT)
        {
            fAppend = FALSE;
        }
        else if(!fAlwaysAppendUnit && !( pPropDesc->GetPPFlags() & PROPPARAM_LENGTH ) )
        {
            CUnitValue      uvDefault;
            uvDefault.SetRawValue ( pPropDesc -> ulTagNotPresentDefault );
            UNITVALUETYPE   uvtDefault = uvDefault.GetUnitType();

            if(uvt == uvtDefault || (uvtDefault == UNIT_NULLVALUE && uvt == UNIT_PIXELS))
            {
                fAppend = FALSE;
            }
        }

        if(fAppend)
            _tcscpy ( szBuffer + nOutLen, TypeNames [ uvt ].pszName );
        else
            szBuffer [ nOutLen ] = _T('\0');
                
        break;
    }
Cleanup:
    RRETURN ( hr );
}

HRESULT
CUnitValue::IsValid ( const PROPERTYDESC *pPropDesc ) const
{
    HRESULT hr = S_OK;
    BOOL    fTestAnyHow=FALSE;
    UNITVALUETYPE uvt = GetUnitType();
    long lUnitValue = GetUnitValue();
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);

    if ( ( ppp->lMin == 0 ) && ( lUnitValue < 0 ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    switch ( uvt )
    {
    case UNIT_TIMESRELATIVE:
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_TIMESRELATIVE ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_ENUM:
        if ( !(ppp->bpp.dwPPFlags & PROPPARAM_ENUM) &&
             !(ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_INTEGER:
        if ( !(ppp->bpp.dwPPFlags & PROPPARAM_FONTSIZE) && 
             !(ppp->bpp.dwPPFlags & PROPPARAM_ANUMBER) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_RELATIVE:
        if ( ppp ->bpp.dwPPFlags & PROPPARAM_FONTSIZE )
        {
            // Netscape treats any FONTSIZE as valid . A value greater than
            // 6 gets treated as seven, less than -6 gets treated as -6.
            // 8 and 9 get treated as "larger" and "smaller".
            goto Cleanup;
        }
        else if ( !( ppp ->bpp.dwPPFlags & PROPPARAM_ANUMBER ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        break;

    case UNIT_PERCENT:
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_PERCENTAGE ) )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            long lMin = ((CUnitValue*)&(ppp->lMin))->GetUnitValue();
            long lMax = ((CUnitValue*)&(ppp->lMax))->GetUnitValue();

            lUnitValue = lUnitValue /  TypeNames [ UNIT_PERCENT ].wScaleMult;

            if ( lUnitValue < lMin || lUnitValue > lMax )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
        break;

    case UNIT_NULLVALUE: // Always valid
        break;

    case UNIT_PIXELS:  // pixels are HTML and CSS valid
        fTestAnyHow = TRUE;
        // fall through

    case UNIT_FLOAT:
    default:  // other Units of measurement are only CSS valid
        if ( ! ( ppp ->bpp.dwPPFlags & PROPPARAM_LENGTH ) && !fTestAnyHow)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
            // it is a length but sometimes we do not want negatives
            long lMin = ((CUnitValue*)&(ppp->lMin))->GetUnitValue();
            long lMax = ((CUnitValue*)&(ppp->lMax))->GetUnitValue();
            if ( lUnitValue < lMin || lUnitValue > lMax )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }

        break;
    }
Cleanup:
    RRETURN1 ( hr, E_INVALIDARG );
}

// The following conversion table converts whole units of basic types and assume
// 1 twip = 1/20 point
// 1 pica = 12 points
// 1 point = 1/72 inch
// 1 in = 2.54 cm

#define CVIX(off) ( off - UNIT_POINT )

const CUnitValue::ConvertTable CUnitValue::BasicConversions[6][6] =
{
    {  // From UNIT_POINT
        { 1,1 },                // To UNIT_POINT
        { 1,12 },               // To UNIT_PICA
        { 1, 72 },              // To UNIT_INCH
        { 1*254, 72*100 },      // To UNIT_CM
        { 1*2540, 72*100 },     // To UNIT_MM
        { 20,1 },               // To UNIT_EM 
    },
    { // From UNIT_PICA
        { 12,1 },               // To UNIT_POINT
        { 1,1 },                // To UNIT_PICS
        { 12, 72 },             // To UNIT_INCH
        { 12*254, 72*100 },     // To UNIT_CM
        { 12*2540, 72*100 },    // To UNIT_MM
        { 20*12, 1 },           // To UNIT_EM 
    },
    { // From UNIT_INCH
        { 72,1 },               // To UNIT_POINT
        { 72,12 },              // To UNIT_PICA
        { 1, 1 },               // To UNIT_INCH
        { 254, 100 },           // To UNIT_CM
        { 2540, 100 },          // To UNIT_MM
        { 1440,1 },             // To UNIT_EM 
    },
    { // From UNIT_CM
        { 72*100,1*254 },        // To UNIT_POINT
        { 72*100,12*254 },       // To UNIT_PICA
        { 100, 254 },            // To UNIT_INCH
        { 1, 1 },                // To UNIT_CM
        { 10, 1 },               // To UNIT_MM
        { 20*72*100, 254 },      // To UNIT_EM 
    },
    { // From UNIT_MM
        { 72*100,1*2540 },       // To UNIT_POINT
        { 72*100,12*2540 },      // To UNIT_PICA
        { 100, 2540 },           // To UNIT_INCH
        { 10, 1 },               // To UNIT_CM
        { 1,1 },                 // To UNIT_MM
        { 20*72*100, 2540 },     // To UNIT_EM 
    },
    { // From UNIT_EM
        { 1,20 },                // To UNIT_POINT
        { 1, 20*12 },            // To UNIT_PICA
        { 1, 20*72 },            // To UNIT_INCH
        { 254, 20*72*100 },      // To UNIT_CM
        { 2540, 20*72*100 },     // To UNIT_MM
        { 1,1 },                 // To UNIT_EM 
    },
};

// EM's, EN's and EX's get converted to pixels

// Whever we convert to-from pixels we use the screen logpixs to ensure that the screen size
// matches the printer size


/* static */
long CUnitValue::ConvertTo( long lValue, 
                            UNITVALUETYPE uvtFromUnits, 
                            UNITVALUETYPE uvtTo, 
                            DIRECTION direction,
                            long  lFontHeight,          // = 1 
                            SIZE  *psizeInch )          // = NULL
{
    UNITVALUETYPE uvtToUnits;
    long lFontMul = 1,lFontDiv = 1;

    if ( uvtFromUnits == uvtTo )
    {
        return lValue;
    }

    if ( uvtFromUnits == UNIT_PIXELS )
    {
        SIZE const* psizeLogInch = psizeInch ? psizeInch : &g_uiDisplay.GetResolution();
        int logPixels = ( direction == DIRECTION_CX ) ? psizeLogInch->cx : psizeLogInch->cy;
        
        // Convert to inches ( stored precision )
        lValue = MulDivQuick ( lValue, TypeNames [ UNIT_INCH ].wScaleMult,
            logPixels );

        uvtFromUnits = UNIT_INCH;
        uvtToUnits = uvtTo;
    }
    else if ( uvtTo == UNIT_PIXELS )
    {
        uvtToUnits = UNIT_INCH;
    }
    else
    {
        uvtToUnits = uvtTo;
    }

    if ( uvtToUnits == UNIT_EM )
        lFontDiv = lFontHeight;
    if ( uvtFromUnits == UNIT_EM )
        lFontMul = lFontHeight;

    if ( uvtToUnits == UNIT_EX )
    {
        lFontDiv = lFontHeight*2;
        uvtToUnits = UNIT_EM;
    }
    if ( uvtFromUnits == UNIT_EX )
    {
        lFontMul = lFontHeight/2;
        uvtFromUnits = UNIT_EM;
    }

    // Note that we perform two conversions in one here to avoid losing
    // intermediate accuracy for conversions to pixels, i.e. we're converting
    // units to inches and from inches to pixels.
    if ( uvtTo == UNIT_PIXELS )
    {
        SIZE const* psizeLogInch = psizeInch ? psizeInch : &g_uiDisplay.GetResolution();
        int logPixels = ( direction == DIRECTION_CX ) ? psizeLogInch->cx : psizeLogInch->cy;

        lValue = MulDivQuick ( lValue,
            lFontMul * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lMul * 
                               TypeNames [ uvtToUnits ].wScaleMult * logPixels,
            lFontDiv * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lDiv * 
                               TypeNames [ uvtFromUnits ].wScaleMult *
                               TypeNames [ UNIT_INCH ].wScaleMult );
    }
    else
    {
        lValue = MulDivQuick ( lValue,
            lFontMul * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lMul * 
                               TypeNames [ uvtToUnits ].wScaleMult ,
            lFontDiv * BasicConversions [CVIX(uvtFromUnits)][CVIX(uvtToUnits)].lDiv * 
                               TypeNames [ uvtFromUnits ].wScaleMult);
    }        


    return lValue;
}



// Set the Percent Value - Don't need a transform because we assume lNewValue is in the
// same transform as lPercentOfValue
BOOL CUnitValue::SetPercentValue ( long lNewValue, DIRECTION direction, long lPercentOfValue )
{
    UNITVALUETYPE uvtToUnits = GetUnitType() ;
    long lUnitValue = GetUnitValue();

    // Set the internal percentage to reflect what percentage of lMaxValue
    if ( lPercentOfValue == 0 )
    {
        lUnitValue = 0;
    }
    else if ( uvtToUnits == UNIT_PERCENT )
    {
        lUnitValue = MulDivQuick ( lNewValue, 100*TypeNames [ UNIT_PERCENT ].wScaleMult, lPercentOfValue  );
    }
    else
    {
        lUnitValue = MulDivQuick ( lNewValue, TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult, lPercentOfValue  );
    }
    SetValue ( lUnitValue, uvtToUnits );
    return TRUE;
}

long CUnitValue::GetPixelValueCore ( CDocScaleInfo const *pdocScaleInfo, 
                                     DIRECTION direction,
                                     long lPercentOfValue,
                                     long lFontHeight /* =1 */) const
{
    UNITVALUETYPE uvtFromUnits = GetUnitType() ;
    long lRetValue;

    SIZE sizeInch;

    // (dmitryt) we come here without pdocScaleInfo from CHTMLDlg code
    //(see CHTMLDlg::GetWidth() for example). In this case, we want screen 
    //resolution (we are about to size dialog window on screen)
    // IE6 bug 7049
    if (pdocScaleInfo)
        sizeInch = pdocScaleInfo->GetDocPixelsPerInch();
    else
        sizeInch = g_uiDisplay.GetResolution(); 
    
    switch ( uvtFromUnits )
    {
    case UNIT_TIMESRELATIVE:
        lRetValue = MulDivQuick(GetUnitValue(), lPercentOfValue,
                                TypeNames[UNIT_TIMESRELATIVE].wScaleMult);
        break;

    case UNIT_NULLVALUE:
        return 0L;

    case UNIT_PERCENT:
        lRetValue = GetPercentValue ( direction, lPercentOfValue );
        break;

    case UNIT_EX:
    case UNIT_EM:
        // turn the twips into pixels
        lRetValue = ConvertTo(GetUnitValue(), 
                              uvtFromUnits, 
                              UNIT_PIXELS, 
                              direction,
                              lFontHeight,
                              &sizeInch);

        // Still need to scale since zooming has been taken out and thus ConvertTo() no longer
        // scales (zooms) for printing (IE5 8543, IE4 11376).  Formerly:  pTransform = NULL;
        break;

    case UNIT_ENUM:
        // TODO: We need to put proper handling for enum in the Apply() so that
        // no one calls GetPixelValue on (for example) the margin CUV objects if
        // they're set to "auto".
        Assert( "Shouldn't call GetPixelValue() on enumerated unit values!" );
        return 0;

    case UNIT_INTEGER:
    case UNIT_RELATIVE:
        // TODO: this doesn't seem right; nothing's being done to convert the
        // retrieved value to anything resembling pixels.
        return GetUnitValue();

    case UNIT_FLOAT:
        lRetValue = MulDivQuick(GetUnitValue(), lFontHeight,
                                TypeNames[UNIT_FLOAT].wScaleMult);
        break;

    default:
        lRetValue = ConvertTo(GetUnitValue(), 
                              uvtFromUnits, 
                              UNIT_PIXELS, 
                              direction, 
                              lFontHeight,
                              &sizeInch);

        break;
    }
    // Finally convert from Window to Doc units, assuming return value is a length
    // For conversions to HIMETRIC, involve the transform
    if ( pdocScaleInfo  )
    {
        Assert(pdocScaleInfo->IsInitialized());
        BOOL fRelative = UNIT_PERCENT == uvtFromUnits ||
                         UNIT_TIMESRELATIVE == uvtFromUnits;
        if (!fRelative)
        {
            if ( direction == DIRECTION_CX )
                lRetValue = pdocScaleInfo->DeviceFromDocPixelsX(lRetValue);
            else
                lRetValue = pdocScaleInfo->DeviceFromDocPixelsY(lRetValue);
        }
    }
    return lRetValue;
}


HRESULT
CUnitValue::FromString ( LPCTSTR pStr, const PROPERTYDESC *pPropDesc, BOOL fStrictCSS1 )
{
    NUMPROPPARAMS *ppp = (NUMPROPPARAMS *)(pPropDesc + 1);

    // if string is empty and boolean is an allowed type make it so...

    // Note the special handling of the table relative "*" here

    while ( _istspace ( *pStr ) )
        pStr++;

    if ( _istdigit ( pStr [ 0 ] ) || pStr [ 0 ] == _T('+') || pStr [ 0 ] == _T('-') ||
        pStr [ 0 ] == _T('*') || pStr [ 0 ] == _T('.') )
    {
        // Assume some numerical value followed by an optional unit
        // specifier
        RRETURN1 ( NumberFromString ( pStr, pPropDesc, fStrictCSS1 ), E_INVALIDARG );
    }
    else
    {
        // Assume an enum
        if ( ppp -> bpp.dwPPFlags & PROPPARAM_ENUM )
        {
            long lNewValue;

            if ( S_OK == LookupEnumString( ppp, (LPTSTR)pStr, &lNewValue ) )
            {
                SetValue( lNewValue, UNIT_ENUM );
                return S_OK;
            }
        }
        return E_INVALIDARG;
    }
}

float CUnitValue::GetFloatValueInUnits ( UNITVALUETYPE uvtTo, 
                                        DIRECTION dir, 
                                        long lFontHeight /*=1*/ )
{
    // Convert the unitvalue into a floating point number in units uvt
    long lEncodedValue = ConvertTo ( GetUnitValue(), GetUnitType(), uvtTo,  dir, lFontHeight );

    return (float)lEncodedValue / (float)TypeNames [ uvtTo ].wScaleMult;
}


HRESULT CUnitValue::ConvertToUnitType ( UNITVALUETYPE uvtConvertTo, 
                                       long           lCurrentPixelSize, 
                                       DIRECTION      dir,
                                       long           lFontHeight /*=1*/)
{
    AssertSz(GetUnitType() != UNIT_PERCENT, "Cannot handle percent units! Contact RGardner!");
    
    // Convert the unit value to the new type but keep the
    // absolute value of the units the same
    // e.e. 20.34 pels -> 20.34 in

    if ( GetUnitType() == uvtConvertTo )
        return S_OK;

    if ( GetUnitType() == UNIT_NULLVALUE )
    {
        // The current value is Null, treat it as a pixel unit with lCurrentPixelSize value
        SetValue ( lCurrentPixelSize, UNIT_PIXELS );
        // fall into one of the cases below
    }

    if ( uvtConvertTo == UNIT_NULLVALUE )
    {
        SetValue ( 0, UNIT_NULLVALUE );
    }
    else if ( IsScalerUnit ( GetUnitType() ) && IsScalerUnit ( uvtConvertTo )  )
    {
        SIZE sizeInch = g_uiDisplay.GetDocPixelsPerInch();
        // Simply converting between scaler units e.g. 20mm => 2px
        SetValue ( ConvertTo ( GetUnitValue(), GetUnitType(), uvtConvertTo, dir, lFontHeight, &sizeInch ), uvtConvertTo);
    }
    else if ( IsScalerUnit ( GetUnitType() ) )
    {
        // Convert from a scaler type to a non-scaler type e.g. 20.3in => %
        // Have no reference for conversion, max it out
        switch ( uvtConvertTo )
        {
        case UNIT_PERCENT:
            SetValue ( 100 * TypeNames [ UNIT_PERCENT ].wScaleMult, UNIT_PERCENT );
            break;

        case UNIT_TIMESRELATIVE:
            SetValue ( 1 * TypeNames [ UNIT_PERCENT ].wScaleMult, UNIT_TIMESRELATIVE );
            break;

        default:
            AssertSz ( FALSE, "Invalid type passed to ConvertToUnitType()" );
            return E_INVALIDARG;
        }
    }
    else if ( IsScalerUnit ( uvtConvertTo) )
    {
        // Convert from a non-scaler to a scaler type use the current pixel size
        // e.g. We know that 20% is equivalent to 152 pixels. So we convert
        // the current pixel value to the new metric unit
        SetValue ( ConvertTo ( lCurrentPixelSize, UNIT_PIXELS, uvtConvertTo, dir, lFontHeight ), uvtConvertTo );
    }
    else
    {
        // Convert between non-scaler types e,g, 20% => *
        // Since we have only two non-sclaer types right now:-
        switch ( uvtConvertTo )
        {
        case UNIT_PERCENT:  // From UNIT_TIMESRELATIVE
            // 1* == 100%
            SetValue ( MulDivQuick ( GetUnitValue(),
                100 * TypeNames [ UNIT_PERCENT ].wScaleMult,
                TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult ) ,
                uvtConvertTo );
            break;

        case UNIT_TIMESRELATIVE: // From UNIT_PERCENT
            // 100% == 1*
            SetValue ( MulDivQuick ( GetUnitValue(),
                TypeNames [ UNIT_TIMESRELATIVE ].wScaleMult,
                TypeNames [ UNIT_PERCENT ].wScaleMult * 100 ) ,
                uvtConvertTo );
            break;

        default:
            AssertSz ( FALSE, "Invalid type passed to ConvertToUnitType()" );
            return E_INVALIDARG;
        }
    }
    return S_OK;
}


/* static */
BOOL CUnitValue::IsScalerUnit ( UNITVALUETYPE uvt ) 
{
    switch ( uvt )
    {
    case UNIT_POINT:
    case UNIT_PICA:
    case UNIT_INCH:
    case UNIT_CM:
    case UNIT_MM:
    case UNIT_PIXELS:
    case UNIT_EM:
    case UNIT_EX:
    case UNIT_FLOAT:
        return TRUE;

    default:
        return FALSE;
    }
}

HRESULT CUnitValue::SetFloatValueKeepUnits ( float fValue, 
                                             UNITVALUETYPE uvt, 
                                             long lCurrentPixelValue,
                                             DIRECTION dir,
                                             long lFontHeight)
{
    long lNewValue;

    // Set the new value to the equivalent of : fValue in uvt units
    // If the current value is a percent use the lCurrentPixelValue to
    // work out the new size

    // There are a number of restrictions on the uvt coming in. Since it's either
    // Document Units when called from CUnitMeasurement::SetValue or
    // PIXELS when called from CUnitMeasurement::SetPixelValue we restrict our
    // handling to the possible doc unit types - which are all the "metric" types

    lNewValue = (long) ( fValue * (float)TypeNames [ uvt ].wScaleMult );
    
    if ( uvt == GetUnitType() )
    {
        SetValue ( lNewValue, uvt );
    }
    else if ( uvt == UNIT_NULLVALUE || !IsScalerUnit ( uvt ) )
    {
        return E_INVALIDARG;
    }
    else if ( GetUnitType() == UNIT_NULLVALUE )
    {
        // If we're current NUll, just set to the new value
        SetValue ( lNewValue, uvt );
    }
    else if ( IsScalerUnit ( GetUnitType() ) )
    {
        // If the conversion is to/from metric units, just convert units
        SetValue ( ConvertTo ( lNewValue, uvt, GetUnitType(), dir, lFontHeight ), GetUnitType() );
    }
    else
    {
        // unit value holds a relative unit,
        // Convert the fValue,uvt to pixels
        lNewValue = ConvertTo ( lNewValue, uvt, UNIT_PIXELS, dir, lFontHeight );

        if ( GetUnitType() == UNIT_PERCENT )
        {
            SetValue ( MulDivQuick ( lNewValue, 
                                     100*TypeNames [ UNIT_PERCENT ].wScaleMult, 
                                     (!! lCurrentPixelValue) ?  lCurrentPixelValue : 1), // don't pass in 0 for divisor
                UNIT_PERCENT );
        }
        else
        {
            // Cannot keep units without loss of precision, over-ride
            SetValue ( lNewValue, UNIT_PIXELS );
        }
    }
    return S_OK;
}

HRESULT CUnitValue::SetFloatUnitValue ( float fValue )
{
    // Set the value from fValue
    // but keep the internaly stored units intact
    UNITVALUETYPE uvType;

    if ( ( uvType = GetUnitType()) == UNIT_NULLVALUE )
    {
        // This case can only happen if SetUnitValue is called when the current value is NULL
        // so force a unit type
        uvType = UNIT_PIXELS;
    }

    // Convert the fValue into a CUnitValue with current unit
    SetValue ( (long)(fValue * (float)TypeNames [ uvType ].wScaleMult),
        uvType );
    return S_OK;
}

//
// Support for CColorValue follows.
//
// IEUNIX: color value starts from 0x10.

extern const struct COLORVALUE_PAIR aColorNames[];
extern const struct COLORVALUE_PAIR aSystemColors[];
extern const INT cbSystemColorsSize;

HRESULT
CColorValue::Persist (
    IStream *pStream,
    const PROPERTYDESC * pPropDesc ) const
{
    TCHAR cBuffer[ 64 ];
    HRESULT hr;

    Assert( S_OK == IsValid() );

    hr = FormatBuffer( cBuffer, ARRAY_SIZE( cBuffer ), pPropDesc );
    if (hr)
        goto Cleanup;

    hr = WriteText( pStream, cBuffer );

Cleanup:
    RRETURN ( hr );
}

HRESULT
CColorValue::FormatBuffer (
    TCHAR * szBuffer,
    UINT uMaxLen,
    const PROPERTYDESC *pPropDesc,
    BOOL fReturnAsHex6 /*==FALSE */) const
{
    HRESULT hr = S_OK;
    const struct COLORVALUE_PAIR * pColorPair;
    LONG lValue;
    DWORD type = GetType();
    INT idx;
    DWORD dwSysColor;
    TCHAR achFmt[5] = _T("<0C>");

    switch (type)
    {
        default:
        case TYPE_UNDEF:
            *szBuffer = 0;
            break;

        case TYPE_NAME:
            // requests from the OM set fReturnAsHex to true, so instead
            // of returning "red; we want to return "#ff0000"
            if (!fReturnAsHex6)
            {
                pColorPair = FindColorByValue( GetRawValue() );
                Assert(pColorPair);
                _tcsncpy( szBuffer, pColorPair->szName, uMaxLen );
                break;
            }
            // else fall through !!!

        case TYPE_RGB:
            // requests from the OM set fReturnAsHex to true, so instead
            // of returning "rgb(255,0,0)" we want to return "#ff0000"
            if (!fReturnAsHex6)
            {
                hr = Format(0, szBuffer, uMaxLen, _T("rgb(<0d>,<1d>,<2d>)"), (_dwValue & 0x0000FF), (_dwValue & 0x00FF00)>>8, (_dwValue & 0xFF0000)>>16);
                break;
            }
            // else fall through !!!

        case TYPE_SYSINDEX:
        case TYPE_POUND6:
        case TYPE_POUND5:
        case TYPE_POUND4:
            achFmt[2] = _T('c');

        case TYPE_POUND3:
        case TYPE_POUND2:
        case TYPE_POUND1:
            lValue = (LONG)GetColorRef();
            if (fReturnAsHex6)
            {
                achFmt[2] = _T('c');
            }
            hr = Format(0, szBuffer, uMaxLen, achFmt, lValue);
            if (!fReturnAsHex6 && (type != TYPE_POUND6))
            {
                szBuffer[((TYPE_POUND1 - type)>>24) + 2] = _T('\0');
            }
            break;

#ifdef UNIX
        case TYPE_UNIXSYSCOL:
            hr = E_INVALIDARG;
            if (!g_fSysColorInit)
                InitColorTranslation();

            for (int idx = 0; idx < ARRAY_SIZE(g_acrSysColor); idx++)
			{
                if ( _dwValue == g_acrSysColor[idx] )
                {
                    _tcsncpy( szBuffer, aSystemColors[idx].szName, uMaxLen );
                    hr = S_OK;
                    break;
                }
			}
            if ( hr )
                AssertSz ( FALSE, "Invalid Color Stored" );
            break;
#endif

        case TYPE_SYSNAME:
            dwSysColor = (_dwValue & MASK_SYSCOLOR)>>24;
            hr = E_INVALIDARG;
            for ( idx = 0; idx < cbSystemColorsSize; idx++ )
            {
                if ( dwSysColor == aSystemColors[idx].dwValue )
                {
                    _tcsncpy( szBuffer, aSystemColors[idx].szName, uMaxLen );
                    hr = S_OK;
                    break;
                }
            }
            AssertSz ( !hr, "Invalid Color Stored" );
            break;
        case TYPE_TRANSPARENT:
            _tcsncpy( szBuffer, _T("transparent"), uMaxLen );
            break;
    }
    RRETURN ( hr );
}

DWORD 
CColorValue::GetIntoRGB(void) const
{
    DWORD dwRet = GetColorRef();
    return ((dwRet & 0xFF) << 16) | (dwRet & 0xFF00) | ((dwRet & 0xFF0000) >> 16);
}

COLORREF
CColorValue::GetColorRef() const
{
    if ( IsSysColor() )
        return (COLORREF)GetSysColorQuick((_dwValue & MASK_SYSCOLOR)>>24);

#ifdef UNIX
        if ( IsUnixSysColor()) 
            return (COLORREF)_dwValue;
#endif

    return (COLORREF) ((_dwValue & MASK_COLOR) | 0x02000000);
}

// Allocates and returns a string reperesenting the color value as #RRGGBB
HRESULT 
CColorValue::FormatAsPound6Str(BSTR *pszColor, DWORD dwColor)
{
    HRESULT     hr;
    OLECHAR     szBuf[8];

    hr = THR(Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0c>"), dwColor));
    if(hr)
        goto Cleanup;

    hr = FormsAllocString(szBuf, pszColor);

Cleanup:
    RRETURN(hr);
}

HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, BSTR * pbstrColor, 
                          BOOL fReturnAsHex /* == FALSE */) const
{
    HRESULT hr;
    TCHAR szBuffer[64];
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue));
    hr = cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL, fReturnAsHex );
    if ( hr )
        goto Cleanup;

    hr = FormsAllocString(szBuffer, pbstrColor);
Cleanup:
    RRETURN( hr );
}


HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, CStr * pcstr, 
                          BOOL fReturnAsHex/* =FALSE*/, BOOL *pfValuePresent /*= NULL*/) const
{
    HRESULT hr;
    TCHAR szBuffer[64];
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue), pfValuePresent);
    hr = cvColor.FormatBuffer(szBuffer, ARRAY_SIZE(szBuffer), NULL, fReturnAsHex );
    if ( hr )
        goto Cleanup;
    hr = pcstr->Set( szBuffer );
Cleanup:
    RRETURN( hr );
}

HRESULT
BASICPROPPARAMS::GetColor(CVoid * pObject, DWORD * pdwValue) const
{
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_GETMFHandler));

    cvColor = (CColorValue)GetAvNumber (pObject, this + 1, sizeof(CColorValue));
    *pdwValue = cvColor.GetRawValue();

    return S_OK;
}

HRESULT
BASICPROPPARAMS::SetColor(CVoid * pObject, TCHAR * pch, WORD wFlags) const
{
    HRESULT hr;
    CColorValue cvColor;

    hr = cvColor.FromString(pch);
    if (hr)
        goto Cleanup;

    Assert(!(dwPPFlags & PROPPARAM_SETMFHandler));

    hr = THR( SetAvNumber ( pObject, (DWORD)cvColor.GetRawValue(), this+1, sizeof ( CColorValue ), wFlags ) );

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT
BASICPROPPARAMS::SetColor(CVoid * pObject, DWORD dwValue, WORD wFlags) const
{
    HRESULT hr;
    CColorValue cvColor;

    Assert(!(dwPPFlags & PROPPARAM_SETMFHandler));

    cvColor.SetRawValue(dwValue);

    hr = THR( SetAvNumber ( pObject, (DWORD)cvColor.GetRawValue(), this+1, sizeof ( CColorValue ), wFlags ) );

    RRETURN1(hr,E_INVALIDARG);
}



//+-----------------------------------------------------
//
//  Member : StripCRLF
//
//  Synopsis : strips CR and LF from a provided string
//      the returned string has been allocated and needs 
//      to be freed by the caller.
//
//+-----------------------------------------------------
static HRESULT
StripCRLF(TCHAR *pSrc, TCHAR **ppDest)
{
    HRESULT hr = S_OK;
    long    lLength;
    TCHAR  *pTarget = NULL;


    if (!ppDest)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( !pSrc )
        goto Cleanup;

    lLength = _tcslen(pSrc);
    *ppDest= (TCHAR*)MemAlloc(Mt(StripCRLF), sizeof(TCHAR)*(lLength+1));
    if (!*ppDest)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pTarget = *ppDest;

    for (; lLength>0; lLength--)
    {
        if ((*pSrc != _T('\r')) && (*pSrc != _T('\n'))) 
        {
            // we want it.
            *pTarget = *pSrc;
            pTarget++;
        }
        pSrc++;
    }

    *pTarget = _T('\0');

Cleanup:
    RRETURN(hr);
}


HRESULT ttol_with_error ( LPCTSTR pStr, long *plValue )
{
    // Always do base 10 regardless of contents of 
    RRETURN1 ( PropertyStringToLong ( pStr, NULL, 10, 0, (unsigned long *)plValue ), E_INVALIDARG );
}


static HRESULT RTCCONV PropertyStringToLong (
        LPCTSTR nptr,
        TCHAR **endptr,
        int ibase,
        int flags,
        unsigned long *plNumber )
{
        const TCHAR *p;
        TCHAR c;
        unsigned long number;
        unsigned digval;
        unsigned long maxval;

        *plNumber = 0;                  /* on error result is 0 */

        p = nptr;                       /* p is our scanning pointer */
        number = 0;                     /* start with zero */

        c = *p++;                       /* read char */
        while (_istspace(c))
            c = *p++;                   /* skip whitespace */

        if (c == '-') 
        {
            flags |= FL_NEG;        /* remember minus sign */
            c = *p++;
        }
        else if (c == '+')
            c = *p++;               /* skip sign */

        if (ibase < 0 || ibase == 1 || ibase > 36) 
        {
            /* bad base! */
            if (endptr)
                    /* store beginning of string in endptr */
                    *endptr = (TCHAR *)nptr;
            return E_INVALIDARG;              /* return 0 */
        }
        else if (ibase == 0) 
        {
            /* determine base free-lance, based on first two chars of
               string */
            if (c != L'0')
                    ibase = 10;
            else if (*p == L'x' || *p == L'X')
                    ibase = 16;
            else
                    ibase = 8;
        }

        if (ibase == 16) 
        {
            /* we might have 0x in front of number; remove if there */
            if (c == L'0' && (*p == L'x' || *p == L'X')) 
            {
                    ++p;
                    c = *p++;       /* advance past prefix */
            }
        }

        /* if our number exceeds this, we will overflow on multiply */
        maxval = ULONG_MAX / ibase;


        for (;;) 
        {      /* exit in middle of loop */
            /* convert c to value */
            if (_istdigit(c))
                    digval = c - L'0';
            else if (_istalpha(c))
            {
                if ( ibase > 10 )
                {
                    if (c >= 'a' && c <= 'z')
                        digval = (unsigned)c - 'a' + 10;
                    else
                        digval = (unsigned)c - 'A' + 10;
                }
                else
                {
                    return E_INVALIDARG;              /* return 0 */
                }
            }
            else
                break;

            if (digval >= (unsigned)ibase)
                break;          /* exit loop if bad digit found */

            /* record the fact we have read one digit */
            flags |= FL_READDIGIT;

            /* we now need to compute number = number * base + digval,
               but we need to know if overflow occured.  This requires
               a tricky pre-check. */

            if (number < maxval || (number == maxval &&
                (unsigned long)digval <= ULONG_MAX % ibase)) 
            {
                    /* we won't overflow, go ahead and multiply */
                    number = number * ibase + digval;
            }
            else 
            {
                    /* we would have overflowed -- set the overflow flag */
                    flags |= FL_OVERFLOW;
            }

            c = *p++;               /* read next digit */
        }

        --p;                            /* point to place that stopped scan */

        if (!(flags & FL_READDIGIT)) 
        {
            number = 0L;                        /* return 0 */

            /* no number there; return 0 and point to beginning of
               string */
            if (endptr)
                /* store beginning of string in endptr later on */
                p = nptr;

            return E_INVALIDARG;            // Return error not a number
        }
        else if ( (flags & FL_OVERFLOW) ||
                  ( !(flags & FL_UNSIGNED) &&
                    ( ( (flags & FL_NEG) && (number > -LONG_MIN) ) ||
                      ( !(flags & FL_NEG) && (number > LONG_MAX) ) ) ) )
        {
            /* overflow or signed overflow occurred */
            //errno = ERANGE;
            if ( flags & FL_UNSIGNED )
                    number = ULONG_MAX;
            else if ( flags & FL_NEG )
                    number = (unsigned long)(-LONG_MIN);
            else
                    number = LONG_MAX;
        }

        if (endptr != NULL)
            /* store pointer to char that stopped the scan */
            *endptr = (TCHAR *)p;

        if (flags & FL_NEG)
                /* negate result if there was a neg sign */
                number = (unsigned long)(-(long)number);

        *plNumber = number; 
        return S_OK;                  /* done. */
}

//+---------------------------------------------------------------------------
//
//  Member: PROPERTYDESC::HandleCodeProperty
//
//+---------------------------------------------------------------------------

HRESULT
PROPERTYDESC::HandleCodeProperty (DWORD dwOpCode, void * pv, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT             hr = S_OK;
    BASICPROPPARAMS *   ppp = (BASICPROPPARAMS *)(this + 1);

    if (ISSET(dwOpCode))
    {
        Assert(!(ISSTREAM(dwOpCode))); // we can't do this yet...

        //
        // Assert ( actualTypeOf(pv) == (VARIANT*) );
        //

        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_DEFAULT:
        case HANDLEPROP_VALUE:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            break;

        case HANDLEPROP_AUTOMATION:

            // Assert ( actualTypeOf(pv) == (VARIANT*) );
            Assert (PROPTYPE_VARIANT == PROPTYPE(dwOpCode) && "Only this type supported for this case");

            hr = THR(ppp->SetCodeProperty( (VARIANT*)pv, pObject, pSubObject));
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
            break;
        }
    }
    else
    {
        switch(OPCODE(dwOpCode))
        {
        case HANDLEPROP_VALUE:
        case HANDLEPROP_STREAM:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            break;

        case HANDLEPROP_COMPARE:
            hr = THR(HandleStringProperty(dwOpCode, pv, pObject, pSubObject));
            RRETURN1(hr,S_FALSE);
            break;

        case HANDLEPROP_AUTOMATION:
            if (!pv)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            Assert (PROPTYPE_VARIANT == PROPTYPE(dwOpCode) && "Only V_DISPATCH supported for this case");

            hr = THR(ppp->GetCodeProperty ((VARIANT*)pv, pObject, pSubObject));
            if (hr)
                goto Cleanup;
            break;

        default:
            hr = E_FAIL;
            Assert(FALSE && "Invalid operation");
        }
    }

Cleanup:

    RRETURN1(hr, E_INVALIDARG);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBase::SetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
CBase::SetCodeProperty (DISPID dispidCodeProp, IDispatch *pDispCode, BOOL *pfAnyDeleted /* = NULL */)
{
    HRESULT hr = S_OK;
    BOOL    fAnyDelete;

    fAnyDelete = DidFindAAIndexAndDelete (dispidCodeProp, CAttrValue::AA_Attribute);
    fAnyDelete |= DidFindAAIndexAndDelete (dispidCodeProp, CAttrValue::AA_Internal);

    if (pDispCode)
    {
        hr = THR(AddDispatchObject(
            dispidCodeProp,
            pDispCode,
            CAttrValue::AA_Internal,
            CAttrValue::AA_Extra_OldEventStyle));
    }

    // if this is an element, let it know that events can now fire
    IGNORE_HR(OnPropertyChange(DISPID_EVPROP_ONATTACHEVENT, 0));

    if (pfAnyDeleted)
        *pfAnyDeleted = fAnyDelete;

    RRETURN (hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_StyleComponent(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StyleComponentHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_StyleComponentHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->SetStyleComponentProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Url(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_UrlHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_UrlHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);
    
    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->SetUrlProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_String(BSTR v)
{
    GET_THUNK_PROPDESC
    return put_StringHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_StringHelper(BSTR v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                         (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    switch (pPropDesc->GetBasicPropParams()->wInvFunc)
    {
    case IDX_GS_BSTR:
        return pPropDesc->GetBasicPropParams()->SetStringProperty(v, this, pSubObj, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
    case IDX_GS_PropEnum:
        return pPropDesc->GetNumPropParams()->SetEnumStringProperty(v, this, pSubObj, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
    }
    return S_OK;
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Short(short v)
{
    GET_THUNK_PROPDESC
    return put_ShortHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_ShortHelper(short v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()), TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Long(long v)
{
    GET_THUNK_PROPDESC
    return put_LongHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_LongHelper(long v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, pSubObj, TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Bool(VARIANT_BOOL v)
{
    GET_THUNK_PROPDESC
    return put_BoolHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_BoolHelper(VARIANT_BOOL v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    return pPropDesc->GetNumPropParams()->SetNumberProperty(v, this, pSubObj, TRUE, fRuntimeStyle ? CAttrValue::AA_Extra_RuntimeStyle : 0);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_Variant(VARIANT v)
{
    GET_THUNK_PROPDESC
    return put_VariantHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_VariantHelper(VARIANT v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr, BOOL fRuntimeStyle)
{
    Assert(pPropDesc);

    RECALC_PUT_HELPER(pPropDesc->GetDispid())

    return SetErrorInfo((pPropDesc->*pPropDesc->pfnHandleProperty)(HANDLEPROP_SET | HANDLEPROP_AUTOMATION | (fRuntimeStyle ? HANDLEPROP_RUNTIMESTYLE : 0) | (PROPTYPE_VARIANT << 16),
                                                                   &v,
                                                                   this,
                                                                   ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_Url(BSTR *p)
{
    GET_THUNK_PROPDESC
    return get_UrlHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_UrlHelper(BSTR *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->GetUrlProperty(p, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_StyleComponent(BSTR *p)
{
    GET_THUNK_PROPDESC
    return get_StyleComponentHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_StyleComponentHelper(BSTR *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    return pPropDesc->GetBasicPropParams()->GetStyleComponentProperty(p, this, ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray()));
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::get_Property(void *p)
{
    GET_THUNK_PROPDESC
    return get_PropertyHelper(p, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::get_PropertyHelper(void *p, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    Assert(pPropDesc);

    RECALC_GET_HELPER(pPropDesc->GetDispid())

    CVoid *pSubObj = (pPropDesc->GetBasicPropParams()->dwPPFlags & PROPPARAM_ATTRARRAY) ?
                        (ppAttr ? CVOID_CAST(ppAttr) : CVOID_CAST(GetAttrArray())) : CVOID_CAST(this);

    switch (pPropDesc->GetBasicPropParams()->wInvFunc)
    {
    case IDX_G_VARIANT:
    case IDX_GS_VARIANT:
    	return SetErrorInfo((pPropDesc->*pPropDesc->pfnHandleProperty)(HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16), p, this, pSubObj));
    case IDX_G_VARIANTBOOL:
    case IDX_GS_VARIANTBOOL:
    case IDX_G_long:
    case IDX_GS_long:
    case IDX_G_short:
    case IDX_GS_short:
	    return pPropDesc->GetNumPropParams()->GetNumberProperty(p, this, pSubObj);
    case IDX_G_BSTR:
    case IDX_GS_BSTR:
        return pPropDesc->GetBasicPropParams()->GetStringProperty((BSTR *)p, this, pSubObj);
    case IDX_G_PropEnum:
    case IDX_GS_PropEnum:
        return pPropDesc->GetNumPropParams()->GetEnumStringProperty((BSTR *)p, this, pSubObj);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::SetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
BASICPROPPARAMS::SetCodeProperty(VARIANT *pvarCode, CBase * pObject, CVoid *) const
{
    HRESULT hr = S_OK;

    Assert ((dwPPFlags & PROPPARAM_ATTRARRAY) && "only attr array support implemented for 'type:code'");

    if ( V_VT(pvarCode) == VT_NULL )
    {
        hr = pObject->SetCodeProperty(dispid, NULL);
    }
    else if ( V_VT(pvarCode) == VT_DISPATCH )
    {
        hr = pObject->SetCodeProperty(dispid, V_DISPATCH(pvarCode) );
    }
    else if ( V_VT(pvarCode) == VT_BSTR )
    {
        pObject->FindAAIndexAndDelete (dispid, CAttrValue::AA_Internal);
        hr = THR(pObject->AddString(dispid, V_BSTR(pvarCode),CAttrValue::AA_Attribute ));
    }
    else
    {
        hr = E_NOTIMPL;
    }

    if (!hr)
        hr = THR(pObject->OnPropertyChange(dispid, dwFlags, (PROPERTYDESC *)GetPropertyDesc()));


    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     BASICPROPPARAMS::GetCodeProperty
//
//----------------------------------------------------------------------------

HRESULT
BASICPROPPARAMS::GetCodeProperty (VARIANT *pvarCode, CBase * pObject, CVoid * pSubObject) const
{
    HRESULT     hr = S_OK;
    AAINDEX     aaidx;

    V_VT(pvarCode) = VT_NULL;

    Assert ((dwPPFlags & PROPPARAM_ATTRARRAY) && "only attr array support implemented for 'type:code'");

    aaidx = pObject->FindAAIndex(dispid, CAttrValue::AA_Internal);
    if ((AA_IDX_UNKNOWN != aaidx) && (pObject->GetVariantTypeAt(aaidx) == VT_DISPATCH))
    {
        hr = THR(pObject->GetDispatchObjectAt(aaidx, &V_DISPATCH(pvarCode)) );
        if ( hr )
            goto Cleanup;
        V_VT(pvarCode) = VT_DISPATCH;
    }
    else
    {
        LPCTSTR szCodeText;
        aaidx = pObject->FindAAIndex(dispid, CAttrValue::AA_Attribute);
        if (AA_IDX_UNKNOWN != aaidx)
        {
            hr = THR(pObject->GetStringAt(aaidx, &szCodeText) );
            if ( hr )
                goto Cleanup;
            hr = FormsAllocString ( szCodeText, &V_BSTR(pvarCode) );
            if ( hr )
                goto Cleanup;            
            V_VT(pvarCode) = VT_BSTR;
        }
    }
Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Helper Function:    NextParenthesizedToken
//
//  Synopsis:
//      This function tokenizes a word or functional notation.
//      Expects string to have no leading whitespace.
//
//  Return Values:
//      "" if the end of the string was reached.
//      pointer to following characters if success.
//-------------------------------------------------------------------------
TCHAR *NextParenthesizedToken( TCHAR *pszToken )
{
    int iParenDepth = 0;
    BOOL fInQuotes = FALSE;
    TCHAR quotechar = _T('"');

    while ( *pszToken && ( iParenDepth || !_istspace( *pszToken ) ) )
    {
        if ( !fInQuotes )
        {
            if ( ( *pszToken == _T('\'') ) || ( *pszToken == _T('"') ) )
            {
                fInQuotes = TRUE;
                quotechar = *pszToken;
            }
            else if ( iParenDepth && ( *pszToken == _T(')') ) )
                iParenDepth--;
            else if ( *pszToken == _T('(') )
                iParenDepth++;
        }
        else if ( quotechar == *pszToken )
        {
            fInQuotes = FALSE;
        }
        pszToken++;
    }
    return pszToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\ippaint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ippain.cxx
//
//  Contents:   IOleInPlaceSiteWindowless helper methods
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDC
//
//  Synopsis:   Gets a DC for the caller, type of DC depends on flags.
//
//  Arguments:  [prc]     -- param as per IOleInPlaceSiteWindowless::GetDC
//              [dwFlags] --                -do-
//              [phDC]    --                -do-
//
//  Returns:    HRESULT
//
//  History:    28-Mar-95   SumitC      Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDC(LPRECT prc, DWORD dwFlags, HDC * phDC)
{
    HRESULT hr = S_OK;

    if (phDC == NULL)
        return E_POINTER;

    *phDC = NULL;

    if (_pInPlace == NULL)
        return E_FAIL;

    _pInPlace->_fIPNoDraw =
    _pInPlace->_fIPPaintBkgnd =
    _pInPlace->_fIPOffScreen = FALSE;

    if (_pInPlace->_hwnd)
    {
        // get the window dc
        *phDC = ::GetDC(_pInPlace->_hwnd);
        if (*phDC == NULL)
            RRETURN(GetLastWin32Error());

        HPALETTE hpal = GetPalette(*phDC);

        if (dwFlags & OLEDC_OFFSCREEN)
        {
            // build an offscreen buffer to return
            Assert(_pInPlace->_pOSC == NULL);
            _pInPlace->_pOSC = new COffScreenContext
                (
                *phDC,
                prc->right - prc->left,
                prc->bottom - prc->top,
                hpal,
                ((dwFlags >> 16) & OFFSCR_BPP)
                    | (dwFlags & OFFSCR_SURFACE)
                    | (dwFlags & OFFSCR_3DSURFACE)
                );
            
            if (_pInPlace->_pOSC == NULL)
            {
                ::ReleaseDC(_pInPlace->_hwnd, *phDC);
                RRETURN(E_OUTOFMEMORY);
            }

            *phDC = _pInPlace->_pOSC->GetDC(prc);
            _pInPlace->_fIPOffScreen = TRUE;
        }

        if (dwFlags & OLEDC_NODRAW)
        {
            _pInPlace->_fIPNoDraw = TRUE;
        }
        else if (dwFlags & OLEDC_PAINTBKGND)
        {
            _pInPlace->_fIPPaintBkgnd = TRUE;
        }
        _pInPlace->_rcPaint = *prc;

    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                GetDC(prc, dwFlags, phDC);
        if ((hr == S_OK) && *phDC)
            GetPalette(*phDC);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::ReleaseDC
//
//  Synopsis:   Releases a DC obtained via GetDC above.
//
//  Arguments:  [hDC] -- param as per IOleInPlaceSiteWindowless::ReleaseDC
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::ReleaseDC(HDC hDC)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    // Get our palette out of the DC so that it doesn't stay locked
    SelectPalette(hDC, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);

    if (_pInPlace->_hwnd)
    {
        if (_pInPlace->_fIPOffScreen)
        {
            Assert(_pInPlace->_pOSC);

            ::ReleaseDC(_pInPlace->_hwnd, _pInPlace->_pOSC->ReleaseDC(_pInPlace->_hwnd, !_pInPlace->_fIPNoDraw));

            delete _pInPlace->_pOSC;
            _pInPlace->_pOSC = NULL;
        }
        else
        {
            if (::ReleaseDC(_pInPlace->_hwnd, hDC) == 0)
                hr = GetLastWin32Error();
        }
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->ReleaseDC(hDC);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::InvalidateRect
//
//  Synopsis:
//
//  Arguments:  [prc]    -- param as per IOleInPlaceSiteWindowless::InvalidateRect
//              [fErase] --             -do-
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::InvalidateRect(LPCRECT prc, BOOL fErase)
{
    HRESULT hr = S_OK;

    if (_state >= OS_INPLACE)
    {
        Assert(_pInPlace);

        if (_pInPlace->_hwnd)
        {
            if (::InvalidateRect(_pInPlace->_hwnd, prc, fErase) == 0)
                hr = GetLastWin32Error();
        }
        else
        {
            Assert(_pInPlace->_fWindowlessInplace);
            hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                    InvalidateRect(prc, fErase);
        }
    }

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::InvalidateRgn
//
//  Synopsis:
//
//  Arguments:  [hrgn]   -- param as per IOleInPlaceSiteWindowless::InvalidateRgn
//              [fErase] --                 -do-
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        ::InvalidateRgn(_pInPlace->_hwnd, hrgn, fErase);    // always returns TRUE
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                InvalidateRgn(hrgn, fErase);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::Scroll
//
//  Synopsis:
//
//  Arguments:  [dx]        --
//              [dy]        --
//              [prcScroll] --
//              [prcClip]   --
//
//  Returns:    HRESULT
//
//  History:    28-Mar-95   SumitC      Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CServer::Scroll(int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip)
{
    HRESULT hr      = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        if (::ScrollWindowEx(_pInPlace->_hwnd,
                             dx,
                             dy,
                             prcScroll,
                             prcClip,
                             NULL,
                             NULL,
                             SW_INVALIDATE) == ERROR)
        {
            hr = GetLastWin32Error();
        }
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                ScrollRect(dx, dy, prcScroll, prcClip);
    }

    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::AdjustRect
//
//  Synopsis:
//
//  Arguments:  [prc] -- param as per IOleInPlaceSiteWindowless::AdjustRect
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::AdjustRect(LPRECT prc)
{
    HRESULT hr = S_OK;

    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        IntersectRect(prc, prc, &_pInPlace->_rcClip);
    }
    else
    {
        Assert(_pInPlace->_fWindowlessInplace);
        hr = ((IOleInPlaceSiteWindowless *)_pInPlace->_pInPlaceSite)->
                AdjustRect(prc);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\olectrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       olectrl.cxx
//
//  Contents:   Ole Control Specific Interface implementations
//
//----------------------------------------------------------------------------


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CControlBaseCtrl::GetControlInfo, IOleControl
//
//  Synopsis:   Returns a filled-in CONTROLINFO.
//
//  Arguments:  [pCI] -- CONTROLINFO to fill in
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetControlInfo(CONTROLINFO *pCI)
{
    memset(pCI, 0, sizeof(CONTROLINFO));
    pCI->cb = sizeof(CONTROLINFO);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnMnemonic, IOleControl
//
//  Synopsis:   Indicates one of our mnemonics has been pressed by the user
//              and we need to take the appropriate action.
//
//  Arguments:  [pMsg] -- Message which corresponds to a mnemonic.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::OnMnemonic(LPMSG pMsg)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnAmbientPropertyChange, IOleControl
//
//  Synopsis:   Indicates one or more ambient properties have changed so we
//              can update our state.
//
//  Arguments:  [dispid] -- Property which changed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_USERMODE:
        _fUserMode = GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);
        break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::FreezeEvents, IOleControl
//
//  Synopsis:   Enables or disables the ability of the control to fire events.
//              Any control which cares about the status of the event
//              freeze count should overwrite this method.
//
//  Arguments:  [fFreeze] -- If TRUE, events are disabled.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::FreezeEvents(BOOL fFreeze)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetDisplayString, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetDisplayString(DISPID dispid, BSTR * pbstr)
{
    if (pbstr)
        *pbstr = NULL;

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::MapPropertyToPage, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::MapPropertyToPage(DISPID dispid, LPCLSID lpclsid)
{
    if (lpclsid)
        *lpclsid = CLSID_NULL;

    return PERPROP_E_NOPAGEAVAILABLE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetPredefinedStrings, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetPredefinedStrings(DISPID       dispid,
                              CALPOLESTR * pcaStringsOut,
                              CADWORD *    lpcaCookiesOut)
{
    if (pcaStringsOut)
    {
        pcaStringsOut->cElems = 0;
        pcaStringsOut->pElems = NULL;
    }

    if (lpcaCookiesOut)
    {
        lpcaCookiesOut->cElems = 0;
        lpcaCookiesOut->pElems = NULL;
    }

    // NOTE (ChrisF): according to the spec this should probably return S_FALSE
    // however, because of a bug in VB4 and VB5/VBA this causes VB not to look for
    // the string in the typelib either. 
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetPredefinedValue, IPerPropertyBrowsing
//
//----------------------------------------------------------------------------

HRESULT
CServer::GetPredefinedValue(DISPID dispid, DWORD dwCookie, VARIANT * pvarOut)
{
    if (pvarOut)
        V_VT(pvarOut) = VT_EMPTY;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\cnct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       cnct.cxx
//
//  Contents:   Connections interfaces and implementations (part 1 of 2).
//
//  History:    12-22-93   adams   Created
//              5-22-95    kfl     converted WCHAR to TCHAR
//              2-21-96    LyleC   Cleaned out unused stuff
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CEnumConnections, ObjectModel, "CEnumConnections")
MtDefine(CEnumConnectionsCreate_pary, Locals, "CEnumConnections::Create pary")
MtDefine(CEnumConnectionsCreate_pary_pv, CEnumConnectionsCreate_pary, "CEnumConnections::Create pary->_pv")

//+------------------------------------------------------------------------
//
//  CEnumConnections Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumConnections::Create(
        int                 ccd,
        CONNECTDATA *       pcd,
        CEnumConnections ** ppenum)
{
    HRESULT                 hr      = S_OK;
    CEnumConnections *      penum   = NULL;
    CDataAry<CONNECTDATA> * pary = NULL;
    CONNECTDATA *           pcdT;
    int                     c;
    int                     cNonNull;

    Assert(ppenum);
    *ppenum = NULL;

    penum = new CEnumConnections;
    if (!penum)
        goto MemError;

    pary = new(Mt(CEnumConnectionsCreate_pary)) CDataAry<CONNECTDATA>(Mt(CEnumConnectionsCreate_pary_pv));
    if (!pary)
        goto MemError;

    Assert(!penum->_pary);

    //  Copy the AddRef'd array of pointers into a CFormsAry
    hr = THR(pary->EnsureSize(ccd));
    if (hr)
        goto Error;

    cNonNull = 0;
    for (c = ccd, pcdT = pcd; c > 0; c--, pcdT++)
    {
        if (pcdT->pUnk)
        {
            (*pary)[cNonNull] = *pcdT;
            pcdT->pUnk->AddRef();
            cNonNull++;
        }
    }

    pary->SetSize(cNonNull);
    penum->_pary = pary;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

MemError:
    hr = E_OUTOFMEMORY;
    // fall through

Error:
    ReleaseInterface(penum);
    delete pary;

    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::CEnumConnections
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumConnections::CEnumConnections(void) :
        CBaseEnum(sizeof(IUnknown *), IID_IEnumConnections, TRUE, TRUE)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::~CEnumConnections
//
//  Synopsis:   dtor.
//
//  History:    10-12-99   alanau   Created
//
//----------------------------------------------------------------------------

CEnumConnections::~CEnumConnections()
{
    if (_pary && _fDelete)
    {
        if ( _fAddRef )
        {
            CONNECTDATA * pcdT;
            int         i;
            int         cSize = _pary->Size();
            
            for (i=0, pcdT = (CONNECTDATA *) Deref(0);
                 i < cSize;
                 i++, pcdT++)
            {
                pcdT->pUnk->Release();
            }
        }

        delete _pary;
        _pary = NULL;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::CEnumConnections
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumConnections::CEnumConnections(const CEnumConnections & enumc)
    : CBaseEnum(enumc)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Next
//
//  Synopsis:   Per IEnumConnections::Next.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CEnumConnections::Next(
        ULONG           ulConnections,
        void *          reelt,
        ULONG *         lpcFetched)
{
    HRESULT         hr;
    CONNECTDATA *   pCD;               // CONNECTDATA's to enumerate
    CONNECTDATA *   pCDEnd;            // end of CONNECTDATA's
    CONNECTDATA *   pCDSrc;
    int             iActual;           // elems returned

    // Determine number of elements to enumerate.
    if (_i + (int) ulConnections <= _pary->Size())
    {
        hr = S_OK;
        iActual = (int) ulConnections;
    }
    else
    {
        hr = S_FALSE;
        iActual = _pary->Size() - _i;
    }

    if (iActual > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (lpcFetched)
    {
        *lpcFetched = (ULONG) iActual;
    }

    // Return elements to enumerate.
    pCDEnd = (CONNECTDATA *) reelt + iActual;
    for (pCD = (CONNECTDATA *) reelt, pCDSrc = (CONNECTDATA *) Deref(_i);
        pCD < pCDEnd;
        pCD++, pCDSrc++)
    {
        *pCD = *pCDSrc;
        pCD->pUnk->AddRef();
    }

    _i += iActual;

    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CEnumConnections::Clone
//
//  Synopsis:   Per IEnumConnections::Clone.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CEnumConnections::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(Create(
            _pary->Size(),
            (CONNECTDATA *)(LPVOID)*_pary,
            (CEnumConnections **) ppenum));
    if (hr)
        RRETURN(hr);

    (* (CEnumConnections **) ppenum)->_i = _i;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\colorval.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       baseprop.cxx
//
//  Contents:   CBase property setting utilities.
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FUNCSIG_HXX_
#define X_FUNCSIG_HXX_
#include "funcsig.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif // X_CBUFSTR_HXX_

#ifndef X_HIMETRIC_HXX_
#define X_HIMETRIC_HXX_
#include "himetric.hxx"
#endif


#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

//
// Support for CColorValue follows.
//
// IEUNIX: color value starts from 0x10.

#define nColorNamesStartOffset 0x11
#define COLOR_INDEX(i) (((DWORD)nColorNamesStartOffset + (DWORD)(i)) << 24)


const struct COLORVALUE_PAIR aColorNames[] =
{
    { _T("aliceblue"),             COLOR_INDEX(0x00) | 0xfff8f0 },
    { _T("antiquewhite"),          COLOR_INDEX(0x01) | 0xd7ebfa },
    { _T("aqua"),                  COLOR_INDEX(0x02) | 0xffff00 },
    { _T("aquamarine"),            COLOR_INDEX(0x03) | 0xd4ff7f },
    { _T("azure"),                 COLOR_INDEX(0x04) | 0xfffff0 },
    { _T("beige"),                 COLOR_INDEX(0x05) | 0xdcf5f5 },
    { _T("bisque"),                COLOR_INDEX(0x06) | 0xc4e4ff },
    { _T("black"),                 COLOR_INDEX(0x07) | 0x000000 },
    { _T("blanchedalmond"),        COLOR_INDEX(0x08) | 0xcdebff },
    { _T("blue"),                  COLOR_INDEX(0x09) | 0xff0000 },
    { _T("blueviolet"),            COLOR_INDEX(0x0a) | 0xe22b8a },
    { _T("brown"),                 COLOR_INDEX(0x0b) | 0x2a2aa5 },
    { _T("burlywood"),             COLOR_INDEX(0x0c) | 0x87b8de },
    { _T("cadetblue"),             COLOR_INDEX(0x0d) | 0xa09e5f },
    { _T("chartreuse"),            COLOR_INDEX(0x0e) | 0x00ff7f },
    { _T("chocolate"),             COLOR_INDEX(0x0f) | 0x1e69d2 },
    { _T("coral"),                 COLOR_INDEX(0x10) | 0x507fff },
    { _T("cornflowerblue"),        COLOR_INDEX(0x11) | 0xed9564 },
    { _T("cornsilk"),              COLOR_INDEX(0x12) | 0xdcf8ff },
    { _T("crimson"),               COLOR_INDEX(0x13) | 0x3c14dc },
    { _T("cyan"),                  COLOR_INDEX(0x14) | 0xffff00 },
    { _T("darkblue"),              COLOR_INDEX(0x15) | 0x8b0000 },
    { _T("darkcyan"),              COLOR_INDEX(0x16) | 0x8b8b00 },
    { _T("darkgoldenrod"),         COLOR_INDEX(0x17) | 0x0b86b8 },
    { _T("darkgray"),              COLOR_INDEX(0x18) | 0xa9a9a9 },
    { _T("darkgreen"),             COLOR_INDEX(0x19) | 0x006400 },
    { _T("darkkhaki"),             COLOR_INDEX(0x1a) | 0x6bb7bd },
    { _T("darkmagenta"),           COLOR_INDEX(0x1b) | 0x8b008b },
    { _T("darkolivegreen"),        COLOR_INDEX(0x1c) | 0x2f6b55 },
    { _T("darkorange"),            COLOR_INDEX(0x1d) | 0x008cff },
    { _T("darkorchid"),            COLOR_INDEX(0x1e) | 0xcc3299 },
    { _T("darkred"),               COLOR_INDEX(0x1f) | 0x00008b },
    { _T("darksalmon"),            COLOR_INDEX(0x20) | 0x7a96e9 },
    { _T("darkseagreen"),          COLOR_INDEX(0x21) | 0x8fbc8f },
    { _T("darkslateblue"),         COLOR_INDEX(0x22) | 0x8b3d48 },
    { _T("darkslategray"),         COLOR_INDEX(0x23) | 0x4f4f2f },
    { _T("darkturquoise"),         COLOR_INDEX(0x24) | 0xd1ce00 },
    { _T("darkviolet"),            COLOR_INDEX(0x25) | 0xd30094 },
    { _T("deeppink"),              COLOR_INDEX(0x26) | 0x9314ff },
    { _T("deepskyblue"),           COLOR_INDEX(0x27) | 0xffbf00 },
    { _T("dimgray"),               COLOR_INDEX(0x28) | 0x696969 },
    { _T("dodgerblue"),            COLOR_INDEX(0x29) | 0xff901e },
    { _T("firebrick"),             COLOR_INDEX(0x2a) | 0x2222b2 },
    { _T("floralwhite"),           COLOR_INDEX(0x2b) | 0xf0faff },
    { _T("forestgreen"),           COLOR_INDEX(0x2c) | 0x228b22 },
    { _T("fuchsia"),               COLOR_INDEX(0x2d) | 0xff00ff },
    { _T("gainsboro"),             COLOR_INDEX(0x2e) | 0xdcdcdc },
    { _T("ghostwhite"),            COLOR_INDEX(0x2f) | 0xfff8f8 },
    { _T("gold"),                  COLOR_INDEX(0x30) | 0x00d7ff },
    { _T("goldenrod"),             COLOR_INDEX(0x31) | 0x20a5da },
    { _T("gray"),                  COLOR_INDEX(0x32) | 0x808080 },
    { _T("green"),                 COLOR_INDEX(0x33) | 0x008000 },
    { _T("greenyellow"),           COLOR_INDEX(0x34) | 0x2fffad },
    { _T("honeydew"),              COLOR_INDEX(0x35) | 0xf0fff0 },
    { _T("hotpink"),               COLOR_INDEX(0x36) | 0xb469ff },
    { _T("indianred"),             COLOR_INDEX(0x37) | 0x5c5ccd },
    { _T("indigo"),                COLOR_INDEX(0x38) | 0x82004b },
    { _T("ivory"),                 COLOR_INDEX(0x39) | 0xf0ffff },
    { _T("khaki"),                 COLOR_INDEX(0x3a) | 0x8ce6f0 },
    { _T("lavender"),              COLOR_INDEX(0x3b) | 0xfae6e6 },
    { _T("lavenderblush"),         COLOR_INDEX(0x3c) | 0xf5f0ff },
    { _T("lawngreen"),             COLOR_INDEX(0x3d) | 0x00fc7c },
    { _T("lemonchiffon"),          COLOR_INDEX(0x3e) | 0xcdfaff },
    { _T("lightblue"),             COLOR_INDEX(0x3f) | 0xe6d8ad },
    { _T("lightcoral"),            COLOR_INDEX(0x40) | 0x8080f0 },
    { _T("lightcyan"),             COLOR_INDEX(0x41) | 0xffffe0 },
    { _T("lightgoldenrodyellow"),  COLOR_INDEX(0x42) | 0xd2fafa },
    { _T("lightgreen"),            COLOR_INDEX(0x43) | 0x90ee90 },
    { _T("lightgrey"),             COLOR_INDEX(0x44) | 0xd3d3d3 },
    { _T("lightpink"),             COLOR_INDEX(0x45) | 0xc1b6ff },
    { _T("lightsalmon"),           COLOR_INDEX(0x46) | 0x7aa0ff },
    { _T("lightseagreen"),         COLOR_INDEX(0x47) | 0xaab220 },
    { _T("lightskyblue"),          COLOR_INDEX(0x48) | 0xface87 },
    { _T("lightslategray"),        COLOR_INDEX(0x49) | 0x998877 },
    { _T("lightsteelblue"),        COLOR_INDEX(0x4a) | 0xdec4b0 },
    { _T("lightyellow"),           COLOR_INDEX(0x4b) | 0xe0ffff },
    { _T("lime"),                  COLOR_INDEX(0x4c) | 0x00ff00 },
    { _T("limegreen"),             COLOR_INDEX(0x4d) | 0x32cd32 },
    { _T("linen"),                 COLOR_INDEX(0x4e) | 0xe6f0fa },
    { _T("magenta"),               COLOR_INDEX(0x4f) | 0xff00ff },
    { _T("maroon"),                COLOR_INDEX(0x50) | 0x000080 },
    { _T("mediumaquamarine"),      COLOR_INDEX(0x51) | 0xaacd66 },
    { _T("mediumblue"),            COLOR_INDEX(0x52) | 0xcd0000 },
    { _T("mediumorchid"),          COLOR_INDEX(0x53) | 0xd355ba },
    { _T("mediumpurple"),          COLOR_INDEX(0x54) | 0xdb7093 },
    { _T("mediumseagreen"),        COLOR_INDEX(0x55) | 0x71b33c },
    { _T("mediumslateblue"),       COLOR_INDEX(0x56) | 0xee687b },
    { _T("mediumspringgreen"),     COLOR_INDEX(0x57) | 0x9afa00 },
    { _T("mediumturquoise"),       COLOR_INDEX(0x58) | 0xccd148 },
    { _T("mediumvioletred"),       COLOR_INDEX(0x59) | 0x8515c7 },
    { _T("midnightblue"),          COLOR_INDEX(0x5a) | 0x701919 },
    { _T("mintcream"),             COLOR_INDEX(0x5b) | 0xfafff5 },
    { _T("mistyrose"),             COLOR_INDEX(0x5c) | 0xe1e4ff },
    { _T("moccasin"),              COLOR_INDEX(0x5d) | 0xb5e4ff },
    { _T("navajowhite"),           COLOR_INDEX(0x5e) | 0xaddeff },
    { _T("navy"),                  COLOR_INDEX(0x5f) | 0x800000 },
    { _T("oldlace"),               COLOR_INDEX(0x60) | 0xe6f5fd },
    { _T("olive"),                 COLOR_INDEX(0x61) | 0x008080 },
    { _T("olivedrab"),             COLOR_INDEX(0x62) | 0x238e6b },
    { _T("orange"),                COLOR_INDEX(0x63) | 0x00a5ff },
    { _T("orangered"),             COLOR_INDEX(0x64) | 0x0045ff },
    { _T("orchid"),                COLOR_INDEX(0x65) | 0xd670da },
    { _T("palegoldenrod"),         COLOR_INDEX(0x66) | 0xaae8ee },
    { _T("palegreen"),             COLOR_INDEX(0x67) | 0x98fb98 },
    { _T("paleturquoise"),         COLOR_INDEX(0x68) | 0xeeeeaf },
    { _T("palevioletred"),         COLOR_INDEX(0x69) | 0x9370db },
    { _T("papayawhip"),            COLOR_INDEX(0x6a) | 0xd5efff },
    { _T("peachpuff"),             COLOR_INDEX(0x6b) | 0xb9daff },
    { _T("peru"),                  COLOR_INDEX(0x6c) | 0x3f85cd },
    { _T("pink"),                  COLOR_INDEX(0x6d) | 0xcbc0ff },
    { _T("plum"),                  COLOR_INDEX(0x6e) | 0xdda0dd },
    { _T("powderblue"),            COLOR_INDEX(0x6f) | 0xe6e0b0 },
    { _T("purple"),                COLOR_INDEX(0x70) | 0x800080 },
    { _T("red"),                   COLOR_INDEX(0x71) | 0x0000ff },
    { _T("rosybrown"),             COLOR_INDEX(0x72) | 0x8f8fbc },
    { _T("royalblue"),             COLOR_INDEX(0x73) | 0xe16941 },
    { _T("saddlebrown"),           COLOR_INDEX(0x74) | 0x13458b },
    { _T("salmon"),                COLOR_INDEX(0x75) | 0x7280fa },
    { _T("sandybrown"),            COLOR_INDEX(0x76) | 0x60a4f4 },
    { _T("seagreen"),              COLOR_INDEX(0x77) | 0x578b2e },
    { _T("seashell"),              COLOR_INDEX(0x78) | 0xeef5ff },
    { _T("sienna"),                COLOR_INDEX(0x79) | 0x2d52a0 },
    { _T("silver"),                COLOR_INDEX(0x7a) | 0xc0c0c0 },
    { _T("skyblue"),               COLOR_INDEX(0x7b) | 0xebce87 },
    { _T("slateblue"),             COLOR_INDEX(0x7c) | 0xcd5a6a },
    { _T("slategray"),             COLOR_INDEX(0x7d) | 0x908070 },
    { _T("snow"),                  COLOR_INDEX(0x7e) | 0xfafaff },
    { _T("springgreen"),           COLOR_INDEX(0x7f) | 0x7fff00 },
    { _T("steelblue"),             COLOR_INDEX(0x80) | 0xb48246 },
    { _T("tan"),                   COLOR_INDEX(0x81) | 0x8cb4d2 },
    { _T("teal"),                  COLOR_INDEX(0x82) | 0x808000 },
    { _T("thistle"),               COLOR_INDEX(0x83) | 0xd8bfd8 },
    { _T("tomato"),                COLOR_INDEX(0x84) | 0x4763ff },
    { _T("turquoise"),             COLOR_INDEX(0x85) | 0xd0e040 },
    { _T("violet"),                COLOR_INDEX(0x86) | 0xee82ee },
    { _T("wheat"),                 COLOR_INDEX(0x87) | 0xb3def5 },
    { _T("white"),                 COLOR_INDEX(0x88) | 0xffffff },
    { _T("whitesmoke"),            COLOR_INDEX(0x89) | 0xf5f5f5 },
    { _T("yellow"),                COLOR_INDEX(0x8a) | 0x00ffff },
    { _T("yellowgreen"),           COLOR_INDEX(0x8b) | 0x32cd9a }
};

extern const struct COLORVALUE_PAIR aSystemColors[];
const struct COLORVALUE_PAIR aSystemColors[] =
{
    { _T("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { _T("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { _T("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { _T("background"),         COLOR_BACKGROUND},      // Desktop background.
    { _T("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { _T("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { _T("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { _T("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { _T("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { _T("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { _T("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { _T("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { _T("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { _T("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { _T("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { _T("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { _T("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { _T("menu"),               COLOR_MENU},            // Menu background.
    { _T("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { _T("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { _T("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { _T("threedface"),         COLOR_3DFACE},
    { _T("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { _T("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { _T("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { _T("window"),             COLOR_WINDOW},          // Window background.
    { _T("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { _T("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
};

extern const INT cbSystemColorsSize;
const  INT cbSystemColorsSize = ARRAY_SIZE(aSystemColors);

int RTCCONV
CompareColorValuePairsByName( const void * pv1, const void * pv2 )
{
    return StrCmpIC( ((struct COLORVALUE_PAIR *)pv1)->szName,
                     ((struct COLORVALUE_PAIR *)pv2)->szName );
}

const struct COLORVALUE_PAIR *
FindColorByName( const TCHAR * szString )
{
    struct COLORVALUE_PAIR ColorName;

    ColorName.szName = szString;

    return (const struct COLORVALUE_PAIR *)bsearch( &ColorName,
                                              aColorNames,
                                              ARRAY_SIZE(aColorNames),
                                              sizeof(struct COLORVALUE_PAIR),
                                              CompareColorValuePairsByName );
}

const struct COLORVALUE_PAIR *
FindColorBySystemName( const TCHAR * szString )
{
    struct COLORVALUE_PAIR ColorName;

    ColorName.szName = szString;

    return (const struct COLORVALUE_PAIR *)bsearch( &ColorName,
                                                    aSystemColors,
                                                    ARRAY_SIZE(aSystemColors),
                                                    sizeof(struct COLORVALUE_PAIR),
                                                    CompareColorValuePairsByName );
}

const struct COLORVALUE_PAIR *
FindColorByColor( DWORD lColor )
{
    int nIndex;
    const struct COLORVALUE_PAIR * pColorName = NULL;

    // Unfortunately, this is a linear search.
    // Fortunately, we will need to lookup the name rarely.

    // The mask (high) byte should be clear.
    if (!(lColor & CColorValue::MASK_FLAG)) 
    {
        // Can't possibly be one of our colors
        return NULL;
    }

    for ( nIndex = ARRAY_SIZE( aColorNames ); nIndex-- ; )
    {
        if (lColor == (aColorNames[nIndex].dwValue & CColorValue::MASK_COLOR))
        {
            pColorName = aColorNames + nIndex;
            break;
        }
    }

    return pColorName;
}

const struct COLORVALUE_PAIR *
FindColorByValue( DWORD dwValue )
{
    CColorValue cvColor = dwValue;
    Assert(ARRAY_SIZE( aColorNames ) > cvColor.Index( dwValue ));
    return aColorNames + cvColor.Index( dwValue );
}

CColorValue::CColorValue ( VARIANT * pvar )
{
    if (V_VT(pvar) == VT_I4)
    {
        SetValue( V_I4( pvar ), TRUE );
    }
    else if (V_VT(pvar) == VT_BSTR)
    {
        FromString( V_BSTR( pvar ) );
    }
    else
    {
        _dwValue = VALUE_UNDEF;
    }
}

int
CColorValue::Index(const DWORD dwValue) const
{
    // The index, as stored in dwValue, should be 1-based.  This
    // is because we want to retain 0 as 'default' flag (undefined).

    // For the return value, however, we generally want an index
    // into aColorNames, so convert it to a 0-based index.

    // IEUNIX: color value starts form nColorNamesStartOffset.

    int nOneBasedIndex = (int)(dwValue >> 24);
    Assert( ARRAY_SIZE( aColorNames ) >= nOneBasedIndex - nColorNamesStartOffset );
    return nOneBasedIndex - nColorNamesStartOffset;
}

long
CColorValue::SetValue( long lColor, BOOL fLookupName, TYPE type)
{
    const struct COLORVALUE_PAIR * pColorName = NULL;

    if (fLookupName)
    {
        pColorName = FindColorByColor( lColor );
    }

    if (pColorName)
    {
        SetValue( pColorName );
    }
    else
    {
#ifdef UNIX
        if ( CColorValue(lColor).IsUnixSysColor()) {
            _dwValue = lColor;
            return _dwValue;
        }
#endif

        _dwValue = (lColor & MASK_COLOR) | type;
    }

    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetValue( const struct COLORVALUE_PAIR * pColorName )
{
    Assert( pColorName );
    Assert( ARRAY_SIZE( aColorNames ) > Index( pColorName->dwValue ) );

    _dwValue = pColorName->dwValue;
    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetRawValue( DWORD dwValue )
{
    _dwValue = dwValue;
    AssertSz( S_OK == IsValid(), "CColorValue::SetRawValue invalid value.");

#ifdef UNIX
    if ( IsUnixSysColor()) {
        return _dwValue;
    }
#endif

    return _dwValue & MASK_COLOR;
}

long
CColorValue::SetSysColor(int nIndex)
{
    _dwValue = TYPE_SYSINDEX + (nIndex << 24);

    return _dwValue & MASK_COLOR;
}


//+-----------------------------------------------------------------
//
//  Member : FromString
//
//  Synopsis : '#' tells us to force a Hex interpretation, w/0 it
//      we try to do a name look up, and if that fails, then we
//      fall back on hex interpretation anyhow.
//
//+-----------------------------------------------------------------
HRESULT
CColorValue::FromString( LPCTSTR pch, BOOL fStrictCSS1 /* FALSE */, BOOL fValidOnly /*=FALSE*/ , int iStrLen /* =-1 */)
{
    HRESULT hr = E_INVALIDARG;

    if (!pch || !*pch)
    {
        Undefine();
        hr = S_OK;
        goto Cleanup;
    }

    if (iStrLen == -1)
        iStrLen = _tcslen(pch);
    else
        iStrLen = min(iStrLen, (int)_tcslen(pch));

    // Leading '#' means it's a hex color, not a named color.
    if ( *pch != _T('#') )
    {
        // it can only be a name if there it is all alphanumeric
        int   i;
        BOOL  bNotAName = FALSE;
        BOOL  bFoundNonHex = FALSE;

        for (i=0; i<iStrLen; i++)
        {
            if (!_istalpha(pch[i]))
            {
                bNotAName = TRUE;
                break;
            }
            if (!bFoundNonHex && !_istxdigit(pch[i]))
                bFoundNonHex = TRUE;
        }

        // if it still COULD be a name, try it
        if (!bNotAName && bFoundNonHex)
        {
            hr = THR_NOTRACE(NameColor( pch ));
            //S_OK means we got it
            if (!hr)
                goto Cleanup;
        }

        // Try it as an rgb(r,g,b) functional notation
        hr = RgbColor( pch, iStrLen );
        // S_OK means it was.
        if ( !hr )
            goto Cleanup;

        // In strict css1 mode we do not try to recognize a string without a leading #
        // as a hex value.
        if (fStrictCSS1)
            goto Cleanup;
    }
    else
    {
         // Skip the '#' character
         pch++;
         iStrLen--;
    }

    // either its NOT a known name or it is a hex value so
    //   convert if necessary
	hr = THR_NOTRACE(HexColor(pch, iStrLen, fValidOnly));

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT GetRgbParam( LPCTSTR &pch, int &iStrLen, BYTE *pResult )
{
    HRESULT hr = S_OK;
    long lValue = 0;
    long lFractionDecimal = 1;
    BOOL fIsNegative = FALSE;

    Assert( "GetRgbParam requires a place to store its result!" && pResult );

    while ( iStrLen && _istspace( *pch ) )
    {
        pch++;
        iStrLen--;
    }

    if ( iStrLen && ( *pch == _T('-') ) )
    {
        fIsNegative = TRUE;
        pch++;
        iStrLen--;
    }

    if ( !(iStrLen && _istdigit( *pch ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    while ( iStrLen && _istdigit( *pch ) )
    {
        lValue *= 10;
        lValue += (long)(*pch) - '0';
        pch++;
        iStrLen--;
        if ( lValue > 255 )
        {   // We're over the maximum, might as well stop paying attention.
            while ( _istdigit( *pch ) )
            {
                pch++;
                iStrLen--;
            }
        }
    }

    if ( iStrLen && ( *pch == _T('.') ) )
    {
        pch++;
        iStrLen--;
        while ( iStrLen && _istdigit( *pch ) )
        {
            lValue *= 10;
            lValue += (long)(*pch) - _T('0');
            lFractionDecimal *= 10;
            pch++;
            iStrLen--;

            if ( lValue > ( LONG_MAX / 5100 ) ) // 5100 = 255 (multiplier in algorithm below) * 10 (multiplier in loop above) * 2 (slop)
            {   // Safety valve so we don't overrun a long.
                while ( _istdigit( *pch ) )
                {
                    pch++;
                    iStrLen--;
                }
            }
        }

    }

    if ( iStrLen && ( *pch == _T('%') ) )
    {
        if ( ( lValue / lFractionDecimal ) >= 100 )
            *pResult = 255;
        else
            *pResult = (BYTE) ( ( lValue * 255 ) / ( lFractionDecimal * 100 ) );
        pch++;
        iStrLen--;
    }
    else
    {
        if ( ( lValue / lFractionDecimal ) > 255 )
            *pResult = 255;
        else
            *pResult = (BYTE)(lValue/lFractionDecimal);
    }

    while ( iStrLen && _istspace( *pch ) )
    {
        pch++;
        iStrLen--;
    }

    if ( iStrLen && ( *pch == _T(',') ) )
    {
        pch++;
        iStrLen--;
    }

    if ( fIsNegative )
        *pResult = 0;
Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+------------------------------------------------------------------------
//
//  Member   : CColorValue::RgbColor
//
//  Synopsis : Convert an RGB functional notation to RGB DWORD
//
//  On entry : pch: "rgb( r, g, b )"
//
//  Returns  : 
//+-----------------------------------------------------------------------
HRESULT CColorValue::RgbColor( LPCTSTR pch, int iStrLen )
{
    HRESULT hr = E_INVALIDARG;
    DWORD   rgbColor = 0;

    if ( iStrLen > 4 && !_tcsnicmp( pch, 4, _T("rgb("), 4 ) )
    {
        // Looks like a functional notation to me.
        pch += 4;
        iStrLen -= 4;

#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[0] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[3] );
#endif
        if ( hr != S_OK )
            goto Cleanup;
#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[1] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[2] );
#endif
        if ( hr != S_OK )
            goto Cleanup;
#ifndef unix
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[2] );
#else
        hr = GetRgbParam( pch, iStrLen, &((BYTE *)&rgbColor)[1] );
#endif
        if ( hr != S_OK )
            goto Cleanup;

        if ( ( iStrLen == 1 ) && ( *pch == _T(')') ) )
            SetValue( rgbColor, FALSE, TYPE_RGB );
        else
            hr = E_INVALIDARG;
    }

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+-----------------------------------------------------------------------
//
//  Member   : GetHexDigit
//
//  Synopsis : Convert an ASCII hex digit character to binary
//
//  On entry : ch: ASCII character '0'..'9','A'..'F', or 'a'..'f'
//
//  Returns  : binary equivalent of ch interpretted at hex digit
//             0 if ch isn't a hex digit
//+-----------------------------------------------------------------------
static inline BYTE GetHexDigit( TCHAR ch, BOOL &fIsValid )
{
    if ( ch >= _T('0') && ch <= _T('9') ) 
    {
        return (BYTE) (ch - _T('0'));
    } 
    else 
    {
        if (ch >= _T('a') && ch <=('f'))
            return (BYTE) (ch - _T('a') + 10);            
        if ( ch >= _T('A') && ch <= _T('F') )
            return (BYTE) (ch - _T('A') + 10);
    }
    fIsValid = FALSE;
    return 0;
}

//+------------------------------------------------------------------------
//  Member: CColorValue::HexColor
//
//  Synopsis: Modifed from IE3 code base, this function takes a string which
//      needs to be converted into a hex rep for the rrggbb color.  The 
//      converstion is annoyingly lenient.
//
//  Note: The leniency of this routine is designed to emulate a popular Web browser
//        Fundamentally, the idea is to divide the given hex string into thirds, with 
//        each third being one of the colors (R,G,B).  If the string length isn't a multiple
//        three, it is (logically) extended with 0's.  Any character that isn't a hex digit
//        is treated as if it were a 0.  When each individual color spec is greater than
//        8 bits, the largest supplied color is used to determine how the given color
//        values should be interpretted (either as is, or scaled down to 8 bits).
//
//+------------------------------------------------------------------------
#define NUM_PRIMARIES   3
#define SHIFT_NUM_BASE  4
#define NUMBER_BASE     (1<<SHIFT_NUM_BASE)
#define MAX_COLORLENGTH 255

HRESULT
CColorValue::HexColor( LPCTSTR pch, int iStrLen, BOOL fValidOnly )
{
    HRESULT hr   = E_INVALIDARG;
    LPCTSTR pchTemp = pch;
    int     vlen = (iStrLen+NUM_PRIMARIES-1)/NUM_PRIMARIES;   // how many digits per section
    int     i, j;
    unsigned int rgb_vals[NUM_PRIMARIES];
    unsigned int max_seen = 0;
    DWORD   rgbColor = 0;
    TYPE    ColorType;
    BOOL    fIsValid = TRUE;

    if (!pch)
        goto Cleanup;

    if ( fValidOnly && (iStrLen != 3) && (iStrLen != 6) && (iStrLen != 9) )
        return E_INVALIDARG;

    // convert string to three color digits ala IE3, and others
    for ( i = 0; i < NUM_PRIMARIES; i++ ) 
    {                               
        // for each tri-section of the string
        for ( j = 0, rgb_vals[i] = 0; j < vlen; j++ ) 
        {                        
            rgb_vals[i] = (rgb_vals[i]<<SHIFT_NUM_BASE) + GetHexDigit(*pchTemp, fIsValid);

            if ( fValidOnly && !fIsValid )
                return E_INVALIDARG;

            if ( *pchTemp )                                         
                pchTemp++; 
        }
        if ( rgb_vals[i] > max_seen ) 
            max_seen = rgb_vals[i]; 
    }

    // rgb_values now has the triad in decimal
    // If any individual color component uses more than 8 bits, 
    //      scale all color values down.
    for ( i = 0 ; max_seen > MAX_COLORLENGTH ; i++ ) 
    {
        max_seen >>= SHIFT_NUM_BASE; 
    }

    if ( i>0 )
    {
        for ( j = 0; j < NUM_PRIMARIES; j++ ) 
            rgb_vals[j] >>= i*SHIFT_NUM_BASE;
    }

    // we used to do arena compatible handling of pound[1,2,3] colors always,
    // however we want NS compatibility and so #ab is turned to #0a0b00 rather
    // than #aabb00, but ONLY for non-stylesheet properties.
    if ( fValidOnly )
    {
        // This code makes #RGB expand to #RRGGBB, instead of #0R0G0B, which apparently those ... people at NS think is correct.
        if ( vlen == 1 )	// only 4 bits/color - scale up by 4 bits (& add to self, to get full range).
        {
            for ( i = 0; i < NUM_PRIMARIES; i++ ) 
            {
                rgb_vals[ i ] += rgb_vals[ i ]<<SHIFT_NUM_BASE;
            }
        }
    }

    // now put the rgb_vals together into a format our code understands
    // mnopqr => qropmn  or in colorese:  rrggbb => bbggrr
#ifdef BIG_ENDIAN
    ((BYTE *)&rgbColor)[0] = 0; 
    ((BYTE *)&rgbColor)[1] = (BYTE)rgb_vals[2];
    ((BYTE *)&rgbColor)[2] = (BYTE)rgb_vals[1];
    ((BYTE *)&rgbColor)[3] = (BYTE)rgb_vals[0];
#else
    ((BYTE *)&rgbColor)[0] = (BYTE)rgb_vals[0];
    ((BYTE *)&rgbColor)[1] = (BYTE)rgb_vals[1];
    ((BYTE *)&rgbColor)[2] = (BYTE)rgb_vals[2];
    ((BYTE *)&rgbColor)[3] = 0;
#endif
    switch (iStrLen) 
    {
    case 0:
        ColorType = TYPE_UNDEF;
        break;
    case 1:
        ColorType = TYPE_POUND1;
        break;
    case 2:
        ColorType = TYPE_POUND2;
        break;
    case 3:
        ColorType = TYPE_POUND3;
        break;
    case 4:
        ColorType = TYPE_POUND4;
        break;
    case 5:
        ColorType = TYPE_POUND5;
        break;
    case 6:
    default:
        ColorType = TYPE_POUND6;
        break;
    }

    // and finally set the color
    SetValue( rgbColor, FALSE, ColorType);
    hr = S_OK;

Cleanup:
    RRETURN1( hr, E_INVALIDARG );
}

//+--------------------------------------------------------------------
//
//  member : Name Color
//
//  Sysnopsis : trying to parse a color string.. it could be a name
//      so lets look for it. if we find it, set the value and leave
//      otherwite return invalidarg (i.e. membernotfound)
//
//+--------------------------------------------------------------------
HRESULT
CColorValue::NameColor( LPCTSTR pch )
{
    const struct COLORVALUE_PAIR * pColorName = FindColorByName( pch );
    HRESULT hr = S_OK;

    if (pColorName)
        SetValue( pColorName );
    else
    {
        pColorName = FindColorBySystemName( pch );
        if ( pColorName )
            _dwValue = TYPE_SYSNAME + (pColorName->dwValue<<24);
        else
        {
            if ( !_wcsicmp( pch, _T("transparent") ) )
                _dwValue = (DWORD)TYPE_TRANSPARENT;
            else
                hr = E_INVALIDARG;
        }
    }
    RRETURN1( hr, E_INVALIDARG );
}

HRESULT
CColorValue::IsValid() const
{
    return ((TYPE_NAME != GetType()) ||
            (ARRAY_SIZE(aColorNames) > Index(GetRawValue()))) ? S_OK : E_INVALIDARG;
}

OLE_COLOR
CColorValue::GetOleColor() const
{
    if ( IsSysColor()) 
        return OLECOLOR_FROM_SYSCOLOR((_dwValue & MASK_SYSCOLOR)>>24);

#ifdef UNIX       
    if ( IsUnixSysColor()) {
        return (OLE_COLOR)_dwValue;
    }
#endif

    return (OLE_COLOR)(_dwValue & MASK_COLOR);
}

CColorValue::TYPE
CColorValue::GetType() const
{
    DWORD dwFlag = _dwValue & MASK_FLAG;

    // What a royal mess.  See the comment in cdbase.hxx for more info
    if ((dwFlag < TYPE_TRANSPARENT) && (dwFlag >= TYPE_NAME))
    {
        if (dwFlag >= TYPE_SYSNAME)
        {
            // A fancy way of avoiding yet another comparison (against TYPE_SYSINDEX)

            dwFlag &= ~MASK_SYSCOLOR;
        }
        else
        {
            dwFlag = TYPE_NAME;
        }
    }

    return (CColorValue::TYPE) dwFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\connect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       connect.cxx
//
//  Contents:   Connection points.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

MtDefine(CConnectionPointContainer, ObjectModel, "CConnectionPointContainer")
MtDefine(CCPCEnumCPAry, Locals, "CConnectionPointContainer::EnumConnectionPoints CPtrAry<IConnectionPoint *>")
MtDefine(CCPCEnumCPAry_pv, CCPCEnumCPAry, "CConnectionPointContainer::EnumConnectionPoints CPtrAry<IConnectionPoint *>::_pv")
MtDefine(CConnectionPtEnumConnectionsAry_pv, Locals, "CConnectionPt::EnumConnections CPtrAry<LPUNKNOWN>::_pv")

DECLARE_CPtrAry(CCPCEnumCPAry, IConnectionPoint *, Mt(CCPCEnumCPAry), Mt(CCPCEnumCPAry_pv))

EXTERN_C const IID DIID_HTMLElementEvents;
EXTERN_C const IID DIID_HTMLControlElementEvents;
EXTERN_C const IID IID_IControlEvents;

#ifdef _WIN64
DWORD   g_dwCookieForWin64 = 0;
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoAdvise
//
//  Synopsis:   Implements IConnectionPoint::Advise.
//
//  Arguments:  [ppUnkSinkOut]    -- Pointer to outgoing sink ptr.
//              [iid]             -- Interface of the advisee.
//              [fEvent]          -- Whether it's an event iface advise
//              [pUnkSinkAdvise]  -- Advisee's sink.
//              [pdwCookie]       -- Cookie to identify connection.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoAdvise(
    REFIID          iid,
    DISPID          dispidBase,
    IUnknown *      pUnkSinkAdvise,
    IUnknown **     ppUnkSinkOut,
    DWORD *         pdwCookie)
{
    HRESULT                     hr;
    IUnknown                   *pUnk = NULL;
    CAttrValue::AAExtraBits     wAAExtra = CAttrValue::AA_Extra_Empty;
    DWORD                       dwCookie;

    Assert(iid != IID_NULL);
    
    if (!pUnkSinkAdvise)
        RRETURN(E_INVALIDARG);

    hr = THR_NOTRACE(pUnkSinkAdvise->QueryInterface(iid, (void **) &pUnk));
    if (hr)
    {
        // If someone is trying to listen to IE4 bad guid for IHTMLControlElementEvents the IID
        // was changed to be unique.  Java VM needs to be advised on this interface not IDispatch
        // (it can't handle it although it should).
        if (iid == DIID_HTMLControlElementEvents)
        {
            hr = THR_NOTRACE(pUnkSinkAdvise->QueryInterface(IID_IControlEvents, (void **) &pUnk));
        }

        if (hr)
        {
            if (dispidBase == DISPID_A_EVENTSINK)
		    {
		        hr = THR(pUnkSinkAdvise->QueryInterface(IID_IDispatch, (void **) &pUnk));
		    }

            if (hr)
                RRETURN1(CONNECT_E_CANNOTCONNECT, CONNECT_E_CANNOTCONNECT);
        }
    }


    if (iid == IID_ITridentEventSink)
    {
        // Quick VBS event hookup.
        wAAExtra = CAttrValue::AA_Extra_TridentEvent;
    }
    // Any event IIDs between 0x305f60e and max UUID of 0x30c38c70 would support
    // new style event binding of the eventObj being a parameter when the event is
    // fired.
    else if (iid.Data1 >= 0x3050f60f && iid.Data1 <= 0x30c38c70)
    {
        // is the rest of GUID in the Trident range?  If not then we're old style
        // event hookup (no eventObj argument)
        if (memcmp(&(DIID_HTMLElementEvents.Data2),
                   &(iid.Data2),
                   sizeof(REFIID) - sizeof(DWORD)))
        {
            // Old style Trident event hookup w/o EventObj as a parameter.
            wAAExtra = CAttrValue::AA_Extra_OldEventStyle;
        }
    }
    else
    {
        // Old style Trident event hookup w/o EventObj as a parameter.
        wAAExtra = CAttrValue::AA_Extra_OldEventStyle;
    }

    hr = THR(AddUnknownObjectMultiple(dispidBase, pUnk, CAttrValue::AA_Internal, wAAExtra));
    if (hr)
        goto Cleanup;

    if (ppUnkSinkOut)
    {
        *ppUnkSinkOut = pUnk;
        pUnk->AddRef();
    }

#ifdef _WIN64
    AAINDEX aaidx;
    aaidx = AA_IDX_UNKNOWN;
    Verify(FindAdviseIndex(dispidBase, 0, pUnk, &aaidx) == S_OK);    // We just added it, so this better not fail
    dwCookie = (DWORD)InterlockedIncrement((LONG *)&g_dwCookieForWin64);
    if (aaidx != AA_IDX_UNKNOWN)
    {
        Verify(SetCookieAt(aaidx, dwCookie) == S_OK);
    }
#else
    dwCookie = (DWORD)pUnk;
#endif

    if (pdwCookie)
    {
        *pdwCookie = dwCookie;
    }

Cleanup:
    ReleaseInterface(pUnk);
    RRETURN1(hr, CONNECT_E_ADVISELIMIT);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoUnadvise
//
//  Synopsis:   Implements IConnectionPoint::Unadvise.
//
//  Arguments:  [dwCookie]        -- Cookie handed out upon Advise.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoUnadvise(DWORD dwCookie, DISPID dispidBase)
{
#ifdef _WIN64
    HRESULT hr;
    AAINDEX aaidx;
    
    if (!dwCookie)
        return S_OK;

    hr = THR(FindAdviseIndex(dispidBase, dwCookie, NULL, &aaidx));
    if (hr)
        goto Cleanup;

    DeleteAt(aaidx);

Cleanup:
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
#else
    return DoUnadvise((IUnknown *)dwCookie, dispidBase);
#endif
}

//+---------------------------------------------------------------------------
//
//  Method:     CBase::DoUnadvise
//
//  Synopsis:   Implements IConnectionPoint::Unadvise. Gor internal use only.
//              Useful for avoiding transforming DWORD to pUNk in Win 64.
//
//----------------------------------------------------------------------------

HRESULT
CBase::DoUnadvise(IUnknown * pUnk, DISPID dispidBase)
{
    HRESULT hr;
    AAINDEX aaidx;
    
    if (!pUnk)
        return S_OK;

    hr = THR(FindAdviseIndex(dispidBase, 0, pUnk, &aaidx));
    if (hr)
        goto Cleanup;

    DeleteAt(aaidx);

Cleanup:
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
}


HRESULT
CBase::FindAdviseIndex(DISPID dispidBase, DWORD dwCookie, IUnknown * pUnkCookie, AAINDEX * paaidx)
{
    HRESULT     hr       = S_OK;
    IUnknown *  pUnkSink = NULL;
    AAINDEX     aaidx    = AA_IDX_UNKNOWN;

    if (!*GetAttrArray())
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Cleanup;
    }

    //
    // Loop through the attr array indices looking for the dwCookie and/or
    // pUnkCookie as the value.
    //

    for (;;)
    {
        aaidx = FindNextAAIndex(
            dispidBase,
            CAttrValue::AA_Internal,
            aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;
            
        if (pUnkCookie)
        {
            ClearInterface(&pUnkSink);
            hr = THR(GetUnknownObjectAt(aaidx, &pUnkSink));
            if (hr || !pUnkSink)
            {
                hr = CONNECT_E_NOCONNECTION;
                goto Cleanup;
            }

            if (pUnkSink == pUnkCookie)
                break;
        }

#ifdef _WIN64
        if (dwCookie)
        {
            DWORD dwCookieSink;
            hr = THR(GetCookieAt(aaidx, &dwCookieSink));
            if (dwCookie == dwCookieSink)
                break;
        }
#endif
    }

    if (aaidx == AA_IDX_UNKNOWN)
    {
        hr = CONNECT_E_NOCONNECTION;
        goto Cleanup;
    }

    *paaidx = aaidx;

Cleanup:
    ReleaseInterface(pUnkSink);
    RRETURN1(hr, CONNECT_E_NOCONNECTION);
}

//+------------------------------------------------------------------------
//
//  CConnectionPointContainer implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::CConnectionPointContainer
//
//  Synopsis:   ctor.
//
//  Arguments:  [pBase]     -- CBase object using this container.
//
//----------------------------------------------------------------------------

CConnectionPointContainer::CConnectionPointContainer(CBase * pBase, IUnknown *pUnkOuter)
{
    CONNECTION_POINT_INFO * pcpi;
    long            i;
    
    MemSetName((this, "CPC pBase=%08x", pBase));

    Assert(pBase);
    Assert(pBase->BaseDesc()->_pcpi);

    for (i = 0; i < CONNECTION_POINTS_MAX; i++)
    {
        _aCP[i]._index = -1;
    }
    
    //
    // Note: we set the refcount to 0 because the caller of this function will
    // AddRef it as part of its implementation of QueryInterface.
    //

    _ulRef      = 0;
    _pBase      = pBase;
    _pUnkOuter  = pUnkOuter;

    // _pUnkOuter is specified explicitly when creating a new
    // COM identity on top of the CBase object. In this case,
    // we only need to SubAddRef the CBase object.

    if (_pUnkOuter)
    {
        _pBase->SubAddRef();
        _pUnkOuter->AddRef();
    }
    else
    {
        _pBase->PrivateAddRef();
        _pBase->PunkOuter()->AddRef();
    }
    
    for (i = 0, pcpi = GetCPI(); pcpi && pcpi->piid; pcpi++, i++)
    {
        _aCP[i]._index = i;
    }

    Assert(i < CONNECTION_POINTS_MAX - 1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::~CConnectionPointContainer
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

CConnectionPointContainer::~CConnectionPointContainer()
{
    // _pUnkOuter is specified explicitly when creating a new
    // COM identity on top of the CBase object. In this case,
    // we only need to SubRelease the CBase object.

    if (_pUnkOuter)
    {
        _pBase->SubRelease();
        _pUnkOuter->Release();
    }
    else
    {
        _pBase->PrivateRelease();
        _pBase->PunkOuter()->Release();
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::QueryInterface(REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = _pUnkOuter ? _pUnkOuter : _pBase->PunkOuter();
    RRETURN_NOTRACE(THR_NOTRACE(pUnk->QueryInterface(iid, ppvObj)));
}


//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::AddRef, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPointContainer::AddRef()
{
    return _ulRef++;
}



//+------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::Release, IUnknown
//
//  Synopsis:   As per IUnknown.
//
//-------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPointContainer::Release()
{
    Assert(_ulRef > 0);

    if (--_ulRef == 0)
    {
        _ulRef = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRef;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::EnumConnectionPoints
//
//  Synopsis:   Enumerates the container's connection points.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::EnumConnectionPoints(IEnumConnectionPoints ** ppEnum)
{
    HRESULT                         hr;
    CCPCEnumCPAry *                 paCP;
    CConnectionPt *                 pCP;

    if (!ppEnum)
        RRETURN(E_POINTER);

    //
    // Copy pointers to connection points to new array.
    //

    *ppEnum = NULL;
    paCP = new CCPCEnumCPAry;
    if (!paCP)
        RRETURN(E_OUTOFMEMORY);

    for (pCP = _aCP; pCP->_index != -1; pCP++)
    {
        hr = THR(paCP->Append(pCP));
        if (hr)
            goto Error;

        pCP->AddRef();
    }

    //
    // Create enumerator which references array.
    //

    hr = THR(paCP->EnumElements(
            IID_IEnumConnectionPoints,
            (LPVOID*)ppEnum,
            TRUE,
            FALSE,
            TRUE));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    paCP->ReleaseAll();
    delete paCP;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::FindConnectionPoint
//
//  Synopsis:   Finds a connection point with a particular IID.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPointContainer::FindConnectionPoint(
        REFIID              iid,
        IConnectionPoint ** ppCP)
{
    CConnectionPt * pCP;

    if (!ppCP)
        RRETURN(E_POINTER);

    *ppCP = NULL;

    for (pCP = _aCP; pCP->_index != -1; pCP++)
    {
        if (*(pCP->MyCPI()->piid) == iid)
        {
            *ppCP = pCP;
            pCP->AddRef();

            return S_OK;
        }
    }

    // If someone is trying to listen to IE4 bad guid for IHTMLControlElementEvents the IID
    // was changed to be unique.  IE4 shipped with IControlEvents for the guid of
    // IControlEvents so we'll map that interface to the correct IE5 IHTMLControlElementEvents
    // IID.
    if (iid == IID_IControlEvents)
    {
        for (pCP = _aCP; pCP->_index != -1; pCP++)
        {
            if (*(pCP->MyCPI()->piid) == DIID_HTMLControlElementEvents)
            {
                *ppCP = pCP;
                pCP->AddRef();
                return S_OK;
            }
        }
    }

    RRETURN(E_NOINTERFACE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPointContainer::GetCPI
//
//  Synopsis:   Get a hold of the array of connection pt information.
//
//----------------------------------------------------------------------------

CONNECTION_POINT_INFO *
CConnectionPointContainer::GetCPI()
{
    return (CONNECTION_POINT_INFO *)(_pBase->BaseDesc()->_pcpi);
}


//+------------------------------------------------------------------------
//
//  CConnectionPt implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::QueryInterface
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::QueryInterface(REFIID iid, LPVOID * ppvObj)
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppvObj = (IConnectionPoint *) this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *) *ppvObj)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::AddRef
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPt::AddRef()
{
    MyCPC()->_ulRef++;
    return MyCPC()->_pBase->SubAddRef();
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Release
//
//  Synopsis:   Per IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CConnectionPt::Release()
{
    CBase * pBase;

    Assert(MyCPC()->_ulRef > 0);

    pBase = MyCPC()->_pBase;
    if (--MyCPC()->_ulRef == 0)
    {
        MyCPC()->_ulRef = ULREF_IN_DESTRUCTOR;
        delete MyCPC();
    }

    return pBase->SubRelease();
}



//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::GetConnectionInterface
//
//  Synopsis:   Returns the IID of this connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::GetConnectionInterface(IID * pIID)
{
    if (!pIID)
        RRETURN(E_POINTER);

    Assert(_index != -1);
    *pIID = *MyCPI()->piid;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::GetConnectionPointContainer
//
//  Synopsis:   Returns the container of this connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    Assert(_index != -1);
    
    if (!ppCPC)
        RRETURN(E_POINTER);

    if (MyCPC()->_pBase->PunkOuter() != (IUnknown *) MyCPC()->_pBase)
    {
        RRETURN(MyCPC()->_pBase->PunkOuter()->QueryInterface(
                IID_IConnectionPointContainer, (void **) ppCPC));
    }

    *ppCPC = MyCPC();
    (*ppCPC)->AddRef();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Advise
//
//  Synopsis:   Adds a connection.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie)
{
    Assert(_index != -1);

    const CONNECTION_POINT_INFO * pcpi = MyCPI();
    
    RRETURN(MyCPC()->_pBase->DoAdvise(
        *pcpi->piid,
        pcpi->dispid,
        pUnkSink,
        NULL,
        pdwCookie));
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::Unadvise
//
//  Synopsis:   Removes a connection.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::Unadvise(DWORD dwCookie)
{
    Assert(_index != -1);
    
    RRETURN(MyCPC()->_pBase->DoUnadvise(
        dwCookie,
        MyCPI()->dispid));
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionPt::EnumConnections
//
//  Synopsis:   Enumerates the connections.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CConnectionPt::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    Assert(_index != -1);
    
    HRESULT                 hr;
    DISPID                  dispidBase;
    CEnumConnections *      pEnum   = NULL;
    CDataAry<CONNECTDATA>   aryCD(Mt(CConnectionPtEnumConnectionsAry_pv));
    CONNECTDATA             cdNew;
    AAINDEX                 aaidx = AA_IDX_UNKNOWN;
    
    cdNew.pUnk = NULL;

    if (!ppEnum)
        RRETURN(E_POINTER);

    if (*(MyCPC()->_pBase->GetAttrArray()))
    {
        dispidBase = MyCPI()->dispid;

        //
        // Iterate thru attr array values with this dispid, appending
        // the IUnknown into a local array.
        //

        for (;;)
        {
            aaidx = MyCPC()->_pBase->FindNextAAIndex(
                dispidBase,
                CAttrValue::AA_Internal,
                aaidx);
            if (aaidx == AA_IDX_UNKNOWN)
                break;
                
            ClearInterface(&cdNew.pUnk);
            hr = THR(MyCPC()->_pBase->GetUnknownObjectAt(
                    aaidx, 
                    &cdNew.pUnk));
            if (hr)
                goto Cleanup;

#ifdef _WIN64
            Verify(MyCPC()->_pBase->GetCookieAt(aaidx, &cdNew.dwCookie) == S_OK);
#else
            cdNew.dwCookie = (DWORD)cdNew.pUnk;
#endif

            hr = THR(aryCD.AppendIndirect(&cdNew));
            if (hr)
                goto Cleanup;
        }
    }

    hr = THR(CEnumConnections::Create(aryCD.Size(), (CONNECTDATA *)(LPVOID)aryCD, &pEnum));

    //  Note that since our enumeration base class doesn't officially
    //    support the IEnumConnections interface, we have to do
    //    an explicit cast via void *

    *ppEnum = (IEnumConnections *) (void *) pEnum;

Cleanup:
    ReleaseInterface(cdNew.pUnk);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\sctrl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  Contents:   CServer implementation (partial).
//
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_H_
#define X_MACCONTROLS_H_
#include "maccontrols.h"
#endif
#endif

DeclareTag(tagOleState, "Server", "OLE state transitions")
PerfDbgExtern(tagPerfWatch)
ExternTag(tagDisableLockAR);

BEGIN_TEAROFF_TABLE(CServer, IOleInPlaceObjectWindowless)
    TEAROFF_METHOD(CServer, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CServer, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CServer, InPlaceDeactivate, inplacedeactivate, ())
    TEAROFF_METHOD(CServer, UIDeactivate, uideactivate, ())
    TEAROFF_METHOD(CServer, SetObjectRects, setobjectrects, (LPCOLERECT lprcPosRect, LPCOLERECT lprcClipRect))
    TEAROFF_METHOD(CServer, ReactivateAndUndo, reactivateandundo, ())
    TEAROFF_METHOD(CServer, OnWindowMessage, onwindowmessage, (UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult))
    TEAROFF_METHOD(CServer, GetDropTarget, getdroptarget, (IDropTarget** ppDropTarget))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleDocumentView)
    TEAROFF_METHOD(CServer, SetInPlaceSite, setinplacesite, (LPOLEINPLACESITE pIPSite))
    TEAROFF_METHOD(CServer, GetInPlaceSite, getinplacesite, (LPOLEINPLACESITE* ppIPSite))
    TEAROFF_METHOD(CServer, GetDocument, getdocument, (IUnknown** ppUnk))
    TEAROFF_METHOD(CServer, SetRect, setrect, (LPRECT lprcView))
    TEAROFF_METHOD(CServer, GetRect, getrect, (LPRECT lprcView))
    TEAROFF_METHOD(CServer, SetRectComplex, setrectcomplex, (LPRECT lprcView, LPRECT lprcHScroll, LPRECT lprcVScroll, LPRECT lprcSizeBox))
    TEAROFF_METHOD(CServer, Show, show, (BOOL fShow))
    TEAROFF_METHOD(CServer, UIActivate, uiactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, Open, open, ())
    TEAROFF_METHOD(CServer, CloseView, closeview, (DWORD dwReserved))
    TEAROFF_METHOD(CServer, SaveViewState, saveviewstate, (IStream* pStm))
    TEAROFF_METHOD(CServer, ApplyViewState, applyviewstate, (IStream* pStm))
    TEAROFF_METHOD(CServer, Clone, clone, (IOleInPlaceSite* pNewIPSite, IOleDocumentView** ppNewView))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleInPlaceActiveObject)
    TEAROFF_METHOD(CServer, GetWindow, getwindow, (HWND*))
    TEAROFF_METHOD(CServer, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    TEAROFF_METHOD(CServer, TranslateAccelerator, translateaccelerator, (LPMSG lpmsg))
    TEAROFF_METHOD(CServer, OnFrameWindowActivate, onframewindowactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, OnDocWindowActivate, ondocwindowactivate, (BOOL fActivate))
    TEAROFF_METHOD(CServer, ResizeBorder, resizeborder, ( LPCOLERECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow))
    TEAROFF_METHOD(CServer, EnableModeless, enablemodeless, (BOOL fEnable))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleObject)
    TEAROFF_METHOD(CServer, SetClientSite, setclientsite, (LPOLECLIENTSITE pClientSite))
    TEAROFF_METHOD(CServer, GetClientSite, getclientsite, (LPOLECLIENTSITE FAR* ppClientSite))
    TEAROFF_METHOD(CServer, SetHostNames, sethostnames, (LPCTSTR szContainerApp, LPCTSTR szContainerObj))
    TEAROFF_METHOD(CServer, Close, close, (DWORD dwSaveOption))
    TEAROFF_METHOD(CServer, SetMoniker, setmoniker, (DWORD dwWhichMoniker, LPMONIKER pmk))
    TEAROFF_METHOD(CServer, GetMoniker, getmoniker, (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk))
    TEAROFF_METHOD(CServer, InitFromData, initfromdata, (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved))
    TEAROFF_METHOD(CServer, GetClipboardData, getclipboarddata, (DWORD dwReserved, LPDATAOBJECT * ppDataObject))
    TEAROFF_METHOD(CServer, DoVerb, doverb, (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, LONG lindex, HWND hwndParent, LPCOLERECT lprcPosRect))
    TEAROFF_METHOD(CServer, EnumVerbs, enumverbs, (LPENUMOLEVERB FAR* ppenumOleVerb))
    TEAROFF_METHOD(CServer, Update, update, ())
    TEAROFF_METHOD(CServer, IsUpToDate, isuptodate, ())
    TEAROFF_METHOD(CServer, GetUserClassID, getuserclassid, (CLSID FAR* pClsid))
    TEAROFF_METHOD(CServer, GetUserType, getusertype, (DWORD dwFormOfType, LPTSTR FAR* pszUserType))
    TEAROFF_METHOD(CServer, SetExtent, setextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CServer, GetExtent, getextent, (DWORD dwDrawAspect, LPSIZEL lpsizel))
    TEAROFF_METHOD(CServer, Advise, advise, (IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CServer, Unadvise, unadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CServer, EnumAdvise, enumadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
    TEAROFF_METHOD(CServer, GetMiscStatus, getmiscstatus, (DWORD dwAspect, DWORD FAR* pdwStatus))
    TEAROFF_METHOD(CServer, SetColorScheme, setcolorscheme, (LPLOGPALETTE lpLogpal))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleControl)
    TEAROFF_METHOD(CServer, GetControlInfo, getcontrolinfo, (CONTROLINFO * pCI))
    TEAROFF_METHOD(CServer, OnMnemonic, onmnemonic, (LPMSG pMsg))
    TEAROFF_METHOD(CServer, OnAmbientPropertyChange, onambientpropertychange, (DISPID dispid))
    TEAROFF_METHOD(CServer, FreezeEvents, freezeevents, (BOOL fFreeze))
END_TEAROFF_TABLE()

#ifdef FANCY_CONNECTION_STUFF
BEGIN_TEAROFF_TABLE(CServer, IRunnableObject)
    TEAROFF_METHOD(CServer, GetRunningClass, getrunningclass, (LPCLSID lpclsid))
    TEAROFF_METHOD(CServer, Run, run, (LPBINDCTX pbc))
    TEAROFF_METHOD_(CServer, IsRunning, isrunning, BOOL, ())
    TEAROFF_METHOD(CServer, LockRunning, lockrunning, (BOOL fLock, BOOL fLastUnlockCloses))
    TEAROFF_METHOD(CServer, SetContainedObject, setcontainedobject, (BOOL fContained))
END_TEAROFF_TABLE()
#endif

#ifdef FANCY_CONNECTION_STUFF
BEGIN_TEAROFF_TABLE(CServer, IExternalConnection)
    TEAROFF_METHOD_(CServer, AddConnection, addconnection, DWORD, (DWORD extconn, DWORD reserved))
    TEAROFF_METHOD_(CServer, ReleaseConnection, releaseconnection, DWORD, (DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses))
END_TEAROFF_TABLE()
#endif

BEGIN_TEAROFF_TABLE(CServer, IPersistStreamInit)
    TEAROFF_METHOD(CServer, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CServer, IsDirty, isdirty, ())
    TEAROFF_METHOD(CServer, Load, LOAD, (LPSTREAM pStm))
    TEAROFF_METHOD(CServer, Save, SAVE, (LPSTREAM pStm, BOOL fClearDirty))
    TEAROFF_METHOD(CServer, GetSizeMax, GETSIZEMAX, (ULARGE_INTEGER FAR * pcbSize))
    TEAROFF_METHOD(CServer, InitNew, initnew, ())
END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IPersistStorage)
//    TEAROFF_METHOD(GetClassID, (LPCLSID lpClassID))
//    TEAROFF_METHOD(IsDirty, ())
//    TEAROFF_METHOD(InitNew, (LPSTORAGE  pStg))
//    TEAROFF_METHOD(Load, (LPSTORAGE  pStg))
//    TEAROFF_METHOD(Save, (LPSTORAGE  pStgSave, BOOL fSameAsLoad))
//    TEAROFF_METHOD(SaveCompleted, (LPSTORAGE  pStgNew))
//    TEAROFF_METHOD(HandsOffStorage, ())
//END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IPersistPropertyBag)
//    TEAROFF_METHOD(GetClassID, (LPCLSID lpClassID))
//    TEAROFF_METHOD(InitNew, ())
//    TEAROFF_METHOD(Load, (LPPROPERTYBAG pBag, LPERRORLOG pErrLog))
//    TEAROFF_METHOD(Save, (LPPROPERTYBAG pBag, BOOL fClearDirty, BOOL fSaveAllProperties))
//END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IDataObject)
    TEAROFF_METHOD(CServer, GetData, getdata, (LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium))
    TEAROFF_METHOD(CServer, GetDataHere, getdatahere, (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium))
    TEAROFF_METHOD(CServer, QueryGetData, querygetdata, (LPFORMATETC pformatetc))
    TEAROFF_METHOD(CServer, GetCanonicalFormatEtc, getcanonicalformatetc, (LPFORMATETC pformatetc, LPFORMATETC pformatetcOut))
    TEAROFF_METHOD(CServer, SetData, setdata, (LPFORMATETC pformatetc, LPSTGMEDIUM pmedium, BOOL fRelease))
    TEAROFF_METHOD(CServer, EnumFormatEtc, enumformatetc, (DWORD dwDirection, LPENUMFORMATETC FAR* ppenum))
    TEAROFF_METHOD(CServer, DAdvise, dadvise, (LPFORMATETC pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD FAR* pdwConnection))
    TEAROFF_METHOD(CServer, DUnadvise, dunadvise, (DWORD dwConnection))
    TEAROFF_METHOD(CServer, EnumDAdvise, enumdadvise, (LPENUMSTATDATA FAR* ppenumAdvise))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleDocument)
    TEAROFF_METHOD(CServer, CreateView, createview, (IOleInPlaceSite * pIPSite, IStream * pStm, DWORD dwReserved, IOleDocumentView ** ppView))
    TEAROFF_METHOD(CServer, GetDocMiscStatus, getdocmiscstatus, (DWORD * pdwStatus))
    TEAROFF_METHOD(CServer, EnumViews, enumviews, (IEnumOleDocumentViews ** ppEnumViews, IOleDocumentView ** ppView))
END_TEAROFF_TABLE()

//BEGIN_TEAROFF_TABLE(CServer, IQuickActivate)
//    TEAROFF_METHOD(QuickActivate, (QACONTAINER *pqacontainer, QACONTROL *pqacontrol))
//    TEAROFF_METHOD(SetContentExtent, (LPSIZEL))
//    TEAROFF_METHOD(GetContentExtent, (LPSIZEL))
//END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IOleCache2)
 TEAROFF_METHOD(CServer, Cache, cache, (FORMATETC *pformatetc, DWORD advf, DWORD *pdwConnection))
 TEAROFF_METHOD(CServer, Uncache, uncache, (DWORD dwConnection))
 TEAROFF_METHOD(CServer, EnumCache, enumcache, (IEnumSTATDATA  **ppenumSTATDATA))
 TEAROFF_METHOD(CServer, InitCache, initcache, (IDataObject *pDataObject))
 // SetData renamed to SetDataCache to avoid conflict with IDataObject::SetData
 TEAROFF_METHOD(CServer, SetDataCache, setdatacache, (FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease))
 TEAROFF_METHOD(CServer, UpdateCache, updatecache, (LPDATAOBJECT pDataObject, DWORD grfUpdf, LPVOID pReserved))
 TEAROFF_METHOD(CServer, DiscardCache, discardcache, (DWORD dwDiscardOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IPointerInactive)
    TEAROFF_METHOD(CServer, GetActivationPolicy, getactivationpolicy, (DWORD * pdwPolicy))
    TEAROFF_METHOD(CServer, OnInactiveMouseMove, oninactivemousemove, (LPCRECT pRectBounds, long x, long y, DWORD grfKeyState))
    TEAROFF_METHOD(CServer, OnInactiveSetCursor, oninactivesetcursor, (LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CServer, IPerPropertyBrowsing)
    TEAROFF_METHOD(CServer, GetDisplayString, getdisplaystring, (DISPID dispid, BSTR * lpbstr))
    TEAROFF_METHOD(CServer, MapPropertyToPage, mappropertytopage, (DISPID dispid, LPCLSID lpclsid))
    TEAROFF_METHOD(CServer, GetPredefinedStrings, getpredefinedstrings, (DISPID dispid, CALPOLESTR * lpcaStringsOut, CADWORD FAR* lpcaCookiesOut))
    TEAROFF_METHOD(CServer, GetPredefinedValue, getpredefinedvalue, (DISPID dispid, DWORD dwCookie, VARIANT * lpvarOut))
END_TEAROFF_TABLE()


//+---------------------------------------------------------------
//
//  Member:     CServer::CServer
//
//  Synopsis:   Constructor for CServer object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

CServer::CServer(IUnknown *pUnkOuter) : CBase()
{
    TraceTag((tagCServer, "constructing CServer"));

    IncrementObjectCount(&_dwObjCnt);

    _pUnkOuter  = pUnkOuter ? pUnkOuter : PunkInner();

    _state = OS_PASSIVE;
    _fUserMode = TRUE;

#ifndef NO_EDIT
    Assert(!_pUndoMgr);

    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT

    _dwAspects = DVASPECT_CONTENT;

    _sizel.cx = _sizel.cy = 1;

}

//+---------------------------------------------------------------
//
//  Member:     CServer::~CServer
//
//  Synopsis:   Destructor for the CServer object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It ensure the object
//              is in a passive state and releases the data/view and inplace
//              subobjects objects.
//
//---------------------------------------------------------------

CServer::~CServer(void)
{
    //  Release interface pointers and strings

    // Delete here just in case we created it without going inplace.
    delete _pInPlace;
    _pInPlace = NULL;

    ReleaseInterface(_pClientSite);
    ReleaseInterface(_pAdvSink);
    ReleaseInterface(_pStg);
#ifndef NO_EDIT
    ReleaseInterface(_pUndoMgr);
#endif // NO_EDIT

    ReleaseInterface(_pOleAdviseHolder);
    ReleaseInterface(_pDataAdviseHolder);
    ReleaseInterface(_pCache);
    ReleaseInterface(_pPStgCache);
    ReleaseInterface(_pViewObjectCache);
    ReleaseInterface(_pPictureMouse);

#ifdef _MAC
	DestroyMacScrollbar(_hVertScroll);
	DestroyMacScrollbar(_hHorzScroll);
#endif

    DecrementObjectCount(&_dwObjCnt);

    TraceTag((tagCServer, "destructed CServer"));
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::Passivate
//
//  Synopsis:   Per CBase.
//
//----------------------------------------------------------------------------

void
CServer::Passivate()
{
    //  Containers are not required to call IOleObject::Close on
    //    objects; containers are allowed to just release all pointers
    //    to an embedded object.  This means that the last reference
    //    to an object can disappear while the object is still in
    //    the OS_RUNNING state.  So, we demote it if necessary.

    Assert(_state <= OS_RUNNING);
    if (_state > OS_LOADED)
    {
        TransitionTo(OS_LOADED);
    }

#ifndef NO_EDIT
    ClearInterface(&_pUndoMgr);

    _pUndoMgr = &g_DummyUndoMgr;
#endif // NO_EDIT


    CBase::Passivate();
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::PrivateQueryInterface, public
//
//  Synopsis:   QueryInterface on the private unknown for CServer
//
//  Arguments:  [riid] -- Interface to return
//              [ppv]  -- New interface returned here
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IViewObjectEx)
        QI_INHERITS2(this, IViewObject, IViewObjectEx)
        QI_INHERITS2(this, IViewObject2, IViewObjectEx)
        QI_TEAROFF(this, IOleObject, _pUnkOuter)
        QI_TEAROFF(this, IOleControl, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF2((CBase *)this, IProvideClassInfo2, IProvideMultipleClassInfo, _pUnkOuter)
        QI_TEAROFF((CBase *)this, ISpecifyPropertyPages, _pUnkOuter)
#ifdef FANCY_CONNECTION_STUFF
        QI_TEAROFF(this, IRunnableObject, _pUnkOuter)
        QI_TEAROFF(this, IExternalConnection, _pUnkOuter)
#endif
        QI_TEAROFF(this, IDataObject, _pUnkOuter)
        QI_TEAROFF(this, IOleDocument, _pUnkOuter)
        QI_TEAROFF(this, IOleCache2, _pUnkOuter)
        QI_TEAROFF2(this, IOleCache, IOleCache2, _pUnkOuter)
        QI_TEAROFF((CBase *)this, IOleCommandTarget, _pUnkOuter)
        QI_TEAROFF(this, IPointerInactive, _pUnkOuter)
        QI_TEAROFF(this, ISupportErrorInfo, _pUnkOuter)
        QI_TEAROFF(this, IPerPropertyBrowsing, _pUnkOuter)
        QI_TEAROFF2(this, IOleWindow, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF2(this, IOleInPlaceObject, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceObjectWindowless, _pUnkOuter)
        QI_TEAROFF(this, IOleInPlaceActiveObject, _pUnkOuter)
        QI_TEAROFF(this, IOleDocumentView, _pUnkOuter)

        default:
            if (iid == IID_IConnectionPointContainer)
            {
                *((IConnectionPointContainer **)ppv) =
                        new CConnectionPointContainer(this, NULL);

                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
            }
            else if (((BaseDesc()->_piidDispinterface && iid == *(BaseDesc()->_piidDispinterface)) ||
                (iid == IID_IDispatch)) &&
                (ServerDesc()->_ibItfPrimary != 0))
            {
                *ppv = (IUnknown *) ((BYTE *) this + ServerDesc()->_ibItfPrimary);
            }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    DbgTrackItf(iid, "CServer", FALSE, ppv);

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::TransitionTo, public
//
//  Synopsis:   Drives the transition of the object from one state to another
//
//  Arguments:  [state] -- the desired resulting state of the object
//
//  Returns:    Success iff the transition completed successfully.  On failure
//              the object will be in the original or some intermediate,
//              but consistent, state.
//
//  Notes:      There are eight direct state transitions.  These are:
//              between the passive and loaded states, between the
//              loaded and inplace states, between the inplace and U.I. active
//              states, and between the loaded and opened states.
//              Each of these direct transitions has an overridable method
//              that effects it.  The TransitionTo function implements
//              transitions between any two arbitrary states by calling
//              these direct transition methods in the proper order.
//
//---------------------------------------------------------------

HRESULT
CServer::TransitionTo(OLE_SERVER_STATE state, LPMSG lpmsg)
{
    PerfDbgLog2(tagPerfWatch, this, "+CServer::TransitionTo %s --> %s", DebugOleStateName(_state), DebugOleStateName(state));

    HRESULT hr = S_OK;

    //  Our objects are not arbitrarily reentrant; specifically,
    //    during TransitionTo, reentrancy to other state transition
    //    functions is only allowed during the various
    //    On[InPlace/UI][Activate/Deactivate] notifications.

    if (TestLock(SERVERLOCK_TRANSITION))
        RRETURN(E_UNEXPECTED);
    //
    //  CLock takes care of blocking transitions and
    //    stabilizing the reference count.
    //

    CLock Lock(this, SERVERLOCK_TRANSITION);

    //  Note that support for the OPEN state is being removed
    //    from the base classes

    Assert(state >= OS_LOADED && state <= OS_UIACTIVE);
    Assert(_state >= OS_PASSIVE && _state <= OS_UIACTIVE);

    // trace tag output
    TraceTag((tagOleState,
                    "%08lX Transition from %s to %s",
                    this,
                    DebugOleStateName(_state),
                    DebugOleStateName(state)));
    
    //  Loop until we've reached the target state.  Some of the
    //    transitions include callbacks to the container, where we
    //    allow the container to make a reentrant call to TransitionTo.
    //    If the state doesn't match our immediate (one-hop) target,
    //    then we stop trying, under the assumption that someone else
    //    has transitioned us to a more urgent target.
    //
    //  + Transitions which do not have reentrant callbacks have
    //    asserts that either an error occurred, or else we're in
    //    the right state
    //
    //  + Transitions with callbacks exit (with success) if after
    //    the transition the object is in an unexpected state

    while (State() != state && !hr)
    {
        switch (_state)
        {
        case OS_PASSIVE:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (PassiveToLoaded)");
            hr = THR(PassiveToLoaded());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (PassiveToLoaded)");
            Assert(hr || _state == OS_LOADED);
            break;

        case OS_LOADED:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (LoadedToRunning)");
            hr = THR(LoadedToRunning());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (LoadedToRunning)");
            Assert(hr || _state == OS_RUNNING);
            break;

        case OS_RUNNING:
            switch (state)
            {
            case OS_LOADED:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (RunningToLoaded)");
                hr = THR(RunningToLoaded());
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (RunningToLoaded)");
                Assert(hr || _state == OS_LOADED);
                break;

            case OS_INPLACE:
            case OS_UIACTIVE:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (RunningToInPlace)");
                hr = THR(RunningToInPlace(lpmsg));
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (RunningToInPlace)");
                if (_state != OS_INPLACE)
                    goto StopTrying;
                break;

            }
            break;

        case OS_INPLACE:
            switch (state)
            {
            case OS_UIACTIVE:
                if (!RequestUIActivate())
                {
                    hr = E_FAIL;
                    goto StopTrying;
                }
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (InPlaceToUIActive)");
                hr = THR(InPlaceToUIActive(lpmsg));
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (InPlaceToUIActive)");
                if (_state != OS_UIACTIVE)
                    goto StopTrying;
                break;

            default:
                PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (InPlaceToRunning)");
                hr = THR(InPlaceToRunning());
                PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (InPlaceToRunning)");
                if (_state != OS_RUNNING)
                    goto StopTrying;
                break;
            }
            break;

        case OS_UIACTIVE:
            PerfDbgLog(tagPerfWatch, this, "+CServer::TransitionTo (UIActiveToInPlace)");
            hr = THR(UIActiveToInPlace());
            PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo (UIActiveToInPlace)");
            if (_state != OS_INPLACE)
                goto StopTrying;
            break;

        }
    }

StopTrying:

    PerfDbgLog(tagPerfWatch, this, "-CServer::TransitionTo");
    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::PassiveToLoaded, protected
//
//  Synopsis:   Effects the direct passive to loaded state transition
//
//  Returns:    Success iff the object is in the loaded state.  On failure
//              the object will be in a consistent passive state.
//
//  Notes:      The base class does not do any processing on this transition.
//
//---------------------------------------------------------------

HRESULT
CServer::PassiveToLoaded(void)
{
    _state = OS_LOADED;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::LoadedToRunning, protected
//
//  Synopsis:   Effects the direct loaded to running state transition
//
//  Returns:    Success if the object is running.
//
//  Notes:      This transition occurs as a result of an
//              IRunnableObject::Run call and is implicit in any
//              DoVerb call.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadedToRunning(void)
{
    LPOLECONTAINER  pContainer;

    //  Put a lock on our container.  This is necessary if our container
    //    allows other clients to link to contained objects (us).

    if (_pClientSite && !_pClientSite->GetContainer(&pContainer))
    {
        // CONSIDER - should we remember LockContainer failed so that we
        //      can avoid calling LockContainer(FALSE) later?

        THR_NOTRACE(pContainer->LockContainer(TRUE));
        pContainer->Release();
    }

    _state = OS_RUNNING;

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::RunningToLoaded, protected
//
//  Synopsis:   Effects the direct running to loaded state transition
//
//  Returns:    Success if the object is loaded.
//
//  Notes:      This transition occurs as a result of an IOleObject::Close()
//              call.
//              This method sends an OnClose notification to all of our
//              advises.
//
//---------------------------------------------------------------

HRESULT
CServer::RunningToLoaded(void)
{
    LPOLECONTAINER  pContainer  = NULL;

    //  Release the lock we put on our container.  Not all containers
    //    support locking, so we allow failures

    if (_pClientSite)
    {
        if (!_pClientSite->GetContainer(&pContainer))
        {
            THR_NOTRACE(pContainer->LockContainer(FALSE));
            pContainer->Release();
        }
    }

    if (_lDirtyVersion)
    {
        SendOnDataChange(ADVF_DATAONSTOP);
    }

    //  Notify our advise holders that we have closed

    if (_pOleAdviseHolder)
        _pOleAdviseHolder->SendOnClose();

#if 0
    //  CONSIDER not sure where (or even if) we should be calling
    //    this.  Chris and Gary need to investigate.

    //  Forcibly cut off remoting clients

    CoDisconnectObject((LPOLEOBJECT) this, 0);
#endif

    _state = OS_LOADED;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RunningToInPlace, protected
//
//  Synopsis:   Effects the direct Running to inplace state transition
//
//  Returns:    Success iff the object is in the inplace state.  On failure
//              the object will be in a consistent Running state.
//
//  Notes:      This transition invokes the ActivateInPlace method.  Containers
//              will typically override this method in order to additionally
//              inplace activate any inside-out embeddings that are visible.
//
//---------------------------------------------------------------

HRESULT
CServer::RunningToInPlace(LPMSG lpmsg)
{
    HRESULT                     hr;

    //  CONSIDER flatten call tree

    hr = THR(ActivateInPlace(lpmsg));
    if (hr)
        goto Error;

#ifdef FANCY_CONNECTION_STUFF
    //  Put an external lock on ourselves so we stay in the running
    //    state even if we have other external connections.

    IGNORE_HR(LockRunning(TRUE, FALSE));
#endif

Error:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceToRunning, protected
//
//  Synopsis:   Effects the direct inplace to Running state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateInPlace method.
//
//              Containers will typically override this method in
//              order to additionally inplace deactivate any inplace-active
//              embeddings.
//
//              This method is called as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceToRunning(void)
{
    HRESULT     hr;

    //  CONSIDER flatten call tree

    //
    // Free the external lock we hold to keep ourselves in the running
    // state in the case of other external connections.
    //

#ifdef FANCY_CONNECTION_STUFF
    IGNORE_HR(LockRunning(FALSE, FALSE));
#endif

    hr = THR(DeactivateInPlace());

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceToUIActive, protected
//
//  Synopsis:   Effects the direct inplace to U.I. active state transition
//
//  Returns:    Success iff the object is in the U.I. active state.  On failure
//              the object will be in a consistent inplace state.
//
//  Notes:      This transition invokes the ActivateUI method.
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceToUIActive(LPMSG lpmsg)
{
    HRESULT     hr;

    //  CONSIDER flatten call tree

#ifndef NO_OLEUI
    hr = THR(ActivateUI(lpmsg));
    if (hr)
        goto Error;
#endif // NO_OLEUI

    hr = THR(SetActiveObject());

Error:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::UIActiveToInPlace, protected
//
//  Synopsis:   Effects the direct U.I. Active to inplace state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateUI method.
//              Containers will typically override this method in
//              order to possibly U.I. deactivate a U.I. active embedding.
//
//---------------------------------------------------------------

HRESULT
CServer::UIActiveToInPlace(void)
{
    IGNORE_HR(ClearActiveObject());

#ifndef NO_OLEUI
    RRETURN(THR(DeactivateUI()));
#else
	RRETURN(S_OK);
#endif // NO_OLEUI
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetActiveObject, protected
//
//  Synopsis:   Informs the frame that we are now the UIActive object.
//
//---------------------------------------------------------------

HRESULT
CServer::SetActiveObject()
{
    HRESULT hr;
    IOleInPlaceActiveObject * pInPlaceActiveObject = NULL;

    TCHAR   ach[MAX_USERTYPE_LEN + 1];

    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPESHORT(BaseDesc()->_idrBase),
            ach,
            ARRAY_SIZE(ach)));

    hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
    if (hr)
        goto Cleanup;

    hr = THR(_pInPlace->_pFrame->SetActiveObject(pInPlaceActiveObject, ach));

Cleanup:
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer:ClearActiveObject, protected
//
//  Synopsis:   Informs the frame that we are no longer the UIActive object.
//
//---------------------------------------------------------------

HRESULT
CServer::ClearActiveObject()
{
    RRETURN(THR(_pInPlace->_pFrame->SetActiveObject(NULL,NULL)));
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetClientSite, public
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves the client site pointer in the
//              _pClientSite member variable.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    IOleDocumentSite *   pMsoDocSite;
    IOleUndoManager *    pUM = NULL;
    HRESULT              hr;
    HRESULT              hr2;


    //  If we already have a client site, refuse requests to
    //    change it
    hr = S_OK;
    if (_pClientSite)
    {
        if (pClientSite)
            RRETURN(E_INVALIDARG);

        ClearInterface(&_pClientSite);

        Assert(!_pInPlace || !_pInPlace->_pInPlaceSite);

        // QUESTION - Why is this needed?
        _fMsoViewExists = FALSE;
    }
    else
    {
        _pClientSite = pClientSite;
        _pClientSite->AddRef();

        DbgTrackItf(IID_IOleClientSite, "HostSite", TRUE, (void **)&_pClientSite);

        _fUserMode = GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

        // CONSIDER Can we recognize doc mode without doing this? (garybu)
        if (OK(THR_NOTRACE(pClientSite->QueryInterface(
                IID_IOleDocumentSite, (void **) &pMsoDocSite))))
        {
            _fMsoDocMode = TRUE;
            ReleaseInterface(pMsoDocSite);
        }

#ifndef NO_EDIT
        if (!hr && (_pUndoMgr == &g_DummyUndoMgr))
        {
            //
            // We don't want to call any overridden implementations because
            // all we want to do is check our parent. We don't want any
            // derived classes creating the undo manager in this call because
            // we'll create it ourselves below.
            //
            hr2 = THR_NOTRACE(CServer::QueryService(
                                SID_SOleUndoManager,
                                IID_IOleUndoManager,
                                (LPVOID*)&pUM));

            if (OK(hr2) && pUM)
            {
                _pUndoMgr = pUM;
            }
            else
            {
                if (ServerDesc()->TestFlag(SERVERDESC_CREATE_UNDOMGR))
                {
                    hr = THR(CreateUndoManager());
                }
                else
                {
                    _pUndoMgr = &g_DummyUndoMgr;
                }
            }
        }
#endif // NO_EDIT
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetClientSite, IOleObject
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetClientSite(LPOLECLIENTSITE * ppClientSite)
{
    *ppClientSite = _pClientSite;
    if (_pClientSite)
    {
        _pClientSite->AddRef();
    }
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//              These strings should be remembered for open
//              edit or to pass along to embeddings that open
//              edit.  Most classes derived from CServer don't
//              care about this, so we ignore them here.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetHostNames(LPCTSTR lpstrCntrApp, LPCTSTR lpstrCntrObj)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::Close
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method ensures the object is in the loaded
//              (not passive!) state.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Close(DWORD dwSaveOption)
{
    HRESULT hr          = S_OK;
    BOOL    fSave;
    int     id;

    // if our object is dirty then we should save it, depending on the
    // save options
    if (_pClientSite != NULL && _lDirtyVersion)
    {
        switch(dwSaveOption)
        {
        case OLECLOSE_SAVEIFDIRTY:
            fSave = TRUE;
            break;

        case OLECLOSE_NOSAVE:
            fSave = FALSE;
            break;

        case OLECLOSE_PROMPTSAVE:
            {
                if (_state <= OS_INPLACE)
                {
                    //we do not prompt if the object
                    //is in-place or invisible
                    fSave = TRUE;
                    break;
                }

                //we only prompt in the following state
                Assert(_state == OS_UIACTIVE);

                //  Put up a message box asking the user if they want
                //    to update the container.

                //  CONSIDER make this work better with DisplayName
                //    ambient property

                hr = THR(ShowMessage(
                    &id,
                    MB_YESNOCANCEL | MB_ICONQUESTION,
                    0,
                    IDS_MSG_SAVE_MODIFIED_OBJECT));

                if (hr)
                    RRETURN(hr);

                if (id == IDCANCEL)
                    RRETURN(OLE_E_PROMPTSAVECANCELLED);

                fSave = (id == IDYES);
            }
            break;

        default:
            RRETURN(E_INVALIDARG);
        }

        if (fSave)
            hr = THR(_pClientSite->SaveObject());
    }

    if (!hr)
        hr = THR(TransitionTo(OS_LOADED));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method notifies our data/view subobject of our new
//              moniker.  It also registers us in the running object
//              table and sends an OnRename notification to all registered
//              advises.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    HRESULT     hr      = S_OK;
    LPMONIKER   pmkFull = NULL;

    //  Ensure that we have a full moniker to register in the ROT
    //  If we have a full moniker, then go with it.
    //  Otherwise ask our client site for a full moniker.

    if (dwWhichMoniker == OLEWHICHMK_OBJFULL)
    {
        pmkFull = pmk;
        if (pmkFull)
            pmkFull->AddRef();
    }
    else
    {
        if (_pClientSite == NULL)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = THR(_pClientSite->GetMoniker(
                    OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJFULL,
                    &pmkFull));
        }

        if (hr)
            goto Cleanup;
    }

    if (pmkFull)
    {
        //  Notify our advise holders that we have been renamed

        if (_pOleAdviseHolder)
            _pOleAdviseHolder->SendOnRename(pmkFull);
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method forwards the request to our client site
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    HRESULT     hr;

    if (ppmk == NULL)
        RRETURN(E_INVALIDARG);

    *ppmk = NULL;   // set out parameters to NULL

    //  Get the requested moniker from our client site

    if (_pClientSite == NULL)
        hr = MK_E_UNAVAILABLE;
    else
        hr = THR_NOTRACE(_pClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk));

    RRETURN_NOTRACE(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InitFromData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_FALSE indicating InitFromData
//              is not supported.  Servers that wish to support initialization
//              from a selection should override this function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::InitFromData(
        LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    return S_FALSE;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetClipboardData
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetClipboardData(DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    if (ppDataObject == NULL)
        RRETURN(E_INVALIDARG);

    *ppDataObject = NULL;               // set out params to NULL

    RRETURN(E_NOTIMPL);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoVerb
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method locates the requested verb in the servers
//              verb table and calls the associated verb function.
//              If the verb is not found then the first (at index 0) verb in
//              the verb table is called.  This should be the primary verb
//              with verb number 0.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DoVerb(
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCOLERECT lprcPosRect)
{
    HRESULT hr  = S_OK;
    int     i;

    Assert(ServerDesc());
    Assert(ServerDesc()->_pOleVerbTable);
    Assert(ServerDesc()->_pOleVerbTable[0].lVerb == OLEIVERB_PRIMARY);

    //  Find the verb in the verb table.

    for (i = 0; i < ServerDesc()->_cOleVerbTable; i++)
    {
        if (iVerb == ServerDesc()->_pOleVerbTable[i].lVerb)
            break;
    }

    //  If the verb is not in the table, then return an error for negative
    //      verbs or default to the 0th entry in the table for positive verbs.
    //      The 0th entry in the table must be the primary verb.

    if (i >= ServerDesc()->_cOleVerbTable)
    {
        if (iVerb < 0)
            RRETURN(E_NOTIMPL);

        i = 0;
    }

    //  All DoVerbs make an implicit transition to the running state if
    //  the object is not already running.
    //
    //  Putting the server into the running state and then returning
    //  E_NOTIMPL for a verb will confuse the container about our state.
    //  Because some classes can return E_NOTIMPL from the state transition
    //  verbs, we skip the step of putting the object into the running
    //  state here.  The implementation of the state transition verbs
    //  will take care of getting the server into the running state.

    if (_state < OS_RUNNING &&
            iVerb != OLEIVERB_INPLACEACTIVATE &&
            iVerb != OLEIVERB_UIACTIVATE)
    {
        // if we are less than OS_LOADED this will transition us up to
        // running.  This happens with outlook
        hr = THR(TransitionTo(OS_RUNNING));
        if (hr)
            goto Cleanup;
    }

    //  Dispatch the verb

    hr = THR((*ServerDesc()->_pfnDoVerb[i])(
            this,
            iVerb,
            lpmsg,
            pActiveSite,
            lindex,
            hwndParent,
            lprcPosRect));
    
    if (hr)
        goto Cleanup;

    //  If we defaulted to the 0th entry in the table (primary verb),
    //      then return the appropriate status.

    if (OK(hr) && iVerb != ServerDesc()->_pOleVerbTable[i].lVerb)
    {
        hr = OLEOBJ_S_INVALIDVERB;
    }

Cleanup:

    //  CONSIDER the error handling here is a little unclear.  Normally,
    //    if we get an error, we try to leave ourselves in our original
    //    state.  However, with DoVerb, we don't have enough information
    //    to know why we're in the state we're in.  We might have
    //    failed, or someone might have moved us there during a callback,
    //    or whatever.
    //
    //  For Forms95, we just leave ourselves in whatever state we're
    //    in if an error occurs.  Note that we do guarantee that we've
    //    legally reached the current state.  Revisit for Forms96.

    RRETURN2(hr, OLEOBJ_S_INVALIDVERB, OLEOBJ_S_CANNOT_DOVERB_NOW);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumVerbs
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method produces an enumerator over the server's
//              verb table.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    HRESULT     hr;

    if (ppenum == NULL)
        RRETURN(E_INVALIDARG);

    hr = THR(CreateOLEVERBEnum(
            ServerDesc()->_pOleVerbTable,
            ServerDesc()->_cOleVerbTable,
            ppenum));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Update
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_OK indicating that the update was
//              successful.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Update(void)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_OK indicating that the object is
//              up to date.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::IsUpToDate(void)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        RRETURN(E_INVALIDARG);
    }

    *pClsid = *BaseDesc()->_pclsid;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetUserType
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the user type string from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetUserType(DWORD dwFormOfType, LPTSTR FAR* ppstr)
{
    int         ids;
    TCHAR       ach[MAX_USERTYPE_LEN + 1];
    const CBase::CLASSDESC * pcd = BaseDesc();

    switch (dwFormOfType)
    {
    case USERCLASSTYPE_APPNAME:
        ids = IDS_USERTYPEAPP;
        break;

    case USERCLASSTYPE_SHORT:
        ids = IDS_USERTYPESHORT(pcd->_idrBase);
        break;

    case USERCLASSTYPE_FULL:
        ids = IDS_USERTYPEFULL(pcd->_idrBase);
        break;

    default:
        *ppstr = NULL;
        RRETURN(E_INVALIDARG);
    }



    Verify(LoadString(
            GetResourceHInst(),
            ids,
            ach,
            ARRAY_SIZE(ach)));

    RRETURN(TaskAllocString(ach, ppstr));
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetExtent
//
//  Synopsis:   Method of IOleObject interface.  Sets the extent
//              for some aspect of the object.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetExtent(DWORD dwAspect, SIZEL *psizel)
{
    HRESULT     hr;
    BOOL fChangedExtent = FALSE;

    Assert(psizel->cx >= 0);
    Assert(psizel->cy >= 0);

    if (psizel->cx < 0 || psizel->cy < 0)
    {
        RRETURN(E_FAIL);
    }

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:

/*
        if (State() >= OS_INPLACE && _sizel.cx && _sizel.cy)
        {
            SIZE size;

            // In order to do himetric <-> pixel conversions, we need to keep
            // _sizel and _pInPlace->_rcPos in sync.  We do this by updating
            // _pInPlace->_rcPos to what we think the container will tell us
            // in a later call to IOleInPlaceObject::SetObjectRects. If the
            // container does not do this, we will be in a confused state.
            //
            // CONSIDER: Consider the CDK behavior.  It keeps things in sync
            // by calling IOleInPlace::OnPosRectChanged with the new rectangle
            // instead of setting _pInPlace->_rcPos directly. This seems
            // wasteful because it causes the container to call
            // SetObjectRects twice -- once from OnPosRectChanged and a
            // second time because the container is trying to resize the
            // control. The CDK uses a flag to prevent infinite recursion
            // should the container call IOleObject::SetExtent from
            // IOleInPlaceSite::OnPosRectChanged (as many seem to do).

            DeviceFromHimetric(&size, *psizel);
            _pInPlace->_rcPos.right  = _pInPlace->_rcPos.left + size.cx;
            _pInPlace->_rcPos.bottom = _pInPlace->_rcPos.top  + size.cy;
        }
*/
        if ( memcmp ( &_sizel, psizel, sizeof ( SIZEL ) ) )
        {
            fChangedExtent = TRUE;
        }
        _sizel = *psizel;
        hr = S_OK;
        break;

    case DVASPECT_DOCPRINT:
        hr = E_NOTIMPL;
        goto Cleanup;

    case DVASPECT_THUMBNAIL:
    case DVASPECT_ICON:
        hr = E_FAIL;
        goto Cleanup;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    if (!_fMsoDocMode && fChangedExtent )
    {
        // Our width & height are persisted through property changes
        // So don't dirty the form
        OnDataChange(FALSE);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetExtent
//
//  Synopsis:   Method of IOleObject interface.  Returns the current
//              size of some aspect of the object.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetExtent(DWORD dwAspect, LPSIZEL lpsizel)
{
    HRESULT     hr  = S_OK;

    if (lpsizel == NULL)
        RRETURN(E_INVALIDARG);

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
        *lpsizel = _sizel;
        break;

    case DVASPECT_THUMBNAIL:
        lpsizel->cx = HimetricFromHPix(32);
        lpsizel->cy = HimetricFromVPix(32);
        break;

    case DVASPECT_ICON:
        if (_pViewObjectCache)
        {
            hr = THR(_pViewObjectCache->GetExtent(
                    dwAspect,
                    -1,
                    NULL,
                    lpsizel));
        }
        else
        {
#ifdef WINCE
	        hr = E_INVALIDARG;
#else
            HGLOBAL         hMF;
            LPMETAFILEPICT  pMF;

            hMF = OleGetIconOfClass(*BaseDesc()->_pclsid, NULL, TRUE);
            if (hMF)
            {
                pMF = (LPMETAFILEPICT) GlobalLock(hMF);
                if (pMF)
                {
	                lpsizel->cx = pMF->xExt;    //  Values are HIMETRIC
    	            lpsizel->cy = pMF->yExt;
	
    	            DeleteMetaFile(pMF->hMF);
                }
                else
               	{
    	            hr = E_OUTOFMEMORY;
               	}
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
#endif // WINCE
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Advise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    HRESULT hr;

    if (!pdwConnection)
        RRETURN(E_INVALIDARG);

    *pdwConnection = NULL;              // set out params to NULL

    if (!_pOleAdviseHolder)
    {
        hr = THR(CreateOleAdviseHolder(&_pOleAdviseHolder));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_pOleAdviseHolder->Advise(pAdvSink, pdwConnection));

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Unadvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Unadvise(DWORD dwConnection)
{
    HRESULT     hr;

    if (!_pOleAdviseHolder)
        RRETURN(OLE_E_NOCONNECTION);

    hr = THR(_pOleAdviseHolder->Unadvise(dwConnection));

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::EnumAdvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    HRESULT     hr;

    if (!ppenumAdvise)
        RRETURN(E_INVALIDARG);

    if (_pOleAdviseHolder == NULL)
    {
        *ppenumAdvise = NULL;
        hr = S_OK;
    }
    else
    {
        hr = THR(_pOleAdviseHolder->EnumAdvise(ppenumAdvise));
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMiscStatus
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the misc status flags from the server's
//              CLASSDESC structure
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetMiscStatus (DWORD dwAspect, DWORD FAR* pdwStatus)
{
    *pdwStatus = ServerDesc()->_dwMiscStatus;
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetColorScheme
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Servers should override this method if they are
//              interested in the palette.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetColorScheme (LPLOGPALETTE lpLogpal)
{
    RRETURN(E_NOTIMPL);   //will we ever?
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetRunningClass, public
//
//  Synopsis:   Returns our current class ID.  Method on IRunnableObject.
//
//  Arguments:  [lpClsid] -- Place to return clsid
//
//----------------------------------------------------------------------------
#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::GetRunningClass(LPCLSID lpClsid)
{
    if (!lpClsid)
        RRETURN(E_INVALIDARG);

    *lpClsid = *BaseDesc()->_pclsid;

    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::Run, public
//
//  Synopsis:   Method in IRunnableObject.  Puts us into the running state if
//              we're not already there.
//
//  Arguments:  [pbc] -- Bind context. (Ignored)
//
//  Notes:      If we're in the running, inplace, or UI Active states, then
//              this method has no effect.
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::Run(LPBINDCTX pbc)
{
    HRESULT hr = S_OK;

    if (_state < OS_RUNNING)
        hr = THR(TransitionTo(OS_RUNNING));

    RRETURN(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::IsRunning, public
//
//  Synopsis:   Method on IRunnableObject.  Returns whether or not we're
//              running.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------
#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(BOOL)
CServer::IsRunning(void)
{
    return (_state >= OS_RUNNING);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::LockRunning, public
//
//  Synopsis:   Method on IRunnableObject.  Locks us in the running state.
//
//  Arguments:  [fLock]             -- TRUE to add a lock, FALSE to release.
//              [fLastUnlockCloses] -- If TRUE, releasing the last lock
//                                     closes us by calling IOleObject::Close
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP
CServer::LockRunning(BOOL fLock, BOOL fLastUnlockCloses)
{
    if (fLock)
    {
        _pUnkOuter->AddRef();

        Assert(_cStrongRefs < 255);
        _cStrongRefs += 1;
    }
    else
    {
        Assert(_cStrongRefs > 0);
        _cStrongRefs -= 1;
        if ((_cStrongRefs == 0) && fLastUnlockCloses)
        {
            Close(OLECLOSE_NOSAVE);
        }
        _pUnkOuter->Release();
    }
    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetContainedObject, public
//
//  Synopsis:   Indicates whether or not we're a contained object.
//
//  Arguments:  [fContained] -- Tells us if we're a contained object.
//
//  Notes:      Since objects based on CServer are always contained, this
//              method is ignored.
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF

STDMETHODIMP
CServer::SetContainedObject(BOOL fContained)
{
    return S_OK;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::AddConnection, public
//
//  Synopsis:   Method on IExternalConnection.  Indicates we have an
//              external connection, which will allow us to clean up
//              properly when all the external connections go away.
//
//  Arguments:  [extconn]  -- Type of connection
//              [reserved] --
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(DWORD)
CServer::AddConnection(DWORD extconn, DWORD reserved)
{
    if (extconn & EXTCONN_STRONG)
    {
        LockRunning(TRUE, FALSE);
        return _cStrongRefs;
    }
    return 0;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CServer::ReleaseConnection, public
//
//  Synopsis:   Method on IExternalConnection. Tells us one of our external
//              connections is going away.  If we have no more external
//              connections, then we close.
//
//  Arguments:  [extconn]            -- Type of connection being released
//              [reserved]           --
//              [fLastReleaseCloses] -- Indicates if we should close or not.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

#ifdef FANCY_CONNECTION_STUFF
STDMETHODIMP_(DWORD)
CServer::ReleaseConnection(DWORD extconn,
                            DWORD reserved,
                            BOOL fLastReleaseCloses)
{
    if (extconn & EXTCONN_STRONG)
    {
        DWORD cStrongRefs = _cStrongRefs;
        LockRunning(FALSE, fLastReleaseCloses);
        return cStrongRefs - 1;
    }
    return 0;
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CServer::QuickActivate, IQuickActivate
//
//  Synopsis:   Connect this object to the container.
//
//              For high performance, functionality in CServer::SetClientSite
//              and other functions is inlined here.  If a derived class
//              overrides CServer::SetClientSite, it will need to override
//              this function as well.
//
//              This function assumes that the class has the following
//              connection points:
//
//                  [0] - Automation events
//                  [1] - Property notifications
//
//  Arguments:  pqacontainer    In, information about the container.
//              pqacontrol      Out, information about this object.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

STDMETHODIMP
CServer::QuickActivate(QACONTAINER *pqacontainer, QACONTROL *pqacontrol)
{
    HRESULT                 hr = S_OK;
    const CLASSDESC *       pcd = ServerDesc();

    if (pqacontainer->cbSize < sizeof(QACONTAINER) ||
        pqacontrol->cbSize < sizeof(QACONTROL))
        RRETURN(E_INVALIDARG);

    // CONSIDER: inline ReplaceInterface here for high speed.
    ReplaceInterface(&_pAdvSink, (IAdviseSink *)pqacontainer->pAdviseSink);
    ReplaceInterface(&_pClientSite, pqacontainer->pClientSite);

#ifndef NO_EDIT
    if (pqacontainer->pUndoMgr)
    {
        ReplaceInterface(&_pUndoMgr, pqacontainer->pUndoMgr);
    }
    else if (ServerDesc()->TestFlag(SERVERDESC_CREATE_UNDOMGR))
    {
        hr = THR(CreateUndoManager());
        if (hr)
            goto Cleanup;
    }
    else
    {
        _pUndoMgr = &g_DummyUndoMgr;
    }
#endif // NO_EDIT

    _fUseAdviseSinkEx = TRUE;
    _fUserMode = (pqacontainer->dwAmbientFlags & QACONTAINER_USERMODE) != 0;


    if (pqacontainer->pPropertyNotifySink)
    {
        hr = THR(ClampITFResult(DoAdvise(
                IID_IPropertyNotifySink,
                DISPID_A_PROPNOTIFYSINK,
                pqacontainer->pPropertyNotifySink,
                NULL,
                &pqacontrol->dwPropNotifyCookie)));
        if (hr)
            goto Cleanup;
    }

    pqacontrol->dwMiscStatus = pcd->_dwMiscStatus;
    pqacontrol->dwViewStatus = pcd->_dwViewStatus;
    GetActivationPolicy(&pqacontrol->dwPointerActivationPolicy);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     CServer::SetContentExtent, IQuickActivate
//
//  Synopsis:   Set the extent of the object.
//
//  Arguments:  lpsizel     The extent in himetric
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::SetContentExtent(LPSIZEL lpsizel)
{
    RRETURN(THR(SetExtent(DVASPECT_CONTENT, lpsizel)));
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::GetContentExtent, IQuickActivate
//
//  Synopsis:   Get the extent of the object.
//
//  Arguments:  lpsizel     The extent in himetric.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetContentExtent(LPSIZEL lpsizel)
{
    RRETURN(THR(GetExtent(DVASPECT_CONTENT, lpsizel)));
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientBool
//
//  Synopsis:   Helper method to get an ambient property of type BOOL.
//              The caller passes in a default value that is returned if
//              the property isn't present on the site, or if no
//              site is present.
//
//  Arguments:  [dispid]        --  property to get
//              [fDefaultValue] --  default value to use if property
//                                  not present
//
//  Returns:    BOOL
//
//-------------------------------------------------------------------------

BOOL
CServer::GetAmbientBool(DISPID dispid, BOOL fDefaultValue)
{
    HRESULT     hr;
    CVariant    var;
    BOOL        f = fDefaultValue;

    hr = GetAmbientVariant(dispid, &var);
    if (!hr && (var.vt == VT_BOOL))
    {
        f = (var.boolVal != 0);
    }

    return f;
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientBstr
//
//  Synopsis:   Helper method to get an ambient property of type BSTR.
//
//  Arguments:  [dispid]        --  property to get
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetAmbientBstr(DISPID dispid, BSTR *pbstr)
{
    HRESULT     hr;
    CVariant    var;

    *pbstr = NULL;

    hr = GetAmbientVariant(dispid, &var);
    if (!hr)
    {
        if (var.vt == VT_BSTR)
        {
            *pbstr = var.bstrVal;
            VariantInit(&var);
        }
        else
            hr = DISP_E_MEMBERNOTFOUND;
    }

    return hr;
}

HPALETTE
CServer::GetAmbientPalette()
{
    CVariant var;
    HRESULT hr = GetAmbientVariant(DISPID_AMBIENT_PALETTE, &var);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_HANDLE)
        {
            Assert(!var.byref || GetObjectType((HGDIOBJ)var.byref) == OBJ_PAL);

            if (!var.byref || GetObjectType((HGDIOBJ)var.byref) != OBJ_PAL)
                return NULL;
                
            return (HPALETTE)var.byref;
        }
    }

    return NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::GetAmbientPropOfType
//
//  Synopsis:   Helper method to get an ambient property of arbitrary
//              type.  Used as GetDispPropOfType.
//
//  Arguments:  [dispid]    --  Property to get
//              [vt]        --  Type of property
//              [pv]        --  Pointer to c data type that receives
//                              the value
//
//  Returns:    HRESULT.  Returns DISP_E_MEMBERNOTFOUND if no client
//              site has been set.
//
//-------------------------------------------------------------------------

HRESULT
CServer::GetAmbientVariant(
        DISPID dispid,
        VARIANT * pvar)
{
    HRESULT     hr;
    IDispatch * pDisp = NULL;

    if (!_pClientSite)
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);

    hr = THR_NOTRACE(_pClientSite->QueryInterface(
            IID_IDispatch,
            (LPVOID*) &pDisp));
    if (hr)
        RRETURN_NOTRACE(DISP_E_MEMBERNOTFOUND);

    Assert(pDisp);

    hr = THR_NOTRACE(GetDispProp(
                        pDisp,
                        dispid,
                        g_lcidUserDefault,
                        pvar));

    pDisp->Release();

    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetCanUndo
//
//  Synopsis:   Helper to determine whether an undo operation is available.
//
//--------------------------------------------------------------------------

#ifndef NO_EDIT
HRESULT
CServer::GetCanUndo(VARIANT_BOOL * pfCanUndo)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    if (!pfCanUndo)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR_NOTRACE(_pUndoMgr->GetLastUndoDescription(&bstr));
    FormsFreeString(bstr);

    *pfCanUndo = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetCanRedo
//
//  Synopsis:   Helper to determine whether a redo operation is available.
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetCanRedo(VARIANT_BOOL * pfCanRedo)
{
    HRESULT     hr;
    BSTR        bstr = NULL;

    if (!pfCanRedo)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR_NOTRACE(_pUndoMgr->GetLastRedoDescription(&bstr));
    FormsFreeString(bstr);

    *pfCanRedo = (hr == S_OK) ? VB_TRUE : VB_FALSE;

    return S_OK;
}
#endif // NO_EDIT

//+-------------------------------------------------------------------------
//
//  Method:     CServer::RequestUIActivate
//
//  Synopsis:   Ask site if it's ok to UI activate.
//
//--------------------------------------------------------------------------

BOOL
CServer::RequestUIActivate()
{
    Assert(State() >= OS_INPLACE);

    if (State() < OS_UIACTIVE &&
        _pInPlace->_fUseExtendedSite)
    {
        if (((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->RequestUIActivate() == S_OK)
            return TRUE;

        // Per spec call OnUIDeactivate.
        // Bug 7243: during the request the host could fire eventcode that will change
        // our current state (like making us invisible). That would invalidate the _pInplace
        // pointer
        if (_pInPlace)
        {
            IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CServer::RequestFocusFromServer
//
//  Synopsis:   Ask site if it's ok to call SetFocus.  This is just a copy
//  of RequestUIActivate function above.  The only difference being that we
//  don't check the UI state in this function.  We're checking to see if we
//  can take focus, rather than asking for UI activation.  This fixes a focus
//  bug Mars.
//
//--------------------------------------------------------------------------

BOOL
CServer::RequestFocusFromServer()
{
    Assert(State() >= OS_INPLACE);

    if (_pInPlace->_fUseExtendedSite)
    {
        if (((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->RequestUIActivate() == S_OK)
            return TRUE;

        // Per spec call OnUIDeactivate.
        // Bug 7243: during the request the host could fire eventcode that will change
        // our current state (like making us invisible). That would invalidate the _pInplace
        // pointer
        if (_pInPlace)
        {
            IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));
        }
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetFocus, public
//
//  Synopsis:   Set the focus to this server.
//
//----------------------------------------------------------------------------

HRESULT
CServer::SetFocus(BOOL fFocus)
{
    HRESULT           hr = S_OK;

    Assert(_pInPlace);
    Assert(State() >= OS_INPLACE);

    if (State() < OS_INPLACE)
    {
        Assert(!fFocus);
        goto Cleanup;
    }

    if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->SetFocus(fFocus));
    }
    else
    {
        Assert(_pInPlace->_hwnd);
        if (fFocus)
        {
            // Capture the focus.
            ::SetFocus(_pInPlace->_hwnd);
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetFocus, public
//
//  Synopsis:   Determines whether the client site has focus
//
//----------------------------------------------------------------------------

BOOL
CServer::GetFocus()
{
    if (_pInPlace->_fWindowlessInplace)
        return (((IOleInPlaceSiteWindowless *) (_pInPlace->_pInPlaceSite))->GetFocus() == S_OK);
    else
        return (_pInPlace->_hwnd == ::GetFocus());
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetCapture, public
//
//  Synopsis:   Find out if we have captured the mouse.
//
//----------------------------------------------------------------------------

BOOL
CServer::GetCapture()
{
    Assert(_pInPlace);
    Assert(State() >= OS_INPLACE);

    if (_pInPlace->_fWindowlessInplace)
    {
        return ((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->GetCapture() == S_OK;
    }
    else
    {
        if (_pInPlace->_hwnd)
        {
            return ::GetCapture() == _pInPlace->_hwnd;
        }
        else
        {            
            return FALSE;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SetCapture, public
//
//  Synopsis:   fCaptured --> Capture the mouse to this server
//              !fCaptured --> This server will not have the capture.
//
//----------------------------------------------------------------------------

HRESULT
CServer::SetCapture(BOOL fCaptured)
{
    HRESULT hr = S_OK;

    if (State() < OS_INPLACE)
    {
        Assert(!fCaptured);
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)
                (_pInPlace->_pInPlaceSite))->SetCapture(fCaptured));
    }
    else
    {
        Assert(_pInPlace->_hwnd || !fCaptured);
        if (fCaptured)
        {
             // Capture the focus.
            ::SetCapture(_pInPlace->_hwnd);
        }
        else if (::GetCapture() == _pInPlace->_hwnd)
        {
            // Release capture if we have it.
#if DBG==1
            Assert(!TLS(fHandleCaptureChanged));
#endif //DBG==1
            ::ReleaseCapture();
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetActivationPolicy
//
//  Synopsis:   Member of IPointerInactive.  Returns bits indicating whether
//              this server should be automatically activated when the
//              mouse passes over it, and deactivated when no longer over.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetActivationPolicy(DWORD * pdwPolicy)
{
    *pdwPolicy = 0;

    if (ServerDesc()->TestFlag(SERVERDESC_ACTIVATEONENTRY))
    {
        *pdwPolicy |= POINTERINACTIVE_ACTIVATEONENTRY;
    }

    if (ServerDesc()->TestFlag(SERVERDESC_DEACTIVATEONLEAVE))
    {
        *pdwPolicy |= POINTERINACTIVE_DEACTIVATEONLEAVE;
    }

    if (ServerDesc()->TestFlag(SERVERDESC_ACTIVATEONDRAG))
    {
        *pdwPolicy |= POINTERINACTIVE_ACTIVATEONDRAG;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::OnInactiveSetCursor
//
//  Synopsis:   Member of IPointerInactive.  Allows the server to set the
//              cursor without requiring activation.
//              Coordinates are in window device units.
//
//  Returns:    S_OK if cursor set.
//              S_FALSE if _mousepointer == fmMousePointerDefault (and does not
//                  set the cursor.)
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::OnInactiveSetCursor(LPCRECT pRectBounds,
                             long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
{
    HRESULT hr;

    hr = SetCursor();

    // if cursor not set yet and required to set something,
    // set standard arrow cursor
    if(fSetAlways && hr == S_FALSE)
    {
        SetCursorIDC(IDC_ARROW);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetCursor
//
//  Synopsis:   Helper function that sets the cursor according to the
//              MousePointer and MouseIcon properties of the CServer.
//
//  Returns:    S_OK if cursor set.
//              S_FALSE if _mousepointer == fmMousePointerDefault (and does not
//                  set the cursor.)
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetCursor()
{
       return S_FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::OnInactiveMouseMove
//
//  Synopsis:   Member of IPointerInactive.  Allows the server to fire
//              mouse move events without going inplace active.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::OnInactiveMouseMove(LPCRECT prc, long x, long y, DWORD grfKeyState)
{
    /*
    POINTL          ptl;
    POINTF          ptf;

    if (ServerDesc()->_sef & SEF_MOUSEMOVE)
    {
        // Convert to document coordinates
        ptl.x = MulDivQuick(x - prc->left, _sizel.cx, prc->right - prc->left);
        ptl.y = MulDivQuick(y -  prc->top, _sizel.cy, prc->bottom -  prc->top);

        UserFromDocument(&ptf, ptl.x, ptl.y);
        IGNORE_HR(FireStdControlEvent_MouseMove(
                VBButtonState((short)grfKeyState),
                VBShiftState(),
                ptf.x,
                ptf.y));
    }
    */
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetEnabled
//
//  Synopsis:   Helper method.  Many objects will simply override this.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = VB_TRUE;
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Method:     CServer::QueryService, CServer
//
//  Synopsis:   Get service from the inplace or client site.
//
//  Arguments:  guidService     id of service
//              iid             id of interface on service
//              ppv             the service
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryService(REFGUID guidService, REFIID iid, void **ppv)
{
    IUnknown *  apUnk[2];
    IUnknown ** ppUnk;
    int         cUnk = 0;
    HRESULT     hr = E_FAIL;            // Assume failure.

    *ppv = NULL;

    //
    // If were are in a doc object and we're inplace (or above), then
    // first see if the service is supported by the InPlaceSite.
    //
    
    if (_fMsoDocMode && _pInPlace && _pInPlace->_pInPlaceSite)
    {
        apUnk[cUnk++] = _pInPlace->_pInPlaceSite;
    }

    // If we have a client site, check it next.
    if (_pClientSite)
    {
        apUnk[cUnk++] = _pClientSite;
    }

    // Now perform the checks.
    ppUnk = apUnk;
    for (cUnk--; cUnk >= 0; cUnk--, ppUnk++)
    {
        IServiceProvider *  pSP;

        hr = THR_NOTRACE((*ppUnk)->QueryInterface(
                IID_IServiceProvider,
                (void **)&pSP));
        if (!hr)
        {
            hr = THR_NOTRACE(pSP->QueryService(guidService, iid, ppv));
            pSP->Release();
            if (!hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::CLock
//
//  Synopsis:   Lock resources in CServer object.
//
//-------------------------------------------------------------------------

CServer::CLock::CLock(CServer *pServer, WORD wLockFlags)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pServer = pServer;
    _wLockFlags = pServer->_wLockFlags;
    pServer->_wLockFlags |= wLockFlags | SERVERLOCK_STABILIZED;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pServer->_pUnkOuter->AddRef();
        pServer->PrivateAddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

CServer::CLock::CLock(CServer *pServer)
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    _pServer = pServer;
    _wLockFlags = pServer->_wLockFlags;
    pServer->_wLockFlags |= SERVERLOCK_STABILIZED;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        pServer->_pUnkOuter->AddRef();

        pServer->PrivateAddRef();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::CLock::~CLock
//
//  Synopsis:   Unlock resources in CServer object.
//
//-------------------------------------------------------------------------

CServer::CLock::~CLock()
{
#if DBG==1
    extern BOOL g_fDisableBaseTrace;
    g_fDisableBaseTrace = TRUE;
#endif

    // _pServer refcount can go down to zero and then the
    // statement : delete this will be executed. After that
    // _pUnkOuter has no valid value any longer and
    // _pServer->_pUnkOuter->Release() can cause a GPF.
    // Therefore we save the value of _pUnkOuter in a local
    // variable maintaining the original release order.
    // The GPF can be reproduce in VBAPP by putting the
    // Unload Me statement into the UserForm1_Layout event
    // procedure

    IUnknown *  pUnkOuter = _pServer->_pUnkOuter;

    _pServer->_wLockFlags = _wLockFlags;

#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pServer->PrivateRelease();
        pUnkOuter->Release();
    }
    
#if DBG==1
    g_fDisableBaseTrace = FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\sdv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//   File:       sdv.cxx
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_H_
#define X_MACCONTROLS_H_
#include "maccontrols.h"
#endif
#endif

//  TODO make this string shorter!

const OLECHAR szContents[] = OLESTR("contents");

#if !defined(WINCE)
/*
 * CreateDCFromTargetDev()
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
HDC
CreateDCFromTargetDev(DVTARGETDEVICE FAR* ptd)
{
    HDC hdc=NULL;
    LPDEVNAMES lpDevNames;
    LPDEVMODE lpDevMode;
    LPTSTR lpszDriverName;
    LPTSTR lpszDeviceName;
    LPTSTR lpszPortName;

    if (ptd == NULL)
    {
        hdc = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        goto errReturn;
    }

    lpDevNames = (LPDEVNAMES) ptd; // offset for size field

    if (ptd->tdExtDevmodeOffset == 0)
        lpDevMode = NULL;
    else
        lpDevMode = (LPDEVMODE) ((LPTSTR)ptd + ptd->tdExtDevmodeOffset);

    lpszDriverName = (LPTSTR) lpDevNames + ptd->tdDriverNameOffset;
    lpszDeviceName = (LPTSTR) lpDevNames + ptd->tdDeviceNameOffset;
    lpszPortName   = (LPTSTR) lpDevNames + ptd->tdPortNameOffset;

    hdc = CreateDC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);

errReturn:
    return hdc;
}
#endif // !WINCE


//+---------------------------------------------------------------
//
//  Member:     CServer::SendOnDataChange
//
//  Synopsis:   Send data change notification to advise sinks.
//
//---------------------------------------------------------------
void
CServer::SendOnDataChange(DWORD_PTR dwAdvf)
{
    HRESULT         hr;
    IDataObject *   pDO;

    if (_pDataAdviseHolder)
    {
        hr = PrivateQueryInterface(IID_IDataObject, (void **)&pDO);
        if (OK(hr))
        {
            _pDataAdviseHolder->SendOnDataChange(pDO, 0, (DWORD)dwAdvf);
            pDO->Release();
        }
    }

    _fDataChangePosted = FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::OnDataChange, public
//
//  Synopsis:   Raises data and view changed to all registered 
//              advises
//
//  Notes:      This function should be called whenever the native
//              data of the object is modified.
//
//---------------------------------------------------------------

void
CServer::OnDataChange(BOOL fInvalidateView )
{
    if(fInvalidateView)
        OnViewChange(DVASPECT_CONTENT);

    if (_pDataAdviseHolder && !_fDataChangePosted && !IsPassivating() && !IsPassivated())
    {
        HRESULT hr = GWPostMethodCall(this, ONCALL_METHOD(CServer, SendOnDataChange, sendondatachange), 0, FALSE, "CServer::SendOnDataChange");
        if (!hr)
            _fDataChangePosted = TRUE;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnPropertyChange
//
//  Synopsis:   Fires property change event, and then OnDataChange
//
//  Arguments:  [dispidProperty] -- PROPID of property that changed
//              [dwFlags]        -- Flags to inhibit behavior
//
//  Notes:      The [dwFlags] parameter has the following values that can be
//              OR'd together:
//
//              SERVERCHNG_NOPROPCHANGE -- Inhibits the OnChanged notification
//                 through the PropNotifySink.
//              SERVERCHNG_NOVIEWCHANGE -- Inhibits the OnViewChange notification.
//              SERVERCHNG_NODATACHANGE -- Inhibits the OnDataChange notification.
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnPropertyChange(
        DISPID dispidProperty,
        DWORD  dwFlags,
        const PROPERTYDESC *ppropdesc)
{

    if (TestLock(SERVERLOCK_PROPNOTIFY) || _state < OS_LOADED)
        return S_OK;

    _lDirtyVersion = MAXLONG;

    if (!(dwFlags & SERVERCHNG_NOPROPCHANGE))
    {
        IGNORE_HR(FireOnChanged(dispidProperty));
    }

    if (!(dwFlags & SERVERCHNG_NODATACHANGE))
    {
        SendOnDataChange(0);
    }

    if (!(dwFlags & SERVERCHNG_NOVIEWCHANGE))
    {
        OnViewChange(DVASPECT_CONTENT);
    }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::GetMonikerDisplayName, public
//
//  Synopsis:   Returns the display name from the object's moniker
//
//  Notes:      The display name of the object is used in for dispensing
//              the Object Descriptor clipboard format.  The caller must
//              free the string returned using TaskFreeString.
//
//---------------------------------------------------------------

LPTSTR
CServer::GetMonikerDisplayName(DWORD dwAssign)
{
    //  Default dwAssign is OLEGETMONIKER_ONLYIFTHERE

    LPMONIKER pmk;
    LPTSTR    lpstrDisplayName = NULL;

    if (OK(GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, &pmk)))
    {
        ::GetMonikerDisplayName(pmk, &lpstrDisplayName);
        pmk->Release();
    }

    return lpstrDisplayName;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetEMBEDDEDOBJECT, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Embedded Object clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetEMBEDDEDOBJECT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT     hr = E_FAIL;

#if !defined(WINCE)
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTORAGE;
        pmedium->pUnkForRelease = NULL;

        hr = THR(StgCreateDocfile(
                NULL,
                STGM_DFRALL | STGM_CREATE | STGM_DELETEONRELEASE,
                0,
                &pmedium->pstg));
        if (hr)
            goto Error;
    }

    hr = THR(WriteClassStg(pmedium->pstg, *pServer->BaseDesc()->_pclsid));
    if (hr)
        goto Error;

    hr = THR(pServer->Save(pmedium->pstg, FALSE));
    if (hr)
        goto Error;

    hr = THR(pServer->SaveCompleted((IStorage *) NULL));
    if (!hr)
    {
        IGNORE_HR(pmedium->pstg->Commit(STGC_DEFAULT));
    }


Error:
    //  If we failed somehow and yet created a docfile, then we will
    //      release the docfile to delete it

    if (hr && !fHere)
        ClearInterface(&pmedium->pstg);
#endif // !WINCE

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetMETAFILEPICT, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Metafilepict clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetMETAFILEPICT(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
#if defined(WINCE)
    RRETURN(E_FAIL);
#else
    HRESULT         hr      = S_OK;
    RECTL           rcl;
    HMETAFILE       hmf     = NULL;
    HDC             hdc;
    LPMETAFILEPICT  pPict;
#ifdef _MAC
    UINT        dwFlags = GMEM_SHARE | GMEM_MOVEABLE;
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    UINT        dwFlags = GMEM_SHARE;
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif



    if (!fHere)
    {
        //  Fill in the pmedium structure

        pmedium->tymed = TYMED_MFPICT;
        pmedium->pUnkForRelease = NULL;
        *phdl = GlobalAlloc(dwFlags, sizeof(METAFILEPICT));

        if (*phdl == NULL)
            goto MemoryError;
#ifdef _MAC
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            goto MemoryError;
        }
#  if DBG == 1
        else
        {
            // the wlm HANDLE is no more...
            hdl = NULL;
        }
#  endif
#endif
    }

    rcl.left = rcl.top = 0;
    hr = THR(pServer->GetExtent(
            pformatetc->dwAspect,
            pformatetc->lindex,
            pformatetc->ptd,
            (SIZEL *)&rcl.right));
    if (hr)
        goto Error;

    hdc = CreateMetaFileA(NULL);
    if (!hdc)
        goto MemoryError;

    rcl.right = HPixFromHimetric(rcl.right);
    rcl.bottom = VPixFromHimetric(rcl.bottom);

    SetMapMode(hdc, MM_ANISOTROPIC);
    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, rcl.right, rcl.bottom, NULL);

    hr = THR(pServer->Draw(pformatetc->dwAspect,
            pformatetc->lindex,
            NULL,
            pformatetc->ptd,
            NULL,
            hdc,
            &rcl,
            &rcl,
            NULL,
            0));

    hmf = CloseMetaFile(hdc);

    if (hmf == NULL)
        goto MemoryError;

    if (hr)
        goto Error;

#ifdef _MAC
    if(!WrapHandle((Handle)pmedium->hGlobal,phdl,FALSE,dwFlags))
    {
        goto MemoryError;
    }
#endif
    pPict = (LPMETAFILEPICT) GlobalLock(*phdl);
    if (pPict == NULL)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // fill in the object descriptor

    pPict->mm   =  MM_ANISOTROPIC;
    pPict->hMF  =  hmf;
    //
    // The following two values MUST BE in HIMETRIC, as long as the mapping
    // mode is MM_ANISOTROPIC.
    //
    pPict->xExt = HimetricFromHPix(rcl.right);
    pPict->yExt = HimetricFromVPix(rcl.bottom);

    GlobalUnlock(*phdl);

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (!fHere && *phdl)
        GlobalFree(*phdl);

    if (hmf)
        DeleteMetaFile(hmf);

    goto Cleanup;
#endif //WINCE
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetENHMETAFILE, static
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the enhanced metafile clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetENHMETAFILE(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
#if defined(WINCE)
    RRETURN(E_FAIL);
#else
    HRESULT         hr      = S_OK;
    RECTL           rcl;
    HDC             hdc;
    HDC             hdcRef = CreateDCFromTargetDev(pformatetc->ptd);
    if (!hdcRef)
        goto MemoryError;

    pmedium->tymed = TYMED_ENHMF;
    pmedium->pUnkForRelease = NULL;
    pmedium->hEnhMetaFile = NULL;

    rcl.left = rcl.top = 0;
    hr = THR(pServer->GetExtent(
            pformatetc->dwAspect,
            pformatetc->lindex,
            pformatetc->ptd,
            (SIZEL *)&rcl.right));
    if (hr)
        goto Error;

    hdc = CreateEnhMetaFileA(
            hdcRef,
            NULL,
            (RECT *)&rcl,
            NULL);
    if (!hdc)
        goto MemoryError;

    rcl.right = MulDivQuick(rcl.right,
            GetDeviceCaps(hdcRef, HORZRES),
            100 * GetDeviceCaps(hdcRef, HORZSIZE));
    rcl.bottom = MulDivQuick(rcl.bottom,
            GetDeviceCaps(hdcRef, VERTRES),
            100 * GetDeviceCaps(hdcRef, VERTSIZE));

    hr = THR(pServer->Draw(pformatetc->dwAspect,
            pformatetc->lindex,
            NULL,
            pformatetc->ptd,
            NULL,
            hdc,
            &rcl,
            &rcl,
            NULL,
            0));

    pmedium->hEnhMetaFile = CloseEnhMetaFile(hdc);

    if (pmedium->hEnhMetaFile == NULL)
        goto MemoryError;

    if (hr)
        goto Error;

Cleanup:
    if (hdcRef)
        DeleteDC(hdcRef);
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (pmedium->hEnhMetaFile)
        DeleteEnhMetaFile(pmedium->hEnhMetaFile);

    goto Cleanup;
#endif // WINCE
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetOBJECTDESCRIPTOR, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Object Descriptor clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetOBJECTDESCRIPTOR(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT             hr                  = S_OK;
    LPTSTR              lpstrDisplay        = NULL;
    size_t              cch;
    size_t              cbSize;
    size_t              cbUserTypeFull;
    size_t              cbDisplay;
    LPOBJECTDESCRIPTOR  pObjDesc;
    TCHAR               achUserTypeFull[MAX_USERTYPE_LEN + 1];
#ifdef _MAC
    UINT        dwFlags = GMEM_SHARE | GMEM_MOVEABLE;
    HANDLE      hdl;
    HANDLE  *   phdl = &hdl;
#else
    UINT        dwFlags = GMEM_SHARE;
    HANDLE  *   phdl = &pmedium->hGlobal;
#endif



    //  REVIEW This is not the best display name for the OBJECTDESCRIPTOR
    //    It would be more useful to see the Class name...

    lpstrDisplay = pServer->GetMonikerDisplayName(OLEGETMONIKER_ONLYIFTHERE);



    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPEFULL(pServer->BaseDesc()->_idrBase),
            achUserTypeFull,
            ARRAY_SIZE(achUserTypeFull)));

    // Compute the size of the descriptor.

    Assert(_tcsclen(achUserTypeFull));

    cbUserTypeFull = (_tcsclen(achUserTypeFull) + 1) * sizeof(TCHAR);

    cbDisplay = 0;
    if (lpstrDisplay != NULL)
    {
        cch = _tcsclen(lpstrDisplay);
        if (cch)
            cbDisplay = (cch + 1) * sizeof(TCHAR);
    }

    cbSize = sizeof(OBJECTDESCRIPTOR) + cbUserTypeFull + cbDisplay;

    if (!fHere)
    {
        // fill in the pmedium structure

        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->pUnkForRelease = NULL;
        *phdl = GlobalAlloc(dwFlags, cbSize);
        if (*phdl == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
#ifdef _MAC
        if(!UnwrapHandle(*phdl,(Handle*)&pmedium->hGlobal))
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }
    if(!WrapHandle( (Handle)pmedium->hGlobal, phdl,FALSE,dwFlags))
    {
        hr = E_HANDLE;
        goto Error;
#endif
    }

    pObjDesc = (LPOBJECTDESCRIPTOR) GlobalLock(*phdl);
    if (!pObjDesc)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // fill in the object descriptor

    pObjDesc->cbSize = cbSize;
    pObjDesc->clsid = *pServer->BaseDesc()->_pclsid;
    pObjDesc->dwDrawAspect = DVASPECT_CONTENT;
    pObjDesc->dwStatus = pServer->ServerDesc()->_dwMiscStatus;

#ifdef _MAC
    pObjDesc->sizel.cx = HPixFromHimetric(pServer->_sizel.cx);
    pObjDesc->sizel.cy = VPixFromHimetric(pServer->_sizel.cy);
#else
    pObjDesc->sizel = pServer->_sizel;
#endif
    pObjDesc->pointl.y = pObjDesc->pointl.x = 0;

    pObjDesc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
    memcpy(pObjDesc + 1, achUserTypeFull, cbUserTypeFull);

    if (lpstrDisplay == NULL)
    {
        pObjDesc->dwSrcOfCopy = 0;
    }
    else
    {
        pObjDesc->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR) + cbUserTypeFull;
        memcpy(
                ((BYTE *) pObjDesc) + pObjDesc->dwSrcOfCopy,
                lpstrDisplay,
                cbDisplay);
    }

    GlobalUnlock(*phdl);

Cleanup:
    TaskFreeString(lpstrDisplay);
    RRETURN(hr);

Error:
    if (!fHere && *phdl)
    {
        GlobalFree(*phdl);
        pmedium->hGlobal = NULL;
    }
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetLINKSOURCE, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Link Source clipboard format
//
//  Arguments:  [pServer] -- pointer to a CServer object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This method uses the moniker cached by the data/view
//              object.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
CServer::GetLINKSOURCE(
        CServer * pServer,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT     hr;
    LPMONIKER   pmk = NULL;
    CLSID       clsid;

    if (!fHere)
    {
        // fill in the pmedium structure

        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pUnkForRelease = NULL;
        hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm));
        if (hr)
            goto Error;
    }

    hr = THR(pServer->GetMoniker(
            OLEGETMONIKER_ONLYIFTHERE,
            OLEWHICHMK_OBJFULL,
            &pmk));
    if (hr)
        goto Error;

    hr = THR(pmk->GetClassID(&clsid));
    if (hr)
        goto Error;

    hr = THR(WriteClassStm(pmedium->pstm, clsid));
    if (hr)
        goto Error;

    hr = THR(pmk->Save(pmedium->pstm, FALSE));
    if (hr)
        goto Error;

Cleanup:
    ReleaseInterface(pmk);

    RRETURN(hr);

Error:
    if (!fHere && pmedium->pstm)
        ClearInterface(&pmedium->pstm);

    goto Cleanup;
}


//+--------------------------------------------------------------
//
//  Member:     CServer::GetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT         hr;
    int             i;

    if (pformatetc == NULL || pmedium == NULL)
        RRETURN(E_INVALIDARG);

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        LPDATAOBJECT    pDO;
        //
        // For the icon aspect, check the cache first.
        //
        if (pformatetc->dwAspect == DVASPECT_ICON && _pCache)
        {
            hr = THR(_pCache->QueryInterface(
                    IID_IDataObject,
                    (LPVOID *) &pDO));
            if (!hr)
            {
                hr = THR(pDO->GetData(pformatetc, pmedium));
                pDO->Release();

                if (!hr)
                    RRETURN(hr);
            }
        }
        hr = THR((*ServerDesc()->_pGetFuncs[i]) (this, pformatetc, pmedium, FALSE));
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetDataHere, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT         hr;
    int             i;

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        LPDATAOBJECT    pDO;
        //
        // For the icon aspect, check the cache first.
        //
        if ((pformatetc->dwAspect == DVASPECT_ICON) && _pCache)
        {
            hr = THR(_pCache->QueryInterface(IID_IDataObject, (LPVOID *) &pDO));
            if (!hr)
            {
                hr = THR(pDO->GetDataHere(pformatetc, pmedium));
                pDO->Release();

                if (!hr)
                    RRETURN(hr);
            }
        }
        hr = THR((*ServerDesc()->_pGetFuncs[i]) (this, pformatetc, pmedium, TRUE));
    }

    RRETURN1(hr, S_FALSE);
}




//+---------------------------------------------------------------
//
//  Member:     CServer::QueryGetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  The return value indicates
//              whether or not a compatible format was found.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::QueryGetData(LPFORMATETC pformatetc)
{
    int     i;

    i = FindCompatibleFormat(
            ServerDesc()->_pGetFmtTable,
            ServerDesc()->_cGetFmtTable,
            *pformatetc);

    RRETURN((i >= 0) ? S_OK : DV_E_FORMATETC);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetCanonicalFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method returns DATA_S_SAMEFORMATETC assuming
//              that each format the server dispenses is its own
//              canonical format.  If this is not the case then this
//              method should be overridden.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetCanonicalFormatEtc(
        LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Set format table
//              for a compatible format.  If one is found it calls
//              the corresponding Set function.
//
//---------------------------------------------------------------
STDMETHODIMP
CServer::SetData(
        LPFORMATETC pformatetc,
        STGMEDIUM FAR *pmedium,
        BOOL fRelease)
{
    HRESULT hr;
    int     i;

    if (!pformatetc || !pmedium)
        RRETURN(E_INVALIDARG);

    i = FindCompatibleFormat(
            ServerDesc()->_pSetFmtTable,
            ServerDesc()->_cSetFmtTable,
            *pformatetc);

    if (i < 0)
    {
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = THR((*ServerDesc()->_pSetFuncs[i])(this, pformatetc, pmedium));
    }

    if (fRelease)
        ReleaseStgMedium(pmedium);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method creates an enumerator over the Get or
//              Set format tables depending on the value of the
//              dwDirection argument.
//
//              TODO -- This method is incorrect because it ends
//              up enumerating formatetc's with more than one
//              DVASPECT flag set in the dwAspect member at a time.
//              This is illegal.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumFormatEtc(
        DWORD dwDirection,
        LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    HRESULT     hr;

    if (!ppenumFormatEtc)
        RRETURN(E_INVALIDARG);

    *ppenumFormatEtc = NULL;            // set out params to NULL

    //  Create an enumerator over our static format table.

    switch (dwDirection)
    {
    case DATADIR_GET:
        hr = THR(CreateFORMATETCEnum(
                ServerDesc()->_pGetFmtTable,
                ServerDesc()->_cGetFmtTable,
                ppenumFormatEtc));
        break;

    case DATADIR_SET:
        hr = THR(CreateFORMATETCEnum(
                ServerDesc()->_pSetFmtTable,
                ServerDesc()->_cSetFmtTable,
                ppenumFormatEtc));
        break;

    default:
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DAdvise(
        FORMATETC FAR* pFormatetc,
        DWORD advf,
        LPADVISESINK pAdvSink,
        DWORD FAR* pdwConnection)
{
    HRESULT         hr;
    IDataObject *   pDO;
    int             i;

    if (pdwConnection == NULL)
        RRETURN(E_INVALIDARG);

    *pdwConnection = NULL;              // set out params to NULL

    //
    //  Make sure we support the requested format if
    //  no request for data is pending.
    //

    if ((advf & ADVF_NODATA) == 0)
    {
        i = FindCompatibleFormat(
                ServerDesc()->_pGetFmtTable,
                ServerDesc()->_cGetFmtTable,
                *pFormatetc);

        if (i < 0)
            RRETURN(DATA_E_FORMATETC);
    }

    if (_pDataAdviseHolder == NULL)
    {
        hr = THR(CreateDataAdviseHolder(&_pDataAdviseHolder));
        if (hr)
            goto Cleanup;
    }

    hr = PrivateQueryInterface(IID_IDataObject, (void **)&pDO);
    if (hr)
        goto Cleanup;

    hr = THR(_pDataAdviseHolder->Advise(
            pDO,
            pFormatetc,
            advf,
            pAdvSink,
            pdwConnection));

    pDO->Release();

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DUnadvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::DUnadvise(DWORD dwConnection)
{
    HRESULT     hr;

    if (!_pDataAdviseHolder)
        RRETURN(OLE_E_NOCONNECTION);

    hr = THR(_pDataAdviseHolder->Unadvise(dwConnection));

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::EnumDAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::EnumDAdvise (LPENUMSTATDATA FAR* ppenumAdvise)
{
    HRESULT     hr;

    if (!ppenumAdvise)
        RRETURN(E_INVALIDARG);

    *ppenumAdvise = NULL;               // set out params to NULL

    if (_pDataAdviseHolder == NULL)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(_pDataAdviseHolder->EnumAdvise(ppenumAdvise));
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::Draw, IViewObject
//
//  Synopsis:   Render object to the DC.
//              Derived classes should override this method to implemnt
//              rendering for DVASPECT_CONTENT.
//
//  Arguments:  Per IViewObjectDraw.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Draw(
        DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hdcTargetDev,
        HDC hdcDraw,
        LPCRECTL prclDraw,
        LPCRECTL prcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    HRESULT     hr;
    CDrawInfo   DI;
    RECT        rc;
    POINT       ptOrg = { 0 };
    SIZE        sizeExt;
    BOOL        fDeleteTargetDev = FALSE;
    
    Assert((prclDraw || _state >= OS_INPLACE) &&
        "violation of prcl==NULL contract");

    Assert(hdcDraw);

    if (dwDrawAspect ==  DVASPECT_ICON)
    {
        hr = E_FAIL;

        //
        //  See if the cache has our icon first before we draw it.
        //
        if (_pViewObjectCache)
        {
            hr = THR(_pViewObjectCache->Draw(
                    dwDrawAspect,
                    lindex,
                    pvAspect,
                    ptd,
                    hdcTargetDev,
                    hdcDraw,
                    prclDraw,
                    prcWBounds,
                    pfnContinue,
                    dwContinue));
        }

// WINCEREVIEW - no support for metafiles or different mapping modes in CE
#ifndef WINCE
        if (hr)
        {
            //
            // Get the 'standard' icon
            //
            HGLOBAL hMetaPict = OleGetIconOfClass(*BaseDesc()->_pclsid,
                                                  NULL, TRUE);

            LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);
            if (pMF)
            {
                POINT ptOrg;
                SIZE  sizeExt;

                SetMapMode(hdcDraw, pMF->mm);
                SetViewportOrgEx(hdcDraw, prclDraw->left, prclDraw->top, &ptOrg);
                SetViewportExtEx(hdcDraw,
                                 prclDraw->right - prclDraw->left,
                                 prclDraw->bottom - prclDraw->top,
                                 &sizeExt);

                PlayMetaFile(hdcDraw, pMF->hMF);

                SetViewportOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);
                SetViewportExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);

                GlobalUnlock(hMetaPict);

                DeleteMetaFile(pMF->hMF);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
#endif // WINCE

        RRETURN(hr);
    }

    if (prclDraw &&
        ( (_sizel.cx == 0 && prclDraw->right - prclDraw->left != 0) ||
          (_sizel.cy == 0 && prclDraw->bottom - prclDraw->top != 0) ) )
    {
        Assert(0 && "Host error: Infinite scale factor.");
        RRETURN(E_FAIL);
    }

    // Copy rectangle because we scribble on it.

    rc = *(prclDraw ? (RECT*)prclDraw : (RECT*)&_pInPlace->_rcPos);

    // Save the DC always

    if (SaveDC(hdcDraw) == 0)
        RRETURN(GetLastWin32Error());

// WINCEREVIEW - no support for metafiles or different mapping modes in CE
//only mapping mode we know in MM_TEXT
#ifndef WINCE
    // Retrieve current window origin
    GetWindowOrgEx(hdcDraw, & ptOrg);
    
    // Ensure that there is a one to one mapping between logial units and
    // device units.

    // If we are drawing into a meta file, then make sure that x and y
    // are going in the right directions.

    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE)
    {
        BOOL    fSwapXExt = rc.left > rc.right;
        BOOL    fSwapYExt = rc.top > rc.bottom;

        if (fSwapXExt || fSwapYExt)
        {
            if (GetWindowExtEx(hdcDraw, &sizeExt) == 0)
                RRETURN(GetLastWin32Error());

            if (fSwapXExt)
            {
                ptOrg.x    = -ptOrg.x;
                sizeExt.cx = -sizeExt.cx;
                rc.left    = -rc.left;
                rc.right   = -rc.right;
            }

            if (fSwapYExt)
            {
                ptOrg.y    = -ptOrg.y;
                sizeExt.cy = -sizeExt.cy;
                rc.top     = -rc.top;
                rc.bottom  = -rc.bottom;
            }

            SetWindowOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);
            SetWindowExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);
        }
    }
    else
    {
        // Convert the rc to the device space, and set of the mapping so that
        // there is a one to one mapping to device.

        // CONSIDER: It may be better performing to place the dc in MM_TEXT
        LPtoDP(hdcDraw, LPPOINT( & rc ), 2);

        GetWindowExtEx(hdcDraw, &sizeExt);
        SetViewportExtEx(hdcDraw, sizeExt.cx, sizeExt.cy, (SIZE *)NULL);
    }
#endif // !WINCE

#ifdef _MAC
	EnsureMacScrollbars(hdcDraw);
#endif

    // According to Doc. We should ignore hdcTargetDev if ptd is NULL.
    // since TextServices requires hdcTargetDev to be NULL if ptd is NULL
    // we better null it here
    //
    // NOTE(SujalP): Our code cannot survive with hdcTargetDev=NULL. It has
    // to reflect some physical device. Hence we make it reflect the ptd
    // passed in. If the ptd too is NULL then we make hdcTargetDev reflect
    // the screen (this is done inside CreateDCFromTargetDev).
    if (   NULL == ptd
        || NULL == hdcTargetDev
       )
    {
        hdcTargetDev = CreateDCFromTargetDev(ptd);
        if (!hdcTargetDev)
            RRETURN(GetLastWin32Error());
        fDeleteTargetDev = TRUE;
    }

    // Set the viewport origin to our starting point, and normalize the
    //  draw rectangle.
    ptOrg.x   += rc.left;
    ptOrg.y   += rc.top;
    rc.left    = rc.top = 0;
    rc.right  -= ptOrg.x;
    rc.bottom -= ptOrg.y;
    SetViewportOrgEx(hdcDraw, ptOrg.x, ptOrg.y, (POINT *)NULL);

    memset(&DI, 0, sizeof(DI));
    DI._dwDrawAspect = dwDrawAspect;
    DI._lindex = lindex;
    DI._pvAspect = pvAspect;
    DI._ptd = ptd;
    DI._hic = XHDC(hdcTargetDev, NULL);
    DI._hdc = XHDC(hdcDraw, NULL);
    DI._prcWBounds = prcWBounds;
    DI._dwContinue = dwContinue;
    DI._pfnContinue = pfnContinue;
    DI._fInplacePaint = prclDraw == NULL;

    /* NOTE (mikhaill) -- following six lines are removed as
       making false impression that scaling is changed here, while
       DI.CDocScaleInfo will be anyway reinitialized in CDoc::Draw().

    SIZE    size, sizeInch;

    size.cx = rc.right - rc.left;
    size.cy = rc.bottom - rc.top;
    sizeInch.cx = GetDeviceCaps(DI._hic, LOGPIXELSX);
    sizeInch.cy = GetDeviceCaps(DI._hic, LOGPIXELSY);

    DI.CDocScaleInfo::Init(size, _sizel, &sizeInch);
    */

    GetPalette(hdcDraw, &DI._fHtPalette);

    // Delegate to the other Draw method, which is overridden by derived
    // classes.

    // Inhibit OnViewChange Calls from Invalidate, as this could potentially
    // cause Draw to be called back
    CLock ViewLock(this, SERVERLOCK_VIEWCHANGE);

    hr = Draw(&DI, &rc);

    RestoreDC(hdcDraw, -1);

    if (fDeleteTargetDev)
    {
        DeleteDC(hdcTargetDev);
    }
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::DrawHighContrastBackground
//
//  Note:       Draws background for controls
//
//----------------------------------------------------------------------------

void
CServer::DrawHighContrastBackground(HDC hdc, const RECT * prc, COLORREF crBack)
{
    COLORREF crOld;

    Assert(g_fHighContrastMode);

    crOld = ::SetBkColor(hdc, crBack);
    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, prc, 0, 0, 0);
    ::SetBkColor(hdc, crOld);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetColorSet, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method returns S_FALSE indicating the server
//              does not support this functionality.  Server's that
//              wish to support it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    if (!ppColorSet)
        RRETURN(E_INVALIDARG);

    *ppColorSet = (LPLOGPALETTE)CoTaskMemAlloc(sizeof(LOGPAL256));
    if (*ppColorSet == NULL)
        return E_OUTOFMEMORY;

    memcpy(*ppColorSet, &g_lpHalftone, sizeof(LOGPAL256));

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetPalette, public
//
//  Synopsis:   Returns the document palette
//
//  Notes:      Returns the document palette.  This implementation is
//              doesn't cache the result from the ambient.
//              it is really expected to be overridden by the derived
//              class.
//
//---------------------------------------------------------------

HPALETTE
CServer::GetPalette(HDC hdc, BOOL *pfHtPal)
{
    CVariant var;
    HPALETTE hpal = GetAmbientPalette();

    if (hpal == NULL)
        hpal = GetDefaultPalette();

    if (hdc && hpal)
    {
        Verify(SelectPalette(hdc, hpal, TRUE));
        RealizePalette(hdc);
    }

    if (pfHtPal)
        *pfHtPal = FALSE;
        
    return hpal;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Freeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method sets flag _fViewFrozen.
//
//              The derived class should pay attention to this flag
//              and not allow any modifications that would change
//              the current rendering.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    if (pdwFreeze == NULL)
        RRETURN(E_INVALIDARG);

    *pdwFreeze = 0; //set out params to NULL

    _fViewFrozen = TRUE;
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Unfreeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method clears the flag _fViewFrozen.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Unfreeze(DWORD dwFreeze)
{
    _fViewFrozen = FALSE;
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SetAdvise, IViewObject
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method implements an advise holder for the view
//              advise.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SetAdvise(DWORD dwAspects, DWORD dwAdvf, LPADVISESINK pAdvSink)
{
    ClearInterface(&_pAdvSink);

    if (!pAdvSink)
        return S_OK;

    if ((dwAspects != DVASPECT_CONTENT) || (dwAdvf != 0))
    {
        _dwAspects = dwAspects;
        _dwAdvf = dwAdvf;
    }

    if (OK(pAdvSink->QueryInterface(IID_IAdviseSinkEx, (void **)&_pAdvSink)))
    {
        _fUseAdviseSinkEx = TRUE;
    }
    else
    {
        _fUseAdviseSinkEx = FALSE;
        _pAdvSink = pAdvSink;
        _pAdvSink->AddRef();
    }

    if (dwAdvf & ADVF_PRIMEFIRST)
        OnViewChange(dwAspects);

    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetAdvise(
        DWORD FAR* pdwAspects,
        DWORD FAR* pdwAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    if (pdwAspects)
        *pdwAspects = _dwAspects;

    if (pdwAdvf)
        *pdwAdvf = _dwAdvf;

    if (ppAdvSink)
    {
        *ppAdvSink = _pAdvSink;

        // COMMFIXLAJOSF : 7694
        if (_pAdvSink)
            _pAdvSink->AddRef();
    }

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetExtent, public
//
//  Synopsis:   Method of IViewObject2
//
//  Arguments:  [dwDrawAspect] -- View aspect of interest
//              [lindex]       -- Always -1
//              [ptd]          -- Target device being used
//              [lpsizel]      -- Place to put object's size
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetExtent(
        DWORD dwDrawAspect,
        LONG lindex,
        DVTARGETDEVICE* ptd,
        LPSIZEL lpsizel)
{
    //
    // Until the cache is in place we'll just forward to IOleObject's
    // implementation of this method.
    //

    RRETURN(GetExtent(dwDrawAspect, lpsizel));
}

void
CServer::SendOnViewChange(DWORD_PTR dwAspects)
{
    if (_pAdvSink && (dwAspects & _dwAspects))
    {
        _pAdvSink->OnViewChange((DWORD)dwAspects, -1);
        if (_dwAdvf & ADVF_ONLYONCE)
            SetAdvise(NULL, 0, 0);
    }

    _fViewChangePosted = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnViewChange
//
//  Synopsis:   Sends an view change notification to registered sinks.
//
//  Arguments:  [dwAspect] -- Aspect of view that changed.
//
//  Returns:    HRESULT.
//
//  History:    4-06-94   adams   Created
//
//----------------------------------------------------------------------------

void
CServer::OnViewChange(DWORD dwAspects)
{
    if (dwAspects == DVASPECT_CONTENT)
    {
        if (_pAdvSink && !_fViewChangePosted && !TestLock(SERVERLOCK_VIEWCHANGE))
        {
            HRESULT hr = GWPostMethodCall(this, ONCALL_METHOD(CServer, SendOnViewChange, sendonviewchange), dwAspects, FALSE, "CServer::SendOnViewChange");
            if (!hr)
                _fViewChangePosted = TRUE;
        }
    }
    else
    {
        SendOnViewChange(dwAspects);
    }
}


//+---------------------------------------------------------------
//
//  Member:     CServer::LoadFromStream, protected
//
//  Synopsis:   Loads the object's persistent state from a stream
//
//  Arguments:  [pStrm] -- stream to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::Load and IPersistFile::Load when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadFromStream(LPSTREAM pStrm)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SaveToStream, protected
//
//  Synopsis:   Saves the object's persistent state to a stream
//
//  Arguments:  [pStrm] -- stream to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::Save and IPersistFile::Save when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::SaveToStream(LPSTREAM pStrm)
{
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetStreamSizeMax, protected
//
//  Synopsis:   Returns the number of bytes required to serialize object
//
//  Notes:      This function is used in the implementation of
//              IPersistStreamInit::GetSizeMax.
//              All objects should override this method.
//
//---------------------------------------------------------------
DWORD
CServer::GetStreamSizeMax(void)
{
    return 0;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::IsDirty, public
//
//  Synopsis:   Method of IPersistStreamInit/Storage/File interface
//
//  Notes:      This method uses the dirty flag, _fDirty.
//              Objects should not set the _fDirty flag directly
//              but instead call the OnDataChange method to set the
//              flag.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::IsDirty(void)
{
    return (_lDirtyVersion ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Load, public
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:      This function uses the LoadFromStream method and
//              transitions the object to the loaded state if the
//              load was successful.
//
//---------------------------------------------------------------
STDMETHODIMP
CServer::Load(LPSTREAM pStrm)
{
    RRETURN(THR(LoadFromStream(pStrm)));
}

//+---------------------------------------------------------------
//
//  Member:     CServer::Save, public
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:      This method uses the SaveToStream method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Save(LPSTREAM pStrm, BOOL fClearDirty)
{
    HRESULT hr;

    if (pStrm == NULL)
    {
        hr = S_FALSE;
        // (hackhack) clear dirty bit if asked
    }
    else if (_state == OS_PASSIVE)
    {
        RRETURN(E_UNEXPECTED);
    }
    else
    {
        hr = THR(SaveToStream(pStrm));
        if (hr)
            goto Cleanup;
    }
    
    if (fClearDirty)
        _lDirtyVersion = 0;

Cleanup:
    
    RRETURN1( hr, S_FALSE );
}



//+---------------------------------------------------------------
//
//  Member:     CServer::GetSizeMax
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    if (pcbSize == NULL)
        RRETURN(E_INVALIDARG);

    ULISet32(*pcbSize, GetStreamSizeMax());
    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member:     CServer::InitNew
//
//  Synopsis:   Method of IPersistStreamInit interface
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CServer::InitNew( )
{
    HRESULT     hr = S_OK;

    // object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);
    Assert(!_pCache);
    _fInitNewed = TRUE;
    _lDirtyVersion = MAXLONG;     // set dirty to true, as per OLE spec (frankman)

    _state = OS_LOADED;

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::LoadFromStorage, protected
//
//  Synopsis:   Loads the object's persistent state from a storage
//
//  Arguments:  [pStg] -- storage to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Load and IPersistFile::Load when
//              the file is a docfile.
//
//              This method opens a stream, "CONTENTS", and uses
//              method LoadFromStream to complete the load.
//              Servers that do more sophisticated loading will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::LoadFromStorage(LPSTORAGE pStg)
{
    HRESULT     hr;
    LPSTREAM    pStrm   = NULL;

    hr = THR(pStg->OpenStream(szContents, NULL, STGM_SRO, 0, &pStrm));
    if (hr)
        goto Cleanup;

    hr = THR(LoadFromStream(pStrm));

Cleanup:
    ReleaseInterface(pStrm);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member: CServer::SaveToStorage
//
//  Synopsis:   Saves the object's persistent state to a storage
//
//  Arguments:  [pStg] -- storage to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Save and IPersistFile::Save when
//              the file is a docfile.
//
//              This method opens a stream, "CONTENTS", and uses
//              method SaveToStream to complete the save.
//              Servers that do more sophisticated saving will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    LPSTREAM    pStrm   = NULL;

    hr = THR(pStg->CreateStream(
            szContents,
            STGM_SALL|STGM_CREATE,
            0L,
            0L,
            &pStrm));
    if (hr)
        goto Cleanup;

    hr = THR(SaveToStream(pStrm));

Cleanup:
    ReleaseInterface(pStrm);

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::InitNew
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method transitions the object to loaded.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::InitNew(LPSTORAGE pStg)
{
    HRESULT     hr  = S_OK;

    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    // object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);

    //  CONSIDER what's the cleanup behavior here?

    if (_pPStgCache)
    {
        hr = THR(_pPStgCache->InitNew(pStg));
        if (hr)
            goto Cleanup;
    }

    _pStg = pStg;
    pStg->AddRef();

    _fInitNewed = TRUE;
    _lDirtyVersion = MAXLONG;     // set dirty to true, as per OLE spec (frankman)

    _state = OS_LOADED;

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Load
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method loads the object using LoadFromStorage and
//              then transitions the object to loaded.
//
//              A pointer to our storage is maintained in member variable
//              _pStg.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Load(LPSTORAGE  pStg)
{
    HRESULT         hr;
    IOleCache2 *    pCache2 = NULL;
    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    //  Object can be loaded only once!

    if (_state != OS_PASSIVE)
        RRETURN(CO_E_ALREADYINITIALIZED);

    //  Do the load and move to the loaded state

    hr = THR(LoadFromStorage(pStg));
    if (hr)
        goto Cleanup;

    _pStg = pStg;
    pStg->AddRef();

    _state = OS_LOADED;

       // Don't nned to save it until the doc changes
    _lDirtyVersion = 0;

Cleanup:
    ReleaseInterface(pCache2);
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::Save
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method uses SaveToStorage to write the persistent
//              state.  It also writes the full user type string to the
//              storage as is required.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::Save(LPSTORAGE  pStg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    CLIPFORMAT  clipfmt;
    TCHAR       achUserTypeFull[MAX_USERTYPE_LEN + 1];

    if (pStg == NULL)
        RRETURN(E_INVALIDARG);

    if (_state == OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    if (_fHandsOff || _fNoScribble)
    {
        TraceTag((tagError, "IPersistStorage::Save called in hands-off or "
                  "no-scribble mode!"));
        RRETURN(E_UNEXPECTED);
    }

    hr = THR(SaveToStorage(pStg, fSameAsLoad));
    if (hr)
        goto Cleanup;

    // Write the UserType string. We don't let this fail the operation.

    clipfmt = (ServerDesc()->_cGetFmtTable > 0) ?
                    ServerDesc()->_pGetFmtTable[0].cfFormat : 0;

    Verify(LoadString(
            GetResourceHInst(),
            IDS_USERTYPEFULL(BaseDesc()->_idrBase),
            achUserTypeFull,
            ARRAY_SIZE(achUserTypeFull)));

    WriteFmtUserTypeStg(pStg, clipfmt, achUserTypeFull);

    _fNoScribble = TRUE;
    _fSameAsLoad = fSameAsLoad;
    _lDirtyVersion = 0;

    //  CONSIDER what's our error recovery strategy here?

    if (_pPStgCache)
        hr = THR(_pPStgCache->Save(pStg, fSameAsLoad));

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::SaveCompleted
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method clears the dirty flag and updates our
//              storage pointer, _pStg, if required.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::SaveCompleted(LPSTORAGE  pStg)
{
    HRESULT hr  = S_OK;

    if (_fHandsOff == TRUE && NULL == pStg)
    {
        //
        // We are in hands off mode and we get didn't get the expected storage.
        //
        TraceTagEx((tagCServer, TAG_NONEWLINE, "CServer::SaveCompleted:"));
        TraceTagEx((tagCServer, TAG_NONAME|TAG_NONEWLINE, "We are in hands off mode and "));
        TraceTagEx((tagCServer, TAG_NONAME, "we get didn't get a storage"));
        RRETURN(E_UNEXPECTED);
    }

    if (_fHandsOff == FALSE && _fNoScribble == FALSE)
    {
        //
        // SaveCompleted is being called in a "normal" state i.e.  without
        // HandsOffStorage() or Save() having been called.
        //
        RRETURN(E_UNEXPECTED);
    }

    if (pStg != NULL)
    {
        if (_pStg != NULL)
        {
            HandsOffStorage();
        }

        Assert(_pStg == NULL);

        _pStg = pStg;
        _pStg->AddRef();
    }

    if (pStg != NULL || _fSameAsLoad)
    {
        if (_fNoScribble)
        {
            _lDirtyVersion = 0;     // clear our dirty flag

            if (_pOleAdviseHolder)
                _pOleAdviseHolder->SendOnSave();
        }
    }

    if (_pPStgCache)
        hr = THR(_pPStgCache->SaveCompleted(pStg));

    _fSameAsLoad = FALSE;
    _fNoScribble = FALSE;       // we are out of NO-SCRIBBLE mode
    _fHandsOff   = FALSE;       // we are out of HANDS-OFF mode

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::HandsOffStorage
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method releases the storage we are holding on to.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
CServer::HandsOffStorage(void)
{
    HRESULT     hr  = S_OK;

    ClearInterface(&_pStg);

    if (_pPStgCache)
        hr = THR(_pPStgCache->HandsOffStorage());

    _fHandsOff = TRUE;

    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//
//  Member:     LoadFromBag
//
//  Synopsis:   Load object state from a property bag
//
//-----------------------------------------------------------------------------

HRESULT
CServer::LoadFromBag(
    LPPROPERTYBAG   pBag,
    LPERRORLOG      pErrLog)
{
    RRETURN(S_OK);
}



//+----------------------------------------------------------------------------
//
//  Member:     SaveToBag
//
//  Synopsis:   Save object state to a property bag
//
//-----------------------------------------------------------------------------

HRESULT
CServer::SaveToBag(
    LPPROPERTYBAG   pBag,
    BOOL            fSaveAllProperties)
{
    RRETURN(S_OK);
}



//+----------------------------------------------------------------------------
//
//  Member:     CServer::Load
//
//  Synopsis:   Method of IPersistPropertyBag interface
//
//  Notes:      This method uses the LoadFromBag method
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CServer::Load(
    LPPROPERTYBAG   pBag,
    LPERRORLOG      pErrLog)
{
    HRESULT hr;

    if (pBag == NULL)
        RRETURN(E_INVALIDARG);

    // object can be loaded only once!
    if (_state != OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    hr = THR(LoadFromBag(pBag, pErrLog));
    if (hr)
        goto Cleanup;

    _state = OS_LOADED;

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//
//  Member:     CServer::Save
//
//  Synopsis:   Method of IPersistPropertyBag interface
//
//  Notes:      This method uses the SaveToBag method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CServer::Save(
    LPPROPERTYBAG   pBag,
    BOOL            fClearDirty,
    BOOL            fSaveAllProperties)
{
    HRESULT hr;

    if (pBag == NULL)
        RRETURN(E_INVALIDARG);

    if (_state == OS_PASSIVE)
        RRETURN(E_UNEXPECTED);

    hr = THR(SaveToBag(pBag, fSaveAllProperties));
    if (hr)
        goto Cleanup;

    if (fClearDirty)
        _lDirtyVersion = 0;

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetRect
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------


STDMETHODIMP
CServer::GetRect(DWORD dwAspect, LPRECTL prcl)
{
    HRESULT hr              = OLE_E_BLANK;
    DWORD   dwViewStatus    = 0L;

    TraceTag((tagCServer, "CServer::GetRect"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
        hr = S_OK;
        break;

    case DVASPECT_TRANSPARENT:
        IGNORE_HR(GetViewStatus(&dwViewStatus));
        if (dwViewStatus & VIEWSTATUS_DVASPECTTRANSPARENT)
            hr = S_OK;
#if DBG == 1
        else
            Assert(0 && "CServer::GetRect -- DVASPECTTRANSPARENT not supported");
#endif
        break;

    case DVASPECT_OPAQUE:
        IGNORE_HR(GetViewStatus(&dwViewStatus));
        if (dwViewStatus & VIEWSTATUS_DVASPECTOPAQUE)
            hr = S_OK;
#if DBG == 1
        else
            Assert(0 && "CServer::GetRect -- DVASPECTOPAQUE not supported");
#endif
        break;
    }

    if (hr == S_OK)
    {
        SetRectl(prcl, 0, 0, _sizel.cx, _sizel.cy);
    }
#if DBG == 1
    else
        Assert(0 && "Unhandled value");
#endif

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetViewStatus
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetViewStatus(DWORD *pdwStatus)
{
    TraceTag((tagCServer, "CServer::GetViewStatus"));
    *pdwStatus = ServerDesc()->_dwViewStatus;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::QueryHitPoint
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryHitPoint(
        DWORD dwAspect,
        LPCRECT prcBounds,
        POINT ptLoc,
        LONG lCloseHint,
        DWORD *pHitResult)
{
    HRESULT hr;

    TraceTag((tagCServer, "CServer::QueryHitPoint"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    {
        *pHitResult = (PtInRect(prcBounds, ptLoc)) ? 
                        HITRESULT_HIT : 
                        HITRESULT_OUTSIDE;
        hr = S_OK;
        break;
    }

    default:
        *pHitResult = 0;
        hr = E_NOTIMPL;
        break;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CServer::QueryHitRect
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::QueryHitRect(DWORD dwAspect, LPCRECT pRectBounds,
                      LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult)
{
    HRESULT hr;

    TraceTag((tagCServer, "CServer::QueryHitRect"));

    switch (dwAspect)
    {
    case DVASPECT_CONTENT:
    {
        *pHitResult = HITRESULT_HIT;
        hr = S_OK;
        break;
    }

    default:
        *pHitResult = 0;
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::GetNaturalExtent
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CServer::GetNaturalExtent(
    DWORD dwAspect, LONG lindex, DVTARGETDEVICE * ptd,
    HDC hicTargetDev, DVEXTENTINFO * pExtentInfo, LPSIZEL psizel )
{
    TraceTag((tagCServer, "CServer::GetNaturalExtent"));
    // CONSIDER: Should this routine deal with aspects other than content?
    return E_NOTIMPL;
}


#ifdef _MAC
//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureMacScrollbars
//
//  Synopsis:   Method of the IViewObjectEx interface.
//
//----------------------------------------------------------------------------

void CServer::EnsureMacScrollbars(HDC hdc)
{
	if ( !_hVertScroll )
		_hVertScroll = CreateMacScrollbar(hdc);
	if ( !_hHorzScroll )
		_hHorzScroll = CreateMacScrollbar(hdc);	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\undo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       undo.cxx
//
//  Contents:   Implementation of Undo classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_QI_IMPL_H
#define X_QI_IMPL_H
#include "qi_impl.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif


DeclareTag(tagUndo, "Undo", "Form Undo");
DeclareTag(tagAllowParentlessUndo, "Undo", "Allow parentless undo")
DeclareTag(tagNoUndo, "Undo", "Disable undo")
MtDefine(Undo, Mem, "Undo")
MtDefine(UndoStringDescription, Undo, "Undo Description String")
MtDefine(CUndoManager, Undo, "CUndoManager")
MtDefine(CParentUndoUnit, Undo, "CParentUndoUnit")
MtDefine(CParentUndo, Undo, "CParentUndo")
MtDefine(CUndoPropChange, Undo, "CUndoPropChange")
MtDefine(CUndoUnitAry_pv, Undo, "CUndoUnitAry::_pv")

CDummyUndoManager      g_DummyUndoMgr;    // No ctor, dtor or member data
CBlockedParentUnit     g_BlockedUnit;


// Private guid for undo manager - {FABDA060-28C7-11d2-B0A7-00C04FA34D84}
const CLSID CLSID_CUndoManager = { 0xfabda060, 0x28c7, 0x11d2, { 0xb0, 0xa7, 0x0, 0xc0, 0x4f, 0xa3, 0x4d, 0x84 } };

static HRESULT 
SafeUndoAryRelease( CUndoUnitAry * pAry, int indexReleaseFrom, int indexReleaseTo)
{
    HRESULT         hr = S_OK;
    CUndoUnitAry    aryRelease;
    int             c;

    c = indexReleaseTo - indexReleaseFrom + 1;

    if (c <= 0)
        goto Cleanup;

    Assert( c <= pAry->Size() );

    hr = aryRelease.Grow( c );
    if (hr)
        goto Cleanup;

    // Copy the part of the array that we want to release
    {
        IOleUndoUnit ** ppUndoFrom = ((IOleUndoUnit**)(*pAry)) + indexReleaseFrom;
        IOleUndoUnit ** ppUndoTo = aryRelease;

        for ( ; c > 0; c--, ppUndoFrom++, ppUndoTo++ )
            *ppUndoTo = *ppUndoFrom;
    }

    // Remove the pointers from the original array
    pAry->DeleteMultiple( indexReleaseFrom, indexReleaseTo );

    // Release all of the pointers in the copied array
    aryRelease.ReleaseAll();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBlockedParentUnit::Close, public
//
//  Synopsis:   Implements the close method for the dummy blocked parent
//              unit.
//
//  Arguments:  [pPUU]    -- Pointer to object being closed.
//              [fCommit] -- ignored
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBlockedParentUnit::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    //
    // We're always blocked, so we only handle that case.
    //
    if (pPUU == (IOleParentUndoUnit*)this)
    {
        return S_FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::CreateUndoManager, public
//
//  Synopsis:   Creates the undo manager if it hasn't already been created.
//              Does not query our container for the undo service.
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::CreateUndoManager(void)
{
    if (_pUndoMgr == &g_DummyUndoMgr)
    {
        TraceTag((tagUndo, "CServer::CreateUndoManager -- creating manager."));

        _pUndoMgr = new CUndoManager();
        if (!_pUndoMgr)
        {
            _pUndoMgr = &g_DummyUndoMgr;
            RRETURN(E_OUTOFMEMORY);;
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::BlockNewUndoUnits, public
//
//  Synopsis:   Causes any new undo units that might be created to be blocked.
//
//  Arguments:  (none)
//
//  Returns:    An HRESULT and a cookie. If the cookie is zero then you don't
//              have to call UnblockNewUndoUnits. All other values are
//              undefined and UnblockNewUndoUnits must be called.
//
//----------------------------------------------------------------------------

HRESULT
CBase::BlockNewUndoUnits(DWORD *pdwCookie)
{
    //
    // Note that QueryCreateUndo _must_ checked for blocked undo units so
    // that nested calls to this method work properly!
    //
    if (QueryCreateUndo(FALSE))
    {
        *pdwCookie = 1;
        RRETURN(UndoManager()->Open(&g_BlockedUnit));
    }

    *pdwCookie = 0;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::UnblockNewUndoUnits, public
//
//  Synopsis:   Unblocks undo units that were blocked by calling
//              BlockNewUndoUnits.
//
//----------------------------------------------------------------------------

void
CBase::UnblockNewUndoUnits(DWORD dwCookie)
{
    if (dwCookie)
    {
        IGNORE_HR(UndoManager()->Close(&g_BlockedUnit, FALSE));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::QueryCreateUndo, public
//
//  Synopsis:   Indicates whether an undo unit should be created or not.
//
//  Arguments:  [fRequiresParent] -- If TRUE, the return value will be FALSE
//                                   unless an undo unit is open on the
//                                   stack.
//
//  Returns:    TRUE if an undo unit should be created, FALSE if not.
//
//  Notes:      If [fRequiresParent] is TRUE, and there is no open unit on
//              the undo stack, then the undo stack will be flushed.
//
//----------------------------------------------------------------------------

BOOL
CBase::QueryCreateUndo(BOOL fRequiresParent, BOOL fDirtyChange /* = TRUE */, BOOL * pfTreeSync /* = NULL */)
{
    HRESULT              hr;
    DWORD                dwUndoState;
    IOleUndoManager * pUM;

    pUM = UndoManager();
    Assert(pUM);

    if( pfTreeSync )
        *pfTreeSync = FALSE;

    if (pUM == &g_DummyUndoMgr WHEN_DBG(|| IsTagEnabled(tagNoUndo)))
        return FALSE;

    hr = pUM->GetOpenParentState(&dwUndoState);
    if (FAILED(hr))
        goto Error;

    if (hr == S_OK)
    {
        //
        // There's an open unit on the stack.
        //
        if ((dwUndoState & UAS_NOPARENTENABLE) && fRequiresParent)
        {
            goto Error;
        }
        else if (dwUndoState & UAS_BLOCKED)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }

    if (!fRequiresParent || TLS( fAllowParentLessPropChanges )
        WHEN_DBG( || IsTagEnabled(tagAllowParentlessUndo) ) )
        return TRUE;

    //
    // The unit needs a parent, but there isn't one, so clear the undo
    // stack.
    //
Error:
    if( fDirtyChange )
        pUM->DiscardFrom(NULL);

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::OpenParentUnit, public
//
//  Synopsis:   Opens a parent unit which does nothing but contain other
//              units and puts it on the undo stack.
//
//  Arguments:  [pBase] -- Owning object
//              [uiID]  -- ID for description
//
//  Returns:    Open parent, may be NULL in certain cases, but this is not
//              an error condition.
//
//  Notes:      The caller should not release the interface returned by
//              this function.  It will be released by CloseParentUnit.
//
//----------------------------------------------------------------------------

CParentUndoUnit *
CBase::OpenParentUnit(CBase * pBase, UINT uiID, TCHAR * pchDescription /* = NULL */)
{
    CParentUndoUnit *      pCPUU     = NULL;
    IOleUndoManager *  pUM;
    DWORD                    dwState;
    HRESULT                  hr;

    TraceTag((tagUndo, "CBase::OpenParentUnit"));

    pUM = UndoManager();
    Assert(pUM);

    if (pUM == &g_DummyUndoMgr)
        return NULL;

    //
    // If there is no undo manager or an already open parent unit then
    // just return NULL because we don't need to create a parent object.
    //
    hr = pUM->GetOpenParentState(&dwState);
    if (FAILED(hr))
        return NULL;

    if ((hr == S_FALSE) ||
        ((dwState & UAS_NOPARENTENABLE) && !(dwState & UAS_BLOCKED)))
    {
        //
        // There's no open object on the stack or it's non-enabling, so put
        // an enabling parent on and return it.
        // 
        if (pchDescription)
            pCPUU = new CParentUndoUnit(pBase, pchDescription);
        else
            pCPUU = new CParentUndoUnit(pBase, uiID);

        if (pCPUU)
        {
            if (FAILED(pUM->Open(pCPUU)))
            {
                ClearInterface(&pCPUU);
            }
        }
    }

    return pCPUU;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CloseParentUnit, public
//
//  Synopsis:   Closes a parent unit opened with OpenParentUnit.
//
//  Arguments:  [pCPUU]    -- Unit returned from OpenParentUnit.
//              [hrCommit] -- If S_OK, then the unit is committed.
//                            Otherwise it's released and not added to the
//                            stack.
//
//  Returns:    HRESULT
//
//  Notes:      If the [pCPUU] object is empty (has no children) then it is
//              not committed.
//
//----------------------------------------------------------------------------

HRESULT
CBase::CloseParentUnit(CParentUndoUnit * pCPUU, HRESULT hrCommit)
{
    HRESULT              hr;
    IOleUndoManager * pUM;

    if (!pCPUU)
        return S_OK;

    TraceTag((tagUndo, "CBase::CloseParentUnit"));

    pUM = UndoManager();
    Assert(pUM);

    //
    // Don't commit if the unit is empty.  Later, if needed, we can add a
    // flag to this function which disables this behavior if we ever get any
    // parent units that affect state and don't need children to be useful.
    //
    if (pCPUU->_aryUndo.Size() == 0)
    {
        hrCommit = S_FALSE;
    }

    hr = pUM->Close(pCPUU, (hrCommit == S_OK) ? TRUE : FALSE);
    if (hr == S_FALSE)
    {
        //
        // The open unit was most likely thrown away by a call to
        // DiscardFrom, so we ignore that situation.
        //
        hr = S_OK;
    }

    pCPUU->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBase::CreatePropChangeUndo, public
//
//  Synopsis:   Creates a property change undo object for simple property
//              types.
//
//  Arguments:  [dispidProp] -- Dispid of the property
//              [wpiType]    -- Type of the property (must match the
//                              in-memory size of the property).
//              [dwProp]     -- Current (old) value of property.
//              [ppUndo]     -- Undo object returned here. Can be NULL. The
//                              returned value may be NULL in non-error cases.
//
//  Returns:    HRESULT
//
//  Notes:
//
// If [wpiType] is WPI_CSTRING, then [dwProp] should be a pointer to a CStr.
//
// If [ppUndo] is NULL, the current value of the property is stored and the
// unit is given to the undo manager.
//
// If [ppUndo] is not NULL, the current value of the property is stored but
// the unit is not given to the Undo Manager.  [ppUndo] is filled in with a
// pointer to the unit, and the caller is responsible for adding the unit
// to the undo stack by calling Add() on the undo manager, and then releasing
// the unit.  The unit does not have to be given to the undo manager (in
// the case of a later error for example), but the returned object should
// always be released if it was not NULL.  The value returned in [ppUndo] is
// NULL if an error occurs or if there is no open unit on the undo stack.
//
//----------------------------------------------------------------------------

HRESULT
CBase::CreatePropChangeUndo(DISPID             dispidProp,
                            VARIANT *          pVar,
                            CUndoPropChange ** ppUndo)
{
    HRESULT           hr;
    CUndoPropChange * pUndo;

    if (ppUndo)
        *ppUndo = NULL;

    if (!QueryCreateUndo(TRUE))
        return S_OK;

    TraceTag((tagUndo, "CBase::CreatePropChangeUndo creating an object."));

    pUndo = new CUndoPropChange(this, IDS_UNDOPROPCHANGE);
    if (!pUndo)
        RRETURN(E_OUTOFMEMORY);

    hr = THR(pUndo->Init(dispidProp, pVar));
    if (hr)
        goto Error;

    if (!ppUndo)
    {
        IOleUndoManager *pUM = UndoManager();

        Assert(pUM);

        hr = THR(pUM->Add(pUndo));

        ReleaseInterface(pUndo);
    }
    else
    {
        *ppUndo = pUndo;
    }

Cleanup:
    RRETURN(hr);

Error:
    ReleaseInterface(pUndo);
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::QueryStatusUndoRedo
//
//  Synopsis:   Helper function for QueryStatus(). Check if in our current
//              state we suport these commands.
//
//--------------------------------------------------------------------------

HRESULT
CBase::QueryStatusUndoRedo(BOOL fUndo, MSOCMD * pcmd, MSOCMDTEXT * pcmdtext)
{
    BSTR        bstr = NULL;
    HRESULT     hr;

    // Get the Undo/Redo state.
    if (fUndo)
        hr = THR_NOTRACE(UndoManager()->GetLastUndoDescription(&bstr));
    else
        hr = THR_NOTRACE(UndoManager()->GetLastRedoDescription(&bstr));

    // Return the command state.
    pcmd->cmdf = hr ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;

    // Return the command text if requested.
    if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
    {

        // TODO - This code needs to be supported on the MAC. (rodc)
        if (hr)
        {
            pcmdtext->cwActual = LoadString(
                    GetResourceHInst(),
                    fUndo ? IDS_CANTUNDO : IDS_CANTREDO,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf);
        }
        else
        {
            hr = Format(
                    0,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf,
                    MAKEINTRESOURCE(fUndo ? IDS_UNDO : IDS_REDO),
                    bstr);
            if (!hr)
                pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);
        }
    }

    if (bstr)
        FormsFreeString(bstr);

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CBase::EditUndo
//
//  Synopsis:   Performs an Undo
//
//---------------------------------------------------------------

HRESULT
CBase::EditUndo()
{
    TraceTag((tagUndo, "CBase::EditUndo"));

    HRESULT hr = THR(UndoManager()->UndoTo(NULL));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CForm::EditRedo
//
//  Synopsis:   Performs a Redo
//
//---------------------------------------------------------------

HRESULT
CBase::EditRedo()
{
    TraceTag((tagUndo, "CBase::EditRedo"));

    HRESULT hr = THR(UndoManager()->RedoTo(NULL));

    RRETURN(hr);
}






//+---------------------------------------------------------------------------
//
//  CComposeUndo Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::CComposeUndo, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CComposeUndo::CComposeUndo()
{
    Assert(_pPUUOpen   == NULL);
    Assert(_fDisabled  == FALSE);
    Assert(_UndoState  == UNDO_BASESTATE);
    Assert(_BlockCount == 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::~CComposeUndo, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CComposeUndo::~CComposeUndo()
{
    IGNORE_HR(SafeUndoAryRelease(&_aryUndo, 0, _aryUndo.Size()-1));
    IGNORE_HR(SafeUndoAryRelease(&_aryRedo, 0, _aryRedo.Size()-1));

    ReleaseInterface(_pPUUOpen);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::GetTopUndoUnit, protected
//
//  Synopsis:   Returns the undo unit at the top of the stack.
//
//----------------------------------------------------------------------------

IOleUndoUnit *
CComposeUndo::GetTopUndoUnit()
{
    int c = _aryUndo.Size();

    if (c)
        return _aryUndo[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::GetTopRedoUnit, protected
//
//  Synopsis:   Returns the redo unit at the top of the stack.
//
//----------------------------------------------------------------------------

IOleUndoUnit *
CComposeUndo::GetTopRedoUnit()
{
    int c = _aryRedo.Size();

    if (c)
        return _aryRedo[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Open, public
//
//  Synopsis:   Adds a parent undo unit, and leaves it open. All further
//              calls to the parent undo methods are forwarded to the object
//              until it is closed.
//
//  Arguments:  [pUU] -- Object to add and leave open.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Open(IOleParentUndoUnit *pPUU)
{
    TraceTag((tagUndo, "CComposeUndo::Open,  this=%p", this));

    if (_fDisabled || (_BlockCount > 0))
        return S_OK;

    if (!pPUU)
    {
        RRETURN(E_INVALIDARG);
    }

    if (_pPUUOpen)
    {
        RRETURN(_pPUUOpen->Open(pPUU));
    }

    ReplaceInterface(&_pPUUOpen, pPUU);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Close(IOleParentUndoUnit * pPUU, BOOL fCommit)
{
    HRESULT hr;

    TraceTag((tagUndo, "CComposeUndo::Close,  this=%p", this));

    if (_fDisabled ||
        ((_BlockCount > 0) && (pPUU != (IOleParentUndoUnit*)this)))
    {
        return S_OK;
    }

    if ((!_pPUUOpen) || (_BlockCount > 0))
    {
        Assert(_NonEnableCount == 0);

        hr = OnClose();
        if (hr)
            RRETURN(hr);

        return S_FALSE;
    }

    hr = THR(_pPUUOpen->Close(pPUU, fCommit));

    if (FAILED(hr) || (hr == S_OK))
        RRETURN(hr);

    Assert(hr == S_FALSE);
    // Close returned S_FALSE

    if (_pPUUOpen != pPUU)
        RRETURN(E_INVALIDARG);

    if (fCommit)
    {
        hr = AddUnit(_pPUUOpen);
    }

    ClearInterface(&_pPUUOpen);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::OnNextAdd, public
//
//  Synopsis:   Notifies most recent child of new unit
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CComposeUndo::OnNextAdd()
{
    if (_pPUUOpen)
        IGNORE_HR( _pPUUOpen->OnNextAdd() ); // must return S_OK

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::Add, public
//
//  Synopsis:   Adds an undo unit to the stack directly. Doesn't leave it
//              open.
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::Add(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CComposeUndo::Add,  this=%p", this));

    if (_fDisabled || (_BlockCount > 0))
        return S_OK;

    if (!pUU)
    {
        RRETURN(E_INVALIDARG);
    }

    if (_pPUUOpen)
    {
        RRETURN(_pPUUOpen->Add(pUU));
    }

    hr = AddUnit(pUU);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::DoTo, protected
//
//  Synopsis:   Helper method that calls do on an array of objects
//
//  Arguments:  [pUM]         -- Pointer to undo manager to pass to units
//              [paryUnit]    -- Undo or Redo stack
//              [pUU]         -- Object to undo or redo to.
//              [fDoRollback] -- If TRUE, rollback will be attempted on an
//                               error. Noone but the undo manager should
//                               pass TRUE for this.
//
//  Returns:    HRESULT
//
//  Notes:      Parent units can use the _fUnitSucceeded flag to determine
//              whether or not they should commit the unit they put on the
//              opposite stack.  If _fUnitSucceeded is TRUE after calling
//              this function, then the unit should commit itself.  If
//              FALSE, the unit does not have to commit itself.  In either
//              case any error code returned by this function should be
//              propagated to the caller.
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::DoTo(IOleUndoManager *            pUM,
                   CUndoUnitAry *               paryUnit,
                   IOleUndoUnit *               pUU,
                   BOOL                         fDoRollback)
{
    IOleUndoUnit **         ppUA;
    CUndoUnitAry            aryCopy;
    int                     iUnit;
    HRESULT                 hr;

    TraceTag((tagUndo, "CComposeUndo::DoTo"));

    _fUnitSucceeded = FALSE;
    _fRollbackNeeded = FALSE;

    if (_fDisabled || _pPUUOpen)
        RRETURN(E_UNEXPECTED);

    Assert(paryUnit);

    if (paryUnit->Size() == 0)
        return S_OK;

    hr = THR(aryCopy.Copy(*paryUnit, FALSE));
    if (hr)
        RRETURN(hr);

    if (pUU)
    {
        iUnit = aryCopy.Find(pUU);
        if (iUnit == -1)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        iUnit = aryCopy.Size() - 1;
        pUU = aryCopy[iUnit];
    }

    //
    // Delete the units from the original array before we call Do() on those
    // units in case they do something naughty like call DiscardFrom which
    // would Release them.
    //
    paryUnit->DeleteMultiple(iUnit, paryUnit->Size() - 1);

    //
    // Make sure the copy of the array has only the units in it we're
    // processing.
    //
    if (iUnit > 0)
    {
        aryCopy.DeleteMultiple(0, iUnit - 1);
    }

    for(ppUA = &aryCopy.Item(aryCopy.Size() - 1);
        ; // Infinite
        ppUA--)
    {
        hr = THR((*ppUA)->Do(pUM));
        if (hr)
            goto Error;

        _fUnitSucceeded = TRUE;

        if (*ppUA == pUU)
            break;
    }

    Assert(!_pPUUOpen);

Cleanup:
    if (hr == E_ABORT)
    {
        hr = E_FAIL;
    }

Cleanup2:
    aryCopy.ReleaseAll();

    RRETURN(hr);

Error:
    if (fDoRollback)
    {
        HRESULT hr2 = S_OK;

        // Using a local because the calls to Do() may change the state
        // of this flag.
        BOOL    fRollbackNeeded = _fRollbackNeeded;

        if (fRollbackNeeded)
        {
            TraceTag((tagUndo, "Undo failed! Attempting rollback..."));

            if (_UndoState == UNDO_UNDOSTATE)
            {
                hr2 = THR(GetTopRedoUnit()->Do(NULL));
            }
            else
            {
                hr2 = THR(GetTopUndoUnit()->Do(NULL));
            }
        }

        Assert(!_pPUUOpen);

        _aryUndo.ReleaseAll();
        _aryRedo.ReleaseAll();
        ClearInterface(&_pPUUOpen); // For safety in retail builds only.

        if (fRollbackNeeded)
        {
            if (hr2)
            {
                TraceTag((tagUndo, "Rollback failed! Bailing out..."));

                hr = E_ABORT;
                goto Cleanup2;
            }
            else
                TraceTag((tagUndo, "Rollback succeeded! Returning error %hr", hr));
        }
    }
#if DBG == 1
    else
    {
        if (!fDoRollback)
        {
            TraceTag((tagUndo, "Undo failed for parent unit!"));
        }
        else if (!_fRollbackNeeded)
        {
            TraceTag((tagUndo, "Undo failed but rollback not needed!"));
        }
    }
#endif

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::AddUnit, protected
//
//  Synopsis:   Adds a new unit to the appropriate stack, no questions asked.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeUndo::AddUnit(IOleUndoUnit *pUU)
{
    HRESULT hr;

    if (_UndoState == UNDO_UNDOSTATE)
    {
        if (_aryRedo.Size() > 0)
        {
            GetTopRedoUnit()->OnNextAdd();
        }

        Assert(!_fRespectMaxEntries || _aryRedo.Size() <= MAX_STACK_ENTRIES);

        hr = THR(_aryRedo.Append(pUU));
        if (hr)
            goto Cleanup;

        pUU->AddRef();

        if (_aryRedo.Size() > MAX_STACK_ENTRIES && _fRespectMaxEntries )
        {
            _aryRedo.ReleaseAndDelete(0);
        }
    }
    else
    {
        if (_aryUndo.Size() > 0)
        {
            GetTopUndoUnit()->OnNextAdd();
        }

        Assert(!_fRespectMaxEntries || _aryUndo.Size() <= MAX_STACK_ENTRIES);

        hr = THR(_aryUndo.Append(pUU));
        if (hr)
            goto Cleanup;

        pUU->AddRef();

        if (_aryUndo.Size() > MAX_STACK_ENTRIES && _fRespectMaxEntries)
        {
            _aryUndo.ReleaseAndDelete(0);
        }

        if (_UndoState == UNDO_BASESTATE)
        {
            _aryRedo.ReleaseAll();
        }
    }

    _fRollbackNeeded = TRUE;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::FindChild, public
//
//  Synopsis:   Searches the children in a given stack for a undo unit.
//
//  Arguments:  [aryUnit] -- Array to look in
//              [pUU]     -- Unit to look for
//
//  Returns:    The index of the element in [aryUnit] that contains [pUU].
//
//----------------------------------------------------------------------------

int
CComposeUndo::FindChild(CUndoUnitAry &aryUnit, IOleUndoUnit *pUU)
{
    IOleParentUndoUnit * pPUU;
    IOleUndoUnit **      ppUA;
    HRESULT              hr     = S_FALSE;
    int                  i;

    for (i = aryUnit.Size(), ppUA = aryUnit;
         i;
         i--, ppUA++)
    {
        if ((*ppUA)->QueryInterface(IID_IOleParentUndoUnit, (LPVOID*)&pPUU) == S_OK)
        {
            hr = pPUU->FindUnit(pUU);

            ReleaseInterface(pPUU);
        }

        if (hr == S_OK)
            break;
    }

    if (i == 0)
        i = -1;
    else
        i = ppUA - (IOleUndoUnit **)aryUnit;

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::SetBlockedState, public
//
//  Synopsis:   Sets the blocked state of the parent unit. The unit
//              maintains a counter.
//
//  Arguments:  [fBlocked] -- If TRUE, the block count is incremented.
//                            Otherwise it's decremented.
//
//  Notes:      If the block count is non-zero, the unit is blocked.
//
//----------------------------------------------------------------------------

void
CComposeUndo::SetBlockedState(BOOL fBlocked)
{
    if (fBlocked)
    {
        Assert(!_pPUUOpen);

        Assert(_BlockCount < MAX_BLOCK_COUNT);
        _BlockCount++;
    }
    else
    {
        Assert(_BlockCount > 0);
        _BlockCount--;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CComposeUndo::SetNonEnableState, public
//
//  Synopsis:   Sets the non-parent-enable state of the parent unit.  The
//              unit maintains a counter.
//
//  Arguments:  [fNonEnable] -- If TRUE, the non-enable count is incremented.
//                              Otherwise it's decremented.
//
//  Notes:      If the non-enable count is non-zero, the unit returns
//              UAS_NOPARENTENABLE from GetParentState.
//
//----------------------------------------------------------------------------

void
CComposeUndo::SetNonEnableState(BOOL fNonEnable)
{
    if (fNonEnable)
    {
        Assert(_NonEnableCount < MAX_BLOCK_COUNT);
        _NonEnableCount++;
    }
    else
    {
        Assert(_NonEnableCount > 0);
        _NonEnableCount--;
    }
}

//+---------------------------------------------------------------------------
//
//  CUndoManager Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::CUndoManager, public
//
//  Synopsis:   CUndoManager ctor
//
//----------------------------------------------------------------------------

CUndoManager::CUndoManager()
{
    _ulRefs = 1;
    _fRespectMaxEntries = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::QueryInterface, public
//
//  Synopsis:   Implements QueryInterface for the undo manager
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (iid == CLSID_CUndoManager)
    {
        *ppv = LPVOID(this);
        return S_OK;
    }

    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleUndoManager)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetOpenParentState, public
//
//  Synopsis:   Indicates whether there's an open unit, and if so whether
//              or not it's blocked.
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    S_OK for an open object, S_FALSE for not.
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetOpenParentState(DWORD * pdwState)
{
    TraceTag((tagUndo, "CUndoManager::GetOpenParentState"));

    if (_fDisabled)
    {
        *pdwState = UAS_BLOCKED;
        return S_OK;
    }

    *pdwState = 0;

    if (_pPUUOpen)
    {
        return _pPUUOpen->GetParentState(pdwState);
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::DiscardFrom, public
//
//  Synopsis:   Removes the specified undo unit and all units below it
//              from the undo stack. Checks child undo units for the given
//              unit and deletes the topmost parent of the given unit.
//
//  Arguments:  [pUU] -- Unit to remove. If NULL, the entire undo and redo
//                       stacks are cleared.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::DiscardFrom(IOleUndoUnit * pUU)
{
    TraceTag((tagUndo, "CUndoManager::DiscardFrom"));

    HRESULT hr = S_OK;

    if (_fDisabled)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (pUU)
    {
        int indexUndo;
        int indexRedo = -1;

        //
        // The most common scenario is for the given unit to exist somewhere
        // in the top-level undo or redo stack. So, we search those first
        // before checking children.
        //
        indexUndo = _aryUndo.Find(pUU);
        if (indexUndo == -1)
        {
            indexRedo = _aryRedo.Find(pUU);
            if (indexRedo == -1)
            {
                indexUndo = FindChild(_aryUndo, pUU);
                if (indexUndo == -1)
                {
                    indexRedo = FindChild(_aryRedo, pUU);
                }
            }
        }

        if ((indexUndo == -1) && (indexRedo == -1))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (indexUndo != -1)
        {
            hr = SafeUndoAryRelease( &_aryUndo, 0, indexUndo );
            if (hr)
                goto Cleanup;
        }
        else
        {
            Assert(indexRedo != -1);
            hr = SafeUndoAryRelease( &_aryRedo, 0, indexRedo );
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = SafeUndoAryRelease( &_aryUndo, 0, _aryUndo.Size() - 1 );
        if (hr)
            goto Cleanup;

        hr = SafeUndoAryRelease( &_aryRedo, 0, _aryRedo.Size() - 1 );
        if (hr)
            goto Cleanup;

        if (_pPUUOpen)
        {
            ClearInterface(&_pPUUOpen);
        }
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::UndoTo, public
//
//  Synopsis:   Performs undo operations up to the given unit on the stack.
//
//  Arguments:  [pUU] -- Undo unit to undo up to. If NULL undo the last one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::UndoTo(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoManager::UndoTo"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    _UndoState = UNDO_UNDOSTATE;

    hr = DoTo(this, &_aryUndo, pUU, TRUE);

    _UndoState = UNDO_BASESTATE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::RedoTo, public
//
//  Synopsis:   Performs redo operations up to the given unit on the stack.
//
//  Arguments:  [pUU] -- Redo unit to redo up to. If NULL redo the last one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::RedoTo(IOleUndoUnit *pUU)
{
    HRESULT hr;

    TraceTag((tagUndo, "CUndoManager::RedoTo"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    _UndoState = UNDO_REDOSTATE;

    hr = DoTo(this, &_aryRedo, pUU, TRUE);

    _UndoState = UNDO_BASESTATE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::EnumUndoable, public
//
//  Synopsis:   Returns an enumerator that enumerates the undo stack.
//
//  Arguments:  [ppEnum] -- Place to put enumerator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::EnumUndoable(IEnumOleUndoUnits **ppEnum)
{
    TraceTag((tagUndo, "CUndoManager::EnumUndoable"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(_aryUndo.EnumElements(IID_IEnumOleUndoUnits,
                                  (void**)ppEnum,
                                  TRUE, TRUE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::EnumRedoable, public
//
//  Synopsis:   Returns an enumerator that enumerates the redo stack.
//
//  Arguments:  [ppEnum] -- Place to put enumerator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::EnumRedoable(IEnumOleUndoUnits **ppEnum)
{
    TraceTag((tagUndo, "CUndoManager::EnumRedoable"));

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(_aryRedo.EnumElements(IID_IEnumOleUndoUnits,
                                  (void**)ppEnum,
                                  TRUE, TRUE, TRUE));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetLastUndoDescription, public
//
//  Synopsis:   Returns the description of the top-most undo unit
//
//  Arguments:  [pbstr] -- Place to put description.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetLastUndoDescription(BSTR *pbstr)
{
    TraceTag((tagUndo, "CUndoManager::GetLastUndoDescription"));

    RRETURN(GetDescr(GetTopUndoUnit(), pbstr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetLastRedoDescription, public
//
//  Synopsis:   Returns the description of the top-most redo unit
//
//  Arguments:  [pstr] -- Place to put description. Should be freed with
//                        the OLE task allocator.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetLastRedoDescription(BSTR *pbstr)
{
    TraceTag((tagUndo, "CUndoManager::GetLastRedoDescription"));

    RRETURN(GetDescr(GetTopRedoUnit(), pbstr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::Enable, public
//
//  Synopsis:   Enables or disables the undo manager.
//
//  Arguments:  [fEnable] -- If TRUE the undo manager is enabled.
//
//  Returns:    HRESULT
//
//  Notes:      The manager cannot be disabled when it is in the middle of
//              an undo or redo, or if there is an open unit.
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::Enable(BOOL fEnable)
{
    TraceTag((tagUndo, "CUndoManager::Enable(%s)", fEnable ? "TRUE" : "FALSE"));

    //
    // Can't disable in the middle of an undo or redo, or when an unit
    // is open.
    //
    if ((_UndoState > UNDO_BASESTATE) || _pPUUOpen)
    {
        RRETURN(E_UNEXPECTED);
    }

    if (fEnable)
    {
        _fDisabled = FALSE;
    }
    else
    {
        DiscardFrom(NULL);
        _fDisabled = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoManager::GetDescr, protected
//
//  Synopsis:   Helper method for GetLast{Un|Re}doDescription
//
//  Arguments:  [pUU]   -- Unit to get description
//              [pbstr] -- Place to put it
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoManager::GetDescr(IOleUndoUnit *pUU, BSTR *pbstr)
{
    *pbstr = NULL;

    if (pUU == NULL)
        RRETURN(E_FAIL);

    if (_fDisabled || (_UndoState != UNDO_BASESTATE))
        RRETURN(E_UNEXPECTED);

    RRETURN(pUU->GetDescription(pbstr));
}

//+---------------------------------------------------------------------------
//
//  CUndoUnit Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::CUndoUnit, public
//
//  Synopsis:   CUndoUnit ctor
//
//  Effects:    Saves member data.
//
//  Arguments:  [pBase]      -- Owner Class
//              [uiStringID] -- String ID of name. Must be a valid resource ID.
//
//  Notes:      [uiStringID] should be unique for each undo class since it is
//              used by GetUnitType() to identify the undo unit.
//
//----------------------------------------------------------------------------

CUndoUnit::CUndoUnit(CBase * pBase, UINT uiStringID)
{
    _pBase   = pBase;
    _uiResID = uiStringID;
    _pchDescription = NULL;
}


CUndoUnit::CUndoUnit(CBase * pBase, TCHAR * pchDescription )
{
    _pBase   = pBase;
    MemAllocString( Mt(UndoStringDescription), pchDescription, &_pchDescription );
}

CUndoUnit::~CUndoUnit()
{
    if( _pchDescription )
        MemFreeString(_pchDescription);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::GetDescription, public
//
//  Synopsis:   Gets the description for this undo unit.
//
//  Arguments:  [pbstr] -- Place to put description
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnit::GetDescription(BSTR *pbstr)
{
    TCHAR szName[FORMS_BUFLEN + 1]; // String for name

    szName[0] = '\0';

    Assert(pbstr);

    if (_pchDescription)
    {
        RRETURN( FormsAllocString( _pchDescription, pbstr ) );
    }
    else
    {
        if (TW32(0, LoadString(GetResourceHInst(), _uiResID, szName, FORMS_BUFLEN)) == 0)
            RRETURN(GetLastWin32Error());
        RRETURN(FormsAllocString(szName, pbstr));
    }

    
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnit::GetUnitType, public
//
//  Synopsis:   Returns the type of this undo unit.
//
//  Arguments:  [pclsid] -- Place to put CLSID (caller allocated).
//              [plID]   -- Place to put identifier.
//
//  Returns:    HRESULT
//
//  Notes:      The classid returned is the form's classid, and the integer
//              is the resource identifier given in the constructor. This
//              information is meaningful only to the form.
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnit::GetUnitType(CLSID *pclsid, LONG *plID)
{
    Assert(pclsid && plID);

    if (_pBase)
    {
        *pclsid = *(_pBase->BaseDesc()->_pclsid);
        *plID = _uiResID;
    }
    else
    {
        *pclsid = CLSID_NULL;
        *plID   = 0;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CUndoUnitBase Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnitBase::CUndoUnitBase, public
//
//  Synopsis:   CUndoUnitBase ctor
//
//  Effects:    Saves member data.
//
//  Arguments:  [pBase]      -- Owner class
//              [uiStringID] -- String ID of name. Must be a valid resource ID.
//
//  Notes:      [uiStringID] should be unique for each undo class since it is
//              used by GetUnitType() to identify the undo unit.
//
//----------------------------------------------------------------------------

CUndoUnitBase::CUndoUnitBase(CBase * pBase, UINT uiStringID)
    : CUndoUnit(pBase, uiStringID)
{
    _ulRefs = 1;

    // We are an undo if we in the base state or in the redo state
    // currently.  i.e. we are not in the undo state
    _fUndo = TLS(nUndoState) != UNDO_UNDOSTATE;
}


HRESULT CUndoUnitBase::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr;
    THREADSTATE * pts = GetThreadState();

    // Do should not be called recursively!
    Assert( TLS(nUndoState) == UNDO_BASESTATE );

    pts->nUndoState = _fUndo ? UNDO_UNDOSTATE : UNDO_REDOSTATE;

    // call the derived class
    hr = PrivateDo( pUndoManager );

    pts->nUndoState = UNDO_BASESTATE;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoUnitBase::QueryInterface, public
//
//----------------------------------------------------------------------------

HRESULT
CUndoUnitBase::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch(iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleUndoUnit)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CParentUnitBase Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::CParentUnitBase, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CParentUnitBase::CParentUnitBase(CBase * pBase, UINT uiStringID)
    : CUndoUnit(pBase, uiStringID)
{
    _ulRefs  = 1;
}


CParentUnitBase::CParentUnitBase(CBase * pBase, BSTR bstrDescription)
    : CUndoUnit(pBase, bstrDescription)
{
    _ulRefs  = 1;
}
//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::~CParentUnitBase, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CParentUnitBase::~CParentUnitBase()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::QueryInterface, public
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::QueryInterface(REFIID iid, LPVOID *ppv)
{
    *ppv = NULL;

    switch(iid.Data1)
    {
        QI_INHERITS(this,  IUnknown)
        QI_INHERITS(this,  IOleParentUndoUnit)
        QI_INHERITS2(this, IOleUndoUnit, IOleParentUndoUnit)
    }

    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::FindUnit, public
//
//  Synopsis:   Indicates if the given unit is in our undo stack or the stack
//              of one of our children. Doesn't check the current open object.
//
//  Arguments:  [pUU] -- Unit to find
//
//  Returns:    TRUE if we found it.
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::FindUnit(IOleUndoUnit *pUU)
{
    int                      i;

    TraceTag((tagUndo, "CParentUnitBase::FindUnit"));

    if (!pUU)
        RRETURN(E_INVALIDARG);

    Assert(_UndoState == UNDO_BASESTATE);

    i = _aryUndo.Find(pUU);
    if (i != -1)
        return S_OK;

    i = FindChild(_aryUndo, pUU);
    if (i != -1)
        return S_OK;

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUnitBase::GetParentState, public
//
//  Synopsis:   Indicates whether there's an open unit, and if so whether
//              or not it's blocked.
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    S_OK always, unless disabled.
//
//----------------------------------------------------------------------------

HRESULT
CParentUnitBase::GetParentState(DWORD * pdwState)
{
    if (!pdwState)
        RRETURN(E_INVALIDARG);

    *pdwState = 0;

    Assert(_UndoState == UNDO_BASESTATE);

    if (_BlockCount > 0)
    {
        Assert(!_pPUUOpen);

        *pdwState = UAS_BLOCKED;
    }
    else if (_pPUUOpen)
    {
        return _pPUUOpen->GetParentState(pdwState);
    }

    if (_NonEnableCount > 0)
    {
        *pdwState |= UAS_NOPARENTENABLE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CParentUndoUnit Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   CParentUndoUnit::CParentUndoUnit
//
//  Synopsis:   CParentUndoUnit ctor
//
//----------------------------------------------------------------------------

CParentUndoUnit::CParentUndoUnit(CBase * pBase, UINT uiStringID)
    : CParentUnitBase(pBase, uiStringID)
{
    TraceTag((tagUndo, "Creating CParentUndoUnit"));
}


CParentUndoUnit::CParentUndoUnit(CBase * pBase, BSTR bstrDescription)
    : CParentUnitBase(pBase, bstrDescription)
{
    TraceTag((tagUndo, "Creating CParentUndoUnit"));
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoUnit::Do, public
//
//  Synopsis:   Calls undo on our contained undo object.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CParentUndoUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT        hr    = S_OK;

    TraceTag((tagUndo, "CParentUndoUnit::Do"));

    if (_aryUndo.Size() == 0)
        return S_OK;

    //
    // Put ourself on the undo manager's Redo stack.
    //
    if (pUndoManager)
    {
        hr = THR(pUndoManager->Open(this));
        if (hr)
            goto Cleanup;
    }

    //
    // Call Do() on all the units. This call makes a copy of the array and
    // removes the units from _aryUndo before making any calls to Do().
    //
    hr = THR(DoTo(pUndoManager, &_aryUndo, _aryUndo[0], FALSE));

    //
    // _fUnitSucceeded will be TRUE after calling DoTo only if at least
    // one of our contained units was successful. In this case we need to
    // commit ourselves, even if an error occurred.
    //

    if (pUndoManager)
    {
        HRESULT hr2;
        BOOL    fCommit = TRUE;

        //
        // If we are empty or none of our contained units succeeded then do
        // not commit ourselves.
        //
        if (!_fUnitSucceeded || (_aryUndo.Size() == 0))
        {
            TraceTag((tagUndo, "Not committing parent unit to redo stack."));
            fCommit = FALSE;
        }

        hr2 = THR(pUndoManager->Close(this, fCommit));
        //
        // Preserve the HRESULT from the call to DoTo() if it failed.
        //
        if (!hr && FAILED(hr2))
        {
            hr = hr2;
        }
    }

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CParentUndo Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndo::Start, public
//
//  Synopsis:   Create the undo unit and open it
//
//----------------------------------------------------------------------------
HRESULT
CParentUndo::Start(UINT uiStringID)
{
    _puu = _pBase->OpenParentUnit( _pBase, uiStringID );

    return S_OK;
}

HRESULT
CParentUndo::Start(TCHAR * pchDescription)
{
    _puu = _pBase->OpenParentUnit( _pBase, 0, pchDescription );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndo::Finish, public
//
//  Synopsis:   Close the parent unit
//
//----------------------------------------------------------------------------
HRESULT
CParentUndo::Finish(HRESULT hrCommit)
{
    HRESULT hr;

    hr = THR( _pBase->CloseParentUnit( _puu, hrCommit ) ); 
    if( hr )
        goto Cleanup;

Cleanup:
    _puu = NULL;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  CUndoPropChange Implementation
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::CUndoPropChange, public
//
//  Synopsis:   Object ctor
//
//----------------------------------------------------------------------------

CUndoPropChange::CUndoPropChange(CBase * pBase,
                                 UINT    uiStringID)
    : CUndoUnitBase(pBase, uiStringID)
{
    Assert(pBase);

    TraceTag((tagUndo, "CUndoPropChange ctor"));

    pBase->PrivateAddRef();

    VariantInit(&_varData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::~CUndoPropChange, public
//
//  Synopsis:   Undo unit dtor
//
//----------------------------------------------------------------------------

CUndoPropChange::~CUndoPropChange()
{
    TraceTag((tagUndo, "CUndoPropChange dtor"));

    _pBase->PrivateRelease();
    
    VariantClear(&_varData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::Init, public
//
//  Synopsis:   Initializes the undo unit for an integer property that is
//              changing.  The function takes ownership of the variant
//              passed in.
//
//  Arguments:  [dispidProp] -- Dispid of property.
//              [pvar] -- the old value, as a variant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChange::Init(DISPID dispidProp, VARIANT* pvar)
{
    TraceTag((tagUndo, "CUndoPropChange::Init"));

    HRESULT hr = S_OK;

    // Take ownership of the variant
    _varData = *pvar;
    VariantInit( pvar );

    _dispid  = dispidProp;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CUndoPropChange::PrivateDo, public
//
//  Synopsis:   Performs the undo of the property change.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CUndoPropChange::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT       hr;
    IDispatch   * pDisp = NULL;
    DWORD         dwCookie = 0;

    TraceTag((tagUndo, "CUndoPropChange::Do"));

    hr = THR(_pBase->PunkOuter()->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp));
    if (hr)
        goto Cleanup;

    //
    // The redo unit should be put on the stack in this call to Invoke()
    // unless we need to disable it.
    //
    if (!pUndoManager)
    {
        _pBase->BlockNewUndoUnits(&dwCookie);
    }

    // NOTE: might want to have different way to specify unset method
    if (V_VT(&_varData) == VT_NULL)
    {
        PROPERTYDESC * pPropDesc = NULL;

        // No propdesc's for expandos, and we don't need them, anyway.
        if( !_pBase->IsExpandoDISPID( _dispid ) )
        {
            hr = THR(_pBase->FindPropDescFromDispID(_dispid, &pPropDesc, NULL, NULL));
            if (hr)
                goto Cleanup;
        }

        _pBase->removeAttributeDispid( _dispid, pPropDesc );
    }
    else
    {
        hr = THR(SetDispProp(
                       pDisp,
                       _dispid,
                       g_lcidUserDefault,
                       &_varData,
                       NULL));
    }

    if (!pUndoManager)
    {
        _pBase->UnblockNewUndoUnits(dwCookie);
    }

Cleanup:
    ReleaseInterface(pDisp);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\sdocobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       docobj.cxx
//
//  Contents:   Implementation for IOleDocument and IOleDocumentView
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


DeclareTag(tagMsoView, "IOleDocumentView", "IOleDocumentView methods in CServer")
DeclareTag(tagMsoDoc, "IOleDocument", "IOleDocument methods in CServer")


//+-------------------------------------------------------------------------
//
//  IOleDocument implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CServer::CreateView, IOleDocument
//
//  Synopsis:   Asks the document to create a new viewand optionally
//              make the view initialize its view state from the given
//              stream.  Fails if we support only one view and this
//              method has already been called.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::CreateView(
        IOleInPlaceSite * pIPSite,
        IStream * pStm,
        DWORD dwReserved,
        IOleDocumentView ** ppView)
{
    HRESULT         hr;

    TraceTag((tagMsoDoc, "CServer::CreateView"));
    Assert(_fMsoDocMode);
    Assert(pIPSite);

    if (_fMsoViewExists)
    {
        RRETURN(E_FAIL);
    }

    hr = THR(EnsureInPlaceObject());
    if (hr)
        goto Cleanup;

    hr = THR(SetInPlaceSite(pIPSite));
    if (hr)
        goto Cleanup;

    if (pStm)
    {
        IGNORE_HR(ApplyViewState(pStm));
    }

    hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView));
    if (hr)
        goto Cleanup;

    _fMsoViewExists = TRUE;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetDocMiscStatus, IOleDocument
//
//  Synopsis:   Returns miscellaneous information about the doc object.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::GetDocMiscStatus(DWORD * pdwStatus)
{
    TraceTag((tagMsoDoc, "CServer::GetDocMiscStatus"));
    Assert(_fMsoDocMode);

    *pdwStatus = DOCMISC_CANTOPENEDIT | DOCMISC_NOFILESUPPORT;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::EnumViews, IOleDocument
//
//  Synopsis:   Enumerates the views of the document.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

STDMETHODIMP
CServer::EnumViews(IEnumOleDocumentViews ** ppEnumViews, IOleDocumentView ** ppView)
{
    TraceTag((tagMsoDoc, "CServer::EnumViews"));
    Assert(_fMsoDocMode);

    HRESULT hr = S_OK;

    *ppEnumViews = NULL;

    if (_fMsoViewExists)
    {
        hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView));
    }
    else
    {
        *ppView = NULL;
    }

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  IOleDocumentView implementation
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetInPlaceSite, IOleDocumentView
//
//  Synopsis:   Detaches from the existing docsite, inplace deactivates
//              and saves new pointer.
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetInPlaceSite(IOleInPlaceSite * pIPSite)
{
    HRESULT hr = S_OK;
    IOleInPlaceSiteEx * pIPSiteEx = NULL;
    
    TraceTag((tagMsoView, "CServer::SetInPlaceSite"));
    Assert(_fMsoDocMode);

    IGNORE_HR(InPlaceDeactivate());
    if (pIPSite)
    {
        hr = THR(EnsureInPlaceObject());
        if (hr)
            goto Cleanup;

        if (!(THR_NOTRACE(pIPSite->QueryInterface(
                   IID_IOleInPlaceSiteEx, (void **)&pIPSiteEx))))
        {
            //
            // This is really something that supports InPlaceSiteEx
            //

            _pInPlace->_fUseExtendedSite = TRUE;
            ReplaceInterface(
                &_pInPlace->_pInPlaceSite, 
                (IOleInPlaceSite *)pIPSiteEx);
        }
        else
        {
            _pInPlace->_fUseExtendedSite = FALSE;
            ReplaceInterface(&_pInPlace->_pInPlaceSite, pIPSite);
        }
        ReleaseInterface(pIPSiteEx);
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetInPlaceSite, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetInPlaceSite(IOleInPlaceSite ** ppIPSite)
{
    TraceTag((tagMsoView, "CServer::GetInPlaceSite"));
    Assert(_fMsoDocMode);

    if (_pInPlace && _pInPlace->_pInPlaceSite)
    {
        _pInPlace->_pInPlaceSite->AddRef();
        
        *ppIPSite = _pInPlace->_pInPlaceSite;
    }
    else
    {
        *ppIPSite = NULL;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetDocument, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetDocument(IUnknown ** ppUnk)
{
    TraceTag((tagMsoView, "CServer::GetDocument"));
    Assert(_fMsoDocMode);

    // cast to any non-tearoff interface
    *ppUnk = (IViewObject *)this;
    (*(IUnknown **) ppUnk)->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetRect, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetRect(LPRECT prcView)
{
    long lDirty = 0;
    HRESULT hr = S_OK;
    SIZEL sizel;

    TraceTag((tagMsoView, "CServer::SetRect"));
    Assert(_fMsoDocMode);

    // NOTE (garybu): SHDOCVW incorrect calls this method
    // before we are inplace activated. Look at bug 20233
    // for more info about this if statement.
    if (State() < OS_INPLACE)
    {
        goto Cleanup;
    }

    sizel.cx = HimetricFromHPix(prcView->right - prcView->left);
    sizel.cy = HimetricFromVPix(prcView->bottom - prcView->top);

    if (sizel.cx != _sizel.cx || sizel.cy != _sizel.cy)
    {
        hr = THR(SetExtent(DVASPECT_CONTENT, &sizel));
        if (hr)
            goto Cleanup;
        //
        // TODO - marka bug for 10161
        // notifications are inadvertently setting dirtiness.
        // this must be fixed for beta2
        //
        lDirty = _lDirtyVersion;
        hr = THR(SetObjectRects(ENSUREOLERECT(prcView), ENSUREOLERECT(prcView)));
        if ( ( ! lDirty ) && ( _lDirtyVersion ))
            _lDirtyVersion = 0;
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::GetRect, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::GetRect(LPRECT prcView)
{
    TraceTag((tagMsoView, "CServer::GetRect"));

    Assert(_pInPlace);
    Assert(_fMsoDocMode);

    *prcView = _pInPlace->_rcPos;
    OffsetRect(prcView, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SetRectComplex, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SetRectComplex(
        LPRECT lprcView,
        LPRECT lprcHScroll,
        LPRECT lprcVScroll,
        LPRECT lprcSizeBox)
{
    TraceTag((tagMsoView, "CServer::SetRectComplex"));
    Assert(_fMsoDocMode);

    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Show, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Show(BOOL fShow)
{
    HRESULT     hr = S_OK;

    TraceTag((tagMsoView, "CServer::Show"));
    Assert(_fMsoDocMode);

    if (fShow)
    {
        if (_state < OS_INPLACE)
        {
            hr = THR(TransitionTo(OS_INPLACE, NULL));
            if (hr)
                goto Cleanup;
        }

        if (_pInPlace->_hwnd)
        {
            ShowWindow(_pInPlace->_hwnd, SW_SHOWNORMAL);
        }
    }
    else
    {
        if (_state == OS_UIACTIVE)
        {
            IGNORE_HR(UIActivate(FALSE));
        }

        if (_state >= OS_INPLACE && _pInPlace->_hwnd)
        {
            ShowWindow(_pInPlace->_hwnd, SW_HIDE);
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::UIActivate, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::UIActivate(BOOL fActivate)
{
    HRESULT     hr = S_OK;
    long lDirtyBefore;
    TraceTag((tagMsoView, "CServer::UIActivate"));
    Assert(_fMsoDocMode);

    lDirtyBefore = _lDirtyVersion;
    if (fActivate && (_state < OS_UIACTIVE))
    {
        hr = THR(TransitionTo(OS_UIACTIVE, NULL));
    }
    else if ((fActivate == FALSE) && (_state == OS_UIACTIVE))
    {
        IGNORE_HR(UIDeactivate());
    }
    //
    // TODO ( marka) - HACK for Bug 10161
    // to be fixed post beta 2
    //
    if ( ( ! lDirtyBefore  ) && ( _lDirtyVersion))
        _lDirtyVersion = 0;
        
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Open, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Open(void)
{
    TraceTag((tagMsoView, "CServer::Open"));
    Assert(_fMsoDocMode);

    //
    //  No view frame of our own
    //

    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::CloseView, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::CloseView(DWORD dwReserved)
{
    TraceTag((tagMsoView, "CServer::CloseView"));
    Assert(_fMsoDocMode);

    //
    //  Implementation of IOleDocumentView::CloseView - we support
    //  only one view.  Send the view the NULL InPlaceSite.
    //

    IGNORE_HR(SetInPlaceSite(NULL));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::SaveViewState, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::SaveViewState(IStream * pStm)
{
    TraceTag((tagMsoView, "CServer::SaveViewState"));
    Assert(_fMsoDocMode);

    //  No view state for now
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::ApplyViewState, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::ApplyViewState(IStream * pStm)
{
    TraceTag((tagMsoView, "CServer::ApplyViewState"));
    Assert(_fMsoDocMode);

    //  No view state for now
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CServer::Clone, IOleDocumentView
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//--------------------------------------------------------------------------

HRESULT
CServer::Clone(IOleInPlaceSite * pNewIPSite, IOleDocumentView ** ppNewView)
{
    TraceTag((tagMsoView, "CServer::Clone"));
    Assert(_fMsoDocMode);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\recalchlp.cxx ===
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       recalc.cxx
//
//  Contents:   CBase recalc support
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECALC_H_
#define X_RECALC_H_
#include <recalc.h>
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

MtDefine(CRecalcInfo, ObjectModel, "CRecalcInfo")

//---------------------------------------------------------------
//
//  Member:     CBase::removeExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::removeExpression(BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}

//---------------------------------------------------------------
//
//  Member:     CBase::setExpression
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::setExpression(BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}

//---------------------------------------------------------------
//
//  Member:     CBase::getExpression
//
// REVIEW michaelw : need to add a language parameter to allow
// REVIEW michaelw : the caller to get the expression language
//
//---------------------------------------------------------------
STDMETHODIMP
CBase::getExpression(BSTR strPropertyName, VARIANT *pvExpression)
{
    AssertSz(0, "CBase recalc methods should never be called");
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\prophelp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       prophelp.cxx
//
//  Contents:   Some functions to help in dealing with object properties
//
//  Functions:  GetCommonPropertyValue
//              SetCommonPropertyValue
//
//  History:    29-Jun-93   SumitC      Created.
//              26-Oct-93   DonCl       Error code usage
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

HRESULT
SetFontProperty(
        UINT        cUnk,
        IUnknown ** apUnk,
        LOGFONT     lf,
        CY          cy);

//+------------------------------------------------------------------------
//
//  Function:   IsSameFontValue
//
//  Synopsis:   Checks to see if two font objects have the same value
//
//-------------------------------------------------------------------------

BOOL
IsSameFontValue(VARIANT * pvar1, VARIANT * pvar2)
{
    HRESULT     hr = S_OK;
    IFont *     pFont1 = NULL;
    IFont *     pFont2 = NULL;

    Assert(V_VT(pvar1) == VT_DISPATCH);
    Assert(V_VT(pvar2) == VT_DISPATCH);

    hr = V_DISPATCH(pvar1)->QueryInterface(IID_IFont, (void **)&pFont1);
    if (hr)
        goto Cleanup;

    hr = V_DISPATCH(pvar2)->QueryInterface(IID_IFont, (void **)&pFont2);
    if (hr)
        goto Cleanup;

    hr = pFont1->IsEqual(pFont2);

Cleanup:
    ReleaseInterface(pFont1);
    ReleaseInterface(pFont2);
    return hr ? FALSE : TRUE;
}


//+---------------------------------------------------------------
//
//  Member:     FindFontObject
//
//  Synopsis:   Find font object in a control set
//
//  Notes:      Helper function for OpenFontDialog()
//
//---------------------------------------------------------------
#ifndef NO_PROPERTY_PAGE
HRESULT
FindFontObject(
        UINT        cUnk,
        IUnknown ** apUnk,
        IFont **    ppFont)
{
    HRESULT         hr = S_OK;
    UINT            i;
    VARIANT         var;
    IDispatch *     pDispatch = NULL;

    VariantInit(&var);

    // Find the first control supports font
    for (i = 0; i < cUnk; i++)
    {
        hr = apUnk[i]->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = GetDispProp(
            pDispatch,
            DISPID_FONT,
            g_lcidUserDefault,
            &var,
            NULL);

        if (hr)
        {
            // The control does not suport font, continue on next one
            ClearInterface(&pDispatch);
            VariantClear(&var);
            continue;
        }
        else
        {
            // Find a font object, stop here
            Assert(V_VT(&var) == VT_DISPATCH);
            hr = V_DISPATCH(&var)->QueryInterface(IID_IFont, (void **)ppFont);
            goto Cleanup;
       }
    }

Cleanup:
    ReleaseInterface(pDispatch);
    VariantClear(&var);
    RRETURN(hr);
}
#endif // NO_PROPERTY_PAGE

HRESULT
GetCommonSubObjectPropertyValue(
        DISPID      dispidMainObject,
        DISPID      dispidSubObject,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr                  = S_OK;
    UINT        i;
    VARIANT     var;
    VARIANT     varDispatch;
    BOOL        fCommonValueExists  = TRUE;
    EXCEPINFO   ei;

    VariantInit(pVar);
    VariantInit(&var);
    VariantInit(&varDispatch);

    InitEXCEPINFO(&ei);

    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; fCommonValueExists && i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispidMainObject,
                g_lcidUserDefault,
                &varDispatch,
                &ei);

        if (hr)
            goto Error;

        // Now get the sub object identified by dispidSubObject
        hr = GetDispProp(
                V_DISPATCH(&varDispatch), 
                dispidSubObject,
                g_lcidUserDefault,
                i == 0 ? pVar : &var,
                &ei);

        if (hr)
            goto Error;

        if (i > 0)
        {
            fCommonValueExists = IsVariantEqual(pVar, &var);
        }

        VariantClear(&var);
        VariantClear(&varDispatch);
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    if (!hr)
    {
        hr = !fCommonValueExists;
    }

    FreeEXCEPINFO(&ei);
    RRETURN2(hr, S_FALSE, DISP_E_MEMBERNOTFOUND);

Error:
    VariantClear(pVar);
    VariantClear(&varDispatch);
    VariantClear(&var);
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Function:   GetCommonPropertyValue
//
//  Synopsis:   Checks to see if an array of objects all have the same value
//              for a given property, returning the value of that property
//              if so.
//
//  Arguments:  [dispid]        --  Property id
//              [cDisp]         --  Number of objects in array
//              [apDisp]        --  Array of objects
//              [pVar]          --  The shared property value is returned
//                                  in *pVar
//
//  Notes:
//              If all the objects support the given property, but the
//              values don't match, this function returns S_FALSE.  The
//              variant returned will have the value of the first
//              object's property.
//
//              If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI); S_OK, S_FALSE, or error
//              Also sets the current error object.
//
//-------------------------------------------------------------------------

HRESULT
GetCommonPropertyValue(
        DISPID      dispid,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr                  = S_OK;
    UINT        i;
    VARIANT     var;
    BOOL        fCommonValueExists  = TRUE;
    EXCEPINFO   ei;

    VariantInit(pVar);
    VariantInit(&var);
    InitEXCEPINFO(&ei);

    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; fCommonValueExists && i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispid,
                g_lcidUserDefault,
                i == 0 ? pVar : &var,
                &ei);

        if (hr)
            goto Error;

        if (i > 0)
        {
            if (DISPID_FONT == dispid)
            {
                fCommonValueExists = IsSameFontValue(pVar, &var);
            }
            else
            {
                fCommonValueExists = IsVariantEqual(pVar, &var);
            }
        }

        VariantClear(&var);
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    if (!hr)
    {
        hr = !fCommonValueExists;
    }

    FreeEXCEPINFO(&ei);
    RRETURN2(hr, S_FALSE, DISP_E_MEMBERNOTFOUND);

Error:
    VariantClear(pVar);
    goto Cleanup;
}

HRESULT
SetCommonSubObjectPropertyValue(
        DISPID      dispidMainObject,
        DISPID      dispidSubObject,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr       = S_OK;
    UINT        i;
    EXCEPINFO   ei;
    VARIANT     varDispatch;

    VariantInit(&varDispatch);

    InitEXCEPINFO(&ei);
    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; i < cDisp; i++)
    {
        hr = GetDispProp(
                apDisp[i], 
                dispidMainObject,
                g_lcidUserDefault,
                &varDispatch,
                &ei);

        if (hr)
            goto Cleanup;

        hr = SetDispProp(
                V_DISPATCH(&varDispatch),
                dispidSubObject,
                g_lcidUserDefault,
                pVar,
                &ei);

        VariantClear(&varDispatch);

        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    FreeEXCEPINFO(&ei);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   SetCommonPropertyValue
//
//  Synopsis:   Sets a property value on an array of objects
//
//  Arguments:  [dispid]        --  Property id
//              [cDisp]         --  Number of objects in array
//              [apDisp]        --  Objects
//              [pVar]          --  New property value
//
//  Notes:      If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI)
//              Also sets the current error object.
//
//-------------------------------------------------------------------------

HRESULT
SetCommonPropertyValue(
        DISPID      dispid,
        UINT        cDisp,
        IDispatch ** apDisp,
        VARIANT *   pVar)
{
    HRESULT     hr       = S_OK;
    UINT        i;
    EXCEPINFO   ei;

    InitEXCEPINFO(&ei);
    if (cDisp == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    for (i = 0; i < cDisp; i++)
    {
        hr = SetDispProp(
                apDisp[i],
                dispid,
                g_lcidUserDefault,
                pVar,
                &ei);

        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (hr)
    {
        IGNORE_HR(SetErrorInfoFromEXCEPINFO(&ei));
    }

    FreeEXCEPINFO(&ei);
    RRETURN(hr);
}


#ifndef NO_PROPERTY_PAGE
UINT_PTR CALLBACK ChooseFontCallback
(
    HWND hwnd,
    UINT msg,
    WPARAM wp,
    LPARAM lp
)
{
    return 0;
}

//+------------------------------------------------------------------------
//
//  Function:   OpenFontDialog
//
//  Synopsis:   Open a font dialog, which is used to set font property.
//
//  Arguments:  [pBase]         --  point to class where this func is called
//                                  It is used to create undo action
//              hWnd            --  point to owner window of dialog
//              [cUnk]          --  Number of objects in array
//              [apUnk]         --  Array of objects
//              [fUndo]         --  Indicate if need to create undo action
//              [pfRet]         --  reture value indicating if use click OK
//
//
//  Notes:
//              The objects are not IDispatch pointers, just regular old
//              IUnknowns.  If an object in the array doesn't support
//              IID_IDispatch, this function will return an error.
//
//              The font value displayed in dialog is the first
//              object's property.
//
//              If cUnk == 0, this function returns E_INVALIDARG
//
//  Returns:    HRESULT (STDAPI); S_OK, S_FALSE, or error
//              Also sets the current error object.
//
//-------------------------------------------------------------------------
HRESULT
OpenFontDialog(
        CBase *     pBase,
        HWND        hWnd,
        UINT        cUnk,
        IUnknown ** apUnk,
        BOOL *      pfRet)
{
    HRESULT         hr;
    LOGFONT         lf;
    CHOOSEFONT      cf;
    IFont *         pFont = NULL;
    CY              cy;
    BOOL            fBold = FALSE;
    BOOL            fItalic = FALSE;
    BOOL            fUnderline = FALSE;
    BOOL            fStrikethrough = FALSE;
#ifdef _MAC
    short           sWeight;
#endif
    BSTR            bstr = NULL;
    BOOL            fRet = FALSE;
    short           sCharSet = FALSE;
    
    cy.Lo = cy.Hi = 0;

    if (cUnk == 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(FindFontObject(cUnk, apUnk, &pFont));
    if (hr)
        goto Cleanup;

    // Get current font information
    if (pFont)
    {
        pFont->get_Name(&bstr);
        pFont->get_Size(&cy);
        pFont->get_Bold(&fBold);
        pFont->get_Italic(&fItalic);
        pFont->get_Underline(&fUnderline);
        pFont->get_Strikethrough(&fStrikethrough);
#ifdef _MAC
        pFont->get_Weight(&sWeight);
#endif
        pFont->get_Charset(&sCharSet);
    }

    // Fill in LOGFONT struct
    memset(&lf, 0, sizeof(LOGFONT));
    _tcsncpy(lf.lfFaceName, bstr, SysStringLen(bstr));
    lf.lfHeight = (int) (cy.Lo * g_uiDisplay.GetResolution().cy / 720000L);

    lf.lfItalic     = !!fItalic;
    lf.lfWeight     = fBold ? 700: 400;
    lf.lfStrikeOut  = !!fStrikethrough;
    lf.lfUnderline  = !!fUnderline;
    lf.lfCharSet    = (BYTE) sCharSet;
#ifdef _MAC
    // mac note: we are using the high order bits of the IFont weight member
    //      to hold the outline and shadow flags.  Since the IFont Weight
    //      interface has the weight as a short, we must move the flags
    //      to the "long" end of the lfWeight field passing it on.
    if( sWeight & MAC_OUTLINE )
        lf.lfWeight     |= FW_OUTLINE;
    if( sWeight & MAC_SHADOW )
        lf.lfWeight     |= FW_SHADOW;
#endif

    // Fill in CHOOSEFONT struct
    memset(&cf, 0, sizeof(CHOOSEFONT));
    cf.lStructSize  = sizeof(CHOOSEFONT);
    cf.hwndOwner    = hWnd;
    cf.hDC          = NULL;
    cf.lpLogFont    = &lf;
    cf.iPointSize   = cy.Lo/1000;
    cf.Flags        = CF_SCREENFONTS |
                      CF_INITTOLOGFONTSTRUCT |
                      CF_FORCEFONTEXIST |
                      CF_EFFECTS |
                      CF_ENABLEHOOK;
    cf.lCustData    = 0;
    cf.lpfnHook     = ChooseFontCallback;
    cf.hInstance    = NULL;
    cf.nFontType    = SCREEN_FONTTYPE;

    //
    //  Open font dialog
    //
    fRet = ChooseFont(&cf);
    if (fRet)
    {
#ifndef NO_EDIT
        CParentUndoUnit *pCPUU = NULL;

        pCPUU = pBase->OpenParentUnit(pBase, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT
        cy.Lo = cf.iPointSize * 1000;

        hr = SetFontProperty(cUnk, apUnk, lf, cy);
#ifndef NO_EDIT
        pBase->CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
    }

Cleanup:
    if (pfRet)
    {
        *pfRet = fRet;
    }
    FormsFreeString(bstr);
    ReleaseInterface(pFont);

    RRETURN(hr);
}
#endif // NO_PROPERTY_PAGE



//+---------------------------------------------------------------
//
//  Member:     SetFontProperty
//
//  Synopsis:   Set font property to selected objects
//
//  Notes:      Helper function for OpenFontDialog()
//
//---------------------------------------------------------------
HRESULT
SetFontProperty(
        UINT        cUnk,
        IUnknown ** apUnk,
        LOGFONT     lf,
        CY          cy)
{
    HRESULT         hr = S_OK;
    IDispatch *     pDispatch = NULL;
    IFont *         pFont = NULL;
    BSTR            bstr = NULL;
    VARIANT         var;
    UINT            i;

    //MAKEBSTR does nothing on Intel Platform, recent change in
    //CFontNew::put_NameHelper(BSTR bstrName) of fontutil.cxx
    //has some code calling SysStringLen, which must be a real
    //BSTR
    hr = FormsReAllocString(&bstr , lf.lfFaceName);
    if (hr)
        goto Cleanup;

    VariantInit(&var);
    for (i = 0; i < cUnk; i++)
    {
        hr = apUnk[i]->QueryInterface(IID_IDispatch, (LPVOID *) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = GetDispProp(
                pDispatch,
                DISPID_FONT,
                g_lcidUserDefault,
                &var,
                NULL);
        if (hr)
            goto Cleanup;

        Assert(V_VT(&var) == VT_DISPATCH);
        hr = V_DISPATCH(&var)->QueryInterface(IID_IFont, (void **)&pFont);
        if (hr)
            goto Cleanup;

        pFont->put_Size(cy);
        pFont->put_Name(bstr);
        pFont->put_Bold((lf.lfWeight == 400) ? FALSE : TRUE);
        pFont->put_Italic(lf.lfItalic);
        pFont->put_Underline(lf.lfUnderline);
        pFont->put_Strikethrough(lf.lfStrikeOut);
        pFont->put_Charset(lf.lfCharSet);
#ifdef _MAC
        // mac note: we are using the high order bits of the weight member
        //      to hold the outline and shadow flags.  Since the IFont put_Weight
        //      interface has the weight as a short, we must move the flags
        //      to the "short" end of the field before casting it out.
        if( lf.lfWeight & FW_OUTLINE )
            lf.lfWeight     |= MAC_OUTLINE;
        if( lf.lfWeight & FW_SHADOW )
            lf.lfWeight     |= MAC_SHADOW;

        pFont->put_Weight((short)lf.lfWeight);
#endif

        ClearInterface(&pDispatch);
        ClearInterface(&pFont);
        VariantClear(&var);
    }

Cleanup:
    ReleaseInterface(pDispatch);
    ReleaseInterface(pFont);
    FormsFreeString(bstr);
    VariantClear(&var);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\sinpl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       sinpl.cxx
//
//  Contents:   Implementation of the CServer inplace functionality
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag(tagCServer, "Server", "Server base class stuff")
DeclareTag(tagRects,   "ServerRects", "Position rect, clip rect, extent")
MtDefine(CInPlace, CDoc, "CInPlace")

#ifndef NO_IME
extern BOOL DIMMHandleDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
#endif

#ifndef WS_EX_LAYOUTRTL // winuser.h defines this for WINVER >= 0x0500
#define WS_EX_LAYOUTRTL 0x00400000L //Right-to-left mirroring, as used in NT5
#endif

//  Size of in-place border

#define CX_IPBORDER     4
#define CY_IPBORDER     4
#define CX_HANDLEINSET  1
#define CY_HANDLEINSET  1


//+---------------------------------------------------------------------------
//
//  Function:   DrawUIActiveBorder
//
//  Synopsis:   Draw the UI Active border
//
//  Arguments:  hdcDraw     Draw into this dc.
//              prc         Draw border inside this rectangle.
//              fHatch      If true, draw hatch border
//              fHandles    If true, draw grab handles
//
//----------------------------------------------------------------------------

void
DrawUIActiveBorder(HDC hdcDraw, RECT * prc, BOOL fHatch, BOOL fHandles)
{
    int     i;
    GDIRECT    rc;
    HBRUSH  hbr;

    if (fHatch)
    {
        hbr = GetCachedBmpBrush(IDR_HATCHBMP);

        SetTextColor(hdcDraw, RGB(0, 0, 0));
        SetBkColor(hdcDraw, RGB(255, 255, 255));

        for (i = 0; i < 4; i++)
        {
            rc = *prc;

            switch (i)
            {
                case 0:  rc.right  = rc.left   + CX_IPBORDER; break;
                case 1:  rc.left   = rc.right  - CX_IPBORDER; break;
                case 2:  rc.bottom = rc.top    + CY_IPBORDER; break;
                case 3:  rc.top    = rc.bottom - CY_IPBORDER; break;
            }

            FillRect(hdcDraw, &rc, hbr);
        }
    }

    if (fHandles)
    {
        hbr = (HBRUSH) GetStockObject(BLACK_BRUSH);

        //
        // Grab handle rectangles:
        //
        //   +-----+------+----+------+-----+
        //   |  0  |      | 1  |      |  2  |
        //   +---+-+      +----+      +-+---+
        //   | 3 |                      | 4 |
        //   +---+                      +---+
        //   |                              |
        //   |                              |
        //   +---+                      +---+
        //   | 5 |                      | 6 |
        //   +---+                      +---+
        //   |                              |
        //   |                              |
        //   +---+                      +---+
        //   | 7 |                      | 8 |
        //   +---+-+      +----+      +-+---+
        //   |  9  |      | 10 |      | 11  |
        //   +-----+------+----+------+-----+
        //

        for (i = 0; i < 12; i++)
        {

            // Compute left and right of rectangle.

            switch (i)
            {
                case 3:
                case 5:
                case 7:
                    rc.left = prc->left;
                    rc.right = rc.left + CX_IPBORDER;
                    break;

                case 0:
                case 9:
                    rc.left = prc->left;
                    rc.right = rc.left + CX_IPBORDER + CX_HANDLEINSET;
                    break;

                case 1:
                case 10:
                    rc.left = (prc->left + prc->right - CX_IPBORDER) / 2;
                    rc.right = rc.left + CX_IPBORDER + CX_HANDLEINSET;
                    break;

                case 2:
                case 11:
                    rc.right = prc->right;
                    rc.left = rc.right - CX_IPBORDER - CX_HANDLEINSET;
                    break;

                case 4:
                case 6:
                case 8:
                    rc.right = prc->right;
                    rc.left = rc.right - CX_IPBORDER;
                    break;
            }

            // Compute top and bottom of rectangle.

            switch (i)
            {
                case 0:
                case 1:
                case 2:
                    rc.top = prc->top;
                    rc.bottom = rc.top + CY_IPBORDER;
                    break;

                case 3:
                case 4:
                    rc.top = prc->top + CY_IPBORDER;
                    rc.bottom = rc.top + CY_HANDLEINSET;
                    break;

                case 5:
                case 6:
                    rc.top = (prc->top + prc->bottom - CY_IPBORDER) / 2;
                    rc.bottom = rc.top + CY_IPBORDER + CY_HANDLEINSET;
                    break;

                case 7:
                case 8:
                    rc.top = prc->bottom - CY_IPBORDER - CY_HANDLEINSET;
                    rc.bottom = rc.top + CY_HANDLEINSET;
                    break;

                case 9:
                case 10:
                case 11:
                    rc.bottom = prc->bottom;
                    rc.top = rc.bottom - CY_IPBORDER;
                    break;
            }

            FillRect(hdcDraw, &rc, hbr);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   CInPlace
//
//  Synopsis:   CInPlace object constructor
//
//  Arguments:  [pServer] -- CServer object that owns us
//
//----------------------------------------------------------------------------

CInPlace::CInPlace()
{
    _fUIDown        = TRUE;
    _fFrameActive   = TRUE;
    _fDocActive     = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInPlace
//
//  Synopsis:   CInPlace object destructor
//
//----------------------------------------------------------------------------

CInPlace::~CInPlace()
{
    ClearInterface(&_pInPlaceSite);
    ClearInterface(&_pFrame);
    ClearInterface(&_pDoc);
    ClearInterface(&_pDataObj);
    Assert(!_hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::EnsureInPlaceObject, CServer
//
//  Synopsis:   Creates the InPlace object when needed.
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

HRESULT
CServer::EnsureInPlaceObject()
{
    if (!_pInPlace)
    {
        _pInPlace = new CInPlace();
        if (!_pInPlace)
            RRETURN(E_OUTOFMEMORY);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::ActivateInPlace, CServer
//
//  Synopsis:   In-place activates the object
//
//  Returns:    Success if we in-place activated properly
//
//  Notes:      This method implements the standard in-place activation
//              protocol and creates the in-place window.
//
//----------------------------------------------------------------------------

HRESULT
CServer::ActivateInPlace(LPMSG lpmsg)
{
    HRESULT     hr;
    HWND        hWndSite;
    RECT        rcPos;
    RECT        rcVisible;
    BOOL        fUsingWindowlessSite = FALSE;
    BOOL        fNoRedraw = FALSE;
    WORD        wLockFlags;

    if (!_pClientSite)
        RRETURN(E_UNEXPECTED);

    hr = THR(EnsureInPlaceObject());
    if (hr)
        RRETURN(hr);

    Assert(_pInPlace);
    Assert(_pInPlace->_fWindowlessInplace == FALSE);
    _pInPlace->_fDeactivating = FALSE;

    // If we were not handed an inplace site through the
    // docobj interfaces, then negotiate for one now.

    if (!_pInPlace->_pInPlaceSite)
    {
        if (OK(_pClientSite->QueryInterface(
                    IID_IOleInPlaceSiteWindowless,
                    (void **)&_pInPlace->_pInPlaceSite)))
        {
            fUsingWindowlessSite = TRUE;
            _pInPlace->_fUseExtendedSite = TRUE;
        }
        else if (OK(_pClientSite->QueryInterface(
                IID_IOleInPlaceSiteEx,
                (void **)&_pInPlace->_pInPlaceSite)))
        {
            _pInPlace->_fUseExtendedSite = TRUE;
        }
        else
        {
            hr = THR(_pClientSite->QueryInterface(
                    IID_IOleInPlaceSite,
                    (void **) &(_pInPlace->_pInPlaceSite)));
            if (hr)
                goto Error;
        }
    }

    Assert(_pInPlace->_pInPlaceSite != NULL);

    hr = THR(_pInPlace->_pInPlaceSite->CanInPlaceActivate());
    if (hr == S_FALSE)
    {
        TraceTag((tagError, "Container refused InPlace activation!"));

        hr = E_FAIL;
        goto Error;
    }
    else if (hr)
        goto Error;

    if (_fWindowless && fUsingWindowlessSite)
    {
        hr = ((IOleInPlaceSiteWindowless *)
                (_pInPlace->_pInPlaceSite))->CanWindowlessActivate();
        _pInPlace->_fWindowlessInplace = (hr == S_OK);
    }

    // get information about position, size etc.

    _pInPlace->_frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

    hr = THR(_pInPlace->_pInPlaceSite->GetWindowContext(
                                        &_pInPlace->_pFrame,
                                        &_pInPlace->_pDoc,
                                        ENSUREOLERECT(&_pInPlace->_rcPos),
                                        ENSUREOLERECT(&_pInPlace->_rcClip),
                                        &_pInPlace->_frameInfo));
    if (hr)
        goto Error;

    if (_fMsoDocMode)
    {
        // Our _sizel has to match our view rect

        SIZEL sizel;

        sizel.cx = HimetricFromHPix(_pInPlace->_rcPos.right - _pInPlace->_rcPos.left);
        sizel.cy = HimetricFromVPix(_pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top);

        SetExtent(DVASPECT_CONTENT, &sizel);
    }

    // Check for the container requesting an infinite scale factor.

    if ((_sizel.cx == 0 && _pInPlace->_rcPos.right - _pInPlace->_rcPos.left != 0) ||
        (_sizel.cy == 0 && _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top != 0))
    {
        Assert(0 && "Host error: Infinite scale factor. Not a Forms error.");
        hr = E_FAIL;
        goto Error;
    }

    TraceTag((tagRects,
            "%08lx ActivateInPlace context pos=%ld %ld %ld %ld; clip=%ld %ld %ld %ld",
            this, _pInPlace->_rcPos, _pInPlace->_rcClip));

    DbgTrackItf(IID_IOleInPlaceFrame, "HostFrame", TRUE, (void **)&_pInPlace->_pFrame);

    TraceTag((tagRects, "%08lx ActivateInPlace extent=%ld %ld", this, _sizel.cx, _sizel.cy));

    if (!_pInPlace->_fWindowlessInplace)
    {
        rcPos = _pInPlace->_rcPos;

        _pInPlace->_ptWnd  = *(POINT *)&_pInPlace->_rcPos;
        OffsetRect(&_pInPlace->_rcPos,
                -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);
        OffsetRect(&_pInPlace->_rcClip,
                -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&hWndSite));
        if (hr)
            goto Error;

        TraceTag((tagRects, "%08lx ActivateInPlace > AttachWin %ld %ld %ld %ld", this, rcPos));

        hr = THR(AttachWin(hWndSite, &rcPos, &_pInPlace->_hwnd));
        if (hr)
            goto Error;

        IntersectRect(&rcVisible, &_pInPlace->_rcPos, &_pInPlace->_rcClip);
        if (!EqualRect(&rcVisible, &_pInPlace->_rcPos))
        {
            _pInPlace->_fUsingWindowRgn = TRUE;
            SetWindowRgn(_pInPlace->_hwnd, CreateRectRgnIndirect(&rcVisible), FALSE);
        }

    }
    else
    {
        _pInPlace->_ptWnd.x = _pInPlace->_ptWnd.y = 0;
    }

    //  Notify our container that we are going in-place active.
    //    Since the container may move us to some new state during
    //    the notification, we need to remember that we're already
    //    transitioning to OS_INPLACE.  If the container refuses
    //    the activation, then we unwind the partial transiton.

    _state = OS_INPLACE;

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    if (_pInPlace->_fUseExtendedSite)
    {
        hr = THR(((IOleInPlaceSiteEx *)_pInPlace->_pInPlaceSite)->
                OnInPlaceActivateEx(&fNoRedraw,
                    _pInPlace->_fWindowlessInplace ? ACTIVATE_WINDOWLESS : 0));
    }
    else
    {
        hr = THR(_pInPlace->_pInPlaceSite->OnInPlaceActivate());
    }

    Relock(wLockFlags);

    if (hr)
    {
        if (_state == OS_INPLACE)
            _state = OS_RUNNING;

        goto Error;
    }

    if (!fNoRedraw)
    {
        InvalidateRect(NULL, TRUE);
    }

Cleanup:
    RRETURN(hr);

Error:
    IGNORE_HR(DeactivateInPlace());
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUpdateEnum
//
//  Synopsis:   Called from EnumChildWindows, used to determine if
//              there's an update region for a child window.
//
//----------------------------------------------------------------------------

static BOOL CALLBACK
GetUpdateEnum(HWND hwnd, LPARAM lparam)
{
    if (GetUpdateRect(hwnd, (RECT *)NULL, 0))
    {
        *(BOOL *)lparam = TRUE;
        return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::DeactivateInPlace, CServer
//
//  Synopsis:   In-place deactivates the object
//
//  Returns:    Success except for catastophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateInPlace
//              including destroying the inplace active window.
//
//---------------------------------------------------------------

HRESULT
CServer::DeactivateInPlace()
{
    IOleInPlaceSite *   pInPlaceSite;
    BOOL                fRedraw;
    WORD                wLockFlags;

    Assert(_pInPlace);

    if (_pInPlace->_fUseExtendedSite && _pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        fRedraw = GetUpdateRect(_pInPlace->_hwnd, (RECT *)NULL, 0);
        if (!fRedraw)
        {
            EnumChildWindows(_pInPlace->_hwnd, GetUpdateEnum, (LPARAM)&fRedraw);
        }
        SetWindowPos(_pInPlace->_hwnd, NULL, 0, 0, 0, 0,
                SWP_HIDEWINDOW | SWP_NOMOVE | SWP_NOSIZE |
                SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
    }
    else
    {
        fRedraw = FALSE;
    }

    DetachWin();

    ClearInterface(&_pInPlace->_pFrame);
    ClearInterface(&_pInPlace->_pDoc);

    //  We use the in place site to send notification below, but
    //    we want to be fully deactivated before we make the call
    //    so that the container can reenter us.  To make this easier,
    //    we NULL out our member variable, but save the value for
    //    later use (and Release()'ing)

    pInPlaceSite = _pInPlace->_pInPlaceSite;

    //
    // Only do this if we were not activated as a docobject.
    // Is it ok to skip all the notifications down below?
    //
    
    if (!_fMsoDocMode)
    {
        _pInPlace->_pInPlaceSite = NULL;
    }

    _pInPlace->_fWindowlessInplace = FALSE;

    //  Notify our container that we're in-place deactivating

    Assert(_state == OS_INPLACE || _state == OS_RUNNING);
    if (_state == OS_INPLACE)
    {
        //  The container may reenter us, so need to remember that
        //    we've done almost all the transition to OS_RUNNING

        _state = OS_RUNNING;

        //  Errors from this notification are ignored (in the function
        //    which calls this one); we don't allow our container to stop
        //    us from in-place deactivating

        if (pInPlaceSite)
        {
            //  We allow the container to reenter us during this
            //    transition, so we need to unlock ourselves

            wLockFlags = Unlock(SERVERLOCK_TRANSITION);

            if (_pInPlace->_fUseExtendedSite)
            {
                IGNORE_HR(((IOleInPlaceSiteEx *)pInPlaceSite)->
                        OnInPlaceDeactivateEx(!fRedraw));
            }
            else
            {
                IGNORE_HR(pInPlaceSite->OnInPlaceDeactivate());
            }

            Relock(wLockFlags);
        }
    }

    if (!_fMsoDocMode)
    {
        ReleaseInterface(pInPlaceSite);
    }

    delete _pInPlace;
    _pInPlace = NULL;

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ActivateUI, CServer
//
//  Synopsis:   Notifies container of U.I. activation and installs our
//              U.I. elements.
//
//  Returns:    Success if our container granted permission to U.I. activate.
//
//  Notes:      Installing our U.I. (border toolbars, floating palettes,
//              adornments) is accomplished via a virtual call to InstallUI.
//
//---------------------------------------------------------------

HRESULT
CServer::ActivateUI(LPMSG lpmsg)
{
    HRESULT     hr;
    WORD        wLockFlags;

    Assert(_pInPlace);
    Assert(_pInPlace->_pInPlaceSite);

    //  We must remember we're in the process of UI Activating,
    //    since the container may move us to some new state
    //    in its notification method

    _state = OS_UIACTIVE;

    //  We allow the container to reenter us during this notification,
    //    so we need to unlock ourselves

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    hr = THR(_pInPlace->_pInPlaceSite->OnUIActivate());

    Relock(wLockFlags);

    if (hr)
    {
        //  If the container fails the OnUIActivate call, then we
        //    give up and stay IPA

        if (_state == OS_UIACTIVE)
            _state = OS_INPLACE;

        goto Cleanup;
    }

    //  NOTE: this is almost (but not quite) robust enough.  If by
    //    some quirk of fate the container caused us to de-UIActivate,
    //    then re-UIActivate us in the OnUIActivate call, then we
    //    would mistakenly re-install our UI below

    if (_state == OS_UIACTIVE && !_pInPlace->_fChildActivating)
    {
        hr = THR(InstallUI());
        if (hr)
            goto Error;

        if (!_fMsoDocMode &&
            (GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE) ||
             GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE)))
        {
            ShowUIActiveBorder(TRUE);
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    DeactivateUI();
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DeactivateUI, CServer
//
//  Synopsis:   Removes any U.I. we have installed and notifies our container
//              that we are no longer U.I. active
//
//  Returns:    Success except for catastrophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateUI.
//              U.I. elements are removed via a virtual call to RemoveUI
//
//---------------------------------------------------------------

HRESULT
CServer::DeactivateUI(void)
{
    WORD wLockFlags;

    //  Remove any UI that is up

    RemoveUI();
    ShowUIActiveBorder(FALSE);

    Assert(_pInPlace);

    _state = OS_INPLACE;

    //  Notify our container that we have deactivated.  Note that
    //    we don't let our container prevent us from UI Deactivating

    //  We need to unlock ourselves in case the container wants
    //    to reenter us during the OnUIDeactivate notification

    wLockFlags = Unlock(SERVERLOCK_TRANSITION);

    IGNORE_HR(_pInPlace->_pInPlaceSite->OnUIDeactivate(FALSE));

    Relock(wLockFlags);

    return S_OK; 
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InstallUI, CServer
//
//  Synopsis:   Installs previously created U.I. so it is displayed to
//              the user.
//
//  Notes:      This method will call the installframeUI and InstallDocUI
//              methods to install those U.I. elements, respectively.
//
//---------------------------------------------------------------

HRESULT
CServer::InstallUI(
    BOOL    fSetFocus)
{
    HRESULT hr = S_OK;

    if (!_pInPlace->_fChildActivating && !_pInPlace->_fDeactivating)
    {
        _pInPlace->_fUIDown = FALSE;

#ifndef NO_OLEUI
        hr = THR(InstallFrameUI());
        if (hr)
            goto Error;

        hr = THR(InstallDocUI());
        if (hr)
            goto Error;
#endif // NO_OLEUI

        // Set focus if requested
        // CONSIDER: This could perhaps be better tracked by watching the activation
        //         state of our container rather than passing flags into this routine.
        //         Unfortunately, tracking activation is difficult in the 96 code base.
        if (fSetFocus)
        {
            SetFocus(TRUE);
        }
    }

Cleanup:
    RRETURN(hr);

Error:
    RemoveUI();
    goto Cleanup;
}



//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveUI, CServer
//
//  Synopsis:   Removes previously installed U.I. so it is hidden from the
//              the user.
//
//  Notes:      This method "undoes" everything done in InstallUI.  It calls
//              the RemoveFrameUI and RemoveDocUI methods.
//
//---------------------------------------------------------------

void
CServer::RemoveUI(void)
{
    if (!_pInPlace->_fUIDown)
    {
        _pInPlace->_fUIDown = TRUE;

#ifndef NO_OLEUI
        RemoveDocUI();
        RemoveFrameUI();
#endif // NO_OLEUI
    }
}

//+--------------------------------------------------------------
//
//  Member:     CServer::DetachWin, CServer
//
//  Synopsis:   Detaches the child's in-place
//              window from the current parent.
//
//  Notes:      This destroys the _hwnd of the server.
//              If the derived class does anything
//              other than create a Window on AttachWin,
//              it must over-ride this function.
//              If the derived class destroys the window
//              on detach, it must set _hwnd = NULL
//
//---------------------------------------------------------------

void
CServer::DetachWin()
{
    Assert(_pInPlace);

    if (_pInPlace->_hwnd)
    {
        Assert(IsWindow(_pInPlace->_hwnd));
        Verify(DestroyWindow(_pInPlace->_hwnd));
        _pInPlace->_hwnd = NULL;
    }
    else if (_pInPlace->_fWindowlessInplace)
    {
        // Do windowless equivalent of DestroyWindow here.

        if (_pInPlace->_fFocus)
        {
            IGNORE_HR(((IOleInPlaceSiteWindowless*)
                    (_pInPlace->_pInPlaceSite))->SetFocus(FALSE));
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CServer::InstallFrameUI, CServer
//
//  Synopsis:   Installs the U.I. elements on the frame window.
//              This function assumes the server has does not
//              have any UI.  Derived classes should override
//              to provide their own UI.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
HRESULT
CServer::InstallFrameUI()
{
    THR_NOTRACE(_pInPlace->_pFrame->SetMenu(NULL, NULL, NULL));
    THR_NOTRACE(_pInPlace->_pFrame->SetBorderSpace(NULL));

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveFrameUI, CServer
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//
//              Servers that override the InstallFrameUI method will
//              also want to override this method.
//              This method is call by the RemoveUI method and on
//              document window deactivation for MDI-application purposes.
//
//---------------------------------------------------------------

void
CServer::RemoveFrameUI()
{
    if (_pInPlace->_pFrame)
    {
        IGNORE_HR(_pInPlace->_pFrame->SetMenu(NULL, NULL, NULL));
        THR_NOTRACE(_pInPlace->_pFrame->SetBorderSpace(NULL));
    };
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InstallDocUI, protected
//
//  Synopsis:   Installs the U.I. elements on the document window
//
//  Notes:      This method notifies the document window that we are
//              the active object.  Otherwise, there are no standard U.I. elements
//              installed on the document window.
//
//              Servers that have document window tools should override this
//              method.
//
//---------------------------------------------------------------

HRESULT
CServer::InstallDocUI(void)
{
    HRESULT hr = S_OK;
    TCHAR   ach[MAX_USERTYPE_LEN + 1];
    IOleInPlaceActiveObject *pInPlaceActiveObject = NULL;

    Assert(_pInPlace);

    if (_pInPlace->_pDoc != NULL)
    {
        Verify(LoadString(
                GetResourceHInst(),
                IDS_USERTYPESHORT(BaseDesc()->_idrBase),
                ach,
                ARRAY_SIZE(ach)));

        hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
        if (hr)
            goto Cleanup;

        hr = THR(_pInPlace->_pDoc->SetActiveObject(pInPlaceActiveObject, ach));
        if (hr)
            goto Error;

        IGNORE_HR(_pInPlace->_pDoc->SetBorderSpace(NULL));
    }

Cleanup:
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);

Error:
    RemoveDocUI();
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::RemoveDocUI, protected
//
//  Synopsis:   Removes the U.I. elements from the document window.
//
//  Notes:      This method "undoes" everything done in the InstallDocUI
//              method.
//
//              Servers that override the InstallDocUI method should
//              also override this method.
//
//---------------------------------------------------------------

void
CServer::RemoveDocUI(void)
{
    Assert(_pInPlace);

    if (_pInPlace->_pDoc != NULL)
    {
        _pInPlace->_pDoc->SetActiveObject(NULL, NULL);
    }
}
#endif // NO_OLEUI


//+---------------------------------------------------------------
//
//  Member:     CServer::GetHWND()
//
//  Synopsis:   Get window used by this CServer.
//
//---------------------------------------------------------------

HWND
CServer::GetHWND()
{
    // WARNING:  This code is very sensitive to the code
    // generator.  The alaising in the last else of the
    // ladder avoids the problem.  If you change this code,
    // please test it by right-clicking a UIActive MPC on
    // the "tab" in a ship build during design mode.  The
    // context menu should appear in the correct place and
    // be functional.  <rodc>

    HWND    hwnd;

    if (State() < OS_INPLACE)
    {
        hwnd = NULL;
    }
    else if (_pInPlace->_hwnd)
    {
        hwnd = _pInPlace->_hwnd;
    }
    else
    {
        HWND *  phwndtmp = &hwnd;

        if (_pInPlace->_pInPlaceSite->GetWindow(phwndtmp))
            hwnd = NULL;
    }

    return hwnd;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::GetWindow, IOleWindow
//
//  Synopsis:   Method of IOleWindow interface
//
//---------------------------------------------------------------

HRESULT
CServer::GetWindow(HWND FAR* lphwnd)
{
    if (_pInPlace == NULL)
        RRETURN_NOTRACE(E_FAIL);

    *lphwnd = _pInPlace->_hwnd;

#ifdef _MAC
	if (*lphwnd == NULL)
		*lphwnd = GetHWND();

    RRETURN_NOTRACE((*lphwnd ? S_OK : E_FAIL));
#else
    RRETURN_NOTRACE((_pInPlace->_hwnd ? S_OK : E_FAIL));
#endif
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Method of IOleWindow interface
//
//  Notes:      This method sets or clears the _fCSHelpMode
//              member flag.  The window procedure needs to pay
//              attention to the value of this flag in implementing
//              context-sensitive help.
//
//---------------------------------------------------------------

HRESULT
CServer::ContextSensitiveHelp(BOOL fEnterMode)
{
    _pInPlace->_fCSHelpMode = fEnterMode;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::InPlaceDeactivate, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method transitions the object to the loaded state
//              if the object is in the InPlace or U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::InPlaceDeactivate(void)
{
    HRESULT hr = S_OK;

    if (State() == OS_INPLACE || State() == OS_UIACTIVE)
    {
        _pInPlace->_fDeactivating = TRUE;
        hr = THR(TransitionTo(OS_RUNNING));

        //  If the in-place object is still around, clear the
        //    flag.  Note that the in-place object may have been
        //    destroyed by the transition to the OS_RUNNING state,
        //    or may not if the container is caching a pointer to
        //    any of the in-place interfaces. (chrisz)


        if (_pInPlace)
        {
            _pInPlace->_fDeactivating = FALSE;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::UIDeactivate, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      The method transitions the object to the in-place state
//              if the object is in U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::UIDeactivate(void)
{
    HRESULT hr = S_OK; 
    if (State() == OS_UIACTIVE)
    {
        _pInPlace->_fDeactivating = TRUE;
        hr = TransitionTo(OS_INPLACE);
        _pInPlace->_fDeactivating = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::SetObjectRects, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method does a Move window on the child
//              window to put it in its new position.
//
//---------------------------------------------------------------

HRESULT
CServer::SetObjectRects(LPCOLERECT prcPos, LPCOLERECT prcClip)
{
    HRESULT     hr = S_OK;
    RECT        rcWnd;
    RECT        rcVisible;

    if (!prcPos)
        RRETURN(E_INVALIDARG);

    Assert(State() >= OS_INPLACE);
    Assert(_pInPlace);
    Assert(_pInPlace->_pInPlaceSite);
    Assert(prcPos->left <= prcPos->right);
    Assert(prcPos->top <= prcPos->bottom);

    if (State() < OS_INPLACE)
        RRETURN(E_UNEXPECTED);

    // Handle bogus call from MFC container with NULL clip rectangle...
    if (!prcClip)
    {
        prcClip = prcPos;
    }

    TraceTag((tagRects,
            "%08lx SetObjectRects pos=%ld %ld %ld %ld; clip=%ld %ld %ld %ld",
            this, *prcPos, *prcClip));

    // Check for the container requesting an infinite scale factor.

    if ((_sizel.cx == 0 && prcPos->right - prcPos->left != 0) ||
        (_sizel.cy == 0 && prcPos->bottom - prcPos->top != 0))
    {
        Assert(0 && "Host error: Infinite scale factor. Not a Forms error.");
        RRETURN(E_FAIL);
    }

    //
    // Update the inplace RECTs and offsets
    //

    if (_pInPlace->_fWindowlessInplace)
    {
        CopyRect(&_pInPlace->_rcPos, prcPos);
        CopyRect(&_pInPlace->_rcClip,prcClip);
    }
    else
    {
        Assert(_pInPlace->_hwnd);

        // Because we set _pInPlace->_rcPos to match the extent
        // in IOleObject::SetExtent, a change in the size of the
        // positon rectangle here implies that the container is
        // scaling us.

/*
        if ((_pInPlace->_rcPos.right - _pInPlace->_rcPos.left !=
                prcPos->right - prcPos->left ||
            _pInPlace->_rcPos.bottom - _pInPlace->_rcPos.top !=
                prcPos->bottom - prcPos->top))
        {
            // Handle change in scaling.
            //::InvalidateRect ( _pInPlace->_hwnd, NULL, TRUE );
            RedrawWindow(_pInPlace->_hwnd,
                (GDIRECT *)NULL, NULL, RDW_ERASE | RDW_ALLCHILDREN | RDW_INVALIDATE);
        }
*/

        _pInPlace->_ptWnd = *(POINT *)&prcPos->left;

        CopyRect(&_pInPlace->_rcPos, prcPos);
        OffsetRect(&_pInPlace->_rcPos,  -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        CopyRect(&_pInPlace->_rcClip, prcClip);
        OffsetRect(&_pInPlace->_rcClip, -_pInPlace->_ptWnd.x, -_pInPlace->_ptWnd.y);

        CopyRect(&rcWnd, prcPos);
        if (_pInPlace->_fShowBorder)
        {
            InflateRect(&rcWnd, CX_IPBORDER, CY_IPBORDER);
        }

        IntersectRect(&rcVisible, &rcWnd, prcClip);
        if (EqualRect(&rcVisible, &rcWnd))
        {
            if (_pInPlace->_fUsingWindowRgn)
            {
                SetWindowRgn(_pInPlace->_hwnd, NULL, TRUE);
                _pInPlace->_fUsingWindowRgn = FALSE;
            }
        }
        else 
        {
            _pInPlace->_fUsingWindowRgn = TRUE;
            OffsetRect(&rcVisible, -rcWnd.left, -rcWnd.top);
            SetWindowRgn(_pInPlace->_hwnd,
                    CreateRectRgnIndirect(&rcVisible),
                    TRUE);
        }

        // we go to some trouble here to make sure we aren't calling SetWindowPos
        // with invalid area in our window, because Windows sends a WM_ERASEBKGND
        // message to our window and all child windows if it finds a completely
        // invalid window at the time that SetWindowPos is called.  This causes
        // truly disastrous flashing to occur when we are resizing the window.
        HRGN hrgnUpdate = ::CreateRectRgnIndirect(&g_Zero.rc);
        if (hrgnUpdate)
        {
            int result = ::GetUpdateRgn(_pInPlace->_hwnd, hrgnUpdate, FALSE);
            if (result != ERROR && result != NULLREGION)
            {
                ::ValidateRgn(_pInPlace->_hwnd, hrgnUpdate);
            }
            else
            {
                ::DeleteObject(hrgnUpdate);
                hrgnUpdate = NULL;
            }
        }

        TraceTag((tagRects, "%08lx SetObjectRects > SetWindowPos %ld %ld %ld %ld", this, rcWnd));
        
        SetWindowPos(_pInPlace->_hwnd, NULL, rcWnd.left, rcWnd.top,
                rcWnd.right - rcWnd.left, rcWnd.bottom - rcWnd.top,
                SWP_NOZORDER | SWP_NOACTIVATE);

        // restore previously invalid area
        if (hrgnUpdate)
        {
            // NOTE: The above call to SetWindowPos may have caused Trident to
            // be synchronously re-entered, and we may have transitioned to
            // not OS_INPLACE, which would leave _pInPlace NULL.  We have to
            // check it before using it again.
            if (_pInPlace && _pInPlace->_hwnd)
                ::InvalidateRgn(_pInPlace->_hwnd, hrgnUpdate, FALSE);
            ::DeleteObject(hrgnUpdate);
        }
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ReactivateAndUndo, IOleInPlaceObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method activates us, but doesn't do anything else.
//              Anyone who supports undo should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::ReactivateAndUndo(void)
{
    HRESULT     hr;

    hr = THR(TransitionTo(OS_UIACTIVE));

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::TranslateAccelerator, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceActiveObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::TranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hr = S_FALSE;
    CLock   Lock(this);
    VARIANT_BOOL    fEnabled;

    // if we are a form this will get called
    // because we are our own inplace object
    // but we want to bail out if we are disabled
    THR(GetEnabled(&fEnabled));
    if (!fEnabled)
    {
        // Call CServer::DoTranslateAccelerator to forward the key
        // up to the site.
        hr = THR(CServer::DoTranslateAccelerator(lpmsg));
    }
    else if (lpmsg->message >= WM_KEYFIRST && lpmsg->message <= WM_KEYLAST)
    {
        hr = THR_NOTRACE(DoTranslateAccelerator(lpmsg));
    }

    //
    // If we are merging menus, let the frame have a crack at 
    // translating accelerators.  The call to OleTranslateAccelerator
    // is necessary even though we're an in-proc server because 
    // the frame has no way of knowing where to route menu messages
    // otherwise.  Without this, things like Alt+E, C will not
    // work correctly.  (anandra)
    //
    
    if (S_FALSE == hr &&
        _pInPlace &&
        _pInPlace->_pFrame &&
        _pInPlace->_fMenusMerged)
    {
        hr = THR(OleTranslateAccelerator(
                _pInPlace->_pFrame, 
                &_pInPlace->_frameInfo, 
                lpmsg));
    }

    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoTranslateAccelerator, CServer
//
//  Synopsis:   Helper method for TranslateAccelerator.
//              Derived control classes should override this method
//              rather than TranslateAccelerator
//
//---------------------------------------------------------------

HRESULT
CServer::DoTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT hr = S_FALSE;
    IOleControlSite * pCtrlSite;

    if (_pClientSite &&
        !THR_NOTRACE(_pClientSite->QueryInterface(
                IID_IOleControlSite,
                (void**) &pCtrlSite)))
    {
            hr = THR(pCtrlSite->TranslateAccelerator(lpmsg, VBShiftState()));
            pCtrlSite->Release();
    }

    RRETURN1_NOTRACE(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::OnFrameWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::OnFrameWindowActivate(BOOL fActivate)
{
    if (_pInPlace)
    {
        if (fActivate && _state == OS_UIACTIVE && !_pInPlace->_fChildActive)
        {
            // Set focus unless a child window has focus already
            HWND hwndFocus = ::GetFocus();
            
            if (!(hwndFocus && _pInPlace->_hwnd && ::IsChild(_pInPlace->_hwnd, hwndFocus)))
            {
                SetFocus(TRUE);
            }
        }

        _pInPlace->_fFrameActive = fActivate;
    }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CServer::OnDocWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

HRESULT
CServer::OnDocWindowActivate(BOOL fActivate)
{
    HRESULT hr = S_OK;

#ifndef NO_OLEUI
    if (!_pInPlace)
        goto Cleanup;

    if (fActivate)
    {
        hr = THR(InstallFrameUI());
    }
    else
    {
        RemoveFrameUI();
    }
#endif // NO_OLEUI

    if (!hr)
    {
        Assert(_pInPlace);

        _pInPlace->_fDocActive = fActivate;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CServer::ResizeBorder, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      There are no standard border adornments so we do
//              nothing in this method.  Servers that have additional
//              U.I. elements that are installed on the frame or
//              document windows should override this method.
//
//---------------------------------------------------------------

HRESULT
CServer::ResizeBorder(
        LPCOLERECT lprc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CServer::EnableModeless, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CServer::EnableModeless(BOOL fEnable)
{
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::ShowUIActiveBorder
//
//  Synopsis:   Shows or hides the UI Active border for this object
//
//  Arguments:  [fShowBorder]   --  TRUE to show it
//
//-------------------------------------------------------------------------

void
CServer::ShowUIActiveBorder(BOOL fShowBorder)
{
    RECT    rc;

    Assert(State() >= OS_INPLACE);

    if (!_pInPlace->_hwnd)
        return;

    if (_pInPlace->_fShowBorder == (unsigned) fShowBorder)
        return;

    _pInPlace->_fShowBorder = fShowBorder;

    rc = _pInPlace->_rcPos;

    if (fShowBorder)
    {
        InflateRect(&rc, CX_IPBORDER, CY_IPBORDER);
    }

    TraceTag((tagRects, "%08lx ShowUIActiveBorder > SetWindowPos %ld %ld %ld %ld",
            this,
            rc.left + _pInPlace->_ptWnd.x,
            rc.top + _pInPlace->_ptWnd.y,
            rc.right - rc.left + _pInPlace->_ptWnd.x,
            rc.bottom - rc.top + _pInPlace->_ptWnd.y));

    SetWindowPos(
            _pInPlace->_hwnd,
            NULL,
            rc.left + _pInPlace->_ptWnd.x,
            rc.top + _pInPlace->_ptWnd.y,
            rc.right - rc.left,
            rc.bottom - rc.top,
            SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnPaint
//
//  Synopsis:   Draws the client area when a window is present
//
//-------------------------------------------------------------------------

void
CServer::OnPaint()
{
    HDC hdc;
    PAINTSTRUCT ps;

    Assert(_pInPlace);
    Assert(_pInPlace->_hwnd);

    if (TestLock(SERVERLOCK_BLOCKPAINT))
        return;

    CLock Lock(this, SERVERLOCK_BLOCKPAINT);

    hdc = ::BeginPaint(_pInPlace->_hwnd, &ps);

    if (!hdc)
        return;

    GetPalette(hdc);

    // NOTE: Here we pass a NULL in for the rect.  This is done becuase
    // this control has a window and must be in place, and the convention
    // is that a NULL is passed in to have the control draw in place, as
    // opposed to drawing it in another view.

    IGNORE_HR(Draw(DVASPECT_CONTENT, -1, 0, 0, 0, hdc, NULL, 0, 0, 0));

    SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);
    EndPaint(_pInPlace->_hwnd, &ps);
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnEraseBkgnd
//
//  Synopsis:   Erases the background when a window is present
//
//-------------------------------------------------------------------------

BOOL
CServer::OnEraseBkgnd(HDC hdc)
{
    Assert( _pInPlace );
    Assert( _pInPlace->_hwnd );

    return TestLock(SERVERLOCK_BLOCKPAINT) ? TRUE : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCSetCursor
//
//  Synopsis:   Set the cursor for the non-licent area.
//
//-------------------------------------------------------------------------

BOOL
CServer::OnNCSetCursor(HWND hwnd, int nHitTest, UINT msg)
{
    TCHAR * idc;

    // Set cursor for non-client area.  We don't let the default
    // window procedure handle this because it gives the container
    // a chance to override what we really want.

    if (hwnd != _pInPlace->_hwnd || msg != WM_MOUSEMOVE)
        return FALSE;

    switch (nHitTest)
    {
    case HTCAPTION:
        idc = IDC_SIZEALL;
        break;

    case HTLEFT:
    case HTRIGHT:
        idc = IDC_SIZEWE;
        break;

    case HTTOP:
    case HTBOTTOM:
        idc = IDC_SIZENS;
        break;

    case HTTOPLEFT:
    case HTBOTTOMRIGHT:
        idc = IDC_SIZENWSE;
        break;

    case HTTOPRIGHT:
    case HTBOTTOMLEFT:
        idc = IDC_SIZENESW;
        break;

    default:
        return FALSE;
    }

    SetCursorIDC(idc);

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCPaint
//
//  Synopsis:   Draws the non-client region for the given window
//
//  Arguments:  hWnd    Window to draw
//
//-------------------------------------------------------------------------

void
CServer::OnNCPaint()
{
    RECT        rcBorder;
    HDC         hdc;

    if (!_pInPlace->_fShowBorder)
        return;

    // Get rcPos and inflate it.  This rcPos is our client
    // coordinate system
    rcBorder = _pInPlace->_rcPos;
    InflateRect(&rcBorder, CX_IPBORDER, CY_IPBORDER);

    // Normalize rcBorder to our window coord. system.
    OffsetRect(&rcBorder, -rcBorder.left, -rcBorder.top);

    hdc = GetWindowDC(_pInPlace->_hwnd);

    DrawUIActiveBorder(
            hdc,
            &rcBorder,
            GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE),
            GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE));

    ::ReleaseDC(_pInPlace->_hwnd, hdc);
}


//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCHitTest
//
//  Synopsis:   Returns the hit code for the border part at the given
//              point.
//
//-------------------------------------------------------------------------

LONG
CServer::OnNCHitTest(POINTS pts)
{
    RECT    rc;
    POINT   pt;
    int     dwHitBits;
    int     d;

    pt.x = pts.x;
    pt.y = pts.y;

    //
    // If it clearly is in the client area, return that fact.
    //
    GetClientRect( _pInPlace->_hwnd , &rc );
    ScreenToClient(_pInPlace->_hwnd, &pt);
    if (PtInRect(&rc, pt))
        return HTCLIENT;

    //
    // If we have no hatch border to test against then we can
    // give no better information.
    //
    if (!_pInPlace->_fShowBorder)
        return HTNOWHERE;

    // Set bits in a DWORD based on horizontal and vertical position
    // of the mouse.

    dwHitBits = 0;

    d = (rc.left + rc.right - CX_IPBORDER) / 2;
    if (pt.x >= d && pt.x < d + CX_IPBORDER + CX_HANDLEINSET)
        dwHitBits |= 0x04;
    else if (pt.x < rc.left + CX_IPBORDER + CX_HANDLEINSET)
        dwHitBits |= 0x01;
    else if (pt.x >= rc.right - CX_IPBORDER - CX_HANDLEINSET)
        dwHitBits |= 0x02;

    d = (rc.top + rc.bottom - CY_IPBORDER) / 2;
    if (pt.y >= d && pt.y < d + CY_IPBORDER + CY_HANDLEINSET)
        dwHitBits |= 0x40;
    else if (pt.y < rc.top + CY_IPBORDER + CY_HANDLEINSET)
        dwHitBits |= 0x10;
    else if (pt.y >= rc.bottom - CY_IPBORDER - CY_HANDLEINSET)
        dwHitBits |= 0x20;

    // Convert bits to hit test codes.

    switch (dwHitBits)
    {
    case 0x11:
        return HTTOPLEFT;
    case 0x21:
        return HTBOTTOMLEFT;
    case 0x41:
        return HTLEFT;
    case 0x12:
        return HTTOPRIGHT;
    case 0x22:
        return HTBOTTOMRIGHT;
    case 0x42:
        return HTRIGHT;
    case 0x14:
        return HTTOP;
    case 0x24:
        return HTBOTTOM;
    }

    return HTCAPTION;
}

//+------------------------------------------------------------------------
//
//  Member:     CServer::OnNCLButtonDown
//
//  Synopsis:   Handle WM_NCLBUTTONDOWN
//
//-------------------------------------------------------------------------

BOOL
CServer::OnNCLButtonDown(int ht, POINTS pts, RECT * prcCurrent)
{
    HRESULT hr;
    XHDC    hdc;
    HWND    hwnd;
    RECT    rcStart;
    RECT    rcCurrent;
    RECT    rcClip;
    RECT    rc;
    MSG     msg;
    POINT   pt;
    POINT   ptStart;
    BOOL    fCallOnPosRectChange = FALSE;

    hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&hwnd));
    if (hr)
        return FALSE;

    if (GetCapture() != NULL)
        return FALSE;

    if (!prcCurrent)
    {
        prcCurrent = &rcCurrent;
    }

    // Get container's window current and lock it so
    // the x-or drawing below will not be messed up.

    UpdateChildTree(hwnd);
    LockWindowUpdate(hwnd);

    // Get starting point in container window coordinates.

    ptStart.x = pts.x;
    ptStart.y = pts.y;
    ScreenToClient(hwnd, &ptStart);

    // Get clip rectangle in container window coordinates.

    rcClip = _pInPlace->_rcClip;
    OffsetRect(&rcClip, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);
    ::GetClientRect(hwnd, &rc);
    IntersectRect(&rcClip, &rcClip, &rc);

    // Get starting rectangle in container window coordinates.

    rcStart = _pInPlace->_rcPos;
    OffsetRect(&rcStart, _pInPlace->_ptWnd.x, _pInPlace->_ptWnd.y);

    // Setup DC for drawing.

    hdc = XHDC(GetDCEx(hwnd, NULL,
            DCX_CACHE |
            DCX_CLIPSIBLINGS |
            DCX_LOCKWINDOWUPDATE), NULL);
    IntersectClipRect(hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom);

    *prcCurrent = rcStart;

    ::SetCapture(hwnd);

    DrawDefaultFeedbackRect(hdc, prcCurrent);

    // Get messages until capture lost or cancelled/accepted

    for (;;)
    {
        ::SuspendCAP();

        GetMessage(&msg, NULL, 0, 0);

        ::ResumeCAP();

        if (::GetCapture() != hwnd)
            goto ExitLoop;

        switch (msg.message)
        {
        case WM_SETCURSOR:
            break;

        case WM_KEYDOWN:
            if (msg.wParam == VK_ESCAPE)
                goto ExitLoop;
            break;

        case WM_RBUTTONDOWN:
            goto ExitLoop;

        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:

            rc = *prcCurrent;
            *prcCurrent = rcStart;

            pts = MAKEPOINTS(msg.lParam);
            pt.x = pts.x;
            pt.y = pts.y;

            if (pt.x < rcClip.left)
                pt.x = rcClip.left;
            else if (pt.x > rcClip.right)
                pt.x = rcClip.right;

            if (pt.y < rcClip.top)
                pt.y = rcClip.top;
            else if (pt.y > rcClip.bottom)
                pt.y = rcClip.bottom;

            switch (ht)
            {
            case HTCAPTION:
                OffsetRect(prcCurrent, pt.x - ptStart.x, pt.y - ptStart.y);
                break;

            case HTLEFT:
            case HTTOPLEFT:
            case HTBOTTOMLEFT:
                prcCurrent->left += pt.x - ptStart.x;
                if (prcCurrent->left > rcStart.right)
                    prcCurrent->left = rcStart.right;
                break;

            case HTRIGHT:
            case HTTOPRIGHT:
            case HTBOTTOMRIGHT:
                prcCurrent->right += pt.x - ptStart.x;
                if (prcCurrent->right < rcStart.left)
                    prcCurrent->right = rcStart.left;
                break;
            }

            switch (ht)
            {
            case HTTOP:
            case HTTOPLEFT:
            case HTTOPRIGHT:
                prcCurrent->top += pt.y - ptStart.y;
                if (prcCurrent->top > rcStart.bottom)
                    prcCurrent->top = rcStart.bottom;
                break;

            case HTBOTTOM:
            case HTBOTTOMLEFT:
            case HTBOTTOMRIGHT:
                prcCurrent->bottom += pt.y - ptStart.y;
                if (prcCurrent->bottom < rcStart.top)
                    prcCurrent->bottom = rcStart.top;
                break;
            }

            if (memcmp(&prcCurrent, &rc, sizeof(rc)))
            {
                DrawDefaultFeedbackRect(hdc, &rc);
                DrawDefaultFeedbackRect(hdc, prcCurrent);
            }

            if (msg.message == WM_LBUTTONUP)
            {
                fCallOnPosRectChange = TRUE;
                goto ExitLoop;
            }

        default:

            // Anything can happen during DispatchMessage.
            // Insure that our feedback is not messed up.

            DrawDefaultFeedbackRect(hdc, prcCurrent);
            DispatchMessage(&msg);
            UpdateChildTree(hwnd);
            DrawDefaultFeedbackRect(hdc, prcCurrent);
            break;
        }
    }

ExitLoop:

    DrawDefaultFeedbackRect(hdc, prcCurrent);

    ::ReleaseDC(hwnd, hdc);
#if DBG==1
    Assert(!TLS(fHandleCaptureChanged));
#endif
    ReleaseCapture();
    LockWindowUpdate(NULL);

    return fCallOnPosRectChange;
}


//+---------------------------------------------------------------------------
//
//  Member:    CServer::OnDestroy
//
//  Synopsis:  Deregister Drag and Drop
//
//----------------------------------------------------------------------------

void
CServer::OnDestroy( )
{
    Assert(_pInPlace->_hwnd);
    RevokeDragDrop(_pInPlace->_hwnd);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnWindowMessage
//
//  Synopsis:   Handles windows messages.
//
//  Arguments:  msg     the message identifier
//              wParam  the first message parameter
//              lParam  the second message parameter
//
//  Returns:    LRESULT as in WNDPROCs
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr=S_OK;
    POINT pt;

    *plResult = 0;

    // We should always be stabilized when handling a window message.
    // This check insures that derived classes are doing the right thing.

    Assert(TestLock(SERVERLOCK_STABILIZED));

    // Events fired by the derived class implementation of OnWindowMessage
    // may have caused this object to leave the inplace state.  Bail out
    // here if it looks like this happened.  We check for _pInPlace instead
    // of _state < OS_INPLACE because the window procedure can be called
    // before we are officially in the inplace state.

    if (!_pInPlace)
    {
        return S_OK;
    }

    // Process the message.

    switch (msg)
    {
    case WM_DESTROY:
        OnDestroy();
        break;

// WINCEREVIEW -- senthilv - 01/30/97 ignoring all message handlers from nonclient area
#ifndef WINCE
    case WM_NCLBUTTONDOWN:
        OnNCLButtonDown(wParam, MAKEPOINTS(lParam));
        break;

    case WM_NCHITTEST:
        *plResult = OnNCHitTest(MAKEPOINTS(lParam));
        break;

    case WM_NCCALCSIZE:
        if (_pInPlace->_fShowBorder)
        {
            // Let the old client rect origin stay the same so shrink
            // incoming rectangle (which is total window size)
            InflateRect((RECT *)lParam, -CX_IPBORDER, -CY_IPBORDER);
        }

        if (wParam && TestServerDescFlag(SERVERDESC_INVAL_ON_RESIZE))
        {
            *plResult |= WVR_REDRAW;
        }
        break;

    case WM_NCPAINT:
        OnNCPaint();
        break;
#endif	// WINCE

    case WM_SETCURSOR:

        if (LOWORD(lParam) != HTCLIENT)
        {
            if (_pInPlace->_hwnd &&
                !OnNCSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam)))
            {
                *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
            }
        }
        else
        {
            HWND hwnd;

            GetCursorPos(&pt);

            hwnd = GetHWND();
            if (hwnd)
            {
                ScreenToClient(hwnd, &pt);

                // First chance at setting the cursor

                if (THR(OnInactiveSetCursor(
                        &_pInPlace->_rcPos,
                        pt.x, pt.y,
                        HIWORD(wParam),
                        FALSE)) == S_FALSE)
                {
                    // Give the container a chance to set the cursor.

                    IGNORE_HR(OnDefWindowMessage(msg,
                                                 wParam ? wParam : (WPARAM)hwnd,
                                                 lParam,
                                                 plResult ));

                    // If the container did not set the cursor, then use the built in
                    // cursor.  Note that we do this for our window only.

                    if (!*plResult && hwnd == (HWND)wParam && !_pInPlace->_fBubbleInsideOut)
                    {
                        *plResult = (THR(OnInactiveSetCursor(
                            &_pInPlace->_rcPos,
                            pt.x, pt.y,
                            HIWORD(wParam),
                            TRUE)) == S_FALSE) ? FALSE : TRUE;
                    }
                }
                else
                {
                    *plResult = TRUE;
                }
            }
        }
        break;

    case WM_MOUSEMOVE:
        hr = THR(OnInactiveMouseMove(
                &_pInPlace->_rcPos,
                MAKEPOINTS(lParam).x,
                MAKEPOINTS(lParam).y,
                wParam));
        break;

    case WM_ERASEBKGND:
        *plResult = OnEraseBkgnd((HDC)wParam);
        break;

    case WM_PAINT:
        OnPaint();
        break;

    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        {
            IOleControlSite * pControlSite;

            _pInPlace->_fFocus = (msg == WM_SETFOCUS);

            if (OK(THR_NOTRACE(_pClientSite->QueryInterface(IID_IOleControlSite,
                    (void **)&pControlSite))))
            {
                pControlSite->OnFocus(msg == WM_SETFOCUS);
                pControlSite->Release();
            }
        }
        break;

    // OCX containers (e.g. VB4) will forward WM_PALETTECHANGED and WM_QUERYNEWPALETTE
    // on to us to properly realize our palette for controls in cases where they are
    // windowed.  This is semantically equivalent to the code in MinFrameWndProc in
    // minfr.cxx.
    case WM_PALETTECHANGED:
        Assert(_pInPlace);
        if ((HWND)wParam == _pInPlace->_hwnd)
            break;
        // **** FALL THRU ****
    case WM_QUERYNEWPALETTE:
        {
            HDC         hdc;

            Assert(_pInPlace);
            hdc = ::GetDC(_pInPlace->_hwnd);
            if (hdc)
            {
                BOOL        fInvalidate = FALSE;
                HPALETTE    hpal;

                hpal = GetPalette();
                if (hpal)
                {
                    HPALETTE hpalOld = SelectPalette(hdc, hpal, (msg == WM_PALETTECHANGED));
                    Assert(hpalOld);
                    fInvalidate = RealizePalette(hdc) || (msg == WM_PALETTECHANGED);
                    SelectPalette(hdc, hpalOld, TRUE);
                    
                    if (fInvalidate && (_state >= OS_INPLACE))
                    {
                        if (_pInPlace->_hwnd)
                            RedrawWindow(_pInPlace->_hwnd, (GDIRECT *)NULL, NULL,
                                         RDW_INVALIDATE | RDW_ALLCHILDREN);
                        else
                            InvalidateRect(NULL, TRUE);
                    }
                }
                ::ReleaseDC(_pInPlace->_hwnd, hdc);
                *plResult = !!hpal;
            }
            break;
        }

    default:
        hr = THR(OnDefWindowMessage(msg, wParam, lParam, plResult));
        break;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::OnDefWindowMessage
//
//  Synopsis:   Default handling for window messages.
//
//  Arguments:  msg      the message identifier
//              wParam   the first message parameter
//              lParam   the second message parameter
//              plResult return value from window proc
//
//----------------------------------------------------------------------------

HRESULT
CServer::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    HRESULT hr = S_OK;

    // Events fired by the derived class implementation of OnWindowMessage
    // may have caused this object to leave the inplace state.  Bail out
    // here if it looks like this happened.  We check for _pInPlace instead
    // of _state < OS_INPLACE because the window procedure can be called
    // before we are officially in the inplace state.

    if (!_pInPlace)
    {
        return S_OK;
    }

    if (_pInPlace->_fWindowlessInplace)
    {
        hr = THR(((IOleInPlaceSiteWindowless*)_pInPlace->_pInPlaceSite)->
                OnDefWindowMessage(msg, wParam, lParam, plResult));
    }
#ifndef NO_IME
    else if (DIMMHandleDefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam, plResult))
    {
        // WM_IME* messages routed through here, so let the imm hook get a chance at them
        // plResult set in call above.
        
        // Note we only bother to hook if !_pInPlace->_fWindowlessInPlace, that is if
        // we have our own window.
    }
#endif // ndef NO_IME
    else if (_pInPlace->_hwnd)
    {
        // Events fired by the derived class implementation of OnWindowMessage
        // may have caused this object to leave the inplace state.  Bail out
        // here if it looks like this happened.  We check for _pInPlace instead
        // of _state < OS_INPLACE because the window procedure can be called
        // before we are officially in the inplace state.

        *plResult = DefWindowProc(_pInPlace->_hwnd, msg, wParam, lParam);
    }
    else
    {
        *plResult = 0;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::WndProc
//
//  Synopsis:   Window procedure for use by derived class.
//              This function maintains the relationship between
//              CServer and HWND and delegates all other functionality
//              to the CServer::OnWindowMessage virtual method.
//
//  Arguments:  hwnd     the window
//              msg      the message identifier
//              wParam   the first message parameter
//              lParam   the second message parameter
//              plResult the window procedure return value
//
//  Returns:    S_FALSE if caller should delegate to the default window proc
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CServer::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

#ifdef _M_IX86
    //automatic stack saver for Win9x. see declaration of this class for details.
    CWin9xStackSave stackSaver;
#endif //_M_IX86

    CServer *pServer;
    LRESULT lResult = 0;

    //
    // a-msadek; Trident window should not be mirrored if hosted by a mirrored process
    //

    if(msg == WM_NCCREATE)
    {
        DWORD dwExStyles;
        if ((dwExStyles = GetWindowLong(hwnd, GWL_EXSTYLE)) & WS_EX_LAYOUTRTL)
        {
             SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyles &~ WS_EX_LAYOUTRTL);
        }
    }

    //
    // If creating, then establish the connection between the HWND and
    // the CServer.  Otherwise, fetch the pointer to the CServer.
    //

#if defined(WINCE) && !defined(WINCE_NT)
    if (msg == WM_CREATE)
#else
    if (msg == WM_NCCREATE)
#endif // WINCE
    {
        pServer = (CServer *) ((LPCREATESTRUCTW)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pServer);
        pServer->_pInPlace->_hwnd = hwnd; 
        pServer->PrivateAddRef();
    }
    else
    {
        pServer = (CServer *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    if (pServer)
    {
        Assert(pServer->_pInPlace);
        Assert(pServer->_pInPlace->_hwnd == hwnd);

        //
        // Give the derived class a chance to handle the window message.
        //

        IGNORE_HR(pServer->OnWindowMessage(msg, wParam, lParam, &lResult));

        //
        // If destroying, break the connection between the HWND and CServer.
        // The call to release might destroy the server, so it must come
        // after the OnWindowMessage virtual function call.
        //

#if defined(WINCE) && !defined(WINCE_NT)
        if (msg == WM_DESTROY)
#else
        if (msg == WM_NCDESTROY)
#endif // WINCE
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            pServer->_pInPlace->_hwnd = NULL;
            pServer->PrivateRelease();
        }

    }
    // We should always calls DefWindowProc
    else
    {
        lResult = DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdbase\verb.cxx ===
//+---------------------------------------------------------------------
//
//  File:       verb.cxx
//
//  Contents:   CServer verb stuff.
//
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------
//
//  Common verb tables
//
//          These are the common verb tables.  Specialized verb tables
//          can be defined elsewhere.
//
//          DoProperties is duplicated in these tables because most
//          containers will not add menu items for negative lVerb values.
//
//          The sizes for these arrays are defined in CDBASE.HXX.  You
//          must update the sizes in CDBASE if you make changes here.
//
//---------------------------------------------------------------

const OLEVERB g_aOleVerbStandard[C_OLEVERB_STANDARD] =
{
    { OLEIVERB_PRIMARY,         NULL, 0, 0 },
    { 1,                        NULL, 0, 0 },
    { OLEIVERB_INPLACEACTIVATE, NULL, 0, 0 },
    { OLEIVERB_UIACTIVATE,      NULL, 0, 0 },
    { OLEIVERB_HIDE,            NULL, 0, 0 },
    { OLEIVERB_SHOW,            NULL, 0, 0 },
    { OLEIVERB_PROPERTIES,      NULL, 0, 0 },
};

const CServer::PFNDOVERB g_apfnDoVerbStandard[C_OLEVERB_STANDARD]=
{
    &CServer::DoUIActivate,
#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
    &CServer::DoProperties,
#endif
    &CServer::DoInPlaceActivate,
    &CServer::DoUIActivate,
    &CServer::DoHide,
    &CServer::DoUIActivate,
#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
    &CServer::DoProperties,
#endif
};


//+---------------------------------------------------------------------------
//
//  Member:     CServer::PrepareActivationMessage
//
//  Synopsis:   Setup an activation message to be later sent by
//              SendActivationMessage.
//
//  Arguments:  lpmsg       The message handed to us in DoVerb.
//              lpmsgSend   The message to send.
//
//  Notes:      > Handles the lpmsg == NULL case.
//              > Translates message parameters, so that the window
//                can deal with the message as if it arrived
//                normally.
//              > We only send mouse messages which cause activation.
//
//----------------------------------------------------------------------------

void
CServer::PrepareActivationMessage(LPMSG lpmsg, LPMSG lpmsgSend)
{
    POINT   pt;
    HRESULT hr;

    Assert(State() >= OS_INPLACE && _pInPlace);

    // Assume no message to send by default.

    lpmsgSend->message = 0;

    if (!lpmsg)
        return;

    // We send only mouse messages. Derived classes can handle
    // keyboard messages in ActivateUI().

    if (lpmsg->message != WM_LBUTTONDOWN &&
             lpmsg->message != WM_RBUTTONDOWN &&
             lpmsg->message != WM_MBUTTONDOWN)
        return;

    pt = lpmsg->pt;

    if (_pInPlace->_hwnd)
    {
        // We need to re-hit-test (since the control may create child windows)
        // and re-translate mouse message coordinates.
        POINT   ptClient = pt;

        ScreenToClient(_pInPlace->_hwnd, &ptClient);
        lpmsgSend->hwnd = ChildWindowFromPointEx(
                _pInPlace->_hwnd,
                ptClient,
                CWP_SKIPINVISIBLE | CWP_SKIPDISABLED);
    }
    else
    {
        hr = THR(_pInPlace->_pInPlaceSite->GetWindow(&lpmsgSend->hwnd));
        if (hr)
            return;
    }

    ScreenToClient(lpmsgSend->hwnd, &pt);
    lpmsgSend->message = lpmsg->message;
    lpmsgSend->wParam = lpmsg->wParam;
    lpmsgSend->lParam = MAKELONG(pt.x, pt.y);
}


//+---------------------------------------------------------------------------
//
//  Member:     CServer::SendActivationMessage
//
//  Synopsis:   Sends message prepared by PrepareActivationMessage
//
//  Arguments:  lpmsg   Message to send.
//
//----------------------------------------------------------------------------

void
CServer::SendActivationMessage(LPMSG lpmsg)
{
    LRESULT lResult;

    if (lpmsg->message != 0)
    {
        if (_pInPlace->_hwnd)
        {
            SendMessage(lpmsg->hwnd,
                    lpmsg->message,
                    lpmsg->wParam,
                    lpmsg->lParam);
        }
        else
        {
            IGNORE_HR(OnWindowMessage(
                    lpmsg->message,
                    lpmsg->wParam,
                    lpmsg->lParam,
                    &lResult));
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     CServer::ActivateView
//
//  Synopsis:   Activate an IOleDocumentView
//
//---------------------------------------------------------------

HRESULT
CServer::ActivateView()
{
    HRESULT hr;
    IOleDocumentSite * pMsoDocSite = NULL;
    IOleDocumentView * pOleDocumentView = NULL;

    Assert(_fMsoDocMode);

    hr = THR(_pClientSite->QueryInterface(IID_IOleDocumentSite,
                 (void **)&pMsoDocSite));
    if (hr)
        goto Cleanup;

    hr = THR(PrivateQueryInterface(IID_IOleDocumentView, (void **)&pOleDocumentView));
    if (hr)
        goto Cleanup;
    
    hr = THR(pMsoDocSite->ActivateMe(pOleDocumentView));

Cleanup:
    ReleaseInterface(pOleDocumentView);
    ReleaseInterface(pMsoDocSite);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CServer::DoShow, public
//
//  Synopsis:   Implement an OLE verb by asking the client site to show
//              this object.
//
//  Arguments:  [pServer] -- pointer to a CServer object.
//
//              All other parameters are the same as the IOleObject::DoVerb
//              method.
//
//  Returns:    Success if the verb was successfully executed
//
//  Notes:      This and the other static Do functions are provided for
//              use in the server's verb table.  This verb results in
//              a ShowObject call on our container and a transition
//              to the U.I. active state
//
//---------------------------------------------------------------

HRESULT
CServer::DoShow(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT hr = S_OK;

    if (!pServer->_pClientSite)
        RRETURN(E_UNEXPECTED);

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        IGNORE_HR(pServer->_pClientSite->ShowObject());
        pServer->_fHidden = FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member: CServer::DoHide, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_HIDE
//              This verb results in a transition to the Running state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoHide(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT hr;

    if (pServer->_fMsoDocMode)
    {
        //
        //  If we're a docobj, then hide should not be called on us.
        //

        hr = E_UNEXPECTED;
    }
    else
    {
        hr = THR(pServer->TransitionTo(OS_RUNNING, lpmsg));
        if (OK(hr))
        {
            pServer->_fHidden = TRUE;
        }
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoUIActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_UIACTIVATE
//              This verb results in a transition to the U.I. active state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoUIActivate(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT     hr;
    MSG         msg;

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        // Get the server into the OS_INPLACE state so that we can setup
        // the activation message.

        if (pServer->State() < OS_INPLACE)
        {
            hr = THR(pServer->TransitionTo(OS_INPLACE, lpmsg));
            if (hr)
                goto Cleanup;
        }

        // Setup the activation message.   We do this before UI activating because
        // this server's screen position (used in setting up the message) can change
        // as a result of UI activation. This can happen because another server removes
        // its UI when deactivting or this server installs UI.

        pServer->PrepareActivationMessage(lpmsg, &msg);

        hr = THR(pServer->TransitionTo(OS_UIACTIVE, lpmsg));
        if (hr)
            goto Cleanup;

        pServer->SendActivationMessage(&msg);
    }

Cleanup:
    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}



//+---------------------------------------------------------------
//
//  Member:     CServer::DoInPlaceActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_INPLACEACTIVATE
//              This verb results in a transition to the inplace state.
//
//---------------------------------------------------------------

HRESULT
CServer::DoInPlaceActivate(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT     hr;
    MSG         msg;

    if (pServer->_fMsoDocMode)
    {
        hr = THR(pServer->ActivateView());
    }
    else
    {
        hr = THR(pServer->TransitionTo(OS_INPLACE, lpmsg));
        if (!hr)
        {
            pServer->PrepareActivationMessage(lpmsg, &msg);
            pServer->SendActivationMessage(&msg);
        }

        pServer->_fHidden = FALSE;
        // Fixes VB4 problem where they call InPlaceActivate instead
        // of DoShow when setting visible=true.
    }

    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}


#if !defined(PRODUCT_RT) && !defined(PRODUCT_96)
//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoProperties
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_PROPERTIES.
//              This verb results in bringing up the property frame on
//              this object.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoProperties(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    HRESULT           hr;
    BSTR              bstrName    = NULL;
    LPTSTR            pszCaption  = NULL;
    IOleControlSite * pSite;
    HWND              hwnd        = NULL;

    Assert(pActiveSite);

    if (!pActiveSite->QueryInterface(IID_IOleControlSite, (LPVOID *) &pSite))
    {
        hr = THR(pSite->ShowPropertyFrame());
        ReleaseInterface(pSite);
        if (!hr)
            return S_OK;
    }

    //  Ignore failure to get display name; in this case, no
    //    display name is given in the property frame title

    hr = pServer->GetAmbientBstr(
            DISPID_AMBIENT_DISPLAYNAME,
            &bstrName);
    if (hr)
        goto Cleanup;

    hr = Format(FMT_OUT_ALLOC,
            &pszCaption, 128,
            MAKEINTRESOURCE(bstrName ? IDS_NAMEDCTRLPROPERTIES : IDS_CTRLPROPERTIES),
            bstrName);
    FormsFreeString(bstrName);

    if (hr)
        goto Cleanup;

    if (pServer->_pInPlace)
    {
        hwnd = pServer->_pInPlace->_hwnd;
    }
#ifndef PRODUCT_96

    int                    i;
    const CLSID * const *  apclsid;
    CLSID                  aclsid[32];

#ifdef NO_PROPERTY_PAGE
    apclsid = NULL;
#else
    apclsid = pServer->BaseDesc()->_apclsidPages;
#endif // NO_PROPERTY_PAGE

    if (!apclsid)
    {
        i = 0;
    }
    else
    {
        for (i = 0; i < ARRAY_SIZE(aclsid) && apclsid[i]; i++)
        {
            aclsid[i] = *apclsid[i];
        }
    }

    hr = THR(OleCreatePropertyFrame(
                hwnd,
                32,
                32,
                pszCaption,
                1,
                (IUnknown **)&pServer,
                i,
                aclsid,
                g_lcidUserDefault,
                0,
                NULL));
#else

    hr = THR(FormsCreatePropertyFrame(
                hwnd,
                32,
                32,
                pszCaption,
                1,
                (IUnknown **)&pServer,
                0,
                NULL,
                g_lcidUserDefault));

#endif
#if DBG == 1
    if (hr)
        TraceTag((tagError, "CServer::DoProperties -- "
                                  "CreatePropertyFrame failed: %lx.", hr));
#endif

Cleanup:
    FormsFreeString(bstrName);
    delete [] pszCaption;

    RRETURN(hr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoUIActivateIfDesign, public
//
//  Synopsis:   Implement OLE Verb by showing the object in user mode or
//              transitioning to UI active state in design mode.  If
//              explicitly asked to UI activate the object in user mode,
//              we return E_NOTIMPL.
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoUIActivateIfDesign(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    PFNDOVERB pfnDoVerb;
    BOOL      fUserMode;
    HRESULT   hr;

    fUserMode = pServer->GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

    if (iVerb == OLEIVERB_UIACTIVATE && fUserMode)
    {
        hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
    }
    else
    {
        pfnDoVerb = fUserMode ? DoShow : DoUIActivate;
        hr = THR(pfnDoVerb(pServer,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect));
    }

    RRETURN1(hr, OLEOBJ_S_CANNOT_DOVERB_NOW);
}

//+---------------------------------------------------------------------------
//
//  Member:     CServer::DoInPlaceActivateIfDesign, public
//
//  Synopsis:   If in design mode, transition to the inplace state.
//
//----------------------------------------------------------------------------

HRESULT
CServer::DoInPlaceActivateIfDesign(
        CServer * pServer,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    BOOL      fUserMode;
    HRESULT   hr;

    fUserMode = pServer->GetAmbientBool(DISPID_AMBIENT_USERMODE, TRUE);

    Assert(iVerb == OLEIVERB_INPLACEACTIVATE);

    if (fUserMode)
    {
        hr = E_NOTIMPL;
    }
    else
    {
        hr = THR(DoInPlaceActivate(pServer,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect));
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\atomtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atomtbl.cxx
//
//  History:    20-Sep-1996     AnandRa     Created
//
//  Contents:   CAtomTable implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ATOMTBL_HXX_
#define X_ATOMTBL_HXX_
#include "atomtbl.hxx"
#endif

#ifndef X_HASHATOMTBL_HXX_
#define X_HASHATOMTBL_HXX_
#include "hashatomtbl.hxx"
#endif

MtDefine(CAtomTable, Utilities, "CAtomTable")
MtDefine(CAtomTable_pv, CAtomTable, "CAtomTable::_pv")

HRESULT
CAtomTable::AddNameToAtomTable(LPCTSTR pch, long *plIndex)
{
    HRESULT hr = S_OK;

    // If we are in hash mode, use that
    if (_phat)
    {
        hr = _phat->AddNameToAtomTable(pch, plIndex);
    }
    else
    {
        long    lIndex;
        CStr *  pstr;
    
        for (lIndex = 0; lIndex < Size(); lIndex++)
        {
            pstr = (CStr *)Deref(sizeof(CStr), lIndex);
            if (_tcsequal(pch, *pstr))
                break;
        }
        if (lIndex == Size())
        {
            CStr cstr;

            if (lIndex >= ATOMTABLE_HASH_THRESHOLD)
            {
                hr = ConvertToHash();
                if (hr)
                    goto Cleanup;

                hr = _phat->AddNameToAtomTable(pch, plIndex);

                goto Cleanup;
            }
        
            //
            // Not found, so add element to array.
            //

            hr = THR(cstr.Set(pch));
            if (hr)
                goto Cleanup;
       
            hr = THR(AppendIndirect(&cstr));
            if (hr)
                goto Cleanup;

            // The array now owns the memory for the cstr, so take it away from
            // the cstr on the stack.

            cstr.TakePch();
        }

        if (plIndex)
        {
            *plIndex = lIndex;
        }
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CAtomTable::GetAtomFromName(LPCTSTR pch, long *plIndex, long *plId, BOOL fCaseSensitive /*= TRUE */,
                                    BOOL fStartFromGivenIndex /* = FALSE */)
{
    HRESULT hr = S_OK;

    if (!pch)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    if (_phat)
    {
        hr = _phat->GetAtomFromName(pch, plIndex, plId, fCaseSensitive, fStartFromGivenIndex);
    }
    else
    {
        long    lIndex;
        CStr *  pstr;

	if(fStartFromGivenIndex)
	{
            if (plIndex && *plIndex>=0)
            {
                  lIndex = *plIndex;
            }
            else
            {
                  hr = E_FAIL;
                  goto Cleanup;
            }
	}
        else
            lIndex = 0;
    
        for (; lIndex < Size(); lIndex++)
        {
            pstr = (CStr *)Deref(sizeof(CStr), lIndex);
            if(fCaseSensitive)
            {
                if (_tcsequal(pch, *pstr))
                    break;
            }
            else
            {
                if(_tcsicmp(pch, *pstr) == 0)
                    break;
            }
        }
    
        if (lIndex == Size())
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        if (plIndex)
        {
            *plIndex = lIndex;
        }

        if (plId)
        {
            *plId = lIndex;
        }
    }

Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}


HRESULT 
CAtomTable::GetNameFromAtom(long lIndex, LPCTSTR *ppch)
{
    HRESULT hr = S_OK;

    if (_phat)
    {
        hr = _phat->GetNameFromAtom( lIndex, ppch );
    }
    else
    {
        CStr *  pcstr;
    
        if (Size() <= lIndex)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        Assert(lIndex>=0 && lIndex < Size());
        pcstr = (CStr *)Deref(sizeof(CStr), lIndex);
        *ppch = (TCHAR *)*pcstr;
    }
    
Cleanup:    
    RRETURN1(hr, DISP_E_MEMBERNOTFOUND);
}

long    
CAtomTable::TableSize()
{
    if (_phat)
        return _phat->TableSize();
    
    return Size();
}

LPTSTR  
CAtomTable::TableItem(long lId)
{
    Assert(lId>=0 && lId < Size());
    if (_phat)
        return _phat->TableItem(lId);
    return Item(lId);
}

void
CAtomTable::Free()
{
    if (_phat)
    {
        _phat->Free();
        delete _phat;
        _phat = NULL;

        Assert( Size() == 0 );
    }
    else
    {
        FreeArray();
    }
}

HRESULT 
CAtomTable::ConvertToHash()
{
    HRESULT hr = S_OK;
    CStr *  pcstr;
    long    i;

    _phat = new CHashAtomTable();
    if (!_phat)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // NOTE: we should probably find a way to do this conversion
    // without reallocating the strings
    for (i=0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        hr = _phat->AddNameWithID( *pcstr, i );
        if (hr)
            goto Cleanup;
    }

    FreeArray();

Cleanup:
    if (hr && _phat)
    {
        _phat->Free();
        delete _phat;
        _phat = NULL;
    }

    RRETURN(hr);
}

void
CAtomTable::FreeArray()
{
    CStr *  pcstr;
    long    i;
    
    for (i = 0; i < Size(); i++)
    {
        pcstr = (CStr *)Deref(sizeof(CStr), i);
        pcstr->Free();
    }
    DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\border.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       border.cxx
//
//  Contents:   Border helper implementation
//
//  Functions:  DrawBorder
//
//  History:    18-Jul-95   SumitC      Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

// global const definitions

const int HAIRLINE_IN_HIMETRICS = 26;
const int BORDEREFFECT_IN_HIMETRICS = 52;


//+-------------------------------------------------------------------------
//
//  Method:     DrawEdge2
//
//  Synopsis:   This routine is functionally equivalent to the Win95
//              DrawEdge API, except the following are not supported:
//                  BF_SOFT, BF_ADJUST, BF_FLAT, BF_MONO, BF_DIAG*
//              Also, colors to be used are passed in by the "c3d"
//              (ThreeDColors object) reference, rather than assuming
//              and being limited to the system colors.
//
//              If BF_MONO flag is specified, only the inner border is
//              drawn. This is used to draw flat scrollbars.
//
//--------------------------------------------------------------------------

void DrawEdge2(XHDC hdc,
        LPRECT lprc,
        UINT edge,
        UINT flags,
        ThreeDColors & c3d,
        COLORREF colorBorder,
        UINT borderXWidth,
        UINT borderYWidth)
{
    COLORREF    colorTL;
    COLORREF    colorBR;
    RECT        rc;
    RECT        rc2;
    UINT        bdrMask;
    HBRUSH      hbrOld = NULL;
    COLORREF    crNow  = (COLORREF)0xFFFFFFFF;

    rc = *lprc;
    BOOL foutEffect = !(flags & BF_MONO); // No outer border if BF_MONO

    int XIn, XOut = 0, YIn, YOut = 0; //init XOut, YOut for retail build to pass

    if (foutEffect)
    {
        // border width can be odd number of pixels, so we divide it between
        // the inner and outer effect.

        XIn = borderXWidth / 2;
        XOut = borderXWidth - XIn;

        YIn = borderYWidth / 2;
        YOut = borderYWidth - YIn;
    }
    else
    {
        XIn = borderXWidth;
        YIn = borderYWidth;
    }

    Assert((BDR_OUTER == 0x0003) && (BDR_INNER == 0x000C));

    Assert(rc.left <= rc.right);
    Assert(rc.top <= rc.bottom);
    if (! (flags & BF_FLAT))
    {
        bdrMask = (foutEffect) ? BDR_OUTER : BDR_INNER;
        for (; bdrMask <= BDR_INNER; bdrMask <<= 2)
        {
            switch (edge & bdrMask)
            {
                case BDR_RAISEDOUTER:
                    colorTL = (flags & BF_SOFT) ? c3d.BtnHighLight() : c3d.BtnLight();
                    colorBR = c3d.BtnDkShadow();
                    break;

                case BDR_RAISEDINNER:
                    colorTL = (flags & BF_SOFT) ? c3d.BtnLight() : c3d.BtnHighLight();
                    colorBR = c3d.BtnShadow();
                    break;

                case BDR_SUNKENOUTER:
                    //fButton should be wndframe
                    colorTL = (flags & BF_SOFT) ? c3d.BtnDkShadow() : c3d.BtnShadow();
                    colorBR = c3d.BtnHighLight();
                    break;

                case BDR_SUNKENINNER:
                    if (flags & BF_MONO)
                    {
                        // inversion of BDR_RAISEDINNER
                        colorTL = c3d.BtnShadow();
                        colorBR = (flags & BF_SOFT) ? c3d.BtnLight() : c3d.BtnHighLight();
                    }
                    else
                    {
                        colorTL = (flags & BF_SOFT) ? c3d.BtnShadow() :  c3d.BtnDkShadow();
                        colorBR = c3d.BtnLight();
                    }
                    break;

                default:
                    return;
            }

            if (flags & (BF_RIGHT | BF_BOTTOM))
            {
                if (colorBR != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, colorBR, &hbrNew, &hbrOld, &crNow);
                }

                if (flags & BF_RIGHT)
                {
                    rc2 = rc;
                    rc2.left = (rc.right -= foutEffect ? XOut : XIn);
                    if (rc2.left < rc.left)
                        rc2.left = rc.left;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }

                if (flags & BF_BOTTOM)
                {
                    rc2 = rc;
                    rc2.top = (rc.bottom -= foutEffect ? YOut : YIn);
                    if (rc2.top < rc.top)
                        rc2.top = rc.top;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }
            }

            if (flags & (BF_LEFT | BF_TOP))
            {
                if (colorTL != crNow)
                {
                    HBRUSH hbrNew;
                    SelectCachedBrush(hdc, colorTL, &hbrNew, &hbrOld, &crNow);
                }
    
                if (flags & BF_LEFT)
                {
                    rc2 = rc;
                    rc2.right = (rc.left += foutEffect ? XOut : XIn);
                    if (rc2.right > rc.right)
                        rc2.right = rc.right;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }

                if (flags & BF_TOP)
                {
                    rc2 = rc;
                    rc2.bottom = (rc.top += foutEffect ? YOut : YIn);
                    if (rc2.bottom > rc.bottom)
                        rc2.bottom = rc.bottom;
                    PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                        rc2.bottom - rc2.top, PATCOPY);
                }
            }
            if (foutEffect)
                foutEffect = FALSE;
        }
    }
    else
    {
        if (colorBorder != crNow)
        {
            HBRUSH hbrNew;
            SelectCachedBrush(hdc, colorBorder, &hbrNew, &hbrOld, &crNow);
        }

        if (flags & BF_RIGHT)
        {
            rc2 = rc;
            rc2.left = (rc.right -= borderXWidth);
            if (rc2.left < rc.left)
                rc2.left = rc.left;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_BOTTOM)
        {
            rc2 = rc;
            rc2.top = (rc.bottom -= borderYWidth);
            if (rc2.top < rc.top)
                rc2.top = rc.top;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_LEFT)
        {
            rc2 = rc;
            rc2.right = (rc.left += borderXWidth);
            if (rc2.right > rc.right)
                rc2.right = rc.right;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }

        if (flags & BF_TOP)
        {
            rc2 = rc;
            rc2.bottom = (rc.top += borderYWidth);
            if (rc2.bottom > rc.bottom)
                rc2.bottom = rc.bottom;
            PatBlt(hdc, rc2.left, rc2.top, rc2.right - rc2.left,
                rc2.bottom - rc2.top, PATCOPY);
        }
    }

    if (flags & BF_MIDDLE)
    {
        if (c3d.BtnFace() != crNow)
        {
            HBRUSH hbrNew;
            SelectCachedBrush(hdc, c3d.BtnFace(), &hbrNew, &hbrOld, &crNow);
        }
        PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
            rc.bottom - rc.top, PATCOPY);
    }

    if (hbrOld)
        ReleaseCachedBrush((HBRUSH)SelectObject(hdc, hbrOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   BRGetBorderWidth
//
//  Synopsis:   Return the border size in himetrics given border attributes
//
//  Arguments:  [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    int          -- -1 is an error value
//
//  History:    9-13-95 created [gideons]
//
//----------------------------------------------------------------------------

int
BRGetBorderWidth( fmBorderStyle BorderStyle )
{
    int uBorderWidth;

    // count for the beveled edge

    if (BorderStyle > fmBorderStyleSingle)
    {
        uBorderWidth = BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        uBorderWidth = HAIRLINE_IN_HIMETRICS;
    }
    else
    if (BorderStyle == fmBorderStyleNone)
    {
        uBorderWidth = 0;
    }
    else
    {
        uBorderWidth = -1;
    }

    return uBorderWidth;
}






//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustRectForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              taking zooming into account
//
//  Arguments:  [pDI]         -- CDrawInfo
//              [prcl]        -- rectangle to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------


HRESULT
BRAdjustRectForBorderActual(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle,
        BOOL            fInflateForBorder)
{
    int uInflateXBy, uInflateYBy;
    UINT inflateUnit;

    Assert(prc);

    // count for the beveled edge

    if (BorderStyle > fmBorderStyleSingle)
    {
        // inflateUnit is 52 HiMetrics
        inflateUnit =  BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        // inflateUnit = 26 HiMetrics.
        inflateUnit = HAIRLINE_IN_HIMETRICS;
    }
    else
        goto Cleanup;

    // compute the actually border dimentions
    uInflateXBy =  pdocScaleInfo->DeviceFromHimetricX(inflateUnit);
    uInflateYBy =  pdocScaleInfo->DeviceFromHimetricY(inflateUnit);

    // Border width can't go below 1 pixel
    if (uInflateXBy == 0)
        uInflateXBy = 1;

    if (uInflateYBy == 0)
        uInflateYBy = 1;

    // Compute border size with zooming.
    if (fInflateForBorder)
        InflateRect((RECT *)prc, uInflateXBy, uInflateYBy );
    else
        InflateRect((RECT *)prc, -uInflateXBy, -uInflateYBy );

   if (prc->left > prc->right)
        prc->left = prc->right;
    if (prc->top > prc->bottom)
        prc->top = prc->bottom;

Cleanup:
    return S_OK;
}

HRESULT
BRAdjustRectForBorder(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle)
{
    return BRAdjustRectForBorderActual(
                    pdocScaleInfo,
                    prc,
                    BorderStyle,
                    FALSE);
}

HRESULT
BRAdjustRectForBorderRev(
        CDocScaleInfo * pdocScaleInfo,
        RECT *          prc,
        fmBorderStyle   BorderStyle)
{
    return BRAdjustRectForBorderActual(
                    pdocScaleInfo,
                    prc,
                    BorderStyle,
                    TRUE);
}






//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustRectlForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              WITHOUT taking zooming into account
//
//  Arguments:  [prcl]        -- rectangle to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------

HRESULT
BRAdjustRectlForBorder
(
        RECTL * prcl,
        fmBorderStyle BorderStyle)
{

    if (BorderStyle > fmBorderStyleSingle)
    {
        // Compute border size with zooming.

        InflateRect((RECT *)prcl,
                    -BORDEREFFECT_IN_HIMETRICS, -BORDEREFFECT_IN_HIMETRICS);
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        // Compute border size with zooming.
        InflateRect((RECT *)prcl,
                    -HAIRLINE_IN_HIMETRICS, -HAIRLINE_IN_HIMETRICS );
    }


    return S_OK;
}





//+---------------------------------------------------------------------------
//
//  Function:   BRAdjustSizelForBorder
//
//  Synopsis:   adjusts a given rectangle's client area given border attributes
//              WITHOUT taking zooming into account
//
//  Arguments:  [psizel]      -- sizel to adjust
//              [BorderStyle] -- borderstyle
//              [Effect]      -- border effect
//              [fSubtractAdd]-- add or subtract borders from the size
//
//  Returns:    HRESULT
//
//  History:    09-19-95    gideons     created
//
//----------------------------------------------------------------------------

HRESULT
BRAdjustSizelForBorder
(
        SIZEL * psizel,
        fmBorderStyle BorderStyle,
        BOOL fSubtractAdd)
{

    int iSubtractAdd = fSubtractAdd? 1: -1;

    if (BorderStyle > fmBorderStyleSingle)
    {
        psizel->cx += iSubtractAdd * 2 * BORDEREFFECT_IN_HIMETRICS;
        psizel->cy += iSubtractAdd * 2 * BORDEREFFECT_IN_HIMETRICS;
    }
    else // if no effect count for a single (for now) border line
    if (BorderStyle == fmBorderStyleSingle)
    {
        psizel->cx += iSubtractAdd * 2 * HAIRLINE_IN_HIMETRICS;
        psizel->cy += iSubtractAdd * 2 * HAIRLINE_IN_HIMETRICS;
    }

    // Don't allow a negative size
    psizel->cx = max(psizel->cx, 0L);
    psizel->cy = max(psizel->cy, 0L);

    return S_OK;
}




void DrawEdge2(HDC hdc,
        LPRECT lprc,
        UINT edge,
        UINT flags,
        ThreeDColors & c3d,
        COLORREF colorBorder,
        UINT borderXWidth,
        UINT borderYWidth);






//+---------------------------------------------------------------------------
//
//  Function:   BRDrawBorder
//
//  Synopsis:   Draws a border for a Forms3 control, or the form
//
//  Arguments:  [pDI]         -- [in] CDrawInfo *
//              [prc]         -- [in,out] rect in pixels
//              [BorderStyle] -- border style
//              [Effect]      -- border effect
//              [colorBorder] -- color of Border
//              [dwFlags]     -- BRFLAGS_BUTTON: if set, use "hard" edges.  usually use "soft"
//                               BRFLAGS_ADJUSTRECT: if set, adjust the rect to reflect the
//                               border drawn.
//                               BRFLAGS_DEFAULT: if set draw default button retangle around
//                               drawing rect and insert everything else accordingly
//
//  Returns:    HRESULT
//
//  History:    05-Sep-95   SumitC      Created
//              09-12-95    gideons     modified to support zooming
//
//----------------------------------------------------------------------------


HRESULT
BRDrawBorder(
        CDrawInfo *pDI,
        RECT * prc,
        fmBorderStyle BorderStyle,
        COLORREF colorBorder,
        ThreeDColors * peffectColor,
        DWORD dwFlags)
{
    ThreeDColors    *ptdc;
    ThreeDColors    tdc;
    UINT            uBdrXWidth;
    UINT            uBdrYWidth;
    UINT            uEdgeStyle = 0, uEdgeFlags = 0;
    UINT            borderUnit;


    if (peffectColor == NULL)
    {
        ptdc = &tdc; // get the default colors
    }
    else
    {
        ptdc = peffectColor;
    }

    Assert(ptdc != NULL);
    AssertXHDC(pDI->_hdc);


    if(dwFlags & BRFLAGS_DEFAULT)
    {
        uBdrYWidth = pDI->DeviceFromHimetricY(HAIRLINE_IN_HIMETRICS);
        uBdrXWidth = pDI->DeviceFromHimetricX(HAIRLINE_IN_HIMETRICS);

        DrawEdge2(pDI->_hdc,
                  (RECT *)prc,
                  0,
                  BF_FLAT | BF_RECT,
                  *ptdc,
                  colorBorder,
                  uBdrXWidth,
                  uBdrYWidth);

        BRAdjustRectForBorder(pDI,
                              (RECT *) prc,
                              fmBorderStyleSingle);
    }

    // draw the beveled edge
    if (BorderStyle > fmBorderStyleSingle)
    {
        borderUnit =  (dwFlags & BRFLAGS_MONO) ?
                        HAIRLINE_IN_HIMETRICS :
                        BORDEREFFECT_IN_HIMETRICS;

        switch (BorderStyle)
        {
        case fmBorderStyleRaised:
            uEdgeStyle = EDGE_RAISED;
            break;

        case fmBorderStyleSunken:
            uEdgeStyle = EDGE_SUNKEN;
            break;

        case fmBorderStyleEtched:
            uEdgeStyle = EDGE_ETCHED;
            break;

        case fmBorderStyleBump:
            uEdgeStyle = EDGE_BUMP;
            break;

        default:
            Assert(0 && "CBorderHelper::Render, illegal effect value");
        }

        // Draw the border of the control

        uEdgeFlags = BF_RECT | ((dwFlags & BRFLAGS_BUTTON) ? BF_SOFT : 0);
        if (dwFlags & BRFLAGS_MONO)
        {
            uEdgeFlags |= BF_MONO;
        }
    }
    else if (BorderStyle == fmBorderStyleSingle)
    {
        borderUnit = HAIRLINE_IN_HIMETRICS;

        uEdgeFlags = BF_FLAT | BF_RECT;
    }
    else
        goto cleanup;   // nothing to do


    uBdrYWidth = pDI->DeviceFromHimetricY(borderUnit);
    uBdrXWidth = pDI->DeviceFromHimetricX(borderUnit);

    // border width can not go below 1 pixel
    if (uBdrYWidth == 0)
        uBdrYWidth = 1;

    if (uBdrXWidth == 0)
        uBdrXWidth = 1;

   //Draw the border
   //NOTE DrawEdge2  currently checks for underflow of prc
    DrawEdge2(pDI->_hdc,
              (RECT *)prc,
              uEdgeStyle,
              uEdgeFlags,
              *ptdc,
              colorBorder,
              uBdrXWidth,
              uBdrYWidth);

    if (dwFlags & BRFLAGS_ADJUSTRECT)
    {
        BRAdjustRectForBorder( pDI, prc, BorderStyle);
    }

cleanup:

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\baseprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       baseprot.cxx
//
//  Contents:   Implementation of a base class for pluggable protocols
//
//  History:    02-12-97    AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_BASEPROT_HXX_
#define X_BASEPROT_HXX_
#include "baseprot.hxx"
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::QueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IInternetProtocolInfo)
    {
        *ppv = (IInternetProtocolInfo *)this;
    }
    else
    {
        RRETURN(super::QueryInterface(riid, ppv));
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::ParseUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    CStr    cstr;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!pcchResult || !pwzResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (ParseAction == PARSE_DOMAIN)
    {
        BSTR bstrTemp;

        hr = THR(UnwrapSpecialUrl(pwzUrl, cstr));
        if (hr)
            goto Cleanup;

        *pcchResult = cstr.Length() + 1;
        
        if (cstr.Length() + 1 > cchResult)
        {
            // Not enough room
            hr = S_FALSE;
            goto Cleanup;
        }

        cstr.AllocBSTR(&bstrTemp);

        UrlGetPartW(bstrTemp, pwzResult, pcchResult, URL_PART_HOSTNAME, 0);  
        SysFreeString(bstrTemp);
    }

Cleanup:
    RRETURN2(hr, INET_E_DEFAULT_ACTION, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::CombineUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::CombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;
    // get the correct base url for navigating to a non-pluggable protocol from a
    // pluggable protocol. We get here from CoInternetCombineUrl if the base url is
    // a pluggable protocol. So, search for the last embedded \1 to extract the true
    // base url and if present, call the API again to combine the non-pluggable
    // protocol url properly. if not prest, just tell urlmon to do the default thing.
    if (pwzBaseUrl)
    {
        TCHAR *pchSrc = _tcsrchr(pwzBaseUrl, _T('\1'));
        if (pchSrc)
        {
            hr = THR(CoInternetCombineUrl(
                    ++pchSrc, 
                    pwzRelativeUrl, 
                    URL_ESCAPE_SPACES_ONLY, 
                    pwzResult, 
                    cchResult, 
                    pcchResult, 
                    0));
        }
    }

    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::CompareUrl
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::CompareUrl(
    LPCWSTR     pwzUrl1,
    LPCWSTR     pwzUrl2,
    DWORD       dwFlags)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocolCF::QueryInfo
//
//  Synopsis:   per IInternetProtocolInfo
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocolCF::QueryInfo(
    LPCWSTR         pwzUrl,
    QUERYOPTION     QueryOption,
    DWORD           dwQueryFlags,
    LPVOID          pvBuffer,
    DWORD           cbBuffer,
    DWORD *         pcbBuffer,
    DWORD           dwReserved)
{
    HRESULT hr = INET_E_DEFAULT_ACTION;

    switch (QueryOption)
    {
    case QUERY_USES_NETWORK:
        {
            if (!pvBuffer || cbBuffer < sizeof(DWORD))
                return E_FAIL;

            if (pcbBuffer)
            {
                *pcbBuffer = sizeof(DWORD);
            }

            *(DWORD *)pvBuffer = FALSE;
            hr = S_OK;
        }
        break;

    case QUERY_IS_SECURE:
        {
            if (!pvBuffer || cbBuffer < sizeof(DWORD))
                return E_FAIL;

            if (pcbBuffer)
            {
                *pcbBuffer = sizeof(DWORD);
            }

            *(DWORD *)pvBuffer = HasSecureContext(pwzUrl);
            hr = S_OK;
        }
        break;
    }

    RRETURN1(hr, INET_E_DEFAULT_ACTION);
}


//+---------------------------------------------------------------------------
//
//  Method:     UnwrapSpecialUrl
//
//  Synopsis:   Helper to unwrap a url by lopping off any stuff after \1
//
//----------------------------------------------------------------------------

HRESULT
UnwrapSpecialUrl(LPCWSTR pchUrl, CStr &cstrUnwrappedUrl)
{
    TCHAR * pchSpecial = NULL;
    HRESULT hr = S_OK;
    static TCHAR   ach[pdlUrlLen];
    DWORD   dwSize;
        
    hr = THR(CoInternetParseUrl(
            pchUrl, 
            PARSE_ENCODE, 
            0, 
            ach, 
            ARRAY_SIZE(ach), 
            &dwSize, 
            0));
    if (hr)
        goto Cleanup;

    pchSpecial = _tcsrchr(ach, _T('\1'));
    if (pchSpecial)
    {
        hr = THR(cstrUnwrappedUrl.Set(pchSpecial + 1));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(cstrUnwrappedUrl.Set(ach));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBaseProtocol::CBaseProtocol(IUnknown *pUnkOuter) : super()
{
    _pUnkOuter = pUnkOuter ? pUnkOuter : PunkInner();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBaseProtocol::~CBaseProtocol()
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Passivate
//
//  Synopsis:   1st stage dtor
//
//----------------------------------------------------------------------------

void
CBaseProtocol::Passivate()
{
    ClearInterface(&_pStm);
    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::PrivateQueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = PunkInner();
    }
    else if (riid == IID_IInternetProtocol || riid == IID_IInternetProtocolRoot)
    {
        *ppv = (IInternetProtocol *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }

    Assert(*ppv);
    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Start(
    LPCWSTR pchUrl, 
    IInternetProtocolSink *pTrans, 
    IInternetBindInfo *pOIBindInfo,
    DWORD grfSTI, 
    HANDLE_PTR dwReserved)
{
    HRESULT         hr = NOERROR;
    PROTOCOLDATA    protdata;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    Assert(!_pProtSink && pOIBindInfo && pTrans && !_cstrURL);

    if ( !(grfSTI & PI_PARSE_URL))
    {
        ReplaceInterface(&_pProtSink, pTrans);
        ReplaceInterface(&_pOIBindInfo, pOIBindInfo);
    }

    _bindinfo.cbSize = sizeof(BINDINFO);
    hr = THR(pOIBindInfo->GetBindInfo(&_grfBindF, &_bindinfo));

    //
    // First get the basic url.  Unescape it first.
    //

    hr = THR(CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0, ach, ARRAY_SIZE(ach), &dwSize, 0));
    if (hr)
        goto Cleanup;
    
    hr = THR(_cstrURL.Set(ach));
    if (hr)
        goto Cleanup;

    //
    // Now append any extra data if needed.
    //
    
    if (_bindinfo.szExtraInfo)
    {
        hr = THR(_cstrURL.Append(_bindinfo.szExtraInfo));
        if (hr)
            goto Cleanup;
    }

    _grfSTI = grfSTI;

    //
    // Always go async and return E_PENDING now.
    // Perform script execution when we get the Continue.
    //

    hr = E_PENDING;
    protdata.grfFlags = PI_FORCE_ASYNC;
    protdata.dwState = BIND_ASYNC;
    protdata.pData = NULL;
    protdata.cbData = 0;

    _pProtSink->Switch(&protdata);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    HRESULT hr = E_FAIL;

    if (_fAborted)
        return hr;

    Assert(!pStateInfoIn->pData && !pStateInfoIn->cbData && 
            pStateInfoIn->dwState == BIND_ASYNC);

    if (pStateInfoIn->dwState == BIND_ASYNC)
    {
        hr =  THR(ParseAndBind());
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    _fAborted = TRUE;
    RRETURN(_pProtSink->ReportResult(E_ABORT, 0, 0));
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Terminate(DWORD dwOptions)
{
    ClearInterface(&_pOIBindInfo);
    ClearInterface(&_pProtSink);
    ReleaseBindInfo(&_bindinfo);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Suspend()
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Resume()
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    
    if (!_pStm)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = THR(_pStm->Read(pv, cb, pcbRead));
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    HRESULT hr = S_OK;
    
    if (!_pStm)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = THR(_pStm->Seek(dlibMove, dwOrigin, plibNewPosition));
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::LockRequest(DWORD dwOptions)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:   per IInternetProtocol
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::UnlockRequest()
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryService
//
//  Synopsis:   per IServiceProvider
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::QueryService(REFGUID rsid, REFIID riid, void ** ppv)
{
    HRESULT             hr = S_OK;
    IServiceProvider *  pSP = NULL;

    *ppv = NULL;

    hr = THR_NOTRACE(_pProtSink->QueryInterface(
            IID_IServiceProvider, (void **)&pSP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pSP->QueryService(rsid, riid, ppv));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSP);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::ParseAndBind
//
//  Synopsis:   Actually perform the binding.
//              Derived classes should just implement this one method
//
//----------------------------------------------------------------------------

HRESULT
CBaseProtocol::ParseAndBind()
{
    if (_pProtSink)
    {
        _pProtSink->ReportResult(E_UNEXPECTED, 0, 0);
    }
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     HasSecureContext
//
//  Synopsis:   Scans a \1-style URL to see if it should be treated as secure
//
//----------------------------------------------------------------------------
BOOL
HasSecureContext(const TCHAR *pchUrl)
{
    TCHAR *pchSpecial; 
    TCHAR *pchNext;
    TCHAR ach[pdlUrlLen]; 
    DWORD dwSize; 

    if (! THR(CoInternetParseUrl( 
        pchUrl, 
        PARSE_ENCODE, 
        0, 
        ach, 
        ARRAY_SIZE(ach), 
        &dwSize, 
        0))) 
    {
        // 1. scan for \1\1 - if present, we have mixed security somewhere along the way
        pchSpecial = ach;

        for (;;)
        {
            pchNext = _tcschr(pchSpecial, _T('\1'));
            
            if (!pchNext)
                break;
                
            pchSpecial = pchNext + 1;

            // Mixed security or missing context: not secure
            
            if (*pchSpecial == _T('\1') || *pchSpecial == _T('\0'))
                return FALSE;
        }
        
        // Last context is https: secure
        
        if (pchSpecial && URL_SCHEME_HTTPS == GetUrlScheme(pchSpecial)) 
            return TRUE; 
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\alpha.asm ===
//----------------------------------------------------------------------------
 //
 // File:     alpha.asm
 //
 // Contains: Assembly code for the Alpha. Implements the dynamic vtable stuff
 //           and the tearoff code.
 //
 //----------------------------------------------------------------------------

.globl DynLinkFunc
.globl CallTornOffMethod

#include <dvtbl.h>

offsetof_pvObject         = 12  // Must be kept in sync with the source code
offsetof_apfn             = 16  // Ditto


rIndex    = $t0
rThis     = $a0

rTemp     = $t1
rTmp2     = $t2
rpFnTable = $t3

.align 3

 // Ensure that DynLinkFunc stays exactly how we expect
.set noreorder
.set nomacro

 //----------------------------------------------------------------------------
 //
 //  Function:  DynLinkFunc
 //
 //  Synopsis:  The code that is put into the dynamic vtable thunks
 //
 //  Notes:     The various 0x7000 constants are replaced on the fly with
 //             appropriate values by InitDynamicVtable.
 //
 //             NOTE: If the MSB of the low word of the offset is 1, then
 //             the high word of the offset must have 1 added to it, since
 //             these instructions sign extend the low word and add it to
 //             the high word.
 //
 //----------------------------------------------------------------------------
.ent DynLinkFunc

DynLinkFunc:

    lda  rIndex, 0x7000($zero) // Store the index (replace 7000 w/ index)
    ldl  rTemp,  0x0(rThis)    // Move vtable pointer into reg
    ldah rTemp,  0x7000(rTemp) // Add high word of offset to vtable ptr
    ldl  rTemp,  0x7000(rTemp) // Add (sign extended) low word of offset to the
                               //   vtable ptr & get the "handler" function ptr
    jmp  (rTemp)               // Call the "handler" function
                               // The offset is the offset between g_pvtbl
                               //   and g_apfnThunkers, computed and replaced
                               //   by InitDynamicVtable.
.end DynLinkFunc

.set macro
.set reorder

 //----------------------------------------------------------------------------
 //
 //  Function:  CallTornOffMethod
 //
 //  Synopsis:  The "handler" function that handles calls to torn-off interfaces
 //
 //  Notes:     Delegates to methods in the function pointer array held by
 //             the CTearOffThunk class
 //
 //----------------------------------------------------------------------------

.align 3


.ent CallTornOffMethod

CallTornOffMethod:

    // Value in rIndex was stored by DynLinkFunc

    ldl    rpFnTable, offsetof_apfn(rThis)          // Get table of functions

    // NOTE: Uncomment the following line if DVTBL_OFFSET_TEAROFF is nonzero.
    // subl   rIndex, DVTBL_OFFSET_TEAROFF, rIndex  // Adjust thunk index

    subl   rIndex, NUMBER_CTIUNKNOWN_METHODS, rTemp // Are we calling IUnknown?
    ldl    rTmp2,  offsetof_pvObject(rThis)         // Get object's this ptr
    s4addl rIndex, rpFnTable, rpFnTable             // Get the entry in table
    cmovge rTemp,  rTmp2, rThis                     // Store new this ptr if
                                                    //   not calling IUnknown
    ldl    rTemp, 0x0(rpFnTable)                    // Get the fn pointer
    jmp    (rTemp)                                  // Call function

.end CallTornOffMethod
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\assoc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       assoc.cxx
//
//  Contents:   String-indexed bag classses (associative-array)
//
//              CPtrBag   (case-sensitive)
//              CPtrBagCi (optionally case-insensitive)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#define ASSOC_HASH_MARKED ((CAssoc*)1)
#define ASSOCVTABLE_HASH_MARKED  ((CAssocVTable *)1)

#ifdef PDLPARSE
#include <stdio.h>
#include <tchar.h>
#define THR(x) x
#define RRETURN(x) return x
#else
MtDefine(CAssoc, PerProcess, "CAssoc")
#endif
//+---------------------------------------------------------------------------
//
//  Variable:   s_asizeAssoc
//
//              A list of primes for use as hashing modulii
//
//----------------------------------------------------------------------------
extern const DWORD s_asizeAssoc[];
const DWORD s_asizeAssoc[] = {/* 3,5,7,11,17,23, */ 37,59,89,139,227,359,577,929,
    1499,2423,3919,6337,10253,16573,26821,43391,70207,113591,183797,297377,
    481171,778541,1259701,2038217,3297913,5336129,8633983,13970093,22604069,
    36574151,59178199,95752333,154930511,250682837,405613333,656296153,
    1061909479,1718205583,2780115059};

// an alternate list (grows faster)
#if 0
const DWORD s_asizeAssoc[] = {/*3,5,7,13,*/23,43,83,163,317,631,1259,2503,5003,9973,
    19937,39869,79699,159389,318751,637499,1274989,2549951,5099893,10199767,
    20399531,40799041,81598067,163196129,326392249,652784471,1305568919,
    2611137817};
#endif


//+---------------------------------------------------------------------------
//
//  Function:   HashPtr
//
//              Computes a 32-bit hash for a ptr, in the manner compatible
//              with HasString and HashStringCi, starting with a given hash
//
// TODO asm version of this if anyone cares
//----------------------------------------------------------------------------

DWORD HashPtr(LPCVOID pvKey, DWORD hash)
{
    Assert (pvKey); // or else we won't calc hash at all

    while (pvKey)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (DWORD)  ((DWORD_PTR)pvKey & 0x7F);
        pvKey = (LPCVOID) (((DWORD_PTR)pvKey & 0xffffffff) >> 7);
    }
    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashString
//
//              Computes a 32-bit hash value for a unicode string
//
//              asm version supplied so that we take advantage of ROR
//
//----------------------------------------------------------------------------
#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashString(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          loop_exit           ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     ch = *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        add         eax, edx            ;   //     hash += ch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashString(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += *pch; // Case-sensitive hash
        pch++;
        len--;
    }

    return hash;
}

#endif

#if !defined(PDLPARSE) && !defined(ASCPARSE)
// Takes a VTableDesc and maps it to a string.
inline const TCHAR *VTableDescToString(const VTABLEDESC *pVTableDesc)
{
    const PROPERTYDESC *pPropDesc = pVTableDesc->GetHashPropDesc();

    switch(pVTableDesc->uVTblEntry & PDLPARSE_MASK)
    {
    case PDLPARSE_BELONGSTOBOTH:
    case PDLPARSE_BELONGSTOOM:
        return pPropDesc->pstrExposedName ?
                    pPropDesc->pstrExposedName :
                    pPropDesc->pstrName;
    case PDLPARSE_BELONGSTOPARSE:
        return pPropDesc->pstrName ?
                    pPropDesc->pstrName :
                    pPropDesc->pstrExposedName;
    default:
        AssertSz(0, "Illegal value for VTable flags");
        return NULL;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCi
//
//              Computes a 32-bit hash value for a unicode string which
//              is case-insensitive for ASCII characters.
//
//              asm version supplied so that we take advantage of ROR
//
//              Not unicode safe
//
//----------------------------------------------------------------------------

#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashStringCi(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          loop_exit           ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        and         dx, ~(_T('a')-_T('A'))
        add         eax, edx            ;   //     hash += *pch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashStringCi(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
        len--;
    }

    return hash;
}

#endif

DWORD HashStringWordCi(const TCHAR *pch, DWORD hash)
{
    while (*pch)
    {
        hash = (hash >> 7) | (hash << (32-7));
        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
    }

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiTryW
//
//  Computes a hash value for a string.
//  Returns a sentinel value if string is unicode.
//
//  Unicode Safe
//
//----------------------------------------------------------------------------

#if defined(_M_IX86)

#pragma warning(disable:4035) // implicit return value left in eax

DWORD HashStringCiTryW(const TCHAR *pch, DWORD len, DWORD hash)
{
    _asm {
        mov         ecx, len            ;   // ecx = len
        mov         ebx, pch            ;   // ebx = pch
        mov         eax, hash           ;   // eax = hash
        xor         edx, edx            ;   // edx = 0
        cmp         ecx, 0              ;   // while (!len)
        je          zero_chk            ;   // {
    loop_top:
        mov         dx, word ptr [ebx]  ;   //     ch = *pch
        ror         eax, 7              ;   //     hash = (hash >> 7) | (hash << (32-7))
        add         ebx, 2              ;   //     pch++
        cmp         dx, 128                 //     if (128 < ch)
        jnl         sentinel_value          //          goto sentinel_value
        and         dx, ~(_T('a')-_T('A'))  //     ch = ch & (~(_T('a')-_T('A')))
        add         eax, edx            ;   //     hash += ch
        dec         ecx                 ;   //     len--
        jnz         loop_top            ;   // }
        jmp         zero_chk
    sentinel_value:
        mov         eax, SENTINEL_VALUE
        jmp         loop_exit
    zero_chk:
        cmp         eax, 0              ;   // if we have a 0 hash, return 1
        jnz         loop_exit
        mov         eax, 1
    loop_exit:
    }                                       // result in eax
}

#pragma warning(default:4035)

#else

DWORD HashStringCiTryW(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));

        if (*pch > 127)
            return SENTINEL_VALUE;

        hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash
        pch++;
        len--;
    }

    // We dont want to return a 0 (especially if we are using a hash table etc).
    if (hash == 0)
        return 1;

    return hash;
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiW
//
//  Computes a hash value for all unicode strings.
//
//  Unicode safe
//
//----------------------------------------------------------------------------

DWORD HashStringCiW(const TCHAR *pch, DWORD len, DWORD hash)
{
    while (len)
    {
        hash = (hash >> 7) | (hash << (32-7));
#if !defined(PDLPARSE) && !defined(ASCPARSE)
        if (*pch > 127)
            hash += (TCHAR)CharUpper((LPTSTR)((DWORD_PTR)(*pch)));
#else
        // NOTE: don't put anything unicode in pdl files
        if (*pch > 127)
            DebugBreak();
#endif
        else
            hash += (*pch & ~(_T('a')-_T('A'))); // Case-insensitive hash

        pch++;
        len--;
    }

    // We dont want to return a 0 (especially if we are using a hash table etc).
    if (hash == 0)
        return 1;

    return hash;
}

//+---------------------------------------------------------------------------
//
//  Function:   HashStringCiDetectW
//
//  Computes a hash value for all strings.
//
//  Unicode safe
//
//----------------------------------------------------------------------------

DWORD HashStringCiDetectW(const TCHAR *pch, DWORD len, DWORD hash)
{
    DWORD dwHash = HashStringCiTryW(pch, len, hash);

    if (dwHash == SENTINEL_VALUE)
        return HashStringCiW(pch, len, hash);
    else
        return dwHash;
}

//+---------------------------------------------------------------------------
//
//  Function:   _tcsnzequal
//
//              Tests equality of two strings, where the first is
//              specified by pch/cch, and the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _tcsnzequal(const TCHAR *string1, DWORD cch, const TCHAR *string2)
{
    while (cch)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;
        cch --;
    }

    return (*string2) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _7csnziequal
//
//              Tests 7-bit-case-insensitive equality of two strings, where
//              the first is specified by pch/cch, and the second is
//              \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _7csnziequal(const TCHAR *string1, DWORD cch, const TCHAR *string2)
{
    while (cch)
    {
        if (*string1 != *string2)
        {
            if ((*string1 ^ *string2) != _T('a') - _T('A'))
                return FALSE;

            if (((unsigned)(*string2 - _T('A')) > _T('Z') - _T('A')) &&
                ((unsigned)(*string2 - _T('a')) > _T('z') - _T('a')))
                return FALSE;
        }
        string1 += 1;
        string2 += 1;
        cch --;
    }

    return (*string2) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   _tcsnzequalWord
//
//              Tests equality of two strings, where the first and
//              the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _tcsnzequalWord(const TCHAR *string1, const TCHAR *string2)
{
    while (*string1)
    {
        if (*string1 != *string2)
            return FALSE;

        string1 += 1;
        string2 += 1;
    }

    return (*string2) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   _7csnziequal
//
//              Tests 7-bit-case-insensitive equality of two strings, where
//              the first and the second is \00-terminated.
//
//----------------------------------------------------------------------------
BOOL _7csnziequalWord(const TCHAR *string1, const TCHAR *string2)
{
    while (*string1)
    {
        if (*string1 != *string2)
        {
            if ((*string1 ^ *string2) != _T('a') - _T('A'))
                return FALSE;

            if (((unsigned)(*string2 - _T('A')) > _T('Z') - _T('A')) &&
                ((unsigned)(*string2 - _T('a')) > _T('z') - _T('a')))
                return FALSE;
        }
        string1 += 1;
        string2 += 1;
    }

    return (*string2) ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::Init
//
//  Synopsis:   Initializes CAssocArray to _cHash = 1.
//              An initial size >0 is required to allow "hash % _mHash".
//
//              Note: to avoid memory allocation here,
//              _pAssocHash and _pAssocs are init'ed to point to a dummy
//              member _assocOne.
//
//  Arguments:  [pch] -- String to match the assoc
//              [hash]-- the result of HashAssocString(pch)
//
//  Returns:    CAssoc (possibly NULL)
//
//----------------------------------------------------------------------------
void CAssocArray::Init()
{
    // init hashtable
    _pHashTable   = &_pAssocOne;
    _pAssocOne    = NULL;
    _cHash        = 0;
    _mHash        = 1;
    _sHash        = 0;
    _maxHash      = 0;
    _iSize        = 0;

    Assert(!_fStatic);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::~CAssocArray
//
//  Synopsis:   Deletes all the assocs stored in the table and frees
//              the hash table memory.
//
//              Note: _pAssocHash is only freed if it does not point to _assocOne.
//
//  Arguments:  [pch] -- String to match the assoc
//              [hash]-- the result of HashAssocString(pch)
//
//  Returns:    CAssoc (possibly NULL)
//
//----------------------------------------------------------------------------
void CAssocArray::Deinit()
{
    Assert(!_fStatic);

    // CAUTION: we delete hash table and cast (const *) to (non-const *) because we know what we are doing.
    //          the hash table is sometimes initialized with static strings,
    //          but it is then marked as _fStatic, which we just have asserted

    CAssoc **ppn = VolatileHashTablePtr();

    for (int c = _mHash; c; ppn++, c--)
    {
        delete *ppn;
    }

    if (_pHashTable != &_pAssocOne)
    {
        // CAUTION: same as above
        MemFree(VolatileHashTablePtr());
        _pHashTable = &_pAssocOne;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::AddAssoc
//
//  Synopsis:   Adds a assoc (a string-number association) to the table.
//              Neither the string nor the number should previously appear.
//
//  Returns:    HRESULT (possibly E_OUTOFMEMORY)
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AddAssoc(DWORD_PTR number, const TCHAR *pch, DWORD len, DWORD hash)
{
    CAssoc *passoc;
    HRESULT hr;

    Assert(!_fStatic);
    Assert(!AssocFromString(pch, len, hash));

    // Step 1: create the new assoc
    passoc = new ((len+1)*sizeof(TCHAR)) CAssoc;
    if (!passoc)
        return NULL;

    passoc->Init(number, pch, len, hash);

    // Step 2: verify that the tables have enough room
    if (_cHash >= _maxHash)
    {
        hr = THR(ExpandHash());
        if (hr)
            goto Error;
    }

    // Step 3: insert the new assoc in the hash array
    SetHashTableEntry(EmptyHashIndex(hash), passoc);
    _cHash++;

    return passoc;

Error:
    delete passoc;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::EmptyHashIndex
//
//  Synopsis:   Finds first empty hash index for the given hash value.
//
//----------------------------------------------------------------------------
DWORD CAssocArray::EmptyHashIndex(DWORD hash)
{
    DWORD i = hash % _mHash;
    DWORD s;

    if (!_pHashTable[i])
        return i;

    s = (hash & _sHash) + 1;

    do
    {
        if (i < s)
            i += _mHash;
        i -=s ;
    } while (_pHashTable[i]);

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::HashIndexFromString
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AssocFromString(const TCHAR *pch, DWORD cch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssoc  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::HashIndexFromStringCi
//
//  Synopsis:   Just like HashIndexFromString, but case-insensitive.
//
//----------------------------------------------------------------------------
const CAssoc *CAssocArray::AssocFromStringCi(const TCHAR *pch, DWORD cch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssoc  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _7csnziequal(pch, cch, passoc->String()))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _7csnziequal(pch, cch, passoc->String()))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArray::ExpandHash
//
//  Synopsis:   Expands the hash table, preserving order information
//              (so that colliding hash entries can be taken out in the
//              same order they were put in).
//
//----------------------------------------------------------------------------
HRESULT CAssocArray::ExpandHash()
{
    CAssoc **ppn;
    CAssoc **pHashTableOld;
    CAssoc **ppnMax;
    DWORD mHashOld;
    DWORD sHashOld;
    DWORD hash;
    DWORD i;
    DWORD s;

    Assert(_iSize < ARRAY_SIZE(s_asizeAssoc));
    Assert(!_fStatic);

    // allocate memory for expanded hash table
    ppn = (CAssoc**)MemAllocClear(Mt(CAssoc), sizeof(CAssoc*) * s_asizeAssoc[_iSize]);
    if (!ppn)
    {
        return E_OUTOFMEMORY;
    }

    // set new sizes
    pHashTableOld = VolatileHashTablePtr();
    mHashOld = _mHash;
    sHashOld = _sHash;
    _mHash = s_asizeAssoc[_iSize];
    _maxHash = _mHash/2;
    for (_sHash = 1; _sHash <= _maxHash; _sHash = _sHash << 1 | 1);
    Assert(_sHash < _mHash);
    _iSize++;
    SetHashTablePtr(ppn);

    // rehash - do per hash value to preserve the "order"
    if (_cHash)
    {
        Assert(_cHash < mHashOld);

        for (ppn = pHashTableOld, ppnMax = ppn+mHashOld; ppn < ppnMax; ppn++)
        {
            if (*ppn && *ppn != ASSOC_HASH_MARKED)
            {
                hash = (*ppn)->Hash();
                i = hash % mHashOld;
                s = (hash & sHashOld) + 1;

                // inner loop needed to preserve "hash order" for ci aliases
                while (pHashTableOld[i])
                {
                    if (pHashTableOld[i] != ASSOC_HASH_MARKED &&
                        pHashTableOld[i]->Hash() == hash)
                    {
                        SetHashTableEntry(EmptyHashIndex(hash), pHashTableOld[i]);
                        pHashTableOld[i] = ASSOC_HASH_MARKED;
                    }

                    if (i < s)
                        i += mHashOld;

                    i -= s;
                }
            }
        }
    }

    // free old memory
    if ((const CAssoc **) pHashTableOld != &_pAssocOne)
        MemFree(pHashTableOld);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::SetImpl
//
//  Synopsis:   Sets an association of the string to the void*, creating
//              a new association if needed.
//
//              TODO: remove associations if e==NULL.
//
//----------------------------------------------------------------------------
HRESULT CImplPtrBag::SetImpl(const TCHAR *pch, DWORD cch, DWORD hash, void *e)
{
    const CAssoc *passoc;

    Assert(!_fStatic);

    passoc = AssocFromString(pch, cch, hash);

    if (passoc)
        (const_cast<CAssoc *>(passoc))->_number = (DWORD_PTR)e;
    else
    {
        passoc = AddAssoc((DWORD_PTR)e, pch, cch, hash);
        if (!passoc)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::GetImpl
//
//  Synopsis:   Returns the void* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
void *CImplPtrBag::GetImpl(const TCHAR *pch, DWORD cch, DWORD hash)
{
    const CAssoc *passoc;

    passoc = AssocFromString(pch, cch, hash);

    if (passoc)
        return (void*)passoc->_number;

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::SetCiImpl
//
//  Synopsis:   Sets an association of the string to the specified void*.
//              If there is no association which satisfies a case-insensitive
//              match, a new association is created.
//
//----------------------------------------------------------------------------
HRESULT CImplPtrBag::SetCiImpl(const TCHAR *pch, DWORD cch, DWORD hash, void *e)
{
    const CAssoc *passoc;

    Assert(!_fStatic);

    passoc = AssocFromStringCi(pch, cch, hash);

    if (passoc)
        (const_cast<CAssoc *>(passoc))->_number = (DWORD_PTR)e;
    else
    {
        passoc = AddAssoc((DWORD_PTR)e, pch, cch, hash);
        if (!passoc)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBag::GetCiImpl
//
//  Synopsis:   Returns the void* associated with the given string or
//              a case-insensitive match, or NULL if none.
//
//----------------------------------------------------------------------------
void *CImplPtrBag::GetCiImpl(const TCHAR *pch, DWORD cch, DWORD hash)
{
    const CAssoc *passoc;

    passoc = AssocFromStringCi(pch, cch, hash);

    if (passoc)
        return (void*)passoc->_number;

    return NULL;
}



///////////////////////////////////////////////////////////////////////////////
//
// CStringTable
//
///////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable constructor
//
//----------------------------------------------------------------------------

CStringTable::CStringTable(CASESENSITIVITY caseSensitivity)
{
    Init();
    _fCaseSensitive = (CASESENSITIVE == caseSensitivity);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable destructor
//
//----------------------------------------------------------------------------

CStringTable::~CStringTable()
{
    Deinit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::Add
//
//----------------------------------------------------------------------------

HRESULT
CStringTable::Add (LPCTSTR pch, LONG cch, LPVOID pv, LPCVOID pvAdditionalKey, BOOL fOverride)
{
    HRESULT     hr;
    int         hash = 0;
    const CAssoc * pAssoc;

    Assert (0 < cch);
    Assert(!_fStatic);

    if (pvAdditionalKey)
    {
        hash = HashPtr(pvAdditionalKey, 0);
    }

    if (_fCaseSensitive)
    {
        hash   = HashString     (pch, cch, hash);
        pAssoc = AssocFromString(pch, cch, hash);
    }
    else
    {
        hash   = HashStringCiDetectW(pch, cch, hash);
        pAssoc = AssocFromStringCi  (pch, cch, hash);
    }

    if (pAssoc)
    {
        if (fOverride)
        {
            Assert(!_fStatic);
            (const_cast<CAssoc *>(pAssoc))->_number = (DWORD_PTR)pv;
        }

        hr = S_OK;
    }
    else
    {
        hr = AddAssoc((DWORD_PTR)pv, pch, cch, hash) ? S_OK : E_FAIL;
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::Find
//
//----------------------------------------------------------------------------

HRESULT
CStringTable::Find(LPCTSTR pch, LONG cch, LPVOID * ppv, LPCVOID pvAdditionalKey, LPCTSTR *ppString)
{
    int         hash = 0;
    const CAssoc * pAssoc;

    Assert (0 < cch);

    if (pvAdditionalKey)
    {
        hash = HashPtr(pvAdditionalKey, 0);
    }

    if (_fCaseSensitive)
    {
        hash   = HashString     (pch, cch, hash);
        pAssoc = AssocFromString(pch, cch, hash);
    }
    else
    {
        hash   = HashStringCiDetectW(pch, cch, hash);
        pAssoc = AssocFromStringCi  (pch, cch, hash);
    }

    if (pAssoc)
    {
        if (ppv)
            *ppv = (LPVOID)pAssoc->_number;

        if (ppString)
            *ppString = pAssoc->String();

        RRETURN (S_OK);
    }
    else
    {
        if (ppv)
            *ppv = NULL;

        RRETURN (E_FAIL);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator constructor
//
//----------------------------------------------------------------------------

CStringTable::CIterator::CIterator(CStringTable * pTable)
{
    _pTable = pTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Start
//
//----------------------------------------------------------------------------

void
CStringTable::CIterator::Start(CStringTable * pTable)
{
    if (pTable)
        _pTable = pTable;

    Assert (_pTable);

    _idx = -1;
    Next();
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Next
//
//----------------------------------------------------------------------------

void
CStringTable::CIterator::Next()
{
    Assert (_pTable);

    _idx++;

    while (!End() && !_pTable->_pHashTable[_idx])
    {
        _idx++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::End
//
//----------------------------------------------------------------------------

BOOL
CStringTable::CIterator::End() const
{
    Assert (_pTable);

    return _pTable->_mHash <= (DWORD)_idx;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStringTable::CIterator::Item
//
//----------------------------------------------------------------------------

LPCVOID
CStringTable::CIterator::Item() const
{
    Assert (_pTable);

    return End() ? NULL : _pTable->_pHashTable[_idx];
}

#if !defined(PDLPARSE)
#if !defined(ASCPARSE)
//+---------------------------------------------------------------------------
//
//  Member:     CAssocArrayVTable::AssocFromString
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssocVTable *
CAssocArrayVTable::AssocFromString(const TCHAR *pch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssocVTable  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _tcsnzequalWord(pch, VTableDescToString(passoc->VTableDesc())))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _tcsnzequalWord(pch, VTableDescToString(passoc->VTableDesc())))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAssocArrayVTable::AssocFromStringCi
//
//  Synopsis:   Finds the place in the hash table in which the assoc with
//              the specified string lives. If no assoc with the string is
//              present, returns the place in the hash table where the
//              assoc would be.
//
//----------------------------------------------------------------------------
const CAssocVTable *
CAssocArrayVTable::AssocFromStringCi(const TCHAR *pch, DWORD hash) const
{
    DWORD    i;
    DWORD    s;
    const CAssocVTable  *passoc;

    i = hash % _mHash;
    passoc = _pHashTable[i];

    if (!passoc)
        return NULL;

    if (passoc->Hash() == hash && _7csnziequalWord(pch, VTableDescToString(passoc->VTableDesc())))
        return passoc;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (i < s)
            i += _mHash;

        i -= s;

        passoc = _pHashTable[i];

        if (!passoc)
            return NULL;

        if (passoc->Hash() == hash && _7csnziequalWord(pch, VTableDescToString(passoc->VTableDesc())))
            return passoc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBagVTable::GetImplCs
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CImplPtrBagVTable::GetImplCs(const TCHAR *pch, DWORD hash, VTABLEDESC_OWNERENUM owner) const
{
    const CAssocVTable *passoc;

    passoc = AssocFromString(pch, hash);

    if (passoc && passoc->VTableDesc()->SlowGetPropDesc(owner))
        return passoc->VTableDesc();

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplPtrBagVTable::GetImplCi
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CImplPtrBagVTable::GetImplCi(const TCHAR *pch, DWORD hash, VTABLEDESC_OWNERENUM owner) const
{
    const CAssocVTable *passoc;

    passoc = AssocFromStringCi(pch, hash);

    if (passoc && passoc->VTableDesc()->SlowGetPropDesc(owner))
        return passoc->VTableDesc();

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator constructor
//
//----------------------------------------------------------------------------
CPtrBagVTable::CIterator::CIterator(const CPtrBagVTable * pTable)
{
    _pTable = pTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Start
//
//----------------------------------------------------------------------------
void
CPtrBagVTable::CIterator::Start(VTABLEDESC_OWNERENUM owner, const CPtrBagVTable * pTable)
{
    if (pTable)
        _pTable = pTable;

    Assert (_pTable);

    _owner = owner;

    switch(_owner)
    {
    case VTABLEDESC_BELONGSTOOM:
        _idx = _pTable->_uOMWalker;
        break;
    case VTABLEDESC_BELONGSTOPARSE:
        _idx = _pTable->_uParserWalker;
        break;
    default:
        AssertSz(0, "Illegal Value for _owner");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Next
//
//----------------------------------------------------------------------------
void
CPtrBagVTable::CIterator::Next()
{
    Assert (_pTable);
    Assert (_pTable->_pHashTable[_idx]);
    Assert (!End());

    switch(_owner)
    {
    case VTABLEDESC_BELONGSTOOM:
        _idx = _pTable->_pHashTable[_idx]->VTableDesc()->GetOMWalker();
        break;
    case VTABLEDESC_BELONGSTOPARSE:
        _idx = _pTable->_pHashTable[_idx]->VTableDesc()->GetParserWalker();
        break;
    default:
        AssertSz(0, "Illegal Value for _owner");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::End
//
//----------------------------------------------------------------------------
BOOL
CPtrBagVTable::CIterator::End() const
{
    Assert (_pTable);

    return _idx == 0x7FF;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTable::CIterator::Item
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CPtrBagVTable::CIterator::Item() const
{
    Assert (_pTable);
    Assert (_pTable->_pHashTable[_idx]);

#ifdef _PREFIX_

    /*  
        VTableDesc() is guaranteed to return a pointer to a 
        valid object. However, since Prefix doesn't know this
        we'll throw in a special assert
    */

    const VTABLEDESC *pVTblDesc = NULL;

    pVTblDesc = _pTable->_pHashTable[idx]->VTableDesc();
    Assert(pVTableDesc);

    return pVTblDesc;

#endif

    return _pTable->_pHashTable[_idx]->VTableDesc();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator constructor
//
//----------------------------------------------------------------------------
CPtrBagVTableAggregate::CIterator::CIterator(const CPtrBagVTableAggregate * pAggregateTable)
{
    _pAggregateTable = pAggregateTable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Start
//
//----------------------------------------------------------------------------
void
CPtrBagVTableAggregate::CIterator::Start(VTABLEDESC_OWNERENUM owner, const CPtrBagVTableAggregate * pAggregateTable)
{
    if (pAggregateTable)
        _pAggregateTable = pAggregateTable;

    Assert (_pAggregateTable);

    _owner = owner;
    _idx = 0;
    _vTableIterator.Start(owner, _pAggregateTable->_VTables[_idx]);
    // If we achieved the end of the aggregate, move onto the next one
    // and keep doing so until you get to one that has members
    while(_vTableIterator.End())
    {
        _idx++;
        if(_pAggregateTable->_VTables[_idx])
            _vTableIterator.Start(_owner, _pAggregateTable->_VTables[_idx]);
        else
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Next
//
//----------------------------------------------------------------------------
void
CPtrBagVTableAggregate::CIterator::Next()
{
    Assert(_pAggregateTable);

    if(!End())
    {
        // Aggregate down to members
        _vTableIterator.Next();

        // If we achieved the end of the aggregate, move onto the next one
        // and keep doing so until you get to one that has members
        while(_vTableIterator.End())
        {
            _idx++;
            if(_pAggregateTable->_VTables[_idx])
                _vTableIterator.Start(_owner, _pAggregateTable->_VTables[_idx]);
            else
                break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::End
//
//----------------------------------------------------------------------------
BOOL
CPtrBagVTableAggregate::CIterator::End() const
{
    Assert (_pAggregateTable);

    return _pAggregateTable->_VTables[_idx] == NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::CIterator::Item
//
//----------------------------------------------------------------------------
const VTABLEDESC *
CPtrBagVTableAggregate::CIterator::Item() const
{
    Assert (_pAggregateTable);

    return End() ? NULL : _vTableIterator.Item();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetCi
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *CPtrBagVTableAggregate::GetCi(const TCHAR *pch,
                                                DWORD hash,
                                                VTABLEDESC_OWNERENUM owner) const
{
    const VTABLEDESC *retVal = NULL;

    // We know that we do not have any String Tables left if we get to a NULL
    // We also know that we have at least one string table, the one for
    // the current class
    for(int lcv = 0; !retVal && _VTables[lcv]; lcv++)
    {
        retVal = _VTables[lcv]->GetCi(pch, hash, owner);
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetCs
//
//  Synopsis:   Returns the VTABLEDESC* associated with the given string, or
//              NULL if none.
//
//----------------------------------------------------------------------------
const VTABLEDESC *CPtrBagVTableAggregate::GetCs(const TCHAR *pch,
                                                DWORD hash,
                                                VTABLEDESC_OWNERENUM owner) const
{
    const VTABLEDESC *retVal = NULL;

    // We know that we do not have any String Tables left if we get to a NULL
    // We also know that we have at least one string table, the one for
    // the current class
    for(int lcv = 0; !retVal && _VTables[lcv]; lcv++)
    {
        retVal = _VTables[lcv]->GetCs(pch, hash, owner);
    }
    return retVal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPtrBagVTableAggregate::GetNumParserProps
//
//  Synopsis:   Gets the total number of ParserProperties in the aggregate
//              hash table
//
//----------------------------------------------------------------------------
DWORD CPtrBagVTableAggregate::GetNumParserProps() const
{
    DWORD nParserProps = 0;

    for(DWORD lcv = 0; _VTables[lcv]; lcv++)
    {
        nParserProps += _VTables[lcv]->_nParserProps;
    }
    return nParserProps;
}

#endif // !defined(ASCPARSE)
#else  // !defined(PDLPARSE)
// ASCPARSE includes this file, so specificially select this code for the PDLPARSE
#if defined(PDLPARSE)
//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::GetIndex
//
//  Synopsis:   Returns the hash table index that corresponds to the string
//
//----------------------------------------------------------------------------
BOOL
CVTableHash::GetIndex(const TCHAR *pch, DWORD cch, DWORD hash, DWORD *pIndex)
{
    Assert(pIndex)

    DWORD    s;
    const CAssoc *passoc;

    *pIndex = hash % _mHash;
    passoc = _pHashTable[*pIndex];

    if (!passoc)
        return FALSE;

    if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
        return TRUE;

    s = (hash & _sHash) + 1;

    for (;;)
    {
        if (*pIndex < s)
            *pIndex += _mHash;

        *pIndex -= s;

        passoc = _pHashTable[*pIndex];

        if (!passoc)
            return FALSE;

        if (passoc->Hash() == hash && _tcsnzequal(pch, cch, passoc->String()))
            return TRUE;
    }
}

BOOL VTblIndexBelongsToParse(DWORD uVTblIndex)
{
    return uVTblIndex & PDLPARSE_BELONGSTOPARSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::ComputeOMParseWalker
//
//  Synopsis:   Computes the walker for the Hash Table.  We use the walker
//              when we are iterating over the hash table entries.
//
//----------------------------------------------------------------------------
void
CVTableHash::ComputeOMParseWalker()
{
    DWORD uPrevOMWalker = 0x7FF;
    DWORD uPrevParserWalker = 0x7FF;

    for(DWORD lcv = 0; lcv < _mHash; lcv++)
    {
        const CAssoc *pAssoc = _pHashTable[lcv];
        if(pAssoc)
        {
            PropdescInfo *pPropDesc = (PropdescInfo *)pAssoc->Number();
            if(pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOPARSE)
            {
                if(uPrevParserWalker != 0x7FF)
                {
                    PropdescInfo *pPrevPropDesc =
                            (PropdescInfo *)_pHashTable[uPrevParserWalker]->Number();
                    pPrevPropDesc->_uOMParserWalker |= lcv;
                }
                uPrevParserWalker = lcv;
            }
            if(pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOOM)
            {
                if(uPrevOMWalker != 0x7FF)
                {
                    PropdescInfo *pPrevPropDesc =
                            (PropdescInfo *)_pHashTable[uPrevOMWalker]->Number();
                    pPrevPropDesc->_uOMParserWalker |= lcv << 11;
                }
                uPrevOMWalker = lcv;
            }
        }
    }
    // Set the last one to be "NULL"
    if(uPrevParserWalker != 0x7FF)
    {
        PropdescInfo *pPrevPropDesc =
                (PropdescInfo *)_pHashTable[uPrevParserWalker]->Number();
        pPrevPropDesc->_uOMParserWalker |= 0x7FF;
    }
    if(uPrevOMWalker != 0x7FF)
    {
        PropdescInfo *pPrevPropDesc =
                (PropdescInfo *)_pHashTable[uPrevOMWalker]->Number();
        pPrevPropDesc->_uOMParserWalker |= 0x7FF << 11;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVTableHash::ToFile
//
//  Synopsis:   Spits out the hash table
//
//----------------------------------------------------------------------------
HRESULT
CVTableHash::ToFile(FILE *file, LPTSTR className, int nParserEntries)
{
    DWORD lcvHashTable;
    DWORD uOMWalker = 0x7FF;
    DWORD uParserWalker = 0x7FF;

    if(_mHash > 1024)
        return E_FAIL;

    ComputeOMParseWalker();

	// Write out the entries in the hash table, skipping over the empty ones
	for(lcvHashTable = 0; lcvHashTable < _mHash; lcvHashTable++)
    {
        const CAssoc *pAssoc = _pHashTable[lcvHashTable];
        if(pAssoc)
        {
            PropdescInfo *pPropDesc = (PropdescInfo *)pAssoc->Number();
            DWORD uVTblIndex = pPropDesc->_uVTblIndex;

            // If the PropDesc belongs to the Parser, store the index
            if(VTblIndexBelongsToParse(uVTblIndex))
            {
                uVTblIndex |= nParserEntries << 19;
                nParserEntries++;
            }

            // Write out the hash table entry
            fprintf(file, "static const CAssocVTable s_AssocVTable%ls%d = { {(PROPERTYDESC *)&s_%sdesc%s%s, 0x%x, 0x%x}, 0x%x};\n",
    		        className, lcvHashTable,
                    pPropDesc->_fProperty ? "prop" : "meth",
                    pPropDesc->_szClass,
                    pPropDesc->_szPropName,
                    pPropDesc->_uOMParserWalker,
                    uVTblIndex,
                    pAssoc->Hash());
        }
    }

    // Next, we declare the Hash Table
    fprintf(file, "const CAssocVTable * const %ls::s_AssocVTablePtr [ ] = {\n", className);

    // Duplicate the Hash Table
    for(lcvHashTable = 0; lcvHashTable < _mHash; lcvHashTable++)
    {
        if(lcvHashTable > 0)
        {
            fprintf(file, ",\n");
        }
        if(!_pHashTable[lcvHashTable])
        {
            fprintf(file, "        NULL");
        }
        else
        {
            PropdescInfo *pPropDesc =
                    (PropdescInfo *)_pHashTable[lcvHashTable]->Number();

            fprintf(file, "        &s_AssocVTable%ls%d",
					className, lcvHashTable);

            // Set the start of the walker
            if((uOMWalker == 0x7FF) &&
                (pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOOM))
            {
                uOMWalker = lcvHashTable;
            }
            if((uParserWalker == 0x7FF) &&
                (pPropDesc->_uVTblIndex & PDLPARSE_BELONGSTOPARSE))
            {
                uParserWalker = lcvHashTable;
            }
        }
    }
    fprintf(file, "\n    };\n");

    // Write out the rest of the member variables
    fprintf(file, "const CAssocArrayVTable %ls::s_StringTable = {\n"
                  "    s_AssocVTablePtr,\n"
                  "    %d, // _cHash\n"
                  "    %d, // _mHash\n"
                  "    %d, // _sHash\n"
                  "    %d, // _maxHash\n"
                  "    %d, // _iSize\n"
                  "    %d, // _nParserProps\n"
                  "    0x%x, // _uOMWalker\n"
                  "    0x%x, // _uParserWalker\n"
                  "    TRUE // _fStatic\n"
                  "}; // End of StringTable\n",
                  className, _cHash, _mHash, _sHash, _maxHash, _iSize, nParserEntries,
                  uOMWalker, uParserWalker);

    return S_OK;
}
#endif  // defined(PDLPARSE)
#endif  // !defined(PDLPARSE)

//+---------------------------------------------------------------------------
//
//  DEBUG ONLY helper: TestStringTable
//
//----------------------------------------------------------------------------

#if DBG == 1
void TestStringTable()
{
    {
        int             c;
        LPVOID          pv;
        CStringTable    st;

        CStringTable::CIterator itr;

        st.Add(_T("foo"),     (LPVOID)1);
        st.Add(_T("foo2"),    (LPVOID)2);
        st.Add(_T("foo3"), 3, (LPVOID)3);
        st.Add(_T("bar"),     (LPVOID)4);
        st.Add(_T("zoo"),     (LPVOID)5);

        Assert (S_OK   == st.Find(_T("foo"),  &pv));
        Assert ((LPVOID)3 == pv);                       // (foo3,3) overrode foo
        Assert (S_OK   == st.Find(_T("foo2"), &pv));
        Assert ((LPVOID)2 == pv);
        Assert (S_OK   == st.Find(_T("bar"),  &pv));
        Assert ((LPVOID)4 == pv);
        Assert (S_OK   == st.Find(_T("zoo"),  &pv));
        Assert ((LPVOID)5 == pv);
        Assert (E_FAIL == st.Find(_T("baz"),  NULL));
        Assert (E_FAIL == st.Find(_T("fo"),   NULL));
        Assert (E_FAIL == st.Find(_T("foo3"), NULL));   // (foo3, 3) should have been added as foo

        c = 0;
        for (itr.Start(&st); !itr.End(); itr.Next())
        {
            c++;
        }
        Assert (4 == c);
    }
    {
        int             c;
        LPVOID          pv;
        CStringTable    st(CStringTable::CASEINSENSITIVE);

        CStringTable::CIterator itr;

        st.Add(_T("foo"),     (LPVOID)1);
        st.Add(_T("foo2"),    (LPVOID)2);
        st.Add(_T("foo3"), 3, (LPVOID)3);
        st.Add(_T("bar"),     (LPVOID)4);
        st.Add(_T("zoo"),     (LPVOID)5);
        st.Add(_T("Zoo"),     (LPVOID)6);

        Assert (S_OK == st.Find(_T("foo"),  &pv));
        Assert ((LPVOID)3 == pv);                       // (foo3,3) overrode foo
        Assert (S_OK == st.Find(_T("foo2"), &pv));
        Assert ((LPVOID)2 == pv);
        Assert (S_OK == st.Find(_T("bar"),  &pv));
        Assert ((LPVOID)4 == pv);
        Assert (S_OK == st.Find(_T("zoo"),  &pv));
        Assert ((LPVOID)6 == pv);
        Assert (S_OK == st.Find(_T("zOO"),  &pv));
        Assert ((LPVOID)6 == pv);                       // should be same as zoo
        Assert (E_FAIL == st.Find(_T("baz"),  NULL));
        Assert (E_FAIL == st.Find(_T("fo"),   NULL));
        Assert (E_FAIL == st.Find(_T("foo3"), NULL));   // (foo3, 3) should have made it as foo

        c = 0;
        for (itr.Start(&st); !itr.End(); itr.Next())
        {
            c++;
        }
        Assert (4 == c);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\buffer.cxx ===
//      Buffer.cpp
//              Copyright 1996 Microsoft Corporation.  All rights reserved.
//
//              This file implements a class that provides a dynamically growing buffer.
//
//      1/5/96 created - Chris Wilson (cwilso@microsoft.com)
//      1/8/97 revised for Trident & converted to Unicode - cwilso

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BUFFER_HXX_
#define X_BUFFER_HXX_
#include "buffer.hxx"
#endif

MtDefine(CBuffer, Utilities, "CBuffer")
MtDefine(CBuffer2, Utilities, "CBuffer2")

#define INIT_BUFFER_COUNT     256   // # of characters for which space is initially alloc'd

//---------------------------------------------------------------------
//      CBuffer::CBuffer()
//              This function initializes the internal buffer to a default length
//  of 1024 characters.
//---------------------------------------------------------------------
CBuffer::CBuffer() :
    m_pszStringBuf(NULL), m_pszCurrChar(NULL), m_lBufSize(INIT_BUFFER_COUNT),
    m_lStringLen(0)
{
        // Allocate buffer space.
        m_pszStringBuf = m_pszCurrChar = (LPTSTR) MemAlloc(Mt(CBuffer),
            sizeof(TCHAR) * m_lBufSize);
        if ( m_pszStringBuf )
            *m_pszStringBuf = _T('\0');
}

//---------------------------------------------------------------------
//      CBuffer::~CBuffer()
//              The destructor for the CBuffer object frees the string buffer
//      (if initialized) and resets all internal member variables, just to
//      be safe.
//---------------------------------------------------------------------
CBuffer::~CBuffer()
{
        if ( m_pszStringBuf )
        {
                MemFree(m_pszStringBuf);
                m_pszStringBuf = m_pszCurrChar = NULL;
                m_lBufSize = m_lStringLen = 0;
        }
}


//---------------------------------------------------------------------
//      CBuffer::GrowBuffer()
//              This method grows the buffer by the specified amount +
//      INIT_BUFFER_COUNT.
//
//---------------------------------------------------------------------
BOOL CBuffer::GrowBuffer( const int iSize /*=1*/ )
{
        long lNewBufSize = m_lBufSize + iSize + INIT_BUFFER_COUNT;
        HRESULT hr = MemRealloc(Mt(CBuffer), (void **)&m_pszStringBuf, lNewBufSize * sizeof(TCHAR));
        if (hr)
            return FALSE;   // ERROR reallocating!  Maybe return hr?

        m_lBufSize = lNewBufSize;
        m_pszCurrChar = m_pszStringBuf + m_lStringLen;
        return TRUE;
}

//---------------------------------------------------------------------
//      CBuffer::TrimTrailingWhitespace()
//              This function trims any whitespace at the end of the string in 
//      the internal buffer, properly keeping track of the string length.
//---------------------------------------------------------------------
void CBuffer::TrimTrailingWhitespace( void )
{
        while ( --m_pszCurrChar > m_pszStringBuf )
        {
                m_lStringLen--;
                if ( !isspace( *m_pszCurrChar ) )
                {
                        m_pszCurrChar++;
                        m_lStringLen++;
                        return;
                }
                *m_pszCurrChar = _T('\0');
        }
}

//---------------------------------------------------------------------
//      CBuffer::SwapContents()
//              This method swaps the contents of two CBuffers.
//---------------------------------------------------------------------
void CBuffer::SwapContents( CBuffer & cBufOther )
{
    LPTSTR pszTemp;
    long lTemp;

    pszTemp = m_pszStringBuf;
    m_pszStringBuf = cBufOther.m_pszStringBuf;
    cBufOther.m_pszStringBuf = pszTemp;

    pszTemp = m_pszCurrChar;
    m_pszCurrChar = cBufOther.m_pszCurrChar;
    cBufOther.m_pszCurrChar = pszTemp;

    lTemp = m_lStringLen;
    m_lStringLen = cBufOther.m_lStringLen;
    cBufOther.m_lStringLen = lTemp;

    lTemp = m_lBufSize;
    m_lBufSize = cBufOther.m_lBufSize;
    cBufOther.m_lBufSize = lTemp;
}


//+------------------------------------------------------------------------
//
//  Class:      CBuffer2
//
//  Synopsis:   A sequence of exponentially growing buffers, used for
//              reducing MemAllocs (logarithmic) and eliminating
//              MemReallocs (complete) when accumulating long strings.
// 
//              A new CBuffer2 contains room for the first 1024 chars
//              without an extra allocation.
//
//-------------------------------------------------------------------------
CBuffer2::CBuffer2()
{
    _pchCur = NULL;
    _cchRemaining = 0;
    _cBuf = 0;
}

void
CBuffer2::Clear()
{
    int c;
    TCHAR **ppch;

    for (c = _cBuf, ppch = _apchBuf; c; c -= 1, ppch += 1)
        MemFree(*ppch);
        
    _pchCur = NULL;
    _cchRemaining = 0;
    _cBuf = 0;
}
       
CBuffer2::~CBuffer2()
{
    int c;
    TCHAR **ppch;

    for (c = _cBuf, ppch = _apchBuf; c; c -= 1, ppch += 1)
        MemFree(*ppch);
}


//+------------------------------------------------------------------------
//
//  Method:     Length
//
//  Synopsis:   return init * (2^buffers - 1) - slop
// 
//-------------------------------------------------------------------------
int
CBuffer2::Length()
{
    return (INIT_BUFFER2_SIZE * ((1 << _cBuf) - 1)) - _cchRemaining;
}

//+------------------------------------------------------------------------
//
//  Method:     SetCStr
//
//  Synopsis:   Do a single alloc on the cstr, then copy contents in
//              one buffer at a time.
// 
//-------------------------------------------------------------------------
HRESULT
CBuffer2::SetCStr(CStr *pcstr)
{
    HRESULT hr;
    int cch;
    int cBufFull;
    int cchCur;
    TCHAR **ppchCur;
    TCHAR *pchTo;

    cch = Length();
    
    hr = THR(pcstr->Set(NULL, Length()));
    if (hr)
        RRETURN(hr);

    if (!cch)
        return S_OK;

    Assert(_cBuf);
    
    pchTo = *pcstr;
    cBufFull = _cBuf - 1;
    cchCur = INIT_BUFFER2_SIZE;
    ppchCur = _apchBuf;

    while (cBufFull)
    {
        memcpy(pchTo, *ppchCur, sizeof(TCHAR) * cchCur);
        
        pchTo += cchCur;
        cchCur *= 2;
        ppchCur += 1;
        cBufFull -= 1;
    }

    cchCur -= _cchRemaining;
    
    memcpy(pchTo, *ppchCur, sizeof(TCHAR) * cchCur);
    
#if DBG == 1
    pchTo += cchCur;

    Assert(pchTo - *pcstr == Length());
#endif    

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Method:     Append
//
//  Synopsis:   Append new stuff to the sequence of buffers, allocating
//              exponentially larger new buffers as needed.
// 
//-------------------------------------------------------------------------
HRESULT
CBuffer2::Append(TCHAR *pch, int cch)
{
    int cchToCopy;
    
    while (cch)
    {
        if (!_cchRemaining)
        {
            int cchAlloc;
            
            // Note: because of exponential growth, we'll really run out of
            // memory long before we hit this condition.
            
            if (_cBuf >= MAX_BUFFER2_GROWTH)
                return E_OUTOFMEMORY;

            cchAlloc = INIT_BUFFER2_SIZE * (1 << _cBuf);
            
            _pchCur = (TCHAR *)MemAlloc(Mt(CBuffer2), sizeof(TCHAR) * cchAlloc);
            if (!_pchCur)
                return E_OUTOFMEMORY;

            _cBuf += 1;
            _apchBuf[_cBuf - 1] = _pchCur;
            _cchRemaining = cchAlloc;
        }

        Assert(_cchRemaining && _pchCur);

        cchToCopy = min(_cchRemaining, cch);

        memcpy(_pchCur, pch, sizeof(TCHAR) * cchToCopy);

        cch -= cchToCopy;
        pch += cchToCopy;
        _cchRemaining -= cchToCopy;
        _pchCur += cchToCopy;
    }

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Method:     Chop
//
//  Synopsis:   Removes the last cch chars from the buffer
// 
//-------------------------------------------------------------------------
void
CBuffer2::Chop(int cch)
{
    int cchBuffer;

    Assert(cch <= Length());

    if (!cch)
        return;

    Assert(_cBuf);
    
    cchBuffer = INIT_BUFFER2_SIZE * (1 << (_cBuf - 1));

    while (cch >= cchBuffer - _cchRemaining)
    {
        Assert(_cBuf > 0);
        
        cch -= cchBuffer - _cchRemaining;
        
        MemFree(_apchBuf[_cBuf - 1]);
        _cBuf -= 1;
        _cchRemaining = 0;
        cchBuffer /= 2;
    }

    _cchRemaining += cch;
    _pchCur = _cBuf ? _apchBuf[_cBuf - 1] + cchBuffer - _cchRemaining : NULL;

    Assert(_cBuf || _cchRemaining == 0);
}

//+------------------------------------------------------------------------
//
//  Method:     Chop
//
//  Synopsis:   Removes the last cch chars from the buffer
// 
//-------------------------------------------------------------------------
void
CBuffer2::TransferTo(CBuffer2 *pbuf)
{
    // copy over pointers
    if (pbuf != this)
    {
        memcpy(pbuf, this, sizeof(CBuffer2));
        memset(this, 0, sizeof(CBuffer2));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\brushbmp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       brushbmp.cxx
//
//  Contents:   Bitmap brush utilities.
//
//  History:    6-Nov-95   RodC     Created
//
//-------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)


struct BBCR
{
    int         resId;
    HBRUSH      hbr;
};

MtDefine(CAryBBCR, THREADSTATE, "CAryBBCR")
MtDefine(CAryBBCR_pv, THREADSTATE, "CAryBBCR::_pv")

// We have to do this because of the forward declare in thread state.
DECLARE_CDataAry(CAryBBCR, BBCR, Mt(CAryBBCR), Mt(CAryBBCR_pv))

//+----------------------------------------------------------------------------
//
//  Function:   InitBmpBrushCache
//
//  Synopsis:   Allocate bitmap brushes cache array
//
//  Arguments:  pts - THREADSTATE of current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitBmpBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->paryBBCR = new CAryBBCR;
    if (!pts->paryBBCR)
        RRETURN(E_OUTOFMEMORY);

    MemSetName((pts->paryBBCR, "BmpBrushCache ary"));

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitBmpBrushCache
//
//  Synopsis:   Releases any bitmap brushes still stored in the cache.
//
//----------------------------------------------------------------------------
void
DeinitBmpBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    if (!pts->paryBBCR)
        return;

    int     c = (*pts->paryBBCR).Size();

    // Loop over all the brushes in the cache and delete them.
    while (c--)
    {
        Assert((*pts->paryBBCR)[c].hbr);
        DeleteObject((*pts->paryBBCR)[c].hbr);
    }

    (*pts->paryBBCR).DeleteAll();

    delete pts->paryBBCR;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCachedBmpBrush
//
//  Synopsis:   Returns a brush handle for the bitmap matching the resource
//              id. A process-wide cache of brushes is maintained.  If this
//              function is called and a matching brush is found in the
//              cache, it is returned.  If no match is found, a new one is
//              added.
//
//              No release is needed.  There are few enough bitmap brushes
//              that they will all be around until the detach.
//
//----------------------------------------------------------------------------

HBRUSH
GetCachedBmpBrush(int resId)
{
    THREADSTATE *   pts;
    HBITMAP         hbmp = NULL;
    HBRUSH          hbr = NULL;
    BBCR *          pbbcr;
    int             c;

    pts = GetThreadState();

    //
    // Look for previously cached bitmap brush.
    //
    for (c = (*pts->paryBBCR).Size(), pbbcr = (*pts->paryBBCR); c > 0; c--, pbbcr++)
    {
        Assert(pbbcr->hbr && pbbcr->resId);

        // Return brush if found.
        if (pbbcr->resId == resId)
        {
            hbr = pbbcr->hbr;
            goto Cleanup;
        }
    }

    //
    // If we didn't find the brush, we need to cook one up.
    //

    // Make sure we will have room for the brush.
    if ((*pts->paryBBCR).EnsureSize((*pts->paryBBCR).Size() + 1))
        goto Cleanup;

    // Load the bitmap resouce.
    hbmp = LoadBitmap(g_hInstCore, MAKEINTRESOURCE(resId)); // NOTE (lmollico): bitmaps are in mshtml.dll
    if (!hbmp)
        goto Cleanup;

    // Turn the bitmap into a brush.
    hbr = CreatePatternBrush(hbmp);
    if (!hbr)
        goto Cleanup;

    // Store the brush.
    (*pts->paryBBCR)[(*pts->paryBBCR).Size()].resId = resId;
    (*pts->paryBBCR)[(*pts->paryBBCR).Size()].hbr = hbr;
    (*pts->paryBBCR).SetSize((*pts->paryBBCR).Size() + 1);

Cleanup:
    if (hbmp)
        DeleteObject(hbmp);

    return hbr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\brush.cxx ===
//+------------------------------------------------------------------------
//
//  File:       brush.cxx
//
//  Contents:   Brush utilities.
//
//  History:    20-Oct-94   GaryBu  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

PerfDbgTag(tagBrushCache,        "BrushCache", "Trace BrushCache")
PerfDbgTag(tagDisableBrushCache, "BrushCache", "Disable Brush Cache")

MtDefine(THREADSTATE_pbcr, THREADSTATE, "THREADSTATE::_pbcr")

#define CBCR_MAX            16

struct BCR
{
    COLORREF    cr;
    int         refs;
    HBRUSH      hbr;
};


//+----------------------------------------------------------------------------
//
//  Function:   InitBrushCache
//
//  Synopsis:   Allocate brush cache array
//
//  Arguments:  pts - THREADSTATE of current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitBrushCache(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->pbcr = new(Mt(THREADSTATE_pbcr)) BCR[CBCR_MAX];
    if (!pts->pbcr)
        RRETURN(E_OUTOFMEMORY);

    MemSetName((pts->pbcr, "Brush Cache Data"));

    memset(pts->pbcr, 0, sizeof(BCR) * CBCR_MAX);

    pts->ibcrNext = -1;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitBrushCache
//
//  Synopsis:   Releases any brushes still stored in the cache
//
//----------------------------------------------------------------------------
void
DeinitBrushCache(
    THREADSTATE *   pts)
{
    int     c;
    BCR *   pbcr;

    Assert(pts);

    if (!pts->pbcr)
        return;

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        Assert(pbcr->refs == 0 && "Unreleased brush in cache at Deinit");
        if (pbcr->hbr)
            DeleteObject(pbcr->hbr);
    }

    delete [] pts->pbcr;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCachedBrush
//
//  Synopsis:   Returns a brush handle matching the given OLE Color.
//              A process-wide cache of brushes is maintained.  If this
//              function is called and a matching brush is found in the
//              cache, it is returned.  If no match is found, one of
//              the cached brushes is kicked out and a new one is
//              added.
//
//              ReleaseCachedBrush should be called to release the
//              brush handle when it is no longer needed.
//
//  Arguments:  clr   OLE Color of the brush
//
//  Returns:    Brush handle.
//
//  Notes:      THE ARGUMENT IS A *COLORREF*!! (Don't pass in an OLE_COLOR)
//
//----------------------------------------------------------------------------

HBRUSH
GetCachedBrush(COLORREF cr)
{
    THREADSTATE *   pts;
    int             c;
    BCR *           pbcr;
    HBRUSH          hbr;

#if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagDisableBrushCache))
        return(CreateSolidBrush(cr));
#endif

    Assert((cr & 0x80000000) == 0);

    pts = GetThreadState();

    // Look for previously cached brush.

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        Assert(pbcr->hbr != NULL || pbcr->cr == 0);

        //  The brush cache initially starts out filled with zeros,
        //    but cr == 0 is a valid color, so we need to check for
        //    both the color matching AND having a valid brush.

        if (pbcr->cr == cr && pbcr->hbr != NULL)
        {
            pbcr->refs++;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: found %x @ %d (%d)\r",
                    cr, pbcr - pts->pbcr, pbcr->refs);

            return pbcr->hbr;
        }
    }

    // Otherwise, create a new brush and add it to the cache.

    hbr = CreateSolidBrush(cr);
    if (!hbr)
    {
        TraceTag((tagError,
                "GCB: could not create brush, falling back to stock brush"));

        // QUESTION: Do we need to be careful sharing stock objects between threads?
        hbr = (HBRUSH)GetStockObject(BLACK_BRUSH);
    }

    // Handle case where the system returns the same
    // brush handle for different color values.

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        if (pbcr->hbr == hbr)
        {
            pbcr->refs++;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: found dup of %x @ %d (%d)\r",
                    cr, pbcr - pts->pbcr, pbcr->refs);

            return hbr;
        }
    }

    pbcr = pts->pbcr + pts->ibcrNext;
    for (c = CBCR_MAX; c > 0; c--)
    {
        pbcr++;
        pts->ibcrNext++;
        if (pts->ibcrNext >= CBCR_MAX)
        {
            pts->ibcrNext = 0;
            pbcr = pts->pbcr;
        }

        Assert(0 <= pts->ibcrNext && pts->ibcrNext < CBCR_MAX);

        if (pbcr->refs == 0)
        {
            if (pbcr->hbr)
                DeleteObject(pbcr->hbr);

            pbcr->hbr = hbr;
            pbcr->cr = cr;
            pbcr->refs = 1;

            PerfDbgLog2(tagBrushCache, NULL, "GCB: new %x @ %d (1)\r", cr, pts->ibcrNext);

            return hbr;
        }

    }

    TraceTag((tagWarning, "GCB: cache full"));

    return hbr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseCachedBrush
//
//  Synopsis:   Releases a brush handle returned by GetCachedBrush.
//
//  Arguments:  hbr  Brush handle to release
//
//----------------------------------------------------------------------------

void
ReleaseCachedBrush(HBRUSH hbr)
{
    THREADSTATE *   pts;
    int             c;
    BCR *           pbcr;

    if (!hbr)
        return;

    pts = GetThreadState();

    for (c = CBCR_MAX, pbcr = pts->pbcr; c > 0; c--, pbcr++)
    {
        if (pbcr->hbr == hbr)
        {
            Assert(pbcr->refs > 0);
            pbcr->refs--;

            PerfDbgLog3(tagBrushCache, NULL, "GCB: released %x @ %d (%d)\r",
                pbcr->cr, pbcr - pts->pbcr, pbcr->refs);

            return;
        }
    }

    TraceTag((tagWarning, "RCB: Brush not found in cache, deleting anyway."));

    DeleteObject((HGDIOBJ)hbr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SelectCachedBrush
//
//  Synopsis:   Helper function to optimally select a cached brush into a DC
//
//  Arguments:  hdc         Device context
//              crNew       color of the brush
//              phbrNew     new brush
//              phbrOld     original brush from the hdc (init to NULL)
//              pcrNow      current cached brush color in the hdc (init to COLORREF_NONE)
//
//----------------------------------------------------------------------------

void SelectCachedBrush(XHDC hdc, COLORREF crNew, HBRUSH * phbrNew, HBRUSH * phbrOld, COLORREF * pcrNow)
{
    HBRUSH hbrNew, hbrOld;

    *phbrNew = *phbrOld;
    
    if (*pcrNow != crNew)
    {
        *phbrNew = hbrNew = GetCachedBrush(crNew);

        if (hbrNew)
        {
            hbrOld = (HBRUSH)SelectObject(hdc, hbrNew);

            if (hbrOld)
            {
                if (*phbrOld == NULL)
                    *phbrOld = hbrOld;
                else
                    ReleaseCachedBrush(hbrOld);

                *pcrNow = crNew;
            }
            else
            {
                ReleaseCachedBrush(hbrNew);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PatBltBrush
//
//  Synopsis:   Helper function for calling PatBlt with a given COLORREF
//
//  Arguments:  hdc         Device context
//              x,y         Point where painting starts
//              xWid,yHei   Size of paint rectangle
//              dwRop       Raster op
//              cr          COLORREF of color to use
//
//----------------------------------------------------------------------------

void PatBltBrush(XHDC hdc, LONG x, LONG y, LONG xWid, LONG yHei,
    DWORD dwRop, COLORREF cr)
{
    HBRUSH hbr = GetCachedBrush(cr);
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
    PatBlt(hdc, x, y, xWid, yHei, dwRop);
    SelectObject(hdc, hbrOld);
    ReleaseCachedBrush(hbr);
}

void PatBltBrush(XHDC hdc, RECT * prc, DWORD dwRop, COLORREF cr)
{
    PatBltBrush(hdc, prc->left, prc->top, prc->right - prc->left,
        prc->bottom - prc->top, dwRop, cr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\cbufstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1997, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CBUFSTR.CXX
//
// Contents     Class implementation for a buffered, appendable string class
//
// Classes      CBufferedStr
//
//
//  History:
//              7-10-97     t-chrisr     created
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#define BUFFEREDSTR_SIZE 1024

MtDefine(CBufferedStr, Utilities, "CBufferedStr")
MtDefine(CBufferedStr_pchBuf, CBufferedStr, "CBufferedStr::_pchBuf")

//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::Set
//
//  Synopsis:   Initilizes a CBufferedStr
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::Set (const TCHAR* pch)
{
    HRESULT hr = S_OK;

    Free();

    _cchIndex = pch ? _tcslen (pch) : 0;
    _cchBufSize = _cchIndex > BUFFEREDSTR_SIZE ? _cchIndex : BUFFEREDSTR_SIZE;
    _pchBuf = new(Mt(CBufferedStr_pchBuf)) TCHAR [ _cchBufSize ];
    if (!_pchBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (pch)
    {
        _tcsncpy (_pchBuf, pch, _cchIndex);
    }

    _pchBuf[_cchIndex] = '\0';

    MemSetName((_pchBuf, "CBufferedStr text"));

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CBufferedStr::QuickAppend
//
//  Parameters: pchNewStr   string to be added to _pchBuf
//
//  Synopsis:   Appends pNewStr into _pchBuf starting at
//              _pchBuf[uIndex].  Increments index to reference
//              new end of string.  If _pchBuf is not large enough,
//              reallocs _pchBuf and updates _cchBufSize.
//
//-------------------------------------------------------------------------
HRESULT
CBufferedStr::QuickAppend (const TCHAR* pchNewStr, ULONG newLen)
{
    Assert (pchNewStr);
    HRESULT hr = S_OK;

    if (!_pchBuf)
    {
        hr = Set();
        if (hr)
            goto Cleanup;
    }

    if (_cchIndex + newLen >= _cchBufSize)    // we can't fit the new string in the current buffer
    {                                         // so allocate a new buffer, and copy the old string
        _cchBufSize += (newLen > BUFFEREDSTR_SIZE) ? newLen : BUFFEREDSTR_SIZE;
        TCHAR * pchTemp = new(Mt(CBufferedStr_pchBuf)) TCHAR [ _cchBufSize ];
        if (!pchTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcsncpy (pchTemp, _pchBuf, _cchIndex);

        Free();
        _pchBuf = pchTemp;
    }

    // append the new string
    _tcsncpy (_pchBuf + _cchIndex, pchNewStr, newLen);
    _cchIndex += newLen;
    _pchBuf[_cchIndex] = '\0';

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\color.cxx ===
//+------------------------------------------------------------------------
//
//  File:       color.cxx
//
//  Contents:   FormsTranslateColor
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CColorInfo, Utilities, "CColorInfo")

COLORREF g_acrSysColor[25];
BOOL     g_fSysColorInit = FALSE;
COLORREF g_crPaletteRelative = 0;
HPALETTE g_hpalHalftone = NULL;

#ifndef _MAC 		
// Inverse color table
BYTE * g_pInvCMAP = NULL;
#endif

RGBQUAD g_rgbHalftone[256];

#if !defined(_MAC)
LOGPAL256 g_lpHalftone;
#else
LOGPAL256 g_lpHalftone =
{
    0x0300, 256,
    {
        { 0x00, 0x00, 0x00, 0x00 },
        { 0x80, 0x00, 0x00, 0x00 },
        { 0x00, 0x80, 0x00, 0x00 },
        { 0x80, 0x80, 0x00, 0x00 },
        { 0x00, 0x00, 0x80, 0x00 },
        { 0x80, 0x00, 0x80, 0x00 },
        { 0x00, 0x80, 0x80, 0x00 },
        { 0xC0, 0xC0, 0xC0, 0x00 },
        { 0xC0, 0xDC, 0xC0, PC_NOCOLLAPSE },
        { 0xA6, 0xCA, 0xF0, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x00, PC_NOCOLLAPSE },
        { 0xEF, 0xD6, 0xC6, PC_NOCOLLAPSE },
        { 0xAD, 0xA9, 0x90, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x33, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x66, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0x99, PC_NOCOLLAPSE },
        { 0x00, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x00, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0xCC, PC_NOCOLLAPSE },
        { 0x00, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xFF, 0xFF, 0xCC, PC_NOCOLLAPSE },
        { 0xA5, 0x00, 0x21, PC_NOCOLLAPSE },
        { 0xD6, 0x00, 0x93, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x50, 0x50, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x33, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x66, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x99, 0xFF, PC_NOCOLLAPSE },
        { 0x00, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0xCC, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0x33, 0x00, PC_NOCOLLAPSE },
        { 0x33, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0x66, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0x99, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0xCC, 0xFF, 0xFF, PC_NOCOLLAPSE },
        { 0xFF, 0x7C, 0x80, PC_NOCOLLAPSE },
        { 0x04, 0x04, 0x04, PC_NOCOLLAPSE },
        { 0x08, 0x08, 0x08, PC_NOCOLLAPSE },
        { 0x0C, 0x0C, 0x0C, PC_NOCOLLAPSE },
        { 0x11, 0x11, 0x11, PC_NOCOLLAPSE },
        { 0x16, 0x16, 0x16, PC_NOCOLLAPSE },
        { 0x1C, 0x1C, 0x1C, PC_NOCOLLAPSE },
        { 0x22, 0x22, 0x22, PC_NOCOLLAPSE },
        { 0x29, 0x29, 0x29, PC_NOCOLLAPSE },
        { 0x39, 0x39, 0x39, PC_NOCOLLAPSE },
        { 0x42, 0x42, 0x42, PC_NOCOLLAPSE },
        { 0x4D, 0x4D, 0x4D, PC_NOCOLLAPSE },
        { 0x55, 0x55, 0x55, PC_NOCOLLAPSE },
        { 0x5F, 0x5F, 0x5F, PC_NOCOLLAPSE },
        { 0x77, 0x77, 0x77, PC_NOCOLLAPSE },
        { 0x86, 0x86, 0x86, PC_NOCOLLAPSE },
        { 0x96, 0x96, 0x96, PC_NOCOLLAPSE },
        { 0xB2, 0xB2, 0xB2, PC_NOCOLLAPSE },
        { 0xCB, 0xCB, 0xCB, PC_NOCOLLAPSE },
        { 0xD7, 0xD7, 0xD7, PC_NOCOLLAPSE },
        { 0xDD, 0xDD, 0xDD, PC_NOCOLLAPSE },
        { 0xE3, 0xE3, 0xE3, PC_NOCOLLAPSE },
        { 0xEA, 0xEA, 0xEA, PC_NOCOLLAPSE },
        { 0xF1, 0xF1, 0xF1, PC_NOCOLLAPSE },
        { 0xF8, 0xF8, 0xF8, PC_NOCOLLAPSE },
        { 0xE7, 0xE7, 0xD6, PC_NOCOLLAPSE },
        { 0xCC, 0xEC, 0xFF, PC_NOCOLLAPSE },
        { 0x33, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0x66, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0x99, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0xCC, 0x00, 0x00, PC_NOCOLLAPSE },
        { 0xFF, 0xFB, 0xF0, PC_NOCOLLAPSE },
        { 0xA0, 0xA0, 0xA4, PC_NOCOLLAPSE },
        { 0x80, 0x80, 0x80, 0x00 },
        { 0xFF, 0x00, 0x00, 0x00 },
        { 0x00, 0xFF, 0x00, 0x00 },
        { 0xFF, 0xFF, 0x00, 0x00 },
        { 0x00, 0x00, 0xFF, 0x00 },
        { 0xFF, 0x00, 0xFF, 0x00 },
        { 0x00, 0xFF, 0xFF, 0x00 },
        { 0xFF, 0xFF, 0xFF, 0x00 },
    }
};
#endif

void CopyColorsFromPaletteEntries(RGBQUAD *prgb, const PALETTEENTRY *ppe,
    UINT uCount)
{
    while (uCount--)
    {
        prgb->rgbRed   = ppe->peRed;
        prgb->rgbGreen = ppe->peGreen;
        prgb->rgbBlue  = ppe->peBlue;
        prgb->rgbReserved = 0;

        prgb++;
        ppe++;
    }
}

void CopyPaletteEntriesFromColors(PALETTEENTRY *ppe, const RGBQUAD *prgb,
    UINT uCount)
{
    while (uCount--)
    {
        ppe->peRed   = prgb->rgbRed;
        ppe->peGreen = prgb->rgbGreen;
        ppe->peBlue  = prgb->rgbBlue;
        ppe->peFlags = 0;

        prgb++;
        ppe++;
    }
}

HRESULT
InitPalette()
{
    HDC hdc = GetDC(NULL);
    HRESULT hr = S_OK;

#if !defined(_MAC) 		
    g_hpalHalftone = SHCreateShellPalette(NULL);
    if (g_hpalHalftone)
    {
        g_lpHalftone.wCnt = (WORD)GetPaletteEntries(g_hpalHalftone, 0, 256, g_lpHalftone.ape);
        g_lpHalftone.wVer = 0x0300;
        CopyColorsFromPaletteEntries(g_rgbHalftone, g_lpHalftone.ape, g_lpHalftone.wCnt);
    }
    else
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
#else
    g_hpalHalftone = CreatePalette((LOGPALETTE *)&g_lpHalftone);
    if (g_hpalHalftone == NULL)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }
    CopyColorsFromPaletteEntries(g_rgbHalftone, g_lpHalftone.ape, g_lpHalftone.wCnt);
#endif

#if !defined(_MAC)
        // Get the dithering table
        SHGetInverseCMAP((BYTE *)&g_pInvCMAP, sizeof(BYTE *));
        if (g_pInvCMAP == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
#if DBG==1
        PALETTEENTRY ape[20], * pe = g_lpHalftone.ape;

        GetSystemPaletteEntries(hdc, 0, 10, ape);
        GetSystemPaletteEntries(hdc, 246, 10, ape + 10);

        if (    memcmp(ape, pe, 10 * sizeof(PALETTEENTRY)) != 0
            ||  memcmp(ape + 10, pe + 246, 10 * sizeof(PALETTEENTRY)) != 0)
        {
            TraceTag((tagPerf, "InitPalette: Unexpected system colors detected"));
        }
#endif

#ifndef NO_PERFDBG
        // Make sure we are using an identity palette
// Disable for IDW build
//        Assert(IsIdentityPalette(g_hpalHalftone));
#endif

        // Generate the inverse mapping table

        g_crPaletteRelative = 0x02000000;
    }
    else
        g_crPaletteRelative = 0;

Cleanup:
    ReleaseDC(NULL, hdc);

    RRETURN(hr);
}

void
DeinitPalette()
{
    if (g_hpalHalftone)
    {
        DeleteObject(g_hpalHalftone);
        g_hpalHalftone = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDefaultPalette
//
//  Synopsis:   Returns a generic (halftone) palette, optionally selecting it
//              into the DC.
//
//              Where possible, use CDoc::GetPalette instead.
//
//----------------------------------------------------------------------------

HPALETTE
GetDefaultPalette(HDC hdc)
{
    HPALETTE hpal = NULL;

    if (g_crPaletteRelative)
    {
        hpal = g_hpalHalftone;
        if (hdc)
        {
#if DBG == 1
            Check(SelectPalette(hdc, hpal, TRUE));
#else
            SelectPalette(hdc, hpal, TRUE);
#endif
            RealizePalette(hdc);
        }
    }
    return hpal;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsHalftonePalette
//
//  Synopsis:   Returns TRUE if the passed palette exactly matches the
//              halftone palette.
//
//----------------------------------------------------------------------------

BOOL
IsHalftonePalette(HPALETTE hpal)
{
    int cColors;
    PALETTEENTRY ape[256];
    
    if (!hpal)
        return FALSE;

    if (hpal == g_hpalHalftone)
        return TRUE;

    cColors = GetPaletteEntries(hpal, 0, 0, NULL);

    // Right number of colors?
    if (cColors != ARRAY_SIZE(ape))
        return FALSE;
    
    if (!GetPaletteEntries(hpal, 0, cColors, ape))
        return FALSE;

    return (!memcmp(ape, g_lpHalftone.ape, sizeof(PALETTEENTRY) * ARRAY_SIZE(ape)));
}

//+---------------------------------------------------------------------------
//
//  Function:   InitColorTranslation
//
//  Synopsis:   Initialize system color translation table.
//
//----------------------------------------------------------------------------

void
InitColorTranslation()
{
    for (int i = 0; i < ARRAY_SIZE(g_acrSysColor); i++)
    {
                // WinCE redefines all the GetSysColor defines
#if defined(WINCE) && !defined(WINCE_NT)
        g_acrSysColor[i] = GetSysColor(i | COLOR_INDEX_MASK);
#else
        g_acrSysColor[i] = GetSysColor(i);
#endif
    }

    g_fSysColorInit = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSysColorQuick
//
//  Synopsis:   Looks up system colors from a cache.
//
//----------------------------------------------------------------------------

COLORREF GetSysColorQuick(int i)
{
    if (!g_fSysColorInit)
        InitColorTranslation();

    return g_acrSysColor[i];
}

//+---------------------------------------------------------------------------
//
//  Function:   FormsTranslateColor
//
//  Synopsis:   Map OLE_COLORs to COLORREFs.
//              This API is identical to OleTranslateColor.
//
//----------------------------------------------------------------------------

STDAPI
FormsTranslateColor(OLE_COLOR clr, HPALETTE hpal, COLORREF * pcr)
{
    int syscolor;

    switch (clr & 0xff000000)
    {
    case 0x80000000:

        syscolor = clr & 0x00ffffff;

        if (syscolor >= ARRAY_SIZE(g_acrSysColor))
            RRETURN(E_INVALIDARG);

        clr = GetSysColorQuick(syscolor);

        break;

    case 0x01000000 :
        // check validity of index
        if (hpal)
        {
            PALETTEENTRY pe;
            // try to get palette entry, if it fails we assume index is invalid
            if (!GetPaletteEntries(hpal, (UINT)(clr & 0xffff), 1, &pe))
                RRETURN(E_INVALIDARG);        // CONSIDER : CDK uses CTL_E_OVERFLOW
        }
        break;

#ifdef UNIX
    case 0x04000000 :   // Motif System Color
#endif
    case 0x02000000 :
        break;

    case 0:
        if (hpal != NULL)
        {
            clr |= 0x02000000;
        }
        break;

    default :
        RRETURN(E_INVALIDARG);
    }

    if (pcr)
        *pcr = clr;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOleColorValid
//
//  Synopsis:   Return true if the given OLE_COLOR is valid.
//
//----------------------------------------------------------------------------

BOOL
IsOleColorValid(OLE_COLOR clr)
{
    //
    // QUESTION -- Why aren't we calling OleTranslateColor?
    //
    return OK(FormsTranslateColor(clr, NULL, NULL));
}


//+---------------------------------------------------------------------------
//
//  Function:   ColorRefFromOleColor
//
//  Synopsis:   Map OLE_COLORs to COLORREFs.  This function does not contain
//              any error checking.   Callers should validate the color with
//              IsOleColorValid() before calling this function.
//
//----------------------------------------------------------------------------

COLORREF
ColorRefFromOleColor(OLE_COLOR clr)
{
// Under WinCE all the colors come in as invalid--starting with 0xC... instead of 0x8
#if defined(WINCE) && !defined(WINCE_NT)
        clr &= 0x80ffffff;
#endif // WINCE
    Assert(IsOleColorValid(clr));
    Assert((clr & 0x02000000) == 0);

    if ((long)clr < 0)
    {
        return GetSysColorQuick(clr & 0xff);
    }
    else
    {
#ifdef UNIX
        if ( CColorValue(clr).IsMotifColor() ) // Motif System Color
            return clr;
#endif

        return clr | g_crPaletteRelative;
    }
}

HDC GetMemoryDC()
{
    HDC hdcMem;

    hdcMem = CreateCompatibleDC(NULL);

    if (hdcMem)
    {
        SetStretchBltMode(hdcMem, COLORONCOLOR);
        GetDefaultPalette(hdcMem);
    }

    return(hdcMem);
}

CColorInfo::CColorInfo() : _dwDrawAspect(DVASPECT_CONTENT) , _lindex(-1), _pvAspect(NULL), _ptd(NULL), _hicTargetDev(NULL), _cColors(0) , _cColorsMax(256)
{
}

CColorInfo::CColorInfo(DWORD dwDrawAspect, LONG lindex, void FAR *pvAspect, DVTARGETDEVICE FAR *ptd, HDC hicTargetDev, unsigned cColorsMax) :
    _dwDrawAspect(dwDrawAspect), _lindex(lindex) , _pvAspect(pvAspect) , _ptd(ptd) , _hicTargetDev(hicTargetDev) , _cColors(0)
{
    _cColorsMax = max((unsigned)256, cColorsMax);
}

HRESULT
CColorInfo::AddColors(HPALETTE hpal)
{
    unsigned cColors = GetPaletteEntries(hpal, 0, 0, NULL);
    cColors = min(_cColorsMax - _cColors, cColors);

    if (cColors)
    {
        GetPaletteEntries(hpal, 0, cColors, &_aColors[_cColors]);
        _cColors += cColors;
    }
    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(LOGPALETTE *pLogPal)
{
    RRETURN(AddColors(pLogPal->palNumEntries, pLogPal->palPalEntry));
}

HRESULT
CColorInfo::AddColors(unsigned cColors, PALETTEENTRY *pColors)
{
    // The check for system colors assumes they occur in the same order as
    // the real system colors.  This is the simplest possible fix for now.

    // Remove any system colors at the end (do this first so that cColors makes sense)

    Assert(g_lpHalftone.wCnt == 256);
    Assert(sizeof(PALETTEENTRY) == sizeof(DWORD));

    DWORD *pSystem = (DWORD *)&g_lpHalftone.ape[g_lpHalftone.wCnt - 1];
    DWORD *pInput = (DWORD *)&pColors[cColors - 1];
    while (cColors && (*pSystem == *pInput))
    {
        pSystem--;
        pInput--;
        cColors--;
    }

    // Remove any system colors at the beginning
    pSystem = (DWORD *)(g_lpHalftone.ape);
    pInput = (DWORD *)pColors;
    while (cColors && (*pSystem == *pInput))
    {
        pSystem++;
        pInput++;
        cColors--;
    }
    pColors = (PALETTEENTRY *)pInput;

    cColors = min(_cColorsMax - _cColors, cColors);
    if (cColors)
    {
        memcpy(&_aColors[_cColors], pColors, cColors * sizeof(PALETTEENTRY));
        _cColors += cColors;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(unsigned cColors, RGBQUAD *pColors)
{
    cColors = min(_cColorsMax - _cColors, cColors);
    if (cColors)
    {
        CopyPaletteEntriesFromColors(&_aColors[_cColors], pColors, cColors);
        _cColors += cColors;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(unsigned cColors, COLORREF *pColors)
{
    cColors = min(_cColorsMax - _cColors, cColors);
    while (cColors)
    {
        _aColors[_cColors].peRed = GetRValue(*pColors);
        _aColors[_cColors].peGreen = GetGValue(*pColors);
        _aColors[_cColors].peBlue = GetBValue(*pColors);
        _aColors[_cColors].peFlags = 0;
        pColors++;
    }

    RRETURN(S_OK);
}

HRESULT
CColorInfo::AddColors(IViewObject *pVO)
{
    LPLOGPALETTE pColors = NULL;
    HRESULT hr = pVO->GetColorSet(_dwDrawAspect, _lindex, _pvAspect, _ptd, _hicTargetDev, &pColors);
    if (FAILED(hr))
    {
        hr = E_NOTIMPL;
    }
    else if (hr == S_OK && pColors)
    {
        AddColors(pColors);
        CoTaskMemFree(pColors);

    }

    RRETURN1(hr, S_FALSE);
}

BOOL
CColorInfo::IsFull()
{
    Assert(_cColors <= _cColorsMax);
    return _cColors >= _cColorsMax;
}

HRESULT
CColorInfo::GetColorSet(LPLOGPALETTE FAR *ppColors)
{
    *ppColors = 0;
    if (_cColors == 0)
        RRETURN1(S_FALSE, S_FALSE);

    LOGPALETTE *pColors;

    //
    // It's just easier to allocate 256 colors instead of messing about.
    //
    *ppColors = pColors = (LOGPALETTE *)CoTaskMemAlloc(sizeof(LOGPALETTE) + 255 * sizeof(PALETTEENTRY));

    if (!pColors)
        RRETURN(E_OUTOFMEMORY);

    // This will ensure that we have a reasonable set of colors, including
    // the system colors to start
    memcpy(pColors, &g_lpHalftone, sizeof(g_lpHalftone));

    unsigned cColors = min((unsigned)236, _cColors);

    // Notice that we avoid overwriting the beginning of the _aColors array.
    // The assumption is that the colors are in some kind of order.
    memcpy(pColors->palPalEntry + 10, _aColors, cColors * sizeof(PALETTEENTRY));

    for (unsigned i = 10 ; i < (cColors + 10); i++)
        pColors->palPalEntry[i].peFlags = PC_NOCOLLAPSE;

    RRETURN(S_OK);
}
#if DBG == 1

ExternTag(tagPalette);

void DumpPalette(CHAR *szName, unsigned cColors, PALETTEENTRY *pColors)
{
    if (pColors)
    {
        TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "DumpPalette: %s\n", szName));
        TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "idx r  g  b  flags"));
        for (unsigned i = 0 ; i < cColors ; i++)
        {
            TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "%02x: %02x %02x %02x %02x", i, pColors[i].peRed, pColors[i].peGreen, pColors[i].peBlue, pColors[i].peFlags));
            if (i % 8 == 0)
                TraceTagEx((tagPalette, TAG_NONAME | TAG_NONEWLINE | TAG_USECONSOLE, "\n"));
        }
    }
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

void DumpPalette(CHAR *szName, LOGPALETTE *lp)
{
    if (lp)
        DumpPalette(szName, lp->palNumEntries, lp->palPalEntry);
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

void DumpPalette(CHAR *szName, HPALETTE hpal)
{
    if (hpal)
    {
        PALETTEENTRY ape[256];
        DumpPalette(szName, GetPaletteEntries(hpal, 0, 256, ape), ape);
    }
    else
        TraceTag((tagPalette, "%s is NULL", szName));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\color3d.cxx ===
//+------------------------------------------------------------------------
//
//  File:       color3d.cxx
//
//  Contents:   Definitions of 3d color
//
//  History:    21-Mar-95   EricVas  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

    //
    // Colors
    //

static inline COLORREF
DoGetColor ( BOOL fUseSystem, COLORREF coColor, int lColorIndex )
{
    return fUseSystem ? GetSysColorQuick( lColorIndex ) : coColor;
}
            
COLORREF ThreeDColors::BtnFace ( void )
    { return DoGetColor( _fUseSystem, _coBtnFace, COLOR_BTNFACE ); }

COLORREF ThreeDColors::BtnLight ( void )
    { return DoGetColor( _fUseSystem, _coBtnLight, COLOR_3DLIGHT); }

COLORREF ThreeDColors::BtnShadow ( void )
    { return DoGetColor( _fUseSystem, _coBtnShadow, COLOR_BTNSHADOW ); }
    
COLORREF ThreeDColors::BtnHighLight ( void )
    { return DoGetColor( _fUseSystem, _coBtnHighLight, COLOR_BTNHIGHLIGHT ); }

COLORREF ThreeDColors::BtnDkShadow ( void )
    { return DoGetColor( _fUseSystem, _coBtnDkShadow, COLOR_3DDKSHADOW ); }
    
COLORREF ThreeDColors::BtnText ( void )
    { return DoGetColor( TRUE, 0, COLOR_BTNTEXT ); }


    //
    // Brushes
    //

HBRUSH ThreeDColors::BrushBtnFace ( void )
    { return GetCachedBrush(BtnFace()); }

HBRUSH ThreeDColors::BrushBtnLight ( void )
    { return GetCachedBrush(BtnLight());}

HBRUSH ThreeDColors::BrushBtnShadow ( void )
    { return GetCachedBrush(BtnShadow()); }
    
HBRUSH ThreeDColors::BrushBtnHighLight ( void )
    { return GetCachedBrush(BtnHighLight()); }
    
HBRUSH ThreeDColors::BrushBtnText ( void )
    { return GetCachedBrush(BtnText()); }



//***********************************************************************
// Start of HWB Functions
//***********************************************************************

//
// RGB to HWB transform
//
// RGB are each on [0, 1]. W and B are returned on [0, 1] and H is  
// returned on [0, 6]. Exception: H is returned UNDEFINED if W == 1 - B.  
//
void RGBtoHWB(HWBVAL *pDstHWB, const RGBVAL *pSrcRGB)
{
    // extract RGB components
    float R = pSrcRGB->red;
    float G = pSrcRGB->green;
    float B = pSrcRGB->blue;

    // find the high and low components
    float loRGB = R;            float hiRGB = R;
    if (loRGB > G) loRGB = G;   if (hiRGB < G) hiRGB = G;
    if (loRGB > B) loRGB = B;   if (hiRGB < B) hiRGB = B;

    // compute the hue
    float hue = UNDEFINED_HUE;
    if (hiRGB != loRGB)
    {
        float f, i;

        if (R == loRGB)
        {
            f = G - B;
            i = 3.0f;
        }
        else if (G == loRGB)
        {
            f = B - R;
            i = 5.0f;
        }
        else
        {
            f = R - G;
            i = 1.0f;
        }

        hue = i - (f / (hiRGB - loRGB));
    }

    // store the result
    pDstHWB->hue       = hue;
    pDstHWB->whiteness = loRGB;
    pDstHWB->blackness = 1 - hiRGB;
}


//
// HWB to RGB transform
//
// H is given on [0, 6] or UNDEFINED. W and B are given on [0, 1].
// RGB are each returned on [0, 1].
//
void HWBtoRGB(RGBVAL *pDstRGB, const HWBVAL *pSrcHWB)
{
    // extract RGB components
    float hue       = pSrcHWB->hue;
    float whiteness = pSrcHWB->whiteness;
    float blackness = pSrcHWB->blackness;

    // extract value;
    float value = 1 - blackness;

    // default R, G and B to value
    float R = value;
    float G = value;
    float B = value;

    // if there is hue then compute the individual components
    if (hue != UNDEFINED_HUE)
    {
        int i = (int)hue;  // floor (h is positive)

        float f = hue - i;
        if (i & 1)
            f = 1.0f - f;

        float mid = whiteness + f * (value - whiteness);

        switch (i)
        {
        case 6:
        case 0:
            G = mid;
            B = whiteness;
            break;

        case 1:
            R = mid;
            B = whiteness;
            break;

        case 2:
            R = whiteness;
            B = mid;
            break;

        case 3:
            R = whiteness;
            G = mid;
            break;

        case 4:
            R = mid;
            G = whiteness;
            break;

        case 5:
            G = whiteness;
            B = mid;
            break;
        }
    }

    // store the result
    pDstRGB->red   = R;
    pDstRGB->green = G;
    pDstRGB->blue  = B;
}


//
// converts a COLORREF to an HWB color value
//
void COLORREFtoHWB(HWBVAL *pDstHWB, COLORREF crColor)
{
    // convert to RGB
    RGBVAL rgb;
    rgb.red   = (float)GetRValue(crColor) / 255.0f;
    rgb.green = (float)GetGValue(crColor) / 255.0f;
    rgb.blue  = (float)GetBValue(crColor) / 255.0f;

    // convert to HWB
    RGBtoHWB(pDstHWB, &rgb);
}


//
// converts an HWB color value to a COLORREF
//
COLORREF HWBtoCOLORREF(const HWBVAL *pSrcHWB)
{
    // convert from HWB
    RGBVAL rgb;
    HWBtoRGB(&rgb, pSrcHWB);

    // convert to integer [0..255]
    int R = (int)((rgb.red   * 255) + 0.5f);
    int G = (int)((rgb.green * 255) + 0.5f);
    int B = (int)((rgb.blue  * 255) + 0.5f);

    // pack into COLORREF
    return RGB(R, G, B);
}


//
// clips an HWB color to make sure (W + B) < 1.0
//
// bias parameter allows caller to specify how overflows are corrected
//  0.0 -> whiteness is reduced
//  1.0 -> blackness is reduced
//  0.5 -> whiteness and blackness are reduced evenly
//  etc...
//
void ClipHWB(HWBVAL *phwb, float bias)
{
    //t clip the raw range for whiteness
    if (phwb->whiteness > 1.0f)
        phwb->whiteness = 1.0f;
    else if (phwb->whiteness < 0.0f)
        phwb->whiteness = 0.0f;

    // clip the raw range for blackness
    if (phwb->blackness > 1.0f)
        phwb->blackness = 1.0f;
    else if (phwb->blackness < 0.0f)
        phwb->blackness = 0.0f;

    // compute the total of whiteness and blackness
    float v = phwb->whiteness + phwb->blackness;

    // if it is valid then we're done
    if (v >= 1.0)
    {
        // there is no hue when we W+B is maxed
        phwb->hue = UNDEFINED_HUE;

        // is there overflow to deal with?
        if (v > 1.0)
        {
            // convert to overflow
            v -= 1.0f;

            // split the overflow into biased components
            float vB = v * bias;
            float vW = v - vB;

            // reduce whiteness according to bias
            phwb->whiteness -= vW;

            // reduce blackness according to bias
            phwb->blackness -= vB;
        }
    }
}


//
// copies an HWB color and calls ClipHWB on the destination
//
// se ClipHWB for more info
//
void CopyClipHWB(HWBVAL *pDst, const HWBVAL *pSrc, float bias)
{
    // copy the raw value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness;
    pDst->blackness = pSrc->blackness;

    // clip with the specified bias
    ClipHWB(pDst, bias);
}


const float afHFudge[] =
{
    0.865f, // hue==0.0 red
    0.870f, // hue==0.5 orange
    1.300f, // hue==1.0 yellow
    1.100f, // hue==1.5 lime
    1.100f, // hue==2.0 green
    1.200f, // hue==2.5 aqua
    1.300f, // hue==3.0 cyan
    0.825f, // hue==3.5 peacock
    0.845f, // hue==4.0 blue
    0.900f, // hue==4.5 purple
    1.000f, // hue==5.0 magenta
    0.900f, // hue==5.5 fuscia
};

#define WB_FUDGE_MIN    (0.40f)
#define WB_FUDGE_MAX    (0.90f)

#define LIGHTEN_BASE    (0.05f)
#define LIGHTEN_SCALE   (0.55f)

#define DARKEN_BASE     (0.00f)
#define DARKEN_SCALE    (0.40f)

static float 
GetHueHighlightFudge(float hue)
{
    if(hue == UNDEFINED_HUE)
        return 1.0f;

    // fetch the hue and scale it for indexing into the fudge array
    float v = 2.0f * hue;
    int step = (int)v;

    // extract the two nearest factors
    float f1 = afHFudge[step % 12];
    float f2 = afHFudge[(step + 1) % 12];

    // calculate the interpolant to use
    float blend = v - step;

    // return the interpolated fudge factor
    return (f1 * (1.0f - blend)) + (f2 * blend);
}


static float 
GetWhiteBlackHighlightFudge(float whiteness, float blackness)
{
    // compute raw fudge factor from 0 to 1
    float v = (1.0f + whiteness - blackness) / 2.0f;

    // scale to desired output range
    return WB_FUDGE_MIN + v * (WB_FUDGE_MAX - WB_FUDGE_MIN);
}


static float 
GetHighlightFudge(const HWBVAL *pSrc)
{
    // make a clipped copy of the value
    HWBVAL hwb;
    CopyClipHWB(&hwb, pSrc, 0.5f);

    // compute the hue-based component of the fudge factor, start with the hue
    float hFudge = GetHueHighlightFudge(hwb.hue);

    // compute a W/B fudge factor from 0 to 1
    float wbFudge = GetWhiteBlackHighlightFudge(hwb.whiteness, hwb.blackness);

    // blend describes how strongly the W and B channels influence the final fudge factor
    float blend = hwb.whiteness + hwb.blackness;

    // combine the hue fudge with the W/B fudge and return it
    return (hFudge * (1.0f - blend)) + (wbFudge * blend);
}


void 
LightenHWB(HWBVAL *pDst, const HWBVAL *pSrc, float factor)
{
    // lighten the value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness + factor * (LIGHTEN_BASE + ((1.0 - pSrc->whiteness) * LIGHTEN_SCALE)) * GetHighlightFudge(pSrc);
    pDst->blackness = pSrc->blackness - factor * (LIGHTEN_BASE + (pSrc->blackness * LIGHTEN_SCALE));

    // make sure we adjust any overflows to favor a lighter color
    ClipHWB(pDst, 1.0f);
}


void 
DarkenHWB(HWBVAL *pDst, const HWBVAL *pSrc, float factor)
{
    // darker the value
    pDst->hue       = pSrc->hue;
    pDst->whiteness = pSrc->whiteness - factor * (DARKEN_BASE + (pSrc->whiteness * DARKEN_SCALE));
    pDst->blackness = pSrc->blackness + factor * (DARKEN_BASE + ((1.0 - pSrc->blackness) * DARKEN_SCALE));

    // make sure we adjust any overflows to favor a darker color
    ClipHWB(pDst, 0.0f);
}


//+------------------------------------------------------------------------
//
//  Functions:  LightenColor & DarkenColor
//
//  Synopsis:   These take COLORREFs and return COLORREFs which are "lighter" or
//              "darker"
//
//-------------------------------------------------------------------------

COLORREF LightenColor(COLORREF cr, float factor /* = 1.0f*/, BOOL fSubstituteSysColors /* = TRUE */)
{
    HWBVAL hwbSrc, hwbDst;

    // check if we should use system colors when the face matches
    if (fSubstituteSysColors && (cr == GetSysColor(COLOR_3DFACE)))
        return GetSysColor(COLOR_3DLIGHT);

    // convert to HWB color space
    COLORREFtoHWB(&hwbSrc, cr);

    // lighten the color
    LightenHWB(&hwbDst, &hwbSrc, factor);

    // convert back to RGB
    return HWBtoCOLORREF(&hwbDst);
}


COLORREF DarkenColor(COLORREF cr, float factor /* = 1.0f*/, BOOL fSubstituteSysColors /* = TRUE */)
{
    HWBVAL hwbSrc, hwbDst;

    // check if we should use system colors when the face matches
    if (fSubstituteSysColors && (cr == GetSysColor(COLOR_3DFACE)))
        return GetSysColor(COLOR_3DSHADOW);

    // convert to HWB color space
    COLORREFtoHWB(&hwbSrc, cr);

    // darken the color
    DarkenHWB(&hwbDst, &hwbSrc, factor);

    // convert back to RGB
    return HWBtoCOLORREF(&hwbDst);
}


// End of HWB Functions
//***********************************************************************


//+------------------------------------------------------------------------
//
//  Member:     ThreeDColors::SetBaseColor
//
//  Synopsis:   This is called to reestablish the 3D colors, based on a
//              single color.
//
//-------------------------------------------------------------------------

void
ThreeDColors::SetBaseColor ( OLE_COLOR coBaseColor )
{
        //
        // Sentinal color (0xffffffff) means use default which is button face
        //

    _fUseSystem = (coBaseColor & 0x80ffffff) == DEFAULT_BASE_COLOR;
    
#ifdef UNIX
    _fUseSystem = ( _fUseSystem ||
                    (CColorValue(coBaseColor).IsUnixSysColor()));
#endif

    if (_fUseSystem)
        return;

        //
        // Ok, now synthesize some colors! 
        //
        // First, use the base color as the button face color
        //
    
    _coBtnFace = ColorRefFromOleColor( coBaseColor );

    _coBtnLight = _coBtnFace;
        //
        // Dark shadow is always black and button face
        // (or so Win95 seems to indicate)
        //

    _coBtnDkShadow = 0;
    
        //
        // Now, lighten/darken colors
        //

    _coBtnShadow = DarkenColor( _coBtnFace );

    XHDC *pxhdc;
    HWND hwnd = NULL;
    HDC  hdc = NULL;

    if(_pxhdc)
    {
        pxhdc = _pxhdc;
    }
    else
    {
        // Use the screen DC, used currently to return values to currentStyle 
        hwnd = GetDesktopWindow();
        hdc = GetDC(hwnd);
        if (!hdc)
            return;
        pxhdc = new XHDC(hdc, NULL);
    }

    if(!pxhdc)
        return;

    COLORREF coRealBtnFace = GetNearestColor( *pxhdc, _coBtnFace );

    _coBtnHighLight = LightenColor( _coBtnFace );

    if (GetNearestColor( *pxhdc, _coBtnHighLight ) == coRealBtnFace)
    {
        _coBtnHighLight = LightenColor( _coBtnHighLight );

        if (GetNearestColor( *pxhdc, _coBtnHighLight ) == coRealBtnFace)
            _coBtnHighLight = RGB( 255, 255, 255 );
    }

    _coBtnShadow = DarkenColor( _coBtnFace );

    if (GetNearestColor( *pxhdc, _coBtnShadow ) == coRealBtnFace)
    {
        _coBtnShadow = DarkenColor( _coBtnFace );

        if (GetNearestColor( *pxhdc, _coBtnShadow ) == coRealBtnFace)
            _coBtnShadow = RGB( 0, 0, 0 );
    }

    if(hdc)
    {
        Assert(_pxhdc == 0);
        ReleaseDC(hwnd, hdc);
        delete pxhdc;
    }
}
//
// Function: RGB2YIQ
//
// Parameter: c -- the color in RGB.
//
// Note: Converts RGB to YIQ. The standard conversion matrix obtained
//       from Foley Van Dam -- 2nd Edn.
//
// Returns: Nothing
//
inline void CYIQ::RGB2YIQ (COLORREF   c)
{
    int R = GetRValue(c);
    int G = GetGValue(c);
    int B = GetBValue(c);

    _Y = (30 * R + 59 * G + 11 * B + 50) / 100;
    _I = (60 * R - 27 * G - 32 * B + 50) / 100;
    _Q = (21 * R - 52 * G + 31 * B + 50) / 100;
}

//
// Function: YIQ2RGB
//
// Parameter: pc [o] -- the color in RGB.
//
// Note: Converts YIQ to RGB. The standard conversion matrix obtained
//       from Foley Van Dam -- 2nd Edn.
//
// Returns: Nothing
//
inline void CYIQ::YIQ2RGB (COLORREF *pc)
{
    int R, G, B;

    R = (100 * _Y +  96 * _I +  62 * _Q + 50) / 100;
    G = (100 * _Y -  27 * _I -  64 * _Q + 50) / 100;
    B = (100 * _Y - 111 * _I + 170 * _Q + 50) / 100;

    // Needed because of round-off errors
    if (R < 0) R = 0; else if (R > 255) R = 255;
    if (G < 0) G = 0; else if (G > 255) G = 255;
    if (B < 0) B = 0; else if (B > 255) B = 255;

    *pc = RGB(R,G,B);
}

//
// Function: Luminance
//
// Parameter: c -- The color whose luminance is to be returned
//
// Returns: The luminance value [0,255]
//
static inline int Luminance (COLORREF c)
{
    return CYIQ(c)._Y;
}

//
// Function: MoveColorBy
//
// Parameters: pcColor [i,o] The color to be moved
//             nLums         Move so that new color is this bright
//                           or darker than the original: a signed
//                           number whose abs value is betn 0 and 255
//
// Returns: Nothing
//
static void MoveColorBy (COLORREF *pcColor, int nLums)
{
    CYIQ yiq(*pcColor);
    int Y;

    Y = yiq._Y;
    
    if (Y + nLums > CYIQ::MAX_LUM)
    {
        // Cannot move more in the lighter direction.
        *pcColor = RGB(255,255,255);
    }
    else if (Y + nLums < CYIQ::MIN_LUM)
    {
        // Cannot move more in the darker direction.
        *pcColor = RGB(0,0,0);
    }
    else
    {
        Y += nLums;
        if (Y < 0)
            Y = 0;
        if (Y > 255)
            Y =255;

        yiq._Y = Y;
        yiq.YIQ2RGB (pcColor);
    }
}

//
// Function: ContrastColors
//
// Parameters: c1,c2 [i,o]: Colors to be contrasted
//             Luminance:   Contrast so that diff is luminance is atleast
//                          this much: A number in the range [0,255]
//
// IMPORTANT: If you change this function, make sure, not to change the order
//            of the colors because some callers depend it.  For example if
//            both colors are white, we need to guarantee that only the
//            first color (c1) is darkens and never the second (c2).
//
// Returns: Nothing
//
void ContrastColors (COLORREF &c1, COLORREF &c2, int LumDiff)
{
    COLORREF *pcLighter, *pcDarker;
    int      l1, l2, lLighter, lDarker;
    int      lDiff, lPullApartBy;

    Assert ((LumDiff >= CYIQ::MIN_LUM) && (LumDiff <= CYIQ::MAX_LUM));

    l1 = Luminance(c1);
    l2 = Luminance(c2);

    // If both the colors are black, make one slightly bright so
    // things work OK below ...
    if ((l1 == 0) && (l2 == 0))
    {
        c1 = RGB(1,1,1);
        l1 = Luminance (c1);
    }
    
    // Get their absolute difference
    lDiff = l1 < l2 ? l2 - l1 : l1 - l2;

    // Are they different enuf? If yes get out
    if (lDiff >= LumDiff)
        return;

    // Attention:  Don't change the order of the two colors as some callers
    // depend on this order. In case both colors are the same they need
    // to know which color is made darker and which is made lighter.
    if (l1 > l2)
    {
        // c1 is lighter than c2
        pcLighter = &c1;
        pcDarker = &c2;
        lDarker = l2;
    }
    else
    {
        // c1 is darker than c2
        pcLighter = &c2;
        pcDarker = &c1;
        lDarker = l1;
    }

    //
    // STEP 1: Move lighter color
    //
    // Each color needs to be pulled apart by this much
    lPullApartBy = (LumDiff - lDiff + 1) / 2;
    Assert (lPullApartBy > 0);
    // First pull apart the lighter color -- in +ve direction
    MoveColorBy (pcLighter, lPullApartBy);

    //
    // STEP 2: Move darker color
    //
    // Need to move darker color in the darker direction.
    // Note: Since the lighter color may not have moved enuf
    // we compute the distance the darker color should move
    // by recomuting the luminance of the lighter color and
    // using that to move the darker color.
    lLighter = Luminance (*pcLighter);
    lPullApartBy = lLighter - LumDiff - lDarker;
    // Be sure that we are moving in the darker direction
    Assert (lPullApartBy <= 0);
    MoveColorBy (pcDarker, lPullApartBy);

    //
    // STEP 3: If necessary, move lighter color again
    //
    // Now did we have enuf space to move in darker region, if not,
    // then move in the lighter region again
    lPullApartBy = Luminance (*pcDarker) + LumDiff - lLighter;
    if (lPullApartBy > 0)
    {
        MoveColorBy (pcLighter, lPullApartBy);
    }

#ifdef DEBUG    
    {
        int l1 = Luminance (c1);
        int l2 = Luminance (c2);
        int diff = l1 - l2; 
    }
#endif    

    return;
}


void
ThreeDColors::NoDither()
{
    _coBtnFace          |= 0x02000000;
    _coBtnLight			|= 0x02000000;
    _coBtnShadow        |= 0x02000000;
    _coBtnHighLight     |= 0x02000000;
    _coBtnDkShadow      |= 0x02000000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\buttutil.cxx ===
//+------------------------------------------------------------------------
//
//  File:       dbbase.cxx
//
//  Contents:   Button Drawing routines common to scrollbar and dropbutton.
//
//  History:    15-Aug-95   t-vuil  Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifdef UNIX
#ifndef X_UNIXCTLS_HXX_
#define X_UNIXCTLS_HXX_
#include "unixctls.hxx"
#endif
#endif
//+------------------------------------------------------------------------
//
//  Function:   DrawRect
//
//  Synopsis:   Draws a rectangle in the current BG color
//
//  Notes:      Uses ExtTextOut because it has generally been highly
//              optimized for text rendering
//
//-------------------------------------------------------------------------

void
DrawRect (
    XHDC hdc, HBRUSH hbr, int x1, int y1, int x2, int y2,
    BOOL fReleaseBrush = TRUE )
{
    if (x2 > x1 && y2 > y1)
    {
        HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
        PatBlt( hdc, x1, y1, x2 - x1, y2 - y1, PATCOPY );
        SelectObject(hdc, hbrOld);
    }

    if (fReleaseBrush)
        ReleaseCachedBrush( hbr );
}

void
CUtilityButton::Invalidate(HWND hWnd, const RECT &rc, DWORD dwFlags)
{
    if (hWnd)
    {
        RedrawWindow(hWnd, &rc, NULL, RDW_INVALIDATE);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     DrawNull
//
//  Synopsis:   Draws nothing
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawNull (
    XHDC hdc, HBRUSH, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
}

//+------------------------------------------------------------------------
//
//  Member:     DrawDotDotDot
//
//  Synopsis:   Draws the Ellipses Glyph (dotdotdot) (used in dropbutton)
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawDotDotDot (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long xStart, yStart, width, height;
    
    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );

        //
        // 106 is about 3 points, which is how far from the bottom
        // the dots starts.
        //
        // 53 is about 1.5 points, which the height/width of the dots
        //

    yStart = rcBounds.bottom -
        MulDiv( rcBounds.bottom - rcBounds.top, 106, sizel.cy );
    
    height = MulDiv( rcBounds.bottom - rcBounds.top, 53, sizel.cy );
    width  = MulDiv( rcBounds.right - rcBounds.left, 54, sizel.cx );

    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 2 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 5 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 8 / 13;
    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     DrawReduce
//
//  Synopsis:   Draws the under bar
//
//-------------------------------------------------------------------------

void
CUtilityButton::DrawReduce (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH glyph,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long xStart, yStart, width, height;
    
    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );

        //
        // 106 is about 3 points, which is how far from the bottom
        // the bar starts.
        //
        // 53 is about 1.5 points, which the height of the bar
        //

    yStart = rcBounds.bottom -
        MulDiv( rcBounds.bottom - rcBounds.top, 108, sizel.cy );
    
    height = MulDiv( rcBounds.bottom - rcBounds.top, 54, sizel.cy );
    
    xStart = rcBounds.left + (rcBounds.right - rcBounds.left) * 3 / 13;
    width  = (rcBounds.right - rcBounds.left) * 6 / 13;

    DrawRect(hdc, hbr, xStart, yStart, xStart + width, yStart + height, FALSE);
}

//+------------------------------------------------------------------------
//
//  Function:   DrawArrow
//
//  Synopsis:   Draws a scrollbar type arrow
//
//-------------------------------------------------------------------------

// NOTE: Use PolyLine when the arrow gets big.  This speeds up drawing,
//         and lets printing dither

void
CUtilityButton::DrawArrow (
    XHDC hdc, HBRUSH hbr, BUTTON_GLYPH dir,
    const RECT & rcBounds, const SIZEL & sizel )
{
    long i;

    Assert( rcBounds.right  > rcBounds.left );
    Assert( rcBounds.bottom > rcBounds.top );
    
    Assert(
        dir == BG_UP || dir == BG_DOWN || dir == BG_LEFT || dir == BG_RIGHT );

    if (dir == BG_UP || dir == BG_DOWN)
    {
            //
            // Determine the height of the arrow by computing the largest
            // arrows we allow for the given width and height, and then taking
            // the smaller of the two.  Also make sure it is non zero.
            //

        long arrow_height =
            max(
                (long)1,
                (long)min(
                    (rcBounds.bottom - rcBounds.top + 2) / 3,
                    ((rcBounds.right - rcBounds.left) * 5 / 8 + 1) / 2 ) );
        
            //
            // Locate where the top of the arrow starts and where it is
            // centered horizontally
            //
        
        long sy =
            rcBounds.top +
                (rcBounds.bottom - rcBounds.top + 1 - arrow_height) / 2;

        long cx =
            rcBounds.left + (rcBounds.right - rcBounds.left - 1) / 2;

            //
            // Draw the arrow from top to bottom in successive strips
            //
        
        for ( i = 0 ; i < arrow_height ; i++ )
        {
            long y = dir == BG_UP ? sy + i : sy + arrow_height - i - 1;

            DrawRect( hdc, hbr, cx - i, y, cx - i + 1 + i * 2, y + 1, FALSE );
        }
    }
    else    
    {
            //
            // Determine the width of the arrow by computing the largest
            // arrows we allow for the given width and height, and then taking
            // the smaller of the two.  Also make sure it iz non zero.
            //
        
        long arrow_width =
            max(
                (long)1,
                (long)min(
                    (rcBounds.right - rcBounds.left + 2) / 3,
                    ((rcBounds.bottom - rcBounds.top) * 5 / 8 + 1) / 2 ) );
        
            //
            // Locate where the left of the arrow starts and where it is
            // centered vertically
            //
        
        long sx =
            rcBounds.left +
                (rcBounds.right - rcBounds.left + 1 - arrow_width) / 2;
        
        long cy =
            rcBounds.top + (rcBounds.bottom - rcBounds.top) / 2;

            //
            // Draw the arrow from top to bottom in successive strips
            //

        for ( long i = 0 ; i < arrow_width ; i++ )
        {
            long x = dir == BG_LEFT ? sx + i : sx + arrow_width - i - 1;
            
            DrawRect( hdc, hbr, x, cy - i, x + 1, cy + i + 1, FALSE );
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   DrawButton
//
//  Synopsis:   Draws a scrollbar type pushbutton
//
//-------------------------------------------------------------------------


void
CUtilityButton::DrawButton (
    CDrawInfo * pDI, HWND hWnd, BUTTON_GLYPH glyph,
    BOOL fPressed, BOOL fEnabled, BOOL focused,
    const RECT & rcBounds, const SIZEL & sizelExtent,
    unsigned long padding )
{
    if (hWnd)
    {
        Invalidate(hWnd, rcBounds);
    }
    else
    {
        void (CUtilityButton ::* pmfDraw) (
                                           XHDC, HBRUSH, BUTTON_GLYPH, const RECT &, const SIZEL & );

        ThreeDColors &  colors = GetColors();
        RECT            rcGlyph = rcBounds;
        SIZEL           sizelGlyph = sizelExtent;
        long            dx = 0, dy = 0, xOffset = 0, yOffset = 0;


        // must have at least hdc
        AssertXHDC(pDI->_hdc);
        // should come in initialized
        Assert(pDI->IsInitialized()); 


        //
        // First, draw the border around the glyph and the background.
        //

        if (fPressed && !_fFlat)
        {
            RECT rcFill = rcBounds;

            //
            // Draw a "single line" border then reduce rect by that size and
            // Fill the rest with the button background
            //
#ifdef UNIX // If it's a motif button, see below #ifdef UNIX codes
            if (!_bMotifScrollBarBtn)
            {
#endif
            IGNORE_HR(BRDrawBorder(
                                   pDI, 
                                   LPRECT(& rcBounds),
                                   fmBorderStyleSingle, 
                                   colors.BtnShadow(), 
                                   0, 
                                   0));

            IGNORE_HR(BRAdjustRectForBorder(
                                            pDI, 
                                            & rcFill, 
                                            fmBorderStyleSingle));

            DrawRect(
                     pDI->_hdc, colors.BrushBtnFace(),
                     rcFill.left, rcFill.top, rcFill.right, rcFill.bottom );

#ifdef UNIX // Draw motif button background
            }
            else
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                switch (glyph)
                {
                    case BG_LEFT:
                        rcFill.right+=1; 
                        break;
                    case BG_RIGHT:
                        rcFill.left-=1;
                        break;
                    case BG_UP:
                        rcFill.bottom+=1;
                        break;
                    case BG_DOWN:
                        rcFill.top-=1;
                        break;
                }
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_LEFT || glyph==BG_UP) ?
                                    LeftTopThumbRect : RightBottomThumbRect,
                                    &rcFill,
                                    FALSE,
                                    &info);
                switch (glyph)
                {
                    case BG_LEFT:
                        rcFill.right-=1; 
                        break;
                    case BG_RIGHT:
                        rcFill.left+=1;
                        break;
                    case BG_UP:
                        rcFill.bottom-=1;
                        break;
                    case BG_DOWN:
                        rcFill.top+=1;
                        break;
                }
            }
#endif
            //
            // Now, compute the reduced rect as if a sunken border were drawn.
            // This leaves the glyph rect in rcGlyph
            //

#ifdef UNIX
            if (!_bMotifScrollBarBtn)
#endif
            IGNORE_HR(BRAdjustRectForBorder(
                                            pDI,
                                            & rcGlyph,
                                            fmBorderStyleRaised));
        }
        else
        {
#ifdef UNIX
            if (!_bMotifScrollBarBtn)
            {
#endif
            //
            // Draw the sunken border and fill the rest with the button bg.
            // This leaves the arrow rect in rcGlyph

            // If we come here with fPressed = TRUE, this must be a flat scrollbar

            IGNORE_HR( BRDrawBorder(
                                    pDI, LPRECT(& rcBounds), 
                                    (fPressed) ? fmBorderStyleSunken : fmBorderStyleRaised,
                                    0, 
                                    & colors, 
                                    (_fFlat) ? BRFLAGS_MONO : 0 ) );

            IGNORE_HR( BRAdjustRectForBorder(
                                             pDI, 
                                             & rcGlyph, 
                                             (_fFlat) ? fmBorderStyleSingle : fmBorderStyleRaised));

            DrawRect(
                     pDI->_hdc, colors.BrushBtnFace(),
                     rcGlyph.left, rcGlyph.top, rcGlyph.right, rcGlyph.bottom );
#ifdef UNIX
            }
            else
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                switch (glyph)
                {
                    case BG_LEFT:
                        rcGlyph.right+=1; 
                        break;
                    case BG_RIGHT:
                        rcGlyph.left-=1;
                        break;
                    case BG_UP:
                        rcGlyph.bottom+=1;
                        break;
                    case BG_DOWN:
                        rcGlyph.top-=1;
                        break;
                }
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_LEFT || glyph==BG_UP) ?
                                    LeftTopThumbRect : RightBottomThumbRect,
                                    &rcGlyph,
                                    FALSE,
                                    &info);
                switch (glyph)
                {
                    case BG_LEFT:
                        rcGlyph.right-=1; 
                        break;
                    case BG_RIGHT:
                        rcGlyph.left+=1;
                        break;
                    case BG_UP:
                        rcGlyph.bottom-=1;
                        break;
                    case BG_DOWN:
                        rcGlyph.top+=1;
                        break;
                }
            }
#endif
        }

        //
        // See if we have a null rect.
        //

        if (rcGlyph.right <= rcGlyph.left || rcGlyph.bottom <= rcGlyph.top)
            goto Cleanup;

        //
        // Adjust the extent to reflect the border
        //

        BRAdjustSizelForBorder(
                               & sizelGlyph, fmBorderStyleSunken );

        //
        // A combo glyph looks like a down arrow
        //

        if (glyph == BG_COMBO)
            glyph = BG_DOWN;

        //
        // Select the draw member.  Default to arrow.
        //

        pmfDraw = & CUtilityButton::DrawArrow;

        switch ( glyph )
        {
            case BG_PLAIN :
                pmfDraw = & CUtilityButton::DrawNull;
                break;

                //
                // Adjust the rect for padding.
                //
                // TODO: the padding has not been zoomed....
                //

            case BG_DOWN  : rcGlyph.bottom -= padding; break;
            case BG_UP    : rcGlyph.top    += padding; break;
            case BG_LEFT  : rcGlyph.left   += padding; break;
            case BG_RIGHT : rcGlyph.right  -= padding; break;

            case BG_REFEDIT:
                pmfDraw = & CUtilityButton::DrawDotDotDot;
                break;

            case BG_REDUCE:
                pmfDraw = & CUtilityButton::DrawReduce;
                break;

            default:
                Assert( 0 && "Unknown glyph" );
                goto Cleanup;
        }

        // In the rest of the code, if the scrollbar is flat, ignore
        // fPressed (no offset even if the button is pressed)
        if (_fFlat)
            fPressed = FALSE;

        //
        // Now that the glyph draw member has been selected, use it to draw.
        //
        //
        // If we are pressed or disabled, we need to compute the offset
        // for pressing or the highlight offset version of the glyph.
        //
        // Also, if we have to draw a focus, we need to know how much to 
        // offset the focus rect from the border.
        //

        if (!fEnabled || fPressed || focused)
        {

            //
            // The offset is 27 HIMETRICS (~ 3/4 points).
            //


            xOffset = MulDiv( rcGlyph.right - rcGlyph.left, 27, sizelGlyph.cx );
            yOffset = MulDiv( rcGlyph.bottom - rcGlyph.top, 27, sizelGlyph.cy );

            if (!fEnabled || fPressed)
            {
                dx = xOffset;
                dy = yOffset;
            }
        }

        if (fEnabled)
        {
            RECT rc = rcGlyph;
            HBRUSH hbr = colors.BrushBtnText();

            if (fPressed)
            {
                rc.left   += dx;
                rc.right  += dx;
                rc.top    += dy;
                rc.bottom += dy;
            }

#ifdef UNIX
            if (_bMotifScrollBarBtn)
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = FALSE;
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_RIGHT || glyph==BG_DOWN) ?
                                    RightBottomButton : LeftTopButton,
                                    &rc,
                                    fPressed,
                                    &info);
            }
            else 
#endif                           
            CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rc, sizelGlyph ));

            ReleaseCachedBrush( hbr );
        }
        else
        {
            HBRUSH hbr;

            //
            // Here we draw the disabled glyph.  First, draw the lighter
            // back ground version, the the darker foreground version.
            //

            RECT rcBack = {
                rcGlyph.left + dx, rcGlyph.top + dy,
                rcGlyph.right + dx, rcGlyph.bottom + dy };

#ifdef UNIX
            if (_bMotifScrollBarBtn)
            {
                ScrollBarInfo info;
                info.lStyle=(glyph==BG_LEFT || glyph==BG_RIGHT)?SB_HORZ:SB_VERT;
                info.bDisabled = TRUE;
                MwPaintMotifScrollRect( pDI->_hdc,
                                    (glyph==BG_DOWN || glyph==BG_RIGHT) ?
                                    RightBottomButton : LeftTopButton,
                                    &rcGlyph,
                                    FALSE, //fPressed,
                                    &info);
            }
            else 
            {
#endif                           
                hbr = colors.BrushBtnHighLight();
                CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rcBack, sizelGlyph ));
                ReleaseCachedBrush( hbr );

                hbr = colors.BrushBtnShadow();
                CALL_METHOD(this,pmfDraw,( pDI->_hdc, hbr, glyph, rcGlyph, sizelGlyph ));
                ReleaseCachedBrush( hbr );
#ifdef UNIX
            }
#endif
        }

        //
        // Draw any focus rect
        //

        // TODO: This relies heavily on the assumption that the arrow which is
        //         drawn leaves alot of space around the edge so that the focus
        //         can be drawn there.  Also, the focus rect is not zoomed here.

        if (focused)
        {
            GDIRECT rcFocus = rcGlyph;

            rcFocus.left   += xOffset + dx;
            rcFocus.right  -= xOffset - dx;
            rcFocus.top    += yOffset + dy;
            rcFocus.bottom -= yOffset - dy;

            rcFocus.right  = max( rcFocus.right, rcFocus.right );
            rcFocus.bottom = max( rcFocus.bottom, rcFocus.top );

            if (rcFocus.right <= rcGlyph.right && rcFocus.bottom <= rcGlyph.bottom)
            {
                ::DrawFocusRect( pDI->_hdc, & rcFocus );
            }
        }
    }
Cleanup:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\csimutil.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CSIMUTIL_HXX_
#define X_CSIMUTIL_HXX_
#include "csimutil.hxx"
#endif

MtDefine(CPointAry, Utilities, "CPointAry")
MtDefine(CPointAry_pv, CPointAry, "CPointAry::_pv")

//=-----------------------------------------------------------------------=
//
// Function:    NextNum
// 
// Synopsis:    Helper function for parsing out the COORDS attribute - 
//              After an intial call to _tcstok to set the pointer to
//              the first token, each call will set *plNum to the number
//              pointed to by *ppch, and then update *ppch to point to
//              the next token.
//
// Arguments:   LONG *plNum - Pointer to LONG to store next num in
//              TCHAR **ppch - Pointer to location in string
//
//=-----------------------------------------------------------------------=
HRESULT
NextNum(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr = S_FALSE;

    Assert(plNum);
    *plNum = 0;


    if(*ppch)
    {
        IGNORE_HR(ttol_with_error(*ppch, plNum));
        *ppch = _tcstok(NULL, DELIMS);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//=-----------------------------------------------------------------------=
//
// Function:    PointInCircle
//
// Synopsis:    Returns TRUE if the point is contained within the circle.
//
// Arguments:   POINT pt - The point to be checked for containment
//
//=-----------------------------------------------------------------------=
BOOL
PointInCircle(POINT pt, LONG lx, LONG ly, LONG lradius)
{
    LONG lDistance;

    // Calculate the square of the distance to the center
    lDistance = (pt.x - lx) * (pt.x - lx) + (pt.y - ly) * (pt.y - ly);

    // Compare against the square of the radius
    if(lDistance <= lradius * lradius)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//=-----------------------------------------------------------------------=
//
// Function: Contains
//
// Synopsis: Returns TRUE if the area contains the given point,
//              false if it does not.
//
//=-----------------------------------------------------------------------=

BOOL
Contains(POINT pt, union CoordinateUnion coords, UINT nShapeType)
{
    switch(nShapeType)
    {
    case SHAPE_TYPE_RECT:
        return PtInRect(&(coords.Rect), pt);
        break;

    case SHAPE_TYPE_CIRCLE:
        return PointInCircle(pt, 
                             coords.Circle.lx, 
                             coords.Circle.ly, 
                             coords.Circle.lradius);
        break;

    case SHAPE_TYPE_POLY:
        return PtInRegion(coords.Polygon.hPoly, pt.x, pt.y);
        break;

    default:
        Assert(FALSE && "Undefined shape");

        return FALSE;
        break;
    }
}


//=-----------------------------------------------------------------------=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from forms directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CEnumGeneric, ObjectModel, "CEnumGeneric")
MtDefine(CEnumVARIANT, ObjectModel, "CEnumVARIANT")

//  TODO reconcile with CEnumXX in stdenum.cxx


// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(paryCopy->Copy(_cb, *pary, _fAddRef));
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    IncrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    IncrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    if (_pary && _fDelete)
    {
        if ( _fAddRef )
        {
            IUnknown ** ppUnk;
            int         i;
            int         cSize = _pary->Size();
            
            for (i=0, ppUnk = (IUnknown **) Deref(0);
                 i < cSize;
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DecrementObjectCount(&_dwObjCnt);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, void ** ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumGeneric (enumg)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//----------------------------------------------------------------------------

class CEnumGeneric : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumGeneric))

    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    //  CEnumGeneric methods
    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            REFIID          iid,
            BOOL            fAddRef,
            BOOL            fCopy,
            BOOL            fDelete,
            CEnumGeneric ** ppenum);

protected:
    CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete);
    CEnumGeneric(const CEnumGeneric & enumg);

    CEnumGeneric& operator=(const CEnumGeneric & enumg); // don't define
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CImplAry *      pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    Assert(pary);
    Assert(ppenum);
    Assert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? S_OK : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef));
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    Assert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **) ppv);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CEnumVARIANT (enumv)
//
//  Purpose:    OLE enumerator for class CImplAry.
//
//  Interface:  Next         -- Per IEnum
//              Clone        --     ""
//              Create       -- Creates a new enumerator.
//              CEnumGeneric -- ctor.
//              CEnumGeneric -- ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

class CEnumVARIANT : public CBaseEnum
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CEnumVARIANT))

    //  IEnum methods
    STDMETHOD(Next) (ULONG celt, void * reelt, ULONG * pceltFetched);
    STDMETHOD(Clone) (CBaseEnum ** ppenum);

    static HRESULT Create(
            size_t          cb,
            CImplAry *      pary,
            VARTYPE         vt,
            BOOL            fCopy,
            BOOL            fDelete,
            IEnumVARIANT ** ppenum);

protected:
    CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete);
    CEnumVARIANT(const CEnumVARIANT & enumv);
    ~CEnumVARIANT();

    HRESULT Init(CImplAry * pary, BOOL fCopy);

    // don't define
    CEnumVARIANT& operator =(const CEnumVARIANT & enumv);

    VARTYPE     _vt;                    // type of element enumerated
};


//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CImplAry *      pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    Assert(pary);
    Assert(ppenum);
    Assert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(penum->Init(pary, fCopy));
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    Assert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}

//+------------------------------------------------------------------------
//  Function:   ~CEnumVARIANT
//
//  Synopsis:   destructor
//
//  History:    8-4-1998  ferhane   Created
//-------------------------------------------------------------------------
CEnumVARIANT::~CEnumVARIANT()
{

    // if VARIANT, and have an array, and asked to delete the data
    // when terminated
    if ( (_vt == VT_VARIANT) && _pary && _fDelete )
    {
        int         i; 
        int         cSize = _pary->Size();
        VARIANT *   pVar;
        
        for( i=0, pVar = (VARIANT *) Deref(0); 
             i < cSize;
             i++, pVar++ )
        {
            IGNORE_HR( VariantClear( pVar ) );
        }

        // to avoid the same loop executing in the base class destructor
        delete _pary;
        _pary = NULL;
    }

    // we leave the decrementing of the reference count to the base
    // class destructor.
}
//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    HRESULT     hr;
    int         c;
    int         i;
    int         j;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            Assert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            Assert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            Assert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            Assert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
            Assert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        case VT_DISPATCH:
            Assert(sizeof(V_DISPATCH(pvar)) == _cb);
            hr = THR((*(IUnknown **) pb)->QueryInterface(
                    IID_IDispatch, (void **) &V_DISPATCH(pvar)));
            if (hr)
            {
                // Cleanup
                j = i;
                while (--j >= 0)
                {
                    ((IDispatch **) reelt)[j]->Release();
                }

                RRETURN(hr);
            }
            break;
        
        case VT_VARIANT:
            Assert( sizeof(*pvar) == _cb );
            hr = THR( VariantCopy( pvar, (VARIANT *)pb ));
            if (hr)
            {
                //Cleanup
                j=i;
                while( --j >= 0)
                {
                    VariantClear( &(((VARIANT *)reelt)[j]) );
                }

                RRETURN(hr);
            }
            break;

        default:
            Assert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = THR(_pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum));
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    Assert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CEnumvariant::Init
//
//  Synopsis:   2nd stage initialization performs copy of array if necessary.
//              This implementation provides VT_VARIANT data type support
//              for the clone operation on this class.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    8-5-98   ferhane   Created
//
//----------------------------------------------------------------------------
HRESULT
CEnumVARIANT::Init(CImplAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CImplAry *  paryCopy    = NULL;     // copied array

    Assert(pary);

    // If the enumeration does not contains a VT_VARIANT array,
    // then use the base class Init() method.
    if ( _vt != VT_VARIANT )
    {
        hr = THR( CBaseEnum::Init( pary, fCopy) );
        goto Cleanup;
    }

    Assert( _cb == sizeof(VARIANT));

    // Copy array if requested.
    if (fCopy)
    {
        VARIANT *   pvarSource;
        VARIANT *   pvarTarget;
        int         cSize = pary->Size();

        paryCopy = new CImplAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // make sure we have enough room in the array.
        hr = THR( paryCopy->EnsureSize(_cb, cSize));
        if ( hr )
            goto Error;

        // Move pointers to the array beginning addresses and copy 
        // each array member.
        pvarSource = (VARIANT *)pary->Deref(_cb, 0);
        pvarTarget = (VARIANT *)paryCopy->Deref( _cb, 0);
        
        for( int i=0; 
             i < cSize;
             i++, pvarSource++, pvarTarget++ )
        {
            hr = THR( VariantCopy( pvarTarget, pvarSource ) );
            if ( hr )
            {
                while( --i >= 0)
                {
                    VariantClear( --pvarTarget );
                }
                goto Error;
            }
        }

        pary = paryCopy;
    }

    // either the new array created because of the copy, or 
    // use the array that is handed ( fCopy == FALSE )
    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\cputil.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cputil.cxx
//
//  Contents:   Connection point utilities.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

const ZERO_STRUCTS g_Zero = {0};


//+---------------------------------------------------------------------------
//
//  Function:   ConnectSink
//
//  Synopsis:   Connects a sink to an object which fires to the sink through
//              a connection point.
//
//  Arguments:  [pUnkSource] -- The source object.
//              [iid]        -- The id of the connection point.
//              [pUnkSink]   -- The sink.
//              [pdwCookie]  -- Cookie that identifies the connection for
//                                  a later disconnect.  May be NULL.
//
//----------------------------------------------------------------------------

HRESULT
ConnectSink(
        IUnknown *  pUnkSource,
        REFIID      iid,
        IUnknown *  pUnkSink,
        DWORD *     pdwCookie)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC;

    Assert(pUnkSource);
    Assert(pUnkSink);

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        RRETURN(hr);

    hr = THR(ConnectSinkWithCPC(pCPC, iid, pUnkSink, pdwCookie));
    pCPC->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ConnectSinkWithCPC
//
//  Synopsis:   Connects a sink to an object which fires to the sink through
//              a connection point.
//
//  Arguments:  [pCPC]       -- The source object as an
//                                  IConnectionPointContainer.
//
//              [iid]        -- The id of the connection point.
//              [pUnkSink]   -- The sink.
//              [pdwCookie]  -- Cookie that identifies the connection for
//                                  a later disconnect.  May be NULL.
//
//----------------------------------------------------------------------------

HRESULT
ConnectSinkWithCPC(
        IConnectionPointContainer * pCPC,
        REFIID                      iid,
        IUnknown *                  pUnkSink,
        DWORD *                     pdwCookie)
{
    HRESULT             hr;
    IConnectionPoint *  pCP;
    DWORD               dwCookie;

    Assert(pCPC);
    Assert(pUnkSink);

    hr = ClampITFResult(THR_NOTRACE(pCPC->FindConnectionPoint(iid, &pCP)));
    if (hr)
        RRETURN1(hr, E_NOINTERFACE);

    if (!pdwCookie)
    {
        //
        // The CDK erroneously fails to handle a NULL cookie, so
        // we pass in a dummy one.
        //

        pdwCookie = &dwCookie;
    }

    hr = ClampITFResult(THR(pCP->Advise(pUnkSink, pdwCookie)));
    pCP->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   DisconnectSink
//
//  Synopsis:   Disconnects a sink from a source.
//
//  Arguments:  [pUnkSource] -- The source object.
//              [iid]        -- The id of the connection point.
//              [pdwCookie]  -- Pointer to the cookie which identifies the
//                                  connection.
//
//  Modifies:   [*pdwCookie] - sets to 0 if disconnect is successful.
//
//----------------------------------------------------------------------------

HRESULT
DisconnectSink(
        IUnknown *  pUnkSource,
        REFIID      iid,
        DWORD *     pdwCookie)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC    = NULL;
    IConnectionPoint *          pCP     = NULL;
    DWORD                       dwCookie;

    Assert(pUnkSource);
    Assert(pdwCookie);

    if (!*pdwCookie)
        return S_OK;

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        goto Cleanup;

    hr = ClampITFResult(THR(pCPC->FindConnectionPoint(iid, &pCP)));
    if (hr)
        goto Cleanup;

    //
    // Allow clients to use *pdwCookie as an indicator of whether
    // or not they are advised by setting it to zero before
    // calling Unadvise.  This prevents recursion in some
    // scenarios.
    //

    dwCookie = *pdwCookie;
    *pdwCookie = NULL;
    hr = ClampITFResult(THR(pCP->Unadvise(dwCookie)));
    if (hr)
    {
        *pdwCookie = dwCookie;
    }

Cleanup:
    ReleaseInterface(pCP);
    ReleaseInterface(pCPC);

    RRETURN(hr);
}



//
// Remove the #ifdev when this function is actually used.
//

#ifdef NEVER

//+---------------------------------------------------------------------------
//
//  Function:   DisconnectSinkWithoutCookie
//
//  Synopsis:   Disconnects a sink from a connection point without
//              using a cookie.
//
//  Arguments:  [pUnkSource] -- The connection point container.
//              [iid]        -- The IID of the connection point.
//
//----------------------------------------------------------------------------

HRESULT
DisconnectSinkWithoutCookie(
        IUnknown *  pUnkSource,
        REFIID      iid,
        IUnknown *  pUnkConnection)
{
    HRESULT                     hr;
    IConnectionPointContainer * pCPC    = NULL;
    IConnectionPoint *          pCP     = NULL;
    IEnumConnections *          pEC     = NULL;
    CONNECTDATA                 cd;

    Assert(pUnkSource);

    //
    // Find the connection point.
    //

    hr = THR(pUnkSource->QueryInterface(
            IID_IConnectionPointContainer, (void **) &pCPC));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pCPC->FindConnectionPoint(iid, &pCP));
    if (hr)
        goto Cleanup;

    //
    // Find this connection.
    //

    hr = ClampITFResult(THR(pCP->EnumConnections(&pEC)));
    if (hr)
        goto Cleanup;

    while ((hr = THR_NOTRACE(pEC->Next(1, &cd, NULL))) == S_OK)
    {
        cd.pUnk->Release();
        if (cd.pUnk == pUnkConnection)
            break;
    }

    if (hr)
    {
        if (hr == S_FALSE)
            hr = E_FAIL;

        goto Cleanup;
    }

    // Disconnect.
    hr = ClampITFResult(THR(pCP->Unadvise(cd.dwCookie)));

Cleanup:
    ReleaseInterface(pEC);
    ReleaseInterface(pCP);
    ReleaseInterface(pCPC);

    RRETURN(hr);
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   GetDefaultDispatchTypeInfo
//
//  Synopsis:   Gets a default typeinfo of a coclass.
//
//  Arguments:  [pPCI]    -- Object containing coclass typeinfo.
//              [fSource] -- Is interface a source?
//              [ppTI]    -- Resulting typeinfo.
//
//  Returns:    HRESULT.
//
//  Modifies:   [ppTI].
//
//----------------------------------------------------------------------------

HRESULT
GetDefaultDispatchTypeInfo(IProvideClassInfo * pPCI,  BOOL fSource, ITypeInfo ** ppTI)
{
    HRESULT     hr;
    ITypeInfo * pTI = NULL;
    TYPEATTR *  pTA = NULL;
    WORD        w;
    int         implTypeFlags;
    HREFTYPE    hrt;
    ITypeInfo * pTIRef;
    TYPEATTR *  pTARef;
    int         implTypeFlagsDesired;

    Assert(pPCI);
    Assert(ppTI);

    *ppTI = NULL;
    hr = THR(pPCI->GetClassInfo(&pTI));
    if (hr)
        goto Cleanup;

    hr = THR(pTI->GetTypeAttr(&pTA));
    if (hr)
        goto Cleanup;

    if (pTA->typekind != TKIND_COCLASS)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    implTypeFlagsDesired = IMPLTYPEFLAG_FDEFAULT;
    if (fSource)
    {
        implTypeFlagsDesired |= IMPLTYPEFLAG_FSOURCE;
    }

    for (w = 0; !hr && w < pTA->cImplTypes; w++)
    {
        pTIRef = NULL;
        pTARef = NULL;

        hr = THR(pTI->GetImplTypeFlags(w, &implTypeFlags));
        if (hr)
            goto LoopCleanup;

        if (implTypeFlags != implTypeFlagsDesired)
            goto LoopCleanup;

        hr = THR(pTI->GetRefTypeOfImplType(w, &hrt));
        if (hr)
            goto LoopCleanup;

        hr = THR(pTI->GetRefTypeInfo(hrt, &pTIRef));
        if (hr)
            goto LoopCleanup;

        hr = THR(pTIRef->GetTypeAttr(&pTARef));
        if (hr)
            goto LoopCleanup;

        if (pTARef->typekind & TKIND_DISPATCH)
        {
            pTIRef->ReleaseTypeAttr(pTARef);
            *ppTI = pTIRef;
            goto Cleanup;
        }

LoopCleanup:
        if (pTARef)
            pTIRef->ReleaseTypeAttr(pTARef);
        ReleaseInterface(pTIRef);
    }

    hr = E_UNEXPECTED;

Cleanup:
    if (pTA)
        pTI->ReleaseTypeAttr(pTA);

    ReleaseInterface(pTI);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\cstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.CXX
//
// Contents     Class implementation for length prefix string class
//
// Classes      CStr
//
// Maintained by Istvanc
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

MtDefine(CStr, Mem, "CStr")
MtDefine(CStr_pch, CStr, "CStr::_pch")
MtDefine(CStrGetAltStr, Utilities, "CStr::GetAltStr *ppch")

#ifdef _MAC
#   define MACONLYSIZEOFPTR     sizeof(BSTR *)
#   define INITMACONLYPTR(p)    *(BSTR *)p = 0

#else
#   define MACONLYSIZEOFPTR     0
#   define INITMACONLYPTR(p)
#endif
//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates memory for a string and initializes it from a given
//              string.
//
//  Arguments:  [pch] -- String to initialize with. Can be NULL
//              [uc]  -- Number of characters to allocate.
//
//  Returns:    HRESULT
//
//  Notes:      The total number of characters allocated is uc+1, to allow
//              for a NULL terminator. If [pch] is NULL, then the string is
//              uninitialized except for the NULL terminator, which is at
//              character position [uc].
//
//  Mac note:   The total number of characters allocated is increased by the
//              size of a pointer.  This pointer, located prior to the length
//              field, will point to a memory allocation that contains the
//              CHAR or WCHAR string alternative to the _pch string.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch, UINT uc)
{
    if (pch == _pch)
	{
        if (uc == Length())
			return S_OK;
        // when the ptrs are the same the length can only be
        // different if the ptrs are NULL.  this is a hack used
        // internally to implement realloc type expansion
        Assert(pch == NULL && _pch == NULL);
	}

    Free();

    BYTE * p = new(Mt(CStr_pch)) BYTE [sizeof(TCHAR) + sizeof(TCHAR) * uc + sizeof(UINT) + MACONLYSIZEOFPTR];
    if (p)
    {
        MemSetName((p, "CStr text"));

        INITMACONLYPTR(p);
        *(UINT *)(p + MACONLYSIZEOFPTR)  = uc * sizeof(TCHAR);
        _pch = (TCHAR *)(p + sizeof(UINT) + MACONLYSIZEOFPTR);
        if (pch)
        {
            _tcsncpy(_pch, pch, uc);
        }

        ((TCHAR *)_pch) [uc] = 0;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [pch] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch)
{
    RRETURN(Set(pch, pch ? _tcsclen(pch) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [cstr] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(const CStr &cstr)
{
    RRETURN(Set(cstr, cstr.Length()));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::TakeOwnership, public
//
//  Synopsis:   Takes the ownership of a string from another CStr class.
//
//  Arguments:  [cstr] -- Class to take string from
//
//  Notes:      This method just transfers a string from one CStr class to
//              another. The class which is the source of the transfer has
//              a NULL value at the end of the operation.
//
//----------------------------------------------------------------------------

void
CStr::TakeOwnership(CStr &cstr)
{
    _Free();
    _pch = cstr._pch;
    cstr._pch = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetBSTR, public
//
//  Synopsis:   Allocates a string and initializes it from a BSTR
//
//  Arguments:  [bstr] -- Initialization string
//
//  Notes:      This method is more efficient than Set(LPCWSTR pch) because
//              of the length-prefix on BSTRs.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetBSTR(const BSTR bstr)
{
    RRETURN(Set(bstr, bstr ? SysStringLen(bstr) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Length, public
//
//  Synopsis:   Returns the length of the string associated with this class
//
//----------------------------------------------------------------------------

UINT
CStr::Length() const
{
    if (_pch)
        return (((UINT *)_pch) [-1]) / sizeof(TCHAR);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAlloc, public
//
//  Synopsis:   Reallocate the string to a different size buffer.
//              The length of the string is not affected, but it is allocated
//              within a larger (or maybe smaller) memory allocation.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAlloc( UINT uc )
{
    HRESULT hr;
    TCHAR * pchOld;
    UINT    ubOld;

    Assert(uc >= Length());  // Disallowed to allocate a too-short buffer.

    if (uc)
    {
        pchOld = _pch;      // Save pointer to old string.
        _pch = 0;           // Prevent Set from Freeing the string.
        ubOld = pchOld ?    // Save old length
                    *(UINT *) (((BYTE *)pchOld) - sizeof(UINT))
                  : 0;

        hr = Set(pchOld, uc);                   // Alloc new; Copy old string.
        if (hr)
        {
            _pch = pchOld;
            RRETURN(hr);
        }
        *(UINT *)(((BYTE *)_pch) - sizeof(UINT)) = ubOld; // Restore length.

        if (pchOld )
        {
            delete [] (((BYTE *)pchOld) - sizeof(UINT) - MACONLYSIZEOFPTR);
        }
    }

    // else if uc == 0, then, since we have already checked that uc >= Length,
    // length must == 0.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Append
//
//  Synopsis:   Append chars to the end of the string, reallocating & updating
//              its length.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Append(LPCTSTR pch, UINT uc)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew;
    BYTE *p;

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;
        _tcsncpy(_pch + ucOld, pch, uc);
        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CStr::Append(LPCTSTR pch)
{
    RRETURN(Append(pch, pch ? _tcsclen(pch) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetLengthNoAlloc, public
//
//  Synopsis:   Sets the internal length of the string. Note.  There is no
//              verification that the length that is set is within the allocated
//              range of the string. If the caller sets the length too large,
//              this blasts a null byte into memory.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetLengthNoAlloc( UINT uc )
{
    if (_pch)
    {
        BYTE * p = ( (BYTE *)_pch - sizeof(UINT));
        *(UINT *)p = uc * sizeof(TCHAR);    // Set the length prefix.
        ((TCHAR *)_pch) [uc] = 0;           // Set null terminator
        return S_OK;
    }
    else 
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. This pointer should not
//                         be pointing to an existing BSTR.
//
//
//  Mac note:   Mac BSTRs are ANSI so we need to convert before allocating the
//              BSTR.
//----------------------------------------------------------------------------

HRESULT
CStr::AllocBSTR(BSTR *pBSTR) const
{
    if (!_pch)
    {
        *pBSTR = 0;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(*this, Length());
    RRETURN(*pBSTR ? S_OK: E_OUTOFMEMORY);
}

/*
//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class. Any existing BSTR pointed to by
//              [pBSTR] is freed.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. Can be pointing to another
//                         BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAllocBSTR(BSTR *pBSTR)
{
    BSTR bstrTemp;

    Assert(pBSTR);

    HRESULT hr = AllocBSTR(&bstrTemp);
    if (!hr)
    {
        SysFreeString(*pBSTR);
        *pBSTR = bstrTemp;
    }
    RRETURN(hr);
}
*/

//+---------------------------------------------------------------------------
//
//  Member:     CStr::TrimTrailingWhitespace, public
//
//  Synopsis:   Removes any trailing whitespace in the string that is
//              associated with this class.
//
//  Arguments:  None.
//
//----------------------------------------------------------------------------

HRESULT CStr::TrimTrailingWhitespace()
{
    if (!_pch)
    	return S_OK;

    UINT ucNewLength = Length();

    for ( ; ucNewLength > 0; ucNewLength-- )
    {
        if ( !_istspace( ((TCHAR *)_pch)[ ucNewLength - 1 ] ) )
            break;
        ((TCHAR *)_pch)[ ucNewLength - 1 ] = (TCHAR) 0;
    }

    BYTE *p = ((BYTE*)_pch - sizeof(UINT));
    *(UINT *)p = ucNewLength * sizeof(TCHAR);
	return S_OK;
}

#ifdef _MAC
//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetAltStr
//
//  Synopsis:   Creates and returns ANSI version of string as a bstr
//
//  Mac note:   We save the pointer in the reserved space prior to the length
//              field.
//
//  Usage note: BEWARE - A second call to GetAltStr destroys the first call's
//                       returned LPSTR, so don't do this:
//                         foo(aStr.GetAltStr(),aStr.GetAltStr());
//----------------------------------------------------------------------------
LPSTR
CStr::GetAltStr()
{
    int     cchBufReq;
    LPSTR    pStr;
    LPSTR   *pach;

    if(NULL==_pch)
        return NULL;
    pach = (LPSTR*)((LPBYTE)_pch - sizeof(UINT) - MACONLYSIZEOFPTR);
    if(*pach)
    {
        delete [] (*pach - sizeof(UINT));
        *pach=0;
    }
    cchBufReq = Length() + sizeof(CHAR);
    // create a new pStr
    pStr = new(Mt(CStrGetAltStr)) CHAR[ cchBufReq + sizeof(UINT)];
    if(NULL != pStr)
    {
        // pretend we are a BSTR
        *(UINT *)pStr = cchBufReq;
        pStr += sizeof(LPSTR);
        // and fill 'er up

        cchBufReq = WideCharToMultiByte(
                        CP_ACP, 0, _pch, Length(), pStr, cchBufReq, NULL, NULL);
        // guarantee null term
        pStr[cchBufReq] = '\0';
    }
    *pach = pStr;
    return *pach;

}
#endif //#ifdef _MAC

//+---------------------------------------------------------------------------
//
//  Member:     CStr::_Free, private
//
//  Synopsis:   Frees any memory held onto by this class.
//
//----------------------------------------------------------------------------

void
CStr::_Free()
{
    if (_pch )
    {
#ifdef _MAC
        LPSTR *pach = (LPSTR*)(((LPBYTE)_pch) - sizeof(UINT) - MACONLYSIZEOFPTR);

        if (*pach)
        {
            delete [] (*pach - sizeof(UINT));
            *pach=0;
        }
#endif
        delete [] (((BYTE *)_pch) - sizeof(UINT) - MACONLYSIZEOFPTR);
    }
    _pch=0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Clone
//
//  Synopsis:   Make copy of current string
//
//----------------------------------------------------------------------------
HRESULT
CStr::Clone(CStr **ppCStr) const
{
    HRESULT hr;
    Assert(ppCStr);
    *ppCStr = new CStr;
    hr = *ppCStr?S_OK:E_OUTOFMEMORY;
    if (hr)
        goto Cleanup;
    MemSetName((*ppCStr, "Cloned CStr:%s", MemGetName(*this)));

    hr = THR( (*ppCStr)->Set(*this) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Compare
//
//  Synopsis:   Case insensitive comparison of 2 strings
//
//----------------------------------------------------------------------------
BOOL
CStr::Compare (const CStr *pCStr) const
{
    return (!_tcsicmp(*pCStr, *this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ComputeCrc
//
//  Synopsis:   Computes a hash of the string.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4305)
WORD
CStr::ComputeCrc() const
{
    WORD wHash=0;
    const TCHAR* pch;
    int i;

    pch=*this;
    for(i = Length();i > 0;i--, pch++)
    {
        wHash = wHash << 7 ^ wHash >> (16-7) ^ (TCHAR)CharUpper((LPTSTR)((DWORD_PTR)(*pch)));
    }

    return wHash;
}
#pragma warning(default:4305)

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Load
//
//  Synopsis:   Initializes the CStr from a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Load(IStream * pstm)
{
    DWORD cch;
    HRESULT hr;

    hr = THR(pstm->Read(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch == 0xFFFFFFFF)
    {
        Free();
    }
    else
    {
        hr = THR(Set(NULL, cch));
        if (hr)
            goto Cleanup;

        if (cch)
        {
            hr = THR(pstm->Read(_pch, cch * sizeof(TCHAR), NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Save
//
//  Synopsis:   Writes the contents of the CStr to a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Save(IStream * pstm) const
{
    DWORD   cch = _pch ? Length() : 0xFFFFFFFF;
    HRESULT hr;

    hr = THR(pstm->Write(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch && cch != 0xFFFFFFFF)
    {
        hr = THR(pstm->Write(_pch, cch * sizeof(TCHAR), NULL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetSaveSize
//
//  Synopsis:   Returns the number of bytes which will be written by
//              CStr::Save
//
//----------------------------------------------------------------------------
ULONG
CStr::GetSaveSize() const
{
    return(sizeof(DWORD) + (_pch ? (Length() * sizeof(TCHAR)) : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\datastm.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       datastm.cxx
//
//  Contents:   CDataStream IStream wrapper
//
//  History:    04-22-1997   DBau (David Bau)    Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DATASTM_HXX_
#define X_DATASTM_HXX_
#include "datastm.hxx"
#endif

#ifndef X_SUBSTM_HXX_
#define X_SUBSTM_HXX_
#include "substm.hxx"
#endif

DeclareTag(tagDataStream, "DataStream", "DataStream methods")
MtDefine(CDataStream, Utilities, "CDataStream")
MtDefine(CDataStream_aryLocations_pv, CDataStream, "CDataStream::_aryLocations::_pv")

// String lengths are written twice, once xor'ed with a cookie, in order to
// lower the probability that we read a huge length and run out of
// memory when the read stream doesn't match the written stream.

#define DWORD_STRING_COOKIE (0xABACADAB)
#define DWORD_CSTR_COOKIE   (0xC0FFEE25)


//+------------------------------------------------------------------------
//
//  Class:      CDataStream
//
//              For robust and convenient saving and loading on a stream.
//
//              SaveData/LoadData - persists a block of bytes of known size;
//                          unlike IStream::Read, CDataStream::LoadData never
//                          succeeds on a partial read.
//
//              SaveDataNow/SaveDataLater - like SaveData, but used to save
//                          out of order. SaveDataLater reserves a position in
//                          the stream, and SaveDataNow writes the data into
//                          a reserved position.
//
//              SaveString/LoadString - for saving and loading a null-
//                          terminated, MemAlloc'ed unicode string.
//
//              SaveCStr/LoadCStr - for saving and loading a CStr.
//
//              BeginSaveSubstream/EndSaveSubstream - creates a
//                          substream of the main stream for writing;
//                          (the substream correctly handles things like
//                          setsize, stat, and seek)
//                          After writing is finished, EndSaveSubstream
//                          detaches the substream from the main stream
//                          and saves the stream length.
//                          The substream must be released after use.
//
//              LoadSubstream - creates a read-only substream (a clone)
//                          which has the data previously saved by
//                          *SaveSubstream.
//                          The substream must be released after use.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveData
//
//  Synopsis:   Wrapper for IStream::Write
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveData(void *pv, ULONG cb)
{
    HRESULT hr;
    ULONG cbWritten;
    
    Assert(pv);
    Assert(!_pSubstream); // Cannot save data in the middle of a substream operation

    //
    // NOTE (lmollico) - for some reason on NT5 we are getting
    // here and _pStream is equal to 1, which is bad. This is IE5 b1 bug
    // #23145
    //
    if (!_pStream)
        return E_FAIL;

    hr = THR(_pStream->Write(pv, cb, &cbWritten));
    if (hr)
        RRETURN(hr);

    if (cb != cbWritten)
    {
        Assert(0); // malformed stream
        return E_FAIL;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveDataLater
//
//  Synopsis:   Encapsulates the work of seeking back and
//              forth to save data.
//
//              NOTE: convenient, but not particularly efficient
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveDataLater(DWORD *pdwCookie, ULONG cb)
{
    HRESULT hr;
    LARGEINT ib;
    CLocation loc;
    
    Assert(pdwCookie);
    Assert(!_pSubstream);

    hr = THR(_aryLocations.EnsureSize(_aryLocations.Size()+1));
    if (hr)
        goto Cleanup;

    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &loc._ib.uli));
    if (hr)
        goto Cleanup;

    loc._cb = cb;
    loc._dwCookie = _aryLocations.Size() ? _aryLocations[_aryLocations.Size()-1]._dwCookie+1 : 0;

    *pdwCookie = loc._dwCookie;
    
    Verify(!_aryLocations.AppendIndirect(&loc));

    ib.i64 = cb;
    hr = THR(_pStream->Seek(ib.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveDataNow
//
//  Synopsis:   Wrapper for IStream::Write
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveDataNow(DWORD dwCookie, void *pv, ULONG cb)
{
    HRESULT hr = E_FAIL;
    LARGEINT ibCur;
    int c;

    Assert(pv);
    
    for (c = _aryLocations.Size(); c;)
    {
        c--;
        if (_aryLocations[c]._dwCookie == dwCookie)
        {
            hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ibCur.uli));
            if (hr)
                goto Cleanup;
                
            hr = THR(_pStream->Seek(_aryLocations[c]._ib.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;
                
            Assert(_aryLocations[c]._cb == cb);
            _aryLocations.Delete(c);

            hr = THR(SaveData(pv, cb));
            if (hr)
                goto Cleanup;
                
            hr = THR(_pStream->Seek(ibCur.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;
                
            return S_OK;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadData
//
//  Synopsis:   Wrapper for IStream::Read. Fails rather than
//              reading an incomplete chunk of data.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadData(void *pv, ULONG cb)
{
    HRESULT hr;
    ULONG cbRead;

    Assert(pv);

    hr = THR(_pStream->Read(pv, cb, &cbRead));
    if (hr)
        RRETURN(hr);

    if (cb != cbRead)
    {
        return E_FAIL;
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SeekData
//
//  Synopsis:   Wrapper for IStream::Seek. 
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekData( ULONG cb)
{
    HRESULT hr;
    LARGE_INTEGER   li;
    li.LowPart  = cb;
    li.HighPart = 0;
    
    hr = THR(_pStream->Seek( li, STREAM_SEEK_CUR, NULL )); 
    if (hr)
        RRETURN(hr);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveString
//
//  Synopsis:   Saves a null-terminated string by prefixing
//              the length in the stream
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveString(TCHAR *pch)
{
    HRESULT hr;
    ULONG len;

    len = pch ? _tcslen(pch) : (DWORD)(-1);

    hr = THR(SaveDword(DWORD_STRING_COOKIE ^ len));
    if (hr)
        goto Cleanup;

    hr = THR(SaveDword(len));
    if (hr)
        goto Cleanup;

    if (pch)
    {
        hr = THR(SaveData(pch, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadString
//
//  Synopsis:   Loads and allocates a null-terminated string
//              that was previously saved by SaveString
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekString()
{
    HRESULT hr;
    ULONG len;
    DWORD dwCode;

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_STRING_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(SeekData( sizeof(TCHAR) * len));
    if (hr)
        goto Cleanup;


Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadString
//
//  Synopsis:   Loads and allocates a null-terminated string
//              that was previously saved by SaveString
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadString(TCHAR **ppch)
{
    HRESULT hr;
    ULONG len;
    DWORD dwCode;

    Assert(ppch);

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_STRING_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(MemRealloc(Mt(CDataStream), (void**)ppch, sizeof(TCHAR)*(len + 1)));
    if (hr)
        goto Cleanup;

    if (*ppch)
    {
        hr = THR(LoadData(*ppch, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;

        (*ppch)[len] = _T('\0');
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SaveCStr
//
//  Synopsis:   Saves a CStr into the stream
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SaveCStr(const CStr *pcstr)
{
    HRESULT hr;
    ULONG len;

    len = *pcstr ? pcstr->Length() : (DWORD)(-1);

    hr = THR(SaveDword(DWORD_CSTR_COOKIE ^ len));
    if (hr)
        goto Cleanup;

    hr = THR(SaveDword(len));
    if (hr)
        goto Cleanup;

    if (*pcstr)
    {
        hr = THR(SaveData(*pcstr, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadCStr
//
//  Synopsis:   Loads a CStr previously saved by SaveCStr
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadCStr(CStr *pcstr)
{
    HRESULT hr;
    ULONG len;
    ULONG dwCode;

    Assert(pcstr);

    hr = THR(LoadDword(&dwCode));
    if (hr)
        goto Cleanup;

    hr = THR(LoadDword(&len));
    if (hr)
        goto Cleanup;

    if ((len ^ dwCode) != DWORD_CSTR_COOKIE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (len == (DWORD)-1)
    {
        pcstr->Free();
    }
    else
    {
        pcstr->Set(NULL, len);
        
        hr = THR(LoadData(*pcstr, sizeof(TCHAR) * len));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::BeginSaveSubstream
//
//  Synopsis:   Returns a new sub-IStream into which arbitrary
//              data can be saved immediately. Once writes
//              into the substream are completed,
//              EndSaveSubstream must be called.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::BeginSaveSubstream(IStream **ppSubstream)
{
    HRESULT hr;
    
    Assert(!_pSubstream);

    hr = THR(SaveDataLater(&_dwLengthCookie, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;

    hr = THR(CreateWritableSubstream(&_pSubstream, _pStream));
    if (hr) 
        goto Cleanup;

    _pSubstream->AddRef();
    *ppSubstream = _pSubstream;
        
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::EndSaveSubstream
//
//  Synopsis:   Completes the write of a substream into the
//              main stream (the length of the substream is
//              prefixed).
//
//-------------------------------------------------------------------------
HRESULT CDataStream::EndSaveSubstream()
{
    HRESULT hr;
    LARGEINT cb;
    
    Assert(_pSubstream);

    // Ask substream to seek to its end
    hr = THR(_pSubstream->Seek(LI_ZERO.li, STREAM_SEEK_END, &cb.uli));
    if (hr)
        goto Cleanup;

    _pSubstream->Detach(); // Ensure no further writes
    ClearInterface(&_pSubstream);
    
    // Save length
    hr = THR(SaveDataNow(_dwLengthCookie, &cb, sizeof(LARGEINT)));
    if (hr) 
        goto Cleanup;
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::LoadSubstream
//
//  Synopsis:   Returns a new substream out of which arbitrary
//              data can be read at any time.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::LoadSubstream(IStream **pStreamOut)
{
    LARGEINT cb;
    CSubstream *psubstream = NULL;
    HRESULT hr;
    
    hr = THR(LoadData(&cb, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;

    hr = THR(CreateReadOnlySubstream(&psubstream, _pStream, cb.uli));
    if (hr)
        goto Cleanup;

    hr = THR(_pStream->Seek(cb.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

    *pStreamOut = psubstream;
    psubstream = NULL;

Cleanup:
    delete psubstream;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDataStream::SeekSubstream
//
//  Synopsis:   Seek over a sub-stream.
//
//-------------------------------------------------------------------------
HRESULT CDataStream::SeekSubstream()
{
    LARGEINT cb;
    HRESULT hr;
    
    hr = THR(LoadData(&cb, sizeof(LARGEINT)));
    if (hr)
        goto Cleanup;


    hr = THR(_pStream->Seek(cb.li, STREAM_SEEK_CUR, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDataStream::DumpStreamInfo
//
//  Synopsis:   Dump stream information for debugging
//
//-------------------------------------------------------------------------

#if (DBG == 1)

void CDataStream::DumpStreamInfo()
{
    HRESULT     hr;
    LARGEINT    ib;
    STATSTG     stat = { 0 };
    BYTE      * pBytes = NULL;
    BOOL        fHaveCurrent = FALSE;

    IGNORE_HR(_pStream->Stat(&stat, 0));

    TraceTag((tagDataStream, "Dumping Stream at 0x%x", _pStream));
    TraceTag((tagDataStream, "    pwcsName=%ws", stat.pwcsName ? stat.pwcsName : L"<no name>"));
    TraceTag((tagDataStream, "    cbSize(LowPart)=0x%x, cbSize(HighPart)=0x%x", 
                    stat.cbSize.LowPart, stat.cbSize.HighPart));

    if (stat.pwcsName)
        CoTaskMemFree(stat.pwcsName);
    
    // Get the current position of the stream into ib
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_CUR, &ib.uli));
    if (hr)
        goto Cleanup;
    fHaveCurrent = TRUE;

    // Reset the stream to the beginning
    hr = THR(_pStream->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    // TOdO: use the metered memory functions.
    pBytes = (BYTE *) LocalAlloc(LPTR, stat.cbSize.LowPart);
    if (!pBytes)
        goto Cleanup;

    hr = THR(_pStream->Read(pBytes, stat.cbSize.LowPart, NULL));
    if (hr)
        goto Cleanup;

    TraceTag((tagDataStream, "    Data at start of stream: >>>%.80s<<<", pBytes));

    TraceTag((tagDataStream, "    Data at end of stream: >>>%.80s<<<", 
        max(pBytes + stat.cbSize.LowPart - 80, pBytes)));

Cleanup:
    // Restore the position of the stream
    if (fHaveCurrent)
        _pStream->Seek(ib.li, STREAM_SEEK_SET, NULL);

    if (pBytes)
        LocalFree(pBytes);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\disputl2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsputil2.cxx
//
//  Contents:   More dispatch utilities.
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

DeclareTag(tagLoadTypeInfo, "TypeInfo", "Trace typeinfo load")
MtDefine(LoadTypeLib, PerfPigs, "Loading type-library MSHTML.TLB")

//+----------------------------------------------------------------------------
//
//  Member:     GetTypeInfoFromCoClass
//
//  Synopsis:   Return either the default dispinterface or default source
//              interface ITypeInfo from a coclass
//
//  Arguments:  pTICoClass - ITypeInfo for containing coclass
//              fSource    - Return either source (TRUE) or default (FALSE) interface
//              ppTI       - Location at which to return the interface (may be NULL)
//              piid       - Location at which to return ther interface IID (may be NULL)
//
//  Returns:    S_OK, E_xxxx
//
//-----------------------------------------------------------------------------
HRESULT
GetTypeInfoFromCoClass(
    ITypeInfo *     pTICoClass,
    BOOL            fSource,
    ITypeInfo **    ppTI,
    IID *           piid)
{
    ITypeInfo * pTI = NULL;
    TYPEATTR *  pTACoClass = NULL;
    TYPEATTR *  pTA = NULL;
    IID         iid;
    HREFTYPE    href;
    int         i;
    int         flags;
    HRESULT     hr;

    Assert(pTICoClass);

    if (!ppTI)
        ppTI = &pTI;
    if (!piid)
        piid = &iid;

    *ppTI = NULL;
    *piid = IID_NULL;

    hr = THR(pTICoClass->GetTypeAttr(&pTACoClass));
    if (hr)
        goto Cleanup;
    Assert(pTACoClass->typekind == TKIND_COCLASS);

    for (i = 0; i < pTACoClass->cImplTypes; i++)
    {
        hr = THR(pTICoClass->GetImplTypeFlags(i, &flags));
        if (hr)
            goto Cleanup;

        if ((flags & IMPLTYPEFLAG_FDEFAULT) &&
            ((fSource && (flags & IMPLTYPEFLAG_FSOURCE)) ||
             (!fSource && !(flags & IMPLTYPEFLAG_FSOURCE))))
        {
            hr = THR(pTICoClass->GetRefTypeOfImplType(i, &href));
            if (hr)
                goto Cleanup;

            hr = THR(pTICoClass->GetRefTypeInfo(href, ppTI));
            if (hr)
                goto Cleanup;

            hr = THR((*ppTI)->GetTypeAttr(&pTA));
            if (hr)
                goto Cleanup;

            *piid = pTA->guid;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:
    if (pTA)
    {
        Assert(*ppTI);
        (*ppTI)->ReleaseTypeAttr(pTA);
    }
    ReleaseInterface(pTI);
    if (pTACoClass)
    {
        Assert(pTICoClass);
        pTICoClass->ReleaseTypeAttr(pTACoClass);
    }
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//  
//  Function:   GetFormsTypeLibPath
//  
//  Synopsis:   Returns the path to a forms type library, either the
//              raw unadorned type library or the special merged
//              version, depending on dwFlags.
//  
//  Arguments:  [ach]       
//  
//  Returns:    HRESULT
//  
//-------------------------------------------------------------------------

void
GetFormsTypeLibPath(TCHAR * ach)
{
    _tcscpy(ach, g_achDLLCore);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetFormsTypeLib
//
//  Synopsis:   Get cached Forms3 type library.
//
//              Note: Not only does it seem like a good idea to
//              to cache the type library, it gets around a suspected
//              bug in LoadTypeLib.  I (garybu) have observed LoadTypeLib
//              returning a bogus object when called repeatedly.
//
//  Arguments:  ppTL        The type library
//              fNoCache    Don't cache the library
//
//----------------------------------------------------------------------------

HRESULT
GetFormsTypeLib(ITypeLib **ppTL, BOOL fNoCache)
{
    THREADSTATE *   pts;
    HRESULT         hr;
    TCHAR           ach[MAX_PATH];
    TCHAR *         pchName;

    pts = GetThreadState();

    if (pts->pTLCache)
    {
        *ppTL = pts->pTLCache;
        (*ppTL)->AddRef();
        return S_OK;
    }

    TraceTag((tagPerf, "Loading Trident Type Library."));

    //TODO (carled) again the crt library shutdown causes oleaut32 to leak memory
    // which is allocated on the very first call to GetFormsTypeLibPath. Remove this 
    // block once the crt libraries are no longer linked in.

    DbgMemoryTrackDisable(TRUE);

    GetFormsTypeLibPath(ach);
#ifndef UNIX // UNIX can use the dll name to find out thd tlb file.
    pchName = _tcsrchr(ach, '.');
    Assert(pchName);
    _tcscpy(pchName + 1, _T("tlb"));
#endif
    hr = THR(LoadTypeLib(ach, ppTL));

    DbgMemoryTrackDisable(FALSE);

    if (hr)
        goto Cleanup;

    MtAdd(Mt(LoadTypeLib), +1, 0);

    // Cache the library if requested and if our DllThreadPassivate will
    // execute (since it is through DllThreadPassivate the library is released)
    // (Some code, such as class initialization code, may load the type library
    //  before any objects have been created)
    if (!fNoCache && GetPrimaryObjectCount())
    {
        pts->pTLCache = *ppTL;
        (*ppTL)->AddRef();
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   DeinitTypeLibCache
//
//  Synopsis:   Release the forms type lib cache.
//
//----------------------------------------------------------------------------

void
DeinitTypeLibCache(THREADSTATE *pts)
{
    Assert(pts);
    ClearInterface(&pts->pTLCache);

    // There is a known bug in NT 4.0 versions prior to Service Pack 3
    // (build 1381) with freeing the typelib for OLEAUT.  We purposely leak
    // the typelib in this case.

    extern DWORD g_dwPlatformServicePack;

    if (    g_dwPlatformID != VER_PLATFORM_WIN32_NT
        ||  HIWORD(g_dwPlatformVersion) != 4
        ||  LOWORD(g_dwPlatformVersion) != 0
        ||  g_dwPlatformServicePack >= 3)
    {
        // release these here although created in a different path
        ClearInterface(&pts->pTypInfoStdOLECache);
        ClearInterface(&pts->pTypLibStdOLECache);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Function    :   ReadyStateInvoke
//
//  Synopsis    :   This helper function is called by the various invokes for 
//      those classes that support the ready state property. this centralizes the
//      logic and code for handling this case.
//
//  RETURNS :   S_OK,           readyState-get and no errors
//              E_INVALIDARG    readystate-get and errors
//              S_FALSE         not readystate-get
//
//-----------------------------------------------------------------------------

HRESULT
ReadyStateInvoke(DISPID dispid, 
                 WORD wFlags, 
                 long lReadyState, 
                 VARIANT * pvarResult)
{
    HRESULT hr = S_FALSE;

    if (dispid == DISPID_READYSTATE )
    {
        if (pvarResult && (wFlags & DISPATCH_PROPERTYGET))
        {
            V_VT(pvarResult) = VT_I4;
            V_I4(pvarResult) = lReadyState;
            hr =  S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetTypeInfo
//
//  Synopsis:   GetTypeInfo helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetTypeInfo(REFIID riid, UINT itinfo, LCID lcid, ITypeInfo ** ppTI)
{
    HRESULT hr;

    Assert(ppTI);
    *ppTI = NULL;
    if (itinfo > 0)
        RRETURN(DISP_E_BADINDEX);

    hr = THR_NOTRACE(LoadF3TypeInfo(riid, ppTI));
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetTypeInfoCount
//
//  Synopsis:   GetTypeInfoCount helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DispatchGetIDsOfNames
//
//  Synopsis:   GetIDsOfNames helper.
//
//--------------------------------------------------------------------------

HRESULT
DispatchGetIDsOfNames(
        REFIID riidInterface,
        REFIID riid,
        OLECHAR ** rgszNames,
        UINT cNames,
        LCID lcid,
        DISPID * rgdispid)
{
    HRESULT     hr;
    ITypeInfo * pTI;

    if (!IsEqualIID(riid, IID_NULL))
        RRETURN(E_INVALIDARG);

    hr = DispatchGetTypeInfo(riidInterface, 0, lcid, &pTI);
    if (hr)
        RRETURN(hr);

    hr = pTI->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTI->Release();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetTypeInfoCount
//
//  Synopsis:   Returns E_NOTIMPL.
//
//  History:    2-16-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetTypeInfoCount(unsigned int *)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetTypeInfo
//
//  Synopsis:   Returns E_NOTIMPL
//
//  History:    2-16-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetTypeInfo(
    unsigned int,
    LCID,
    ITypeInfo FAR* FAR*)
{
    RRETURN(E_NOTIMPL);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEventSink::GetIDsOfNames
//
//  Synopsis:   Returns E_NOTIMPL.
//
//  History:    12-28-93   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEventSink::GetIDsOfNames(
    REFIID,
    OLECHAR FAR* FAR*,
    unsigned int,
    LCID,
    DISPID FAR*)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadF3TypeInfo
//
//  Synopsis:   Loads a typeinfo from the Forms3 type library.
//
//  Arguments:  [clsid] -- The clsid of the typeinfo to load.
//              [ppTI]  -- The resulting typeinfo.
//
//----------------------------------------------------------------------------

HRESULT
LoadF3TypeInfo(REFCLSID clsid, ITypeInfo ** ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    hr = THR(GetFormsTypeLib(&pTL));
    if (hr)
        RRETURN(hr);

    hr = THR_NOTRACE(pTL->GetTypeInfoOfGuid(clsid,ppTI));
    pTL->Release();

#if DBG == 1
    if (IsTagEnabled(tagLoadTypeInfo))
    {
        if (!*ppTI)
        {
            TraceTag((tagLoadTypeInfo,
                      "Unable to load Forms^3 typeinfo %hr.", hr));
        }
        else
        {
            BSTR    bstr = NULL;
            (void) (*ppTI)->GetDocumentation(
                    MEMBERID_NIL, &bstr, NULL, NULL, NULL);

            TraceTag((tagLoadTypeInfo, "Loaded typeinfo %ls.", STRVAL(bstr)));
            FormsFreeString(bstr);
        }
    }
#endif

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::CCreateTypeInfoHelper
//
//---------------------------------------------------------------------------

CCreateTypeInfoHelper::CCreateTypeInfoHelper()
{
    memset (this, 0, sizeof(*this));
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::~CCreateTypeInfoHelper
//
//---------------------------------------------------------------------------

CCreateTypeInfoHelper::~CCreateTypeInfoHelper()
{
    ReleaseInterface(pTypLib);
    ReleaseInterface(pTypLibStdOLE);
    ReleaseInterface(pTypInfoStdOLE);
    ReleaseInterface(pTypInfoCoClass);
    ReleaseInterface(pTypInfoCreate);
    ReleaseInterface(pTIOut);
    ReleaseInterface(pTICoClassOut);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::Start
//
//---------------------------------------------------------------------------

HRESULT
CCreateTypeInfoHelper::Start(REFIID riid)
{
    static GUID guidStdOle = {0x00020430,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46};

    HRESULT         hr;
    THREADSTATE *   pts;

    hr = THR(CreateTypeLib2(SYS_WIN32, _T(""), &pTypLib));
    if (hr)
        goto Cleanup;

    //
    // Initialize the typlib with some of the usual defaults.
    //

    hr = THR(pTypLib->SetGuid(g_Zero.guid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetName(_T("Page")));
    if (hr)
        goto Cleanup;

    hr = THR(pTypLib->SetLcid(LOCALE_SYSTEM_DEFAULT));
    if (hr)
        goto Cleanup;

    pts = GetThreadState();

    if (pts->pTypLibStdOLECache)
    {
        pTypLibStdOLE = pts->pTypLibStdOLECache;
        pTypInfoStdOLE = pts->pTypInfoStdOLECache;
    }
    else
    {
        //
        // Get Information on the standard OLE IDispatch
        //

        hr = THR(LoadRegTypeLib(
            guidStdOle,
            STDOLE_MAJORVERNUM,
            STDOLE_MINORVERNUM,
            STDOLE_LCID,
            &pTypLibStdOLE));
        if (hr)
            goto Cleanup;

        hr = THR(pTypLibStdOLE->GetTypeInfoOfGuid(IID_IDispatch, &pTypInfoStdOLE));
        if (hr) 
            goto Cleanup;

        pts->pTypLibStdOLECache = pTypLibStdOLE;
        pts->pTypInfoStdOLECache = pTypInfoStdOLE;
    }
    pTypLibStdOLE->AddRef();
    pTypInfoStdOLE->AddRef();

    //
    // Now create the typeInfo for the objects.
    //

    hr = THR(pTypLib->CreateTypeInfo(_T("PageProps"), TKIND_DISPATCH, &pTypInfoCreate));
    if (hr)
        goto Cleanup;

    //
    // Again perform the standard initialization on the typeinfo.
    //

    hr = THR(pTypInfoCreate->SetGuid(riid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->AddRefTypeInfo(pTypInfoStdOLE, &hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->AddImplType(0, hreftype));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
// CCreateTypeInfoHelper::Finalize
//
//---------------------------------------------------------------------------

HRESULT
CCreateTypeInfoHelper::Finalize(LONG lImplTypeFlags)
{
    HRESULT hr;

    //
    // Finish off the type info.
    //

    hr = THR(pTypInfoCreate->LayOut());
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCreate->QueryInterface(
        IID_ITypeInfo,
        (void **)&pTIOut));
    if (hr)
        goto Cleanup;

    //
    // Now we have to create a coclass for the interface
    //

    hr = THR(pTypLib->CreateTypeInfo(_T("Page"), TKIND_COCLASS, &pTypInfoCoClass));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetGuid(g_Zero.guid));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetVersion(1, 0));
    if (hr)
        goto Cleanup;

    // Add the Page Property dispinterface to coclass
    hr = THR(pTypInfoCoClass->AddRefTypeInfo(pTIOut, &hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->AddImplType(0, hreftype));
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->SetImplTypeFlags(0, lImplTypeFlags));
    if (hr)
        goto Cleanup;

    //
    // Finish off the CoClass
    hr = THR(pTypInfoCoClass->LayOut());
    if (hr)
        goto Cleanup;

    hr = THR(pTypInfoCoClass->QueryInterface(
        IID_ITypeInfo,
        (void **)&pTICoClassOut));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\errtbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       errtbl.cxx
//
//  Contents:   Error table for GetErrorText
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include "olectl.h"
#endif

//
// Each entry in the table has the following format:
//     StartError, NumberOfErrorsToMap, ErrorMessageResourceID
//
// The last entry must be all 0s.
//

struct ERRTOMSG
{
    SCODE   error;                      // the starting error code
    USHORT  cErrors;                    // number of errors in range to map
    USHORT  ids;                        // the error msg string id
};

//
// Disable warning: Truncation of constant value.  There is
// no way to specify a short integer constant.
//

#pragma warning(disable:4305 4309)

const ERRTOMSG g_aetmError[] =
{
#ifdef PRODUCT_97
    FORMS_E_NOPAGESSPECIFIED,   1,  IDS_E_NOPAGESSPECIFIED,
    FORMS_E_NOPAGESINTERSECT,   1,  IDS_E_NOPAGESINTERSECT,
#endif
    E_UNEXPECTED,               1,  IDS_EE_UNEXPECTED,
    E_FAIL,                     1,  IDS_EE_FAIL,
    E_INVALIDARG,               1,  IDS_EE_INVALIDARG,
    CTL_E_CANTMOVEFOCUSTOCTRL,          1,  IDS_EE_CANTMOVEFOCUSTOCTRL,
    CTL_E_CONTROLNEEDSFOCUS,            1,  IDS_EE_CONTROLNEEDSFOCUS,
    CTL_E_INVALIDPICTURE,               1,  IDS_EE_INVALIDPICTURE,
    CTL_E_INVALIDPICTURETYPE,           1,  IDS_EE_INVALIDPICTURETYPE,
    CTL_E_INVALIDPROPERTYARRAYINDEX,    1,  IDS_EE_INVALIDPROPERTYARRAYINDEX,
    CTL_E_INVALIDPROPERTYVALUE,         1,  IDS_EE_INVALIDPROPERTYVALUE,
    CTL_E_METHODNOTAPPLICABLE,          1,  IDS_EE_METHODNOTAPPLICABLE,
    CTL_E_OVERFLOW,                     1,  IDS_EE_OVERFLOW,
    CTL_E_PERMISSIONDENIED,             1,  IDS_EE_PERMISSIONDENIED,
    CTL_E_SETNOTSUPPORTEDATRUNTIME,     1,  IDS_EE_SETNOTSUPPORTEDATRUNTIME,
    CTL_E_INVALIDPASTETARGET,           1,  IDS_EE_INVALIDPASTETARGET,
    CTL_E_INVALIDPASTESOURCE,           1,  IDS_EE_INVALIDPASTESOURCE,
    CTL_E_MISMATCHEDTAG,                1,  IDS_EE_MISMATCHEDTAG,
    CTL_E_INCOMPATIBLEPOINTERS,         1,  IDS_EE_INCOMPATIBLEPOINTERS,
    CTL_E_UNPOSITIONEDPOINTER,          1,  IDS_EE_UNPOSITIONEDPOINTER,
    CTL_E_UNPOSITIONEDELEMENT,          1,  IDS_EE_UNPOSITIONEDELEMENT,
    CLASS_E_NOTLICENSED,                1,  IDS_EE_NOTLICENSED,
    MSOCMDERR_E_NOTSUPPORTED,           1,  IDS_E_CMDNOTSUPPORTED,
    HRESULT_FROM_WIN32(ERROR_INTERNET_INVALID_URL),       1, IDS_EE_INTERNET_INVALID_URL,
    HRESULT_FROM_WIN32(ERROR_INTERNET_NAME_NOT_RESOLVED), 1, IDS_EE_INTERNET_NAME_NOT_RESOLVED,
    // Terminate table with nulls.
    0,                          0,  0,
};

const ERRTOMSG g_aetmSolution[] =
{

    // Terminate table with nulls.
    0,                          0,  0,
};


#pragma warning(default:4305 4309)

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorText
//
//  Synopsis:   Gets the text of an error from a message resource.
//
//  Arguments:  [hr]   --   The error.  Must not be 0.
//              [pstr] --   Buffer for the message.
//              [cch]  --   Size of the buffer in characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [*pstr]
//
//----------------------------------------------------------------------------

HRESULT
GetErrorText(HRESULT hrError, LPTSTR pstr, int cch)
{
    HRESULT     hr  = S_OK;
    const ERRTOMSG * petm;
    DWORD       dwFlags;
    LPCVOID     pvSource;
    BOOL        fHrCode = FALSE;
    

    Assert(pstr);
    Assert(cch >= 0);

    //
    // Check if we handle the message in our table.
    //

    for (petm = g_aetmError; petm->error; petm++)
    {
        if (petm->error <= hrError && hrError < petm->error + petm->cErrors)
        {


            if (!LoadString(GetResourceHInst(), petm->ids, pstr, cch))
                RRETURN(GetLastWin32Error());

            return S_OK;
        }
    }

    //
    // Check the system for the message.
    //

    if (hrError >= HRESULT_FROM_WIN32(INTERNET_ERROR_BASE) &&
        hrError <= HRESULT_FROM_WIN32(INTERNET_ERROR_LAST))
    {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = GetModuleHandleA("wininet.dll");
        fHrCode = TRUE;
    }
    else if (hrError >= INET_E_ERROR_FIRST && hrError <= INET_E_ERROR_LAST)
    {
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = GetModuleHandleA("urlmon.dll");
    }
    else
    {
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
        pvSource = NULL;
    }

    if (FormatMessage(
            dwFlags,
            pvSource,
            fHrCode ? HRESULT_CODE(hrError) : hrError,
            LANG_SYSTEM_DEFAULT,
            pstr,
            cch,
            NULL))
    {
        return S_OK;
    }

    //
    // Show the error string and the hex code.
    //

    hr = Format(0, pstr, cch, MAKEINTRESOURCE(IDS_UNKNOWN_ERROR), hrError);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSolutionText
//
//  Synopsis:   Gets the text of an error from a message resource.
//
//  Arguments:  [hr]   --   The error.  Must not be 0.
//              [pstr] --   Buffer for the message.
//              [cch]  --   Size of the buffer in characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [*pstr]
//
//----------------------------------------------------------------------------

HRESULT
GetSolutionText(HRESULT hrError, LPTSTR pstr, int cch)
{
    const ERRTOMSG *  petm;

    Assert(pstr);
    Assert(cch >= 0);

    //
    // Check if we handle the message in our table.
    //

    for (petm = g_aetmSolution; petm->error; petm++)
    {
        if (petm->error <= hrError && hrError < petm->error + petm->cErrors)
        {


            if (!LoadString(GetResourceHInst(), petm->ids, pstr, cch))
                RRETURN(GetLastWin32Error());

            return S_OK;
        }
    }

    *pstr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\fatstg.cxx ===
//+---------------------------------------------------------------------
//
//  File:       fatstg.hxx
//
//  Contents:   IStream on top of a DOS (non-docfile) file
//
//	History:	
//
//----------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

//REVIEW: this file is substantially incomplete!
//REVIEW: this will either be completed or (hopefully) replaced!

//+---------------------------------------------------------------
//
//  Class:      FatStream
//
//  Purpose:    Provide an IStream interface to a DOS file
//
//---------------------------------------------------------------

MtDefine(FatStream, Utilities, "FatStream")

class FatStream: public IStream
{
    friend HRESULT CreateStreamOnFile(LPCTSTR, DWORD, LPSTREAM * ppstrm);
    friend HRESULT CloseStreamOnFile(LPSTREAM pStm);

public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(FatStream))
    DECLARE_FORMS_STANDARD_IUNKNOWN(FatStream);

    // *** IStream methods ***
    STDMETHOD(Read) (VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead);
    STDMETHOD(Write) (VOID const HUGEP *pv, ULONG cb, ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (LARGE_INTEGER dlibMove, DWORD dwOrigin,
                                    ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD(SetSize) (ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (IStream FAR *pstm, ULARGE_INTEGER cb,
                ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (DWORD grfCommitFlags);
    STDMETHOD(Revert) (void);
    STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                            DWORD dwLockType);
    STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                            DWORD dwLockType);
    STDMETHOD(Stat) (STATSTG FAR *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream FAR * FAR *ppstm);

private:
    FatStream()
        { _ulRefs = 1; _hfile = INVALID_HANDLE_VALUE; }
    ~FatStream();

    HRESULT Init(HANDLE hfile, LPCTSTR pchFile);

    HANDLE  _hfile;
    CStr    _cstrFileName;
};

inline 
FatStream::~FatStream()
{
    if (_hfile != INVALID_HANDLE_VALUE)
        CloseHandle(_hfile); 

    if (_cstrFileName.Length()) 
        DeleteFile(_cstrFileName);
}

//+---------------------------------------------------------------
//
//  Function:   CreateStreamOnFile, public
//
//  Synopsis:   Provides an IStream interface to a DOS file
//
//  Arguments:  [pchFile] -- the DOS file
//              [dwDesiredAccess] -- see CreateFile
//              [dwShareMode] -- see CreateFile
//              [dwCreationDistribution] -- see CreateFile
//              [ppstrm] -- where the opened stream is returned
//
//  Returns:    Success iff the stream interface could be provided
//
//----------------------------------------------------------------

HRESULT
CreateStreamOnFile(LPCTSTR pchFile, DWORD dwSTGM, LPSTREAM * ppstrm)
{
    DWORD       dwDesiredAccess = 0;
    DWORD       dwShareMode = 0;
    DWORD       dwCreationDistribution = 0;
    HANDLE      hfile;
    FatStream * pStmFat = NULL;
    HRESULT     hr = S_OK;

    Assert(pchFile != NULL && _tcsclen(pchFile) != 0);

    if (dwSTGM & STGM_READWRITE)
        dwDesiredAccess |= (GENERIC_READ|GENERIC_WRITE);
    else if (dwSTGM & STGM_WRITE)
        dwDesiredAccess |= GENERIC_WRITE;
    else
        dwDesiredAccess |= GENERIC_READ;

    if (dwSTGM & STGM_SHARE_DENY_NONE)
        dwShareMode |= (FILE_SHARE_READ|FILE_SHARE_WRITE);
    else if (dwSTGM & STGM_SHARE_DENY_WRITE)
        dwShareMode |= FILE_SHARE_READ;
    else if (dwSTGM & STGM_SHARE_DENY_READ)
        dwShareMode |= FILE_SHARE_WRITE;

    if (dwSTGM & STGM_CREATE)
        dwCreationDistribution |= CREATE_ALWAYS;
    else
        dwCreationDistribution |= OPEN_EXISTING;

    hfile = CreateFile(
            pchFile,
            dwDesiredAccess,
            dwShareMode,
            NULL,
            dwCreationDistribution,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (hfile==INVALID_HANDLE_VALUE)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    pStmFat = new FatStream();
    if (!pStmFat)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pStmFat->Init(
            hfile,
            dwSTGM & STGM_DELETEONRELEASE ? pchFile : NULL));
    if (hr)
        goto Error;

    *ppstrm = pStmFat;

Cleanup:
    RRETURN(hr);

Error:
    delete pStmFat;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::Init
//
//  Synopsis:   Initialize the class.
//
//----------------------------------------------------------------

HRESULT
FatStream::Init(HANDLE hfile, LPCTSTR pchFile)
{
    HRESULT hr = S_OK;

    _hfile = hfile;

    if (pchFile)
        hr = THR(_cstrFileName.Set(pchFile));

    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::QueryInterface
//
//  Synopsis:   method from IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (iid == IID_IUnknown || iid == IID_IStream)
    {
        *ppv = (IStream *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown FAR*) *ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     FatStream::Read
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Read(VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    ULONG   cbTemp;
    
    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    RRETURN(ReadFile(
        _hfile,
        pv,
        cb,
        pcbRead ? pcbRead : &cbTemp,
        NULL) ? S_OK : GetLastWin32Error());
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Write
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Write(VOID const HUGEP *pv,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    BOOL    fSuccess;
    DWORD   cbWritten;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    fSuccess = WriteFile(_hfile, pv, (DWORD) cb, &cbWritten, NULL);
    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

    RRETURN(fSuccess ? S_OK : GetLastWin32Error());
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Seek
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Seek(LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER FAR *plibNewPosition)
{
    DWORD   newpos;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    if (dlibMove.HighPart != 0 && dlibMove.HighPart != -1)
        RRETURN(E_FAIL);

    newpos = SetFilePointer(_hfile, (LONG) dlibMove.LowPart, NULL, (int) dwOrigin);

    if (plibNewPosition != NULL)
        ULISet32(*plibNewPosition, (LONG) newpos);

    RRETURN(newpos == -1 ? E_FAIL : S_OK);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::SetSize
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::SetSize(ULARGE_INTEGER libNewSize)
{
    DWORD   newpos;

    if (_hfile == INVALID_HANDLE_VALUE)
        RRETURN(E_FAIL);

    if (libNewSize.HighPart != 0)
        RRETURN(E_FAIL);

    newpos = SetFilePointer(_hfile, (LONG) libNewSize.LowPart, NULL, FILE_BEGIN);
    if (newpos == -1)
        RRETURN(GetLastWin32Error());

    if (!SetEndOfFile(_hfile))
        RRETURN(GetLastWin32Error());

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::CopyTo
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::CopyTo(IStream FAR *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR *pcbRead,
        ULARGE_INTEGER FAR *pcbWritten)
{
    DWORDLONG   cbRequest = *(LONGLONG *) &cb;
    DWORDLONG   cbActual = 0;
    HRESULT     hr = S_OK;

    if (_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    while (cbRequest)
    {
        BYTE    buf[4096];
        ULONG   cbAttempt = min(cbRequest, (DWORDLONG) sizeof(buf));
        ULONG   cbRead;

        hr = THR(Read(buf, cbAttempt, &cbRead));
        if (hr)
            goto Cleanup;

        hr = THR(pstm->Write(buf, cbRead, NULL));
        if (hr)
            goto Cleanup;

        cbActual += cbRead;
        cbRequest -= cbRead;

        if (cbAttempt > cbRead)
            break;
    }

    if (pcbRead)
        *pcbRead = *(ULARGE_INTEGER *) &cbActual;
    if (pcbWritten)
        *pcbWritten = *(ULARGE_INTEGER *) &cbActual;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Commit
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Commit(DWORD grfCommitFlags)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Revert
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Revert(void)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::LockRegion
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::LockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::UnlockRegion
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP FatStream::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    RRETURN(STG_E_INVALIDFUNCTION);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Stat
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    HRESULT     hr = S_OK;

    if (_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (pstatstg != NULL)
    {
        pstatstg->pwcsName = NULL;
        if (grfStatFlag != STATFLAG_NONAME) // if (grfStatFlag == STATFLAG_DEFAULT)
        {
            int cchFileName = _cstrFileName.Length();
            if (cchFileName)
            {
                pstatstg->pwcsName = (LPOLESTR) CoTaskMemAlloc (sizeof(TCHAR) * (cchFileName + 1));
                if (!pstatstg->pwcsName)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                _tcscpy(pstatstg->pwcsName, _cstrFileName);
            }
        }

        pstatstg->type = STGTY_STREAM;
        ULISet32(pstatstg->cbSize,(LONG) GetFileSize(_hfile, NULL));
        //pstatstg->mtime = fstatus.m_mtime;
        //pstatstg->ctime = fstatus.m_ctime;
        //pstatstg->atime = fstatus.m_atime;
        //pstatstg->grfMode = ;
        pstatstg->grfLocksSupported = 0;     // no locking supported
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------
//
//  Member:     FatStream::Clone
//
//  Synopsis:   method of IStream interface
//
//----------------------------------------------------------------

STDMETHODIMP
FatStream::Clone(IStream FAR * FAR *ppstm)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CloseStreamOnFile(LPSTREAM pStm)
{
    HRESULT hr = S_OK;
    FatStream *pStmFat = DYNCAST(FatStream, pStm);

    if (pStmFat->_hfile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!CloseHandle(pStmFat->_hfile))
        hr = GetLastWin32Error();

    pStmFat->_hfile = INVALID_HANDLE_VALUE;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\core\cdutil\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities used internally by Forms3
//              and by C++ language integration clients.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif

#ifndef X_OLECTL_H_
#define X_OLECTL_H_
#include <olectl.h>
#endif

//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        FormsFreeString(pEI->bstrSource);
        FormsFreeString(pEI->bstrDescription);
        FormsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SetErrorInfoFromEXCEPINFO
//
//  Synopsis:   Set per thread error info using data from an EXCEPINFO
//
//----------------------------------------------------------------------------

HRESULT
SetErrorInfoFromEXCEPINFO(EXCEPINFO *pexcepinfo)
{
    ICreateErrorInfo *  pCEI = NULL;
    IErrorInfo *        pEI = NULL;
    HRESULT             hr;

    if (pexcepinfo->pfnDeferredFillIn)
    {
        hr = THR((*pexcepinfo->pfnDeferredFillIn)(pexcepinfo));
        if (hr)
            goto Cleanup;

        pexcepinfo->pfnDeferredFillIn = NULL;
    }

    hr = THR(CreateErrorInfo(&pCEI));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetSource(pexcepinfo->bstrSource));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetDescription(pexcepinfo->bstrDescription));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetHelpFile(pexcepinfo->bstrHelpFile));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->SetHelpContext(pexcepinfo->dwHelpContext));
    if (hr)
        goto Cleanup;

    hr = THR(pCEI->QueryInterface(IID_IErrorInfo, (void **)&pEI));
    if (hr)
        goto Cleanup;

    hr = SetErrorInfo(NULL, pEI);

Cleanup:
    ReleaseInterface(pEI);
    ReleaseInterface(pCEI);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   VARTYPEFromBYTE
//
//  Synopsis:   Converts a byte specification of the type of a variant to
//              a VARTYPE.
//
//----------------------------------------------------------------------------

VARTYPE
VARTYPEFromBYTE(BYTE b)
{
    VARTYPE vt;

    Assert(!(b & 0xB0));
    if (b & 0x40)
    {
        vt = (VARTYPE) ((UINT) b ^ (0x40 | VT_BYREF));
    }
    else
    {
        vt = b;
    }

    return vt;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsVariantOmitted
//
//  Synopsis:   Checks to see if variant was omitted in vb call
//
//  Arguments:  [pvarg] -- Variant tpo check
//
//  Returns:    BOOL: TRUE is omitted
//
//----------------------------------------------------------------------------

BOOL
IsVariantOmitted ( const VARIANT * pvarg )
{
    if (!pvarg)
        return TRUE;
    
    return pvarg &&
           V_VT(pvarg) == VT_ERROR && 
           V_ERROR(pvarg) == DISP_E_PARAMNOTFOUND;
}


// We don't want to include the CRuntime so we've built the routine here.

// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              of legacy browser compatibility ).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, VARIANT *pvarg, VARTYPE vt,IServiceProvider *pSrvProvider, DWORD dwFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = THR(pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType));
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
    	hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);

        //Assert(!hr && "IVariantChangeType::ChangeType failure");
        if (!hr || hr == E_ACCESSDENIED)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
    