This FileObject is needed to close the connection to the serial port.
	PFILE_OBJECT
               SerialFileObject;

	struct _CARD_STATUS {

		PIRP	            Irp;

		CARD_STATUS_MODE  Mode;

		HANDLE 	         ThreadHandle;

		IO_STATUS_BLOCK   IoStatus;

		KDPC	            Dpc;

	} CardStatus;


} READER_EXTENSION, *PREADER_EXTENSION;



/*------------------------------------------------------------------------------
Prototype section
------------------------------------------------------------------------------*/
NTSTATUS GDDK_09ReaderPower
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS GDDK_09SetProtocol
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS GDDK_09Transmit
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS GDDK_09CardTracking
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GDDK_09SpecificIOCTL
(
	 PSMARTCARD_EXTENSION   SmartcardExtension,
    DWORD                  IoControlCode,
    DWORD                  BufferInLen,
    BYTE                  *BufferIn,
    DWORD                  BufferOutLen,
    BYTE                  *BufferOut,
    DWORD                 *LengthOut
);
NTSTATUS GDDK_09SpecificTag
(
	 PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD                IoControlCode,
    DWORD                BufferInLen,
    BYTE                *BufferIn,
    DWORD                BufferOutLen,
    BYTE                *BufferOut,
    DWORD               *LengthOut
);
void GDDK_09UpdateCardStatus
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
void GDDK_09LockExchange
(
    PSMARTCARD_EXTENSION   SmartcardExtension
);
void GDDK_09UnlockExchange
(
    PSMARTCARD_EXTENSION   SmartcardExtension
);


NTSTATUS GDDK_09OpenChannel
(
   PSMARTCARD_EXTENSION SmartcardExtension,
   CONST WORD32         DeviceNumber,
   CONST WORD32         PortSerialNumber,
   CONST WORD32         IFDNumber,
   CONST WORD32         MaximalBaudRate
);

NTSTATUS GDDK_09CloseChannel
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS GDDK_09OpenSession
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GDDK_09SwitchSession
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GDDK_09CloseSession
(
   PSMARTCARD_EXTENSION SmartcardExtension
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\cmbp0\cmbp0scr.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbp0/sw/cmbp0.ms/rcs/cmbp0scr.h $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#if !defined ( __CMMOB_PNP_SCR_H__ )
   #define __CMMOB_PNP_SCR_H__

   #ifdef MEMORYCARD

      #define ADDR_WRITEREG_FLAGS0              0x00
      #define ADDR_WRITEREG_FLAGS1              0x02
      #define ADDR_WRITEREG_PROCEDURE_T0        0x08
      #define ADDR_WRITEREG_MESSAGE_LENGTH      0x0A
      #define ADDR_WRITEREG_BAUDRATE            0x0C
      #define ADDR_WRITEREG_STOPBITS            0x0E

      #define ADDR_READREG_FLAGS0               0x00
      #define ADDR_READREG_LASTPROCEDURE_T0     0x02
      #define ADDR_READREG_BYTESTORECEIVE_T1    0x02
      #define ADDR_READREG_BYTES_RECEIVED       0x04
      #define ADDR_READREG_FLAGS1               0x06

// Flags 0 Read Register
      #define FLAG_INSERTED               0x01
      #define FLAG_POWERED                0x02
      #define FLAG_BYTES_RECEIVED_B9      0x04
      #define FLAG_RECEIVE                0x08

// Flag Procedure Bytes Received
      #define FLAG_NOPROCEDURE_RECEIVED   0x80

// Flags 1 Write Register
      #define FLAG_BAUDRATE_HIGH          0x01
      #define FLAG_INVERS_PARITY          0x02
      #define FLAG_CLOCK_8MHZ             0x04
      #define FLAG_T0_WRITE               0x08

// Flags 0 Write Register (Commands)
      #define CMD_RESET_SM       0x80
      #define CMD_POWERON_COLD   0x44
      #define CMD_POWERON_WARM   0x46
      #define CMD_POWEROFF       0x42
      #define CMD_WRITE_T0       0x48
      #define CMD_WRITE_T1       0x50

   #endif

   #ifdef IOCARD

      #define ADDR_WRITEREG_FLAGS0              0x00
      #define ADDR_WRITEREG_FLAGS1              0x01
      #define ADDR_WRITEREG_PROCEDURE_T0        0x02
      #define ADDR_WRITEREG_BUFFER_ADDR         0x03
      #define ADDR_WRITEREG_BUFFER_DATA         0x04
      #define ADDR_WRITEREG_MESSAGE_LENGTH      0x05
      #define ADDR_WRITEREG_BAUDRATE            0x06
      #define ADDR_WRITEREG_STOPBITS            0x07

      #define ADDR_READREG_FLAGS0               0x00
      #define ADDR_READREG_LASTPROCEDURE_T0     0x01
      #define ADDR_READREG_BYTESTORECEIVE_T1    0x01
      #define ADDR_READREG_BYTES_RECEIVED       0x02
      #define ADDR_READREG_FLAGS1               0x03
      #define ADDR_READREG_BUFFER_DATA          0x04

// Flags 0 Read Register
      #define FLAG_INSERTED               0x01
      #define FLAG_POWERED                0x02
      #define FLAG_BYTES_RECEIVED_B9      0x04
      // meaning of the flag:    Receiving T1
      //                         Receiving T0 finished
      //                         Reader detection
      #define FLAG_RECEIVE                0x08


// Flag 1 Read Register
      #define FLAG_NOPROCEDURE_RECEIVED   0x80

// Flags 1 Write Register
      #define FLAG_BAUDRATE_HIGH          0x01
      #define FLAG_INVERS_PARITY          0x02
      #define FLAG_CLOCK_8MHZ             0x04
      #define FLAG_T0_WRITE               0x08
      #define FLAG_BUFFER_ADDR_B9         0x10
      #define FLAG_TACTIVE                0x20
      #define FLAG_CHECK_PRESENCE         0x40
      #define FLAG_READ_CIS               0x80

// Flags 0 Write Register (Commands)
      #define CMD_RESET_SM       0x80
      #define CMD_POWERON_COLD   0x44
      #define CMD_POWERON_WARM   0x46
      #define CMD_POWEROFF       0x42
      #define CMD_WRITE_T0       0x48
      #define CMD_WRITE_T1       0x50

   #endif


NTSTATUS CMMOB_CardPower (
                         IN PSMARTCARD_EXTENSION SmartcardExtension
                         );

NTSTATUS CMMOB_PowerOnCard (
                           IN  PSMARTCARD_EXTENSION SmartcardExtension,
                           IN  PUCHAR pbATR,
                           IN  BOOLEAN fMaxWaitTime,
                           OUT PULONG pulATRLength
                           );

NTSTATUS CMMOB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMMOB_Transmit (
                        IN PSMARTCARD_EXTENSION SmartcardExtension
                        );

NTSTATUS CMMOB_TransmitT0 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          );

NTSTATUS CMMOB_TransmitT1 (
                          PSMARTCARD_EXTENSION SmartcardExtension
                          );

NTSTATUS CMMOB_SetProtocol (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMMOB_SetFlags1 (
                         PREADER_EXTENSION ReaderExtension
                         );

NTSTATUS CMMOB_IoCtlVendor (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMMOB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION SmartcardExtension
                                        );

NTSTATUS CMMOB_SetSpeed (
                        IN PSMARTCARD_EXTENSION SmartcardExtension,
                        IN PUCHAR               abFIDICommand
                        );

NTSTATUS CMMOB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMMOB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   );

NTSTATUS CMMOB_ReadDeviceDescription(
                                    IN PSMARTCARD_EXTENSION SmartcardExtension
                                    );

NTSTATUS CMMOB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMMOB_CardTracking (
                            IN PSMARTCARD_EXTENSION SmartcardExtension
                            );

VOID CMMOB_CompleteCardTracking(
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               );

NTSTATUS CMMOB_CancelCardTracking(
                                 PDEVICE_OBJECT DeviceObject,
                                 PIRP Irp
                                 );

NTSTATUS CMMOB_StartCardTracking(
                                IN PDEVICE_OBJECT DeviceObject
                                );

VOID CMMOB_StopCardTracking(
                           IN PDEVICE_OBJECT DeviceObject
                           );

VOID CMMOB_UpdateCurrentStateThread(
                                   IN PVOID Context
                                   );

NTSTATUS CMMOB_UpdateCurrentState(
                                 IN PSMARTCARD_EXTENSION SmartcardExtension
                                 );

NTSTATUS CMMOB_ResetReader(
                          IN PREADER_EXTENSION ReaderExtension
                          );

NTSTATUS CMMOB_BytesReceived(
                            IN PREADER_EXTENSION ReaderExtension,
                            OUT PULONG pulBytesReceived
                            );

NTSTATUS CMMOB_SetCardParameters(
                                IN PREADER_EXTENSION ReaderExtension
                                );

BOOLEAN CMMOB_CardInserted(
                          IN PREADER_EXTENSION ReaderExtension
                          );

BOOLEAN CMMOB_CardPowered(
                         IN PREADER_EXTENSION ReaderExtension
                         );

BOOLEAN CMMOB_ProcedureReceived(
                               IN PREADER_EXTENSION ReaderExtension
                               );

BOOLEAN CMMOB_GetReceiveFlag(
                            IN PREADER_EXTENSION ReaderExtension
                            );

NTSTATUS CMMOB_GetProcedureByte(
                               IN PREADER_EXTENSION ReaderExtension,
                               OUT PUCHAR pbProcedureByte
                               );
NTSTATUS CMMOB_ReadRegister(
                           IN PREADER_EXTENSION ReaderExtension,
                           IN USHORT usAddress,
                           OUT PUCHAR pbData
                           );

NTSTATUS CMMOB_WriteRegister(
                            IN PREADER_EXTENSION ReaderExtension,
                            IN USHORT usAddress,
                            IN UCHAR bData
                            );

NTSTATUS CMMOB_ReadBuffer(
                         IN PREADER_EXTENSION ReaderExtension,
                         IN ULONG ulOffset,
                         IN ULONG ulLength,
                         OUT PUCHAR pbData
                         );

NTSTATUS CMMOB_WriteBuffer(
                          IN PREADER_EXTENSION ReaderExtension,
                          IN ULONG ulLength,
                          IN PUCHAR pbData
                          );

NTSTATUS CMMOB_ReadT0(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN ULONG ulBytesToRead,
                     IN ULONG ulBytesSent,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead,
                     OUT PBOOLEAN pfDataSent
                     );

NTSTATUS CMMOB_ReadT1(
                     IN PREADER_EXTENSION ReaderExtension,
                     IN LONG ulBytesToRead,
                     IN ULONG ulBWT,
                     IN ULONG ulCWT,
                     OUT PUCHAR pbData,
                     OUT PULONG pulBytesRead
                     );

NTSTATUS CMMOB_WriteT0(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN ULONG ulBytesToReceive,
                      IN PUCHAR pbData
                      );

NTSTATUS CMMOB_WriteT1(
                      IN PREADER_EXTENSION ReaderExtension,
                      IN ULONG ulBytesToWrite,
                      IN PUCHAR pbData
                      );

VOID CMMOB_InverseBuffer (
                         PUCHAR pbBuffer,
                         ULONG  ulBufferSize
                         );

#endif	// __CMMOB_PNP_SCR_H__
/*****************************************************************************
* History:
* $Log: cmbp0scr.h $
* Revision 1.3  2000/07/27 13:53:05  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410\gntscr09.h ===
/*******************************************************************************
*                 Copyright (c) 1997 Gemplus developpement
*
* Name        : GNTSCR09.H (Gemplus NT Smart Card Reader module 09)
*
* Description : This module holds the prototypes of the functions 
*               from GNTSCR09.C
*
* Release     : 1.00.001
*
* Last Modif  : 22/06/97: V1.00.001  (GPZ)
*                 - Start of development.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/


#ifndef _GNTSCR09_
#define _GNTSCR09_

/*------------------------------------------------------------------------------
Struct section:
------------------------------------------------------------------------------*/

typedef struct _DEVICE_EXTENSION {

	SMARTCARD_EXTENSION SmartcardExtension;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;




/*------------------------------------------------------------------------------
Prototype section:
------------------------------------------------------------------------------*/
NTSTATUS DriverEntry
(
   IN  PDRIVER_OBJECT  DriverObject,
   IN  PUNICODE_STRING RegistryPath
);
NTSTATUS GDDKNT_09AddDevice
(
   IN PDRIVER_OBJECT         DriverObject,
   IN PUNICODE_STRING        SerialDeviceName,
   IN ULONG                  DeviceNumber,
   IN ULONG                  SerialNumber,
   ULONG                     IFDNumber,
   IN PSMARTCARD_EXTENSION   PreviousDeviceExt,
   IN ULONG                  MaximalBaudRate
);
NTSTATUS GDDKNT_09CreateDevice
(
   IN PDRIVER_OBJECT         DriverObject,
   IN PUNICODE_STRING        SmartcardDeviceName,
   IN PUNICODE_STRING        SerialDeviceName,
   IN ULONG                  DeviceNumber,
   IN ULONG                  SerialNumber,
   ULONG                     IFDNumber,
   IN PSMARTCARD_EXTENSION   PreviousDeviceExt,
   IN ULONG                  MaximalBaudRate
);

NTSTATUS GDDKNT_09CreateClose
(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
);

VOID GDDKNT_09Unload
(
   IN PDRIVER_OBJECT DriverObject
);

NTSTATUS GDDKNT_09DeviceControl
(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp
);

NTSTATUS GDDKNT_09InitializeCardTracking
(
   PSMARTCARD_EXTENSION SmartcardExtension
);


VOID GDDKNT_09UpdateCardStatus
(
   IN PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS GDDKNT_09Cleanup
(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410\gntser.c ===
/*******************************************************************************
*                 Copyright (c) 1997 Gemplus developpement
*
* Name        : GNTSER.C (Gemplus  Win NT SERial port management)
*
* Description : This module holds the functions needed for a communication on a
*               serial line.
*
* Compiler    : Microsoft DDK for Windows NT
*               
* Host        : IBM PC and compatible machines under Windows NT4
*
* Release     : 1.00.002
*
* Last Modif  : 01/12/97: V1.00.002  (TFB)
*                 - Change IOCTL_SMARTCARD_WRITE and IOCTL_SMARTCARD_READ in
*                   respectively GTSER_IOCTL_WRITE and GTSER_IOCTL_READ.
*               07/07/97: V1.00.001  (GPZ)
*                 - Start of development.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/
/*------------------------------------------------------------------------------
Include section:
   - stdio.h: standards definitons.
   - ntddk.h: DDK Windows NT general definitons.
   - ntddser.h: DDK Windows NT serial management definitons.
------------------------------------------------------------------------------*/
#include <stdio.h>
#include <ntddk.h>
#include <ntddser.h>

/*------------------------------------------------------------------------------
   - smclib.h: smart card library definitions.
------------------------------------------------------------------------------*/
#define SMARTCARD_POOL_TAG 'cGCS'
#include <smclib.h>

/*------------------------------------------------------------------------------
   - gemcore.h: Gemplus general definitions for the GemCore smart card reader.
   - gntser.h is used to define general macros and values for serial management.
   - gntscr09.h: public interface definition for the reader.
   - gioctl09.h: public interface definition for IOCTL functions.
------------------------------------------------------------------------------*/
#include "gemcore.h"
#include "gntscr09.h"
#include "gioctl09.h"
#include "gntser.h"


/*------------------------------------------------------------------------------
Type section:
   TPORT_CONFIG:
    - WaitRelease holds the timeout for the release of the semaphore.
    - Counter holds the number of opened session. If its value is 0, the port is
      closed.
    - Error holds Rx over state.
    - TimeOut holds the character level time out.
    - TxSize memorises the transmit buffer size.
    - RxSize memorises the reception buffer size.
    - InitRts memorises the initial Rts signal state.
    - InitDtr memorises the initial Dtr signal state.
    - Access is TRUE if the access is free, else FALSE if the channel access 
      is locked.
    - pSerialPortDevice is a pointer on the serial Device Object.
	 - pSerialFileObject is a pointer on the serial FileObject. Is needed to 
      close the connection to the serial port.
 - GTSER_IOCTL_WRITE io control to write a buffer on a serial port.
 - GTSER_IOCTL_READ  io control to read  a buffer on a serial port.
------------------------------------------------------------------------------*/
typedef struct 
{
   PIRP	            Irp;
   KEVENT 	         Event;
   IO_STATUS_BLOCK   IoStatus;
   KDPC	            Dpc;
} CARD_STATUS;

typedef struct
{
   DWORD          WaitRelease;
   WORD16         Counter;
   INT16          Error;
   WORD16         TimeOut;
   WORD16         TxSize;
   WORD16         RxSize;
   WORD16         InitRts;
   WORD16         InitDtr;
   INT32          Access;
   PDEVICE_OBJECT pSerialPortDevice;
	PFILE_OBJECT   pSerialFileObject;
   PKMUTEX        pExchangeMutex;
} TPORT_CONFIG;

#define GTSER_DEF_WAIT_RELEASE         2000
#define GTSER_IOCTL_WRITE					SCARD_CTL_CODE(1001)
#define GTSER_IOCTL_READ					SCARD_CTL_CODE(1000)

/*------------------------------------------------------------------------------
Macro section:
 - CTRL_BAUD_RATE control the baud rate parameter.
 - WORD_LEN, PARITY and STOP retreive the configuration values to pass to
   Windows to configure the port.
------------------------------------------------------------------------------*/
#define WORD_LEN(x)       (BYTE)(((x) & 0x03) + 5)
#define PARITY(x)         (BYTE)(parity[((BYTE)(x) >> 3) & 3])
#define STOP(x)           (BYTE)(stop[((x) >> 2) & 1])

/*------------------------------------------------------------------------------
Global variable section:
 - port_config is an array of TPORT_CONFIG which memorises the port
   configuration at each time.
------------------------------------------------------------------------------*/
TPORT_CONFIG
   port_config[HGTSER_MAX_PORT] =
   {
      {0,0,0,0,0,0,0,0,TRUE,NULL,NULL},
      {0,0,0,0,0,0,0,0,TRUE,NULL,NULL},
      {0,0,0,0,0,0,0,0,TRUE,NULL,NULL},
      {0,0,0,0,0,0,0,0,TRUE,NULL,NULL}
   };

static WORD16
   parity[] = {NO_PARITY,
					ODD_PARITY,
					NO_PARITY,
					EVEN_PARITY};
static WORD16
   stop[] = {STOP_BIT_1,
				 STOP_BITS_2};

/*------------------------------------------------------------------------------
Local function definition section:
------------------------------------------------------------------------------*/
static NTSTATUS GDDKNT_SetupComm
(
	const INT16         Handle,
	const ULONG         InSize,
	const ULONG         OutSize
);
static NTSTATUS GDDKNT_GetCommStatus
(
	const INT16         Handle,
	SERIAL_STATUS       *SerialStatus
);
static NTSTATUS GDDKNT_ResetComm
(
	const INT16         Handle
);
static NTSTATUS GDDKNT_PurgeComm
(
	const INT16         Handle,
	const ULONG         Select
);
/*******************************************************************************
* INT16  G_SerPortOpen
* (
*    const TGTSER_PORT  *Param
* )
*
* Description :
* -------------
* This routine opens a serial port and initializes it according to the
*    parameters found in Param.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
* Param holds the following parameters:
*  - Port indicates the selected port: G_COM1 (1), G_COM2 (2), G_COM3 (3) or
*    G_COM4 (4).
*  - BaudRate is used to set port baud rate: 110, 150, 300, 600, 1200, 2400,
*    4800, 9600, 19200, 38400 or 57600.
*    A value greater than 57600 is reduced to 57600 !
*  - Mode gathers
*     * word size WORD_5 (0), WORD_6 (1), WORD_7 (2) or WORD_8 (3),
*     * stop bit number STOP_BIT_1 (0) or STOP_BIT_2 (4) and
*     * parity NO_PARITY (0), ODD_PARITY (8) or EVEN_PARITY (24).
*  - TimeOut indicates the time out value, in milli-seconds, at character level.
*  - TxSize is the transmit buffer size, in bytes.
*  - RxSize is the reception buffer size, in mbytes.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:
*  - a handle on the port channel (>= 0).
* If an error condition is raised:
*  - GE_HOST_PORT_ABS  (- 401) if port is not found on host or is locked by
*       another device.
*  - GE_HOST_PORT_OPEN (- 411) if the port is already opened.
*  - GE_HOST_MEMORY    (- 420) if a memory allocation fails.
*  - GE_HOST_PARAMETERS(- 450) if one of the given parameters is out of the
*    allowed range or is not supported by hardware.
*  - GE_UNKNOWN_PB     (-1000) if an unexpected problem is encountered.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  com_name    gives the DOS level port name
  device_ctrl is used to hold the string requred by BuildCommDCB.
  parity      gives the DOS level parity name
  port_config is set with the selected configuration.

*******************************************************************************/
INT16  G_SerPortOpen(const TGTSER_PORT  *Param)
{
/*------------------------------------------------------------------------------
Local variables:
 - Handle holds the handle associated to the given port. It is calculated
   by the following formula Port - 1.
 - response holds the called function responses.
 - current_dcb is used to set parameters in the device control block.
------------------------------------------------------------------------------*/
INT16
   Handle = (INT16)(Param->Port - 1);
NTSTATUS
   status;
PSMARTCARD_EXTENSION
	SmartcardExtension;
SERIAL_READER_CONFIG
	SerialConfig;
PREADER_EXTENSION 
   pReaderExtension;

/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port number (G_COM1 .. G_COM4): GE_HOST_PARAMETERS
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PARAMETERS);
   }
/*------------------------------------------------------------------------------
<= Test the port access state : GE_HOST_PORT_LOCKED
------------------------------------------------------------------------------*/
   if (port_config[Handle].Access == FALSE)
   {
      return (GE_HOST_PORT_LOCKED);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter field null): GE_HOST_PORT_OPEN
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter != 0)
   {
      return (GE_HOST_PORT_OPEN);
   }
/*------------------------------------------------------------------------------
Retrieve the SmartcardExtension structure of the current device.
------------------------------------------------------------------------------*/
	SmartcardExtension = (PSMARTCARD_EXTENSION)(Param->pSmartcardExtension);
	pReaderExtension = SmartcardExtension->ReaderExtension;
	port_config[Handle].pSerialPortDevice = pReaderExtension->ConnectedSerialPort;
	port_config[Handle].pSerialFileObject = pReaderExtension->SerialFileObject;
	port_config[Handle].pExchangeMutex    = &pReaderExtension->ExchangeMutex;

/*------------------------------------------------------------------------------
   The current port state is read and stored in current_dcb structure by
   calling GetCommState function.
   If the reading is possible (GetCommState return 0)
   Then
      The current_dcb structure is updated with the given parameter (baud
      rate, ByteSize, Parity, StopBits).
      The modified state is written by calling SetCommState.
------------------------------------------------------------------------------*/
   status = GDDKNT_GetCommState(Handle,&SerialConfig);
   if (NT_SUCCESS(status))
   {
		status = GDDKNT_SetupComm(Handle,4096L,4096L);
/*------------------------------------------------------------------------------
		Set the serial port communication parameters
------------------------------------------------------------------------------*/
      SerialConfig.BaudRate.BaudRate = Param->BaudRate;
      SerialConfig.LineControl.WordLength = WORD_LEN(Param->Mode);
      SerialConfig.LineControl.Parity     = PARITY(Param->Mode);
      SerialConfig.LineControl.StopBits   = STOP(Param->Mode);
		SerialConfig.WaitMask = SERIAL_EV_RXCHAR;
/*------------------------------------------------------------------------------
	   Set timeouts
------------------------------------------------------------------------------*/
		SerialConfig.Timeouts.ReadIntervalTimeout = 1000;
		SerialConfig.Timeouts.ReadTotalTimeoutConstant = 5000;
	   SerialConfig.Timeouts.ReadTotalTimeoutMultiplier = 50;
/*------------------------------------------------------------------------------
		Set special characters
------------------------------------------------------------------------------*/
		SerialConfig.SerialChars.ErrorChar = 0;
		SerialConfig.SerialChars.EofChar = 0;
	   SerialConfig.SerialChars.EventChar = 0;
		SerialConfig.SerialChars.XonChar = 0;
		SerialConfig.SerialChars.XoffChar = 0;
		SerialConfig.SerialChars.BreakChar = 0xFF;
/*------------------------------------------------------------------------------
		Set handflow
------------------------------------------------------------------------------*/
	   SerialConfig.HandFlow.XonLimit = 0;
		SerialConfig.HandFlow.XoffLimit = 0;
	   SerialConfig.HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
		SerialConfig.HandFlow.ControlHandShake = 0;
      status = GDDKNT_SetCommState(Handle,&SerialConfig);
	}
/*------------------------------------------------------------------------------
   Else
      response is set with IE_DEFAULT error value.
------------------------------------------------------------------------------*/
   else
   {
      return (GE_HOST_PARAMETERS);
   }
/*------------------------------------------------------------------------------
Treats system error codes:
   If an error has occured (response < 0)
   Then
      switch response value:
         IE_OPEN, IE_BAD_ID and IE_HARDWARE
<=          GE_HOST_PORT_ABS
         IE_MEMORY
<=          GE_HOST_MEMORY
         IE_BAUDRATE, IE_BYTESIZE, IE_DEFAULT
<=          GE_HOST_PARAMETERS
         default
<=          GE_UNKNOWN_PB
------------------------------------------------------------------------------*/
	if (!NT_SUCCESS(status))
   {
      switch (status)
      {
         case STATUS_INSUFFICIENT_RESOURCES:
         {
            return (GE_HOST_MEMORY);
         }
         case STATUS_BUFFER_TOO_SMALL:
         {
            return (GE_HOST_PARAMETERS);
         }
         default         :
         {
            return (GE_UNKNOWN_PB);
         }
      }
   }
/*------------------------------------------------------------------------------
Memorises the given parameters in port_config structure.
   Counter, Error, TimeOut, TxSize and RxSize fields are updated.
------------------------------------------------------------------------------*/
   port_config[Handle].Counter = 1;
   port_config[Handle].Error   = 0;
   port_config[Handle].TimeOut = Param->TimeOut;
   port_config[Handle].TxSize  = Param->TxSize;
   port_config[Handle].RxSize  = Param->RxSize;
/*------------------------------------------------------------------------------
<= the handle value.
------------------------------------------------------------------------------*/
   return (Handle);

}

/*******************************************************************************
* INT16  G_SerPortAddUser
* (
*    const INT16 Port
* )
*
* Description :
* -------------
* Add a new user on a port. This function return the handle of a previously
* opened port.
*
* Remarks     :
* -------------
* When this function is successful, it is mandatory to call G_SerPortClose
* to decrement the user number.
*
* In          :
* -------------
*  - Port indicates the selected port: G_COM2 (1), G_COM2 (2), G_COM3 (3) or
*    G_COM4 (4).
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:
*    a handle on the port channel (>= 0)
* If an error condition is raised:
*  - GE_HOST_PORT_CLOSE (-412) if port is closed.
*  - GE_HOST_RESOURCES  (-430) if too many users hold the port.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config memorises the port configuration.

*******************************************************************************/
INT16  G_SerPortAddUser
(
   const INT16  Port
)
{
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Port < G_COM1) || (Port > G_COM4))
   {
      return (GE_HOST_PARAMETERS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Port - 1].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
<= Test port_config.Counter [!= 65535): GE_HOST_RESOURCES
------------------------------------------------------------------------------*/
   if (port_config[Port - 1].Counter == 65535lu)
   {
      return (GE_HOST_RESOURCES);
   }
/*------------------------------------------------------------------------------
Increments the port_config.Counter.
------------------------------------------------------------------------------*/
   port_config[Port - 1].Counter += 1;

/*------------------------------------------------------------------------------
<= Port number.
------------------------------------------------------------------------------*/
   return (Port - 1);
}

/*******************************************************************************
* INT16  G_SerPortClose
* (
*    const INT16 Handle
* )
*
* Description :
* -------------
* This routine closes a previously opened serial port.
*
* Remarks     :
* -------------
* When port is shared, the close will be effective only when all clients will
*    have closed the port.
*
* In          :
* -------------
*  - Handle holds the port handle.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK                (   0).
* If an error condition is raised:
*  - GE_HOST_PORT_CLOSE (-412) if the selected port is already closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config is updated to closed state.

*******************************************************************************/
INT16  G_SerPortClose (const INT16 Handle)
{
/*------------------------------------------------------------------------------
Local variables:
 - response holds the called function responses.
------------------------------------------------------------------------------*/
INT16
   response;

/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
   Decrements the port_config.Counter field.
   If is the last connection on the port
   Then
      Set the access state to TRUE.
------------------------------------------------------------------------------*/
   port_config[Handle].Counter -= 1;
   if (port_config[Handle].Counter == 0)
   {
      port_config[Handle].Access = TRUE;
   }
/*------------------------------------------------------------------------------
Closes really the port for the last user:
   If port_config.Counter = 0
   Then
      The queues are flushed by calling PurgeComm function.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      GDDKNT_PurgeComm(Handle,SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_TXABORT);
   }
   else
   {
      response = G_OK;
   }
/*------------------------------------------------------------------------------
<= Last Response
------------------------------------------------------------------------------*/
   return (response);
}

/*******************************************************************************
* INT16  G_SerPortWrite
* (
*    const INT16        Handle,
*    const WORD16       Length,
*    const BYTE         Buffer[]
* )
*
* Description :
* -------------
* This routine writes bytes on a previously opened serial port.
*
* Remarks     :
* -------------
* WARNING: Application must verify that it remains enough place to send all the
* bytes.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - Length holds the number of bytes to write.
*  - Buffer holds the bytes to write.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK                (   0).
* If an error condition is raised:
*  - GE_HI_LEN          (-311) if there is not enough available space is in Tx
*    queue.
*  - GE_HOST_PORT_BREAK (-404) if the bytes cannot be sent.
*  - GE_HOST_PORT_CLOSE (-412) if port is closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config memorises the port configuration.

*******************************************************************************/
INT16  G_SerPortWrite
(
   const INT16        Handle,
   const WORD16       Length,
   const BYTE         Buffer[]
)
{
/*------------------------------------------------------------------------------
Local variables:
------------------------------------------------------------------------------*/
NTSTATUS
   status;
SERIAL_STATUS
	SerialStatus;
WORD16
	LengthOut;

   ASSERT(Buffer != NULL);
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }

/*------------------------------------------------------------------------------
Control if the write can be made in one time:
 - The windows port status is read by calling GetCommError to know how many
   bytes remain in Tx queue (port_config.Error field is updated if needed).
 - If the write length is greater than the available space in Tx queue
   Then
<=    GE_HI_LEN
------------------------------------------------------------------------------*/
   GDDKNT_GetCommStatus(Handle,&SerialStatus);
   port_config[Handle].Error |= (WORD16)(SERIAL_ERROR_OVERRUN & SerialStatus.Errors);
   if (Length > ( port_config[Handle].TxSize - SerialStatus.AmountInOutQueue))
   {
      return (GE_HI_LEN);
   }
/*------------------------------------------------------------------------------
Writes the given byte in Tx queue by calling the WriteComm function.
   If an error occurs during this operation
   Then
      The ClearCommError function is called to unblock the port
      (port_config.Error field is updated if needed).
<=    GE_HOST_PORT_BREAK
------------------------------------------------------------------------------*/
	LengthOut = 0;
	status = GDDKNT_SerPortIoRequest(Handle,
												 GTSER_IOCTL_WRITE,
												 500UL,
												 Length,
												 Buffer,
												 &LengthOut,
												 NULL);
   if (!NT_SUCCESS(status))
   {
	   GDDKNT_GetCommStatus(Handle,&SerialStatus);
		port_config[Handle].Error |= (WORD16)(SERIAL_ERROR_OVERRUN & SerialStatus.Errors);
	   GDDKNT_ResetComm(Handle);
      return (GE_HOST_PORT_BREAK);
   }
   return (G_OK);
}

/*******************************************************************************
* INT16  G_SerPortRead
* (
*    const INT16         Handle,
*          WORD16       *Length,
*          BYTE          Buffer[]
* )
*
* Description :
* -------------
* This routine reads bytes on a previously opened serial port.
*
* Remarks     :
* -------------
* It ends when required length = read length or when a character level timeout
*    is detected.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - Length holds the number of bytes to read.
*  - Buffer is a free area of, at least, Length bytes.
*
* Out         :
* -------------
*  - Length holds the real number of read bytes.
*  - Buffer holds the read bytes.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK               (   0).
* If an error condition is raised:
*  - GE_IFD_MUTE        (-201) if a character timeout is detected.
*  - GE_HI_COMM         (-300) if a communication error occurs.
*  - GE_HI_PARITY       (-301) if a parity error is encountered.
*  - GE_HI_PROTOCOL     (-310) if a frame error is encountered.
*  - GE_HOST_PORT_CLOSE (-412) if port is closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config memorises the port configuration.

*******************************************************************************/
INT16  G_SerPortRead
(
   const INT16         Handle,
         WORD16       *Length,
         BYTE          Buffer[]
)
{
/*------------------------------------------------------------------------------
Local variables:
 - end_tick is used to manage timeout.
 - ptr point on the next position in buffer. The HUGE modifier is used to avoid
   wraparound.
 - status will hold Windows port status.
 - nb_of_read_byte memorises the number of read bytes.
 - byte_to read holds the number of bytes to read in one loop.
 - read_byte holds the number of bytes which have been really read in a loop.
 - response holds called function responses.
------------------------------------------------------------------------------*/
NTSTATUS
   status;
WORD32
   end_tick;
INT16
   response,i;
DWORD
   error;
TIME
	CurrentTime;
SERIAL_STATUS
	SerialStatus;

   ASSERT(Buffer != NULL);
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port Handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      *Length = 0;
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
   Try to read the bytes.
------------------------------------------------------------------------------*/
	status = GDDKNT_SerPortIoRequest(Handle,
												 GTSER_IOCTL_READ,
												 port_config[Handle].TimeOut,
												 0,
												 NULL,
												 Length,
												 Buffer);
/*------------------------------------------------------------------------------
   If an error occurs (response == FALSE)
   Then
      VCOMM_GetLastError
      According to the detected error, a status is returned:
      CE_RXPARITY
<=       GE_HI_PARITY
      CE_FRAME
<=       GE_HI_PROTOCOL
      other cases
<=       GE_HI_COMM
------------------------------------------------------------------------------*/
	if (!NT_SUCCESS(status))
	{
	   GDDKNT_GetCommStatus(Handle,&SerialStatus);
		error = (WORD16)(SerialStatus.Errors);
      if (error  & SERIAL_ERROR_PARITY)
      {
         return (GE_HI_PARITY);
      }
      else if (error & SERIAL_ERROR_FRAMING)
      {
         return (GE_HI_PROTOCOL);
      }
      else
      {
         return (GE_HI_COMM);
      }
   }
/*------------------------------------------------------------------------------
   Else
      Then
         Length is updated with the number of read byte.
<=       GE_IFD_MUTE
------------------------------------------------------------------------------*/
   else
   {
      if (*Length == 0)
      {
         return (GE_IFD_MUTE);
      }
   }
/*------------------------------------------------------------------------------
<= G_OK
------------------------------------------------------------------------------*/
   return (G_OK);

}

/*******************************************************************************
* INT16  G_SerPortFlush
* (
*    const INT16         Handle,
*    const WORD16        Select
* )
*
* Description :
* -------------
* This function clears Tx and Rx buffers.
*
* Remarks     :
* -------------
* When RX_QUEUE is selected, the RX_OVER flag is reseted.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - Select holds the buffers to clear:
*       HGTSER_TX_QUEUE
*       HGTSER_RX_QUEUE
*       HGTSER_TX_QUEUE | HGTSER_RX_QUEUE
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK               (   0).
* If an error condition is raised:
*  - GE_HOST_PORT_CLOSE (-412) if port is closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*  - GE_HOST_PORT_BREAK (-404) if the port cannot be flush.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config memorises the port configuration.

*******************************************************************************/
INT16  G_SerPortFlush
(
   const INT16  Handle,
   const WORD16 Select
)
{
NTSTATUS
   status;

	/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
Clears the selected queues:
   If HGTSER_TX_QUEUE is selected
   Then
      Flushes the Tx queue by calling FlushComm.
------------------------------------------------------------------------------*/
   if (Select & HGTSER_TX_QUEUE)
   {
      status = GDDKNT_PurgeComm(Handle,SERIAL_PURGE_TXCLEAR);
      if (!NT_SUCCESS(status))
      {
         return (GE_HOST_PORT_BREAK);
      }
   }
/*------------------------------------------------------------------------------
   If HGTSER_RX_QUEUE is selected
   Then
      Flushes the Rx queue by calling FlushComm.
      Reset port_config.error field.
------------------------------------------------------------------------------*/
   if (Select & HGTSER_RX_QUEUE)
   {
      status = GDDKNT_PurgeComm(Handle,SERIAL_PURGE_RXCLEAR);
      if (!NT_SUCCESS(status))
      {
         return (GE_HOST_PORT_BREAK);
      }
      port_config[Handle].Error = 0;
   }
   return(G_OK);
}

/*******************************************************************************
* INT16  G_SerPortStatus
* (
*    const INT16                Handle,
*          WORD16              *TxLength,
*          WORD16              *RxLength,
*          TGTSER_STATUS       *Status
* )
*
* Description :
* -------------
* Return information about communication state.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
* Handle holds the port handle.
*
* Out         :
* -------------
*  - TxLength holds the used Tx buffer length.
*  - RxLength holds the used Rx buffer length.
*  - Status   can hold the following flags:
*    HGTSER_RX_OVER when a character has been lost since last call to this
*    function.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK               (    0).
* If an error condition is raised:
*  - GE_HOST_PORT_CLOSE (-412) if port is closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config memorises the port configuration.

*******************************************************************************/
INT16  G_SerPortStatus
(
   const INT16                Handle,
         WORD16              *TxLength,
         WORD16              *RxLength,
         TGTSER_STATUS       *Status
)
{
/*------------------------------------------------------------------------------
Local variables:
 - status will hold Windows port status.
------------------------------------------------------------------------------*/
NTSTATUS
   status;
SERIAL_STATUS
	SerialStatus;

   ASSERT(TxLength != NULL);
   ASSERT(RxLength != NULL);
   ASSERT(Status != NULL);
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port Handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
Updates the given parameters:
   The current windows state is read and port_config.Error field is updated.
------------------------------------------------------------------------------*/
   status = GDDKNT_GetCommStatus(Handle,&SerialStatus);
   if (!NT_SUCCESS(status))
   {
      return (GE_HOST_PORT_BREAK);
   }
/*------------------------------------------------------------------------------
   TxLength, RxLength and Status parameter fields are updated.
------------------------------------------------------------------------------*/
   *TxLength = (WORD16)SerialStatus.AmountInOutQueue;
   *RxLength = (WORD16)SerialStatus.AmountInInQueue;
   *Status = 0;
/*------------------------------------------------------------------------------
The Error field is reseted.
------------------------------------------------------------------------------*/
   port_config[Handle].Error = 0;
/*------------------------------------------------------------------------------
<= G_OK
------------------------------------------------------------------------------*/
   return (G_OK);
}

/*******************************************************************************
* INT16  G_SerPortGetState
* (
*    TGTSER_PORT       *Param,
*    WORD16            *UserNb
* )
*
* Description :
* -------------
* This routine read the currently in use parameters for an opened serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
* The following field of Param must be filled:
*  - Port indicates the selected port: G_COM1 (1), G_COM2 (2), G_COM3 (3) or
*    G_COM4 (4).
*
* Out         :
* -------------
* The following fields of Param are updated by the call:
*  - BaudRate holds the currently selected port baud rate: 110, 150, 300, 600,
*    1200, 2400, 4800, 9600, 19200, 38400 or 57600.
*  - Mode gathers
*     * word size WORD_5 (0), WORD_6 (1), WORD_7 (2) or WORD_8 (3),
*     * stop bit number STOP_BIT_1 (0) or STOP_BIT_2 (4) and
*     * parity NO_PARITY (0), ODD_PARITY (8) or EVEN_PARITY (24).
*  - TimeOut indicates the time out value, in milli-seconds, at character level.
*  - TxSize is the transmit buffer size, in bytes.
*  - RxSize is the reception buffer size, in mbytes.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK               (   0).
* If an error condition is raised:
*  - GE_HOST_PORT_OS    (-410) if a unexpected value has been returned by the
*       operating system.
*  - GE_HOST_PORT_CLOSE (-412) if the selected port is closed.
*  - GE_HOST_PARAMETERS (-450) if the given handle is out of the allowed range.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config is read.

*******************************************************************************/
INT16  G_SerPortGetState
(
   TGTSER_PORT       *Param,
   WORD16            *UserNb
)
{
/*------------------------------------------------------------------------------
Local variables:
 - handle holds the handle associated to the given port. It is calculated by the
   following formula Port - 1.
 - response holds the called function responses.
 - current_dcb is used to read parameters in the device control block.
------------------------------------------------------------------------------*/
NTSTATUS
   status;
INT16
   Handle = (INT16)(Param->Port - 1);
SERIAL_READER_CONFIG
	SerialConfig;

   ASSERT(Param != NULL);
   ASSERT(UserNb != NULL);
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port Handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }
/*------------------------------------------------------------------------------
The current port state is read and stored in current_dcb structure by calling
   GetCommState function.
   If an error has occured (response < 0)
   Then
<=    GE_HOST_PORT_OS
------------------------------------------------------------------------------*/
   status = GDDKNT_GetCommState(Handle,&SerialConfig);
   if (!NT_SUCCESS(status))
   {
      return (GE_HOST_PORT_OS);
   }
/*------------------------------------------------------------------------------
The parameters are updated with the read values.
------------------------------------------------------------------------------*/
   Param->BaudRate = SerialConfig.BaudRate.BaudRate;
/*------------------------------------------------------------------------------
   If the byte size is not supported
   Then
<=    GE_HOST_PORT_OS
------------------------------------------------------------------------------*/
   switch (SerialConfig.LineControl.WordLength)
   {
      case 5:
         Param->Mode = HGTSER_WORD_5;
         break;
      case 6:
         Param->Mode = HGTSER_WORD_6;
         break;
      case 7:
         Param->Mode = HGTSER_WORD_7;
         break;
      case 8:
         Param->Mode = HGTSER_WORD_8;
         break;
      default:
         return (GE_HOST_PORT_OS);
   }

/*------------------------------------------------------------------------------
   If the parity is not supported
   Then
<=    GE_HOST_PORT_OS
------------------------------------------------------------------------------*/
   switch (SerialConfig.LineControl.Parity)
   {
      case NO_PARITY:
         Param->Mode |= HGTSER_NO_PARITY;
         break;
      case ODD_PARITY:
         Param->Mode |= HGTSER_ODD_PARITY;
         break;
      case EVEN_PARITY:
         Param->Mode |= HGTSER_EVEN_PARITY;
         break;
      case SERIAL_PARITY_MARK:
      case SERIAL_PARITY_SPACE:
      default:
         return (GE_HOST_PORT_OS);
   }
/*------------------------------------------------------------------------------
   If the stop bit number is not supported
   Then
<=    GE_HOST_PORT_OS
------------------------------------------------------------------------------*/
   switch (SerialConfig.LineControl.StopBits)
   {
      case STOP_BIT_1:
         Param->Mode |= HGTSER_STOP_BIT_1;
         break;
      case STOP_BITS_2:
         Param->Mode |= HGTSER_STOP_BIT_2;
         break;
      case STOP_BITS_1_5:
      default:
         return (GE_HOST_PORT_OS);
   }
/*------------------------------------------------------------------------------
Updates the library fields ITNumber, TimeOut, TxSize and RxSize.
------------------------------------------------------------------------------*/
   Param->ITNumber = DEFAULT_IT;
   Param->TimeOut  = port_config[Handle].TimeOut;
   Param->TxSize   = port_config[Handle].TxSize;
   Param->RxSize   = port_config[Handle].RxSize;
/*------------------------------------------------------------------------------
The UserNb parameter is filled with the port_config.Counter.
------------------------------------------------------------------------------*/
   *UserNb         = port_config[Handle].Counter;
/*------------------------------------------------------------------------------
<= G_OK
------------------------------------------------------------------------------*/
   return (G_OK);
}

/*******************************************************************************
* INT16  G_SerPortSetState
* (
*    TGTSER_PORT       *Param
* )
*
* Description :
* -------------
* This routine alters the currently in use parameters for an opened serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
* The following field of Param must be filled:
*  - Port indicates the selected port: G_COM1 (1), G_COM2 (2), G_COM3 (3) or
*    G_COM4 (4).
*  - BaudRate holds the currently selected port baud rate: 110, 150, 300, 600,
*    1200, 2400, 4800, 9600, 19200, 38400 or 57600.
*  - Mode gathers
*     * word size WORD_5 (0), WORD_6 (1), WORD_7 (2) or WORD_8 (3),
*     * stop bit number STOP_BIT_1 (0) or STOP_BIT_2 (4) and
*     * parity NO_PARITY (0), ODD_PARITY (8) or EVEN_PARITY (24).
*  - TimeOut indicates the time out value, in milli-seconds, at character level.
*
* Out         :
* -------------
* The following fields of Param are updated by the call:
*  - TxSize is the transmit buffer size, in bytes.
*  - RxSize is the reception buffer size, in mbytes.
*
* Responses   :
* -------------
* If everything is OK:
*  - G_OK               (   0).
* If an error condition is raised:
*  - GE_HOST_PORT_ABS   (- 401) if port is not found on host or is locked by
*       another device.
*  - GE_HOST_PORT_OS    (- 410) if a unexpected value has been returned by the
*       operating system.
*  - GE_HOST_PORT_CLOSE (- 412) if the selected port is closed.
*  - GE_HOST_MEMORY     (- 420) if a memory allocation fails.
*  - GE_HOST_PARAMETERS (- 450) if one of the given parameters is out of the
*    allowed range or is not supported by hardware.
*  - GE_UNKNOWN_PB      (-1000) if an unexpected problem is encountered.
*
  Extern var  :
  -------------
  Nothing.

  Global var  :
  -------------
  port_config is set with the selected configuration.

*******************************************************************************/
INT16  G_SerPortSetState
(
   TGTSER_PORT       *Param
)
{
NTSTATUS
   status;
INT16
   response = G_OK,
   Handle = (INT16)(Param->Port - 1);
SERIAL_READER_CONFIG
	SerialConfig;
DWORD
   error = 0;

   ASSERT(Param != NULL);
/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (GE_HOST_PORT_ABS);
   }
/*------------------------------------------------------------------------------
<= Test the port state (Counter > 0): GE_HOST_PORT_CLOSE.
------------------------------------------------------------------------------*/
   if (port_config[Handle].Counter == 0)
   {
      return (GE_HOST_PORT_CLOSE);
   }

   status = GDDKNT_GetCommState(Handle,&SerialConfig);
   if (NT_SUCCESS(status))
   {
      SerialConfig.BaudRate.BaudRate      = Param->BaudRate;
      SerialConfig.LineControl.WordLength = WORD_LEN(Param->Mode);
      SerialConfig.LineControl.Parity     = PARITY(Param->Mode);
      SerialConfig.LineControl.StopBits   = STOP(Param->Mode);
	   status = GDDKNT_SetCommState(Handle,&SerialConfig);
   }
/*------------------------------------------------------------------------------
      Else
         error is set with GE_HOST_PARAMETERS error value.
------------------------------------------------------------------------------*/
   else
   {
      return(GE_HOST_PARAMETERS);
   }
	if (!NT_SUCCESS(status))
   {
      switch (status)
      {
         case STATUS_BUFFER_TOO_SMALL:
         case STATUS_INVALID_PARAMETER:
            response = GE_HOST_PARAMETERS;
            break;
         default         :
            response = GE_UNKNOWN_PB;
            break;
      }
   }
   return(response);
}
/*******************************************************************************
* INT32  G_SerPortLockComm
* (
*    const INT16 Handle,
*    const DWORD WaitRelease 
* )
*
* Description :
* -------------
*     Take the mutex for a serial port communication if is free or wait 
*     the release
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*     Handle hold the port handle
*     WaitRelease old the new time to wait the release
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is OK:  TRUE
*   else                FALSE
*
  Extern var  :
  -------------
  Nothing.
 
  Global var  :
  -------------
  Nothing
 
*******************************************************************************/
INT32  G_SerPortLockComm
(
    const INT16 Handle,
    const DWORD WaitRelease
)
{
NTSTATUS
	status;
LARGE_INTEGER
   timeout;

/*------------------------------------------------------------------------------
Controls the given parameters:
<= Test the port handle (0 <= Handle < HGTSER_MAX_PORT): GE_HOST_PARAMETERS.
------------------------------------------------------------------------------*/
   if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT))
   {
      return (FALSE);
   }
/*------------------------------------------------------------------------------
   Wait the release of the mutex
------------------------------------------------------------------------------*/
   timeout.QuadPart = -((LONGLONG)(
      port_config[Handle].WaitRelease > GTSER_DEF_WAIT_RELEASE ? 
      port_config[Handle].WaitRelease : GTSER_DEF_WAIT_RELEASE)*10*1000);
	status = KeWaitForMutexObject(
		   port_config[Handle].pExchangeMutex,
		   Executive,
		   KernelMode,
		   FALSE,
		   &timeout
         );
   if (status != STATUS_SUCCESS)
   {
      return(FALSE);
   }
   else
   {
      port_config[Handle].WaitRelease = WaitRelease;
      return(TRUE);
   }
}

/*******************************************************************************
* void  G_SerPortUnlockComm
* (
*    const INT16 Handle
* )
*
* Description :
* -------------
* Release the mutex for a serial port communication.
*
* Remarks     :
* -------------
* Nothing.
*
* In          : Handle hold the port handle
* -------------
* Nothing
*
* Out         :
* -------------
*
* Responses   :
* -------------
* Nothing
*
  Extern var  :
  -------------
  Nothing.
 
  Global var  :
  -------------
  Nothing
 
*******************************************************************************/
void  G_SerPortUnlockComm
(
    const INT16 Handle
)
{
NTSTATUS
	status;

/*------------------------------------------------------------------------------
Controls the given parameters:
------------------------------------------------------------------------------*/
   if ((Handle >= 0) && (Handle < HGTSER_MAX_PORT))
   {
      status = KeReleaseMutex(port_config[Handle].pExchangeMutex,FALSE);
   }
}
/******************************************************************************
* NTSTATUS GDDKNT_SerPortIoRequest
* (
*    IN CONST INT16          Handle,
*    IN CONST ULONG          SerialIoControlCode,
*    IN CONST ULONG          CmdTimeout,
*    IN CONST WORD16         LengthIn,
*    IN CONST BYTE          *BufferIn,
*    IN OUT   WORD16        *pLengthOut,
*    OUT      BYTE          *BufferOut
* )
*
* Description :
* -------------
*    This function sends IOCTL's to the serial driver. It waits on for their
*    completion, and then returns.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - CmdTimeout is the current command timeout.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
NTSTATUS GDDKNT_SerPortIoRequest
(
   IN CONST INT16          Handle,
   IN CONST ULONG          SerialIoControlCode,
   IN CONST ULONG          CmdTimeout,
   IN CONST WORD16         LengthIn,
   IN CONST BYTE          *BufferIn,
   IN OUT   WORD16        *pLengthOut,
   OUT      BYTE          *BufferOut
)
{
NTSTATUS 
   status;
PIRP     
   irp;
PIO_STACK_LOCATION 
   irpNextStack;
IO_STATUS_BLOCK 
   ioStatus;
KEVENT   
   event;
LARGE_INTEGER
   timeout;

   KeInitializeEvent(&event,NotificationEvent,FALSE);
/*------------------------------------------------------------------------------
   Build an Irp to be send to serial driver
------------------------------------------------------------------------------*/
   irp = IoBuildDeviceIoControlRequest
      (
         SerialIoControlCode,
         port_config[Handle].pSerialPortDevice, 
         (PVOID)BufferIn,
         (ULONG)LengthIn,
         (PVOID)BufferOut,
         (ULONG)(*pLengthOut),
         FALSE,
         &event,
         &ioStatus
      );

   if (irp == NULL) 
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }
   irpNextStack = IoGetNextIrpStackLocation(irp);

   switch (SerialIoControlCode) 
   {
	   case GTSER_IOCTL_WRITE:
		   irpNextStack->MajorFunction = IRP_MJ_WRITE;
		   irpNextStack->Parameters.Write.Length = (ULONG)LengthIn;
		   break;

	   case GTSER_IOCTL_READ:
		   irpNextStack->MajorFunction = IRP_MJ_READ;
		   irpNextStack->Parameters.Read.Length = (ULONG)(*pLengthOut);
		   break;
   }

   status = IoCallDriver(port_config[Handle].pSerialPortDevice,irp);

   if (status == STATUS_PENDING) 
   {
      timeout.QuadPart = -((LONGLONG) CmdTimeout*10*1000);
      status = KeWaitForSingleObject(&event, 
												 Suspended, 
                           			 KernelMode, 
                           			 FALSE, 
                           			 &timeout);
      if (status == STATUS_TIMEOUT) 
      {
         IoCancelIrp(irp);
         KeWaitForSingleObject(&event, 
										 Suspended, 
										 KernelMode, 
										 FALSE, 
										 NULL);
      }
   }

   status = ioStatus.Status;

   switch (SerialIoControlCode) 
   {
      case GTSER_IOCTL_WRITE:
         if (ioStatus.Status == STATUS_TIMEOUT) 
         {
	         // STATUS_TIMEOUT isn't correctly mapped 
	         // to a WIN32 error, that's why we change it here to STATUS_IO_TIMEOUT
	         status = STATUS_IO_TIMEOUT;
         } 
         break;

      case GTSER_IOCTL_READ:
         if (ioStatus.Status == STATUS_TIMEOUT) 
         {
	         // STATUS_TIMEOUT isn't correctly mapped 
	         // to a WIN32 error, that's why we change it here to STATUS_IO_TIMEOUT
	         status = STATUS_IO_TIMEOUT;
	         *pLengthOut = 0;
         } 
         break;

      default:
	      *pLengthOut = (WORD16)(ioStatus.Information);
         break;
	}
	return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_SetCommState
* (
*    const INT16         Handle,
*    SERIAL_READER_CONFIG *SerialConfig
* )
*
* Description :
* -------------
*    This routine will appropriately configure the serial port.
*    It makes synchronous calls to the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
NTSTATUS GDDKNT_SetCommState
(
	const INT16         Handle,
	SERIAL_READER_CONFIG *SerialConfig
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
USHORT 
   i;
ULONG
	SerialIoControlCode;
WORD16
	LengthIn,
	LengthOut;
PUCHAR 
   pBufferIn;

   ASSERT(SerialConfig != NULL);
	for (i=0; NT_SUCCESS(status); i++) 
   {
      switch (i) 
      {
		   case 0:
			   // Set up baudrate 
			   SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
			   pBufferIn = (PUCHAR)&SerialConfig->BaudRate;
				LengthIn = sizeof(SERIAL_BAUD_RATE);
				break;

	      case 1:
	            // Set up line control parameters
			   SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
			   pBufferIn = (PUCHAR)&SerialConfig->LineControl;
				LengthIn = sizeof(SERIAL_LINE_CONTROL);
	         break;

	      case 2:
	         // Set serial special characters
				SerialIoControlCode = IOCTL_SERIAL_SET_CHARS;
		    	pBufferIn = (PUCHAR)&SerialConfig->SerialChars;
				LengthIn = sizeof(SERIAL_CHARS);
	         break;

	      case 3:
	         // Set up timeouts
				SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
			   pBufferIn = (PUCHAR)&SerialConfig->Timeouts;
				LengthIn = sizeof(SERIAL_TIMEOUTS);
	         break;

	      case 4:
	         // Set flowcontrol and handshaking
				SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;
			   pBufferIn = (PUCHAR)&SerialConfig->HandFlow;
				LengthIn = sizeof(SERIAL_HANDFLOW);
	         break;

	      case 5:
	         // Set break off
			   SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
				LengthIn = 0;
	         break;

         case 6:
			   return STATUS_SUCCESS;
		}

		LengthOut = 0;
		status = GDDKNT_SerPortIoRequest(Handle,
													 SerialIoControlCode,
													 500UL,
													 LengthIn,
													 pBufferIn,
													 &LengthOut,
													 NULL);
    }

    return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_GetCommState
* (
*    const INT16         Handle,
*    SERIAL_READER_CONFIG *SerialConfig
* )
*
* Description :
* -------------
*    This routine will appropriately configure the serial port.
*    It makes synchronous calls to the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
NTSTATUS GDDKNT_GetCommState
(
	const INT16         Handle,
	SERIAL_READER_CONFIG *SerialConfig
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
USHORT 
   i;
ULONG
	SerialIoControlCode;
WORD16
	LengthOut;
PUCHAR 
   pBufferOut;

   ASSERT(SerialConfig != NULL);
	for (i=0; NT_SUCCESS(status); i++) 
   {
      switch (i) 
      {

		   case 0:
			   // Get up baudrate 
			   SerialIoControlCode = IOCTL_SERIAL_GET_BAUD_RATE;
			   pBufferOut = (PUCHAR)&SerialConfig->BaudRate;
				LengthOut = sizeof(SERIAL_BAUD_RATE);
				break;

	      case 1:
	         // Get up line control parameters
			   SerialIoControlCode = IOCTL_SERIAL_GET_LINE_CONTROL;
			   pBufferOut = (PUCHAR)&SerialConfig->LineControl;
				LengthOut = sizeof(SERIAL_LINE_CONTROL);
	         break;

	      case 2:
	         // Get serial special characters
				SerialIoControlCode = IOCTL_SERIAL_GET_CHARS;
		    	pBufferOut = (PUCHAR)&SerialConfig->SerialChars;
				LengthOut = sizeof(SERIAL_CHARS);
	         break;

	      case 3:
	         // Get up timeouts
				SerialIoControlCode = IOCTL_SERIAL_GET_TIMEOUTS;
			   pBufferOut = (PUCHAR)&SerialConfig->Timeouts;
				LengthOut = sizeof(SERIAL_TIMEOUTS);
	         break;

	      case 4:
	         // Get flowcontrol and handshaking
				SerialIoControlCode = IOCTL_SERIAL_GET_HANDFLOW;
			   pBufferOut = (PUCHAR)&SerialConfig->HandFlow;
				LengthOut = sizeof(SERIAL_HANDFLOW);
	         break;

	      case 5:
			   return STATUS_SUCCESS;
		}

		status = GDDKNT_SerPortIoRequest(Handle,
													 SerialIoControlCode,
													 500UL,
													 0,
													 NULL,
													 &LengthOut,
													 pBufferOut);
    }

    return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_SetupComm
* (
*    const INT16         Handle,
*    const ULONG         InSize,
*    const ULONG         OutSize
* )
*
* Description :
* -------------
*    This routine will appropriately resize the driver's internal typeahead 
*    and input buffers of the serial port.
*    It makes synchronous calls to the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - InSize  is the input  buffer size.
*  - OutSize is the output buffer size.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
static NTSTATUS GDDKNT_SetupComm
(
	const INT16         Handle,
	const ULONG         InSize,
	const ULONG         OutSize
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
SERIAL_QUEUE_SIZE 
   SerialQueueSize;
WORD16 
   LengthOut = 0;

	// Set up queue size
	SerialQueueSize.InSize  = InSize;
	SerialQueueSize.OutSize = OutSize;

	status = GDDKNT_SerPortIoRequest(Handle,
												 IOCTL_SERIAL_SET_QUEUE_SIZE,
												 500UL,
												 sizeof(SERIAL_QUEUE_SIZE),
												 (PUCHAR)&SerialQueueSize,
												 &LengthOut,
												 NULL);

   return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_GetCommStatus
* (
*    const INT16         Handle,
*    SERIAL_STATUS       *SerialStatus
* )
*
* Description :
* -------------
*    This routine will appropriately get status information of the serial port.
*    It makes synchronous calls to the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*
* Out         :
* -------------
*  - SerialStatus is the pointer to the status information returned.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
static NTSTATUS GDDKNT_GetCommStatus
(
	const INT16         Handle,
	SERIAL_STATUS       *SerialStatus
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
WORD16 
   LengthOut;

   ASSERT(SerialStatus != NULL);
	LengthOut = sizeof(SERIAL_STATUS);
	status = GDDKNT_SerPortIoRequest(Handle,
												 IOCTL_SERIAL_GET_COMMSTATUS,
												 500UL,
												 0,
												 NULL,
												 &LengthOut,
												 (PUCHAR)SerialStatus);

   return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_ResetComm
* (
*    const INT16         Handle
* )
*
* Description :
* -------------
*    This routine will appropriately get status information of the serial port.
*    It makes synchronous calls to the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
static NTSTATUS GDDKNT_ResetComm
(
	const INT16         Handle
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
WORD16 
   LengthOut = 0;

	status = GDDKNT_SerPortIoRequest(Handle,
												 IOCTL_SERIAL_RESET_DEVICE,
												 500UL,
												 0,
												 NULL,
												 &LengthOut,
												 NULL);

   return status;
}

/******************************************************************************
* NTSTATUS GDDKNT_PurgeComm
* (
*    const INT16         Handle,
*    const ULONG         Select
* )
*
* Description :
* -------------
*    This routine flush the data in the serial port.
*
* Remarks     :
* -------------
* Nothing.
*
* In          :
* -------------
*  - Handle holds the port handle.
*  - Select holds the buffers to clear:
*       SERIAL_PURGE_TXCLEAR
*       SERIAL_PURGE_RXCLEAR
*       SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR
*
* Out         :
* -------------
* Nothing.
*
* Responses   :
* -------------
* If everything is Ok:
*    STATUS_SUCCESS               (   0).
*  
*******************************************************************************/
static NTSTATUS GDDKNT_PurgeComm
(
	const INT16         Handle,
	const ULONG         Select
)
{
NTSTATUS 
   status = STATUS_SUCCESS;
ULONG
   PurgeMask = Select;
WORD16 
   LengthOut = 0;

	status = GDDKNT_SerPortIoRequest(Handle,
												 IOCTL_SERIAL_PURGE,
												 500UL,
												 sizeof(PurgeMask),
												 (PUCHAR)&PurgeMask,
												 &LengthOut,
												 NULL);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gntscr0a.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
   GNTSCR0A.C (Gemplus NT Smart Card Reader module for GCR410P )

Description :
   This is the main module which holds the main functions for a standard NT driver

Environment:
   Kernel mode

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development. Pnp support.
   14/04/98: V1.00.002  (GPZ)
      - Updated for Power Management support.
   19/05/98: V1.00.003  (GPZ)
      - Updated for the GemCore 1.11-3 version.
   28/05/98: V1.00.004  (GPZ)
      - The reference to PRTL_REMOVE_LOCK is removed.
   03/06/98: V1.00.005  (GPZ)
      - After a power down, the card state is updated.
   08/06/98: V1.00.006  (GPZ)
   18/06/98: V1.00.007  (GPZ)
      - The functions which use KeAcquireSpinLock/KeAcquireCancelSpinlock
      must be NOT PAGEABLE.
     - Modification of GCR410PPnPDeviceControl.
     - Modification of GCR410PPowerDeviceControl to support completly the
     request of the power management.
   16/07/98: V1.00.008  (GPZ)
      - To update the card state, we use a System Worker Thread which is called
     like a callback function only when an RING Irq occurs. The thread terminates
     immediately.
   17/07/98: V1.00.009  (GPZ)
      - The Interface state is set to true at the end of StartDevice.
   06/08/98: V1.00.010  (GPZ)
      - If the StartDevice failed and the serial port is openned, we close
     the serial port instead of call the WaitForDeviceRemoval function.
   11/09/98: V1.00.011  (GPZ)
      - GCR410PDeviceControl, GCR410PPnPDeviceControl and GCR410PPowerDeviceControl
      updated to block all incoming Ioctls as long as the reader is
      in stand by/hibernation mode.
      - All functions which use SpinLock cannot be Pageable.
   13/09/98: V1.00.012  (GPZ)
      - Check if the CardStatus thread runs before to close the serial port.
--*/


#include <stdio.h>
#include "gntscr.h"
#include "gntscr0a.h"
#include "gntser.h"

//
// Pragma section:
//
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGEABLE,GCR410PStartSerialEventTracking)
#pragma alloc_text(PAGEABLE,GCR410PStopSerialEventTracking)
#pragma alloc_text(PAGEABLE,GCR410PAddDevice)
#pragma alloc_text(PAGEABLE,GCR410PCreateDevice)
#pragma alloc_text(PAGEABLE,GCR410PStartDevice)
#pragma alloc_text(PAGEABLE,GCR410PStopDevice)
#pragma alloc_text(PAGEABLE,GCR410PRemoveDevice)
#pragma alloc_text(PAGEABLE,GCR410PDriverUnload)

#if DBG
#pragma optimize ("",off)
#endif

//
// Constant section:
//   - GCR410P_DRIVER_VERSION is the current version of the driver
//   - MAX_DEVICES is the maximum number of devices (and instances) we want
//      to support
//
#define GCR410P_DRIVER_VERSION  0x0112
//ISV
#define MAX_DEVICES  50

//
// Global variable section:
//   - ulMaximalBaudRate defines the maximal baud rate for the reader.
//   - bDevicePort is an array of boolean to signals if a device is
//     already created.
//
ULONG
   ulMaximalBaudRate;

BOOLEAN    bDevicePort[MAX_DEVICES];

NTSTATUS
DriverEntry(
   IN  PDRIVER_OBJECT  DriverObject,
   IN  PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

   DriverObject   - supplies the driver object.
   RegistryPath   - supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS               - We could initialize at least one device.

--*/
{
   NTSTATUS status;
   RTL_QUERY_REGISTRY_TABLE paramTable[4];
   UNICODE_STRING driverPath;
   WCHAR buffer[MAXIMUM_FILENAME_LENGTH];

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!DriverEntry: Enter - version: %X - %s %s\n",
      SC_DRIVER_NAME,
      GCR410P_DRIVER_VERSION,
      __DATE__,
      __TIME__)
      );

    //
    // we do some stuff in this driver that
    // assumes a single digit port number
    //
    // Initialize the Driver Object with driver's entry points
   //
   DriverObject->DriverUnload =                         GCR410PDriverUnload;
   DriverObject->DriverExtension->AddDevice =           GCR410PAddDevice;
   DriverObject->MajorFunction[IRP_MJ_CREATE] =         GCR410PCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] =          GCR410PCreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] =        GCR410PCleanup;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = GCR410PDeviceControl;
   DriverObject->MajorFunction[IRP_MJ_PNP] =            GCR410PPnPDeviceControl;
   DriverObject->MajorFunction[IRP_MJ_POWER] =          GCR410PPowerDeviceControl;


   //
   // Read in the the driver registry path "MaximalBaudRate".
   //
   ulMaximalBaudRate = 0;
   RtlZeroMemory(paramTable,sizeof(paramTable));
   paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
   paramTable[0].Name = L"MaximalBaudRate";
   paramTable[0].EntryContext = &ulMaximalBaudRate;
   paramTable[0].DefaultType = REG_DWORD;
   paramTable[0].DefaultData = &ulMaximalBaudRate;
   paramTable[0].DefaultLength = sizeof(ULONG);

   driverPath.Buffer = buffer;
   driverPath.MaximumLength = sizeof(buffer);
   driverPath.Length = 0;

   RtlCopyUnicodeString(&driverPath,RegistryPath);

   status = RtlQueryRegistryValues(
      RTL_REGISTRY_ABSOLUTE,
      driverPath.Buffer,
      &paramTable[0],
      NULL,
      NULL
      );
   if ((ulMaximalBaudRate !=  9600lu) && (ulMaximalBaudRate != 19200lu) &&
       (ulMaximalBaudRate != 38400lu)
       ) {

       ulMaximalBaudRate = IFD_STANDARD_BAUD_RATE;
   }


   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!DriverEntry: Exit\n",
      SC_DRIVER_NAME)
      );
   return STATUS_SUCCESS;
}

NTSTATUS
GCR410PAddDevice(
   IN PDRIVER_OBJECT  DriverObject,
   IN PDEVICE_OBJECT  PhysicalDeviceObject
   )
/*++

Routine Description:

    This is the add-device routine.

Arguments:

   DriverObject         - points to the driver object representing the driver.
   PhysicalDeviceObject - points to the PDO for the PnP device being added.

Return Value:

    STATUS_SUCCESS               - We could initialize at least one device.
    STATUS_UNSUCCESSFUL          - We cannot connect the device to PDO.

--*/
{
   NTSTATUS status;
   PDEVICE_OBJECT DeviceObject = NULL;

   PAGED_CODE();

   ASSERT(DriverObject != NULL);
   ASSERT(PhysicalDeviceObject != NULL);
   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PAddDevice: Enter\n",
      SC_DRIVER_NAME)
      );


   __try {

      PDEVICE_EXTENSION deviceExtension;

      //
      // Try to create a device .
      //
      status = GCR410PCreateDevice(
         DriverObject,
         PhysicalDeviceObject,
         &DeviceObject
         );
      if (status != STATUS_SUCCESS) {

         SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GCR410PAddDevice: GCR410PCreateDevice=%X(hex)\n",
            SC_DRIVER_NAME,
            status)
            );
         __leave;
      }
      //
      // Attach the PhysicalDeviceObject to the new created device.
      //
      deviceExtension = DeviceObject->DeviceExtension;
      ATTACHED_DEVICE_OBJECT = IoAttachDeviceToDeviceStack(
          DeviceObject,
          PhysicalDeviceObject
          );

      if (ATTACHED_DEVICE_OBJECT == NULL) {

         SmartcardLogError(
            DriverObject,
            GEM_CANT_CONNECT_TO_ASSIGNED_PORT,
            NULL,
            0
            );
         status = STATUS_UNSUCCESSFUL;
         __leave;
      }

      //
      // Register our new device object
      //
      status = IoRegisterDeviceInterface(
         PhysicalDeviceObject,
         &SmartCardReaderGuid,
         NULL,
         &deviceExtension->PnPDeviceName
         );
        ASSERT(status == STATUS_SUCCESS);

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
   }
   __finally {

      if (status != STATUS_SUCCESS) {

         GCR410PRemoveDevice(DeviceObject);
      }
   }
   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PAddDevice: Exit=%X(hex)\n",
      SC_DRIVER_NAME,
      status
      )
      );
   return status;
}

NTSTATUS
GCR410PCreateDevice(
   IN  PDRIVER_OBJECT      DriverObject,
   IN  PDEVICE_OBJECT      PhysicalDeviceObject,
   OUT PDEVICE_OBJECT      *DeviceObject
   )
/*++

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.

Arguments:

   DriverObject         - points to the driver object representing the driver.
   PhysicalDeviceObject - points to the PDO for the PnP device being added.
   DeviceObject         - the device created.

Return Value:

    STATUS_SUCCESS      - device created.
--*/
{
   PDEVICE_EXTENSION deviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   ULONG nDeviceNumber;
   PREADER_EXTENSION readerExtension;
   PSMARTCARD_EXTENSION smartcardExtension;

   PAGED_CODE();

   ASSERT(DriverObject != NULL);
   ASSERT(PhysicalDeviceObject != NULL);

   *DeviceObject = NULL;
   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PCreateDevice: Enter\n",
      SC_DRIVER_NAME)
      );

   for( nDeviceNumber = 0; nDeviceNumber < MAX_DEVICES; nDeviceNumber++ ) {

      if (bDevicePort[nDeviceNumber] == FALSE) {

         bDevicePort[nDeviceNumber] = TRUE;
         break;
      }
   }

   if (nDeviceNumber == MAX_DEVICES) {

      status = STATUS_INSUFFICIENT_RESOURCES;
      SmartcardDebug(
         DEBUG_ERROR,
         ("%s!GCR410PCreateDevice: Insufficient ressources\n",
         SC_DRIVER_NAME)
         );
      SmartcardLogError(
         DriverObject,
         GEM_CANT_CREATE_MORE_DEVICES,
         NULL,
         0
         );
        return STATUS_INSUFFICIENT_RESOURCES;
   }

   //
   // Try to create a new device smart card object
   //
   status = IoCreateDevice(
      DriverObject,
      sizeof(DEVICE_EXTENSION),
      NULL,
      FILE_DEVICE_SMARTCARD,
      0,
      TRUE,
      DeviceObject
      );
   SmartcardDebug(
      DEBUG_TRACE,
      ("%s!GCR410PCreateDevice: IoCreateDevice status =%X(hex)\n",
      SC_DRIVER_NAME,
      status)
      );
   if (!NT_SUCCESS(status)) {

      SmartcardLogError(
         DriverObject,
         GEM_CANT_CREATE_DEVICE,
         NULL,
         0
         );
      return status;
   }
   ASSERT(*DeviceObject != NULL);
   //
   // Now we have a pointer on the new device.
   //
   deviceExtension = (*DeviceObject)->DeviceExtension;
   ASSERT(deviceExtension != NULL);

   // This event signals Start/Stop notification
   KeInitializeEvent(
      &deviceExtension->ReaderStarted,
      NotificationEvent,
      FALSE
      );
   // This event signals that the serial driver has been closed
   KeInitializeEvent(
      &deviceExtension->SerialCloseDone,
      NotificationEvent,
      TRUE
      );
   // This event signals that the card status thread is scheduled
   KeInitializeEvent(
      &deviceExtension->CardStatusNotInUse,
      NotificationEvent,
      TRUE
      );

   // Used to keep track of open close calls
   deviceExtension->ReaderOpen = FALSE;

    // SpinLock used to manage the card state
   KeInitializeSpinLock(&deviceExtension->SpinLock);

   // Thread that waits the device removal
   deviceExtension->CloseSerial = IoAllocateWorkItem(
      *DeviceObject
      );
    // Thread which will be called when a card state change will occur.
   deviceExtension->CardStateChange = IoAllocateWorkItem(
      *DeviceObject
      );
   // We try to allocate memory for the ReaderExtension struct.
   smartcardExtension = &deviceExtension->SmartcardExtension;
   smartcardExtension->ReaderExtension = ExAllocatePool(
      NonPagedPool,
      sizeof(READER_EXTENSION)
      );

   if (deviceExtension->SmartcardExtension.ReaderExtension == NULL ||
        deviceExtension->CardStateChange == NULL ||
        deviceExtension->CloseSerial == NULL) {

      SmartcardLogError(
         DriverObject,
         GEM_NO_MEMORY,
         NULL,
         0
         );
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   readerExtension = smartcardExtension->ReaderExtension;
   RtlZeroMemory(
      readerExtension,
      sizeof(READER_EXTENSION)
      );

   // Write the version of the lib we use to the smartcard extension
   smartcardExtension->Version = SMCLIB_VERSION;

   // Now let the lib allocate the buffer for data transmission
   smartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
   smartcardExtension->SmartcardReply.BufferSize =   MIN_BUFFER_SIZE;
   status = SmartcardInitialize(smartcardExtension);
    SmartcardDebug(
      DEBUG_TRACE,
      ("%s!GCR410PCreateDevice: SmartcardInitialize=%lX(hex)\n",
      SC_DRIVER_NAME,
      status)
      );
   if (status != STATUS_SUCCESS) {

      SmartcardLogError(
         DriverObject,
         (smartcardExtension->OsData ? GEM_WRONG_LIB_VERSION : GEM_NO_MEMORY),
         NULL,
         0
         );
      return status;
   }
   smartcardExtension->VendorAttr.UnitNo = nDeviceNumber;

   // Save the deviceObject
   deviceExtension->SmartcardExtension.OsData->DeviceObject = *DeviceObject;
   //
   // Set up the call back functions
   //  (nota: RDF_CARD_EJECT and RDF_READER_SWALLOW are not supported)
   //
   smartcardExtension->ReaderFunction[RDF_TRANSMIT] = GDDK_0ATransmit;
   smartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = GDDK_0ASetProtocol;
   smartcardExtension->ReaderFunction[RDF_CARD_POWER] = GDDK_0AReaderPower;
   smartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = GDDK_0ACardTracking;
   smartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] = GDDK_0AVendorIoctl;

    // save the current power state of the reader
    smartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;


   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PCreateDevice: Exit=%X(hex)\n",
      SC_DRIVER_NAME,
      status)
      );
   return status;
}


NTSTATUS
GCR410PStartDevice(
   IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
   Open the serial device, start card tracking and register our
    device interface. If any of the calls here fails we don't care
    to rollback since a stop will be called later which we then
    use to clean up.

--*/
{
    NTSTATUS status;
    PIRP irp;
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PStartDevice: Enter\n",
      SC_DRIVER_NAME)
      );

   irp = IoAllocateIrp(
      (CCHAR) (DeviceObject->StackSize + 1),
      FALSE
      );

   ASSERT(irp != NULL);

   if (irp == NULL) {

      SmartcardDebug(
         DEBUG_ERROR,
         ("%s!GCR410PStartDevice: IoAllocateIrp failed!\n",
         SC_DRIVER_NAME)
         );
      SmartcardLogError(
         DeviceObject,
         GEM_NO_MEMORY,
         NULL,
         0
         );
      return STATUS_NO_MEMORY;
   }

   __try {

      PIO_STACK_LOCATION irpStack;
      IO_STATUS_BLOCK ioStatusBlock;

      //
      // Open the underlying serial driver.
      // This is necessary for two reasons:
      // a) The serial driver can't be used without opening it
      // b) The call will go through serenum first which informs
      //    it to stop looking/polling for new devices.
      //
      irp->UserIosb = &ioStatusBlock;
      IoSetNextIrpStackLocation(irp);
      irpStack = IoGetCurrentIrpStackLocation(irp);

      irpStack->MajorFunction = IRP_MJ_CREATE;
      irpStack->Parameters.Create.Options = 0;
      irpStack->Parameters.Create.ShareAccess = 0;
      irpStack->Parameters.Create.FileAttributes = 0;
      irpStack->Parameters.Create.EaLength = 0;

      status = GCR410PCallSerialDriver(
         ATTACHED_DEVICE_OBJECT,
         irp
         );

      if (status != STATUS_SUCCESS) {

         if (status == STATUS_SHARED_IRQ_BUSY) {

            SmartcardLogError(
               DeviceObject,
               GEM_SHARED_IRQ_BUSY,
               NULL,
               0
               );
         }

         __leave;
      }
      // The serial port is openned
        KeClearEvent(&deviceExtension->SerialCloseDone);

      // Open the communication with the reader
      status = GDDK_0AOpenChannel(
         &deviceExtension->SmartcardExtension,
         deviceExtension->SmartcardExtension.VendorAttr.UnitNo, //Device number
         deviceExtension->SmartcardExtension.VendorAttr.UnitNo,
         ulMaximalBaudRate
         );
      SmartcardDebug(
         DEBUG_TRACE,
         ("%s!GCR410PStartDevice: GDDK_0AOpenChannel=%X(hex)\n",
         SC_DRIVER_NAME,
         status)
         );

      if (status != STATUS_SUCCESS) {

            if (status == STATUS_BAD_DEVICE_TYPE) {

            SmartcardLogError(
               DeviceObject,
               GEM_IFD_BAD_VERSION,
               NULL,
               0
               );
            } else {

            SmartcardLogError(
               DeviceObject,
               GEM_IFD_COMMUNICATION_ERROR,
               NULL,
               0
               );
            }
            __leave;
      }

        // Start the serial event tracking (DSR and RING events)
      status = GCR410PStartSerialEventTracking(&deviceExtension->SmartcardExtension);
      if (status != STATUS_SUCCESS) {

         SmartcardLogError(
            DeviceObject,
            GEM_START_SERIAL_EVENT_TRACKING_FAILED,
            NULL,
            0
            );
         __leave;
      }

        // Set the Device Interface state to True
        status = IoSetDeviceInterfaceState(
         &deviceExtension->PnPDeviceName,
         TRUE
         );

        if (status != STATUS_SUCCESS) {

            SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GCR410PStartDevice: IoSetDeviceInterfaceState failed!\n",
            SC_DRIVER_NAME)
            );
            SmartcardLogError(
            DeviceObject,
            GEM_SET_DEVICE_INTERFACE_STATE_FAILED,
            NULL,
            0
            );
         __leave;
      }
        // Set the ReaderStarted event.
      KeSetEvent(&deviceExtension->ReaderStarted,0,FALSE);
   }
   __finally {

      if (status != STATUS_SUCCESS) {

         PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

         SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GCR410PStartDevice: failed!\n",
            SC_DRIVER_NAME)
            );
            // If we have failed, then we call the StopDevice to undo all we have done here.
            GCR410PStopDevice(DeviceObject);

      }
      IoFreeIrp(irp);
   }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PStartDevice: Exit=%X(hex)\n",
      SC_DRIVER_NAME,
      status)
      );

   return status;
}


VOID
GCR410PStopDevice(
    IN PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
    Finishes card tracking requests and closes the connection to the
    serial driver.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension;
    LARGE_INTEGER timeout;

    PAGED_CODE();

    ASSERT(DeviceObject != NULL);

    deviceExtension = DeviceObject->DeviceExtension;
    smartcardExtension = &deviceExtension->SmartcardExtension;

   ASSERT(smartcardExtension != NULL);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PStopDevice: Enter\n",
      SC_DRIVER_NAME)
      );

   // If the serial port is not yet closed.
   if (KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l) {

      NTSTATUS status;

        // Close the communication with the reader
        status = GDDK_0ACloseChannel(
            smartcardExtension
            );
      SmartcardDebug(
         DEBUG_TRACE,
         ("%s!GCR410PStopDevice: GDDK_0ACloseChannel=%X(hex)\n",
         SC_DRIVER_NAME,
         status)
         );
        // test if we ever started event tracking
        if (smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0) {

            // We 'only' need to close the serial port
            GCR410PCloseSerialPort(DeviceObject, NULL);

        } else {

            // We now inform the serial driver that we're not longer
          // interested in serial events. This will also free the irp
          // we use for those io-completions
          // This will also create an event which will close the serial port.
            status = GCR410PStopSerialEventTracking(smartcardExtension);

          // now wait until the connection to serial is closed
         // timeout.QuadPart = -((LONGLONG) HOR3COMM_CHAR_TIME*10*1000);
         status = KeWaitForSingleObject(
            &deviceExtension->SerialCloseDone,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
          //ASSERT(status == STATUS_SUCCESS);
         if(status != STATUS_SUCCESS)
         {
            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!GCR410PStopDevice: Failed waiting to close...\n",
               SC_DRIVER_NAME)
               );
         }
        }
    }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PStopDevice: Exit\n",
      SC_DRIVER_NAME)
      );
}


NTSTATUS
GCR410PDeviceControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp
   )
/*++

Routine Description:
    This is our IOCTL dispatch function

--*/
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   KIRQL irql;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    LARGE_INTEGER timeout;

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PDeviceControl: Enter\n",
      SC_DRIVER_NAME)
      );

   if (smartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0)
   {
      SmartcardDebug(
         DEBUG_ERROR,
         ( "%s!GCR410PDeviceControl: Exit (Reader was removed or power down!)\n",
         SC_DRIVER_NAME)
         );

      // the wait mask is set to 0 whenever the device was either
      // surprise-removed or politely removed
      status = STATUS_DEVICE_REMOVED;
      return status;
   }

   KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
   if (deviceExtension->IoCount == 0) {

      KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

        //timeout.QuadPart = -((LONGLONG) HOR3COMM_CHAR_TIME*10*1000);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

      ASSERT(status == STATUS_SUCCESS);
      KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
   }
   ASSERT(deviceExtension->IoCount >= 0);
   deviceExtension->IoCount++;
   KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

   status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'tcoI');
   if (status != STATUS_SUCCESS) {

      // the device has been removed. Fail the call
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return STATUS_DEVICE_REMOVED;
   }

   status = SmartcardDeviceControl(
      &(deviceExtension->SmartcardExtension),
      Irp
      );
   SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'tcoI');

   KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
   deviceExtension->IoCount--;
   ASSERT(deviceExtension->IoCount >= 0);
   KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PDeviceControl: Exit=%X(hex)\n",
      SC_DRIVER_NAME,
      status)
      );

   return status;
}


VOID
GCR410PCloseSerialPort(
   IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
   )
/*++

Routine Description:

    This function closes the connection to the serial driver when the reader
    has been removed (unplugged). This function runs as a system thread at
    IRQL == PASSIVE_LEVEL. It waits for the remove event that is set by
    the IoCompletionRoutine

Arguments:

   DeviceObject   - is a pointer to the device.

Return Value:

    Nothing
--*/
{
   PDEVICE_EXTENSION deviceExtension;
   NTSTATUS status;
   PIRP irp;
   PIO_STACK_LOCATION irpStack;
   IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER timeout;

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PCloseSerialPort: Enter\n",
      SC_DRIVER_NAME)
      );

    ASSERT(DeviceObject!=NULL);

    deviceExtension = DeviceObject->DeviceExtension;

    ASSERT(KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l);

   //
   // first mark this device as 'gone'.
   // This will prevent that someone can re-open the device
    // We intentionally ignore possible errors
   //
   IoSetDeviceInterfaceState(
      &deviceExtension->PnPDeviceName,
      FALSE
      );

   // wait until the card status thread is running
   //timeout.QuadPart = -((LONGLONG) HOR3COMM_CHAR_TIME*10*1000);
   status = KeWaitForSingleObject(
      &deviceExtension->CardStatusNotInUse,
      Executive,
      KernelMode,
      FALSE,
      NULL
      );
   ASSERT(status == STATUS_SUCCESS);
   if(status != STATUS_SUCCESS)
   {
   SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!GCR410PCloseSerialPort: Failed waiting to stop thread...\n",
         SC_DRIVER_NAME)
         );
   }

   irp = IoAllocateIrp(
      (CCHAR) (DeviceObject->StackSize + 1),
      FALSE
      );
   ASSERT(irp != NULL);
   if (irp) {

      IoSetNextIrpStackLocation(irp);
      // We send down a close to the serial driver. This close goes
      // througt Serenum first which will trigger it to start looking
      // for changes on the com-port. Since our device is gone it will
      // call the device removal event of our PnP dispatch.
      irp->UserIosb = &ioStatusBlock;
      irpStack = IoGetCurrentIrpStackLocation(irp);
      irpStack->MajorFunction = IRP_MJ_CLOSE;

      status = GCR410PCallSerialDriver(
         deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject,
         irp
         );

      SmartcardDebug(
         DEBUG_TRACE,
         ("%s!GCR410PCloseSerialPort: Send IRP_MJ_CLOSE to the serial device=%lX\n",
         SC_DRIVER_NAME,
         status)
         );

      IoFreeIrp(irp);
   }

   // Informs that the serial port is closed
   KeSetEvent(
      &deviceExtension->SerialCloseDone,
      0,
      FALSE
      );

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PCloseSerialPort: Exit\n",
      SC_DRIVER_NAME)
      );
}


VOID
GCR410PWaitForCardStateChange(
   IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
   )
/*++

Routine Description:

   This function send a command to the reader to known the card status. This
   function runs as a system thread at IRQL == PASSIVE_LEVEL. It waits for
   the CardStateChange event that it set by the IoCompletionRoutine.

Arguments:

   DeviceObject   - is a pointer to the device.

Return Value:

    Nothing
--*/
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PWaitForCardStateChange: Enter\n",
        SC_DRIVER_NAME)
      );

   smartcardExtension = &deviceExtension->SmartcardExtension;
   ASSERT(smartcardExtension != NULL);

   //ISV
   // If device is not ready - do not run exchange!
   if(smartcardExtension->ReaderExtension->ReaderPowerState != PowerReaderWorking)
   {

      SmartcardDebug(
         DEBUG_ERROR,
         ( "%s!GCR410PWaitForCardStateChange: Exit (reader is not ready yet!)\n",
         SC_DRIVER_NAME)
         );

      // Informs that the card status update is done
      KeSetEvent(
         &deviceExtension->CardStatusNotInUse,
         0,
         FALSE
         );
      return;
   }

    // Protect the exchange
   GDDK_0ALockExchange(smartcardExtension);
    if (GDDK_0AUpdateCardStatus(smartcardExtension) == STATUS_SUCCESS) {

        // Complete the card tracking except if we are in a
        // power up - power down cycle (Power Management)
       if (smartcardExtension->ReaderExtension->PowerRequest == FALSE) {

            GCR410PCompleteCardTracking(smartcardExtension);
        }
    }
   GDDK_0AUnlockExchange(smartcardExtension);

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PWaitForCardStateChange: Exit\n",
        SC_DRIVER_NAME)
      );

   // Informs that the card status update is done
   KeSetEvent(
      &deviceExtension->CardStatusNotInUse,
      0,
      FALSE
      );
}




NTSTATUS
GCR410PIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PKEVENT Event
   )
/*++

Routine Description:
   Completion routine for an Irp sent to the serial driver.
    It sets only an event that we can use to wait for.

--*/
{
   UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;

    } else {

        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
GCR410PCallSerialDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:
   Send an Irp to the serial driver.

--*/
{

   NTSTATUS status = STATUS_SUCCESS;
   KEVENT Event;

   // Copy our stack location to the next.
   IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. The event is passed
   // to our completion routine and will be set when the serial driver is done
   //
   KeInitializeEvent(
      &Event,
      NotificationEvent,
      FALSE
      );

   // Our IoCompletionRoutine sets only our event
   IoSetCompletionRoutine (
      Irp,
      GCR410PIoCompletion,
      &Event,
      TRUE,
      TRUE,
      TRUE
      );

   if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

      status = PoCallDriver(DeviceObject, Irp);

   } else {

      // Call the serial driver
      status = IoCallDriver(DeviceObject, Irp);
   }

   // Wait until the serial driver has processed the Irp
   if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
      status = Irp->IoStatus.Status;
    }

   return status;
}




NTSTATUS
GCR410PPnPDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
   PDEVICE_OBJECT AttachedDeviceObject;
   PIO_STACK_LOCATION irpStack;
   BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
   KIRQL irql;

   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GCR410PPnPDeviceControl: Enter\n",
        SC_DRIVER_NAME)
      );

    status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, ' PnP');
   ASSERT(status == STATUS_SUCCESS);
   if (status != STATUS_SUCCESS) {

      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
   }

   AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

   Irp->IoStatus.Information = 0;
   irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
   switch(irpStack->MinorFunction)
   {
      case IRP_MN_START_DEVICE:

         SmartcardDebug(
            DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_START_DEVICE\n",
                SC_DRIVER_NAME)
                );

         // We have to call the underlying driver first
         status = GCR410PCallSerialDriver(AttachedDeviceObject, Irp);
         ASSERT(NT_SUCCESS(status));

         if (NT_SUCCESS(status)) {

            status = GCR410PStartDevice(DeviceObject);
         }
         break;

      case IRP_MN_QUERY_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

         KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
         if (deviceExtension->IoCount > 0) {

            // we refuse to stop if we have pending io
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = STATUS_DEVICE_BUSY;

         } else {

            // stop processing requests
            KeClearEvent(&deviceExtension->ReaderStarted);
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = GCR410PCallSerialDriver(AttachedDeviceObject, Irp);
         }
         break;

      case IRP_MN_CANCEL_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

         status = GCR410PCallSerialDriver(
                AttachedDeviceObject,
                Irp
                );

         if (status == STATUS_SUCCESS) {

            // we can continue to process requests
            KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
         }
         break;

      case IRP_MN_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

         GCR410PStopDevice(DeviceObject);

         //
         // we don't do anything since a stop is only used
         // to reconfigure hw-resources like interrupts and io-ports
         //
         status = GCR410PCallSerialDriver(
                AttachedDeviceObject,
                Irp
                );
         break;

      case IRP_MN_QUERY_REMOVE_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

         // disable the reader
         status = IoSetDeviceInterfaceState(
            &deviceExtension->PnPDeviceName,
            FALSE
            );
            ASSERT(NT_SUCCESS(status));

            if (!NT_SUCCESS(status)) {

                break;
            }

         // now look if someone is currently connected to us
         if (deviceExtension->ReaderOpen) {

                //
                // someone is connected, fail the call
                // we will enable the device interface in
                // IRP_MN_CANCEL_REMOVE_DEVICE again
                //
                status = STATUS_UNSUCCESSFUL;
                break;
         }

         // pass the call to the next driver in the stack
         status = GCR410PCallSerialDriver(AttachedDeviceObject, Irp);
         break;

      case IRP_MN_CANCEL_REMOVE_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

         status = GCR410PCallSerialDriver(
                AttachedDeviceObject,
                Irp
                );
         // reenable the interface only in case that the reader is
         // still connected. This covers the following case:
         // hibernate machine, disconnect reader, wake up, stop device
         // (from task bar) and stop fails since an app. holds the device open
         //
            if (status == STATUS_SUCCESS &&
            readerExtension->SerialConfigData.SerialWaitMask != 0)
         {
                status = IoSetDeviceInterfaceState(
                    &deviceExtension->PnPDeviceName,
                    TRUE
                    );

                ASSERT(status == STATUS_SUCCESS);
            }

         break;

      case IRP_MN_REMOVE_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PPnPDeviceControl: IRP_MN_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

         GCR410PRemoveDevice(DeviceObject);
         status = GCR410PCallSerialDriver(
                AttachedDeviceObject,
                Irp
                );

         deviceRemoved = TRUE;
         break;

      default:
         // This is an Irp that is only useful for underlying drivers
         SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GCR410PnPDeviceControl: IRP_MN_...%lx\n",
                SC_DRIVER_NAME,
                irpStack->MinorFunction)
                );

            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(AttachedDeviceObject, Irp);
            irpSkipped = TRUE;
         break;
   }

    if (irpSkipped == FALSE) {

      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    if (deviceRemoved == FALSE) {

      SmartcardReleaseRemoveLockWithTag(smartcardExtension, ' PnP');
    }
   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GCR410PPnPDeviceControl: Exit=%X(hex)\n",
        SC_DRIVER_NAME,
        status)
      );

    return status;
}

VOID
GCR410PSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    UNREFERENCED_PARAMETER (MinorFunction);

   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GCR410PSystemPowerCompletion: Enter\n",
        SC_DRIVER_NAME)
      );


    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = IoStatus->Status;

    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
    if (PowerState.SystemState == PowerSystemWorking) {

        PoSetPowerState (
            DeviceObject,
            SystemPowerState,
            PowerState
            );
    }

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GCR410PSystemPowerCompletion: Exit\n",
        SC_DRIVER_NAME)
      );
}


NTSTATUS
GCR410PDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;


    SmartcardDebug(
        DEBUG_DRIVER,
        ( "%s!GCR410PDevicePowerCompletion: Enter\n",
        SC_DRIVER_NAME)
        );

   //ISV
   // We've got power up request, so...
   // Report everybody that reader is powered up again!
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    // Restore the communication with the reader
    status = GDDK_0ARestoreCommunication(SmartcardExtension);

    //
    // We issue a power request in order to figure out
    // what the actual card status is
    //
    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
    GDDK_0AReaderPower(SmartcardExtension);

    //
    // If a card was present before power down or now there is
    // a card in the reader, we complete any pending card monitor
    // request, since we do not really know what card is now in the
    // reader.
    //
    if(SmartcardExtension->ReaderExtension->CardPresent ||
       SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {

        GCR410PCompleteCardTracking(SmartcardExtension);
    }


    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State
        );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    SmartcardDebug(
        DEBUG_DRIVER,
        ( "%s!GCR410PDevicePowerCompletion: Exit\n",
        SC_DRIVER_NAME)
        );
    return STATUS_SUCCESS;
}


NTSTATUS
GCR410PPowerDeviceControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action;


    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!GCR410PPowerDeviceControl: Enter\n",
        SC_DRIVER_NAME)
        );

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!GCR410PPowerDeviceControl: Irp = %lx\n",
        SC_DRIVER_NAME,
        Irp)
        );

    status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');
    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

   switch (irpStack->Parameters.Power.Type) {
   case DevicePowerState:
      if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

         switch (irpStack->Parameters.Power.State.DeviceState) {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!GCR410PPowerDeviceControl: PowerDevice D0\n",
                           SC_DRIVER_NAME)
                          );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   GCR410PDevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;

         case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!GCR410PPowerDeviceControl: PowerDevice D3\n",
                           SC_DRIVER_NAME)
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent) {

               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = GDDK_0AReaderPower(smartcardExtension);
               ASSERT(status == STATUS_SUCCESS);
            }

            //
            // If there is a pending card tracking request, setting
            // this flag will prevent completion of the request
            // when the system will be waked up again.
            //
            smartcardExtension->ReaderExtension->PowerRequest = TRUE;

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            ASSERT(FALSE);
            action = SkipRequest;
            break;
         }
      } else {
         ASSERT(FALSE);
         action = SkipRequest;
      }
      break;

   case SystemPowerState: {

         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

         POWER_STATE_TYPE powerType = DevicePowerState;

         ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                PowerReaderUnspecified);

         switch (irpStack->MinorFunction) {

         KIRQL irql;

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!GCR410PPowerDeviceControl: Query Power\n",
                           SC_DRIVER_NAME)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
               KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
               if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls
                  KeClearEvent(&deviceExtension->ReaderStarted);

               } else {

                  // can't go to sleep mode since the reader is busy.
                  status = STATUS_DEVICE_BUSY;
               }
               KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
               break;
            }

            action = CompleteRequest;
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_ERROR,
                          ("%s!GCR410PPowerDeviceControl: PowerSystem S%d\n",
                           SC_DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderWorking) {

                  // We're already in the right state
                  KeSetEvent(&deviceExtension->ReaderStarted,0,FALSE);
                  action = CompleteRequest;
                  break;
               }

               // wake up the underlying stack...
               powerState.DeviceState = PowerDeviceD0;
               action = MarkPending;
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderOff) {

                  // We're already in the right state
                  action = CompleteRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD3;

               // first, inform the power manager of our new state.
               PoSetPowerState (
                               DeviceObject,
                               SystemPowerState,
                               powerState
                               );
               action = MarkPending;
               break;

            default:
               ASSERT(FALSE);
               action = CompleteRequest;
               break;
            }
         }
      }
      break;

   default:
      ASSERT(FALSE);
      action = CompleteRequest;
      break;
   }


    switch (action) {

        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                GCR410PSystemPowerCompletion,
                Irp,
                NULL
                );
            ASSERT(status == STATUS_PENDING);
         break;

        case SkipRequest:

            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GCR410PPowerDeviceControl: Exit %lx\n",
        SC_DRIVER_NAME,
        status)
        );

    return status;
}



NTSTATUS
GCR410PCreateClose(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
   SmartcardDebug(
       DEBUG_DRIVER,
       ("%s!GCR410PCreateClose: Enter\n",
        SC_DRIVER_NAME)
       );

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,'lCrC');
         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!TLP3CreateClose: Open\n",
               DRIVER_NAME)
               );

         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,'lCrC');
         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!GCR410PCreateClose: Close\n",
            DRIVER_NAME)
            );

         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,'lCrC');

         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

   SmartcardDebug(
       DEBUG_DRIVER,
       ("%s!GCR410PCreateClose: Exit\n",
        SC_DRIVER_NAME)
       );
    return status;
}



NTSTATUS
GCR410PCancel(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

   This routine is called by the I/O system when the irp should be cancelled.

Arguments:

   DeviceObject   - is a pointer to the device.
   Irp            - holds the Irp involved.

Return Value:

    STATUS_CANCELLED          - the Irp is cancelled.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GCR410PCancel: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    GCR410PCompleteCardTracking(smartcardExtension);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GCR410PCancel: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_CANCELLED;
}




NTSTATUS
GCR410PCleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

  This routine is called by the I/O system when the device is closed.

Arguments:

   DeviceObject   - is a pointer to the device.
   Irp            - holds the Irp involved.

Return Value:

    STATUS_SUCCESS               - the request is completed
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GCR410PCleanup: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp != smartcardExtension->OsData->NotificationIrp);

    // We need to complete the notification irp
    GCR410PCompleteCardTracking(smartcardExtension);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GCR410PCleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
      );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT
      );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GCR410PCleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}


VOID
GCR410PRemoveDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

Routine Description:
    Remove the device from the system.

--*/
{
   PDEVICE_EXTENSION deviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension;

    PAGED_CODE();

   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GCR410PRemoveDevice: Enter\n",
      SC_DRIVER_NAME)
      );

    ASSERT(DeviceObject != NULL);

   if (DeviceObject == NULL) {

      SmartcardDebug(
         DEBUG_TRACE,
         ( "%s!GCR410PRemoveDevice: Exit immediatly (no device to remove)\n",
         SC_DRIVER_NAME)
         );

      return;
   }

   deviceExtension = DeviceObject->DeviceExtension;
   smartcardExtension = &deviceExtension->SmartcardExtension;

   if (smartcardExtension->OsData) {

      // complete pending card tracking requests (if any)
      GCR410PCompleteCardTracking(smartcardExtension);
      ASSERT(smartcardExtension->OsData->NotificationIrp == NULL);
      // Wait until we can safely unload the device
      SmartcardReleaseRemoveLockAndWait(smartcardExtension);
   }


   ASSERT(smartcardExtension->VendorAttr.UnitNo < MAX_DEVICES);
   ASSERT(bDevicePort[smartcardExtension->VendorAttr.UnitNo] == TRUE);

   // Mark this slot as available
   //bDevicePort[smartcardExtension->VendorAttr.UnitNo] = FALSE;

   GCR410PStopDevice(DeviceObject);

    if (deviceExtension->SmartcardExtension.ReaderExtension &&
        deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject) {

      IoDetachDevice(
            deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject
            );

       SmartcardDebug(
          DEBUG_TRACE,
          ( "%s!GCR410PRemoveDevice: IoDetachDevice\n",
          SC_DRIVER_NAME)
          );
   }

   if(deviceExtension->PnPDeviceName.Buffer) {

      RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
   }

   if(smartcardExtension->OsData) {

      SmartcardExit(smartcardExtension);
   }

   if (smartcardExtension->ReaderExtension) {

      ExFreePool(smartcardExtension->ReaderExtension);
   }

    if (deviceExtension->CloseSerial) {

        IoFreeWorkItem(deviceExtension->CloseSerial);
    }

    if (deviceExtension->CardStateChange) {

        IoFreeWorkItem(deviceExtension->CardStateChange);
    }

   IoDeleteDevice(DeviceObject);

    DeviceObject=NULL;

   SmartcardDebug(
      DEBUG_INFO,
      ( "%s!GCR410PRemoveDevice: Exit\n",
      SC_DRIVER_NAME)
      );
}




VOID
GCR410PDriverUnload(
   IN PDRIVER_OBJECT DriverObject
   )
/*++

Routine Description:

     The driver unload routine.  This is called by the I/O system when the
     device is unloaded from memory.

Arguments:

     DriverObject    - is a pointer to the driver object for this device.

Return Value:

    Nothing
--*/
{
   PAGED_CODE();

   SmartcardDebug(
      DEBUG_INFO,
      ("%s!GCR410PDriverUnload\n",
      SC_DRIVER_NAME)
      );
}

NTSTATUS
GCR410PStartSerialEventTracking(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

  This routine initialized serial event tracking. It calls the serial driver to
   set a wait mask for RING and DSR tracking. After that it installs a completion
   routine to be called when RING or DSR is signaled.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
      the current device.

Return Value:

    Nothing
--*/
{
   NTSTATUS status;
   PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
   IO_STATUS_BLOCK ioStatus;
   KEVENT event;

   PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PStartSerialEventTracking: Enter\n",
      SC_DRIVER_NAME)
      );

   KeInitializeEvent(
      &event,
      NotificationEvent,
      FALSE
      );

   readerExtension->SerialConfigData.SerialWaitMask =
      SERIAL_EV_DSR | SERIAL_EV_RING;

   // Send a wait mask to the serial driver. This call only sets the
   // wait mask. We want to be informed when the RING or DSR chnages its state.
   readerExtension->SerialStatusIrp = IoBuildDeviceIoControlRequest(
      IOCTL_SERIAL_SET_WAIT_MASK,
      readerExtension->AttachedDeviceObject,
      &readerExtension->SerialConfigData.SerialWaitMask,
      sizeof(readerExtension->SerialConfigData.SerialWaitMask),
      NULL,
      0,
      FALSE,
      &event,
      &ioStatus
      );

   if (readerExtension->SerialStatusIrp == NULL) {

      return STATUS_INSUFFICIENT_RESOURCES;
   }

   status = IoCallDriver(
      readerExtension->AttachedDeviceObject,
      readerExtension->SerialStatusIrp
      );

   if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );

      //ASSERT (STATUS_SUCCESS == status);
      status = ioStatus.Status;
   }

   if (status == STATUS_SUCCESS) {

      PIO_STACK_LOCATION irpSp;

      readerExtension->SerialStatusIrp = IoAllocateIrp(
         (CCHAR) (SmartcardExtension->OsData->DeviceObject->StackSize + 1),
         FALSE
         );

       if (readerExtension->SerialStatusIrp == NULL) {

           return STATUS_INSUFFICIENT_RESOURCES;
       }

       irpSp = IoGetNextIrpStackLocation( readerExtension->SerialStatusIrp );
      irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

      irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
      irpSp->Parameters.DeviceIoControl.OutputBufferLength =
         sizeof(readerExtension->SerialConfigData.SerialWaitMask);
      irpSp->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_SERIAL_WAIT_ON_MASK;

      readerExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
         &readerExtension->SerialConfigData.SerialWaitMask;

      // We simulate a callback now that triggers the card supervision
      SmartcardExtension->ReaderExtension->GetModemStatus = FALSE;

      GCR410PSerialEvent(
         SmartcardExtension->OsData->DeviceObject,
         readerExtension->SerialStatusIrp,
         SmartcardExtension
         );

      status = STATUS_SUCCESS;
   }
   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PStartSerialEventTracking: Exit\n",
      SC_DRIVER_NAME)
      );
   return status;
}


NTSTATUS
GCR410PStopSerialEventTracking(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

  This routine disabled the serial event tracking. It calls the serial driver to
   set a wait mask to 0.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
      the current device.

Return Value:

    Nothing
--*/
{
   NTSTATUS status;
   PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
   IO_STATUS_BLOCK ioStatus;
   KEVENT event;
   PIRP irp;

   PAGED_CODE();

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PStopSerialEventTracking: Enter\n",
      SC_DRIVER_NAME)
      );

   KeInitializeEvent(
      &event,
      NotificationEvent,
      FALSE
      );

   readerExtension->SerialConfigData.SerialWaitMask = 0;

   irp = IoBuildDeviceIoControlRequest(
      IOCTL_SERIAL_SET_WAIT_MASK,
      readerExtension->AttachedDeviceObject,
      &readerExtension->SerialConfigData.SerialWaitMask,
      sizeof(readerExtension->SerialConfigData.SerialWaitMask),
      NULL,
      0,
      FALSE,
      &event,
      &ioStatus
      );

   if (irp == NULL) {

       SmartcardDebug(
          DEBUG_ERROR,
          ( "%s!GCR410PStopSerialEventTracking: Insufficient resources\n",
          SC_DRIVER_NAME)
          );

      return STATUS_INSUFFICIENT_RESOURCES;
   }

   status = IoCallDriver(
      readerExtension->AttachedDeviceObject,
      irp
      );

   if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );

      //ASSERT (STATUS_SUCCESS == status);
      status = ioStatus.Status;
   }

   SmartcardDebug(
      DEBUG_INFO,
      ( "%s!GCR410PStopSerialEventTracking: Exit\n",
      SC_DRIVER_NAME)
      );

   return status;
}



VOID
GCR410PCompleteCardTracking(
   IN PSMARTCARD_EXTENSION SmartcardExtension
   )
{
    KIRQL ioIrql, keIrql;
    PIRP notificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &keIrql
        );

    notificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        keIrql
        );

    if (notificationIrp) {

        IoSetCancelRoutine(
            notificationIrp,
            NULL
            );
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (notificationIrp) {

      SmartcardDebug(
         DEBUG_INFO,
         ("%s!GCR410PCompleteCardTracking: Completing NotificationIrp %lxh\n",
            DRIVER_NAME,
            notificationIrp)
         );

       //   finish the request
        if (notificationIrp->Cancel) {

           notificationIrp->IoStatus.Status = STATUS_CANCELLED;

        } else {

           notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }
       notificationIrp->IoStatus.Information = 0;

       IoCompleteRequest(
            notificationIrp,
            IO_NO_INCREMENT
            );
    }
}


NTSTATUS
GCR410PSerialEvent(
   IN PDEVICE_OBJECT       DeviceObject,
   IN PIRP                 Irp,
   IN PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

  This routine is called in two cases:
  a) RING signaled (card inserted or removed)
  b) DSR changed (reader has been removed)

  For a) we update the card status and complete outstanding card tracking
  requests.
  For b) we start to unload the driver

  This function calls itself using IoCompletion. In the 'first' callback
  the serial driver only tells us that something has changed. We set up a
  call for 'what has changed' (GetModemStatus) which then call this function
  again.
  When we updated everything and we don't unload the driver card tracking is
  is started again.

Arguments:

   Device Object        - is a pointer on the current device object
   Irp                  - is a pointer on the current irp.
   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                          the current device.

Return Value:
   STATUS_MORE_PROCESSING_REQUIRED  - we need more process to complet the request.
   STATUS_SUCCESS                   - completed
--*/
{
   NTSTATUS status;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!GCR410PSerialEvent: Enter\n",
      SC_DRIVER_NAME)
      );

    if (SmartcardExtension->ReaderExtension->GetModemStatus) {

      SmartcardDebug(
         DEBUG_TRACE,
         ( "%s!GCR410PSerialEvent: Modem status=%X(hex)\n",
         SC_DRIVER_NAME,
         SmartcardExtension->ReaderExtension->ModemStatus)
         );

      if ((SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_DSR_STATE) == 0) {

         PDEVICE_EXTENSION deviceExtension;

         SmartcardDebug(
            DEBUG_INFO,
            ( "%s!GCR410PSerialEvent: Reader removed\n",
            SC_DRIVER_NAME)
            );

         deviceExtension = SmartcardExtension->OsData->DeviceObject->DeviceExtension;
         // We set the mask to zero to signal that we can release the irp that
         // we use for the serial events.
         SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask = 0;
         //ISV
         SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;
      } else {

         PDEVICE_EXTENSION deviceExtension=
                SmartcardExtension->OsData->DeviceObject->DeviceExtension;

           SmartcardDebug(
              DEBUG_TRACE,
              ( "%s!GCR410PSerialEvent: cardStateChange\n",
                SC_DRIVER_NAME)
              );

            ASSERT(KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l);

            if (KeReadStateEvent(&deviceExtension->CardStatusNotInUse) != 0L) {

               // Informs that the card status update is running
               KeClearEvent(&deviceExtension->CardStatusNotInUse);

             // Schedule the card status thread
             IoQueueWorkItem(
                deviceExtension->CardStateChange,
                    (PIO_WORKITEM_ROUTINE) GCR410PWaitForCardStateChange,
                CriticalWorkQueue,
                    NULL
                );
            }
      }
    }

   // If the reader is disconnected
   if (SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask == 0) {

      PDEVICE_EXTENSION deviceExtension=
         SmartcardExtension->OsData->DeviceObject->DeviceExtension;

        ASSERT(KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l);

      //Schedule our remove thread
      IoQueueWorkItem(
         deviceExtension->CloseSerial,
            (PIO_WORKITEM_ROUTINE) GCR410PCloseSerialPort,
         CriticalWorkQueue,
            NULL
         );

      SmartcardDebug(
         DEBUG_INFO,
         ( "%s!GCR410PSerialEvent: Exit (release IRP)\n",
         SC_DRIVER_NAME)
         );

      //
        // We don't need the IRP anymore, so free it and tell the
      // io subsystem not to touch it anymore by returning the value below
      //
      IoFreeIrp(Irp);
      return STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (SmartcardExtension->ReaderExtension->GetModemStatus == FALSE) {

       //
      // Setup call for device control to get modem status.
      //
      PIO_STACK_LOCATION irpStack;

      irpStack = IoGetNextIrpStackLocation(
         SmartcardExtension->ReaderExtension->SerialStatusIrp
         );

      irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
      irpStack->MinorFunction = 0UL;
      irpStack->Parameters.DeviceIoControl.OutputBufferLength =
         sizeof(SmartcardExtension->ReaderExtension->ModemStatus);
      irpStack->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_SERIAL_GET_MODEMSTATUS;

      SmartcardExtension->ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
         &SmartcardExtension->ReaderExtension->ModemStatus;

      SmartcardExtension->ReaderExtension->GetModemStatus = TRUE;

    } else {

      PIO_STACK_LOCATION irpStack;

      // Setup call for device control to wait for a serial event
      irpStack = IoGetNextIrpStackLocation(
         SmartcardExtension->ReaderExtension->SerialStatusIrp
         );

      irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
      irpStack->MinorFunction = 0UL;
      irpStack->Parameters.DeviceIoControl.OutputBufferLength =
         sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask);
      irpStack->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_SERIAL_WAIT_ON_MASK;

      SmartcardExtension->ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
         &SmartcardExtension->ReaderExtension->SerialConfigData.SerialWaitMask;

      SmartcardExtension->ReaderExtension->GetModemStatus = FALSE;
    }

   IoSetCompletionRoutine(
      SmartcardExtension->ReaderExtension->SerialStatusIrp,
      GCR410PSerialEvent,
      SmartcardExtension,
      TRUE,
      TRUE,
      TRUE
      );

    status = IoCallDriver(
      SmartcardExtension->ReaderExtension->AttachedDeviceObject,
      SmartcardExtension->ReaderExtension->SerialStatusIrp
      );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gioctl0a.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
   GIOCTL0A.C (Gemplus IOCTL Smart card Reader module 0A)

Description:
   This module holds the IOCTL functions for a smart card reader driver
    in compliance with PC/SC.


Environment:
   Kernel mode

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.
   26/04/98: V1.00.002  (GPZ)
      - Add the RestoreCommunication function for the Power Management.
   18/06/98: V1.00.003  (GPZ)
      - Send a classic PowerUp command (0x12 only) for a Warm reset
      in case of the Transparent protocol is selected.
      - The functions which use KeAcquireSpinLock/KeAcquireCancelSpinlock
      must be NOT PAGEABLE.
   28/08/98: V1.00.004  (GPZ)
      - Check the size of the output buffers before a RtlCopyMemory.
   22/01/99: V1.00.005 (YN)
     - Change the way to increase com port speed

--*/

#include "gntscr.h"
#include "gntser.h"
#include "gntscr0a.h"



//#pragma alloc_text(PAGEABLE, GDDK_0ASetProtocol)
//#pragma alloc_text(PAGEABLE, GDDK_0ATransmit)
//#pragma alloc_text(PAGEABLE, GDDK_0AVendorIoctl)


//
// Static functions declaration section:
//
static void GDDK_0ASetTransparentConfig(PSMARTCARD_EXTENSION,BYTE);
//
// Static variables declaration section:
//   - dataRatesSupported: holds all the supported data rates.
//
static ULONG
   dataRatesSupported[] = {
      9909,  13212,  14400,  15855,
     19200,  19819,  26425,  28800,
     31710,  38400,  39638,  52851,
     57600,  76800,  79277, 105703,
    115200, 158554
      };


NTSTATUS
GDDK_0AReaderPower(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This function is called by the Smart card library when a
     IOCTL_SMARTCARD_POWER occurs.
   This function provides 3 differents functionnality, depending of the minor
   IOCTL value
     - Cold reset (SCARD_COLD_RESET),
     - Warm reset (SCARD_WARM_RESET),
     - Power down (SCARD_POWER_DOWN).

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS         - We could execute the request.
    STATUS_NOT_SUPPORTED   - We could not support the minor Ioctl.

--*/
{
   NTSTATUS status;
   BYTE cmd[5],rbuff[HOR3GLL_BUFFER_SIZE];
   USHORT rlen;
   KIRQL irql;
   READER_EXTENSION
      *param = SmartcardExtension->ReaderExtension;


   SmartcardDebug(
      DEBUG_IOCTL,
      ("%s!GDDK_0AReaderPower: Enter\n",
        SC_DRIVER_NAME)
      );

   //
   // Since power down triggers the UpdateSerialStatus function, we have
   // to inform it that we forced the change of the status and not the user
   // (who might have removed and inserted a card)
   //
   SmartcardExtension->ReaderExtension->PowerRequest = TRUE;

   // Lock the mutex to avoid a call of an other command.
    GDDK_0ALockExchange(SmartcardExtension);
   switch(SmartcardExtension->MinorIoControlCode) {

    case SCARD_POWER_DOWN:
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!GDDK_0AReaderPower: SCARD_POWER_DOWN\n",
            SC_DRIVER_NAME)
            );
        //
        // ICC is powered Down
        //
        rlen = HOR3GLL_BUFFER_SIZE;
        cmd[0] = HOR3GLL_IFD_CMD_ICC_POWER_DOWN;
        status = GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            1,
            cmd,
            &rlen,
            rbuff
            );
        if (status == STATUS_SUCCESS) {

            status = GDDK_Translate(rbuff[0],RDF_CARD_POWER);
        }
        //
        // Set the card CurrentState
        //
        SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_UNDEFINED;
        SmartcardExtension->CardCapabilities.ATR.Length = 0;
            rlen = HOR3GLL_BUFFER_SIZE;
        cmd[0] = HOR3GLL_IFD_CMD_ICC_STATUS;
        status = GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            1,
            cmd,
            &rlen,
            rbuff
            );
        if (status == STATUS_SUCCESS) {

            status = GDDK_Translate(rbuff[0],0);
        }
        if (status == STATUS_SUCCESS) {

            KeAcquireSpinLock(
                &SmartcardExtension->OsData->SpinLock,
                &irql
                );
            if ((rbuff[1] & 0x04) == 0) {

                SmartcardExtension->ReaderCapabilities.CurrentState =
                    SCARD_ABSENT;
            } else if ((rbuff[1] & 0x02) == 0) {

                SmartcardExtension->ReaderCapabilities.CurrentState =
                    SCARD_SWALLOWED;
            }
            KeReleaseSpinLock(
                &SmartcardExtension->OsData->SpinLock,
                irql
                );
        }
        break;
    case SCARD_COLD_RESET:
    case SCARD_WARM_RESET:
        SmartcardDebug(
            DEBUG_IOCTL,
            ("%s!GDDK_0AReaderPower: SCARD_COLD_RESET or SCARD_WARM_RESET\n",
            SC_DRIVER_NAME)
            );
        status = GDDK_0AIccReset(
            SmartcardExtension,
            SmartcardExtension->MinorIoControlCode
            );
        if (status == STATUS_SUCCESS) {

            //
            // Check if we have a reply buffer.
            // smclib makes sure that it is big enough
            // if there is a buffer
            //
            if (SmartcardExtension->IoRequest.ReplyBuffer) {

                RtlCopyMemory(
                    SmartcardExtension->IoRequest.ReplyBuffer,
                    SmartcardExtension->CardCapabilities.ATR.Buffer,
                    SmartcardExtension->CardCapabilities.ATR.Length
                    );
                *SmartcardExtension->IoRequest.Information =
                    SmartcardExtension->CardCapabilities.ATR.Length;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

    default:
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_0AReaderPower: Minor IOCTL not supported!\n",
            SC_DRIVER_NAME)
            );
        status = STATUS_NOT_SUPPORTED;
    }

   SmartcardExtension->ReaderExtension->PowerRequest = FALSE;
   SmartcardDebug(
      DEBUG_IOCTL,
      ("%s!GDDK_0AReaderPower: Exit=%X(hex)\n",
        SC_DRIVER_NAME,
        status)
      );
   // Unlock the mutex.
    GDDK_0AUnlockExchange(SmartcardExtension);
    return (status);
}


NTSTATUS
GDDK_0AIccReset(
   PSMARTCARD_EXTENSION SmartcardExtension,
   ULONG                ResetType
   )
/*++

Routine Description:

   This function provides 2 differents functionnality
     - Cold reset (SCARD_COLD_RESET),
     - Warm reset (SCARD_WARM_RESET),

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   ResetType            - type of the reset (SCARD_COLD_RESET or SCARD_WARM_RESET)

Return Value:

    STATUS_SUCCESS         - We could execute the request.
    STATUS_NOT_SUPPORTED   - We could not support the minor Ioctl.

--*/
{
    NTSTATUS status;
    BYTE cmd[5],
         rbuff[HOR3GLL_BUFFER_SIZE];
    USHORT rlen;
    KEVENT event;
    LARGE_INTEGER timeout;
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;

   SmartcardExtension->ReaderExtension->IccConfig.PTSMode = IFD_WITHOUT_PTS_REQUEST;
    switch(ResetType) {

    case SCARD_COLD_RESET:
        if (param->IccConfig.ICCType != ISOCARD) {

            //
            // Defines the type of the card (ISOCARD) and set the card presence
            //
            param->IccConfig.ICCType      = ISOCARD;
            rlen = HOR3GLL_BUFFER_SIZE;
            cmd[0] = HOR3GLL_IFD_CMD_ICC_DEFINE_TYPE;
            cmd[1] = (BYTE) param->IccConfig.ICCType;
            cmd[2] = (BYTE) param->IccConfig.ICCVpp;
            cmd[3] = (BYTE) param->IccConfig.ICCPresence;
            status = GDDK_Oros3Exchange(
                param->Handle,
                HOR3GLL_LOW_TIME,
                4,
                cmd,
                &rlen,
                rbuff
                );
            if (status == STATUS_SUCCESS) {

                status = GDDK_Translate(rbuff[0],RDF_CARD_POWER);
            }
            if (status != STATUS_SUCCESS) {

                return(status);
            }
        }
        //
        // ICC is powered Down
        //
        rlen = HOR3GLL_BUFFER_SIZE;
        cmd[0] = HOR3GLL_IFD_CMD_ICC_POWER_DOWN;
        status = GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            1,
            cmd,
            &rlen,
            rbuff
            );
        if (status == STATUS_SUCCESS) {

            status = GDDK_Translate(rbuff[0],RDF_CARD_POWER);
        }
        if (status != STATUS_SUCCESS) {

            return(status);
        }

        if (param->PowerTimeOut) {

            //
            // Waits for the Power Timeout to be elapsed.
            //
            KeInitializeEvent(&event,NotificationEvent,FALSE);
            timeout.QuadPart = -((LONGLONG) param->PowerTimeOut * 10 * 1000);
            KeWaitForSingleObject(&event,
                Suspended,
                KernelMode,
                FALSE,
                &timeout);
        }

    case SCARD_WARM_RESET:
        //
        // ICC is powered up (GDDK_Oros3IccPowerUp).
        //
        rlen = HOR3GLL_BUFFER_SIZE;
        if (param->IccConfig.ICCType == TRANSPARENT_PROTOCOL) {

            status = GDDK_Oros3IccPowerUp(
                param->Handle,
                param->CmdTimeOut,
                0xFF,
                IFD_DEFAULT_MODE,
                0,
                0,
                0,
                0,
                &rlen,
                rbuff
                );
        } else {

            status = GDDK_Oros3IccPowerUp(
                param->Handle,
                param->CmdTimeOut,
                param->IccConfig.ICCVcc,
                param->IccConfig.PTSMode,
                param->IccConfig.PTS0,
                param->IccConfig.PTS1,
                param->IccConfig.PTS2,
                param->IccConfig.PTS3,
                &rlen,
                rbuff
                );
        }
        if (status == STATUS_SUCCESS) {

            status = GDDK_Translate(rbuff[0],RDF_CARD_POWER);
        }
        if (status != STATUS_SUCCESS) {

            return(status);
        }
        //
        // Copy ATR to smart card struct (remove the reader status byte)
        // The lib needs the ATR for evaluation of the card parameters
        //
        if (
            (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG) (rlen - 1))
            &&
            (sizeof(SmartcardExtension->CardCapabilities.ATR.Buffer) >= (ULONG)(rlen - 1))
            ) {

            RtlCopyMemory(
                SmartcardExtension->SmartcardReply.Buffer,
                rbuff + 1,
                rlen - 1
                );
            SmartcardExtension->SmartcardReply.BufferLength = (ULONG) (rlen - 1);

            RtlCopyMemory(
                SmartcardExtension->CardCapabilities.ATR.Buffer,
                SmartcardExtension->SmartcardReply.Buffer,
                SmartcardExtension->SmartcardReply.BufferLength
                );
            SmartcardExtension->CardCapabilities.ATR.Length =
                (UCHAR) SmartcardExtension->SmartcardReply.BufferLength;

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;
            //
            // Parse the ATR string in order to check if it as valid
            // and to find out if the card uses invers convention
            //
            status = SmartcardUpdateCardCapabilities(SmartcardExtension);
        } else  {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    default:
        status = STATUS_NOT_SUPPORTED;
    }

    return (status);
}


NTSTATUS
GDDK_0ASetProtocol(
      PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   The smart card lib requires to have this function. It is called
   to set a the transmission protocol and parameters. If this function
    is called with a protocol mask (which means the caller doesn't card
    about a particular protocol to be set) we first look if we can
    set T=1 and the T=0

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS               - We could execute the request.
    STATUS_DEVICE_PROTOCOL_ERROR - We could not support the protocol requested.

--*/
{
    NTSTATUS status;
    BYTE     rbuff[HOR3GLL_BUFFER_SIZE];
    USHORT rlen;
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;
    PSERIAL_READER_CONFIG serialConfigData =
        &SmartcardExtension->ReaderExtension->SerialConfigData;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0ASetProtocol: Enter\n",
        SC_DRIVER_NAME)
        );

    // Lock the mutex to avoid a call of an other command.
    GDDK_0ALockExchange(SmartcardExtension);
    __try {
        //
        // Check if the card is already in specific state
        // and if the caller wants to have the already selected protocol.
        // We return success if this is the case.
        //
        if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
            (SmartcardExtension->CardCapabilities.Protocol.Selected &
            SmartcardExtension->MinorIoControlCode)
            ) {
            status = STATUS_SUCCESS;
            __leave;
        }

        while(TRUE) {
            //
            // Select T=1 or T=0 and indicate that pts1 follows
            //
            if (  SmartcardExtension->CardCapabilities.Protocol.Supported &
                  SmartcardExtension->MinorIoControlCode                  &
                  SCARD_PROTOCOL_T1
               ) {

                SmartcardExtension->ReaderExtension->IccConfig.PTS0 = IFD_NEGOTIATE_T1 | IFD_NEGOTIATE_PTS1;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;

            } else if (  SmartcardExtension->CardCapabilities.Protocol.Supported &
                         SmartcardExtension->MinorIoControlCode                  &
                         SCARD_PROTOCOL_T0
                      ) {

                SmartcardExtension->ReaderExtension->IccConfig.PTS0 = IFD_NEGOTIATE_T0 | IFD_NEGOTIATE_PTS1;
                SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

            } else {

                status = STATUS_INVALID_DEVICE_REQUEST;
                __leave;
            }
            //
            // Set pts1 which codes Fl and Dl
            //
            SmartcardExtension->ReaderExtension->IccConfig.PTS1 =
                SmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                SmartcardExtension->CardCapabilities.PtsData.Dl;

            param->IccConfig.PTSMode = IFD_NEGOTIATE_PTS_MANUALLY;
            rlen = HOR3GLL_BUFFER_SIZE;
            status = GDDK_Oros3IccPowerUp(
                param->Handle,
                param->CmdTimeOut,
                param->IccConfig.ICCVcc,
                param->IccConfig.PTSMode,
                param->IccConfig.PTS0,
                param->IccConfig.PTS1,
                param->IccConfig.PTS2,
                param->IccConfig.PTS3,
                &rlen,
                rbuff
                );
            if (status == STATUS_SUCCESS) {

                status = GDDK_Translate(rbuff[0],RDF_CARD_POWER);
            }
            if (status == STATUS_SUCCESS ) {

                //The card replied correctly to our pts-request
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GDDK_0ASetProtocol: PTS Request OK\n",
                    SC_DRIVER_NAME)
                    );
                break;
            } else if (SmartcardExtension->CardCapabilities.PtsData.Type !=
                        PTS_TYPE_DEFAULT
                      ) {

                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GDDK_0ASetProtocol: PTS failed. Trying default parameters...\n",
                    SC_DRIVER_NAME)
                    );
                //
                // The card did either NOT reply or it replied incorrectly
                // so try default values.
                // Set PtsData Type to Default and do a cold reset
                //
                SmartcardExtension->CardCapabilities.PtsData.Type =
                    PTS_TYPE_DEFAULT;

                status = GDDK_0AIccReset(SmartcardExtension,SCARD_COLD_RESET);
                continue;
            }
            //
            // The card failed the pts-request
            //
            status = STATUS_DEVICE_PROTOCOL_ERROR;
            __leave;
        } //End of the while

        //
        // The card replied correctly to the pts request
        // Set the appropriate parameters for the port
        //
        if ( SmartcardExtension->CardCapabilities.Protocol.Selected &
             SCARD_PROTOCOL_T1
           ) {

            serialConfigData->Timeouts.ReadIntervalTimeout = 10 +
                SmartcardExtension->CardCapabilities.T1.CWT / 1000;
        }
        else if ( SmartcardExtension->CardCapabilities.Protocol.Selected &
                 SCARD_PROTOCOL_T0
                ) {

            serialConfigData->Timeouts.ReadIntervalTimeout = 10 +
                SmartcardExtension->CardCapabilities.T0.WT / 1000;
        }
        //
        // Now indicate that we're in specific mode
        // and return the selected protocol to the caller
        //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information =
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
    }

    __finally
    {
        if (status != STATUS_SUCCESS) {

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;
            *SmartcardExtension->IoRequest.Information = 0;
        }
    }
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0ASetProtocol: Exit=%lX(hex)\n",
        SC_DRIVER_NAME,
        status)
        );
    // Unlock the mutex.
    GDDK_0AUnlockExchange(SmartcardExtension);
    return status;
}


NTSTATUS
GDDK_0ATransmit(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This function is called by the Smart card library when a
     IOCTL_SMARTCARD_TRANSMIT occurs.
   This function is used to transmit a command to the card.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS                - We could execute the request.
    STATUS_INVALID_DEVICE_STATE   - If the protocol specified is different from
                                    the protocol selected
    STATUS_INVALID_DEVICE_REQUEST - We could not support the protocol specified.

--*/
{
    NTSTATUS status;
    PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer,
           replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
    PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
    PSCARD_IO_REQUEST scardIoRequest = (PSCARD_IO_REQUEST)
                      SmartcardExtension->OsData->CurrentIrp->AssociatedIrp.SystemBuffer;
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;
    USHORT rlen,
           rlenCmd;
    BYTE cmd[5],
         rbuff[HOR3GLL_BUFFER_SIZE],
         rbuffCmd[HOR3GLL_BUFFER_SIZE];
    ULONG t1Timeout;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_IOCTL,
        ("%s!GDDK_0ATransmit: Enter\n",
        SC_DRIVER_NAME)
        );

    //Set the reply buffer length to 0.
    *SmartcardExtension->IoRequest.Information = 0;
    status = STATUS_SUCCESS;

    //
    // Verify if the protocol specified is the same than the protocol selected.
    //
    *requestLength = 0;
    if (SmartcardExtension->CardCapabilities.Protocol.Selected !=
        scardIoRequest->dwProtocol) {

        return (STATUS_INVALID_DEVICE_STATE);
    }
    // Lock the mutex to avoid a call of an other command.
    GDDK_0ALockExchange(SmartcardExtension);
    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

    // For RAW protocol we return STATUS_INVALID_DEVICE_STATE
    case SCARD_PROTOCOL_RAW:
        status = STATUS_INVALID_DEVICE_STATE;
        break;

    //
    // T=0 PROTOCOL:
    //   Call the SmartCardT0Request which updates the SmartcardRequest struct.
    //
    case SCARD_PROTOCOL_T0:
        SmartcardExtension->SmartcardRequest.BufferLength = 0;
        status = SmartcardT0Request(SmartcardExtension);
        if (status == STATUS_SUCCESS) {

            rlen = HOR3GLL_BUFFER_SIZE;
            //
            // If the length LEx > 0
            // Then
            //    Is an ISO Out command.
            //    If LEx > SC_IFD_T0_MAXIMUM_LEX (256) we return STATUS_BUFFER_TOO_SMALL
            //   Call the GDDK_Oros3IsoOutput
            //
            if (SmartcardExtension->T0.Le > 0) {

                if (SmartcardExtension->T0.Le > SC_IFD_T0_MAXIMUM_LEX) {

                    status = STATUS_BUFFER_TOO_SMALL;
                }
                if (status == STATUS_SUCCESS) {

                    status = GDDK_Oros3IsoOutput(
                        param->Handle,
                        param->APDUTimeOut,
                        HOR3GLL_IFD_CMD_ICC_ISO_OUT,
                        (BYTE *)SmartcardExtension->SmartcardRequest.Buffer,
                        &rlen,
                        rbuff
                        );
                }
            } else {

                //
                // Else Is an ISO In command.
                //   If LC > SC_IFD_T0_MAXIMUM_LC (255) we return STATUS_BUFFER_TOO_SMALL
                //   Call the GDDK_Oros3IsoInput
                //
                if (SmartcardExtension->T0.Lc > SC_IFD_T0_MAXIMUM_LC) {

                    status = STATUS_BUFFER_TOO_SMALL;
                }
                if (status == STATUS_SUCCESS) {

                    status = GDDK_Oros3IsoInput(
                        param->Handle,
                        param->APDUTimeOut,
                        HOR3GLL_IFD_CMD_ICC_ISO_IN,
                        (BYTE *)SmartcardExtension->SmartcardRequest.Buffer,
                        (BYTE *)SmartcardExtension->SmartcardRequest.Buffer + 5,
                        &rlen,
                        rbuff
                        );
                }
            }
        }
        if (status == STATUS_SUCCESS) {

            status = GDDK_Translate(rbuff[0],RDF_TRANSMIT);
        }
        //
        // If the Status is Success
        //  Copy the response in the SmartcardReply buffer. Remove the status
        //   of the reader.
        //   Call the SmartcardT0reply function to update the IORequest struct.
        //
        if (status == STATUS_SUCCESS){
            ASSERT(SmartcardExtension->SmartcardReply.BufferSize >= (ULONG) (rlen - 1));
            RtlCopyMemory(
                SmartcardExtension->SmartcardReply.Buffer,
                rbuff + 1,
                rlen - 1
                );
            SmartcardExtension->SmartcardReply.BufferLength = (ULONG) (rlen - 1);
            status = SmartcardT0Reply(SmartcardExtension);
        }
        break;

    //
    // T=1 PROTOCOL:
    //
    case SCARD_PROTOCOL_T1:
        //
        // If the current card type <> TRANSPARENT_PROTOCOL,
        //
        if (param->IccConfig.ICCType != TRANSPARENT_PROTOCOL) {

            // We read the status of the card to known the current voltage and the TA1
            rlenCmd = HOR3GLL_BUFFER_SIZE;
            cmd[0] = HOR3GLL_IFD_CMD_ICC_STATUS;
            status = GDDK_Oros3Exchange(
                param->Handle,
                HOR3GLL_LOW_TIME,
                1,
                cmd,
                &rlenCmd,
                rbuffCmd
                );
            param->TransparentConfig.CFG = rbuffCmd[1] & 0x01; //Vcc
            param->TransparentConfig.Fi = rbuffCmd[3] >>4; //Fi
            param->TransparentConfig.Di = 0x0F & rbuffCmd[3]; //Di

            //We define the type of the card.
            rlenCmd = HOR3GLL_BUFFER_SIZE;
            param->IccConfig.ICCType = TRANSPARENT_PROTOCOL;
            cmd[0] = HOR3GLL_IFD_CMD_ICC_DEFINE_TYPE;
            cmd[1] = (BYTE) param->IccConfig.ICCType;
            cmd[2] = (BYTE) param->IccConfig.ICCVpp;
            cmd[3] = (BYTE) param->IccConfig.ICCPresence ;
            status = GDDK_Oros3Exchange(
                param->Handle,
                HOR3GLL_LOW_TIME,
                4,
                cmd,
                &rlenCmd,
                rbuffCmd
                );
            if (status == STATUS_SUCCESS) {

                status = GDDK_Translate(rbuffCmd[0],RDF_TRANSMIT);
            }

            if (status != STATUS_SUCCESS) {

                break;
            }

            // Set the transparent configuration
            GDDK_0ASetTransparentConfig(SmartcardExtension,SmartcardExtension->T1.Wtx);
        }
        //
        // Loop for the T=1 management
        //
        do {
            PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;

            // Tell the lib function how many bytes I need for the prologue
            //
            *requestLength = 0;
            status = SmartcardT1Request(SmartcardExtension);
            if (status != STATUS_SUCCESS) {
                break;
            }
            if (SmartcardExtension->T1.Wtx) {

                // Compute the timeout for the Oros3Exchange (WTX * BWT)
                t1Timeout = SmartcardExtension->CardCapabilities.T1.BWT / 1000;
                t1Timeout *= SmartcardExtension->T1.Wtx;
                t1Timeout += 500;
                GDDK_0ASetTransparentConfig(SmartcardExtension,SmartcardExtension->T1.Wtx);

            } else {

                t1Timeout = SmartcardExtension->CardCapabilities.T1.BWT / 1000;
                t1Timeout += 500;
            }

         SER_SetPortTimeout(param->Handle, t1Timeout);

            rlen = HOR3GLL_BUFFER_SIZE;
            status = GDDK_Oros3TransparentExchange(
                param->Handle,
                t1Timeout,
                (USHORT) SmartcardExtension->SmartcardRequest.BufferLength,
                SmartcardExtension->SmartcardRequest.Buffer,
                &rlen,
                rbuff
                );
            if (status == STATUS_SUCCESS) {

                status = GDDK_Translate(rbuff[0],RDF_TRANSMIT);
            }
            if (status != STATUS_SUCCESS) {
                rlen = 1;
            }
            if (SmartcardExtension->T1.Wtx) {

                // Set the reader BWI to the default value
                GDDK_0ASetTransparentConfig(SmartcardExtension,0);
            }

            // Copy the response in the reply buffer
            if (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG) (rlen -1)) {
                SmartcardExtension->SmartcardReply.BufferLength = (ULONG) (rlen - 1);

                if (SmartcardExtension->SmartcardReply.BufferLength > 0) {
                    RtlCopyMemory(
                        SmartcardExtension->SmartcardReply.Buffer,
                        rbuff + 1,
                        rlen - 1
                        );
                }
            }
            status = SmartcardT1Reply(SmartcardExtension);
        } while (status == STATUS_MORE_PROCESSING_REQUIRED);
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

   SER_SetPortTimeout(param->Handle, HOR3COMM_CHAR_TIMEOUT);

    // Unlock the mutex.
    GDDK_0AUnlockExchange(SmartcardExtension);
    SmartcardDebug(
        DEBUG_IOCTL,
        ("%s!GDDK_0ATransmit: Exit=%X(hex)\n",
        SC_DRIVER_NAME,
        status)
        );
    if (status != STATUS_SUCCESS) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_0ATransmit: failed! status=%X(hex)\n",
            SC_DRIVER_NAME,
            status)
            );
    }
    return (status);
}




NTSTATUS
GDDK_0ACardTracking(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This function is called by the Smart card library when an
     IOCTL_SMARTCARD_IS_PRESENT or IOCTL_SMARTCARD_IS_ABSENT occurs.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_PENDING                - The request is in a pending mode.

--*/
{
    KIRQL oldIrql;

    //
    // Set cancel routine for the notification irp
    //
    IoAcquireCancelSpinLock(&oldIrql);

    IoSetCancelRoutine(
        SmartcardExtension->OsData->NotificationIrp,
        GCR410PCancel
        );

    IoReleaseCancelSpinLock(oldIrql);

    return STATUS_PENDING;
}




NTSTATUS
GDDK_0AVendorIoctl(
    PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

   This routine is called when a vendor IOCTL_SMARTCARD_ is send to the driver.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;
    USHORT rlen;
    BYTE rbuff[HOR3GLL_BUFFER_SIZE];

    PAGED_CODE();

    ASSERT(SmartcardExtension != NULL);
    SmartcardDebug(
        DEBUG_IOCTL,
        ("%s!GDDK_0AVendorIoctl: Enter, IoControlCode=%lX(hex)\n",
        SC_DRIVER_NAME,
        SmartcardExtension->MajorIoControlCode)
        );
    // Lock the mutex to avoid a call of an other command.
    GDDK_0ALockExchange(SmartcardExtension);
    // Set the reply buffer length to 0.
    *SmartcardExtension->IoRequest.Information = 0;

    switch(SmartcardExtension->MajorIoControlCode) {
    //
    // For IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE and IOCTL_VENDOR_SMARTCARD_SET_ATTRIBUTE
    //   Call the GDDK_0AVendorTag function
    //
    case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
    case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
        status = GDDK_0AVendorTag(
            SmartcardExtension,
            (ULONG)  SmartcardExtension->MajorIoControlCode,
            (ULONG)  SmartcardExtension->IoRequest.RequestBufferLength,
            (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer,
            (ULONG)  SmartcardExtension->IoRequest.ReplyBufferLength,
            (PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer,
            (PULONG) SmartcardExtension->IoRequest.Information
            );
        break;

    //
    // For IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE
    //   Send the command to the reader
    //
    case IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:
        rlen = (USHORT) HOR3GLL_BUFFER_SIZE;
        status = GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            (USHORT) SmartcardExtension->IoRequest.RequestBufferLength,
            (BYTE *) SmartcardExtension->IoRequest.RequestBuffer,
            &rlen,
            rbuff
            );

        if (status != STATUS_SUCCESS) {

            break;
        }
        if (SmartcardExtension->IoRequest.ReplyBufferLength < (ULONG) rlen) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        RtlCopyMemory(
            SmartcardExtension->IoRequest.ReplyBuffer,
            rbuff,
            rlen
            );
        *(SmartcardExtension->IoRequest.Information) = (ULONG) rlen;
        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_NOT_SUPPORTED;
        break;
    }
    // Unlock the mutex.
    GDDK_0AUnlockExchange(SmartcardExtension);

    SmartcardDebug(
        DEBUG_IOCTL,
        ("%s!GDDK_0AVendorIoctl: Exit=%X(hex)\n",
        SC_DRIVER_NAME,
        status)
        );
    return status;
}


NTSTATUS
GDDK_0AVendorTag(
   PSMARTCARD_EXTENSION   SmartcardExtension,
   ULONG                  IoControlCode,
   ULONG                  BufferInLen,
   PUCHAR                 BufferIn,
   ULONG                  BufferOutLen,
   PUCHAR                 BufferOut,
   PULONG                 LengthOut
   )
/*++

Routine Description:

   This function is called when a specific Tag request occurs.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   IoControlCode        - holds the Ioctl value.
   BufferInLen          - holds the length of the input data.
   BufferIn             - holds the input data.
   BufferOutLen         - holds the size of the output buffer.
   BufferOut            - the output buffer.
   LengthOut            - holds the length of the output data.

Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.

--*/
{
    ULONG TagValue;
    PREADER_EXTENSION pReaderExtension = SmartcardExtension->ReaderExtension;

    ASSERT(pReaderExtension != NULL);
    // Set the reply buffer length to 0.
    *LengthOut = 0l;
    // Verify the length of the Tag
    if (BufferInLen < sizeof(TagValue)) {

        return(STATUS_BUFFER_TOO_SMALL);
    }
    TagValue = (ULONG) *((PULONG)BufferIn);

    // Switch for the different IOCTL:
    // Get the value of one tag (IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE)
    //      Switch for the different Tags:
    switch(IoControlCode) {

    // Get an attribute
    case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
        switch (TagValue) {

        // Baud rate of the reader (SCARD_ATTR_SPEC_BAUD_RATE)
        case SCARD_ATTR_SPEC_BAUD_RATE:
            if (BufferOutLen < (ULONG) sizeof(pReaderExtension->IFDBaudRate)) {

                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                BufferOut,
                &pReaderExtension->IFDBaudRate,
                sizeof(pReaderExtension->IFDBaudRate)
                );
            *(LengthOut) = (ULONG) sizeof(pReaderExtension->IFDBaudRate);
            return (STATUS_SUCCESS);
            break;

        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:
            if (BufferOutLen < (ULONG) sizeof(pReaderExtension->PowerTimeOut)) {

                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                BufferOut,
                &pReaderExtension->PowerTimeOut,
                sizeof(pReaderExtension->PowerTimeOut)
                );
            *(LengthOut) = (ULONG) sizeof(pReaderExtension->PowerTimeOut);
            return STATUS_SUCCESS;
            break;

        // Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
        case SCARD_ATTR_SPEC_CMD_TIMEOUT:
            if (BufferOutLen < (ULONG) sizeof(pReaderExtension->CmdTimeOut)) {
                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                BufferOut,
                &pReaderExtension->CmdTimeOut,
                sizeof(pReaderExtension->CmdTimeOut)
                );
            *(LengthOut) = (ULONG) sizeof(pReaderExtension->CmdTimeOut);
            return STATUS_SUCCESS;
            break;
        // APDU Timeout (SCARD_ATTR_SPEC_APDU_TIMEOUT)
        case SCARD_ATTR_SPEC_APDU_TIMEOUT:
            if (BufferOutLen < (ULONG) sizeof(pReaderExtension->APDUTimeOut)) {
                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                BufferOut,
                &pReaderExtension->APDUTimeOut,
                sizeof(pReaderExtension->APDUTimeOut)
                );
            *(LengthOut) = (ULONG) sizeof(pReaderExtension->APDUTimeOut);
            return STATUS_SUCCESS;
            break;
        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
            return STATUS_NOT_SUPPORTED;
            break;
        }
        break;

    // Set the value of one tag (IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE)
    case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
        switch (TagValue) {

        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:
            if (BufferInLen <(ULONG) (sizeof(pReaderExtension->PowerTimeOut) + sizeof(TagValue))) {

                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                &pReaderExtension->PowerTimeOut,
                BufferIn + sizeof(TagValue),
                sizeof(pReaderExtension->PowerTimeOut)
                );
            return STATUS_SUCCESS;
            break;

        // Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
        case SCARD_ATTR_SPEC_CMD_TIMEOUT:
            if (BufferInLen <(ULONG) (sizeof(pReaderExtension->CmdTimeOut) + sizeof(TagValue))) {

                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                &pReaderExtension->CmdTimeOut,
                BufferIn + sizeof(TagValue),
                sizeof(pReaderExtension->CmdTimeOut)
                );
            return STATUS_SUCCESS;
            break;

        // Command Timeout (SCARD_ATTR_SPEC_APDU_TIMEOUT)
        case SCARD_ATTR_SPEC_APDU_TIMEOUT:
            if (BufferInLen <(ULONG) (sizeof(pReaderExtension->APDUTimeOut) + sizeof(TagValue))) {

                return(STATUS_BUFFER_TOO_SMALL);
            }
            RtlCopyMemory(
                &pReaderExtension->APDUTimeOut,
                BufferIn + sizeof(TagValue),
                sizeof(pReaderExtension->APDUTimeOut)
                );
            return STATUS_SUCCESS;
            break;

        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
            return STATUS_NOT_SUPPORTED;
    }
    break;

    default:
        return STATUS_NOT_SUPPORTED;
        break;
    }
}


NTSTATUS
GDDK_0AOpenChannel(
   PSMARTCARD_EXTENSION SmartcardExtension,
   CONST ULONG          DeviceNumber,
   CONST ULONG          PortSerialNumber,
   CONST ULONG          MaximalBaudRate
   )
/*++

Routine Description:

    This routine try to establish a connection with a reader, and after
     update the characteristic of this reader.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   DeviceNumber         - holds the current device number (0 to MAX_DEVICES).
   PortSerialNumber     - holds the port serial number (0 to HGTSER_MAX_PORT).
   MaximalBaudRate      - holds the maximal speed specified for the reader.

Return Value:

    STATUS_SUCCESS          - We could execute the request.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    short handle,portcom;
    char os_string[HOR3GLL_OS_STRING_SIZE];
    USHORT os_length = HOR3GLL_OS_STRING_SIZE;
    USHORT user;
    TGTSER_PORT comm;
    ULONG br;
    BYTE minorVersion,majorVersion;
    COM_SERIAL serial_channel;
    USHORT rlen;
    BYTE cmd[5],rbuff[HOR3GLL_BUFFER_SIZE];
    LARGE_INTEGER timeout;

    // Update the serial communication channel information:
    serial_channel.Port     = PortSerialNumber + G_COM1;
    serial_channel.BaudRate = MaximalBaudRate;
    serial_channel.pSmartcardExtension  = SmartcardExtension;

    // Initializes a mutex object (in a high level) for the exchange commands with
    // the smart card reader.
    KeInitializeMutex(
        &SmartcardExtension->ReaderExtension->ExchangeMutex,
        3
        );
    // Initializes a mutex object (in a high level) for the long APDU commands with
    // the smart card reader.
    KeInitializeMutex(
        &SmartcardExtension->ReaderExtension->LongAPDUMutex,
        3
        );
    // Open a communication channel (GDDK_Oros3OpenComm).
    //   The reader baudrate is automatically detected by this function.
    handle = (short)DeviceNumber;
    status = GDDK_Oros3OpenComm(&serial_channel,handle);
    if (status == STATUS_DEVICE_ALREADY_ATTACHED) {

        status = GDDK_SerPortAddUser((USHORT) serial_channel.Port,&portcom);
        if (status != STATUS_SUCCESS) {

            return (status);
        }
        GDDK_GBPOpen(handle,2,4,portcom);
    }
    if (status != STATUS_SUCCESS) {

        return (status);
    }

    //
    // Verify the Firmware version: this driver support only the PnP GemCore based
    // readers
    //
    cmd[0] = (BYTE) HOR3GLL_IFD_CMD_MEM_RD;
    cmd[1] = (BYTE)HOR3GLL_IFD_TYP_VERSION;
    cmd[2] = HIBYTE(HOR3GLL_IFD_ADD_VERSION);
    cmd[3] = LOBYTE(HOR3GLL_IFD_ADD_VERSION);
    cmd[4] = (BYTE)HOR3GLL_IFD_LEN_VERSION;
    status = GDDK_Oros3Exchange(
        handle,
        HOR3GLL_LOW_TIME,
        5,
        cmd,
        &os_length,
        os_string
        );
    if (status != STATUS_SUCCESS) {
        GDDK_Oros3CloseComm(handle);
        return (status);
    }
    if (os_length >= (USHORT)strlen(IFD_FIRMWARE_VERSION)) {
        if (memcmp(os_string + 1,IFD_FIRMWARE_VERSION,strlen(IFD_FIRMWARE_VERSION))) {

            GDDK_Oros3CloseComm(handle);
            return (STATUS_INVALID_DEVICE_STATE);
        }
    } else {
        GDDK_Oros3CloseComm(handle);
        return (STATUS_INVALID_DEVICE_STATE);
    }
    // GemCore Rx.yy-yz
    // x = major version
    // y = minor version
    // z = M if masked version
    majorVersion = os_string[strlen(IFD_FIRMWARE_VERSION) + 1] - '0';
    minorVersion = 100 * (os_string[strlen(IFD_FIRMWARE_VERSION) + 3] - '0');
    minorVersion += 10 * (os_string[strlen(IFD_FIRMWARE_VERSION) + 4] - '0');
    minorVersion +=  (os_string[strlen(IFD_FIRMWARE_VERSION) + 6] - '0');
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0AOpenChannel: GemCore version = %d.%d\n",
        SC_DRIVER_NAME,
        majorVersion,
        minorVersion)
        );
    if ((majorVersion < IFD_VERSION_MAJOR) || (minorVersion < IFD_VERSION_MINOR)) {

        GDDK_Oros3CloseComm(handle);
            SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_0AOpenChannel: The firmware version is not supported by the driver!\n",
            SC_DRIVER_NAME)
            );
        return (STATUS_BAD_DEVICE_TYPE);
    }

    // Optimizes the baudrate:
    // Initializes the comm variable to modify the used baud rate.
    status = GDDK_GBPChannelToPortComm(handle,&portcom);
    if (status != STATUS_SUCCESS) {

        GDDK_Oros3CloseComm(handle);
        return status;
    }
    status  = GDDK_SerPortGetState(
        portcom,
        &comm,
        &user
        );
    if (status != STATUS_SUCCESS) {

        GDDK_Oros3CloseComm(handle);
        return status;
    }

   //ISV
   // Connection was established
   // Now try to connect at max speed!
   comm.BaudRate = serial_channel.BaudRate;
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0AOpenChannel: Connection established at %d baud rate\n",
        SC_DRIVER_NAME,comm.BaudRate));

            // Unsupported baud rate
    if(comm.BaudRate >= 38400)
    {
        SmartcardDebug(DEBUG_ERROR,("GDDK_0AOpenChannel: ###### UNSUPPORTED BAUD RATE %d\n", comm.BaudRate));
        GDDK_Oros3CloseComm(handle);
        return (STATUS_INVALID_DEVICE_STATE);
    }
            // Maximum baud rate is already set - nothing to do
    if(comm.BaudRate==38400)
    {
       SmartcardDebug(DEBUG_DRIVER,("GDDK_0AOpenChannel: MAX SPEED SET TO 38400!\n"));
    }
    else
    {
        // Try to negotiate a better baud rate.
        int i=0;
        BOOLEAN bBetterBaudRate=FALSE;
        ULONG brList[3] = {38400, 19200, 9600};
        USHORT brListLength = 3;
        ULONG previousBaudRate = 0;
      KEVENT event;
        previousBaudRate = comm.BaudRate;

        i = 0;
        while ( (i < brListLength) &&
                (bBetterBaudRate == FALSE) )
        {
            br = brList[i];

            // The reader is switched to the selected value (GDDK_Oros3SIOConfigure). The
            // function status is not tested because, as the IFD has switched
            // immediatly, it is not possible to read its response.
            comm.BaudRate = br;
            rlen = 0;
            rbuff[0]=0x0;
            GDDK_Oros3SIOConfigure(
                handle,
                HOR3GLL_LOW_TIME,
                0,
                8,
                comm.BaudRate,
                &rlen,
                rbuff,
            FALSE
                );

            //
            // Waits for the fisrt command is processed by the reader
         // 500 ms is enought
            //
            KeInitializeEvent(&event,NotificationEvent,FALSE);
            timeout.QuadPart = -((LONGLONG)  500 * 1000);
            KeWaitForSingleObject(&event,
                Suspended,
                KernelMode,
                FALSE,
                &timeout);

            // Host is switched to the selected value (GDDK_SerPortSetState).
            // If this call is successful,
            // Then
            //   The last command is re-sent to read the IFD response.
            //   response is optionnaly initialized with the translated IFD status.
            status = GDDK_SerPortSetState(
                portcom,
                &comm
                );
            if (status == STATUS_SUCCESS)
            {
                rlen = HOR3GLL_BUFFER_SIZE;
                rbuff[0]=0x0;
                status = GDDK_Oros3SIOConfigure(
                    handle,
                    HOR3GLL_LOW_TIME,
                    0,
                    8,
                    comm.BaudRate,
                    &rlen,
                    rbuff,
               TRUE
                    );
                if (status == STATUS_SUCCESS)
                {
                    bBetterBaudRate = TRUE;
                }
            }
        } // endwhile

               // Check if a better baudrate was negotiated
        if (bBetterBaudRate==FALSE)
        {
                //*** Can come back to the previous one
                // return an error message right now.
            GDDK_Oros3CloseComm(handle);
            return (STATUS_INVALID_DEVICE_STATE);
        }
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0AOpenChannel: Reader speed was set to %d baud rate\n",
        SC_DRIVER_NAME,comm.BaudRate));

    // Sends the SetMode command with parameter 0 to disable TLP compatibility.
    rlen = HOR3GLL_BUFFER_SIZE;
    cmd[0] = (BYTE) HOR3GLL_IFD_CMD_MODE_SET;
    cmd[1] = (BYTE) 0x00;
    cmd[2] = (BYTE) 0x00;
    status = GDDK_Oros3Exchange(
        handle,
        HOR3GLL_LOW_TIME,
        3,
        cmd,
        &rlen,
        rbuff
        );
    if (status != STATUS_SUCCESS) {

        GDDK_Oros3CloseComm(handle);
        return (status);
    }

   // Reader capabilities:
   // - the type of the reader (SCARD_READER_TYPE_SERIAL)
   // - the channel for the reader (PortSerialNumber)
   // - the protocols supported by the reader (SCARD_PROTOCOL_T0, SCARD_PROTOCOL_T1)
   // - the mechanical characteristic of the reader:
    SmartcardExtension->ReaderCapabilities.ReaderType =
        SCARD_READER_TYPE_SERIAL;
    SmartcardExtension->ReaderCapabilities.Channel =
        PortSerialNumber;
    SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
    SmartcardExtension->ReaderCapabilities.MechProperties = 0;

    // Reader capabilities (continue):
    // - the default clock frequency (SC_IFD_DEFAULT_CLK_FREQUENCY)
    // - the maximum clock frequency (SC_IFD_MAXIMUM_CLK_FREQUENCY)
    // - the default data rate (SC_IFD_DEFAULT_DATA_RATE)
    // - the maximum data rate (SC_IFD_MAXIMUM_DATA_RATE)
    // - the maximum IFSD (SC_IFD_MAXIMUM_IFSD)
    // - the power management is set to 0.
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
        SC_IFD_DEFAULT_CLK_FREQUENCY;
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
        SC_IFD_MAXIMUM_CLK_FREQUENCY;
    SmartcardExtension->ReaderCapabilities.DataRate.Default =
        SC_IFD_DEFAULT_DATA_RATE;
    SmartcardExtension->ReaderCapabilities.DataRate.Max =
        SC_IFD_MAXIMUM_DATA_RATE;
    SmartcardExtension->ReaderCapabilities.MaxIFSD =
        SC_IFD_MAXIMUM_IFSD;
    SmartcardExtension->ReaderCapabilities.PowerMgmtSupport = 0;

    // Reader capabilities (continue):
    // - List all the supported data rates
    SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
        dataRatesSupported;
    SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
        sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

    // Vendor Attributes:
    // - the vendor information (SC_VENDOR_NAME)
    strcpy(
        SmartcardExtension->VendorAttr.VendorName.Buffer,
        SC_VENDOR_NAME
        );
    SmartcardExtension->VendorAttr.VendorName.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.VendorName.Buffer);

    // Vendor Attributes (continue):
    // - the UnitNo information. Is set to the device number.
    // - the IFD serial number (is set to a NULL string).
    // - the IFD version is set.
    strcpy(SmartcardExtension->VendorAttr.IfdType.Buffer,SC_IFD_TYPE);
    SmartcardExtension->VendorAttr.IfdType.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.IfdType.Buffer);
    SmartcardExtension->VendorAttr.UnitNo = DeviceNumber;
    SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;
    SmartcardExtension->VendorAttr.IfdVersion.VersionMajor = (UCHAR)majorVersion;
    SmartcardExtension->VendorAttr.IfdVersion.VersionMinor = (UCHAR)minorVersion;
    SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

    // Reader Extension:
    // - the Handle of the reader.
    // - the IFD number of the reader.
    // - the ICCType (ISOCARD).
    // - the ICCVpp (HOR3GLL_DEFAULT_VPP).
    // - the ICCPresence.
    // - the command timeout for the reader (HOR3GLL_DEFAULT_TIME).
    // - the IFD baud rate.
    // - the power timeout (0).
    // - the selected VCC power supply voltage value.
    // - the PTS negotiate mode.
    // - the parameter PTS0.
    // - the parameter PTS1.
    // - the parameter PTS2.
    // - the parameter PTS3.
    SmartcardExtension->ReaderExtension->Handle                 = handle;
    SmartcardExtension->ReaderExtension->APDUTimeOut            = HOR3GLL_APDU_TIMEOUT;
    SmartcardExtension->ReaderExtension->CmdTimeOut             = HOR3GLL_DEFAULT_TIME;
    SmartcardExtension->ReaderExtension->IFDBaudRate            = br;
    SmartcardExtension->ReaderExtension->PowerTimeOut           = ICC_DEFAULT_POWER_TIMOUT;
    SmartcardExtension->ReaderExtension->MaximalBaudRate        = MaximalBaudRate;
    SmartcardExtension->ReaderExtension->IccConfig.ICCType      = ISOCARD;
    SmartcardExtension->ReaderExtension->IccConfig.ICCVpp       = HOR3GLL_DEFAULT_VPP;
    SmartcardExtension->ReaderExtension->IccConfig.ICCVcc       = ICC_VCC_5V;
    SmartcardExtension->ReaderExtension->IccConfig.PTSMode      = IFD_DEFAULT_MODE;
    SmartcardExtension->ReaderExtension->IccConfig.PTS0         = 0;
    SmartcardExtension->ReaderExtension->IccConfig.PTS1         = 0;
    SmartcardExtension->ReaderExtension->IccConfig.PTS2         = 0;
    SmartcardExtension->ReaderExtension->IccConfig.PTS3         = 0;
    SmartcardExtension->ReaderExtension->IccConfig.ICCPresence  = 0x0D;

    // Define the type of the card (ISOCARD) and set the card presence
    rlen = HOR3GLL_BUFFER_SIZE;
    cmd[0] = HOR3GLL_IFD_CMD_ICC_DEFINE_TYPE;
    cmd[1] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCType;
    cmd[2] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCVpp;
    cmd[3] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCPresence ;
    status = GDDK_Oros3Exchange(
        handle,
        HOR3GLL_LOW_TIME,
        4,
        cmd,
        &rlen,
        rbuff
        );
    if (status == STATUS_SUCCESS) {

        status = GDDK_Translate(rbuff[0],0);
    }
    if (status != STATUS_SUCCESS) {

        GDDK_Oros3CloseComm(handle);
        return(status);
    }
    // Update the status of the card
    GDDK_0AUpdateCardStatus(SmartcardExtension);

    return(STATUS_SUCCESS);
}


NTSTATUS
GDDK_0ACloseChannel(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

Routine Description:

    This routine close a conection previously opened with a reader.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS          - We could execute the request.

--*/
{
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;
    USHORT rlen;
    BYTE cmd[1],rbuff[HOR3GLL_BUFFER_SIZE];

    // Call power down function:
    rlen = HOR3GLL_BUFFER_SIZE;
    cmd[0] = HOR3GLL_IFD_CMD_ICC_POWER_DOWN;
    return(
        GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            1,
            cmd,
            &rlen,
            rbuff
            )
        );
}



NTSTATUS
GDDK_0AUpdateCardStatus(
   PSMARTCARD_EXTENSION pSmartcardExtension
   )
/*++

Routine Description:

   This function send a command to the reader to known the state of the card.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS          - We could execute the request.

--*/
{
    BYTE cmd[1];
    READER_EXTENSION *param = pSmartcardExtension->ReaderExtension;
    USHORT rlen;
    BYTE rbuff[HOR3GLL_BUFFER_SIZE];
    KIRQL irql;
    NTSTATUS  status;

    // Read the status of the reader
    cmd[0] = HOR3GLL_IFD_CMD_ICC_STATUS;
    rlen = HOR3GLL_BUFFER_SIZE;
    status = GDDK_Oros3Exchange(
        param->Handle,
        HOR3GLL_LOW_TIME,
        (const USHORT)1,
        (const BYTE *)cmd,
        &rlen,
        rbuff
        );
    if (status == STATUS_SUCCESS) {

        status = GDDK_Translate(rbuff[0],0);
    }
    if (status != STATUS_SUCCESS) {

        return status;
    }
    KeAcquireSpinLock(
        &pSmartcardExtension->OsData->SpinLock,
        &irql
        );

    if ((rbuff[1] & 0x04) == 0) {

        // The card is absent
        pSmartcardExtension->ReaderCapabilities.CurrentState =  SCARD_ABSENT;
        pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        pSmartcardExtension->CardCapabilities.ATR.Length = 0;

        SmartcardDebug(
            DEBUG_TRACE,
            ("%s!GDDK_0AUpdateCardStatus: Card removed\n",
            SC_DRIVER_NAME)
            );

    } else if ((rbuff[1] & 0x02) == 0) {

        // The card is present
        pSmartcardExtension->ReaderCapabilities.CurrentState =  SCARD_SWALLOWED;
        pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
        pSmartcardExtension->CardCapabilities.ATR.Length = 0;

        SmartcardDebug(
            DEBUG_TRACE,
            ("%s!GDDK_0AUpdateCardStatus: Card inserted\n",
            SC_DRIVER_NAME)
            );
   }

    KeReleaseSpinLock(
        &pSmartcardExtension->OsData->SpinLock,
        irql
        );
    return status;
}




VOID
GDDK_0ALockExchange(
    PSMARTCARD_EXTENSION   SmartcardExtension
   )
/*++

Routine Description:

   Wait the release of the ExchangeMutex and take this.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_SUCCESS          - We could execute the request.

--*/
{

    KeWaitForMutexObject(
        &SmartcardExtension->ReaderExtension->LongAPDUMutex,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );
}




VOID
GDDK_0AUnlockExchange(
    PSMARTCARD_EXTENSION   SmartcardExtension
   )
/*++

Routine Description:

   Release of the Exchange mutex.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

--*/
{
    KeReleaseMutex(
        &SmartcardExtension->ReaderExtension->LongAPDUMutex,
        FALSE
        );
}





static VOID
GDDK_0ASetTransparentConfig(
    PSMARTCARD_EXTENSION   SmartcardExtension,
    BYTE                   NewWtx
   )
/*++

Routine Description:

   Set the parameters of the transparent mode.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   NewWtx               - holds the value (ms) of the new Wtx

--*/
{
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;
    LONG etu;
    BYTE temp,mask,index;
    USHORT rlen;
    BYTE cmd[6],rbuff[HOR3GLL_BUFFER_SIZE];
    NTSTATUS status;

    // Inverse or direct conversion
    if (SmartcardExtension->CardCapabilities.InversConvention)
        param->TransparentConfig.CFG |= 0x20;
    else
        param->TransparentConfig.CFG &= 0xDF;
    // Transparent T=1 like (with 1 byte for the length).
    param->TransparentConfig.CFG |= 0x08;
    // ETU = ((F[Fi]/D[Di]) - 1) / 3
    etu = SmartcardExtension->CardCapabilities.ClockRateConversion[
        (BYTE) param->TransparentConfig.Fi].F;
    if (SmartcardExtension->CardCapabilities.BitRateAdjustment[
        (BYTE) param->TransparentConfig.Fi].DNumerator) {

        etu /= SmartcardExtension->CardCapabilities.BitRateAdjustment[
            (BYTE) param->TransparentConfig.Fi].DNumerator;
    }
    etu -= 1;
    etu /= 3;
    param->TransparentConfig.ETU = (BYTE) ( 0x000000FF & etu);

    if (SmartcardExtension->CardCapabilities.N == 0xFF) {

        param->TransparentConfig.EGT = (BYTE) 0x00;
    } else {
        param->TransparentConfig.EGT = (BYTE) SmartcardExtension->CardCapabilities.N;
    }

    param->TransparentConfig.CWT = (BYTE) SmartcardExtension->CardCapabilities.T1.CWI;
    if (NewWtx) {

        for (mask = 0x80,index = 8; index !=0x00; index--) {
            temp = NewWtx & mask;
            if (temp == mask)
                break;
            mask = mask/2;
        }
        param->TransparentConfig.BWI = SmartcardExtension->CardCapabilities.T1.BWI + index;
    } else {

        param->TransparentConfig.BWI = SmartcardExtension->CardCapabilities.T1.BWI;
    }
    // Now we send the configuration command
    rlen = HOR3GLL_BUFFER_SIZE;
    cmd[0] = HOR3GLL_IFD_CMD_TRANS_CONFIG;
    cmd[1] = param->TransparentConfig.CFG;
    cmd[2] = param->TransparentConfig.ETU;
    cmd[3] = param->TransparentConfig.EGT;
    cmd[4] = param->TransparentConfig.CWT;
    cmd[5] = param->TransparentConfig.BWI;
    status = GDDK_Oros3Exchange(
        param->Handle,
        HOR3GLL_LOW_TIME,
        6,
        cmd,
        &rlen,
        rbuff
        );
}


NTSTATUS
GDDK_0ARestoreCommunication(
    PSMARTCARD_EXTENSION   SmartcardExtension
   )
/*++

Routine Description:

   Restore the communication with the reader at the good speed.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

--*/
{
    TGTSER_PORT comm;
    BYTE cmd[10],rbuff[HOR3GLL_BUFFER_SIZE];
    USHORT user,rlen;
    ULONG  br;
    SHORT portcom;
    KEVENT event;
    LARGE_INTEGER timeout;
    NTSTATUS status;
    READER_EXTENSION *param = SmartcardExtension->ReaderExtension;

    // Loop while a right response has not been received. We start at 9600
    status = GDDK_GBPChannelToPortComm(param->Handle,&portcom);
    if (status != STATUS_SUCCESS) {

        return status;
    }
    status = GDDK_SerPortGetState(portcom,&comm,&user);

    if (status != STATUS_SUCCESS) {
       return status;
    }

    comm.BaudRate = 9600;
    GDDK_SerPortSetState(portcom,&comm);

    GDDK_0ALockExchange(SmartcardExtension);
    __try {
        do {
            // Wait for HOR3COMM_CHAR_TIME ms before any command for IFD to forget any
            // previous received byte.
            KeInitializeEvent(&event,NotificationEvent,FALSE);
            timeout.QuadPart = -((LONGLONG) HOR3COMM_CHAR_TIME*10*1000);
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                &timeout
                );
            SmartcardDebug(
                DEBUG_TRACE,
                ("%s!GDDK_0ARestoreCommunication: Try at baud rate = %d\n",
                SC_DRIVER_NAME,
                comm.BaudRate)
                );
            // Define the type of the card (ISOCARD) and set the card presence
            rlen = HOR3GLL_BUFFER_SIZE;
            SmartcardExtension->ReaderExtension->IccConfig.ICCType = ISOCARD;
            cmd[0] = HOR3GLL_IFD_CMD_ICC_DEFINE_TYPE;
            cmd[1] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCType;
            cmd[2] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCVpp;
            cmd[3] = (BYTE) SmartcardExtension->ReaderExtension->IccConfig.ICCPresence ;
            status = GDDK_Oros3Exchange(
                param->Handle,
                HOR3GLL_LOW_TIME,
                4,
                cmd,
                &rlen,
                rbuff
                );
            if (status != STATUS_SUCCESS) {

                if (comm.BaudRate == 9600lu) {

                    comm.BaudRate = 38400lu;
                } else if (comm.BaudRate == 38400lu) {
                    comm.BaudRate = 19200lu;
                } else {
                    status = STATUS_INVALID_DEVICE_STATE;
                    __leave;
                }
                // The new baud rate configuration is set.
                GDDK_SerPortSetState(portcom,&comm);
            } else {
                break;
            }
        } while (status != STATUS_SUCCESS);
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_0ARestoreCommunication: Baud rate = %d\n",
            SC_DRIVER_NAME,
            comm.BaudRate)
            );

        // Optimizes the baudrate:
        if(param->MaximalBaudRate > comm.BaudRate) {
            br = comm.BaudRate;
            for(;br < param->MaximalBaudRate;) {
                br = br * 2;
                // The reader is switched to the selected value (GDDK_Oros3SIOConfigure). The
                // function status is not tested because, as the IFD has switched
                // immediatly, it is not possible to read its response.
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GDDK_0ARestoreCommunication: Optimize baud rate = %d\n",
                    SC_DRIVER_NAME,
                    comm.BaudRate)
                    );
                comm.BaudRate = br;
                rlen = 0;
                GDDK_Oros3SIOConfigure(
                    param->Handle,
                    HOR3GLL_LOW_TIME,
                    0,
                    8,
                    comm.BaudRate,
                    &rlen,
                    rbuff,
               FALSE
                    );
            //
            // Waits for the fisrt command is process by the reader
            // 500 ms is enought
            //
            KeInitializeEvent(&event,NotificationEvent,FALSE);
            timeout.QuadPart = -((LONGLONG)  500 * 1000);
            KeWaitForSingleObject(&event,
               Suspended,
               KernelMode,
               FALSE,
               &timeout);

                // Host is switched to the selected value (GDDK_SerPortSetState).
                // If this call is successful,
                // Then
                //   The last command is re-sent to read the IFD response.
                //   response is optionnaly initialized with the translated IFD status.
                status = GDDK_SerPortSetState(portcom,&comm);
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GDDK_0ARestoreCommunication: Set baud rate = %d\n",
                    SC_DRIVER_NAME,
                    comm.BaudRate)
                    );

                if (status == STATUS_SUCCESS) {
                    rlen = HOR3GLL_BUFFER_SIZE;
                    status = GDDK_Oros3SIOConfigure(
                        param->Handle,
                        HOR3GLL_LOW_TIME,
                        0,
                        8,
                        comm.BaudRate,
                        &rlen,
                        rbuff,
                  TRUE
                        );
                    if (status == STATUS_SUCCESS) {

                        status = GDDK_Translate(rbuff[0],0);
                    }
                    if (status != STATUS_SUCCESS) {

                        break;
                    }
                }
            }
            if ((br > 38400) || (status != STATUS_SUCCESS)) {

                status = STATUS_INVALID_DEVICE_STATE;
                __leave;
            }
        }
        SmartcardDebug(
            DEBUG_TRACE,
            ("%s!GDDK_0ARestoreCommunication: Current baud rate = %d\n",
            SC_DRIVER_NAME,
            comm.BaudRate)
            );

        // Send the SetMode command with parameter 0 to disable TLP compatibility.
        rlen = HOR3GLL_BUFFER_SIZE;
        cmd[0] = (BYTE) HOR3GLL_IFD_CMD_MODE_SET;
        cmd[1] = (BYTE) 0x00;
        cmd[2] = (BYTE) 0x00;
        status = GDDK_Oros3Exchange(
            param->Handle,
            HOR3GLL_LOW_TIME,
            3,
            cmd,
            &rlen,
            rbuff
            );
        if (status != STATUS_SUCCESS) {

            __leave;
        }
        // Update the status of the card
        GDDK_0AUpdateCardStatus(SmartcardExtension);
    }
    __finally {
        if (status != STATUS_SUCCESS) {

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!GDDK_0ARestoreCommunication: Failed\n",
                SC_DRIVER_NAME,
                comm.BaudRate)
                );
        }
    }
    GDDK_0AUnlockExchange(SmartcardExtension);
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!GDDK_0ARestoreCommunication: Exit=%X(hex)\n",
        SC_DRIVER_NAME,
        status)
        );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gntscr.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:  
   GNTSCR.H (Gemplus NT Smart Card Reader definition)

Description : 
   Holds the common definitions for a smart card reader
   This file is a dedicated to a GemCore Pnp reader

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.

--*/

#ifndef _GNTSCR_
#define _GNTSCR_

#define SMARTCARD_POOL_TAG 'bGCS'

#include <ntddk.h>
#include <ntddser.h>
#include <smclib.h>
#include "gemlog.h"
#include "gemcore.h"
#include "gioctl0A.h"


//
// Constant section:
//   - SC_DRIVER_NAME defines the name of the Smart Card reader driver.
//   - SC_VENDOR_NAME defines the name of the Smart Card reader vendor.
//   - SC_IFD_TYPE defines the type of the Smart Card reader.
//
#define SC_DRIVER_NAME           "GCR410P"
#define SC_VENDOR_NAME           "GEMPLUS"
#define SC_IFD_TYPE              "GCR410P"

//
//   - IFD_FIRMWARE_VERSION defines the version of the firmware supported 
//      by the driver.
//   - IFD_VERSION_MAJOR and IFD_VERSION_MINOR defines the major and minor 
//      version of the firmware supported by the driver.
//
#define IFD_FIRMWARE_VERSION     "GemCore-R"
#define IFD_VERSION_MAJOR        1
#define IFD_VERSION_MINOR        113


//
//   - REG_KEY_MAXIMAL_BAUD_RATE defines the key name in the registry which
//      contains the value of the maximal baud rate for the reader.
//   - IFD_STANDARD_BAUD_RATE defines the standard baud rate for the reader (38400)
//
#define REG_KEY_MAXIMAL_BAUD_RATE   "MaximalBaudRate"
#define IFD_STANDARD_BAUD_RATE      38400

//
//   - ICC_DEFAULT_POWER_TIMOUT defines the default power timout in ms (0).
//
#define ICC_DEFAULT_POWER_TIMOUT     0

//
//   - SCARD_CLASS is a macro to know the class of a Tag.
//
#define SCARD_CLASS(Value) (ULONG) (((ULONG)(Value)) >> 16)

//
//   - IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE defines a specific IOCTL for the Gemplus 
//      Reader to exchange data with the reader without control of the driver.
//   - IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to gets vendor attributes.
//   - IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to sets vendor attributes.
//
#define IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE  CTL_CODE(FILE_DEVICE_SMARTCARD,2048,0,0)
#define IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2049,0,0)
#define IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2050,0,0)

//
//   - SCARD_ATTR_SPEC_BAUD_RATE is the Tag to acces at the value of the baud rate (PC/IFD).
//   - SCARD_ATTR_SPEC_CMD_TIMEOUT is the Tag to access at the value of the Cmd Timeout.
//   - SCARD_ATTR_SPEC_POWER_TIMEOUT is the Tag to access at the value of the Power 
//      Timeout.
//   - SCARD_ATTR_SPEC_APDU_TIMEOUT is the Tag to access at the value of the APDU 
//      Timeout.
//
#define SCARD_ATTR_SPEC_BAUD_RATE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0180)
#define SCARD_ATTR_SPEC_CMD_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0181)
#define SCARD_ATTR_SPEC_POWER_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0182)
#define SCARD_ATTR_SPEC_APDU_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0183)

//
//   - SC_IFD_DEFAULT_CLK_FREQUENCY defines the default frequency for the reader.
//   - SC_IFD_MAXIMUM_CLK_FREQUENCY defines the maximum frequency for the reader.
//   - SC_IFD_DEFAULT_DATA_RATE defines the default baud rate for the reader.
//   - SC_IFD_MAXIMUM_DATA_RATE defines the maximum baud rate for the reader.
//   - SC_IFD_MAXIMUM_IFSD defines the maximum IFSD supported by the reader.
//   - SC_IFD_T0_MAXIMUM_LEX defines the maximum LEX in T=0 supported by the reader.
//   - SC_IFD_T0_MAXIMUM_LC defines the maximum LC in T=0 supported by the reader.
//
#define SC_IFD_DEFAULT_CLK_FREQUENCY      3686
#define SC_IFD_MAXIMUM_CLK_FREQUENCY      3686
#define SC_IFD_DEFAULT_DATA_RATE          9909
#define SC_IFD_MAXIMUM_DATA_RATE        158554
#define SC_IFD_MAXIMUM_IFSD                254
#define SC_IFD_T0_MAXIMUM_LEX              256
#define SC_IFD_T0_MAXIMUM_LC               255


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef enum _ACTION {
 	
    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;


//
// Struct section:
//   - _DEVICE_EXTENSION define a struct for the device extension:
//
typedef struct _DEVICE_EXTENSION {

    // Our smart card extension
	 SMARTCARD_EXTENSION SmartcardExtension;

    // The current number of io-requests
    LONG IoCount;

    // Used to signal that the reader is able to process requests
    KEVENT ReaderStarted;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to signal that the connection to the serial driver has been closed
    KEVENT SerialCloseDone;

    // Used to signal that the card status thread is scheduled
    KEVENT CardStatusNotInUse;

	 // The pnp device name of our smart card reader
	 UNICODE_STRING PnPDeviceName;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

    KSPIN_LOCK SpinLock;

    // A worker thread that closes the serial driver
    PIO_WORKITEM CloseSerial;

    // A worker thread that closes the serial driver
    PIO_WORKITEM CardStateChange;


} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
//   - _SERIAL_READER_CONFIG define a struct for the serial configuration:
//
typedef struct _SERIAL_READER_CONFIG {
	// flow control
   SERIAL_HANDFLOW      HandFlow;           

	// special characters
   SERIAL_CHARS         SerialChars;           

	// read/write timeouts
   SERIAL_TIMEOUTS      Timeouts;           

	// Baudrate for reader
   SERIAL_BAUD_RATE     BaudRate;          

	// Stop bits, parity configuration
   SERIAL_LINE_CONTROL  LineControl;    

	// Event serial reader uses to signal insert/removal
   ULONG                SerialWaitMask;                     

} SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

//
//   - _READER_EXTENSION define a struct for the reader specific portion of 
//   the smart card extension.
//    * Handle holds the serial communication handle;
//    * ICCType holds the ICC type.
//    * ICCVpp holds the selected VPP value (G_Oros2IccDefineType).
//    * ICCPresence holds the selected presence byte (G_Oros2IccDefineType).
//    * CmdTimeOut holds the timeout for any command expect an APDU command.
//    * APDUTimeOut holds the timeout for an APDU command.
//    * IFDBaudRate holds the baudrate used between IFD and Host.
//    * PowerTimeOut holds the time for the reader to really power off an ICC
//      after the PowerOff command has been sent.
//    * MaximalBaudRate defines the maximal baud rate for the reader.
//
typedef struct _READER_EXTENSION {
   short                Handle;
   ULONG                CmdTimeOut;
   ULONG                APDUTimeOut;
   ULONG                IFDBaudRate;
   ULONG                PowerTimeOut;
   ULONG                MaximalBaudRate;
   struct _ICC_CONFIG {
      short                ICCType;
      USHORT               ICCVpp;
      USHORT               ICCPresence;
      BYTE                 ICCVcc;
      BYTE                 PTSMode;
      BYTE                 PTS0;
      BYTE                 PTS1;
      BYTE                 PTS2;
      BYTE                 PTS3;
   } IccConfig;
   struct _TRANSPARENT_CONFIG {
      BYTE                 CFG;
      BYTE                 ETU;
      BYTE                 EGT;
      BYTE                 CWT;
      BYTE                 BWI;
      BYTE                 Fi;
      BYTE                 Di;
   } TransparentConfig;
	KMUTEX               LongAPDUMutex;
	KMUTEX               ExchangeMutex;

	ULONG	               SerialIoControlCode;

	SERIAL_READER_CONFIG SerialConfigData;

	PIRP SerialStatusIrp;

    // DeviceObject pointer to serial port
    PDEVICE_OBJECT AttachedDeviceObject;

    // Flag that indicates that the caller requests a power-down or a reset
	BOOLEAN	PowerRequest;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

    // Saved card state for hibernation/sleeping modes.
    BOOLEAN CardPresent;

    // Flag that indicates we're getting the ModemStatus (used in a DPC)
	BOOLEAN	GetModemStatus;

    // Variable used to receive the modem status
	ULONG 	ModemStatus;


} READER_EXTENSION, *PREADER_EXTENSION;

#define READER_EXTENSION(member) (SmartcardExtension->ReaderExtension->member)
#define ATTACHED_DEVICE_OBJECT deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject


//ISV
/*
#undef SmartcardDebug
#define SmartcardDebug(LEVEL, STRING) {DbgPrint STRING;}  
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gemcore.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:  
   GEMCORE.H (GemCore reader operating system functions)

Environment:
   Kernel mode

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.
   22/01/99: V1.00.002 (YN)
	  - Add GetResponse in GDDK_Oros3SIOConfigure special
	  use for increase com speed.

--*/
#ifndef _GEMCORE_H
#define _GEMCORE_H
//
// General C macros.
//
#ifndef LOBYTE
#define LOBYTE(w)   ((BYTE)(w))
#endif
#ifndef HIBYTE
#define HIBYTE(w)   ((BYTE)(((USHORT)(w)) >> 8))
#endif

/*------------------------------------------------------------------------------
Card section:
------------------------------------------------------------------------------*/
#define  ISOCARD                 0x02
#define  TRANSPARENT_PROTOCOL    0xEF
/*------------------------------------------------------------------------------
   Defines the available protocols between reader and card (PTS Mode):
   - IFD_DEFAULT_MODE           -> same as OROS 2.x maximum speed without request,
   - IFD_WITHOUT_PTS_REQUEST    -> no PTS management (baud rate is 9600 bps),
   - IFD_NEGOTIATE_PTS_OPTIMAL  -> PTS management automatically,
   - IFD_NEGOTIATE_PTS_MANUALLY -> PTS management "manually" by parameters. 
   Defines the PTS format (PTS0) and indicates by the bits b5,b6,b7 set to 1 the 
   presence of the optional parameters PTS1,PTS2,PTS3 respectively. The least
   significant bits b1 to b4 select protocol type type T. Use the macro 
   - IFD_NEGOTIATE_PTS1,
   - IFD_NEGOTIATE_PTS2,
   - IFD_NEGOTIATE_PTS3,
   - IFD_NEGOTIATE_T0,
   - IFD_NEGOTIATE_T1 to set these bits.
   Defines the ICC power supply voltage:
   - ICC_VCC_5V is the power supply voltage 5V (by default),
   - ICC_VCC_3V is the power supply voltage 3V,
   - ICC_VCC_DEFAULT is the power supply voltage by default (5V).
------------------------------------------------------------------------------*/
#define IFD_DEFAULT_MODE					0
#define IFD_WITHOUT_PTS_REQUEST				1
#define IFD_NEGOTIATE_PTS_OPTIMAL   		2
#define IFD_NEGOTIATE_PTS_MANUALLY			3

#define IFD_NEGOTIATE_PTS1					0x10
#define IFD_NEGOTIATE_PTS2					0x20
#define IFD_NEGOTIATE_PTS3					0x40

#define IFD_NEGOTIATE_T0					0x00
#define IFD_NEGOTIATE_T1					0x01

#define ICC_VCC_5V							0
#define ICC_VCC_3V							1
#define ICC_VCC_DEFAULT						ICC_VCC_5V


/*------------------------------------------------------------------------------
Product Interface Library section:
   MAX_DUMMY_CHANNEL is used in RFU fields.
   MAX_IFD_CHANNEL defines the maximal IFD supported in a same time by the API.
------------------------------------------------------------------------------*/
#define MAX_DUMMY_CHANNEL   100
#define MAX_IFD_CHANNEL	    16

/*------------------------------------------------------------------------------
   Serial port definitions.
      G_COMx must be used for automatic address selection.
------------------------------------------------------------------------------*/
#define G_COM1        1
#define G_COM2        2
#define G_COM3        3
#define G_COM4        4


/*------------------------------------------------------------------------------
Constant section:
   HGTGBPP maximal size for a message:
      <NAD> <PCB> <Len> <max is 255 bytes> <EDC>
------------------------------------------------------------------------------*/
#define HGTGBP_MAX_DATA        255
#define HGTGBP_MAX_BUFFER_SIZE HGTGBP_MAX_DATA + 4
/*------------------------------------------------------------------------------
Constant section:
 - HOR3COMM_MAX_TRY communication try is launched before the channel is declared
   broken. Today 2.
------------------------------------------------------------------------------*/
#define HOR3COMM_MAX_TRY         2
#define HOR3COMM_MAX_RESYNCH     2
/*------------------------------------------------------------------------------
 - HOR3COMM_CHAR_TIMEOUT is the timeout at character level: today 1000 ms.
 - HOR3COMM_NACK_TIME is the time out used when a nack command is sent to IFD:
      today 1000 ms are used.
 - HOR3COMM_CHAR_TIME is the time for IFD to forget any previously received
      byte: today 300 ms.
------------------------------------------------------------------------------*/
#define HOR3COMM_CHAR_TIMEOUT 1000
#define HOR3COMM_NACK_TIME    1000
#define HOR3COMM_CHAR_TIME     300
/*------------------------------------------------------------------------------
Constant section:
  - HOR3GLL_DEFAULT_TIME is the default timeout for a command to be proceeded by
    an OROS3.X IFD. Today 5s (5000ms).
  - HOR3GLL_LOW_TIME is the timeout used for IFD management commands (500ms).
  - HOR3GLL_DEFAULT_VPP is the default VPP value. Today 0.
  - HOR3GLL_DEFAULT_PRESENCE is the default presence byte. Today 3 for no
    presence detection.                  
  - HOR3GLL_BUFFER_SIZE holds the size for the exchange buffers. We used the
    maximal size for TLP protocol to allow OROS3.X upgrades.
  - HOR3GLL_OS_STRING_SIZE is the size for a GemCore OS string. 16 characters are
    used for <Reader Status>"GemCore-R1.00".
------------------------------------------------------------------------------*/
#define HOR3GLL_DEFAULT_TIME      5000
#define HOR3GLL_APDU_TIMEOUT     60000
#define HOR3GLL_LOW_TIME           500
#define HOR3GLL_DEFAULT_VPP          0
#define HOR3GLL_DEFAULT_PRESENCE     3
#define HOR3GLL_BUFFER_SIZE        261
#define HOR3GLL_OS_STRING_SIZE     HOR3GLL_IFD_LEN_VERSION+1

/*------------------------------------------------------------------------------
   Reader list of commands:
------------------------------------------------------------------------------*/
#define HOR3GLL_IFD_CMD_MODE_SET    		0x01
#define HOR3GLL_IFD_CMD_SIO_SET	    		0x0A
#define HOR3GLL_IFD_CMD_INFO		    		0x0D
#define HOR3GLL_IFD_CMD_ICC_DEFINE_TYPE	0x17
#define HOR3GLL_IFD_CMD_ICC_POWER_DOWN 	0x11
#define HOR3GLL_IFD_CMD_ICC_POWER_UP 		0x12
#define HOR3GLL_IFD_CMD_ICC_ISO_OUT    	0x13
#define HOR3GLL_IFD_CMD_ICC_ISO_IN     	0x14
#define HOR3GLL_IFD_CMD_ICC_APDU    		0x15
#define HOR3GLL_IFD_CMD_TRANS_CONFIG 		0x12
#define HOR3GLL_IFD_CMD_TRANS_IN        	0x15
#define HOR3GLL_IFD_CMD_TRANS_SHORT    	0x15
#define HOR3GLL_IFD_CMD_TRANS_LONG     	0x14
#define HOR3GLL_IFD_CMD_TRANS_RESP     	0x13

#define HOR3GLL_IFD_CMD_ICC_SYNCHRONE 	   0x16
#define HOR3GLL_IFD_CMD_ICC_STATUS    	   0x17
#define HOR3GLL_IFD_CMD_MEM_RD	    		0x22
#define HOR3GLL_IFD_CMD_MEM_WR	    		0x23
/*------------------------------------------------------------------------------
   Reader special address:
------------------------------------------------------------------------------*/
#define HOR3GLL_IFD_TYP_VERSION	    		0x05
#define HOR3GLL_IFD_ADD_VERSION	    		0x3FE0
#define HOR3GLL_IFD_LEN_VERSION	    		0x10
/*------------------------------------------------------------------------------
Constant section
 - HT0CASES_LIN_SHORT_MAX define the maximum Lin value for a short case.
------------------------------------------------------------------------------*/
#define HT0CASES_LIN_SHORT_MAX   255


/*------------------------------------------------------------------------------
Connexion section:
   COM_TYPE defines the today supported Gemplus peripheral connection type.
------------------------------------------------------------------------------*/
typedef enum
{
   G_SERIAL
} COM_TYPE;
/*------------------------------------------------------------------------------
   Serial port definitions.
      COM_SERIAL structure gathers the serial port parameters:
         - Port holds the port key word or directly the port address.
           Under Windows, it is not possible to give directly the address.
         - BaudRate holds the baud rate for the selected communication port.
------------------------------------------------------------------------------*/
typedef struct
{
    ULONG  Port;
    ULONG  BaudRate;
    void  *pSmartcardExtension;
} COM_SERIAL;



NTSTATUS  GDDK_Translate(
    const BYTE  IFDStatus,
    const ULONG IoctlType
);
NTSTATUS  GDDK_GBPOpen
(
    const SHORT  Handle,
    const USHORT HostAdd,
    const USHORT IFDAdd,
    const SHORT  PortCom   
);
NTSTATUS  GDDK_GBPClose
(
    const SHORT  Handle
);
NTSTATUS  GDDK_GBPBuildIBlock
(
    const SHORT         Handle,
    const USHORT        CmdLen, 
    const BYTE          Cmd[], 
          USHORT       *MsgLen,
          BYTE          Msg[]
);
NTSTATUS  GDDK_GBPBuildRBlock
(
    const SHORT         Handle,
          USHORT       *MsgLen,
          BYTE          Msg[]
);
NTSTATUS  GDDK_GBPBuildSBlock
(
    const SHORT         Handle,
          USHORT       *MsgLen,
          BYTE          Msg[]
);
NTSTATUS  GDDK_GBPDecodeMessage
(
    const SHORT         Handle,
    const USHORT        MsgLen, 
    const BYTE          Msg[], 
          USHORT       *RspLen,
          BYTE          Rsp[]
);
NTSTATUS  GDDK_GBPChannelToPortComm
(
    const SHORT  Handle,
          SHORT *PortCom
);
NTSTATUS  GDDK_Oros3SendCmd
(
    const SHORT        Handle,
    const USHORT       CmdLen,
    const BYTE         Cmd[],
    const BOOLEAN      Resynch
);
NTSTATUS  GDDK_Oros3ReadResp
(
    const SHORT         Handle,
    const ULONG         Timeout,
          USHORT       *RspLen,
          BYTE          Rsp[]
);
NTSTATUS  GDDK_Oros3OpenComm
(
    COM_SERIAL   *Param,
    const SHORT         Handle
);
NTSTATUS  GDDK_Oros3Exchange
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const USHORT        CmdLen,
    const BYTE          Cmd[],
          USHORT       *RspLen,
          BYTE          Rsp[]
);
NTSTATUS  GDDK_Oros3CloseComm
(
    const USHORT Handle
);
NTSTATUS  GDDK_Oros3SIOConfigure
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const SHORT         Parity,
    const SHORT         ByteSize,
    const ULONG         BaudRate,
          USHORT       *RspLen,
          BYTE          Rsp[],
	const BOOLEAN		GetResponse
);

NTSTATUS  GDDK_Oros3IccPowerUp
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          ICCVcc,
    const BYTE          PTSMode,
    const BYTE          PTS0,
    const BYTE          PTS1,
    const BYTE          PTS2,
    const BYTE          PTS3,
          USHORT       *RespLen,
          BYTE          RespBuff[]
);
NTSTATUS  GDDK_Oros3IsoOutput
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          OrosCmd,
    const BYTE          Command[5],
          USHORT       *RespLen,
          BYTE          RespBuff[]
);
NTSTATUS  GDDK_Oros3IsoInput
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          OrosCmd,
    const BYTE          Command[5],
    const BYTE          Data[],
          USHORT       *RespLen,
          BYTE          RespBuff[]
);
NTSTATUS  GDDK_Oros3TransparentExchange
(
    const SHORT         Handle,
    const ULONG         Timeout,
    const USHORT        CmdLen,
    const BYTE         *CmdBuff,
          USHORT       *RespLen,
          BYTE         *RespBuff
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gioctl0a.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:  
   GIOCTL0A.H (Gemplus IOCTL Smart card Reader module 0A)


Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.

--*/
#ifndef _GIOCTL0A_
#define _GIOCTL0A_


//
// Prototype section
//
NTSTATUS 
GDDK_0AReaderPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0AIccReset(
	PSMARTCARD_EXTENSION SmartcardExtension,
	ULONG                ResetType
	);

NTSTATUS 
GDDK_0ASetProtocol(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0ATransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0ACardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0AVendorIoctl(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0AVendorTag(
	PSMARTCARD_EXTENSION   SmartcardExtension,
	ULONG                  IoControlCode,
	ULONG                  BufferInLen,
	PUCHAR                 BufferIn,
	ULONG                  BufferOutLen,
	PUCHAR                 BufferOut,
	PULONG                 LengthOut
	);

NTSTATUS
GDDK_0AUpdateCardStatus(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID 
GDDK_0ALockExchange(
	PSMARTCARD_EXTENSION   SmartcardExtension
	);

VOID
GDDK_0AUnlockExchange(
	PSMARTCARD_EXTENSION   SmartcardExtension
	);


NTSTATUS 
GDDK_0AOpenChannel(
	PSMARTCARD_EXTENSION SmartcardExtension,
	CONST ULONG          DeviceNumber,
	CONST ULONG          PortSerialNumber,
	CONST ULONG          MaximalBaudRate
	);

NTSTATUS 
GDDK_0ACloseChannel(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GDDK_0ARestoreCommunication(
	PSMARTCARD_EXTENSION   SmartcardExtension
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410\gntser.h ===
/*******************************************************************************
*                 Copyright (c) 1997 Gemplus developpement
*
* Name        : GNTSER.H (Gemplus NT SERial management)
*
* Description : This module holds the prototypes of the functions from GNTSER.C
*
* Release     : 1.00.001
*
* Last Modif  : 22/06/97: V1.00.001  (GPZ)
*                 - Start of development.
*
********************************************************************************
*
* Warning     :
*
* Remark      :
*
*******************************************************************************/

/*------------------------------------------------------------------------------
Constant section:
 - HGTSER_MAX_PORT holds the number of managed port. Today 4.
 - HGTSER_WORD_5, HGTSER_WORD_6, HGTSER_WORD_7 and HGTSER_WORD_8 allow to 
   configure the number of bits per word.
 - HGTSER_STOP_BIT_1 and HGTSER_STOP_BIT_2 allow to configure the number of stop
   bit.
 - HGTSER_NO_PARITY, HGTSER_ODD_PARITY and HGTSER_EVEN_PARITY allow to configure
   the communication parity.
 - HGTSER_TX_QUEUE and HGTSER_RX_QUEUE are queues indentifiers.
 - HGTSER_RX_OVER is set when the reception queue is full and characters has 
   been lost.                                                                   
 
 - HGTSER_RTS_LINE is identifier of RTS line for Line status functions.
 - HGTSER_DTR_LINE is identifier of DTR line for Line status functions.
------------------------------------------------------------------------------*/
#define HGTSER_MAX_PORT          4
#define HGTSER_WORD_5         0x00
#define HGTSER_WORD_6         0x01
#define HGTSER_WORD_7         0x02
#define HGTSER_WORD_8         0x03
#define HGTSER_STOP_BIT_1     0x00
#define HGTSER_STOP_BIT_2     0x04
#define HGTSER_NO_PARITY      0x00
#define HGTSER_ODD_PARITY     0x08
#define HGTSER_EVEN_PARITY    0x18
#define HGTSER_TX_QUEUE          1
#define HGTSER_RX_QUEUE          2
#define HGTSER_RX_OVER           1

#define HGTSER_RTS_LINE       0
#define HGTSER_DTR_LINE       1

/*------------------------------------------------------------------------------
Constant section:
 - WTX_TIMEOUT is the time out used when a WTX REQUEST is send by  the CT.
 - CHAR_TIMEOUT is the timeout at character level: today 1000 ms.
------------------------------------------------------------------------------*/
#define WTX_TIMEOUT 3000
#define CHAR_TIMEOUT 1000
/*------------------------------------------------------------------------------
Type section:
 - TGTSER_PORT gathers data used to manage a serial port:
    * Port     indicates the selected port.
               G_COM1, G_COM2, G_COM3 or G_COM4
    * BaudRate is used to set port baud rate when open routine is called.
               300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200
    * ITNumber indicates the interrupt number to use. The 0XFF value indicates
               the default value. Allowed number are from 0 to 15.
    * Mode     Memorises
               WORD size       : 5, 6, 7 or 8
               stop bit number : 1 or 2
               parity          : no parity, odd or even parity
    * TimeOut  indicates the time out value, in milli-seconds, at character
               level.
    * TxSize   is the transmit buffer size, in bytes.
    * RxSize   is the reception buffer size, in mbytes.
------------------------------------------------------------------------------*/
typedef struct
{
   INT16   Port;
   WORD32  BaudRate;
   WORD16  ITNumber;
   WORD16  Mode;
   WORD16  TimeOut;
   WORD16  TxSize;
   WORD16  RxSize;
   void *pSmartcardExtension;
} TGTSER_PORT;
/*------------------------------------------------------------------------------
 - TGTSER_STATUS holds status bit about the serial communication.
   Today only HGTSER_RX_OVER can be set or not.
------------------------------------------------------------------------------*/
typedef WORD16 TGTSER_STATUS;


/*------------------------------------------------------------------------------
Prototypes section:
------------------------------------------------------------------------------*/
INT16  G_SerPortOpen
(
   const TGTSER_PORT  *Param
);
INT16  G_SerPortClose
(
   const INT16 Handle
);
INT16  G_SerPortWrite
(
   const INT16        Handle,
   const WORD16       Length,
   const BYTE         Buffer[]
);
INT16  G_SerPortRead
(
   const INT16         Handle,
         WORD16       *Length,
         BYTE          Buffer[]
);
INT16  G_SerPortFlush
(
   const INT16  Handle,
   const WORD16 Select
);
INT16  G_SerPortStatus
(
   const INT16                Handle,
         WORD16               *TxLength,
         WORD16              *RxLength,
         TGTSER_STATUS       *Status
);
INT16  G_SerPortAddUser
(
   const INT16  Port
);
INT16  G_SerPortGetState
(
   TGTSER_PORT       *Param,
   WORD16            *UserNb
);
INT16  G_SerPortSetState
(
   TGTSER_PORT       *Param
);
INT32  G_SerPortLockComm
(
    const INT16 Handle,
    const DWORD WaitRelease
);
void  G_SerPortUnlockComm
(
    const INT16 Handle
);

NTSTATUS GDDKNT_SerPortIoRequest
(
   IN CONST INT16          Handle,
   IN CONST ULONG          SerialIoControlCode,
   IN CONST ULONG          CmdTimeout,
   IN CONST WORD16         LengthIn,
   IN CONST BYTE          *BufferIn,
   IN OUT   WORD16        *pLengthOut,
   OUT      BYTE          *BufferOut
);

NTSTATUS GDDKNT_SetCommState
(
	const INT16         Handle,
	SERIAL_READER_CONFIG *SerialConfig
);
NTSTATUS GDDKNT_GetCommState
(
	const INT16         Handle,
	SERIAL_READER_CONFIG *SerialConfig
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gemcore.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
   GEMCORE.C (GemCore reader operating system functions)

Environment:
   Kernel mode

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.
   25/04/98: V1.00.002  (GPZ)
      - Remove the G+ error code.
   22/01/99: V1.00.003 (YN)
     - Add GetResponse in GDDK_Oros3SIOConfigure special
     use for increase com speed.

--*/


#include <string.h>
#include "gntscr.h"
#include "gntser.h"

//
// Local constant section:
// - IBLOCK_PCB (0x00) and IBLOCK_MASK (0xA0) are used to detect the I-Block PCB
//   signature (0x0xxxxxb).
// - IBLOCK_SEQ_POS indicates the number of left shift to apply to 0000000xb for
//   x to be the sequence bit for a I-Block.
// - RBLOCK_PCB (0x80) and RBLOCK_MASK (0xEC) are used to detect the R-Block PCB
//   signature (100x00xx).
// - RBLOCK_SEQ_POS indicates the number of left shift to apply to 0000000xb for
//   x to be the sequence bit for a R-Block.
// - ERR_OTHER and ERR_EDC are the error bits in a R-Block PCB.
// - RESYNCH_REQUEST (0xC0) and RESYNCH_RESPONSE (0xE0) are the PCB used in
//   S-Blocks.
//
#define IBLOCK_PCB       0x00
#define IBLOCK_MASK      0xA0
#define IBLOCK_SEQ_POS   0x06
#define RBLOCK_PCB       0x80
#define RBLOCK_MASK      0xEC
#define RBLOCK_SEQ_POS   0x04
#define ERR_OTHER        0x02
#define ERR_EDC          0x01
#define RESYNCH_REQUEST  0xC0
#define RESYNCH_RESPONSE 0xE0

//
//Macro section:
// - HOST2IFD (Handle) returns the NAD byte for message from Host to IFD.
// - IFD2HOST (Handle) returns the NAD byte awaited in an IFD message.
// - MK_IBLOCK_PCB  (x) builds an I-Block PCB where x is the channel handle.
// - MK_RBLOCK_PCB  (x) builds an R-Block PCB where x is the channel handle.
// - ISA_IBLOCK_PCB (x) return TRUE if the given parameter is a I-Block PCB.
// - ISA_RBLOCK_PCB (x) return TRUE if the given parameter is a R-Block PCB.
// - SEQ_IBLOCK     (x) return the state of the sequence bit: 0 or 1.
// - INC_SEQUENCE   (x) increment a sequence bit: 0 -> 1 and 1 -> 0.
//
#define HOST2IFD(Handle)  ((BYTE )                                           \
                             (                                               \
                                (gtgbp_channel[(Handle)].IFDAdd << 4)        \
                               + gtgbp_channel[(Handle)].HostAdd             \
                             )                                               \
                          )
#define IFD2HOST(Handle)  ((BYTE )                                           \
                             (                                               \
                                (gtgbp_channel[(Handle)].HostAdd << 4)       \
                               + gtgbp_channel[(Handle)].IFDAdd              \
                             )                                               \
                          )
#define MK_IBLOCK_PCB(x)  ((BYTE )                                           \
                             (                                               \
                                IBLOCK_PCB                                   \
                              + (gtgbp_channel[(x)].SSeq << IBLOCK_SEQ_POS)  \
                             )                                               \
                          )
#define MK_RBLOCK_PCB(x)  ((BYTE )                                           \
                             (                                               \
                                RBLOCK_PCB                                   \
                              + (gtgbp_channel[(x)].RSeq << RBLOCK_SEQ_POS)  \
                              + gtgbp_channel[(x)].Error                     \
                             )                                               \
                          )
#define ISA_IBLOCK_PCB(x) (((x) & IBLOCK_MASK) == IBLOCK_PCB)
#define ISA_RBLOCK_PCB(x) (((x) & RBLOCK_MASK) == RBLOCK_PCB)
#define SEQ_IBLOCK(x)     (((x) & (0x01 << IBLOCK_SEQ_POS)) >> IBLOCK_SEQ_POS)
#define INC_SEQUENCE(x)   (x) = (BYTE )(((x) + 1) % 2)

//
// Types section:
//  - TGTGBP_CHANNEL gathers information about a channel:
//     * UserNb is the number of user for the channel.
//     * HostAdd holds the address identifier for the host in 0..15.
//     * IFDAdd holds the address identifier for the associated IFD in 0..15.
//     * PortCom holds the serial port number
//     * SSeq holds the sequence bit for the next I-Block to send: 0 or 1.
//     * RSeq holds the awaited sequence bit: 0 or 1.
//     * Error gathers the encountered error conditions.
//
typedef struct
{
    BYTE  UserNb;
    BYTE  HostAdd;
    BYTE  IFDAdd;
    short PortCom;
    BYTE  SSeq;
    BYTE  RSeq;
    BYTE  Error;
} TGTGBP_CHANNEL;

//
// Global variable section:
//  - gtgbp_channel[MAX_IFD_CHANNEL] is an array of TGTGBP_CHANNEL which memorises
//    the communication parameters for each opened channel.
//  - handle_GBP is a conversion for the logical channel to the GBP channel.
//
static TGTGBP_CHANNEL
   gtgbp_channel[MAX_IFD_CHANNEL] =
   {
      {0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0}
   };

static short
   handle_GBP[MAX_IFD_CHANNEL] =
   {
      {0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0}
   };







NTSTATUS
GDDK_GBPOpen(
    const SHORT  Handle,
    const USHORT HostAdd,
    const USHORT IFDAdd,
    const SHORT  PortCom
   )
/*++

Routine Description:

 This function initialises internal variables for communicating in Gemplus
 Block protocol through a serial port.
 This function must be called before any other in this module.

Arguments:

   Handle      - holds the communication handle to associate to the channel.
   HostAdd     - is the host address. A valid value must be in 0.. 15. The memorised
      value is (HostAdd mod 16).
   AFDAdd      - is the IFD address. A valid value must be in 0.. 15. The memorised
      value is (IFDAdd mod 16). This value should be different from the HostAdd.
   PortCom     - holds the serial port number

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    SHORT cptHandleLog=0,present=-1;

    //
    // The given parameters are controlled:
    //
    if (
        ((Handle < 0)   || (Handle >= MAX_IFD_CHANNEL))   ||
        ((HostAdd <= 0) || (HostAdd >= MAX_IFD_CHANNEL))  ||
        ((IFDAdd <= 0)  || (IFDAdd >= MAX_IFD_CHANNEL))   ||
        (HostAdd == IFDAdd)
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    if ((PortCom < 0) || (PortCom >= HGTSER_MAX_PORT)) {

        return STATUS_PORT_DISCONNECTED;
    }

    // Scan the structure to found an already opened channel for the same PortCom
    // and HostAdd.
    while ((cptHandleLog<MAX_IFD_CHANNEL) && (present <0)) {

        if ((IFDAdd  == gtgbp_channel[cptHandleLog].IFDAdd)  &&
            (HostAdd == gtgbp_channel[cptHandleLog].HostAdd) &&
            (PortCom == gtgbp_channel[cptHandleLog].PortCom) &&
            (gtgbp_channel[cptHandleLog].UserNb > 0)
           ) {

            present = cptHandleLog;
        }
        cptHandleLog++;
    }
    // If IFDAdd, PortCom, and HostAdd fields exists
    // Increment the user number counter and write in the array handle_GBP
    // the handle of the GBP.
    if (present != -1) {

        gtgbp_channel[present].UserNb += 1;
        handle_GBP[Handle] = present;
        return STATUS_SUCCESS;
    }

    // Scan the structure to find the first line free
    cptHandleLog=0;
    present=-1;
    while ((cptHandleLog<MAX_IFD_CHANNEL) && (present <0)) {

        if (gtgbp_channel[cptHandleLog].UserNb==0) {

            present=cptHandleLog;
        }
        cptHandleLog++;
    }
    if (present == -1) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    handle_GBP[Handle]= present;

    // Memorises the given parameters and initializes gtgbp_channel structure.
    // - UserNb is initialized to 1
    // - HostAdd and IFDAdd holds the associated parameter low part of low byte.
    // - PortCom is initialized to PortCom value
    // - SSeq and RSeq are initialized to 0.
    // - Error is reseted to 0.
    gtgbp_channel[handle_GBP[Handle]].UserNb   = 1;
    gtgbp_channel[handle_GBP[Handle]].HostAdd  = (BYTE )(HostAdd & 0x000F);
    gtgbp_channel[handle_GBP[Handle]].IFDAdd   = (BYTE )(IFDAdd  & 0x000F);
    gtgbp_channel[handle_GBP[Handle]].PortCom   = PortCom;
    gtgbp_channel[handle_GBP[Handle]].SSeq     = 0;
    gtgbp_channel[handle_GBP[Handle]].RSeq     = 0;
    gtgbp_channel[handle_GBP[Handle]].Error    = 0;
    return STATUS_SUCCESS;
}


NTSTATUS
GDDK_GBPClose(
    const short  Handle
   )
/*++

Routine Description:

 This function resets internal variables for communicating in Gemplus Block
 protocol through a serial port.
 This function must be called for each opened channel (GDDK_GBPOpen).

Arguments:

   Handle      - holds the communication handle to associate to the channel.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
   // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    // Test channel state (UseNbr field different from 0)
    if (gtgbp_channel[handle_GBP[Handle]].UserNb == 0) {

        return STATUS_PORT_DISCONNECTED;
    }
    // Decrement the gtgbp_channel structure UserNb field.
    gtgbp_channel[handle_GBP[Handle]].UserNb -= 1;
    return STATUS_SUCCESS;
}




NTSTATUS
GDDK_GBPBuildIBlock(
    const SHORT         Handle,
    const USHORT        CmdLen,
    const BYTE          Cmd[],
          USHORT       *MsgLen,
          BYTE          Msg[]
   )
/*++

Routine Description:

 This function takes a command and builds an Information Gemplus Block
 Protocol. When this command is successful, the send sequence bit is updated for
 the next exchange.

Arguments:

   Handle      - holds the communication handle to associate to the channel.
   CmdLen      - indicates the number of bytes in the Cmd buffer.
                 This value must be lower than HGTGBP_MAX_DATA (Today 254).
   Cmd         - holds the command bytes.
   MsgLen      - indicates the number of available bytes in Msg.
   Msg         - is updated by the message.


Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE edc;
    USHORT i,j = 0;

    ASSERT(Cmd != NULL);
    ASSERT(MsgLen != NULL);
    ASSERT(Msg != NULL);

    // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    // Test channel state (UserNb different from 0)
    if (gtgbp_channel[handle_GBP[Handle]].UserNb == 0) {

        return STATUS_PORT_DISCONNECTED;
   }
   // Test CmdLen (<= HGTGBP_MAX_DATA) and MsgLen (>= 4 + CmdLen)
   // Msg must be able to receive the following GBP block
   //      <NAD> <PCB> <Len> [ Data ...] <EDC>
   if ((CmdLen > HGTGBP_MAX_DATA) || (*MsgLen < CmdLen + 4)) {

        return STATUS_INVALID_PARAMETER;
   }

    // The message is built:
    // NAD holds Target address in high part and Source address in low part.
    // PCB holds I-Block mark: 0 SSeq 0 x x x x x
    // Len is given by CmdLen
    // [.. Data ..] are stored in Cmd.
    // EDC is an exclusive or of all the previous bytes.
    //    It is updated when Msg buffer is updated.
    edc  = Msg[j++] = HOST2IFD(handle_GBP[Handle]);
    edc ^= Msg[j++] = MK_IBLOCK_PCB(handle_GBP[Handle]);
    edc ^= Msg[j++] = (BYTE ) CmdLen;
    for (i = 0; i < CmdLen; i++) {

        edc ^= Msg[j++] = Cmd[i];
    }
    Msg[j++] = edc;
    *MsgLen = (USHORT)j;
    // The sequence number is updated for the next exchange.
    INC_SEQUENCE(gtgbp_channel[handle_GBP[Handle]].SSeq);
    return STATUS_SUCCESS;
}


NTSTATUS
GDDK_GBPBuildRBlock(
   const SHORT     Handle,
        USHORT    *MsgLen,
        BYTE      Msg[]
   )
/*++

Routine Description:

 This function builds a Repeat Gemplus Block Protocol.

Arguments:

   Handle      - holds the communication handle to associate to the channel.
   MsgLen      - indicates the number of available bytes in Msg.
                 This value must be at least 4 to allow to build the message.
   Msg         - holds the message to send.


Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE edc;
    USHORT j = 0;

    ASSERT(MsgLen != NULL);
    ASSERT(Msg != NULL);

   // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    // Test channel state (UserNb different from 0)
    if (gtgbp_channel[handle_GBP[Handle]].UserNb == 0) {

        return STATUS_PORT_DISCONNECTED;
    }
    // Test MsgLen (>= 4 )
    // Msg must be able to receive the following GBP block <NAD> <PCB> <0> <EDC>
    if (*MsgLen < 4) {

        return STATUS_INVALID_PARAMETER;
    }

    // The message is built:
    // NAD holds Target address in high part and Source address in low part.
    // PCB holds R-Block mark: 1 0 0 RSeq 0 x x x x x
    // Len is null
    // EDC is an exclusive or of all the previous bytes.
    // It is updated when Msg buffer is updated.
    edc  = Msg[j++] = HOST2IFD(handle_GBP[Handle]);
    edc ^= Msg[j++] = MK_RBLOCK_PCB(handle_GBP[Handle]);
    edc ^= Msg[j++] = 0;
    Msg[j++] = edc;
    *MsgLen = (USHORT)j;
    return STATUS_SUCCESS;
}



NTSTATUS
GDDK_GBPBuildSBlock(
    const SHORT         Handle,
          USHORT       *MsgLen,
          BYTE          Msg[]
   )
/*++

Routine Description:

 This function builds a Synchro request Gemplus Block Protocol.

Arguments:

   Handle      - holds the communication handle to associate to the channel.
   MsgLen      - indicates the number of available bytes in Msg.
                 This value must be at least 4 to allow to build the message.
   Msg         - holds the message to send.


Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE edc;
    USHORT j = 0;

    ASSERT(MsgLen != NULL);
    ASSERT(Msg != NULL);

    // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {
        return STATUS_INVALID_PARAMETER;
    }
    // Test channel state (UserNb different from 0)
    if (gtgbp_channel[handle_GBP[Handle]].UserNb == 0) {
        return STATUS_PORT_DISCONNECTED;
    }
    // Test MsgLen (>= 4 )
    // Msg must be able to receive the following GBP block <NAD> <PCB> <0> <EDC>
    if (*MsgLen < 4) {

        return STATUS_INVALID_PARAMETER;
    }

    // The message is built:
    // NAD holds Target address in high part and Source address in low part.
    // PCB holds R-Block mark: 1 1 0 0 0 0 0 0
    // Len is null
    // EDC is an exclusive or of all the previous bytes.
    //    It is updated when Msg buffer is updated.
    edc  = Msg[j++] = HOST2IFD(handle_GBP[Handle]);
    edc ^= Msg[j++] = RESYNCH_REQUEST;
    edc ^= Msg[j++] = 0;
    Msg[j++] = edc;
    *MsgLen = (USHORT)j;
    return STATUS_SUCCESS;
}



NTSTATUS
GDDK_GBPDecodeMessage(
    const SHORT         Handle,
    const USHORT        MsgLen,
    const BYTE          Msg[],
          USHORT       *RspLen,
          BYTE          Rsp[]
   )
/*++

Routine Description:

 This function takes a Gemplus Block Protocol message and extract the response
 from it.
 The awaited sequence bit is updated when a valid I-Block has been received.
 The sequence bits are reseted when a valid RESYNCH RESPONSE has been received.

Arguments:

   Handle      - holds the communication handle to associate to the channel.
   MsgLen      - indicates the number of available bytes in Msg.
                 This value must be at least 4 to allow to build the message.
   Msg         - holds the message to read.
   RspLen      - indicates the number of available bytes in Rsp.
   Rsp         - holds the response.


Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE edc;
    USHORT j;
    NTSTATUS response;
    BOOLEAN resynch = FALSE;

    ASSERT(Msg != NULL);
    ASSERT(RspLen != NULL);
    ASSERT(Rsp != NULL);
    // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    // Test channel state (UserNb different from 0)
    if (gtgbp_channel[handle_GBP[Handle]].UserNb == 0) {

        return STATUS_PORT_DISCONNECTED;
    }
    // Reset the associated error field.
    gtgbp_channel[handle_GBP[Handle]].Error = 0;
    // Verifies the message frame and copies the data bytes:
    // Test NAD (HostAdd | IFDAdd)
    if (Msg[0] != IFD2HOST(handle_GBP[Handle])) {

        *RspLen =0;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    edc = Msg[0];
    if (Msg[1] == RESYNCH_RESPONSE)  {

        response = STATUS_SYNCHRONIZATION_REQUIRED;
        resynch = TRUE;

    } else if (ISA_RBLOCK_PCB(Msg[1])) {

        response = STATUS_UNSUCCESSFUL;
    } else if (ISA_IBLOCK_PCB(Msg[1])) {

        if ( (BYTE ) SEQ_IBLOCK(Msg[1]) != gtgbp_channel[handle_GBP[Handle]].RSeq) {

            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        response = STATUS_SUCCESS;
    } else {

        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    edc ^= Msg[1];
    // Test Len (Len + 4 = MsgLen and RspLen >= Len)
    // This error update the Error.other bit.
    if (((USHORT)Msg[2] > *RspLen) || ((USHORT)(Msg[2] + 4) != MsgLen)) {

        *RspLen =0;
        gtgbp_channel[handle_GBP[Handle]].Error |= ERR_OTHER;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    edc ^= Msg[2];
    // Copies the data bytes, updates RspLen and calculated edc.
    *RspLen = (USHORT)Msg[2];
    for (j = 0; j < *RspLen; j++) {

        Rsp[j] = Msg[j + 3];
        edc ^= Rsp[j];
    }
    // Test the read EDC
    if (edc != Msg[j + 3]) {

        *RspLen = 0;
        gtgbp_channel[handle_GBP[Handle]].Error |= ERR_EDC;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    // Updates the awaited sequence bit when a valid I-Block has been received.
    if (response == STATUS_SUCCESS) {

        INC_SEQUENCE(gtgbp_channel[handle_GBP[Handle]].RSeq);
    } else if (resynch) {
        // Reset the sequence bits when a valid S-Block has been received.
        gtgbp_channel[handle_GBP[Handle]].SSeq = gtgbp_channel[handle_GBP[Handle]].RSeq = 0;
    }
    return response;
}



NTSTATUS
GDDK_GBPChannelToPortComm(
    const SHORT  Handle,
          SHORT *PortCom
   )
/*++

Routine Description:

 This function return a physical port associate with the Logical Channel

Arguments:

   Handle      - holds the communication handle to associate to the channel.

Return Value:

    the value of the physical port.

--*/
{
    // The given parameters are controlled:
    if (
        ((Handle < 0) || (Handle >= MAX_IFD_CHANNEL)) ||
        ((handle_GBP[Handle] < 0) || (handle_GBP[Handle] >= MAX_IFD_CHANNEL))
       ) {

        return STATUS_INVALID_PARAMETER;
    }
    *PortCom = gtgbp_channel[handle_GBP[Handle]].PortCom;
    return STATUS_SUCCESS;
}



NTSTATUS
GDDK_Translate(
    const BYTE  IFDStatus,
    const ULONG IoctlType
   )
/*++

Routine Description:

 Translate IFD status in NT status codes.

Arguments:

   IFDStatus   - is the value to translate.
   IoctlType  - is the current smart card ioctl.

Return Value:

    the translated code status.

--*/
{
    switch (IFDStatus) {

    case 0x00 : return STATUS_SUCCESS;
    case 0x01 : return STATUS_NO_SUCH_DEVICE;
    case 0x02 : return STATUS_NO_SUCH_DEVICE;
    case 0x03 : return STATUS_INVALID_PARAMETER;
    case 0x04 : return STATUS_IO_TIMEOUT;
    case 0x05 : return STATUS_INVALID_PARAMETER;
    case 0x09 : return STATUS_INVALID_PARAMETER;
    case 0x10 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x11 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x12 : return STATUS_INVALID_PARAMETER;
    case 0x13 : return STATUS_CONNECTION_ABORTED;
    case 0x14 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x15 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x16 : return STATUS_INVALID_PARAMETER;
    case 0x17 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x18 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x19 : return STATUS_INVALID_PARAMETER;
    case 0x1A : return STATUS_INVALID_PARAMETER;
    case 0x1B : return STATUS_INVALID_PARAMETER;
    case 0x1C : return STATUS_INVALID_PARAMETER;
    case 0x1D : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x1E : return STATUS_INVALID_PARAMETER;
    case 0x1F : return STATUS_INVALID_PARAMETER;
    case 0x20 : return STATUS_INVALID_PARAMETER;
    case 0x30 : return STATUS_IO_TIMEOUT;
    case 0xA0 : return STATUS_SUCCESS;
    case 0xA1 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xA2 :
        if      (IoctlType == RDF_CARD_POWER) { return STATUS_UNRECOGNIZED_MEDIA;}
        else                                  { return STATUS_IO_TIMEOUT;        }
    case 0xA3 : return STATUS_PARITY_ERROR;
    case 0xA4 : return STATUS_REQUEST_ABORTED;
    case 0xA5 : return STATUS_REQUEST_ABORTED;
    case 0xA6 : return STATUS_REQUEST_ABORTED;
    case 0xA7 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xCF : return STATUS_INVALID_PARAMETER;
    case 0xE4 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xE5 : return STATUS_SUCCESS;
    case 0xE7 : return STATUS_SUCCESS;
    case 0xF7 : return STATUS_NO_MEDIA;
    case 0xF8 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xFB : return STATUS_NO_MEDIA;
    default   : return STATUS_INVALID_PARAMETER;
    }
}




NTSTATUS
GDDK_Oros3SIOConfigure(
    const SHORT         Handle,
    const ULONG         Timeout,
    const SHORT         Parity,
    const SHORT         ByteSize,
    const ULONG         BaudRate,
          USHORT       *RspLen,
          BYTE          Rsp[],
   const BOOLEAN     GetResponse
   )
/*++

Routine Description:

 This command sets the SIO line parity, baud rate and number of bits per
    character.
 After a reset, the line defaults is no parity, 8 bits per character and 9600
 bauds.
 This command must be sent 2 times because:
  - when the IFD receive the command, it switch immediatly and sends its
    response according to the new parameters. Host cannot receive this
    response.
  - the second call change nothing, so the host receive the response.

  The configure SIO line command format is
         <0Ah> <Configuration byte>
                XXXXXXXXb
                |||||\-/ codes the selected baud rate according to
                |||||000    RFU
                |||||001    76800
                |||||010    38400
                |||||011    19200
                |||||100     9600
                |||||101     4800
                |||||110     2400
                |||||111     1200
                ||||---- codes the character size according to
                ||||0       for 8 bits per character
                ||||1       for 7 bits per character
                |||----- codes the parity according to
                |||0        for no parity
                |||1        for even parity
                \-/      are not used.

Arguments:

   Handle   - is the handle returned by the communication layer.
   Timeout   - is the time, in ms, for IFD to send its response.
   Parity   - can hold 0 for no parity or 2 for even parity.
   ByteSize - can hold 7 or 8 bits per character.
   BaudRate - can hold 1200, 2400, 4800, 9600, 19200, 38400 or 76800. This last
               value is not allowed on PC.
   RespLen  - holds the available place in RespBuff. The needed value is 1 byte.
   RespBuff - holds RespLen read bytes. The response has the following format:
               <IFD status>

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
   NTSTATUS NTStatus;
    BYTE cmd[2] = { HOR3GLL_IFD_CMD_SIO_SET };

    ASSERT(RspLen != NULL);
    ASSERT(Rsp != NULL);
    // The configuration byte is set with the given parameters:
    // Switch the BaudRate value, the corresponding code initializes cmd[1].
    // default case returns the following error:  GE_HOST_PARAMETERS
    switch (BaudRate) {

    case 38400lu:
        cmd[1] = 0x02;
        break;
    case 19200lu:
        cmd[1] = 0x03;
        break;
    case  9600lu:
        cmd[1] = 0x04;
        break;
    default   :
        return STATUS_INVALID_PARAMETER;
    }

    // Switch the ByteSize value, the corresponding code is added to cmd[1].
    // default case returns the following error:  GE_HOST_PARAMETERS
    switch (ByteSize) {

    case 8 :
        break;
    case 7 :
        cmd[1] += 0x08;
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

    // Switch the Parity value, the corresponding code is added to cmd[1].
    // default case returns the following error: GE_HOST_PARAMETERS
    switch (Parity) {
    case 0 :
        break;
    case 2:
        cmd[1] += 0x10;
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

   if(GetResponse){
      NTStatus = GDDK_Oros3Exchange(Handle,Timeout,2,cmd,RspLen,Rsp);
   }else{
       BOOLEAN resynch = FALSE;
      USHORT index;

            SmartcardDebug(
                DEBUG_TRACE,
                ("%s!GDDK_Oros3IOConfigure: CMD=",
                SC_DRIVER_NAME)
                );
            for(index=0;index<2;index++) {
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%02X,",
                    cmd[index])
                    );
            }
            SmartcardDebug(
                DEBUG_TRACE,
                ("\n")
                );

         NTStatus = GDDK_Oros3SendCmd(Handle,2,cmd,resynch);
   }
    return NTStatus;
}


NTSTATUS
GDDK_Oros3OpenComm(
    COM_SERIAL       *Param,
    const SHORT             Handle
   )
/*++

Routine Description:

 This function opens a communication channel with a GemCore >= 1.x IFD. It runs a
 sequence to determine the currently in use baud rate and to set the IFD in
 an idle mode from the communication protocol point of view.

Arguments:

  Param     - holds the parameters of the serial port.
  Handle    - holds the logical number to manage.

Return Value:

  a handle on the communication channel (>= 0).

--*/
{
    TGTSER_PORT comm;
    BYTE r_buff[HOR3GLL_OS_STRING_SIZE];
    USHORT r_len;
    SHORT portcom;
    KEVENT event;
    LARGE_INTEGER timeout;
    NTSTATUS status;

   ASSERT(Param != NULL);
    // Open the physical communication channel.
    // The serial port is opened to 9600 bauds in order to scan all the supported
    // baud rates.
    comm.Port     = (USHORT) Param->Port;
    comm.BaudRate = 9600;
    comm.Mode     = HGTSER_WORD_8 + HGTSER_NO_PARITY + HGTSER_STOP_BIT_1;
    comm.TimeOut  = HOR3COMM_CHAR_TIMEOUT;
    comm.TxSize   = HGTGBP_MAX_BUFFER_SIZE;
    comm.RxSize   = HGTGBP_MAX_BUFFER_SIZE;
    comm.pSmartcardExtension = Param->pSmartcardExtension;
    status = GDDK_SerPortOpen(&comm,&portcom);
    if (status != STATUS_SUCCESS)
   {
      Param->BaudRate = 9600;
        return status;
    }
    // The Gemplus Block Protocol is initialized.
    GDDK_GBPOpen(Handle,2,4,portcom);

    //
    // Loop while a right response has not been received:
    //
    do {
        // Wait for HOR3COMM_CHAR_TIME ms before any command for IFD to forget any
        // previous received byte.
        KeInitializeEvent(&event,NotificationEvent,FALSE);
        timeout.QuadPart = -((LONGLONG) HOR3COMM_CHAR_TIME*10*1000);
        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            &timeout
            );
        // Try an OROS command (ReadMemory at OSString position).
        r_len = HOR3GLL_IFD_LEN_VERSION+1;
        status = GDDK_Oros3Exchange(
            Handle,
            HOR3GLL_LOW_TIME,
            5,
            (BYTE *)("\x22\x05\x3F\xE0\x0D"),
            &r_len,
            r_buff
            );
        // If this exchange fails
        // Then
        //   If the current baud rate is 9600
        //   Then
        //      The next try will be 38400
        //   ElseIf the current baud rate is 38400
        //   Then
        //      The next try will be 19200
        //   Else
        //   Then
        //      The communication channel is closed (GBP/Serial).
        if (status != STATUS_SUCCESS) {

         //ISV
            if (comm.BaudRate == 9600lu)
         {
                comm.BaudRate = 38400lu;
            }
         else if (comm.BaudRate == 38400lu)
         {
                comm.BaudRate = 19200lu;
            }
         else
         {
                GDDK_GBPClose(Handle);
                GDDK_SerPortClose(portcom);
            Param->BaudRate = 9600;
                return STATUS_INVALID_DEVICE_STATE;
            }
            // The new baud rate configuration is set.
            // If the call fails
            // Then
            //    The communication channel is closed (GBP/Serial).
            status = GDDK_SerPortSetState(
                portcom,
                &comm
                );
            if (status != STATUS_SUCCESS) {

                GDDK_GBPClose(Handle);
                GDDK_SerPortClose(portcom);
            Param->BaudRate = 9600;
                return status;
            }
        } else {
            break;
        }
    } while (r_len != (HOR3GLL_IFD_LEN_VERSION+1));

   //ISV
   // We found connection speed -> report it
   Param->BaudRate = comm.BaudRate;

   SmartcardDebug(
      DEBUG_DRIVER,("%s!GDDK_Oros3OpenComm: connection was established at %d\n",
      SC_DRIVER_NAME,
      Param->BaudRate)
      );

    return STATUS_SUCCESS;
}


NTSTATUS
GDDK_Oros3CloseComm(
    const USHORT Handle
   )
/*++

Routine Description:

 This function closes a communication channel with the reader

Arguments:

  Handle    - holds the logical number to manage.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    SHORT portcom;
    NTSTATUS status;

    status = GDDK_GBPChannelToPortComm(Handle,&portcom);
    ASSERT(status == STATUS_SUCCESS);
    if (status != STATUS_SUCCESS) {

        return status;
    }
    GDDK_GBPClose(Handle);
    return (GDDK_SerPortClose(portcom));
}

NTSTATUS
GDDK_Oros3SendCmd(
    const SHORT        Handle,
    const USHORT       CmdLen,
    const BYTE         Cmd[],
    const BOOLEAN      Resynch
   )
/*++

Routine Description:

 This function send a command to the IFD according to Gemplus Block
 Protocol.
 If the CmdLen field is null, this function send a R-Block or a S-Block
 according to the resynch boolean value.

Arguments:

  Handle    - holds the logical number to manage.
  CmdLen    - indicates the number of bytes in the Cmd buffer. If this value is
              null, a R-Block is sent.
  Cmd       - holds the command bytes.
  Resynch   - is read to find if a R-Block or a S-Block must be sent.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    SHORT portcom;
    USHORT s_len;
    BYTE s_buff[HGTGBP_MAX_BUFFER_SIZE];
    NTSTATUS response;

    ASSERT(Cmd != NULL);

    response = GDDK_GBPChannelToPortComm(Handle,&portcom);
    if (response != STATUS_SUCCESS) {

        return response;
    }
    // The GBP message to send is build from the given command:
    // If CmdLen is null Then
    //   If resynch is true
    //   Then  a S-Block is built.
    //   Else  a R-BLOCK message is built:
    s_len = HGTGBP_MAX_BUFFER_SIZE;
    if (CmdLen == 0) {
        if (Resynch) {

            response = GDDK_GBPBuildSBlock(Handle,&s_len,s_buff);
        } else {
            response = GDDK_GBPBuildRBlock(Handle,&s_len,s_buff);
        }
    } else {
        // Else an I-BLOCK message is built:
        response = GDDK_GBPBuildIBlock(Handle,CmdLen,Cmd,&s_len,s_buff);
    }
    if (response != STATUS_SUCCESS) {

        return response;
    }
    // The communication queues are flushed before the writing.
    response = GDDK_SerPortFlush(portcom, HGTSER_TX_QUEUE | HGTSER_RX_QUEUE);
    if (response != STATUS_SUCCESS) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_Oros3SendCmd Flush failed=%X(hex)\n",
            SC_DRIVER_NAME,
            response)
            );
        return response;
    }
    // The message is written. As the queues have been flushed, it remains enough
    // place in the transmitt queue for the whole message.
    response = GDDK_SerPortWrite(
        portcom,
        s_len,
        s_buff
        );
    if (response != STATUS_SUCCESS) {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!GDDK_Oros3SendCmd SerPortWrite=%X(hex)\n",
            SC_DRIVER_NAME,
            response)
            );
    }
    return (response);
}


NTSTATUS
GDDK_Oros3ReadResp(
    const SHORT         Handle,
    const ULONG         Timeout,
          USHORT       *RspLen,
          BYTE          Rsp[]
   )
/*++

Routine Description:

 This function reads the IFD response to a command according to
 Gemplus Block Protocol.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout.
  RspLen    - indicates how many bytes can be stored in Rsp buffer.
              It will be updated with the length of the response.
  Rsp       - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    SHORT portcom;
    USHORT user_nb,r_len;
    BYTE r_buff[HGTGBP_MAX_BUFFER_SIZE];
    TGTSER_PORT comm;
    NTSTATUS response;

    ASSERT(RspLen != NULL);
    ASSERT(Rsp != NULL);
    response = GDDK_GBPChannelToPortComm(Handle,&portcom);
    if (response != STATUS_SUCCESS) {
        return response;
    }

    // Set the communication timeout
    response = GDDK_SerPortGetState(
        portcom,
        &comm,
        &user_nb
        );

    if (response != STATUS_SUCCESS) {
       return response;
    }

    comm.TimeOut = (USHORT) Timeout;
    response = GDDK_SerPortSetState(
        portcom,
        &comm
        );

    // Read the IFD response:
    // The first three bytes are read by calling GDDK_SerPortRead.
    r_len = 3;
    response = GDDK_SerPortRead(
        portcom,
        &r_len,
        r_buff
        );
    if (response != STATUS_SUCCESS) {

        *RspLen = 0;
        return response;
    }
    // r_len is udpated with the number of bytes which must be read to receive a
    //   complete Gemplus Block Protocol: the number indicated by the length field
    //   of the GBP message + one byte for the EDC.
    r_len = (USHORT)(r_buff[2] + 1);
    // The end of the message is read by calling GDDK_SerPortRead. The character
    //   timeout pass to GDDK_SerPortOpen will be used to determine broken
    //   communication.
    response = GDDK_SerPortRead(
        portcom,
        &r_len,
        r_buff + 3
        );
    if (response != STATUS_SUCCESS) {

        *RspLen = 0;
        return response;
    }
    // The message length is restored by adding 3 to r_len.
    r_len += 3;
    // The GBP message is controlled and decoded:
    return (GDDK_GBPDecodeMessage(Handle,r_len,r_buff,RspLen,Rsp));
}



NTSTATUS
GDDK_Oros3Exchange(
    const SHORT         Handle,
    const ULONG         Timeout,
    const USHORT        CmdLen,
    const BYTE          Cmd[],
          USHORT       *RspLen,
          BYTE          Rsp[]
   )
/*++

Routine Description:

 This function sends a command to the IFD according to Gemplus Block
 Protocol and read its response.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout.
  CmdLen    - indicates the number of bytes in the Cmd buffer.
  Cmd       - holds the command bytes.
  RspLen    - indicates how many bytes can be stored in Rsp buffer.
              It will be updated with the length of the response.
  Rsp       - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    ULONG timeout = Timeout;
    USHORT index, cmdlen_used = CmdLen, rsplen_save = *RspLen;
    SHORT try_counter  = 0,sync_counter = 0,portcom;
    NTSTATUS response;
    BOOLEAN resynch;

    ASSERT(Cmd != NULL);
    ASSERT(RspLen != NULL);
    ASSERT(Rsp != NULL);

    // initialize the result buffer
    RtlZeroMemory(Rsp, *RspLen);

    // Associate Handle( or ChannelNb) with portcom
    response = GDDK_GBPChannelToPortComm(Handle,&portcom);
    if (response != STATUS_SUCCESS) {

        return response;
    }

    // Waits the serial communication semaphore
    if (GDDK_SerPortLockComm(portcom,HOR3COMM_MAX_TRY * Timeout) == FALSE) {
        return STATUS_CANT_WAIT;
    }
    // A first try loop for sending the command is launched:
    // This loop allows to try to send the command, then, if the try fails, to
    // resynchronize the reader and then to tru to send the command one more time.
    resynch = FALSE;
    while (sync_counter++ < HOR3COMM_MAX_RESYNCH) {
        // A second try loop for sending the command is launched:
        // We send the command and, if a communication error occurs, HOR3COMM_MAX_TRY
        // repetitions are allowed before the communication is considered as broken.
        //   The given command is sent to IFD.
        try_counter = 0;
        while (try_counter++ < HOR3COMM_MAX_TRY) {

#if DBG || DEBUG
            SmartcardDebug(
                DEBUG_TRACE,
                ("%s!GDDK_Oros3Exchange: CMD=",
                SC_DRIVER_NAME)
                );
            for(index=0;index<cmdlen_used;index++) {
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%02X,",
                    Cmd[index])
                    );
            }
            SmartcardDebug(
                DEBUG_TRACE,
                ("\n")
                );
#endif
            response = GDDK_Oros3SendCmd(Handle,cmdlen_used,Cmd,resynch);
            if (response != STATUS_SUCCESS) {

                *RspLen = 0;
                GDDK_SerPortUnlockComm(portcom);
                return response;
            }
            // The IFD response is read (RspLen is restored for the cases where we have
            //   received a R-Block from the reader).
            *RspLen = rsplen_save;
            response = GDDK_Oros3ReadResp(
                Handle,
                timeout,
                RspLen,
                Rsp
                );
#if DBG || DEBUG
            SmartcardDebug(
                DEBUG_TRACE,
                ("%s!GDDK_Oros3Exchange: RSP=",
                SC_DRIVER_NAME)
                );
            if (response == STATUS_SUCCESS) {
                if (*RspLen > 0) {
                    for(index=0;index<*RspLen;index++) {
                        SmartcardDebug(
                        DEBUG_TRACE,
                        ("%02X,",
                        Rsp[index])
                        );
                    }
                }
            }
            SmartcardDebug(
                DEBUG_TRACE,
                ("\n")
                );
#endif
            // If we are not interested by the response then we exit immediatly
            if (rsplen_save == 0) {

                *RspLen = 0;
                GDDK_SerPortUnlockComm(portcom);
                return response;
            }
            // If a good message has been read
            // Then
            //    Release the serial communication semaphore.
            if (response == STATUS_SUCCESS) {

                GDDK_SerPortUnlockComm(portcom);
                return response;

            } else if (response == STATUS_SYNCHRONIZATION_REQUIRED) {

                // Else if a S-Block response has been received
                // Then
                //   try_counter is reseted.
                try_counter = 0;
                cmdlen_used = CmdLen;
                resynch = FALSE;
            }
            else if (response != STATUS_UNSUCCESSFUL) {
                // If a communication error different from a R-Block message is raised
                // Then
                //   cmdlen_used and timeout are initialized to send a R-Block.
                cmdlen_used = 0;
                resynch     = FALSE;
                timeout     = HOR3COMM_NACK_TIME;
            }
        }
        cmdlen_used = 0;
        resynch     = TRUE;
        timeout     = HOR3COMM_NACK_TIME;
    }
    // When we have exceeded the try counter, no communication is possible: RspLen
    // is set to 0
    // Release the serial communication semaphore.
    *RspLen = 0;
    GDDK_SerPortUnlockComm(portcom);
    return response;
}

NTSTATUS
GDDK_Oros3IccPowerUp(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          ICCVcc,
    const BYTE          PTSMode,
    const BYTE          PTS0,
    const BYTE          PTS1,
    const BYTE          PTS2,
    const BYTE          PTS3,
          USHORT       *RespLen,
          BYTE          RespBuff[]
   )
/*++

Routine Description:

 This command powers up an ICC and returns its answer to reset.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout.
  Voltage   - holds the power supply voltage.
  PTSMode   - holds the PTS negotiate mode. This module supports :
               * IFD_DEFAULT_MODE           -> same as OROS 2.x,
               * IFD_WITHOUT_PTS_REQUEST    -> no PTS management (baud rate is 9600 bps),
               * IFD_NEGOTIATE_PTS_OPTIMAL  -> PTS management automatically,
               * IFD_NEGOTIATE_PTS_MANUALLY -> PTS management "manually" by parameters.
               * PTS0 is updated with the currently PTS parameter PTS0 :
                 * IFD_NEGOTIATE_PTS1,
                 * IFD_NEGOTIATE_PTS2,
                 * IFD_NEGOTIATE_PTS3.
                 * PTS1 holds the PTS parameter PTS1.
                 * PTS2 holds the PTS parameter PTS2.
                 * PTS3 holds the PTS parameter PTS3.
  RspLen    - indicates how many bytes can be stored in Rsp buffer.
              It will be updated with the length of the response.
  Rsp       - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    NTSTATUS response;
    USHORT i,len = 0;
    BYTE   CFG = 0,PCK,cmd[7];
    USHORT output_size, rlen=HOR3GLL_BUFFER_SIZE;
    BYTE rbuff[HOR3GLL_BUFFER_SIZE];

    ASSERT(RespLen != NULL);
    ASSERT(RespBuff != NULL);

    output_size = *RespLen;
    cmd[len++] = HOR3GLL_IFD_CMD_ICC_POWER_UP;

    switch(ICCVcc) {

    case ICC_VCC_3V:
        CFG = 0x02;
        break;
    case ICC_VCC_5V:
        CFG = 0x01;
        break;
    default:
        CFG = 0x00;
        break;
    }

    switch(PTSMode) {

    case IFD_WITHOUT_PTS_REQUEST:
        CFG |= 0x10;
        cmd[len++] = CFG;
        response = GDDK_Oros3Exchange(Handle,Timeout,len,cmd,RespLen,RespBuff);
        break;
    case IFD_NEGOTIATE_PTS_OPTIMAL:
        CFG |= 0x20;
        cmd[len++] = CFG;
        response = GDDK_Oros3Exchange(Handle,Timeout,len,cmd,RespLen,RespBuff);
        break;
    // For a PTS request:
    //   Send a Power Up command without PTS management (to stay at 9600)
    //   Send the PTS request
    //   Return the ATR if the command success
    //   Else return the status.
    case IFD_NEGOTIATE_PTS_MANUALLY:
        // first reset Icc without PTS management
        CFG |= 0x10;
        cmd[len++] = CFG;
        response = GDDK_Oros3Exchange(Handle,Timeout,len,cmd,RespLen,RespBuff);
        if ((response == STATUS_SUCCESS) && (RespLen > 0) && (RespBuff[0] == 0x00)) {
            // then send PTS parameters
            len = 1;
            CFG |= 0xF0;
            cmd[len++] = CFG;
            cmd[len++] = PTS0;
            if ((PTS0 & IFD_NEGOTIATE_PTS1) != 0)
                cmd[len++] = PTS1;
            if ((PTS0 & IFD_NEGOTIATE_PTS2) != 0)
                cmd[len++] = PTS2;
            if ((PTS0 & IFD_NEGOTIATE_PTS3) != 0)
                cmd[len++] = PTS3;
            // computes the exclusive-oring of all characters from CFG to PTS3
            PCK = 0xFF;
            for (i=2; i<len; i++) {
                PCK ^= cmd[i];
            }
            cmd[len++] = PCK;
            response = GDDK_Oros3Exchange(Handle,Timeout,len,cmd,&rlen,rbuff);
            if ((response != STATUS_SUCCESS) || (rlen != 1) || (rbuff[0] != 0x00)) {
                ASSERT(output_size >= rlen);
                *RespLen = rlen;
                if (rlen > 0) {

                    memcpy(RespBuff,rbuff,rlen);
                }
            }
        }
        break;
    case IFD_DEFAULT_MODE:
    default:
        if (CFG != 0x00) {
            cmd[len++] = CFG;
        }
        response = GDDK_Oros3Exchange(Handle,Timeout,len,cmd,RespLen,RespBuff);
        break;
    }

    return response;
}


NTSTATUS
GDDK_Oros3IsoOutput(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          OrosCmd,
    const BYTE          Command[5],
          USHORT       *RespLen,
          BYTE          RespBuff[]
   )
/*++

Routine Description:

 This command sends T=0 ISO out commands, that is, command that retrieve data from
 an ICC.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout (ms).
  OrosCmd   - is the OROS command byte.
  Command   - is a buffer with the following format:
                <Cla> <INS> <P1> <P2> <Length>
  RespLen   - holds the available place in RespBuff. It must be at least Length
               value incremented by 3 (IFD Status + SW1 + SW2).
              It will be updated with the length of the response.
  RespBuff  - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE  cmd[6];
    NTSTATUS response;
    USHORT resp1_len, resp2_len;
    BYTE resp_buff[HOR3GLL_BUFFER_SIZE];

    ASSERT(Command != NULL);
    ASSERT(RespLen != NULL);
    ASSERT(RespBuff != NULL);
    // Set the OROS command byte.
    cmd[0] = OrosCmd;

    // If the length is lower or equal to 252 (255 - (<IFD Status> + <SW1> + <SW2>))
    // (standard OROS cmds)
    if ((Command[4] <= (HGTGBP_MAX_DATA - 3)) && (Command[4] != 0)) {

        // The five command bytes are added in cmd buffer.
        memcpy(cmd + 1, Command, 5);
        return (GDDK_Oros3Exchange(Handle,Timeout,6,cmd,RespLen,RespBuff));
    }

    // If the length is greater than 252 and lower or equal to 256
    //   (extended OROS cmds)
    else if ((Command[4] > (HGTGBP_MAX_DATA - 3)) || (Command[4] == 0)) {
        // Prepare and send the first part of the extended ISO Out command:
        // The five command bytes are added in cmd buffer.
        memcpy(cmd + 1, Command, 5);
        resp1_len = HOR3GLL_BUFFER_SIZE;
        response = GDDK_Oros3Exchange(Handle,Timeout,6,cmd,&resp1_len,RespBuff);
        if ((response != STATUS_SUCCESS) || (RespBuff[0] != 0x00)) {

            *RespLen = resp1_len;
            return response;
        }

        // Prepare and send the second part of the extended ISO Out command:
        // The five command bytes are added in cmd buffer:
        //      0xFF,0xFF,0xFF,0xFF,LN - length already receive.
        memcpy(cmd + 1,"\xFF\xFF\xFF\xFF", 4);
        if (Command[4] == 0x00) {
            cmd[5] = (BYTE ) (256 - ((BYTE ) (resp1_len - 1)));
        } else {
            cmd[5] -= ((BYTE ) (resp1_len - 1));
        }
        resp2_len = HOR3GLL_BUFFER_SIZE;
        response = GDDK_Oros3Exchange(Handle,Timeout,6,cmd,&resp2_len,resp_buff);

        if ((response != STATUS_SUCCESS) || (resp_buff[0] != 0x00)) {
            memcpy(RespBuff,resp_buff,resp2_len);
            *RespLen = resp2_len;
            return response;
        }
        memcpy(RespBuff + resp1_len,resp_buff + 1,resp2_len - 1);
        *RespLen = (USHORT) (resp1_len + resp2_len - 1);
        return response;

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
GDDK_Oros3IsoInput(
    const SHORT         Handle,
    const ULONG         Timeout,
    const BYTE          OrosCmd,
    const BYTE          Command[5],
    const BYTE          Data[],
          USHORT       *RespLen,
          BYTE          RespBuff[]
   )
/*++

Routine Description:

 This command sends T=0 ISO In commands, that is, command that retrieve data from
 an ICC.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout (ms).
  OrosCmd   - is the OROS command byte.
  Command   - is a buffer with the following format:
                <Cla> <INS> <P1> <P2> <Length>
  RespLen   - holds the available place in RespBuff. It must be at least Length
               value incremented by 3 (IFD Status + SW1 + SW2).
              It will be updated with the length of the response.
  RespBuff  - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    BYTE cmd[HOR3GLL_BUFFER_SIZE];
    NTSTATUS response;
    USHORT resp_len = *RespLen;

    ASSERT(Command != NULL);
    ASSERT(Data != NULL);
    ASSERT(RespLen != NULL);
    ASSERT(RespBuff != NULL);

    // Set the OROS command byte.
    cmd[0] = OrosCmd;
    // The given length is controlled.
    // If the length is lower or equal than the standard available space (248)
    if (Command[4] <= (HGTGBP_MAX_DATA - 7)) {

        memcpy(cmd + 1, Command, 5);
        memcpy(cmd + 6, Data, Command[4]);
        return(
            GDDK_Oros3Exchange(
                Handle,
                Timeout,
                (USHORT)(6 + Command[4]),
                cmd,
                RespLen,
                RespBuff
                )
            );
    } else if (Command[4] <= HT0CASES_LIN_SHORT_MAX) {

        // If the length is lower or equal than the extended available space (255)
        // Prepare and send the first part of the extended ISO In command:
        // The five command bytes are added in cmd buffer: 0xFF,0xFF,0xFF,0xFF,LN-248
        memcpy(cmd + 1,"\xFF\xFF\xFF\xFF", 4);
        cmd[5] = (BYTE ) (Command[4] - 248);
        // The data field is added.
        memcpy(cmd + 6, Data + 248, cmd[5]);
        response = GDDK_Oros3Exchange(
            Handle,
            Timeout,
            (USHORT)(6 + cmd[5]),
            cmd,
            &resp_len,
            RespBuff
            );
        if ((response != STATUS_SUCCESS) || (RespBuff[0] != 0x00) || (resp_len != 1)) {

            if ((response == STATUS_SUCCESS) && (RespBuff[0] == 0x1B)) {

                RespBuff[0] = 0x12;
            }
            return response;
        }
        // Prepare and send the Second part of the extended ISO In command:
        // The five command bytes are added in cmd buffer.
        // The data field is added (248 bytes).
        // The command is sent to IFD.
        memcpy(cmd + 1, Command, 5);
        memcpy(cmd + 6, Data,248);
        return(
            GDDK_Oros3Exchange(
                Handle,
                Timeout,
                (USHORT)(6 + 248),
                cmd,
                RespLen,
                RespBuff
                )
            );

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS
GDDK_Oros3TransparentExchange(
   const SHORT         Handle,
    const ULONG         Timeout,
    const USHORT        CmdLen,
    const BYTE         *CmdBuff,
          USHORT       *RespLen,
          BYTE         *RespBuff
   )
/*++

Routine Description:

 This command sends transparent commands, that is, command that send and receive
 data to/from an ICC.

Arguments:

  Handle    - holds the logical number to manage.
  Timeout   - is the command timeout (ms).
  OrosCmd   - is the OROS command byte.
  Command   - is a buffer with the following format:
                <Cla> <INS> <P1> <P2> <Length>
  RespLen   - holds the available place in RespBuff. It must be at least Length
               value incremented by 3 (IFD Status + SW1 + SW2).
              It will be updated with the length of the response.
  RespBuff  - holds the response.

Return Value:

    STATUS_SUCCESS               - We could execute the request.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    BYTE cmd[HOR3GLL_BUFFER_SIZE];
    USHORT lnToSend, resp_len1, resp_len2;
    BYTE resp_buff1[HOR3GLL_BUFFER_SIZE],resp_buff2[HOR3GLL_BUFFER_SIZE];

    ASSERT(CmdBuff != NULL);
    ASSERT(RespLen != NULL);
    ASSERT(RespBuff != NULL);

    // The total command length (CLA,INS,P1,P2,LIn,DataIn,LEx) is controlled:
    // If the length is upper than 261 (LIn = 255 and Lex <> 0)
    // Then returns GE_HI_CMD_LEN
    if (CmdLen > 261) {

        return STATUS_INVALID_PARAMETER;
    }
    // If the length is upper than the standard available space (254)
    // Then
    //   Send the last datas
    if (CmdLen > 254) {
        cmd[0] = HOR3GLL_IFD_CMD_TRANS_LONG;
        resp_len1 = HOR3GLL_BUFFER_SIZE;
        memcpy(
            cmd + 1,
            CmdBuff+254,
            CmdLen - 254
            );
        lnToSend = CmdLen - 254 + 1;
        status = GDDK_Oros3Exchange(
            Handle,
            Timeout,
            lnToSend,
            cmd,
            &resp_len1,
            resp_buff1
            );
        if (status != STATUS_SUCCESS) {

            return status;
        }
    }
    // Send the firts datas
    cmd[0] = HOR3GLL_IFD_CMD_TRANS_SHORT;
    if (CmdLen > 254) {

        memcpy(cmd + 1,CmdBuff,CmdLen);
        lnToSend = 254 + 1;
    } else {

        if(CmdLen > 0) {

            memcpy(cmd + 1,CmdBuff,CmdLen);
        }
        lnToSend = CmdLen + 1;
    }
    resp_len1 = HOR3GLL_BUFFER_SIZE;
    status = GDDK_Oros3Exchange(
        Handle,
        Timeout,
        lnToSend,
        cmd,
        &resp_len1,
        resp_buff1
        );
    if (status != STATUS_SUCCESS) {

        return status;
    }
    // If the IFD signals more data to read
    if (resp_len1 > 0 && resp_buff1[0] == 0x1B) {

        // Send a command to read the last data.
        cmd[0] = HOR3GLL_IFD_CMD_TRANS_RESP;
        resp_len2 = HOR3GLL_BUFFER_SIZE;
        status = GDDK_Oros3Exchange(
            Handle,
            Timeout,
            1,
            cmd,
            &resp_len2,
            resp_buff2
            );
        if (status != STATUS_SUCCESS) {

            return status;
        }
        if ((resp_len1 + resp_len2 - 2) > *RespLen) {

            return STATUS_INVALID_PARAMETER;
        }
        // Copy the last reader status
        resp_buff1[0] = resp_buff2[0];
        *RespLen = resp_len1 + resp_len2 - 1;
        memcpy(RespBuff,resp_buff1,resp_len1);
        memcpy(RespBuff + resp_len1,resp_buff2 + 1,resp_len2 - 1);
        return STATUS_SUCCESS;
    } else {

        if (resp_len1 > *RespLen) {

            return STATUS_INVALID_PARAMETER;
        }
        *RespLen = resp_len1;
        memcpy(RespBuff,resp_buff1,resp_len1);
        return STATUS_SUCCESS;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gntscr0a.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:  
   GNTSCR0A.H (Gemplus NT Smart Card Reader module 0A)

Description : 
   This module holds the prototypes of the functions from GNTSCR0A.C

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.

--*/


#ifndef _GNTSCR0A_
#define _GNTSCR0A_

//
// Prototype section:
//
NTSTATUS 
DriverEntry(
	IN  PDRIVER_OBJECT  DriverObject,
	IN  PUNICODE_STRING RegistryPath
	);

NTSTATUS 
GCR410PAddDevice(
	IN PDRIVER_OBJECT  DriverObject,
	IN PDEVICE_OBJECT  PhysicalDeviceObject 
	);

NTSTATUS 
GCR410PCreateDevice(
	IN  PDRIVER_OBJECT      DriverObject,
	IN  PDEVICE_OBJECT      PhysicalDeviceObject,
	OUT PDEVICE_OBJECT      *DeviceObject
	);

NTSTATUS 
GCR410PStartDevice(
	IN PDEVICE_OBJECT DeviceObject
	);

VOID 
GCR410PStopDevice(
	IN PDEVICE_OBJECT DeviceObject
	);

VOID 
GCR410PCloseSerialPort(
	IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
	);

VOID 
GCR410PWaitForCardStateChange(
	IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
	);

NTSTATUS 
GCR410PSerialCallComplete(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp,
	IN PKEVENT			Event
	);

NTSTATUS 
GCR410PCallSerialDriver(
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP				Irp
	);

NTSTATUS 
GCR410PCreateClose(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS 
GCR410PCancel(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS 
GCR410PCleanup(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

VOID  
GCR410PRemoveDevice( 
	PDEVICE_OBJECT DeviceObject
	);

VOID 
GCR410PDriverUnload(
	IN PDRIVER_OBJECT DriverObject
	);

NTSTATUS 
GCR410PPnPDeviceControl(
	IN PDEVICE_OBJECT DeviceObject, 
	IN PIRP Irp
	);

VOID
GCR410PSystemPowerCompletion(    
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,    
    IN POWER_STATE PowerState,    
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus    
    );

NTSTATUS
GCR410PDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
GCR410PPowerDeviceControl(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP Irp
	);

NTSTATUS 
GCR410PStartSerialEventTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GCR410PStopSerialEventTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GCR410PSerialEvent(
	IN PDEVICE_OBJECT       DeviceObject,
	IN PIRP                 Irp,
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID 
GCR410PCompleteCardTracking(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS 
GCR410PDeviceControl(
	PDEVICE_OBJECT pDeviceObject,
	PIRP pIrp
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\debug.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef DBG_INT
#define DBG_INT
#include "generic.h"

#pragma PAGEDCODE

class CDebug;
class CDebug
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CDebug(){initializeUsage();};
public:
	virtual ~CDebug(){};

	/*Open(CDevice*) {};
	Close(CDevice*) {};
	CopyDebug(CDevice*) {};
	trace(...) {};
	*/
	virtual VOID	start() {};
	virtual VOID	stop()  {};
	virtual VOID	trace(PCH Format,... ) {};
	virtual VOID	trace_buffer(PVOID pBuffer,ULONG BufferLength) {};
	
	VOID	initializeUsage(){usage = 0;};
	LONG	incrementUsage(){return ++usage;};
	LONG	decrementUsage(){return --usage;};
protected:
	BOOL active;
private:
	LONG usage;
};	

#define TRACE	if(debug) debug->trace
#define TRACE_BUFFER	if(debug) debug->trace_buffer
#define DEBUG_START()	if(debug) debug->start()
#define DEBUG_STOP()	if(debug) debug->stop()


#endif//DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\event.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef EV_INT
#define EV_INT
#include "generic.h"

#pragma PAGEDCODE
class CEvent
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CEvent(){};
	virtual ~CEvent(){};
public:
	
	virtual VOID		initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State) {};
	virtual VOID		clear(PRKEVENT Event) {};
	virtual LONG		reset(PRKEVENT Event) {return 0;};
	virtual LONG		set(PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait) {return 0;};

	virtual NTSTATUS	waitForSingleObject (PVOID Object,
							KWAIT_REASON WaitReason,KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout) {return STATUS_SUCCESS;};

	virtual NTSTATUS	waitForMultipleObjects(ULONG Count,
							PVOID Object[],
							WAIT_TYPE WaitType,
							KWAIT_REASON WaitReason,
							KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout,
							PKWAIT_BLOCK WaitBlockArray) {return STATUS_SUCCESS;};
	
};	

#endif//EVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\device.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//      08/11/99    -   implemented 
//-------------------------------------------------------------------
#ifndef __DEVICE__
#define __DEVICE__

#include "generic.h"

enum DEVSTATE 
{
    STOPPED,                                // device stopped
    WORKING,                                // started and working
    PENDINGSTOP,                            // stop pending
    PENDINGREMOVE,                          // remove pending
    SURPRISEREMOVED,                        // removed by surprise
    REMOVED,                                // removed
};

// Remove eventually previous declaration!...
typedef enum _DEVICE_PNP_STATE {

    NOT_STARTED = 0,         // Not started yet
    STARTED,                 // Device has received the START_DEVICE IRP
    STOP_PENDING,            // Device has received the QUERY_STOP IRP
    _STOPPED_,                 // Device has received the STOP_DEVICE IRP
    REMOVE_PENDING,          // Device has received the QUERY_REMOVE IRP
    SURPRISE_REMOVE_PENDING, // Device has received the SURPRISE_REMOVE IRP
    DELETED                  // Device has received the REMOVE_DEVICE IRP
} DEVICE_PNP_STATE;

enum POWERSTATE 
{
    POWERON,                                // power on, device in D0 state
    POWEROFFPENDING,                        // power off operation is pending
    POWEROFF,                               // power off, device in D3 state
    IDLEOFF,                                // power off due to idle detection
};

typedef struct _PPOWER_CONTEXT_
{
    PKEVENT powerEvent;
    NTSTATUS status;
} POWER_CONTEXT,*PPOWER_CONTEXT;


#define INITIALIZE_PNP_STATE()    \
        this->m_DevicePnPState =  NOT_STARTED;\
        this->m_PreviousPnPState = NOT_STARTED

#define SET_NEW_PNP_STATE(__state_) \
        this->m_PreviousPnPState =  this->m_DevicePnPState;\
        this->m_DevicePnPState = (_state_)

#define RESTORE_PREVIOUS_PNP_STATE()   \
        this->m_DevicePnPState =   this->m_PreviousPnPState

#define IS_DEVICE_PNP_STATE(_state_)   \
        (this->m_DevicePnPState == _state_)


#define DEVICE_SURPRISE_REMOVAL_OK 1

#define PNPTABSIZE      IRP_MN_QUERY_LEGACY_BUS_INFORMATION+1
#define POWERTABSIZE    IRP_MN_QUERY_POWER+1
#define STATETABSIZE    REMOVED+1
#define SYSTEM_POWER_TAB_NAMESIZE 8
#define DEVICE_POWER_TAB_NAMESIZE 6


typedef enum PENDING_REQUEST_TYPE
{
    OPEN_REQUEST = 0,
    CLOSE_REQUEST,
    READ_REQUEST,
    WRITE_REQUEST,
    IOCTL_REQUEST,
    PNP_REQUEST,
    POWER_REQUEST,
    SYSTEM_REQUEST,
    FLUSH_REQUEST,
    CLEAN_REQUEST,
    START_IO_REQUEST
} PENDING_REQUEST_TYPE;

class CPendingIRP
{
public:
    NTSTATUS m_Status;
    SAFE_DESTRUCTORS();
    virtual VOID dispose(){self_delete();};
public:
    LIST_ENTRY entry;
    PENDING_REQUEST_TYPE Type;
    PDEVICE_OBJECT  DeviceObject;
    PIRP Irp;
public:
    CPendingIRP(PIRP Irp,PENDING_REQUEST_TYPE rt = OPEN_REQUEST,
        PDEVICE_OBJECT  tdo = NULL,PFILE_OBJECT tfo = NULL):
        Irp(Irp), Type(rt), DeviceObject(tdo)
    {
    };
};

// ABSTRUCT class
// This is main interface from system to the device.
// Specific devices should implement the interface to support system requests.
class CDevice;
class CSystem;
class CIrp;
class CEvent;
class CPower;
class CDebug;
class CLock;
class CMemory;
class CIoPacket;
class CThread;

typedef struct _REMOVE_LOCK 
{
    LONG usage;                 // reference count
    BOOLEAN removing;           // true if removal is pending
    KEVENT evRemove;            // event to wait on
} REMOVE_LOCK, *PREMOVE_LOCK;


class CDevice;
#pragma PAGEDCODE
class CDevice
{
public:
    NTSTATUS m_Status;
    SAFE_DESTRUCTORS();
public:
    ULONG m_Type;
    // Support for the linked list of devices...
    LIST_ENTRY   entry;
protected:
    LONG        m_Usage;        // use count on this device
    static ULONG DeviceNumber;  // Device instance number

    UNICODE_STRING m_Ifname;
    CUString*   m_DeviceObjectName;
    
    UCHAR       m_VendorName[MAXIMUM_ATTR_STRING_LENGTH];
    USHORT      m_VendorNameLength;
    UCHAR       m_DeviceType[MAXIMUM_ATTR_STRING_LENGTH];
    USHORT      m_DeviceTypeLength;

    BOOL        m_Started;      // Set TRUE if device started, FALSE if stopped
    BOOL        m_Openned;      // Set TRUE if device openned, FALSE if closed
    BOOL        m_Added;        // Set TRUE if device was added to system, FALSE if it is not
     
    BOOL        m_SurprizeRemoved;
    REMOVE_LOCK m_RemoveLock;

    BOOL        m_RestartActiveThread;
    KEVENT      m_evEnabled;        // event to wait on after device was disabled

    // Event to signal device Idle state
    //KMUTEX        IdleState;=========== It will be much better!!!!!!!!!
    KEVENT      IdleState;

    // Capabilities structure and device flags to handle
    DEVICE_CAPABILITIES m_DeviceCapabilities;
    ULONG               m_Flags;
    // Power management constants
    PULONG              m_Idle; // idle counter pointer
    ULONG               Idle_conservation;
    ULONG               Idle_performance;
    DEVICE_POWER_STATE  m_CurrentDevicePowerState;

    DEVICE_POWER_STATE  m_PowerDownLevel;
    PIRP                m_PowerIrp;
    BOOL                m_EnabledForWakeup;

    //Current device state
    DEVSTATE            m_DeviceState;
    // Will be used for canceled request
    DEVSTATE            m_DevicePreviousState;

    // Next members will remove previous two (eventually)...
    DEVICE_PNP_STATE    m_PreviousPnPState;
    DEVICE_PNP_STATE    m_DevicePnPState;

    CSystem*        system;
    CIrp*           irp;
    CEvent*         event;

    CPower*         power;
    CDebug*         debug;
    CLock*          lock;
    CMemory*        memory;
    
    // Support for asynchronous communications
    CThread*        IoThread;

    LONG DevicePoolingInterval;
    LONG Write_To_Read_Delay;
    LONG Power_WTR_Delay;// Delay at power command
    LONG DeviceCommandTimeout;// Timeout for the device commands

    GUID InterfaceClassGuid;
    BOOL m_DeviceInterfaceRegistered;

    ULONG  CardState;
    
    // --------- ASYNCHRONOUS REQUESTS SUPPORT FUNCTIONS ---------------------------- 
    // This group of functions will allow to create asynchronous 
    // communications with the driver.
    // It includes -
    //  -   functions to mark our Irp as pending and to include it into
    //      our device requests queue (makeRequestPending());
    //  -   to extract next Irp from the device queue (startNextPendingRequest())
    //      and to start device specific Irp processing (startIoRequest())
    //  -   getIoRequestsQueue() allows devices to verify device queue state.
    // It is completely is up to specific device how to manage the device queue and
    // to make synchronous or asynchronous Irp processing.
    // For expl. device can create specific thread to process Irps.
    // More than this - some devices can deside to make asyncronous communications only
    // for specific (time consuming) device request while processing others syschronously.
    //
    // cancelPendingIrp() will cancel current Irp and remove corresponding IoRequest from 
    // IoRequestQueue.
    
protected:
    CLinkedList<CPendingIRP>* m_IoRequests; // Clients' IO requests
    // Support for dynamic device connections
    PIRP m_OpenSessionIrp;
public:
    virtual CLinkedList<CPendingIRP>* getIoRequestsQueue() = 0;
    virtual VOID     cancelPendingIrp(PIRP Irp) = 0;
    virtual NTSTATUS cancelPendingRequest(CPendingIRP* IrpReq) = 0;
    virtual NTSTATUS cancelAllPendingRequests() = 0;

    virtual NTSTATUS makeRequestPending(PIRP Irp_request,PDEVICE_OBJECT toDeviceObject,PENDING_REQUEST_TYPE Type) = 0;
    // Next functions will be called by Irp processing thread.
    // Checks if request queue is empty and if it is NOT - starts next request...
    virtual NTSTATUS startNextPendingRequest() = 0;
    // Device specific function which processes pending requests...
    // It will be redefied by specific devices.
    virtual NTSTATUS startIoRequest(CPendingIRP*) = 0;
    // --------- ASYNCHRONOUS REQUESTS SUPPORT FUNCTIONS ---------------------------- 

public:
    CDevice()
    {
        m_Type    = GRCLASS_DEVICE;
        m_Openned = FALSE;
        m_Added   = FALSE;

        // At begining device is at stop state 
        m_DevicePreviousState = STOPPED;
        m_DeviceState = STOPPED;

        m_SurprizeRemoved = FALSE;
        m_RestartActiveThread = FALSE;
        m_DeviceInterfaceRegistered = FALSE;
        m_ParentDeviceObject = NULL;
        DevicePoolingInterval = 500;// 0.5s better for detection
		set_Default_WTR_Delay(); //1ms corrects "0 bytes" problem
        Power_WTR_Delay     = 1; //1ms should be OK...
        DeviceCommandTimeout = 60000;// 60sec

        m_IoRequests = NULL;
        DBG_PRINT("         New Device %8.8lX was created...\n",this);
    }; // Default pooling interval

    BOOL    PnPfcntab[PNPTABSIZE];
    BOOL    Powerfcntab[POWERTABSIZE];

#ifdef DEBUG
    PCHAR PnPfcnname[PNPTABSIZE];
    PCHAR Powerfcnname[POWERTABSIZE];
    PCHAR Powersysstate[SYSTEM_POWER_TAB_NAMESIZE];
    PCHAR Powerdevstate[DEVICE_POWER_TAB_NAMESIZE];
    PCHAR statenames[STATETABSIZE];
#endif // DEBUG

protected:
    virtual ~CDevice(){};
        // Complete current request with given information
    virtual NTSTATUS    completeDeviceRequest(PIRP Irp, NTSTATUS status, ULONG info) {return STATUS_SUCCESS;};

    VOID    activatePnPHandler(LONG HandlerID)
    {
        if (HandlerID >= arraysize(PnPfcntab)) return;
        PnPfcntab[HandlerID] = TRUE;
    };

    VOID    disActivatePnPHandler(LONG HandlerID)
    {
        if (HandlerID >= arraysize(PnPfcntab)) return;
        PnPfcntab[HandlerID] = FALSE;
    };
public:
    virtual CDevice* create(VOID) {return NULL;};
    virtual VOID addRef(){refcount++;};
    virtual VOID removeRef(){if(refcount) refcount--;};
    virtual LONG getRefCount(){ return refcount;};
    virtual VOID markAsOpenned(){ m_Openned = TRUE;};
    virtual VOID markAsClosed() { m_Openned = FALSE;};
    virtual BOOL isOpenned() { return m_Openned;};

    virtual VOID setDeviceState(DEVSTATE state)
    {
        m_DevicePreviousState = m_DeviceState;
        m_DeviceState = state;
    };
    virtual DEVSTATE getDeviceState(){return m_DeviceState;};   
    virtual VOID restoreDeviceState(){m_DeviceState = m_DevicePreviousState;};
    virtual getObjectType(){return m_Type;};

    virtual ULONG    getCardState(){return CardState;};
    virtual VOID     setCardState(ULONG state){CardState = state;};


    // Call this function instead of destructor.
    // It will assure safety device removal.
    virtual VOID        dispose()       {};
    // Checks if device object is still valid.
    virtual BOOL        checkValid()    {return FALSE;};

    // Next methods should be defined by ALL clients...
    virtual BOOL        createDeviceObjects()   {return FALSE;};
    virtual VOID        removeDeviceObjects()   {};

    virtual VOID        initializeRemoveLock()  {};
    virtual NTSTATUS    acquireRemoveLock()     {return STATUS_SUCCESS;};
    virtual VOID        releaseRemoveLock()     {};
    virtual VOID        releaseRemoveLockAndWait() {};
    virtual BOOL        isDeviceLocked()        {return FALSE;};

    virtual VOID        setBusy() {};
    virtual VOID        setIdle() {};
    virtual NTSTATUS    waitForIdle() {return STATUS_SUCCESS;};
    virtual NTSTATUS    waitForIdleAndBlock() {return STATUS_SUCCESS;};

    //virtual NTSTATUS  add(PDRIVER_OBJECT Driver,PDEVICE_OBJECT PnpDeviceObject) {};
    virtual NTSTATUS    add(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT pPdo) {return STATUS_UNSUCCESSFUL;};

    PDEVICE_OBJECT      getSystemObject(){return m_DeviceObject;};
    PDEVICE_OBJECT      getPhysicalObject(){return m_PhysicalDeviceObject;};
    PDEVICE_OBJECT      getLowerDriver(){return m_pLowerDeviceObject;};
    UNICODE_STRING*     getDeviceInterfaceName(){return &m_Ifname;};
    GUID*               getDeviceInterfaceGUID(){return &InterfaceClassGuid;};
    BOOL                isDeviceInterfaceRegistered(){return m_DeviceInterfaceRegistered;};
    virtual BOOL        registerDeviceInterface(const GUID* Guid) {return FALSE;};
    virtual VOID        unregisterDeviceInterface(UNICODE_STRING* InterfaceName) {};

    
    CUString*           getDeviceName(){return m_DeviceObjectName;};

    ULONG               getDeviceNumber(){ULONG ID = DeviceNumber; if(ID) --ID; return ID;};
    ULONG               incrementDeviceNumber(){ULONG ID = DeviceNumber; ++DeviceNumber; return ID;};

    virtual VOID        remove()        {};
    virtual VOID        onDeviceStart() {};
    virtual VOID        onDeviceStop()  {};

    // These functions will create driver's IRPs to transfer datas.
    // Device stack will keep track of all active (sended to lower level)
    // and pending (mark as pending) IRPs...
    virtual NTSTATUS    send(CIoPacket* Irp) {return STATUS_SUCCESS;};
    virtual NTSTATUS    sendAndWait(CIoPacket* Irp) {return STATUS_SUCCESS;};
    // Functions will send request and wait for a reply...
    virtual  NTSTATUS   write(PUCHAR pRequest,ULONG RequestLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    
    // Interface for system requests. ..
    virtual NTSTATUS    pnpRequest(IN PIRP Irp) {return STATUS_SUCCESS;};
    virtual NTSTATUS    powerRequest(PIRP irp)  {return STATUS_SUCCESS;};

    virtual NTSTATUS    open(PIRP irp)          {return STATUS_SUCCESS;};//Create
    virtual NTSTATUS    close(PIRP irp)         {return STATUS_SUCCESS;};

    virtual NTSTATUS    read(PIRP irp)          {return STATUS_SUCCESS;};
    virtual NTSTATUS    write(PIRP irp)         {return STATUS_SUCCESS;};
    virtual VOID        startIo(PIRP irp){};

    virtual NTSTATUS    deviceControl(PIRP irp) {return STATUS_SUCCESS;};

    virtual NTSTATUS    cleanup(PIRP Irp)       {return STATUS_SUCCESS;};
    virtual NTSTATUS    flush(PIRP Irp)         {return STATUS_SUCCESS;};

    virtual LONG        getDevicePoolingInterval()
    {
        return DevicePoolingInterval;
    };
    virtual VOID        setDevicePoolingInterval(LONG interval)
    {
        DevicePoolingInterval = interval;
    };

    virtual LONG        getCommandTimeout()
    {
        return DeviceCommandTimeout;
    };
    virtual VOID        setCommandTimeout(LONG timeout)
    {
        DeviceCommandTimeout = timeout;
    };
    
    // Inhereted classes will overwrite this function
    virtual NTSTATUS ThreadRoutine()
    {
        return STATUS_SUCCESS;
    };

    #pragma LOCKEDCODE
    // This is callback function for the attached threads
    static VOID ThreadFunction(CDevice* device)
    {
        if(device) device->ThreadRoutine();
    };
    #pragma PAGEDCODE

    virtual LONG    get_Power_WTR_Delay()
    {
        return Power_WTR_Delay;
    };
    
    virtual LONG    get_WTR_Delay()
    {
        return Write_To_Read_Delay;
    };

    virtual VOID    set_WTR_Delay(LONG Delay)
    {
        Write_To_Read_Delay = Delay;
    };
    
    virtual VOID    set_Default_WTR_Delay()
    {
        Write_To_Read_Delay = 1;
    };

    virtual VOID    registerPowerIrp(PIRP Irp){m_PowerIrp = Irp;};
    virtual PIRP    getPowerIrp(){return m_PowerIrp;};
    virtual VOID    unregisterPowerIrp(){m_PowerIrp = NULL;};
    virtual BOOL    isEnabledForWakeup(){return m_EnabledForWakeup;};
    virtual VOID    setCurrentDevicePowerState(DEVICE_POWER_STATE state){m_CurrentDevicePowerState = state;};
    virtual NTSTATUS sendDeviceSetPower(DEVICE_POWER_STATE devicePower, BOOLEAN wait) = 0;

    virtual VOID    setSurprizeRemoved(){m_SurprizeRemoved = TRUE;};
    virtual VOID    clearSurprizeRemoved(){m_SurprizeRemoved = FALSE;};
    virtual BOOL    isSurprizeRemoved(){ return m_SurprizeRemoved;};

    virtual VOID    setThreadRestart(){m_RestartActiveThread = TRUE;};
    virtual VOID    clearThreadRestart(){m_RestartActiveThread = FALSE;};
    virtual BOOL    isRequiredThreadRestart(){ return m_RestartActiveThread;};

protected:
    WCHAR Signature[3];

    PDRIVER_OBJECT  m_DriverObject;
    // Back reference to system object
    PDEVICE_OBJECT  m_DeviceObject;
    // Device object lower at stack
    PDEVICE_OBJECT  m_pLowerDeviceObject;
    // Interrupt handle/object
    IN PKINTERRUPT  m_InterruptObject;
    // Physical device object used at Power management
    PDEVICE_OBJECT  m_PhysicalDeviceObject;
    // Will be used by child at bus to access parent
    PDEVICE_OBJECT  m_ParentDeviceObject;
protected:
    BOOL    initialized;//Current object finished initialization
    LONG    refcount;
};



#ifdef DEBUG

#define INCLUDE_PNP_FUNCTIONS_NAMES()   \
    PnPfcnname[IRP_MN_START_DEVICE]         = "IRP_MN_START_DEVICE";\
    PnPfcnname[IRP_MN_QUERY_REMOVE_DEVICE]  = "IRP_MN_QUERY_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_REMOVE_DEVICE]        = "IRP_MN_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_CANCEL_REMOVE_DEVICE] = "IRP_MN_CANCEL_REMOVE_DEVICE";\
    PnPfcnname[IRP_MN_STOP_DEVICE]          = "IRP_MN_STOP_DEVICE";\
\
    PnPfcnname[IRP_MN_QUERY_STOP_DEVICE]    = "IRP_MN_QUERY_STOP_DEVICE";\
    PnPfcnname[IRP_MN_CANCEL_STOP_DEVICE]   = "IRP_MN_CANCEL_STOP_DEVICE";\
    PnPfcnname[IRP_MN_QUERY_DEVICE_RELATIONS]= "IRP_MN_QUERY_DEVICE_RELATIONS";\
\
    PnPfcnname[IRP_MN_QUERY_INTERFACE]      = "IRP_MN_QUERY_INTERFACE";\
    PnPfcnname[IRP_MN_QUERY_CAPABILITIES]   = "IRP_MN_QUERY_CAPABILITIES";\
    PnPfcnname[IRP_MN_QUERY_RESOURCES]      = "IRP_MN_QUERY_RESOURCES";\
\
    PnPfcnname[IRP_MN_QUERY_RESOURCE_REQUIREMENTS]  = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";\
    PnPfcnname[IRP_MN_QUERY_DEVICE_TEXT]    = "IRP_MN_QUERY_DEVICE_TEXT";\
    PnPfcnname[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";\
    PnPfcnname[14]                          = "Unsupported PnP function";\
\
    PnPfcnname[IRP_MN_READ_CONFIG]          = "IRP_MN_READ_CONFIG";\
    PnPfcnname[IRP_MN_WRITE_CONFIG]         = "IRP_MN_WRITE_CONFIG";\
    PnPfcnname[IRP_MN_EJECT]                = "IRP_MN_EJECT";\
\
    PnPfcnname[IRP_MN_SET_LOCK]                     = "IRP_MN_SET_LOCK";\
    PnPfcnname[IRP_MN_QUERY_ID]                     = "IRP_MN_QUERY_ID";\
    PnPfcnname[IRP_MN_QUERY_PNP_DEVICE_STATE]       = "IRP_MN_QUERY_PNP_DEVICE_STATE";\
    PnPfcnname[IRP_MN_QUERY_BUS_INFORMATION]        = "IRP_MN_QUERY_BUS_INFORMATION";\
    PnPfcnname[IRP_MN_DEVICE_USAGE_NOTIFICATION]    = "IRP_MN_DEVICE_USAGE_NOTIFICATION";\
    PnPfcnname[IRP_MN_SURPRISE_REMOVAL]             = "IRP_MN_SURPRISE_REMOVAL";\
    PnPfcnname[IRP_MN_QUERY_LEGACY_BUS_INFORMATION] = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";

#define INCLUDE_POWER_FUNCTIONS_NAMES() \
    Powerfcnname[IRP_MN_WAIT_WAKE]      = "IRP_MN_WAIT_WAKE";\
    Powerfcnname[IRP_MN_POWER_SEQUENCE] = "IRP_MN_POWER_SEQUENCE";\
    Powerfcnname[IRP_MN_SET_POWER]      = "IRP_MN_SET_POWER";\
    Powerfcnname[IRP_MN_QUERY_POWER]    = "IRP_MN_QUERY_POWER";\
\
    Powersysstate[0]    = "PowerSystemUnspecified";\
    Powersysstate[1]    = "PowerSystemWorking";\
    Powersysstate[2]    = "PowerSystemSleeping1";\
    Powersysstate[3]    = "PowerSystemSleeping2";\
    Powersysstate[4]    = "PowerSystemSleeping3";\
    Powersysstate[5]    = "PowerSystemShutdown";\
    Powersysstate[6]    = "PowerSystemMaximum";\
\
    Powerdevstate[0]    = "PowerDeviceUnspecified";\
    Powerdevstate[1]    = "PowerDeviceD0";\
    Powerdevstate[2]    = "PowerDeviceD1";\
    Powerdevstate[3]    = "PowerDeviceD2";\
    Powerdevstate[4]    = "PowerDeviceD3";\
    Powerdevstate[5]    = "PowerDeviceMaximum";

#define INCLUDE_STATE_NAMES()   \
    statenames[0] = "STOPPED";\
    statenames[1] = "WORKING";\
    statenames[2] = "PENDINGSTOP";\
    statenames[3] = "PENDINGREMOVE";\
    statenames[4] = "SURPRISEREMOVED";\
    statenames[5] = "REMOVED";

#else

#define INCLUDE_PNP_FUNCTIONS_NAMES()
#define INCLUDE_POWER_FUNCTIONS_NAMES()
#define INCLUDE_STATE_NAMES()

#endif // DEBUG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gntser.c ===
/*++
                 Copyright (c) 1998 Gemplus developpement

Name: 
   GNTSER.C (Gemplus  Win NT SERial port management)

Description : 
   This module holds the functions needed for a communication on a serial line.

Environment:
   Kernel mode
               
Revision History :
   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.
   26/04/98: V1.00.002  (GPZ)
   22/01/99: V1.00.003  (YN)
	  - Remove the IRPCancel durnig call the serial driver

--*/

#include <stdio.h>
#include "gntscr.h"
#include "gntser.h"


//
// Type section:
//    TPORT_CONFIG:
//     - WaitRelease holds the timeout for the release of the semaphore.
//     - Counter holds the number of opened session. If its value is 0, the port is
//       closed.
//     - Error holds Rx over state.
//     - TimeOut holds the character level time out.
//     - TxSize memorises the transmit buffer size.
//     - RxSize memorises the reception buffer size.
//     - pSerialPortDevice is a pointer on the serial Device Object.
//
typedef struct
{
   ULONG          WaitRelease;
   USHORT         Counter;
   short          Error;
   ULONG         TimeOut;
   USHORT         TxSize;
   USHORT         RxSize;
   PDEVICE_OBJECT pSerialPortDevice;
   PKMUTEX         pExchangeMutex;
} TPORT_CONFIG;

#define GTSER_DEF_WAIT_RELEASE         2000
#define GTSER_IOCTL_WRITE					SCARD_CTL_CODE(1001)
#define GTSER_IOCTL_READ					SCARD_CTL_CODE(1000)

//
// Macro section:
//  - WORD_LEN, PARITY and STOP retreive the configuration values to pass to
//    Windows to configure the port.
//
#define WORD_LEN(x)       (BYTE)(((x) & 0x03) + 5)
#define PARITY(x)         (BYTE)(parity[((BYTE)(x) >> 3) & 3])
#define STOP(x)           (BYTE)(stop[((x) >> 2) & 1])

//
// Global variable section:
// - port_config is an array of TPORT_CONFIG which memorises the port
//   configuration at each time.
//
TPORT_CONFIG
    port_config[HGTSER_MAX_PORT] =
    {
        {0,0,0,0,0,0,NULL,NULL},
        {0,0,0,0,0,0,NULL,NULL},
        {0,0,0,0,0,0,NULL,NULL},
        {0,0,0,0,0,0,NULL,NULL}
    };

static USHORT
    parity[] = {
        NO_PARITY,
        ODD_PARITY,
        NO_PARITY,
        EVEN_PARITY
        };
static USHORT
    stop[] = {
        STOP_BIT_1,
        STOP_BITS_2
        };
//
// Local function definition section:
//
static NTSTATUS GDDKNT_GetCommStatus
(
    const SHORT         Handle,
    SERIAL_STATUS       *SerialStatus
);






NTSTATUS  
GDDK_SerPortOpen(
    const TGTSER_PORT  *Param,
          SHORT        *Handle
	)
/*++

Routine Description:

 This routine opens a serial port and initializes it according to the
    parameters found in Param.

Arguments:

 Param holds the following parameters:
  - Port indicates the selected port.
  - BaudRate is used to set port baud rate.
  - Mode gathers
     * word size WORD_5 (0), WORD_6 (1), WORD_7 (2) or WORD_8 (3),
     * stop bit number STOP_BIT_1 (0) or STOP_BIT_2 (4) and
     * parity NO_PARITY (0), ODD_PARITY (8) or EVEN_PARITY (24).
  - TxSize is the transmit buffer size, in bytes.
  - RxSize is the reception buffer size, in bytes.

--*/
{
    NTSTATUS status;
    PSMARTCARD_EXTENSION SmartcardExtension;
    SERIAL_READER_CONFIG SerialConfig;
    PREADER_EXTENSION pReaderExtension;
    SERIAL_QUEUE_SIZE SerialQueueSize;
    USHORT LengthOut = 0;
    SHORT handle = Param->Port - 1;

    // Controls the given parameters:
    if ((handle < 0) || (handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[handle].Counter != 0) {
        return STATUS_DEVICE_ALREADY_ATTACHED;
    }
    // Retrieve the SmartcardExtension structure of the current device.
    SmartcardExtension = (PSMARTCARD_EXTENSION)(Param->pSmartcardExtension);
    pReaderExtension = SmartcardExtension->ReaderExtension;
    port_config[handle].pSerialPortDevice = pReaderExtension->AttachedDeviceObject;
    port_config[handle].pExchangeMutex    = &pReaderExtension->ExchangeMutex;

    // The current port state is read and stored in current_dcb structure by
    // calling GetCommState function.
    // If the reading is possible (GetCommState return 0)
    // Then
    //   The current_dcb structure is updated with the given parameter (baud
    //   rate, ByteSize, Parity, StopBits).
    //   The modified state is written by calling SetCommState.
    status = GDDKNT_GetCommState(handle,&SerialConfig);
    if (NT_SUCCESS(status))
    {
        SerialQueueSize.InSize  = 4096L;
        SerialQueueSize.OutSize = 4096L;
        status = GDDKNT_SerPortIoRequest(
            handle,
            IOCTL_SERIAL_SET_QUEUE_SIZE,
            500UL,
            sizeof(SERIAL_QUEUE_SIZE),
            (PUCHAR)&SerialQueueSize,
            &LengthOut,
            NULL
            );

        // Set the serial port communication parameters
        SerialConfig.BaudRate.BaudRate = Param->BaudRate;
        SerialConfig.LineControl.WordLength = WORD_LEN(Param->Mode);
        SerialConfig.LineControl.Parity     = PARITY(Param->Mode);
        SerialConfig.LineControl.StopBits   = STOP(Param->Mode);
        // Set timeouts
        SerialConfig.Timeouts.ReadIntervalTimeout = 1000;
        SerialConfig.Timeouts.ReadTotalTimeoutConstant = 50000;
        SerialConfig.Timeouts.ReadTotalTimeoutMultiplier = 0; // 50;
        // Set special characters
        SerialConfig.SerialChars.ErrorChar = 0;
        SerialConfig.SerialChars.EofChar = 0;
        SerialConfig.SerialChars.EventChar = 0;
        SerialConfig.SerialChars.XonChar = 0;
        SerialConfig.SerialChars.XoffChar = 0;
        SerialConfig.SerialChars.BreakChar = 0xFF;
        // Set handflow
        SerialConfig.HandFlow.XonLimit = 0;
        SerialConfig.HandFlow.XoffLimit = 0;
        SerialConfig.HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
        SerialConfig.HandFlow.ControlHandShake = 0;
        status = GDDKNT_SetCommState(handle,&SerialConfig);
    }
    if (!NT_SUCCESS(status)) {

        return status;
    }

    // Memorises the given parameters in port_config structure.
    // Counter, Error, TimeOut, TxSize and RxSize fields are updated.
    port_config[handle].Counter = 1;
    port_config[handle].Error   = 0;
    port_config[handle].TimeOut = Param->TimeOut;
    port_config[handle].TxSize  = Param->TxSize;
    port_config[handle].RxSize  = Param->RxSize;
    // We update the handle value.
    *Handle = handle;
    return STATUS_SUCCESS;

}




NTSTATUS  
GDDK_SerPortAddUser(
    const SHORT   Port,
          SHORT  *Handle
	)
/*++

Routine Description:

 Add a new user on a port. This function return the handle of a previously
 opened port.
 When this function is successful, it is mandatory to call G_SerPortClose
 to decrement the user number.

Arguments:

  Port   - indicates the selected port: G_COMx

Return Value:

--*/
{
    // Controls the given parameters:
    if ((Port < G_COM1) || (Port > G_COM4)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Port - 1].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }
    if (port_config[Port - 1].Counter == 65535lu) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    // Increments the port_config.Counter.
    port_config[Port - 1].Counter += 1;

    // We return the Port number.
    *Handle = Port - 1;
    return STATUS_SUCCESS;
}




NTSTATUS  
GDDK_SerPortClose (
    const SHORT Handle
	)
/*++

Routine Description:

 This routine closes a previously opened serial port.
 When port is shared, the close will be effective only when all clients will
    have closed the port.

Arguments:

   Handle   - holds the port handle.

Return Value:

--*/
{
    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }
    // Decrements the port_config.Counter field.
    port_config[Handle].Counter -= 1;
    // Closes really the port for the last user:
    // The queues are flushed.
    if (port_config[Handle].Counter == 0) {
        GDDK_SerPortFlush(Handle,SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_TXABORT);
    }
    return STATUS_SUCCESS;
}




NTSTATUS  
GDDK_SerPortWrite(
    const SHORT        Handle,
    const USHORT       Length,
    const BYTE         Buffer[]
	)
/*++

Routine Description:

 This routine writes bytes on a previously opened serial port.

Arguments:

   Handle   - holds the port handle.
   Length   - holds the number of bytes to write.
   Buffer   - holds the bytes to write.

Return Value:

--*/
{
    NTSTATUS status;
    SERIAL_STATUS SerialStatus;
    USHORT LengthOut;

    ASSERT(Buffer != NULL);
    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }

    // Control if the write can be made in one time:
    // The windows port status is read by calling GetCommError to know how many
    // bytes remain in Tx queue (port_config.Error field is updated if needed).
    status = GDDKNT_GetCommStatus(Handle,&SerialStatus);
    ASSERT(status == STATUS_SUCCESS);
    if (status != STATUS_SUCCESS) {

        return status;     	
    }

    port_config[Handle].Error |= (USHORT)(SERIAL_ERROR_OVERRUN & SerialStatus.Errors);
    if (Length > ( port_config[Handle].TxSize - SerialStatus.AmountInOutQueue)) {
        return STATUS_INVALID_PARAMETER;
    }
    // Writes the given byte in Tx queue .
    // If an error occurs during this operation
    // Then
    //   The ClearCommError function is called to unblock the port
    //   (port_config.Error field is updated if needed).
    LengthOut = 0;
    status = GDDKNT_SerPortIoRequest(
        Handle,
        GTSER_IOCTL_WRITE,
        500UL,
        Length,
        Buffer,
        &LengthOut,
        NULL
        );

    if (!NT_SUCCESS(status)) {

        GDDKNT_GetCommStatus(Handle,&SerialStatus);
        port_config[Handle].Error |= (USHORT)(SERIAL_ERROR_OVERRUN & SerialStatus.Errors);
        LengthOut = 0;
        status = GDDKNT_SerPortIoRequest(
            Handle,
            IOCTL_SERIAL_RESET_DEVICE,
            500UL,
            0,
            NULL,
            &LengthOut,
            NULL
            );
        return STATUS_PORT_DISCONNECTED;
    }
    return STATUS_SUCCESS;
}



NTSTATUS  
GDDK_SerPortRead(
    const SHORT         Handle,
          USHORT       *Length,
          BYTE          Buffer[]
	)
/*++

Routine Description:

 This routine reads bytes on a previously opened serial port.
 It ends when required length = read length or when a character level timeout
    is detected.

Arguments:

   Handle   - holds the port handle.
   Length   - holds the number of bytes to read.
   Buffer   - is a free area of, at least, Length bytes.

Return Value:

--*/
{
    NTSTATUS status;

    ASSERT(Buffer != NULL);
    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        *Length = 0;
        return STATUS_PORT_DISCONNECTED;
    }

    // Try to read the bytes.
    status = GDDKNT_SerPortIoRequest(
        Handle,
        GTSER_IOCTL_READ,
        port_config[Handle].TimeOut,
        0,
        NULL,
        Length,
        Buffer
        );
    if (!NT_SUCCESS(status)) {
        return status;
    } else {
        if (*Length == 0) {
            return STATUS_INVALID_DEVICE_STATE;
        }
    }
    return STATUS_SUCCESS;

}


NTSTATUS  
GDDK_SerPortFlush(
    const SHORT  Handle,
    const USHORT Select
	)
/*++

Routine Description:

 This function clears Tx and Rx buffers.
 When RX_QUEUE is selected, the RX_OVER flag is reseted.

Arguments:

   Handle   - holds the port handle.
   Select   - holds the buffers to clear:

Return Value:

--*/
{
    NTSTATUS status;
    USHORT LengthOut = 0;
    ULONG PurgeMask;

    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }
    // Clears the selected queues
    if (Select & HGTSER_TX_QUEUE) {
        PurgeMask = SERIAL_PURGE_TXCLEAR;
    }
    if (Select & HGTSER_RX_QUEUE) {
        PurgeMask = SERIAL_PURGE_RXCLEAR;
        port_config[Handle].Error = 0;
    }

    status = GDDKNT_SerPortIoRequest(
        Handle,
        IOCTL_SERIAL_PURGE,
        500UL,
        sizeof(PurgeMask),
        (PUCHAR)&PurgeMask,
        &LengthOut,
        NULL
        );
    return STATUS_SUCCESS;
}




NTSTATUS  
GDDK_SerPortGetState(
    const SHORT   Handle,
    TGTSER_PORT  *Param,
    USHORT       *UserNb
	)
/*++

Routine Description:

 This routine read the currently in use parameters for an opened serial port.

Arguments:

   Handle   - holds the port handle.
   Param    - is a pointer on the Param structure.
   UserNb   - is a pointer on the number of user for this port.

Return Value:

--*/
{
    NTSTATUS status;
    SERIAL_READER_CONFIG SerialConfig;

    ASSERT(Param != NULL);
    ASSERT(UserNb != NULL);
    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }
    // The current port state is read and stored in current_dcb structure by calling
    // GetCommState function.
    status = GDDKNT_GetCommState(Handle,&SerialConfig);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    // The parameters are updated with the read values.
    Param->BaudRate = SerialConfig.BaudRate.BaudRate;
    switch (SerialConfig.LineControl.WordLength) {

    case 5:
        Param->Mode = HGTSER_WORD_5;
        break;
    case 6:
        Param->Mode = HGTSER_WORD_6;
        break;
    case 7:
        Param->Mode = HGTSER_WORD_7;
        break;
    case 8:
        Param->Mode = HGTSER_WORD_8;
        break;
    default:
        return STATUS_INVALID_DEVICE_STATE;
    }

    switch (SerialConfig.LineControl.Parity) {

    case NO_PARITY:
        Param->Mode |= HGTSER_NO_PARITY;
        break;
    case ODD_PARITY:
        Param->Mode |= HGTSER_ODD_PARITY;
        break;
    case EVEN_PARITY:
        Param->Mode |= HGTSER_EVEN_PARITY;
        break;
    case SERIAL_PARITY_MARK:
    case SERIAL_PARITY_SPACE:
    default:
        return STATUS_INVALID_DEVICE_STATE;
    }

    switch (SerialConfig.LineControl.StopBits) {

    case STOP_BIT_1:
        Param->Mode |= HGTSER_STOP_BIT_1;
        break;
    case STOP_BITS_2:
        Param->Mode |= HGTSER_STOP_BIT_2;
        break;
    case STOP_BITS_1_5:
    default:
        return STATUS_INVALID_DEVICE_STATE;
    }
    // Updates the library fields TimeOut, TxSize and RxSize.
    Param->TimeOut  = port_config[Handle].TimeOut;
    Param->TxSize   = port_config[Handle].TxSize;
    Param->RxSize   = port_config[Handle].RxSize;
    // The UserNb parameter is filled with the port_config.Counter.
    *UserNb = port_config[Handle].Counter;
    return STATUS_SUCCESS;
}




NTSTATUS  
GDDK_SerPortSetState(
    const SHORT   Handle,
    TGTSER_PORT  *Param
	)
/*++

Routine Description:

 This routine alters the currently in use parameters for an opened serial port.

Arguments:

   Handle   - holds the port handle.
   Param    - is a pointer on the Param structure.

Return Value:

--*/
{
    NTSTATUS status;
    SERIAL_READER_CONFIG SerialConfig;
    ULONG error = 0;

    ASSERT(Param != NULL);
    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return STATUS_INVALID_PARAMETER;
    }
    if (port_config[Handle].Counter == 0) {
        return STATUS_PORT_DISCONNECTED;
    }

    status = GDDKNT_GetCommState(Handle,&SerialConfig);
    if (NT_SUCCESS(status))
    {
        SerialConfig.BaudRate.BaudRate      = Param->BaudRate;
        SerialConfig.LineControl.WordLength = WORD_LEN(Param->Mode);
        SerialConfig.LineControl.Parity     = PARITY(Param->Mode);
        SerialConfig.LineControl.StopBits   = STOP(Param->Mode);
        status = GDDKNT_SetCommState(Handle,&SerialConfig);
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }
    // Updates the library fields TimeOut, TxSize and RxSize.
    port_config[Handle].TimeOut = Param->TimeOut;
    port_config[Handle].TxSize  = Param->TxSize;
    port_config[Handle].RxSize  = Param->RxSize;
    return status;
}




BOOLEAN 
GDDK_SerPortLockComm(
    const SHORT Handle,
    const ULONG WaitRelease
	)
/*++

Routine Description:

     Take the mutex for a serial port communication if is free or wait 
     the release

Arguments:

   Handle      - holds the port handle
   WaitRelease - holds the new time to wait the release

Return Value:

--*/
{
    NTSTATUS status;
    LARGE_INTEGER timeout;

    // Controls the given parameters:
    if ((Handle < 0) || (Handle >= HGTSER_MAX_PORT)) {
        return FALSE;
    }
    timeout.QuadPart = -((LONGLONG)(
    port_config[Handle].WaitRelease > GTSER_DEF_WAIT_RELEASE ? 
    port_config[Handle].WaitRelease : GTSER_DEF_WAIT_RELEASE)*10*1000);
    status = KeWaitForMutexObject(
        port_config[Handle].pExchangeMutex,
        Executive,
        KernelMode,
        FALSE,
        &timeout
        );
    if (status != STATUS_SUCCESS) {
        return FALSE;
    } else {
        port_config[Handle].WaitRelease = WaitRelease;
        return TRUE;
    }
}



VOID  
GDDK_SerPortUnlockComm(
    const SHORT Handle
	)
/*++

Routine Description:

   Release the mutex for a serial port communication.

Arguments:

   Handle      - holds the port handle

Return Value:

--*/
{
    NTSTATUS status;

    // Controls the given parameters:
    if ((Handle >= 0) && (Handle < HGTSER_MAX_PORT)) {
        status = KeReleaseMutex(port_config[Handle].pExchangeMutex,FALSE);
    }
}




NTSTATUS 
GDDKNT_SerPortIoRequest(
    CONST SHORT          Handle,
    CONST ULONG          SerialIoControlCode,
    CONST ULONG          CmdTimeout,
    CONST USHORT         LengthIn,
    CONST BYTE          *BufferIn,
          USHORT        *pLengthOut,
          BYTE          *BufferOut
	)
/*++

Routine Description:

    This function sends an IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

Arguments:

   Handle      - holds the port handle

Return Value:

--*/
{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpNextStack;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;

    KeInitializeEvent(&event,NotificationEvent,FALSE);
    // Build an Irp to be send to serial driver
    irp = IoBuildDeviceIoControlRequest(
        SerialIoControlCode,
        port_config[Handle].pSerialPortDevice, 
        (PVOID)BufferIn,
        (ULONG)LengthIn,
        (PVOID)BufferOut,
        (ULONG)(*pLengthOut),
        FALSE,
        &event,
        &ioStatus
        );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpNextStack = IoGetNextIrpStackLocation(irp);

    switch (SerialIoControlCode) {
    case GTSER_IOCTL_WRITE:
        irpNextStack->MajorFunction = IRP_MJ_WRITE;
        irpNextStack->Parameters.Write.Length = (ULONG)LengthIn;
        break;

    case GTSER_IOCTL_READ:
        irpNextStack->MajorFunction = IRP_MJ_READ;
        irpNextStack->Parameters.Read.Length = (ULONG)(*pLengthOut);
        break;
    }
    // Call the serial driver 
    status = IoCallDriver(
        port_config[Handle].pSerialPortDevice,
        irp
        );

    if (status == STATUS_PENDING) {
		// Wait until the serial driver has processed the Irp
		status = KeWaitForSingleObject(
			&event, 
			Suspended, 
			KernelMode, 
			FALSE, 
			NULL
			);
		//ASSERT(status == STATUS_SUCCESS);
    }

	if(status == STATUS_SUCCESS)
	{
	    status = ioStatus.Status;
		switch (SerialIoControlCode) {

		case GTSER_IOCTL_WRITE:
			if (ioStatus.Status == STATUS_TIMEOUT) {
				// STATUS_TIMEOUT isn't correctly mapped 
				// to a WIN32 error, that's why we change it here to STATUS_IO_TIMEOUT
				status = STATUS_IO_TIMEOUT;
			} 
			break;

		case GTSER_IOCTL_READ:
			if (ioStatus.Status == STATUS_TIMEOUT) {
				// STATUS_TIMEOUT isn't correctly mapped 
				// to a WIN32 error, that's why we change it here to STATUS_IO_TIMEOUT
				status = STATUS_IO_TIMEOUT;
				*pLengthOut = 0;
			} 
			break;

		default:
			*pLengthOut = (USHORT)(ioStatus.Information);
			break;
		}
	}
    return status;
}





NTSTATUS 
GDDKNT_SetCommState(
	const SHORT         Handle,
	SERIAL_READER_CONFIG *SerialConfig
	)
/*++

Routine Description:

    This routine will appropriately configure the serial port.
    It makes synchronous calls to the serial port.

Arguments:

   Handle         - holds the port handle
   SerialConfig   - holds the configuration to set.

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT i;
    ULONG SerialIoControlCode;
    USHORT LengthIn,LengthOut;
    PUCHAR pBufferIn;

    ASSERT(SerialConfig != NULL);
	for (i=0; NT_SUCCESS(status); i++) {
        switch (i) {
        case 0:
            // Set up baudrate 
            SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
            pBufferIn = (PUCHAR)&SerialConfig->BaudRate;
            LengthIn = sizeof(SERIAL_BAUD_RATE);
            break;

        case 1:
            // Set up line control parameters
            SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
            pBufferIn = (PUCHAR)&SerialConfig->LineControl;
            LengthIn = sizeof(SERIAL_LINE_CONTROL);
            break;

        case 2:
            // Set serial special characters
            SerialIoControlCode = IOCTL_SERIAL_SET_CHARS;
            pBufferIn = (PUCHAR)&SerialConfig->SerialChars;
            LengthIn = sizeof(SERIAL_CHARS);
            break;

        case 3:
            // Set up timeouts
            SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
            pBufferIn = (PUCHAR)&SerialConfig->Timeouts;
            LengthIn = sizeof(SERIAL_TIMEOUTS);
            break;

        case 4:
            // Set flowcontrol and handshaking
            SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;
            pBufferIn = (PUCHAR)&SerialConfig->HandFlow;
            LengthIn = sizeof(SERIAL_HANDFLOW);
            break;

        case 5:
            // Set break off
            SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
            LengthIn = 0;
            break;

        case 6:
            // Set DTR
            SerialIoControlCode = IOCTL_SERIAL_SET_DTR;
            LengthIn = 0;
            break;

        case 7:
            // Set RTS
            SerialIoControlCode = IOCTL_SERIAL_SET_RTS;
            LengthIn = 0;
            break;

        case 8:
            return STATUS_SUCCESS;
		}

        LengthOut = 0;
        status = GDDKNT_SerPortIoRequest(Handle,
            SerialIoControlCode,
            500UL,
            LengthIn,
            pBufferIn,
            &LengthOut,
            NULL
            );
    }

    return status;
}

NTSTATUS 
GDDKNT_GetCommState(
	const SHORT         Handle,
	SERIAL_READER_CONFIG *SerialConfig
	)
/*++

Routine Description:

    This routine will get the configuration of the serial port.
    It makes synchronous calls to the serial port.

Arguments:

   Handle         - holds the port handle
   SerialConfig   - holds the configuration of the serial port.

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT i;
    ULONG SerialIoControlCode;
    USHORT LengthOut;
    PUCHAR pBufferOut;

    ASSERT(SerialConfig != NULL);

    for (i=0; NT_SUCCESS(status); i++) {
        switch (i) {

        case 0:
            // Get up baudrate 
            SerialIoControlCode = IOCTL_SERIAL_GET_BAUD_RATE;
            pBufferOut = (PUCHAR)&SerialConfig->BaudRate;
            LengthOut = sizeof(SERIAL_BAUD_RATE);
            break;

        case 1:
            // Get up line control parameters
            SerialIoControlCode = IOCTL_SERIAL_GET_LINE_CONTROL;
            pBufferOut = (PUCHAR)&SerialConfig->LineControl;
            LengthOut = sizeof(SERIAL_LINE_CONTROL);
            break;

        case 2:
            // Get serial special characters
            SerialIoControlCode = IOCTL_SERIAL_GET_CHARS;
            pBufferOut = (PUCHAR)&SerialConfig->SerialChars;
            LengthOut = sizeof(SERIAL_CHARS);
            break;

        case 3:
            // Get up timeouts
            SerialIoControlCode = IOCTL_SERIAL_GET_TIMEOUTS;
            pBufferOut = (PUCHAR)&SerialConfig->Timeouts;
            LengthOut = sizeof(SERIAL_TIMEOUTS);
            break;

        case 4:
            // Get flowcontrol and handshaking
            SerialIoControlCode = IOCTL_SERIAL_GET_HANDFLOW;
            pBufferOut = (PUCHAR)&SerialConfig->HandFlow;
            LengthOut = sizeof(SERIAL_HANDFLOW);
            break;

        case 5:
            return STATUS_SUCCESS;
		}

        status = GDDKNT_SerPortIoRequest(Handle,
            SerialIoControlCode,
            500UL,
            0,
            NULL,
            &LengthOut,
            pBufferOut
            );
    }

    return status;
}



static NTSTATUS 
GDDKNT_GetCommStatus(
	const SHORT         Handle,
	SERIAL_STATUS       *SerialStatus
	)
/*++

Routine Description:

    This routine will appropriately get status information of the serial port.
    It makes synchronous calls to the serial port.

Arguments:

   Handle         - holds the port handle
   SerialStatus   - holds the status of the serial port.

Return Value:

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT LengthOut;

    ASSERT(SerialStatus != NULL);
    LengthOut = sizeof(SERIAL_STATUS);
    status = GDDKNT_SerPortIoRequest(Handle,
        IOCTL_SERIAL_GET_COMMSTATUS,
        500UL,
        0,
        NULL,
        &LengthOut,
        (PUCHAR)SerialStatus
        );

    return status;
}


NTSTATUS SER_SetPortTimeout( const short Handle, ULONG Timeout)
{    // Controls the given parameters:
short portcom;
	if(GDDK_GBPChannelToPortComm(Handle,&portcom))	return STATUS_INVALID_PARAMETER;
	port_config[portcom].TimeOut = Timeout;
	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\driver.h ===
// Gemplus (C) 1999
// This is main Driver object for the driver.
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef DRV_INT
#define DRV_INT

// System includes
#include "kernel.h"

#pragma PAGEDCODE
#ifdef __cplusplus
extern "C"{
#endif

NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath);
VOID WDM_Unload(IN PDRIVER_OBJECT DriverObject);

// WDM devices
LONG WDM_AddDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_USBDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_USBReader(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
LONG WDM_Add_Bus(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject);
NTSTATUS WDM_SystemControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);


#ifdef __cplusplus
}
#endif

// already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gcr410p\gntser.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:  
   GNTSER.H (Gemplus NT SERial management)

Description : 
  This module holds the prototypes of the functions from GNTSER.C

Revision History :

   dd/mm/yy
   13/03/98: V1.00.001  (GPZ)
      - Start of development.

--*/
#ifndef _GNTSER_
#define _GNTSER_
//
// Constant section:
//  - HGTSER_MAX_PORT holds the number of managed port. Today 4.
//  - HGTSER_WORD_5, HGTSER_WORD_6, HGTSER_WORD_7 and HGTSER_WORD_8 allow to 
//    configure the number of bits per word.
//  - HGTSER_STOP_BIT_1 and HGTSER_STOP_BIT_2 allow to configure the number of stop
//    bit.
//  - HGTSER_NO_PARITY, HGTSER_ODD_PARITY and HGTSER_EVEN_PARITY allow to configure
//    the communication parity.
//  - HGTSER_TX_QUEUE and HGTSER_RX_QUEUE are queues indentifiers.
//  - HGTSER_RX_OVER is set when the reception queue is full and characters has 
//    been lost.                                                                   
//  - WTX_TIMEOUT is the time out used when a WTX REQUEST is send by  the CT.
//  - CHAR_TIMEOUT is the timeout at character level: today 1000 ms.
//  
#define HGTSER_MAX_PORT          4
#define HGTSER_WORD_5         0x00
#define HGTSER_WORD_6         0x01
#define HGTSER_WORD_7         0x02
#define HGTSER_WORD_8         0x03
#define HGTSER_STOP_BIT_1     0x00
#define HGTSER_STOP_BIT_2     0x04
#define HGTSER_NO_PARITY      0x00
#define HGTSER_ODD_PARITY     0x08
#define HGTSER_EVEN_PARITY    0x18
#define HGTSER_TX_QUEUE          1
#define HGTSER_RX_QUEUE          2
#define HGTSER_RX_OVER           1
#define WTX_TIMEOUT 3000
#define CHAR_TIMEOUT 1000

//
// Type section:
//  - TGTSER_PORT gathers data used to manage a serial port:
//     * Port     indicates the selected port.
//                G_COM1, G_COM2, G_COM3 or G_COM4
//     * BaudRate is used to set port baud rate when open routine is called.
//                300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200
//     * Mode     Memorises
//                WORD size       : 5, 6, 7 or 8
//                stop bit number : 1 or 2
//                parity          : no parity, odd or even parity
//     * TimeOut  indicates the time out value, in milli-seconds, at character
//                level.
//     * TxSize   is the transmit buffer size, in bytes.
//     * RxSize   is the reception buffer size, in bytes.
// 
typedef struct
{
   SHORT   Port;
   ULONG   BaudRate;
   USHORT  Mode;
   ULONG   TimeOut;
   USHORT  TxSize;
   USHORT  RxSize;
   void *pSmartcardExtension;
} TGTSER_PORT;


//
// Prototypes section:
//
NTSTATUS  
GDDK_SerPortOpen(
    const TGTSER_PORT  *Param,
          SHORT        *Handle
	);

NTSTATUS  
GDDK_SerPortClose(
    const SHORT Handle
	);

NTSTATUS  
GDDK_SerPortWrite(
    const SHORT        Handle,
    const USHORT       Length,
    const BYTE         Buffer[]
	);

NTSTATUS  
GDDK_SerPortRead(
    const SHORT         Handle,
          USHORT       *Length,
          BYTE          Buffer[]
	);

NTSTATUS  
GDDK_SerPortFlush(
    const SHORT  Handle,
    const USHORT Select
	);

NTSTATUS  
GDDK_SerPortAddUser(
    const SHORT   Port,
          SHORT  *Handle
	);

NTSTATUS  
GDDK_SerPortGetState(
    const SHORT   Handle,
    TGTSER_PORT  *Param,
    USHORT       *UserNb
	);

NTSTATUS  
GDDK_SerPortSetState(
    const SHORT   Handle,
    TGTSER_PORT  *Param
	);

BOOLEAN  
GDDK_SerPortLockComm(
    const SHORT Handle,
    const DWORD WaitRelease
	);
VOID
GDDK_SerPortUnlockComm(
    const SHORT Handle
	);

NTSTATUS 
GDDKNT_SerPortIoRequest(
    CONST SHORT          Handle,
    CONST ULONG          SerialIoControlCode,
    CONST ULONG          CmdTimeout,
    CONST USHORT         LengthIn,
    CONST BYTE          *BufferIn,
          USHORT        *pLengthOut,
          BYTE          *BufferOut
	);

NTSTATUS 
GDDKNT_SetCommState(
	const SHORT         Handle,
	SERIAL_READER_CONFIG *SerialConfig
	);

NTSTATUS 
GDDKNT_GetCommState(
	const SHORT         Handle,
	SERIAL_READER_CONFIG *SerialConfig
	);

NTSTATUS SER_SetPortTimeout( const short Handle, ULONG Timeout);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\driver.cpp ===
//-------------------------------------------------------------------
// This is driver object
// It defines interface with specific system
// Author: Sergey Ivanov
// Log:
//      06/08/99    -   implemented 
//-------------------------------------------------------------------
#include "driver.h"

#ifdef WDM_KERNEL
#pragma message("******** WDM build... ********")
#endif

#include "usbreader.h"

// Walter Oney
// @func Determine if we're running under Windows 98 or Windows 2000
// @rdesc TRUE if running under Windows 98, FALSE if under Windows 2000
// @comm This function calls IoIsWdmVersionAvailable to see if the OS
// supports WDM version 1.10. Win98 and Win98 2d ed support 1.00, whereas
// Win2K supports 1.10.

#pragma PAGEDCODE

BOOLEAN GENERIC_EXPORT isWin98()
{                           // IsWin98
#ifdef _X86_
    return !IoIsWdmVersionAvailable(1, 0x10);
#else
    return FALSE;
#endif // _X86_
}// IsWin98

#pragma LOCKEDCODE

#if DEBUG && defined(_X86_)

extern "C" VOID __declspec(naked) __cdecl _chkesp()
{
    _asm je okay
    ASSERT(!DRIVERNAME " - Stack pointer mismatch!");
okay:
    _asm ret
}

#endif // DBG

// This will fix some linker problem
int __cdecl _purecall(VOID) {return 0;};

#pragma LOCKEDDATA
BOOLEAN SystemWin98 = TRUE;
ULONG   ObjectCounter = 0;

#pragma INITCODE
// Driver main entry...(Actually, it could have any name...)
NTSTATUS    DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegistryPath)
{
    DBG_PRINT ("\n");
    DBG_PRINT ("*** DriverEntry: DriverObject %8.8lX ***\n", DriverObject);

    if(SystemWin98 = isWin98())
    {
        DBG_PRINT("========  WINDOWS 98 DETECTED ========\n");
    }
    else
        DBG_PRINT("========  WINDOWS 2000 DETECTED ========\n");
    // Create driver kernel...
#pragma message("********** Compiling WDM driver version *********")
    DBG_PRINT ("        Loading WDM kernel\n");
    kernel = CKernel::loadWDMKernel();
    if(!kernel)
    {
        // LOG ERROR!
        DBG_PRINT ("ERROR: At loading WDM kernel! ***\n");
        return STATUS_UNSUCCESSFUL;
    }
    
    DBG_PRINT ("        Creating unicode string for registry path...\n");
    
    kernel->RegistryPath = new (NonPagedPool)CUString(RegistryPath);
    if (!ALLOCATED_OK(kernel->RegistryPath))
    {
        // LOG ERROR!
        DISPOSE_OBJECT(kernel->RegistryPath);
        DISPOSE_OBJECT(kernel);
        DBG_PRINT ("ERROR: At allocating WDM registry path! ***\n");
        return STATUS_UNSUCCESSFUL;
    }

    DBG_PRINT ("        Registering WDM system callbacks\n");

    DriverObject->DriverExtension->AddDevice            = WDM_AddDevice;
    DriverObject->DriverUnload                          = WDM_Unload;

    DriverObject->MajorFunction[IRP_MJ_CREATE]          = open;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = close;

    DriverObject->MajorFunction[IRP_MJ_WRITE]           = write;
    DriverObject->MajorFunction[IRP_MJ_READ]            = read;
    // The mechanism for handling read and write requests for a device that uses
    // interrupts includes a Start I/O routine, an interrupt service routine, and
    // a deferred procedure call routine that finishes handling interrupts. We
    // need to supply the StartIo routine address here.
    //DriverObject->DriverStartIo = startIo;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = WDM_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = deviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = pnpRequest;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = powerRequest;

    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = flush;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = cleanup;

    DBG_PRINT ("**** Driver was initialized successfully! ****\n");

    return STATUS_SUCCESS;
}

NTSTATUS
WDM_SystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
{
   NTSTATUS status = STATUS_SUCCESS;
   CDevice *device;

   device = kernel->getRegisteredDevice(DeviceObject);

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(device->getLowerDriver(), Irp);
      
   return status;

}

#pragma PAGEDCODE
VOID WDM_Unload(IN PDRIVER_OBJECT DriverObject)
{   
    PAGED_CODE();

    DBG_PRINT ("\n*** Unload: Driver %8.8lX ***\n", DriverObject);
    kernel->dispose();
    DBG_PRINT("*** Object counter before unload %d\n",ObjectCounter);

    DBG_PRINT (">>>>>>> All active devices were removed! Driver was unloaded! <<<<<<\n");
} 


#pragma PAGEDCODE

// C wrapper functions for driver object
LONG WDM_AddDevice(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject)
{
NTSTATUS status = STATUS_UNSUCCESSFUL;
    // Get registry about device type installation
    // switch depends of device.
    // Create device object
    // Check device type and create device specific objects
    // like serial, usb, PCMCIA and so on...
    // Specific objects can overwrite base class functions.
    // For now we will create USB device object
    //TODO recognize device type dinamically...


#pragma message("********** Compiling USB READER driver version *********")
    //status = WDM_Add_USBDevice(DriverObject,DeviceObject);
    DBG_PRINT ("Adding USB reader...\n");
    status = WDM_Add_USBReader(DriverObject,DeviceObject);
    return status;
}


// We decided to support different devices at system...
// It requires to have different callback functions for different devices.
// So let's create wrappers and redirect requests to specific devices.

// CALLBACK WRAPPER FUNCTIONS
// This callbacks should be defined at any device object
#pragma LOCKEDCODE
IMPLEMENT_CALLBACK_LONG1(open,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(close,IN PIRP);

IMPLEMENT_CALLBACK_LONG1(read,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(write,IN PIRP);
IMPLEMENT_CALLBACK_VOID1(startIo,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(deviceControl,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(flush,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(cleanup,IN PIRP);
IMPLEMENT_CALLBACK_LONG1(powerRequest,IN PIRP);

// Support callbacks
IMPLEMENT_CALLBACK_VOID1(cancelPendingIrp,IN PIRP);

#pragma LOCKEDCODE
NTSTATUS pnpRequest(IN PDEVICE_OBJECT fdo,IN PIRP Irp)
{
CDevice* device;
//CUSBReader* device;// TO CHANGE LATER....
NTSTATUS status;
PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
ULONG MinorFunction = stack->MinorFunction;

    //device = (CUSBReader*) kernel->getRegisteredDevice(fdo);// TO CHANGE LATER....
    device = kernel->getRegisteredDevice(fdo);// TO CHANGE LATER....
    if(!device) 
    {
        DBG_PRINT ("*** PnP: Device was already removed...***\n");
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;
        ::IoCompleteRequest(Irp,IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_STATE;
    }
    
    status = device->pnpRequest(Irp);

    if(MinorFunction == IRP_MN_REMOVE_DEVICE)
    {
        //Child devices will be removed by BUS...
        if(device->getObjectType()!= CHILD_DEVICE)
        {
            PDEVICE_OBJECT DeviceObject = device->getSystemObject();
            // Sometimes Unload can interrupt standard PnP sequence 
            // and remove device before we finish...
            DBG_PRINT ("*** PnP: Disposing device -> %8.8lX ***\n", device);
            device->dispose();
            if(DeviceObject)
            {            
                DBG_PRINT("Deleting device object %8.8lX from system...\n",DeviceObject);
                DBG_PRINT("<<<<< OBJECT REFERENCE COUNT ON REMOVE %d\n",DeviceObject->ReferenceCount);
                IoDeleteDevice(DeviceObject);
            }
        }
    }
    return  status;
}

#pragma PAGEDCODE
LONG WDM_Add_USBReader(IN PDRIVER_OBJECT DriverObject,IN PDEVICE_OBJECT DeviceObject)
{
NTSTATUS status;
WCHAR wcTemp[256];
ULONG junk;
    
    CLogger* logger = kernel->getLogger();

    DBG_PRINT("*** AddDevice: DriverObject %8.8lX, DeviceObject %8.8lX ***\n", DriverObject, DeviceObject);
    DBG_PRINT("     Creating WDM USB reader...\n");
    CUSBReader* reader = kernel->createUSBReader();
    if(ALLOCATED_OK(reader))    
    {
        reader->acquireRemoveLock();
        DBG_PRINT ("Call USB reader object to add the reader...\n");
        status = reader->add(DriverObject,DeviceObject);
        if(!NT_SUCCESS(status))     
        {
            DBG_PRINT ("###### Add() reports error! Disposing reader...\n");            
            reader->dispose();
            return status;
        }
        else//Register our device object and device class
        {
            DBG_PRINT ("        Registering new reader %8.8lX at kernel...\n",reader);
            //kernel->registerObject(reader->getSystemObject(),(CDevice*)reader);
            kernel->registerObject(reader->getSystemObject(),(CUSBReader*)reader);
        }
        
        {
        CUString*   ustrTmp;
        ANSI_STRING astrTmp;
        UNICODE_STRING valname;
        ULONG size = 0;
        HANDLE hkey;

            DBG_PRINT ("=====================================================\n");
            // Set default values..
            reader->setVendorName("Gemplus",sizeof("Gemplus"));
            reader->setDeviceType("GemPC430",sizeof("GemPC430"));

            // Get Hardware ID
            status = IoGetDeviceProperty(DeviceObject, DevicePropertyHardwareID, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device Hardware ID  - %ws\n", wcTemp);
            }

            status = IoGetDeviceProperty(DeviceObject, DevicePropertyDeviceDescription, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device description  - %ws\n", wcTemp);
            }           
            
            status = IoGetDeviceProperty(DeviceObject, DevicePropertyManufacturer, sizeof(wcTemp), wcTemp, &junk);
            if(NT_SUCCESS(status))      
            {
                DBG_PRINT("  Device Manufacturer - %ws\n", wcTemp);
            }

            // Get OEM IfdType if present
            status = IoOpenDeviceRegistryKey(DeviceObject, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hkey);
            if (NT_SUCCESS(status))
            {
                // Get Vendor name...
                RtlInitUnicodeString(&valname, L"VendorName");
                size = 0;
                status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
                if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
                {
                    PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(NonPagedPool, size);
                    if(vpip)
                    {
                        status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
                        if (NT_SUCCESS(status))
                        {
                            DBG_PRINT(" OEM Vendor name found - '%ws' \n", vpip->Data);
                            // Copy string into the driver...
                            ustrTmp = new(NonPagedPool) CUString((PWCHAR)vpip->Data);
                            if(ALLOCATED_OK(ustrTmp))
                            {
                                RtlUnicodeStringToAnsiString(&astrTmp,&ustrTmp->m_String,TRUE);
                                reader->setVendorName(astrTmp.Buffer,astrTmp.Length);
                                RtlFreeAnsiString(&astrTmp);
                            }
                            DISPOSE_OBJECT(ustrTmp);
                        }
                        ExFreePool(vpip);
                    }
                }
            
                // Get IfdType...
                RtlInitUnicodeString(&valname, L"IfdType");
                size = 0;
                status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
                if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
                {
                    PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(NonPagedPool, size);
                    if(vpip)
                    {
                        status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
                        if (NT_SUCCESS(status))
                        {
                            DBG_PRINT(" OEM IfdType found - '%ws' \n", vpip->Data);
                            // Copy string into the driver...
                            ustrTmp = new(NonPagedPool) CUString((PWCHAR)vpip->Data);
                            if(ALLOCATED_OK(ustrTmp))
                            {
                                RtlUnicodeStringToAnsiString(&astrTmp,&ustrTmp->m_String,TRUE);
                                reader->setDeviceType(astrTmp.Buffer,astrTmp.Length);
                                RtlFreeAnsiString(&astrTmp);
                            }
                            DISPOSE_OBJECT(ustrTmp);
                        }
                        ExFreePool(vpip);
                    }
                }

                ZwClose(hkey);
            }
            DBG_PRINT ("=====================================================\n");

        }
        status = STATUS_SUCCESS;
        DBG_PRINT("**** Initializing SmartCardSystem...  ****\n");          
        reader->initializeSmartCardSystem();

        DBG_PRINT("**** Creating reader interface type %d, protocol %d ****\n",READER_INTERFACE_GEMCORE,READER_PROTOCOL_LV);            
        if(!reader->createInterface(READER_INTERFACE_GEMCORE,READER_PROTOCOL_LV,reader))
        {
            DBG_PRINT("**** Failed to create reader interface...  ****\n");         
            if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_FAILED_TO_CREATE_INTERFACE,DeviceObject);
            //Close and unregister reader...
            reader->dispose();
            return STATUS_UNSUCCESSFUL;
        }

        DBG_PRINT("**** USB reader successfuly loaded!  ****\n");           
        reader->releaseRemoveLock();
        //if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_START_OK, reader->getSystemObject());
        return status;
    }
    else
    {
        DISPOSE_OBJECT(reader);
        DBG_PRINT("#### Failed to create USB reader...\n");         
        if(ALLOCATED_OK(logger)) logger->logEvent(GRCLASS_FAILED_TO_CREATE_READER,DeviceObject);
    }
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\gemcore.cpp ===
#include "gemcore.h"
#include "iopack.h"

#pragma PAGEDCODE

NTSTATUS CGemCore::read(CIoPacket* Irp)
{
NTSTATUS status;
ULONG ReplyLength;
	ReplyLength = Irp->getReadLength();
	
	TRACE("GemCore read requested...\n");

	status = readAndWait((PUCHAR)Irp->getBuffer(),Irp->getReadLength(),(PUCHAR)Irp->getBuffer(),&ReplyLength);
	if(!NT_SUCCESS(status)) ReplyLength = 0;
	Irp->setInformation(ReplyLength);

	TRACE("GemCore read response:\n");
	//TRACE_BUFFER(Irp->getBuffer(),ReplyLength);
	
	return status;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::write(CIoPacket* Irp)
{
NTSTATUS status;
ULONG ReplyLength;
	ReplyLength = Irp->getWriteLength();
	
	TRACE("GemCore write requested...\n");
	//TRACE_BUFFER(Irp->getBuffer(),Irp->getWriteLength());

	status = writeAndWait((PUCHAR)Irp->getBuffer(),Irp->getReadLength(),(PUCHAR)Irp->getBuffer(),&ReplyLength);
	if(!NT_SUCCESS(status)) ReplyLength = 0;
	Irp->setInformation(ReplyLength);

	TRACE("GemCore write response:\n");
	//TRACE_BUFFER(Irp->getBuffer(),ReplyLength);
	return status;
}

#pragma PAGEDCODE
// Reader interface functions...
NTSTATUS CGemCore::readAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
ULONG length;
ULONG BufferLength;
BOOL  extendedCommand;
ULONG replyLength;
ULONG expectedReplyLength;	
ULONG replyBufferPosition = 0;

	if(!RequestLength || !pRequest || !pReply || !pReplyLength  || RequestLength<5)
		return STATUS_INVALID_PARAMETER;

	length = pRequest[4];
	if (!length || (length > READER_DATA_BUFFER_SIZE - 3))
	{
		// If the length is lower or equal to 252 (255 - (<IFD Status> + <SW1> + <SW2>))
		// (standard OROS cmds)
		extendedCommand = TRUE;
		TRACE("******** EXTENDED COMMAND REQUESTED! ");
		TRACE_BUFFER(pRequest,RequestLength);

		if(!length) length = 256;
		expectedReplyLength = length;
	}
	else	extendedCommand = FALSE;


	pOutputBuffer[0] = GEMCORE_CARD_READ;
	memory->copy(pOutputBuffer+1,pRequest,5);
	length = 6;
	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Extended command valid only if card reports 0 status!
	if(pInputBuffer[0]!=0)
	{
		extendedCommand = FALSE;
	}
	// ISV: If card finish Xfer, do not send send second part of the command!
	// This will fix CyberFlex card problem...
	if(extendedCommand && BufferLength==3)
	{
		TRACE("******** EXTENDED COMMAND CANCELLED BY CARD REPLY!\n");
		extendedCommand = FALSE;
	}
	
	// Skip status byte
	replyLength = BufferLength - 1;	
	if(extendedCommand)
	{
		// Copy first part of the reply to the output buffer...
		// Skip status byte.
		if(*pReplyLength<(replyBufferPosition + replyLength))
		{
			*pReplyLength = 0;
			return STATUS_INVALID_BUFFER_SIZE;
		}
		memory->copy(pReply,pInputBuffer+1, replyLength);
		replyBufferPosition = replyLength;

		// Read second block of data...
		pOutputBuffer[0] = GEMCORE_CARD_READ;
		memory->copy(pOutputBuffer+1,"\xFF\xFF\xFF\xFF", 4);
        	pOutputBuffer[5] = (BYTE ) (expectedReplyLength - replyLength);
		length = 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			*pReplyLength = 0;
			return status;
		}

		status = translateStatus(pInputBuffer[0],0);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			return status;
		}
		// Skip status byte.
		replyLength = BufferLength - 1;	
	}
	
	if(*pReplyLength<(replyBufferPosition + replyLength))
	{

		TRACE("Gemcore: INVALID BUFFER LENGTH - buffer length %d, reply length %d\n",*pReplyLength,(replyBufferPosition + replyLength));
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	// Skip status byte.
	if(replyLength) memory->copy(pReply+replyBufferPosition,pInputBuffer+1, replyLength);
	*pReplyLength = replyBufferPosition + replyLength;

	TRACE("GemCore readAndWait() response with Length %d \n",*pReplyLength);
	//TRACE_BUFFER(pReply,*pReplyLength);

	return status;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::writeAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
ULONG length;
ULONG BufferLength;
NTSTATUS status;

	TRACE("\nGEMCORE WRITE:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest || RequestLength<5)
	{
		TRACE("\nGEMCORE WRITE: INVALID IN PARAMETERS...\n");
		return STATUS_INVALID_PARAMETER;
	}

	length = pRequest[4];
	if(RequestLength<length+5)
	{
		TRACE("\nGEMCORE WRITE: INVALID REQUESTED LENGTH...\n");
		return STATUS_INVALID_PARAMETER;
	}
	
	if (length > READER_DATA_BUFFER_SIZE - 7)
	{
        // If the length is lower or equal than the extended available space (255)
        // Prepare and send the first part of the extended ISO In command:
        // The five command bytes are added in cmd buffer: 0xFF,0xFF,0xFF,0xFF,LN-248
		// Read second block of data...
 		pOutputBuffer[0] = GEMCORE_CARD_WRITE;
		memory->copy(pOutputBuffer+1,"\xFF\xFF\xFF\xFF", 4);
		length = length - (READER_DATA_BUFFER_SIZE - 7);
		pOutputBuffer[5] = (BYTE )length;
		memory->copy(pOutputBuffer+6,pRequest + 5 + 248, length);
		// Add size of header...
		length += 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			return status;
		}

		if(!NT_SUCCESS(status))
		{
			return status;
		}
		// NOW prepare and send the Second part of the extended ISO In command:
        // The five command bytes are added in cmd buffer.
        // The data field is added (248 bytes).
        // The command is sent to IFD.
		// Now set length to first block of data...
		length = 248;
	}
 	
	pOutputBuffer[0] = GEMCORE_CARD_WRITE;
	memory->copy(pOutputBuffer+1,pRequest,4);
	pOutputBuffer[5] = pRequest[4]; // Warning you must specified full APDU length
	memory->copy(pOutputBuffer+6,pRequest+5, length);
	// Add size of header...
	length += 6;
	BufferLength = InputBufferLength;
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Skip status byte.
	length = BufferLength - 1;	
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	// Skip status byte.
	if(length) memory->copy(pReply,pInputBuffer+1, length);
	*pReplyLength = length;
	
	TRACE("GemCore writeAndWait() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}

#pragma PAGEDCODE
ReaderConfig	CGemCore::getConfiguration()
{
	return configuration;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::setConfiguration(ReaderConfig configuration)
{
	this->configuration = configuration;
	return STATUS_SUCCESS;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	ULONG length;
	ULONG BufferLength;
	NTSTATUS status;

	TRACE("\nGEMCORE VendorIOCTL:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE IOCTL: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

	memory->copy(pOutputBuffer,pRequest, RequestLength);

	// Send direct gemcore command
	BufferLength = InputBufferLength;

	status = protocol->writeAndWait(pOutputBuffer,RequestLength,pInputBuffer,&BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}
	// NOTE: DO NOT TRANSLATE REPLY, USER REQUIRED TO GET THIS INFORMATION

	// SO, keep status byte.
	length = BufferLength;
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	
	// Skip status byte.
	if(length) memory->copy(pReply, pInputBuffer, length);
	*pReplyLength = length;
	
	TRACE("GemCore VendorIOCTL() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}


#pragma PAGEDCODE
NTSTATUS CGemCore::SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	ULONG length;
	ULONG BufferLength;
	NTSTATUS status;
    BYTE  NewTA1;


	TRACE("\nGEMCORE SwitchSpeed:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE SwitchSpeed: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

	NewTA1 = pRequest[0];

    // Modify speed value in reader's memory.
    length = 6;
    pOutputBuffer[0] = 0x23;  // Write memory command
    pOutputBuffer[1] = 0x01;  // The type of memory is iData.
    pOutputBuffer[2] = 0x00;  // Address high byte.
    pOutputBuffer[3] = 0x89;  // Address low byte.
    pOutputBuffer[4] = 0x01;  // Number of byte to write

    // New speed.
    pOutputBuffer[5] = NewTA1;

	// Send direct gemcore command
	BufferLength = InputBufferLength;

	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}

	length = BufferLength;
	if(*pReplyLength<length)
	{
		*pReplyLength = 0;
		return STATUS_BUFFER_TOO_SMALL;
	}
	
	// Copy the full reply
	if(length) memory->copy(pReply, pInputBuffer, length);
	*pReplyLength = length;

	TRACE("GemCore SwitchSpeed() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}

// TODO:
// ??????????????????
// It is specific to device not Gemcore
// I would suggest to move it into the  specific reader object!
#pragma PAGEDCODE
NTSTATUS CGemCore::VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	NTSTATUS status;
    ULONG TagValue;

	TRACE("\nGEMCORE VendorAttibute:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest)
	{
		TRACE("\nGEMCORE VendorAttibute: INVALID IN PARAMETERS...\n");
		*pReplyLength = 0;
		return STATUS_INVALID_PARAMETER;
	}

    if (RequestLength < sizeof(TagValue)) 
	{
		*pReplyLength = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    TagValue = (ULONG) *((PULONG)pRequest);

    switch(ControlCode)
	{
    // Get an attribute
    case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
        switch (TagValue)
		{
        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:
            if (*pReplyLength < (ULONG) sizeof(configuration.PowerTimeOut))
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				&configuration.PowerTimeOut,
				sizeof(configuration.PowerTimeOut));
			*pReplyLength = (ULONG)sizeof(configuration.PowerTimeOut);
			status = STATUS_SUCCESS;
            break;

        case SCARD_ATTR_MANUFACTURER_NAME:
            if (*pReplyLength < ATTR_LENGTH)
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				ATTR_MANUFACTURER_NAME,
				sizeof(ATTR_MANUFACTURER_NAME));
			
			*pReplyLength = (ULONG)sizeof(ATTR_MANUFACTURER_NAME);
			status = STATUS_SUCCESS;
            break;

        case SCARD_ATTR_ORIGINAL_FILENAME:
            if (*pReplyLength < ATTR_LENGTH)
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
			// Copy the value of PowerTimeout in the reply buffer
			memory->copy(
				pReply,
				ATTR_ORIGINAL_FILENAME,
				sizeof(ATTR_ORIGINAL_FILENAME));
			
			*pReplyLength = (ULONG)sizeof(ATTR_ORIGINAL_FILENAME);
			status = STATUS_SUCCESS;
            break;
        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
			*pReplyLength = 0;
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    // Set the value of one tag (IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE)
    case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
        switch (TagValue)
		{

        // Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
        case SCARD_ATTR_SPEC_POWER_TIMEOUT:

            if (RequestLength <(ULONG) (sizeof(configuration.PowerTimeOut) + sizeof(TagValue)))
			{
				*pReplyLength = 0;
                return STATUS_BUFFER_TOO_SMALL;
            }
            memory->copy(
                &configuration.PowerTimeOut,
                pRequest + sizeof(TagValue),
                sizeof(configuration.PowerTimeOut));

			*pReplyLength = 0;
            status = STATUS_SUCCESS;
            break;

        // Unknown tag, we return STATUS_NOT_SUPPORTED
        default:
			*pReplyLength = 0;
            status = STATUS_NOT_SUPPORTED;
        }
        break;

    default:
		*pReplyLength = 0;
        status = STATUS_NOT_SUPPORTED;
        break;
    }

	TRACE("GemCore VendorAttibute() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);
	return status;
}




#pragma PAGEDCODE
NTSTATUS CGemCore::powerUp(BYTE* pReply,ULONG* pReplyLength)
{
	BYTE  CFG = 0,PCK;
	ULONG length,i;
	ULONG BufferLength;

	NTSTATUS status;

	switch(configuration.Voltage)
	{
		case CARD_VOLTAGE_3V: CFG = 0x02;break;
		case CARD_VOLTAGE_5V: CFG = 0x01;break;
		default:    		  CFG = 0x00;break;
	}

	switch(configuration.PTSMode) 
	{
		case PTS_MODE_DISABLED: CFG |= 0x10;break;
		case PTS_MODE_OPTIMAL:	CFG |= 0x20;break;
		case PTS_MODE_MANUALLY: CFG |= 0x10;break;
		case PTS_MODE_DEFAULT:  CFG = 0x00;break;  // do not add cfg field
		default:				CFG = 0x00;break;  // same
	}

	length = 0;
	pOutputBuffer[length++] = GEMCORE_CARD_POWER_UP;

	// YN: if CFG = 0 that means we just need to do a power without CFG
	// This append in the case with a card in specific mode (presence of TA2)
	if(CFG) pOutputBuffer[length++] = CFG;

	BufferLength = InputBufferLength;
	protocol->set_WTR_Delay(protocol->get_Power_WTR_Delay());
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
	protocol->set_Default_WTR_Delay();

	if (NT_SUCCESS(status)) 
	{
		if(BufferLength)
		{
			BufferLength--;
			TRACE("GemCore status %x\n",pInputBuffer[0]);
			status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			
			if(!NT_SUCCESS(status))
			{
				TRACE("GemCore FAILED TO POWER UP CARD! Status %x\n", status);
				*pReplyLength = 0;
				return status;
			}

			TRACE("GemCore power() ATR");
			TRACE_BUFFER(pInputBuffer+1,BufferLength);
			// Skip status byte and copy ATR
			if(pInputBuffer[1]==0x3B || pInputBuffer[1]==0x3F)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
				*pReplyLength = BufferLength;
			}
			else
			{
				*pReplyLength = 0;
				return STATUS_UNSUCCESSFUL;
			}
			//return status; //YN: do not return now
		}
		else
		{
			*pReplyLength = 0;
			return STATUS_UNSUCCESSFUL;
		}

		// YN: add PTS capabilities
		if (pInputBuffer[0] == 0x00) 
		{
			if(configuration.PTSMode == PTS_MODE_MANUALLY)
			{
				length = 0;
				pOutputBuffer[length++] = GEMCORE_CARD_POWER_UP;
				CFG |= 0xF0; //Manual PPS and 3V or 5V module
				pOutputBuffer[length++] = CFG;
				pOutputBuffer[length++] = configuration.PTS0;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS1) != 0) pOutputBuffer[length++] = configuration.PTS1;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS2) != 0) pOutputBuffer[length++] = configuration.PTS2;
				if ((configuration.PTS0 & PTS_NEGOTIATE_PTS3) != 0) pOutputBuffer[length++] = configuration.PTS3;
				
				// computes the exclusive-oring of all characters from CFG to PTS3				
				PCK = 0xFF;
				for (i=2; i<length; i++) { PCK ^= pOutputBuffer[i];}
				pOutputBuffer[length++] = PCK;

				BufferLength = InputBufferLength;
				
				protocol->set_WTR_Delay(protocol->get_Power_WTR_Delay());
				status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
				protocol->set_Default_WTR_Delay();

				// Copy into buffer only when it fail.
				if (!NT_SUCCESS(status) || (BufferLength != 1) || (pInputBuffer[0] != 0x00)) 
				{
					*pReplyLength = BufferLength;
					if (BufferLength > 1)
					{
						memory->copy(pReply,pInputBuffer,BufferLength);
					}
				}

				return status;
			}
		}
	}
	else
	{
		*pReplyLength = 0;
	}

	return status;
}




#pragma PAGEDCODE
NTSTATUS CGemCore::power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific)
{
	ULONG length;
	ULONG BufferLength;
	ULONG PreviousState;
	NTSTATUS status;

	switch(ControlCode)
	{
    case SCARD_COLD_RESET:

		//ISV: First treat any card as ISO card on cold reset!
        // Defines the type of the card (ISOCARD) and set the card presence 
		RestoreISOsetting();
		length = 2;
		BufferLength = InputBufferLength;
		pOutputBuffer[0] = GEMCORE_DEFINE_CARD_TYPE;
		pOutputBuffer[1] = (UCHAR)configuration.Type;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);

		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
		}

		if (!NT_SUCCESS(status))
		{
			return status;
		}

		if(Specific == FALSE)
		{
			// 
			// Just define card default values
			// 
			RestoreISOsetting();
		}


		PreviousState = protocol->getCardState();

		// Power down first for a cold reset
		// YN : verify power state of card first
		
		length = 0;
		pOutputBuffer[length++] = GEMCORE_CARD_POWER_DOWN;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
		}
		TRACE("GemCore powerDown() response\n");
		//TRACE_BUFFER(pInputBuffer,BufferLength);
		*pReplyLength = 0;
		if(status != STATUS_SUCCESS)
		{
			return status;
		}

		// YN this is PowerTimeout must be a 
        if ((PreviousState & SCARD_POWERED) && (configuration.PowerTimeOut))
		{
            // Waits for the Power Timeout to be elapsed.
			// before doing reset.
			TRACE("GEMCORE power, ColdReset timeout %d ms\n", configuration.PowerTimeOut);
			DELAY(configuration.PowerTimeOut);
        }

    case SCARD_WARM_RESET:
		// If card have a Specific mode let Gemcore negociate properly with this card.
		if(Specific)
		{
			// keep configuration of the reader.
			configuration.PTSMode = PTS_MODE_DEFAULT;
			status = powerUp(pReply, pReplyLength);
		}
		else if(configuration.Type == TRANSPARENT_MODE_CARD)
		{
			// ISV: Command 12 will fail in transparant mode...
			// Let's set reader in ISO mode first!
			TRACE("	WARM RESET for Transparent mode requested...\n");
			RestoreISOsetting();
			length = 2;
			BufferLength = InputBufferLength;
			pOutputBuffer[0] = GEMCORE_DEFINE_CARD_TYPE;
			pOutputBuffer[1] = (UCHAR)configuration.Type;

			status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
			if(NT_SUCCESS(status))
			{
				if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			}

			if (!NT_SUCCESS(status))
			{
				return status;
			}			
			// do not lost transparent config on warm reset
			// keep configuration of the reader.
			status = powerUp(pReply, pReplyLength);
		}
		else
		{
			// Do a regular ISO reset
			status = powerUp(pReply, pReplyLength);			
		}

		return status;
		break;
	case SCARD_POWER_DOWN:
			length = 0;
			pOutputBuffer[length++] = GEMCORE_CARD_POWER_DOWN;
			BufferLength = InputBufferLength;
			status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
			if(NT_SUCCESS(status))
			{
				if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
			}
			TRACE("GemCore powerDown() response\n");
			//TRACE_BUFFER(pInputBuffer,BufferLength);
			*pReplyLength = 0;
			return status;
		break;
	}
	*pReplyLength = 0;
	return STATUS_INVALID_DEVICE_REQUEST;
}


#pragma PAGEDCODE
VOID	 CGemCore::cancel()
{
}

#pragma PAGEDCODE
NTSTATUS CGemCore::initialize()
{
	TRACE("Initializing Gemcore interface...\n");
	TRACE("Setting Gemcore reader mode...\n");
	
	Initialized = TRUE;
	Mode = READER_MODE_NATIVE;
	NTSTATUS status = setReaderMode(READER_MODE_NATIVE);
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to set Gemcore reader mode %x\n",READER_MODE_NATIVE);
		return STATUS_INVALID_DEVICE_STATE;
	}

	TRACE("Getting Gemcore reader version...\n");
	ULONG VersionLength = VERSION_STRING_MAX_LENGTH;
	status = getReaderVersion(Version,&VersionLength);
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to get GemCore reader interface version...\n");
		return STATUS_INVALID_DEVICE_STATE;
	}
	else
	{
		Version[VersionLength] = 0x00;
		TRACE("****** GemCore version - %s ******\n",Version);
	}

	TRACE("Gemcore interface initialized...\n");
	return status;

}

#pragma PAGEDCODE
ULONG CGemCore::getReaderState()
{
ULONG BufferLength;
	pOutputBuffer[0] = GEMCORE_GET_CARD_STATUS;
	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,1,pInputBuffer,&BufferLength);			
	TRACE("GemCore getReaderState() response\n");
	//TRACE_BUFFER(pInputBuffer,BufferLength);

	if(!NT_SUCCESS(status) || !BufferLength || (BufferLength<2))
	{
		TRACE("FAILED!\n");
		return SCARD_ABSENT;	
	}

	if (!(pInputBuffer[1] & 0x04))
	{
		TRACE("*** Card is absent!\n");
		return SCARD_ABSENT;
	}
	else 
	if (pInputBuffer[1] & 0x04)
	{
		TRACE("*** Card is present!\n");
		return SCARD_SWALLOWED;
	}
	else
	{
		TRACE("Card state is unknown!\n");
		return SCARD_ABSENT;
	}
	
	return SCARD_ABSENT;
}

#pragma PAGEDCODE
NTSTATUS  CGemCore::getReaderVersion(PUCHAR pVersion, PULONG pLength)
{
ULONG BufferLength;
ULONG length;
	if(!pVersion || !pLength) return STATUS_INVALID_PARAMETER;
	length = sizeof(GEMCORE_GET_FIRMWARE_VERSION);
	// Remove last 0x00
	if(length) length--;
	memory->copy(pOutputBuffer,GEMCORE_GET_FIRMWARE_VERSION,length);
	BufferLength = InputBufferLength;

	TRACE("getReaderVersion() \n");
	//TRACE_BUFFER(pOutputBuffer,length);

	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pLength = 0;
		return STATUS_UNSUCCESSFUL;	
	}
	
	if (pInputBuffer[0])
	{
		*pLength = 0;
		return translateStatus(pInputBuffer[0],0);
	}

	if(BufferLength-1 > *pLength)
	{
		BufferLength =  *pLength;
	}
	// Remove status byte...
	BufferLength--;
	if(BufferLength) memory->copy(pVersion,pInputBuffer+1,BufferLength);
	*pLength = BufferLength;
	return STATUS_SUCCESS;
}

#pragma PAGEDCODE
NTSTATUS CGemCore::setReaderMode(ULONG mode)
{
BYTE CFG_BYTE; 
ULONG BufferLength;

	switch(mode)
	{
	case READER_MODE_NATIVE: CFG_BYTE = 0x00;	break;
	case READER_MODE_ROS:	 CFG_BYTE = 0x08;	break;
	case READER_MODE_TLP:	 CFG_BYTE = 0x09;	break;
		default:			 CFG_BYTE = 0x00;	break;
	}

	pOutputBuffer[0] = GEMCORE_READER_SET_MODE;
	pOutputBuffer[1] = 0x00;
	pOutputBuffer[2] = CFG_BYTE;

	BufferLength = InputBufferLength;
	NTSTATUS status = protocol->writeAndWait(pOutputBuffer,3,pInputBuffer,&BufferLength);			
	if(!NT_SUCCESS(status))
	{
		TRACE("Failed to set reader mode...\n");
		return status;	
	}

	return status;
};

#pragma PAGEDCODE
NTSTATUS	CGemCore::translateStatus( const BYTE  ReaderStatus, const ULONG IoctlType)
{
    switch (ReaderStatus) 
	{
    case 0x00 : return STATUS_SUCCESS;
    case 0x01 : return STATUS_NO_SUCH_DEVICE;
    case 0x02 : return STATUS_NO_SUCH_DEVICE;
    case 0x03 : return STATUS_INVALID_PARAMETER; 
    case 0x04 : return STATUS_IO_TIMEOUT;
    case 0x05 : return STATUS_INVALID_PARAMETER;
    case 0x09 : return STATUS_INVALID_PARAMETER;
    case 0x10 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x11 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x12 : return STATUS_INVALID_PARAMETER;
    case 0x13 : return STATUS_CONNECTION_ABORTED;
    case 0x14 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x15 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x16 : return STATUS_INVALID_PARAMETER;
    case 0x17 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x18 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x19 : return STATUS_INVALID_PARAMETER;
    case 0x1A : return STATUS_INVALID_PARAMETER;
    case 0x1B : return STATUS_INVALID_PARAMETER;
    case 0x1C : return STATUS_INVALID_PARAMETER;
    case 0x1D : return STATUS_UNRECOGNIZED_MEDIA;
    case 0x1E : return STATUS_INVALID_PARAMETER;
    case 0x1F : return STATUS_INVALID_PARAMETER;
    case 0x20 : return STATUS_INVALID_PARAMETER;
    case 0x30 : return STATUS_IO_TIMEOUT;
    case 0xA0 : return STATUS_SUCCESS;
    case 0xA1 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xA2 : 
        if(IoctlType == GEMCORE_CARD_POWER) return STATUS_UNRECOGNIZED_MEDIA;
        else                                return STATUS_IO_TIMEOUT;
    case 0xA3 : return STATUS_PARITY_ERROR;
    case 0xA4 : return STATUS_REQUEST_ABORTED;
    case 0xA5 : return STATUS_REQUEST_ABORTED;
    case 0xA6 : return STATUS_REQUEST_ABORTED;
    case 0xA7 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xCF : return STATUS_INVALID_PARAMETER;
    case 0xE4 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xE5 : return STATUS_SUCCESS;
    case 0xE7 : return STATUS_SUCCESS;
    case 0xF7 : return STATUS_NO_MEDIA;
    case 0xF8 : return STATUS_UNRECOGNIZED_MEDIA;
    case 0xFB : return STATUS_NO_MEDIA;
    default   : return STATUS_INVALID_PARAMETER;
    }
}


#pragma PAGEDCODE
VOID CGemCore::RestoreISOsetting(VOID)
{
	configuration.Type		= ISO_CARD;//ISO_CARD  (02)
	configuration.PresenceDetection = DEFAULT_PRESENCE_DETECTION; // (0D)
	configuration.Voltage	= CARD_DEFAULT_VOLTAGE;  //CARD_DEFAULT_VOLTAGE;
	configuration.PTSMode	= PTS_MODE_DISABLED;  //PTS_MODE_DISABLED;
	configuration.PTS0		= 0;
	configuration.PTS1		= 0;
	configuration.PTS2		= 0;
	configuration.PTS3		= 0;
	configuration.Vpp		= 0;  //CARD_DEFAULT_VPP;
	configuration.ActiveProtocol = 0;// Undefined
}


#pragma PAGEDCODE
NTSTATUS	CGemCore::setTransparentConfig(
	PSCARD_CARD_CAPABILITIES cardCapabilities,
	BYTE NewWtx
	)
/*++

Routine Description:

	Set the parameters of the transparent mode.

Arguments:
	PSCARD_CARD_CAPABILITIES CardCapabilities - structure for card 
	NewWtx               - holds the value (ms) of the new Wtx

--*/
{
    LONG etu;
    BYTE temp,mask,index;
	ULONG Length, BufferLength;

    NTSTATUS status;

	TRACE("\nGEMCORE T1 setTransparentConfig Enter\n");

    // Inverse or direct conversion
    if (cardCapabilities->InversConvention)
        configuration.transparent.CFG |= 0x20;
    else
        configuration.transparent.CFG &= 0xDF;
    // Transparent T=1 like (with 1 byte for the length).
    configuration.transparent.CFG |= 0x08;
    // ETU = ((F[Fi]/D[Di]) - 1) / 3
    etu = cardCapabilities->ClockRateConversion[
        (BYTE) configuration.transparent.Fi].F;
    if (cardCapabilities->BitRateAdjustment[
        (BYTE) configuration.transparent.Fi].DNumerator) {

        etu /= cardCapabilities->BitRateAdjustment[
            (BYTE) configuration.transparent.Di].DNumerator;
    }
    etu -= 1;
    etu /= 3;
    configuration.transparent.ETU = (BYTE) ( 0x000000FF & etu);

    if (cardCapabilities->N == 0xFF) {

        configuration.transparent.EGT = (BYTE) 0x00;
    } else {
        configuration.transparent.EGT = (BYTE) cardCapabilities->N;
    }

    configuration.transparent.CWT = (BYTE) cardCapabilities->T1.CWI;
    if (NewWtx) {

        for (mask = 0x80,index = 8; index !=0x00; index--) {
            temp = NewWtx & mask;
            if (temp == mask)
                break;
            mask = mask/2;
        }
        configuration.transparent.BWI = cardCapabilities->T1.BWI + index;
    } else {

        configuration.transparent.BWI = cardCapabilities->T1.BWI;
    }

	Length = 6;
	BufferLength = InputBufferLength;

	pOutputBuffer[0] = GEMCORE_CARD_POWER_UP;
    pOutputBuffer[1] = configuration.transparent.CFG;
    pOutputBuffer[2] = configuration.transparent.ETU;
    pOutputBuffer[3] = configuration.transparent.EGT;
    pOutputBuffer[4] = configuration.transparent.CWT;
    pOutputBuffer[5] = configuration.transparent.BWI;

	status = protocol->writeAndWait(pOutputBuffer,Length,pInputBuffer,&BufferLength);

	if(NT_SUCCESS(status))
	{
		if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
	}

	TRACE("\nGEMCORE T1 setTransparentConfig Exit\n");

	return status;
}



#pragma PAGEDCODE
NTSTATUS CGemCore::setProtocol(ULONG ProtocolRequested)
{
	NTSTATUS status;
	UCHAR Buffer[256];
	ULONG BufferLength = 256;

	switch(ProtocolRequested)
	{
	case SCARD_PROTOCOL_T1:
		configuration.PTS0 = PTS_NEGOTIATE_T1 | PTS_NEGOTIATE_PTS1;
		configuration.ActiveProtocol = SCARD_PROTOCOL_T1;
		break;
	case SCARD_PROTOCOL_T0:
		configuration.PTS0 = PTS_NEGOTIATE_T0 | PTS_NEGOTIATE_PTS1;
		configuration.ActiveProtocol = SCARD_PROTOCOL_T0;
	default:
		break;
	}
	// PTS1 has to be set before at power up...
	//configuration.PTS1 = CardCapabilities->PtsData.Fl << 4 | CardCapabilities->PtsData.Dl;

	if(configuration.PTSMode == PTS_MODE_MANUALLY)
	{
		status = powerUp(Buffer,&BufferLength);
	}
	else {
		status = power(SCARD_COLD_RESET, Buffer, &BufferLength, FALSE);
	}

	if(NT_SUCCESS(status))
	{
		if(BufferLength)  status = translateStatus(pInputBuffer[0],GEMCORE_CARD_POWER);
	}

	return status;
}


// TODO:
// What the purpose of the function?
// It's name does not tell anything...
// Actually it was suggested for the different purposes.
// Function has to be rewritten! It has a lot of mixed stuff like getting
// card status for example.
// ............................

//
// Use to made full T1 exchange in transparent mode
//
#pragma PAGEDCODE
NTSTATUS CGemCore::translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	NTSTATUS status;
	UCHAR Cmd[256];
	ULONG CmdLength = 0;
	UCHAR Buffer[256];
	ULONG BufferLength;
	ULONG length;

	//
	// If the current card type <> TRANSPARENT_MODE_CARD 
	//
	if (configuration.Type != TRANSPARENT_MODE_CARD) 
	{

		// We read the status of the card to known the current voltage and the TA1
		BufferLength = 256;
		CmdLength = 1;

		Cmd[0] = GEMCORE_GET_CARD_STATUS;
		status = protocol->writeAndWait(Cmd,CmdLength,Buffer,&BufferLength);
		
		// verify return code of reader
		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(Buffer[0],GEMCORE_CARD_POWER);
		}
		
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		// Update Config
		configuration.transparent.CFG = Buffer[1] & 0x01; //Vcc
		configuration.transparent.Fi = Buffer[3] >>4; //Fi
		configuration.transparent.Di = 0x0F & Buffer[3]; //Di

		//We define the type of the card.

		BufferLength = 256;
		CmdLength = 2;
		// assign TRANSPARENT_MODE_CARD
		configuration.Type = TRANSPARENT_MODE_CARD;
		Cmd[0] = GEMCORE_DEFINE_CARD_TYPE;
		Cmd[1] = (BYTE) configuration.Type;
		status = protocol->writeAndWait(Cmd,CmdLength,Buffer,&BufferLength);

		if(NT_SUCCESS(status))
		{
			if(BufferLength)  status = translateStatus(Buffer[0],GEMCORE_CARD_POWER);
		}
		
		if (!NT_SUCCESS(status))
		{
			return status;
		}

		// YN ?  Mandatory!!!  Else reader will be slow in T=1
        // Set the transparent configuration
		setTransparentConfig(cardCapabilities, NewWtx);

		NewWtx = 0;  // to not repeat again this call
    }
	/////// 

	if(NewWtx)
	{
		setTransparentConfig(cardCapabilities, NewWtx);
	}

	TRACE("\nGEMCORE T1 translate_request:\n");
	//TRACE_BUFFER(pRequest,RequestLength);
	if(!RequestLength || !pRequest ) return STATUS_INVALID_PARAMETER;

	length = RequestLength;  // protocol
	
	if (RequestLength >= READER_DATA_BUFFER_SIZE  )
	{
		// If the length is upper than the standard available space (254)
		// Then Send the last datas 

        // If the length is lower or equal than the extended available space (255)
        // Prepare and send the first part of the extended ISO In command:
        // The five command bytes are added in cmd buffer: 0xFF,0xFF,0xFF,0xFF,LN-248
		// Read second block of data...
 		pOutputBuffer[0] = GEMCORE_CARD_WRITE;  // specific for transparent exchange write long...

		length = length - 254 + 1;

		memory->copy(pOutputBuffer+1,pRequest + 254, length - 1);
		// Add size of header...
		length += 6;
		BufferLength = InputBufferLength;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
		if(!NT_SUCCESS(status) || !BufferLength)
		{
			return status;
		}

		// prepare next paquet
		length = 254;
	}

	pOutputBuffer[0] = GEMCORE_CARD_EXCHANGE;
	memory->copy(pOutputBuffer +1 ,pRequest, length);

	// Add size of header...
	length += 1;

	BufferLength = InputBufferLength;
	status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer,&BufferLength);
	if(!NT_SUCCESS(status) || !BufferLength)
	{
		*pReplyLength = 0;
		return status;
	}

    // If the IFD signals more data to read...
	// YN: 2 block for response...
    if (BufferLength > 0 && pInputBuffer[0] == 0x1B)
	{
		ULONG BufferLength2 = 256;
		UCHAR pInputBuffer2[256];

		// Send a command to read the last data.
 		pOutputBuffer[0] = GEMCORE_CARD_READ;  // specific for transparent exchange read long...
		length = 1;
		status = protocol->writeAndWait(pOutputBuffer,length,pInputBuffer2,&BufferLength2);

		if(!NT_SUCCESS(status) || !BufferLength2)
		{
			*pReplyLength = 0;
			return status;
		}

        if ((BufferLength + BufferLength2 - 2) > *pReplyLength) 
		{
			*pReplyLength = 0;
            return STATUS_INVALID_PARAMETER;
        }

        // Copy the last reader status
        pInputBuffer[0] = pInputBuffer2[0];

		status = translateStatus(pInputBuffer[0],0);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			return status;
		}

		// Skip 2 status byte.
        *pReplyLength = BufferLength + BufferLength2 - 2;

		// Skip status byte.
		if(*pReplyLength) 
		{
			memory->copy(pReply,pInputBuffer+1, BufferLength -1);
			memory->copy(pReply + (BufferLength-1), pInputBuffer2 +1, BufferLength2 -1);
		}

		TRACE("GemCore translate_request2 () response\n");
		//TRACE_BUFFER(pReply,*pReplyLength);

		return status;
	}

	status = translateStatus(pInputBuffer[0],0);
	if(!NT_SUCCESS(status))
	{
		*pReplyLength = 0;
		return status;
	}

	// Skip status byte.
	length = BufferLength - 1;

	if(*pReplyLength < length)
	{
		*pReplyLength = 0;
		return STATUS_INVALID_BUFFER_SIZE;
	}
	
	// Skip status byte.
	if(length) 
	{
		memory->copy(pReply,pInputBuffer+1, length);
	}
	*pReplyLength = length;
	
	TRACE("GemCore translate_request() response\n");
	//TRACE_BUFFER(pReply,*pReplyLength);

	return status;
};


// TODO:
// ???????????
#pragma PAGEDCODE
NTSTATUS CGemCore::translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	switch(configuration.ActiveProtocol)
	{
	case SCARD_PROTOCOL_T1:
		break;
	case SCARD_PROTOCOL_T0:
	default:
		break;
	}
	return STATUS_SUCCESS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\interface.cpp ===
#include "interface.h"
#include "kernel.h"

#pragma PAGEDCODE
CReaderInterface::CReaderInterface()
{ 
	protocol = NULL;
	memory   = NULL;
	debug	 = NULL;

	Initialized = FALSE;
	Mode = READER_MODE_NATIVE;

};

CReaderInterface::CReaderInterface(CProtocol* protocol)
{
	debug	= kernel->createDebug();
	if(protocol)	this->protocol = protocol;
	memory = kernel->createMemory();
	if(memory)
	{
		pOutputBuffer = (PUCHAR) memory->allocate(NonPagedPool,INTERFACE_OUTPUT_BUFFER_SIZE);
		pInputBuffer  = (PUCHAR) memory->allocate(NonPagedPool,INTERFACE_INPUT_BUFFER_SIZE);
		if(pOutputBuffer && pInputBuffer)
		{
			OutputBufferLength	= INTERFACE_OUTPUT_BUFFER_SIZE;
			InputBufferLength	= INTERFACE_INPUT_BUFFER_SIZE;
		}
		else
		{
			if(pOutputBuffer) memory->free(pOutputBuffer);
			if(pInputBuffer)  memory->free(pInputBuffer);
			pOutputBuffer	  = NULL;
			pInputBuffer	  = NULL;
		}
	}

	Initialized = FALSE;
	Mode = READER_MODE_NATIVE;
	TRACE("********* ReaderInterface object created ...\n");
};

CReaderInterface::~CReaderInterface()
{ 
	TRACE("******* Destroing ReaderInterface object...\n");
	if(memory)		  
	{
		if(pOutputBuffer) memory->free(pOutputBuffer);
		if(pInputBuffer)  memory->free(pInputBuffer);
		memory->dispose();
	}
	if(protocol)	protocol->dispose();
	if(debug)		debug->dispose();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\int.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef INT_INT
#define INT_INT
#include "generic.h"
#pragma PAGEDCODE
class CInterrupt
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CInterrupt(){};
	virtual ~CInterrupt(){};
public:

	virtual NTSTATUS	connect(OUT PKINTERRUPT *InterruptObject,
							IN PKSERVICE_ROUTINE ServiceRoutine,
							IN PVOID ServiceContext,
							IN PKSPIN_LOCK SpinLock OPTIONAL,
							IN ULONG Vector,
							IN KIRQL Irql,
							IN KIRQL SynchronizeIrql,
							IN KINTERRUPT_MODE InterruptMode,
							IN BOOLEAN ShareVector,
							IN KAFFINITY ProcessorEnableMask,
							IN BOOLEAN FloatingSave
							) {return STATUS_SUCCESS;};

	virtual VOID		disconnect(IN PKINTERRUPT InterruptObject) {};
	virtual VOID		initializeDpcRequest(IN PDEVICE_OBJECT pFdo,IN PDEFERRED_FUNCTION DpcForIsr) {};
	virtual BOOLEAN		synchronizeExecution (	IN PKINTERRUPT Interrupt,
												IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
												IN PVOID SynchronizeContext) {return FALSE;};         
};	

#endif//CInterrupt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\guid.h ===
/*++
 The below GUID is used to generate symbolic links to
  driver instances created from user mode
--*/
#ifndef GUID_INC
#define GUID_INC

#ifdef __cplusplus
extern "C"{
#endif

#include <smclib.h>
#include <initguid.h>


// {8C7F3D60-FC17-11d2-B669-0008C7606FEB} for GRUSB.SYS
DEFINE_GUID(GUID_CLASS_GRCLASS, 
0x8c7f3d60, 0xfc17, 0x11d2, 0xb6, 0x69, 0x0, 0x8, 0xc7, 0x60, 0x6f, 0xeb);

//SmartCardReaderGuid
DEFINE_GUID(GUID_CLASS_SMARTCARD, 
0x50DD5230, 0xBA8A, 0x11D1, 0xBF, 0x5D, 0x00, 0x00, 0xF8, 0x05, 0xF5, 0x30);

#ifdef __cplusplus
}
#endif

#endif // end, #ifndef GUID_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\gemcore.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		08/11/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __GEMCORE__
#define __GEMCORE__

#include "interface.h"
#include "rdrconfig.h"

// Reader max buffer size
#define READER_DATA_BUFFER_SIZE  255

// Tells that power command was used 
#define GEMCORE_CARD_POWER	1

//
// DEFAULT_POWER_TIMEOUT defines the default power timout in ms.
//
#define GEMCORE_DEFAULT_POWER_TIMEOUT	750


#define GEMCORE_CARD_POWER_DOWN	0x11
#define GEMCORE_CARD_POWER_UP	0x12
#define GEMCORE_CARD_READ		0x13
#define GEMCORE_CARD_WRITE		0x14
#define GEMCORE_CARD_EXCHANGE	0x15
#define GEMCORE_DEFINE_CARD_TYPE	0x17
#define GEMCORE_GET_CARD_STATUS		0x17// Commands differs only by parameter...

#define GEMCORE_GET_FIRMWARE_VERSION "\x22\x05\x3F\xE0\x10"
#define GEMCORE_READER_SET_MODE	     0x01

// Card configuration
#define  ISO_CARD                   0x02
#define  TRANSPARENT_MODE_CARD      0xEF
#define  DEFAULT_PRESENCE_DETECTION 0x0D
#define  CARD_DEFAULT_VPP           0

#define CARD_VOLTAGE_5V				0
#define CARD_VOLTAGE_3V 			1
#define CARD_DEFAULT_VOLTAGE		CARD_VOLTAGE_5V

// PTS mode parameters
#define PTS_MODE_DEFAULT			0
#define PTS_MODE_DISABLED			1
#define PTS_MODE_OPTIMAL   			2
#define PTS_MODE_MANUALLY			3

#define PTS_NEGOTIATE_PTS1			0x10
#define PTS_NEGOTIATE_PTS2			0x20
#define PTS_NEGOTIATE_PTS3			0x40

#define PTS_NEGOTIATE_T0			0x00
#define PTS_NEGOTIATE_T1			0x01

//   - ICC_DEFAULT_POWER_TIMOUT defines the default power timout in ms.
#define ICC_DEFAULT_POWER_TIMOUT     750

#pragma PAGEDCODE

class  CIoPacket;

class CGemCore : public CReaderInterface
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
private:
ReaderConfig configuration;
protected:
	CGemCore(){};
public:
	CGemCore(CProtocol* protocol) : CReaderInterface(protocol)
	{ 
		TRACE("Gemcore Reader Interface was created with protocol %x \n",protocol);
	  // These values went from Gemcore portocol
	  // Lets leave it for now, but eventually we could 
	  // redefine them creating Gemcore independent
	  // reader configuration
	  configuration.Type		= ISO_CARD;//ISO_CARD (02)
	  configuration.PresenceDetection = DEFAULT_PRESENCE_DETECTION;//DEFAULT_PRESENCE_DETECTION (0D)
	  configuration.Voltage	= CARD_DEFAULT_VOLTAGE;  //CARD_DEFAULT_VOLTAGE;
	  configuration.PTSMode	    = PTS_MODE_DISABLED;  //PTS_MODE_DISABLED;
	  configuration.PTS0		= 0;
	  configuration.PTS1		= 0;
	  configuration.PTS2		= 0;
	  configuration.PTS3		= 0;
	  configuration.Vpp		    = 0;  //CARD_DEFAULT_VPP;
	  configuration.ActiveProtocol = 0;// Undefined
	  configuration.PowerTimeOut = GEMCORE_DEFAULT_POWER_TIMEOUT;
	  m_Status = STATUS_SUCCESS;
	};

	virtual ~CGemCore()
	{ 
		TRACE("GemCore Reader Interface %8.8lX was destroied...\n",this);
	};

	virtual VOID dispose()
	{
		self_delete();
	};


	static CReaderInterface*  create(CProtocol* protocol)
	{ 
		CReaderInterface* interface = new (NonPagedPool) CGemCore(protocol); 
		if(!ALLOCATED_OK(interface))
		{
			DISPOSE_OBJECT(interface);
			interface = NULL;
		}
		return interface; 
	};


	virtual  NTSTATUS	translateStatus( const BYTE  ReaderStatus, const ULONG IoctlType);

	virtual  ULONG     getReaderState();
	virtual  NTSTATUS  getReaderVersion(PUCHAR pVersion, PULONG pLength);
	virtual  NTSTATUS  setReaderMode(ULONG mode);
	virtual  NTSTATUS  initialize();


	// Reader interface functions...
	virtual  ReaderConfig	getConfiguration();
	virtual  NTSTATUS setConfiguration(ReaderConfig configuration);
	virtual  NTSTATUS  setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual  VOID RestoreISOsetting(VOID);
	
	virtual  NTSTATUS read(CIoPacket* Irp);
	virtual  NTSTATUS write(CIoPacket* Irp);
	virtual  NTSTATUS readAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual  NTSTATUS writeAndWait(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
    virtual  NTSTATUS ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
    virtual  NTSTATUS power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific);
	virtual  NTSTATUS powerUp(BYTE* pReply,ULONG* pReplyLength);
	virtual  NTSTATUS setProtocol(ULONG ProtocolRequested);
	virtual  VOID	  cancel();
	// Process smartcard requests according to reader capabilities
	virtual  NTSTATUS translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual  NTSTATUS translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\generic.h ===
// Gemplus (C) 1999
// This module keeps system interface for the driver.
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef GEN_INT
#define GEN_INT

#define PAGEDCODE code_seg("page")
#define LOCKEDCODE code_seg()
#define INITCODE code_seg("init")

#define PAGEDDATA data_seg("page")
#define LOCKEDDATA data_seg()
#define INITDATA data_seg("init")

#define SMARTCARD_POOL_TAG 'bGCS'

// Include files for different system objects
#ifdef WDM_KERNEL
#include "syswdm.h"
#else
#ifdef	NT4_KERNEL
#include "sysnt4.h"
#else
#ifdef	WIN9X_KERNEL
#include "syswin9x.h"
#else
#include "syswdm.h"
#endif
#endif
#endif

#include <smclib.h>

#include "gemlog.h"

// Miscellaneous useful declarations
#ifndef arraysize
#define arraysize(p) (sizeof(p)/sizeof((p)[0]))
#endif


#ifndef CTL_CODE
	#pragma message("CTL_CODE undefined. Include winioctl.h or devioctl.h before this file")
#endif

#define IOCTL_GRCLASS_GETVER	CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef	VOID (*PDEFERRED_FUNCTION)(IN struct _KDPC *Dpc, IN PDEVICE_OBJECT  DeviceObject,IN PIRP Irp, IN PVOID SystemArgument2);
int __cdecl _purecall(VOID);

#define SAFE_DESTRUCTORS()\
	VOID self_delete(VOID){delete this;}

#ifdef __cplusplus
	#define GENERICAPI extern "C" 
#else
	#define GENERICAPI
#endif

#define GENERIC_EXPORT __declspec(dllexport) __stdcall
typedef VOID (__stdcall *PQNOTIFYFUNC)(PVOID);

BOOLEAN GENERIC_EXPORT isWin98();

#define DRIVERNAME "GRClass.sys"
#define NT_OBJECT_NAME   L"\\Device\\GRClass"

#if DEBUG
extern "C" VOID __cdecl _chkesp();
#endif

extern BOOLEAN SystemWin98;

// Power management constants
#define GUR_IDLE_CONSERVATION	60		// sleep after 60 seconds on battery power
#define GUR_IDLE_PERFORMANCE	600		// sleep after 10 minutes on AC power

EXTERN_C const GUID FAR GUID_CLASS_GRCLASS;
EXTERN_C const GUID FAR GUID_CLASS_SMARTCARD;

// Supported by driver different type of devices
#define GRCLASS_DEVICE		0
#define USB_DEVICE			1
#define USBREADER_DEVICE	2
#define BUS_DEVICE			3
#define CHILD_DEVICE		4

inline VOID _cdecl DBG_PRINT(PCH Format,...)
{
va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	SmartcardDebug (DEBUG_DRIVER,("GemPC430: "));
	SmartcardDebug (DEBUG_DRIVER, (strTempo));
};

inline VOID _cdecl DBG_PRINT_NO_PREFIX(PCH Format,...)
{
va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	SmartcardDebug (DEBUG_DRIVER, (strTempo));
};

 // already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\interface.h ===
//-------------------------------------------------------------------
// This is abstract class for Reader Interface
// Specific interfaces should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		11/09/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __READER_INTERFACE__
#define __READER_INTERFACE__

#include "generic.h"
#include "kernel.h"
#include "rdrconfig.h"


#define READER_INTERFACE_GEMCORE	1
#define READER_INTERFACE_OROS		2
#define READER_INTERFACE_USB		3
#define READER_INTERFACE_GPR		4

#define READER_MODE_NATIVE			1
#define READER_MODE_ROS				2
#define READER_MODE_TLP				3

#define INTERFACE_OUTPUT_BUFFER_SIZE	0x1000
#define INTERFACE_INPUT_BUFFER_SIZE	    0x1000

#define VERSION_STRING_MAX_LENGTH   16
class CProtocol;
class CDebug;
class CMemory;
class CIoPacket;
#pragma PAGEDCODE
class CReaderInterface
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	// Internal buffers to manage Xfers...
    ULONG  OutputBufferLength;
    PUCHAR pOutputBuffer;
    ULONG  InputBufferLength;
    PUCHAR pInputBuffer;

	CDebug*	 debug;
	CProtocol* protocol;
	CMemory* memory;

	BOOL     Initialized;
	UCHAR    Version[VERSION_STRING_MAX_LENGTH];
	ULONG    Mode;
protected:
	CReaderInterface();
	virtual ~CReaderInterface();
public:	

	CReaderInterface(CProtocol* protocol);

	virtual  ReaderConfig	getConfiguration() 
	{ReaderConfig c;
		c.Type = 0;
		c.PresenceDetection = 0;
		c.Vpp = 0;
		c.Voltage = 0;
		c.PTSMode = 0;
		c.PTS0 = 0;
		c.PTS1 = 0;
		c.PTS2 = 0;
		c.PTS3 = 0;
		c.ActiveProtocol = 0;
		c.PowerTimeOut = 0;
		return c;
	};
	virtual  NTSTATUS  setConfiguration(ReaderConfig configuration) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  getReaderVersion(PUCHAR pVersion, PULONG pLength) {return STATUS_SUCCESS;};
	virtual  ULONG     getReaderState()   {return 0;};
	virtual  NTSTATUS  setReaderMode(ULONG mode) {return STATUS_SUCCESS;};
	virtual  BOOL      isInitialized(){return Initialized;};
	virtual  NTSTATUS  initialize() {return STATUS_SUCCESS;};

		// Pure virtual functions will be implemented by specific interfaces (expl: CGemCore)...
	virtual  NTSTATUS  read(CIoPacket* Irp)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS  write(CIoPacket* Irp) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS  ioctl(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  SwitchSpeed(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  VendorAttribute(ULONG ControlCode,PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
    virtual  NTSTATUS  power(ULONG ControlCode,PUCHAR pReply,ULONG* pReplyLength, BOOLEAN Specific) {return STATUS_SUCCESS;};
	virtual  NTSTATUS  setProtocol(ULONG ProtocolRequested) {return STATUS_SUCCESS;};

	virtual  NTSTATUS translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};

	virtual  VOID	   cancel() {};
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\iopack.cpp ===
#include "iopack.h"
#include "kernel.h"

#pragma LOCKEDCODE
NTSTATUS onRequestComplete(PDEVICE_OBJECT pDO,IN PIRP Irp, IN PVOID context)
{
	//DBG_PRINT("		======= Request completion Irp %8.8lX, Packet %8.8lX\n",Irp,context);
	CIoPacket* packet = (CIoPacket*) context;
	if(packet)
	{
		return packet->onRequestComplete();
	}
	return STATUS_MORE_PROCESSING_REQUIRED;
}

#pragma PAGEDCODE
CIoPacket::CIoPacket(UCHAR StackSize)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	systemIrp = FALSE;
	m_DoNotFreeIrp = FALSE;
	CompletionEvent = NULL;
	IoStatus.Status = STATUS_SUCCESS;
	IoStatus.Information = 0;
	SystemBuffer = NULL;
	m_Irp = NULL;
	m_TimeOut = 60000;// Default timeout 60 seconds for any kind of IORequest

	__try
	{
		debug  = kernel->createDebug();
		memory = kernel->createMemory();
		event  = kernel->createEvent();
		irp    = kernel->createIrp();

		if(	!ALLOCATED_OK(memory) || !ALLOCATED_OK(event) ||
			!ALLOCATED_OK(irp)) __leave;

		SystemBuffer = memory->allocate(NonPagedPool,PAGE_SIZE);
		if(!SystemBuffer) __leave;
		m_Irp = irp->allocate(StackSize+1, FALSE);
		if (!m_Irp)		  __leave;
		irp->initialize(m_Irp,irp->sizeOfIrp(StackSize+1),StackSize+1);
		Stack = *(irp->getNextStackLocation(m_Irp));
		irp->setCompletionRoutine(m_Irp,CALLBACK_FUNCTION(onRequestComplete),NULL,TRUE,TRUE,TRUE);
		m_Status = STATUS_SUCCESS;
	}
	__finally
	{
		if(!NT_SUCCESS(m_Status))
		{
			// Remove all allocated objects...
			// In this constructor we know that it is not system Irp...
			TRACE("FAILED TO CREATE IoPacket object %x\n",m_Status);
			TRACE("SystemBuffer - %x\n",SystemBuffer);
			TRACE("debug - %x, memory - %x\n",debug,memory);
			TRACE("event - %x, irp - %x\n",event,irp);

			if(ALLOCATED_OK(memory))
			{
				if(SystemBuffer) memory->free(SystemBuffer);
				SystemBuffer = NULL;
			}

			if(ALLOCATED_OK(irp))
			{
				if(m_Irp) irp->free(m_Irp);
				m_Irp = NULL;
			}
			DISPOSE_OBJECT(irp);
			DISPOSE_OBJECT(event);
			DISPOSE_OBJECT(memory);
			DISPOSE_OBJECT(debug);
		}
	}
};

	
CIoPacket::CIoPacket(PIRP Irp)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	systemIrp = TRUE;
	m_DoNotFreeIrp = FALSE;
	CompletionEvent = NULL;
	IoStatus.Status = STATUS_SUCCESS;
	IoStatus.Information = 0;
	SystemBuffer = NULL;
	m_TimeOut = 60000;// Default timeout 60 seconds for any kind of IORequest
	m_Irp = NULL;

	__try
	{
		if(!Irp) __leave;

		debug  = kernel->createDebug();
		memory = kernel->createMemory();
		event  = kernel->createEvent();
		irp    = kernel->createIrp();

		if(	!ALLOCATED_OK(memory) || !ALLOCATED_OK(event) ||
			!ALLOCATED_OK(irp))		__leave;
		m_Irp = Irp;
		Stack = *(irp->getNextStackLocation(m_Irp));
		SystemBuffer = m_Irp->AssociatedIrp.SystemBuffer;
		// We do not care here if system buffers is NULL
		// but we will not copy data if it will be not initialized (NULL)
		m_Status = STATUS_SUCCESS;
	}
	__finally
	{
		if(!NT_SUCCESS(m_Status))
		{
			TRACE("FAILED TO CREATE IoPacket object %x\n",m_Status);
			TRACE("SystemBuffer - %x, Irp - %x\n",SystemBuffer,Irp);
			TRACE("debug - %x, memory - %x\n",debug,memory);
			TRACE("event - %x, irp - %x\n",event,irp);
			// Remove all allocated objects...
			DISPOSE_OBJECT(irp);
			DISPOSE_OBJECT(event);
			DISPOSE_OBJECT(memory);
			DISPOSE_OBJECT(debug);
		}
	}
};

CIoPacket::~CIoPacket()
{
	if(!systemIrp)
	{
		if(SystemBuffer) memory->free(SystemBuffer);
		SystemBuffer = NULL;
	}

	DISPOSE_OBJECT(irp);
	DISPOSE_OBJECT(event);
	DISPOSE_OBJECT(memory);
	DISPOSE_OBJECT(debug);
};

VOID CIoPacket::setMajorIOCtl(UCHAR controlCode)
{
	Stack.MajorFunction = controlCode;
};

UCHAR CIoPacket::getMajorIOCtl()
{				
	return Stack.MajorFunction;
};
	
VOID CIoPacket::setMinorIOCtl(UCHAR controlCode)
{
	Stack.MinorFunction = controlCode;
};

NTSTATUS    CIoPacket::buildStack(PDEVICE_OBJECT DeviceObject, ULONG Major, UCHAR Minor, ULONG IoCtl, PVOID Context)
{
	// Create copy of the next stack
	if(!m_Irp) return STATUS_INVALID_DEVICE_STATE;

	Stack = *(irp->getNextStackLocation(m_Irp));
	Stack.DeviceObject = DeviceObject;
	switch(Major)
	{
	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			// Set stack parameters...
			Stack.MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
			Stack.Parameters.Others.Argument1 = Context;
			Stack.Parameters.DeviceIoControl.IoControlCode = IoCtl;
		}
		break;
	case IRP_MJ_PNP:
		{
			// Set stack parameters...
			Stack.MajorFunction = IRP_MJ_PNP;
			Stack.MinorFunction = Minor;
			if(Minor==IRP_MN_QUERY_CAPABILITIES)
			{
				Stack.Parameters.DeviceCapabilities.Capabilities = (PDEVICE_CAPABILITIES) Context;
			}
		}
		break;
	default:
		// Copy current stack location to next...
		if(systemIrp)	Stack = *(irp->getCurrentStackLocation(m_Irp));
		else
		{
			Stack.DeviceObject = DeviceObject;
			Stack.MajorFunction = (UCHAR)Major;
			Stack.MinorFunction = Minor;
		}
	}
	return STATUS_SUCCESS;
};

VOID  CIoPacket::copyStackToNext()
{
PIO_STACK_LOCATION	nextStack;
	if(!m_Irp) return;

	nextStack = irp->getNextStackLocation(m_Irp);
	if(nextStack)	*nextStack = Stack;
};

VOID  CIoPacket::copyCurrentStackToNext()
{
	if(!m_Irp) return;
	irp->copyCurrentStackLocationToNext(m_Irp);
}

// Function will set completion routine for the Irp.
VOID   CIoPacket::setCompletion(PIO_COMPLETION_ROUTINE CompletionFunction)
{
PIO_COMPLETION_ROUTINE Completion;
	if(!m_Irp) return;
	Completion = CompletionFunction==NULL ? CALLBACK_FUNCTION(onRequestComplete) : CompletionFunction;
	if(m_Irp) irp->setCompletionRoutine(m_Irp,Completion,this,TRUE,TRUE,TRUE);
};

VOID   CIoPacket::setDefaultCompletionFunction()
{
	if(m_Irp) irp->setCompletionRoutine(m_Irp,CALLBACK_FUNCTION(onRequestComplete),this,TRUE,TRUE,TRUE);
};

NTSTATUS CIoPacket::copyBuffer(PUCHAR pBuffer, ULONG BufferLength)
{
	if(!pBuffer || !BufferLength || BufferLength>PAGE_SIZE)  return STATUS_INVALID_PARAMETER;
	if(m_Irp)
	{
		if(!systemIrp)
		{
			if(!m_Irp->AssociatedIrp.SystemBuffer)
			{
				if(!SystemBuffer)
				{
					SystemBuffer = memory->allocate(NonPagedPool,PAGE_SIZE);
					if(!SystemBuffer)  return STATUS_INSUFFICIENT_RESOURCES;
				}
				m_Irp->AssociatedIrp.SystemBuffer = SystemBuffer;
			}
		}

		if(m_Irp->AssociatedIrp.SystemBuffer)
			memory->copy(m_Irp->AssociatedIrp.SystemBuffer,pBuffer,BufferLength);
		else
		{
			TRACE("	***** AssociatedIrp SYSTEM BUFFER IS NULL!\nFailed to copy bus driver reply with len %x!\n",BufferLength);
		}
		return STATUS_SUCCESS;
	}
	else return STATUS_INSUFFICIENT_RESOURCES;
};

PIO_STACK_LOCATION CIoPacket::getStack()
{
	return &Stack;
};

PVOID CIoPacket::getBuffer()
{
	return SystemBuffer;
};

ULONG CIoPacket::getReadLength()
{
	return Stack.Parameters.Read.Length;
};

VOID CIoPacket::setWriteLength(ULONG length)
{
	Stack.Parameters.Write.Length = length;
};

VOID CIoPacket::setReadLength(ULONG length)
{
	Stack.Parameters.Read.Length = length;
};

ULONG CIoPacket::getWriteLength()
{
	return Stack.Parameters.Write.Length;
};

VOID CIoPacket::setInformation(ULONG_PTR information)
{
	if(m_Irp)	m_Irp->IoStatus.Information = information;
	IoStatus.Information		= information;
};

ULONG_PTR CIoPacket::getInformation()
{
	return IoStatus.Information;
};

VOID    CIoPacket::updateInformation()
{
	if(m_Irp)	IoStatus.Information = m_Irp->IoStatus.Information;
};

NTSTATUS CIoPacket::getSystemReply(PUCHAR pReply,ULONG Length)
{
	if(!pReply || !Length || Length> PAGE_SIZE)  return STATUS_INVALID_PARAMETER;
	if(SystemBuffer)
	{
		memory->copy(pReply,SystemBuffer,Length);
		return STATUS_SUCCESS;
	}
	else return STATUS_INSUFFICIENT_RESOURCES;
};

#pragma LOCKEDCODE
NTSTATUS	CIoPacket::onRequestComplete()
{ // Callback to finish previously sended request
	TRACE("		=======> IoPacket processes Completion()\n");
	if(systemIrp)
	{
		if (m_Irp->PendingReturned)
		{
			TRACE("		Irp marked as pending...\n");
			irp->markPending(m_Irp);
		}
	}

	IoStatus.Status = m_Irp->IoStatus.Status;
	IoStatus.Information = m_Irp->IoStatus.Information;
	TRACE("		Irp completes with status %8.8lX , info %8.8lX\n",IoStatus.Status,IoStatus.Information);
	if(!systemIrp)
	{
		if(!m_DoNotFreeIrp)
		{
			PIRP  Irp = m_Irp;
			m_Irp = NULL;
			if(Irp) irp->free(Irp);
		}
	}
	if(CompletionEvent)	event->set(CompletionEvent,IO_NO_INCREMENT,FALSE);
	return STATUS_MORE_PROCESSING_REQUIRED;
};

#pragma PAGEDCODE
VOID CIoPacket::setCompletionEvent(PKEVENT CompletionEvent)
{
	if(CompletionEvent)
	{
		this->CompletionEvent = CompletionEvent;
	}
}

VOID CIoPacket::setStatus(NTSTATUS status)
{
	IoStatus.Status = status;
}

NTSTATUS CIoPacket::getStatus()
{
	return IoStatus.Status;
}

VOID  CIoPacket::setDefaultCompletionEvent()
{
	event->initialize(&DefaultCompletionEvent,NotificationEvent, FALSE);	
	setCompletionEvent(&DefaultCompletionEvent);
}

NTSTATUS  CIoPacket::waitForCompletion()
{	// Set current timeout
	return waitForCompletion(getTimeout());
}

NTSTATUS  CIoPacket::waitForCompletion(LONG TimeOut)
{
	// Because we set Alertable parameter to FALSE,
	// there are only two possible statuses from the function STATUS_SUCCESS and
	// STATUS_TIMEOUT...

	// We should not try to cancel system Irps!
	if(systemIrp)
	{
	NTSTATUS status;
		status = event->waitForSingleObject(CompletionEvent, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status))
		{	
			TRACE("waitForCompletion() reports error %x\n", status);
			setStatus(STATUS_IO_TIMEOUT);
			setInformation(0);
		}			
		status = getStatus();
		return status;
	}
	else
	{
	LARGE_INTEGER timeout;
    timeout.QuadPart = -TimeOut * 10000;
  		if (event->waitForSingleObject(CompletionEvent, Executive, KernelMode, FALSE, &timeout) == STATUS_TIMEOUT)
		{
		KIRQL oldIrql;
			// Ok! We've got timeout..
			// Completion function still can be called.
			 // First tell completion not to free our Irp
			IoAcquireCancelSpinLock(&oldIrql);
				if(m_Irp) m_DoNotFreeIrp = TRUE;
			IoReleaseCancelSpinLock(oldIrql);
			
			DEBUG_START();
			TRACE("######## waitForCompletion() reports TIMEOUT after %d msec ############\n",getTimeout());
			if(m_Irp)
			{
				irp->cancel(m_Irp);  //  okay in this context
				// Wait for the cancel callback to be called
				event->waitForSingleObject(CompletionEvent, Executive, KernelMode, FALSE, NULL);
				TRACE("######## Current Irp cancelled!!! ############\n");
				// Now we can safely free our Irp
				if(m_DoNotFreeIrp)
				{
					if(m_Irp) irp->free(m_Irp);
					m_Irp = NULL;
					m_DoNotFreeIrp = FALSE;
				}
				// Report Irp timeout
				setStatus(STATUS_IO_TIMEOUT);
				setInformation(0);
			}
		}
		return getStatus();
	}
}

VOID  CIoPacket::setStackDefaults()
{
	setDefaultCompletionEvent();
	copyStackToNext();
	setDefaultCompletionFunction();
}

// Normally IoPacket will be created on the next stack location.
// The function allows to take current stack location.
// It is useful if we want to forward system IRP down the stack.
VOID  CIoPacket::setCurrentStack()
{
	if(m_Irp) Stack = *(irp->getCurrentStackLocation(m_Irp));
}


VOID	CIoPacket::setTimeout(LONG TimeOut)
{
	m_TimeOut = TimeOut;
};

ULONG	CIoPacket::getTimeout()
{
	return m_TimeOut;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\lock.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef LOCK_INT
#define LOCK_INT
#include "generic.h"

#pragma PAGEDCODE
class CLock
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CLock(){};
	virtual ~CLock(){};
public:

	virtual VOID	initializeSpinLock(PKSPIN_LOCK SpinLock) {};
	virtual VOID	acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql) {};
	virtual VOID	releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql)  {};
	virtual VOID	acquireCancelSpinLock(PKIRQL Irql)	{};
	virtual VOID	releaseCancelSpinLock(KIRQL Irql)	{};
	virtual LONG	interlockedIncrement(IN PLONG  Addend) {return 0;};
	virtual LONG	interlockedDecrement(IN PLONG  Addend) {return 0;};
};	

#endif//CLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\irp.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef IRP_INT
#define IRP_INT
#include "generic.h"

#pragma PAGEDCODE
class CIrp;
// Interface to general system services...
class CIrp
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CIrp(){};
	virtual ~CIrp(){};
public:

	virtual PIRP		allocate(CCHAR StackSize,BOOLEAN ChargeQuota) {return NULL;};
	virtual	VOID		initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize) {};
	virtual	USHORT		sizeOfIrp(IN CCHAR StackSize) =0;


	virtual VOID		free(PIRP Irp) {};
	virtual PIRP		buildDeviceIoControlRequest(
						   IN ULONG IoControlCode,
						   IN PDEVICE_OBJECT DeviceObject,
						   IN PVOID InputBuffer OPTIONAL,
						   IN ULONG InputBufferLength,
						   IN OUT PVOID OutputBuffer OPTIONAL,
						   IN ULONG OutputBufferLength,
						   IN BOOLEAN InternalDeviceIoControl,
						   IN PKEVENT Event,
						   OUT PIO_STATUS_BLOCK IoStatusBlock
						   ) {return NULL;};

	virtual PIRP		buildSynchronousFsdRequest(
							IN ULONG MajorFunction,
							IN PDEVICE_OBJECT DeviceObject,
							IN OUT PVOID Buffer OPTIONAL,
							IN ULONG Length OPTIONAL,
							IN PLARGE_INTEGER StartingOffset OPTIONAL,
							IN PKEVENT Event,
							OUT PIO_STATUS_BLOCK IoStatusBlock
							){return NULL;};


	virtual PIO_STACK_LOCATION	getCurrentStackLocation(PIRP Irp) {return NULL;};
	virtual PIO_STACK_LOCATION	getNextStackLocation(PIRP Irp) {return NULL;};
	virtual VOID		skipCurrentStackLocation(PIRP Irp) {};
	virtual VOID		setNextStackLocation(IN PIRP Irp) {};
	virtual VOID		markPending(PIRP Irp) {};
	virtual VOID		copyCurrentStackLocationToNext(PIRP Irp) {};
	virtual VOID		setCompletionRoutine(PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
					PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel ) {};
	virtual PDRIVER_CANCEL	setCancelRoutine(PIRP Irp, PDRIVER_CANCEL NewCancelRoutine ) {return NULL;};
	virtual VOID		completeRequest(PIRP Irp,CCHAR PriorityBoost) {};
	virtual VOID		startPacket(PDEVICE_OBJECT DeviceObject,PIRP Irp,PULONG Key,PDRIVER_CANCEL CancelFunction) {};
	virtual VOID		startNextPacket(PDEVICE_OBJECT DeviceObject,BOOLEAN Cancelable) {};

	virtual VOID		cancel(PIRP Irp) {};
	// Should it go to interrupt??
	virtual VOID		requestDpc(PDEVICE_OBJECT DeviceObject,PIRP Irp,PVOID Context) {};
};	

#endif//IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\logger.h ===
#ifndef __LOG__
#define __LOG__
#include "generic.h"

#pragma PAGEDCODE
class CLogger
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
	LONG usage;
public:
	CLogger(){};
	virtual ~CLogger(){};
	virtual VOID logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo) {};
	LONG		incrementUsage(){return ++usage;};
	LONG		decrementUsage(){return --usage;};
};

// Message definition file for EventLog driver
// Copyright (C) 1999 by Walter Oney
// All rights reserved
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_EVENTLOG_ERROR_CODE     0x2A


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENTLOG_MSG_TEST
//
// MessageText:
//
//  %2 said, "Hello, world!"
//
#define EVENTLOG_MSG_TEST                ((NTSTATUS)0x602A0001L)


#endif//LOGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\iopack.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __IO_PACKET__
#define __IO_PACKET__
#include "generic.h"

// This class will manage creation and 
// manipulation of driver IRPs
class CIrp;
class CMemory;
class CEvent;
class CDebug;

#pragma LOCKEDCODE
NTSTATUS onRequestComplete(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context);

#pragma PAGEDCODE
class CIoPacket;

class CIoPacket
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
IO_STACK_LOCATION Stack;
					   //Cancel;
	PIRP  m_Irp;
	UCHAR StackSize;
	CIrp* irp;
	CMemory* memory;
	CEvent*  event;
	CDebug*  debug;

	BOOL  systemIrp;
	BOOL  m_DoNotFreeIrp;
	// Event to signal xfer completion
	KEVENT	DefaultCompletionEvent;
	PKEVENT	CompletionEvent;

	IO_STATUS_BLOCK IoStatus;
	PVOID	SystemBuffer;
	LONG   m_TimeOut;
protected:
	CIoPacket(){};
	virtual ~CIoPacket();
public:
	CIoPacket(UCHAR StackSize);
	CIoPacket(PIRP Irp);

	virtual PIRP getIrpHandle(){return m_Irp;};

	virtual VOID setMajorIOCtl(UCHAR controlCode);
	virtual UCHAR getMajorIOCtl();

	virtual VOID setMinorIOCtl(UCHAR controlCode);
	virtual NTSTATUS    buildStack(PDEVICE_OBJECT DeviceObject, ULONG Major=IRP_MJ_INTERNAL_DEVICE_CONTROL, UCHAR Minor=0, ULONG IoCtl=0, PVOID Context=NULL);
	virtual PIO_STACK_LOCATION getStack();

	virtual VOID copyStackToNext();
	virtual VOID copyCurrentStackToNext();

	virtual VOID setCompletion(PIO_COMPLETION_ROUTINE CompletionFunction=NULL);
	virtual VOID setDefaultCompletionFunction();
	virtual NTSTATUS  waitForCompletion();
	virtual NTSTATUS  waitForCompletion(LONG TimeOut);

	virtual VOID setDefaultCompletionEvent();
	virtual VOID setCompletionEvent(PKEVENT CompletionEvent);
	virtual VOID setStackDefaults();
	virtual VOID setCurrentStack();

	virtual NTSTATUS  onRequestComplete();


	virtual NTSTATUS copyBuffer(PUCHAR pBuffer, ULONG BufferLength);
	virtual PVOID	getBuffer();

	virtual ULONG	getReadLength();
	virtual VOID	setReadLength(ULONG length);

	virtual ULONG	getWriteLength();
	virtual VOID	setWriteLength(ULONG length);

	virtual VOID    setInformation(ULONG_PTR information);
	virtual ULONG_PTR   getInformation();
	virtual VOID    updateInformation();

	virtual NTSTATUS getSystemReply(PUCHAR pReply,ULONG Length);
	
	virtual VOID	setStatus(NTSTATUS status);
	virtual NTSTATUS getStatus();

	virtual VOID	setTimeout(LONG TimeOut);
	virtual ULONG	getTimeout();
};

#endif//IRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\kernel.h ===
//-------------------------------------------------------------------
// This is main object
// It starts all life of the system.
// Author: Sergey Ivanov
// Log:
//		06/08/99	-	implemented	
//-------------------------------------------------------------------

/**********************************************************/
#ifndef __KERNEL__
#define __KERNEL__

// System includes
#include "generic.h"

// Objects supported by the kernel
// Client side
#include "device.h"
#include "system.h"
#include "memory.h"
#include "irp.h"
#include "event.h"
#include "semaphore.h"
#include "int.h"
#include "power.h"
#include "debug.h"
#include "logger.h"
#include "lock.h"
#include "reader.h"
#include "interface.h"
#include "protocol.h"
#include "smartcard.h"
#include "rdrconfig.h"
#include "iopack.h"
#include "timer.h"

/**********************************************************/
#pragma LOCKEDCODE
class CGBus;
class CChild;
class CUSBDevice;
class CUSBReader;
class CKernel;
class CDevice;
class CReaderInterface;

/*
 There is only one instance of the class CKernel
*/
class CKernel
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
public:
	~CKernel(VOID){};

	// Return the kernel object.
	static CKernel* loadWDMKernel(VOID);
	static CKernel* loadNT4Kernel(VOID);
	static CKernel* loadWin9xKernel(VOID);
	LONG			getSystemType(VOID){return systemtype;};
	CDebug*		getDebug(VOID){return debug;};
	CLogger*	getLogger(VOID){return logger;};

#ifdef	USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

	// This is kernel system objects factory
#ifdef	USBDEVICE_PROJECT
	static CUSBDevice*	createUSBDevice(VOID);
#endif
#ifdef	USBREADER_PROJECT
	static CUSBReader*	createUSBReader(VOID);
#endif
#ifdef	BUS_PROJECT
	static CDevice*		createBus(VOID);
	static CDevice*		createChild(CGBus*  parent,LONG instanceID);
	static CDevice*		createChild(CGBus*  parent,IN PUNICODE_STRING DeviceName,LONG instanceID);
#endif
	// Objects driver can create
	static CSystem*		createSystem(VOID);	
	static CMemory*		createMemory(VOID); 
	static CIrp*		createIrp(VOID);
	static CEvent*		createEvent(VOID);
	static CSemaphore*	createSemaphore(VOID);
	static CInterrupt*	createInterrupt(VOID);
	static CPower*		createPower(VOID);
	static CLock*		createLock(VOID);
	static CDebug*		createDebug(VOID);
	static CTimer*		createTimer(TIMER_TYPE Type);
	// Creates interface to comminicate with reader...
	static CReaderInterface* createReaderInterface(LONG interfaceType,LONG protocolType,CDevice* device);
	static CLogger*		createLogger(VOID);
	
	// Device registration function
	// Register device at driver
	static VOID registerObject(PDEVICE_OBJECT fdo,CDevice* dev);
	static VOID unregisterObject(PDEVICE_OBJECT fdo);
	static CDevice* getRegisteredDevice(PDEVICE_OBJECT fdo);
public:
	CUString* RegistryPath;
	// Linked list of device objects
	static CLinkedList<CDevice>	   *DeviceLinkHead;

private:
	static LONG	systemtype; 
	static LONG	refcount;
	static CDebug*		debug;
	static CLogger*		logger;
private:
	CKernel(){};
};

typedef enum _SYSTEM_TYPE_ 
{
    WDM_SYSTEM = 1,
    NT4_SYSTEM,
    WIN9X_SYSTEM
} SYSTEM_TYPE;


#define CALLBACK_FUNCTION(f) ::f

#define DECLARE_CALLBACK_VOID0(f)	VOID f(PDEVICE_OBJECT pDO)
#define DECLARE_CALLBACK_BOOL0(f)	BOOL f(PDEVICE_OBJECT pDO)
#define DECLARE_CALLBACK_LONG0(f)	NTSTATUS f(PDEVICE_OBJECT pDO)
// functions which take two argument
#define DECLARE_CALLBACK_VOID1(f,type)	VOID f(PDEVICE_OBJECT pDO,type arg)
#define DECLARE_CALLBACK_LONG1(f,type)	NTSTATUS f(PDEVICE_OBJECT pDO,type arg)
// functions which can take three argument
#define DECLARE_CALLBACK_LONG2(f,type1,type2)	NTSTATUS f(PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)

//C wrapper for the DPC function
#define DECLARE_CALLBACK_DPCR(fname,type1,type2)	VOID fname(PKDPC Dpc, PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)
#define DECLARE_CALLBACK_ISR(fname)		BOOL fname(struct _KINTERRUPT *Interrupt,PDEVICE_OBJECT pDO)


// This will be used to create callback functions
//#define CDEVICE(pDo)	((CDevice*)pDo->DeviceExtension)
inline CDevice* getObjectPointer(PDEVICE_OBJECT pDo)
{
	//DBG_PRINT("Object %8.8lX was called\n",pDo);
	if(!pDo || !pDo->DeviceExtension)
	{
		DBG_PRINT("\n****** ERROR! Device %8.8lX ????, CDevice %8.8lX>>> ",pDo,pDo->DeviceExtension);
		return NULL; // Object was removed...
	}

	ULONG type = ((CDevice*)pDo->DeviceExtension)->m_Type;
	switch(type)
	{
	case USB_DEVICE:
		{
			//DBG_PRINT("\nUSB_DEVICE %8.8lX >>> ",(CDevice*)((CUSBDevice*)pDo->DeviceExtension));
			return ((CDevice*)((CUSBDevice*)pDo->DeviceExtension)); break;
		}
	case USBREADER_DEVICE:
		{
			//DBG_PRINT("\nUSBREADER_DEVICE %8.8lX >>> ",(CDevice*)((CUSBReader*)pDo->DeviceExtension));
			return ((CDevice*)((CUSBReader*)pDo->DeviceExtension)); break;
		}
	default:
		DBG_PRINT("\n****** ERROR! Device %8.8lX ????, CDevice %8.8lX>>> ",pDo,pDo->DeviceExtension);
		return ((CDevice*)pDo->DeviceExtension);
	}
};
#define CDEVICE(pDo)  getObjectPointer(pDo)
// functions which take one argument -> device object
#define IMPLEMENT_CALLBACK_VOID0(f)	\
			VOID f(PDEVICE_OBJECT pDO)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->f();}
#define IMPLEMENT_CALLBACK_BOOL0(f)	\
			BOOL f(PDEVICE_OBJECT pDO) \
				{if(!CDEVICE(pDO)) return FALSE; return CDEVICE(pDO)->f();}
#define IMPLEMENT_CALLBACK_LONG0(f)	\
			NTSTATUS f(PDEVICE_OBJECT pDO) \
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f();}
// functions which take two argument
#define IMPLEMENT_CALLBACK_VOID1(f,type)\
		VOID f(PDEVICE_OBJECT pDO,type arg)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->f(arg);}
#define IMPLEMENT_CALLBACK_LONG1(f,type)	\
		NTSTATUS f(PDEVICE_OBJECT pDO,type arg)\
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f(arg);}
// functions which can take three argument
#define IMPLEMENT_CALLBACK_LONG2(f,type1,type2)\
		NTSTATUS f(PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)\
				{if(!CDEVICE(pDO)) return STATUS_INVALID_HANDLE; return CDEVICE(pDO)->f(arg1, arg2);}

//C wrapper for the DPC function
#define IMPLEMENT_CALLBACK_DPCR(fname,type1,type2)	\
			VOID fname(PKDPC Dpc, PDEVICE_OBJECT pDO,type1 arg1, type2 arg2)\
				{if(CDEVICE(pDO)) CDEVICE(pDO)->DpcForIsr(Dpc, arg1,arg2);}

#define IMPLEMENT_CALLBACK_ISR(fname)	\
			BOOL fname(struct _KINTERRUPT *Interrupt,PDEVICE_OBJECT pDO)\
				{if(CDEVICE(pDO)) return CDEVICE(pDO)->fname();}


//A global reference to the one and only kernel object
extern CKernel*	kernel;

// System side
// WDM system
#ifdef WDM_KERNEL
#include "wdmsys.h"
#include "wdmmem.h"
#include "wdmirp.h"
#include "wdmevent.h"
#include "wdmsem.h"
#include "wdmint.h"
#include "wdmlock.h"
#include "wdmpower.h"
#include "wdmdebug.h"
#include "wdmlog.h"
#include "wdmtimer.h"
//#include "wdmdev.h"

#endif

// Specific supported devices
//#include "usbdev.h"

#pragma LOCKEDCODE
// Declare used device callbacks...
#ifndef _DEVICE_CALLBACKS_
#define _DEVICE_CALLBACKS_
DECLARE_CALLBACK_LONG1(open,IN PIRP);
DECLARE_CALLBACK_LONG1(close,IN PIRP);

DECLARE_CALLBACK_LONG1(read,IN PIRP);
DECLARE_CALLBACK_LONG1(write,IN PIRP);
DECLARE_CALLBACK_VOID1(startIo,IN PIRP);

DECLARE_CALLBACK_LONG1(deviceControl,IN PIRP);


DECLARE_CALLBACK_LONG1(flush,IN PIRP);
DECLARE_CALLBACK_LONG1(cleanup,IN PIRP);

DECLARE_CALLBACK_LONG1(powerRequest,IN PIRP);

NTSTATUS pnpRequest(IN PDEVICE_OBJECT fdo,IN PIRP Irp);

DECLARE_CALLBACK_VOID1(cancelPendingIrp,IN PIRP);

VOID onSendDeviceSetPowerComplete(PDEVICE_OBJECT junk, UCHAR fcn, POWER_STATE state, PPOWER_CONTEXT context, PIO_STATUS_BLOCK pstatus);

#endif

#endif//KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\kernel.cpp ===
#include "kernel.h"
#include "usbdev.h"
#include "usbreader.h"
#include "lvprot.h"
#include "gemcore.h"

//$(WINICE)\nmsym.exe /translate:source,package,always  obj\checked\grclass.sys
#pragma LOCKEDCODE

//The global visible instance of the kernel and system object
CKernel* kernel = NULL;

// Some static kernel variable required initialization
LONG	CKernel::systemtype = 0; 
LONG	CKernel::refcount = 0;
CDebug*		CKernel::debug  = NULL;
CLogger*	CKernel::logger = NULL;
//CLinkedList<CUSBDevice> * CKernel::USBDeviceLinkHead = NULL;
//CLinkedList<CUSBReader> * CKernel::DeviceLinkHead = NULL;
//CLinkedList<CGBus> * CKernel::BusesLinkHead = NULL;

CLinkedList<CDevice> * CKernel::DeviceLinkHead = NULL;
// Instance number for the driver devices
ULONG CDevice::DeviceNumber = 0;

CKernel* CKernel::loadWDMKernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
		systemtype = WDM_SYSTEM;
		refcount++;
       CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;
		if (!ALLOCATED_OK(CKernel::DeviceLinkHead))
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
} 

CKernel* CKernel::loadNT4Kernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))	
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		systemtype = NT4_SYSTEM;
		refcount++;
        CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;
		if (!CKernel::DeviceLinkHead)
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		
		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
}

CKernel* CKernel::loadWin9xKernel(VOID)
{
	if( kernel == NULL )
	{
		kernel = new (NonPagedPool) CKernel;
		if (!ALLOCATED_OK(kernel))
		{
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		systemtype = WIN9X_SYSTEM;
		refcount++;
        CKernel::DeviceLinkHead = new (NonPagedPool) CLinkedList<CDevice>;

		if (!CKernel::DeviceLinkHead)
		{
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		debug = createDebug();
		if(!ALLOCATED_OK(debug))
		{
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}

		logger = createLogger();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			DISPOSE_OBJECT(debug);
			DISPOSE_OBJECT(CKernel::DeviceLinkHead);
			DISPOSE_OBJECT(kernel);
			return NULL;
		}
	}
	return kernel;
}



VOID CKernel::dispose(VOID)
{	
	refcount--;
	if(refcount<=0)
	{
		TRACE("Unload: Removing all registered devices...\n");

		delete DeviceLinkHead;    // this will kill all attached devices

		if(kernel->RegistryPath)
		{
			kernel->RegistryPath->dispose();
		}

		if(debug)  debug->dispose();
		if(logger) logger->dispose();
		self_delete();
		kernel = NULL; 
	}
}

CSystem*    CKernel::createSystem(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CSystem* obj = CWDMSystem::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CMemory*    CKernel::createMemory(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CMemory* obj = CWDMMemory::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CIrp*		CKernel::createIrp(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CIrp* obj = CWDMIrp::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CEvent*		CKernel::createEvent(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CEvent* obj = CWDMEvent::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CSemaphore*		CKernel::createSemaphore(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CSemaphore* obj = CWDMSemaphore::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CInterrupt* CKernel::createInterrupt(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CInterrupt* obj = CWDMInterrupt::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CLock*  CKernel::createLock(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CLock* obj = CWDMLock::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}


CPower*		CKernel::createPower(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CPower* obj = CWDMPower::create();
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CDebug*		CKernel::createDebug(VOID)
{
	// Only one debug module exist at system
	// It will be shared between all objects
	if(debug)
	{
		debug->incrementUsage();
		//TRACE("				Debug object reused %d times\n",);
		return debug;
	}
	if(systemtype==WDM_SYSTEM)
	{
		CDebug* d = CWDMDebug::create();
		if(!ALLOCATED_OK(d))
		{
			DISPOSE_OBJECT(d);
			return NULL;
		}

		d->incrementUsage();
		return d;
	}
	return NULL;
}


VOID CKernel::registerObject(PDEVICE_OBJECT fdo,CDevice* device)
{

	fdo->DeviceExtension = device;
	if(!ALLOCATED_OK(device)) return;
	if(device->m_Type!=CHILD_DEVICE)
	{
		if(DeviceLinkHead)	DeviceLinkHead->New(device);
	}
}

VOID CKernel::unregisterObject(PDEVICE_OBJECT fdo)
{
CDevice* device;
	device = ((CDevice*)fdo->DeviceExtension);
	fdo->DeviceExtension = NULL;
	if(!ALLOCATED_OK(device)) return;
	if(device->m_Type!=CHILD_DEVICE) DeviceLinkHead->remove(device);
}

CDevice* CKernel::getRegisteredDevice(PDEVICE_OBJECT fdo)
{
	return getObjectPointer(fdo);
}

CReaderInterface* CKernel::createReaderInterface(LONG interfaceType,LONG protocolType,CDevice* device)
{
CProtocol* protocol = NULL;
//CReaderInterface* interface = NULL;
CGemCore* interface = NULL;// TOBE CHANGED
	switch(protocolType)
	{
	case READER_PROTOCOL_LV:
	default:
		protocol = new (NonPagedPool) CLVProtocol(device);// TO CHANGE LATER...
		break;
	}
	if(!ALLOCATED_OK(protocol))
	{
		DISPOSE_OBJECT(protocol);
		return NULL;
	}

	switch(interfaceType)
	{
	case READER_INTERFACE_GEMCORE:
	default:
		interface = new (NonPagedPool) CGemCore(protocol);
		break;
	}
	if(!ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(interface);
		DISPOSE_OBJECT(protocol);
		return NULL;
	}
	return interface;
};

CTimer*		CKernel::createTimer(TIMER_TYPE Type)
{
	if(systemtype==WDM_SYSTEM)
	{
		CTimer* obj = CWDMTimer::create(Type);
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}

CLogger*	CKernel::createLogger()
{
	if(logger)
	{
		logger->incrementUsage();
		return logger;
	}
	if(systemtype==WDM_SYSTEM)
	{
		logger = CWDMLogger::create();
		if(!ALLOCATED_OK(logger))
		{
			DISPOSE_OBJECT(logger);
			return NULL;
		}
		logger->incrementUsage();
		return logger;
	}
	return NULL;
}

#ifdef	USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

#ifdef USBDEVICE_PROJECT
CUSBDevice*    CKernel::createUSBDevice(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CUSBDevice* obj =  new (NonPagedPool) CUSBDevice;
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}
#endif

#ifdef	USBREADER_PROJECT
CUSBReader*	CKernel::createUSBReader(VOID)
{
	if(systemtype==WDM_SYSTEM)
	{
		CUSBReader* obj = new (NonPagedPool) CUSBReader;
		RETURN_VERIFIED_OBJECT(obj);
	}
	return NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\lvprot.h ===
//-------------------------------------------------------------------
// This is the class for the length-value protocol
// Author: Sergey Ivanov
// Log:
//		11/10/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __LV_PROTOCOL__
#define __LV_PROTOCOL__

#include "protocol.h"

#pragma PAGEDCODE
class CDevice;

class CLVProtocol : public CProtocol
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
protected:
	CLVProtocol(){};
public:	
	CLVProtocol(CDevice* device) : CProtocol(device)
	{
		TRACE("\nLength-Value protocol was created...\n");
		m_Status = STATUS_SUCCESS;
	};

	virtual ~CLVProtocol()
	{ 
		TRACE("Length-Value protocol %8.8lX was destroied...\n",this);
	};

	virtual VOID dispose()
	{
		self_delete();
	};

	virtual  VOID  set_WTR_Delay(LONG Delay);
	virtual  ULONG get_WTR_Delay();
	virtual  VOID  set_Default_WTR_Delay();
	virtual  LONG  get_Power_WTR_Delay();
	virtual  ULONG getCardState(); 

	virtual  NTSTATUS writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
	virtual  NTSTATUS readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\power.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef PWR_INT
#define PWR_INT
#include "generic.h"

#pragma PAGEDCODE
class CPower
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CPower(){};
	virtual ~CPower(){};
public:

	virtual PULONG		registerDeviceForIdleDetection (
							IN PDEVICE_OBJECT     DeviceObject,
							IN ULONG              ConservationIdleTime,
							IN ULONG              PerformanceIdleTime,
							IN DEVICE_POWER_STATE State
							) {return NULL;};

	virtual POWER_STATE	declarePowerState(IN PDEVICE_OBJECT   DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State) 
	{POWER_STATE p; 
		p.SystemState = PowerSystemShutdown;
		p.DeviceState = PowerDeviceUnspecified;
		return p;
	};

	virtual VOID		startNextPowerIrp(IN PIRP Irp) {};
	
	virtual NTSTATUS	callPowerDriver (IN PDEVICE_OBJECT DeviceObject,IN OUT PIRP Irp) {return STATUS_SUCCESS;};
	virtual VOID		setPowerDeviceBusy(PULONG	IdlePointer) {};
	virtual NTSTATUS	requestPowerIrp(IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL) {return STATUS_SUCCESS;};
};	

#endif//POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\protocol.cpp ===
#include "protocol.h"
#include "kernel.h"

#pragma PAGEDCODE
CProtocol::CProtocol()
{ 
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	device = NULL;
	memory = NULL;
	debug  = NULL;
	m_Status = STATUS_SUCCESS;
};

CProtocol::CProtocol(CDevice* device)
{
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	this->device = device;
	memory = kernel->createMemory();

	debug	= kernel->createDebug();
	if(ALLOCATED_OK(memory))
	{
		pOutputBuffer = (PUCHAR) memory->allocate(NonPagedPool,PROTOCOL_OUTPUT_BUFFER_SIZE);
		pInputBuffer  = (PUCHAR) memory->allocate(NonPagedPool,PROTOCOL_INPUT_BUFFER_SIZE);
		if(pOutputBuffer && pInputBuffer)
		{
			OutputBufferLength	= PROTOCOL_OUTPUT_BUFFER_SIZE;
			InputBufferLength	= PROTOCOL_INPUT_BUFFER_SIZE;
		}
		else
		{
			if(pOutputBuffer) memory->free(pOutputBuffer);
			if(pInputBuffer)  memory->free(pInputBuffer);
			pOutputBuffer	  = NULL;
			pInputBuffer	  = NULL;
		}
	}
	TRACE("New Protocol %8.8lX was created...\n",this);
	if(ALLOCATED_OK(memory) && device)	m_Status = STATUS_SUCCESS;
};

CProtocol::~CProtocol()
{ 
	if(pOutputBuffer) memory->free(pOutputBuffer);
	if(pInputBuffer)  memory->free(pInputBuffer);
	if(memory) memory->dispose();
	if(debug)  debug->dispose();
	TRACE("Protocol %8.8lX was destroied...\n",this);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\memory.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef MEM_INT
#define MEM_INT
#include "generic.h"

#pragma PAGEDCODE
class CMemory
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CMemory(){};
	virtual ~CMemory(){};
public:

	virtual PVOID		allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes) {return NULL;};
	virtual VOID		zero(IN PVOID pMem,IN SIZE_T size) {};
	virtual VOID		free(IN PVOID pMem) {};
	virtual VOID		copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length) {};

	virtual PVOID		mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType) {return NULL;};
	virtual VOID		unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes) {};
	virtual VOID		set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill) {};

};	

#endif//MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\message.h ===
//-------------------------------------------------------------------
// Message class
// It declare interface to send messages to the objects
// If 
// Author: Sergey Ivanov
// Log:
//		06/08/99	-	implemented	
//-------------------------------------------------------------------
// Message class
//
template class<CMessageData Md>
class CMessage 
{
	CFloat message_id;
	CFloat _from;
	CFloat _to;
	<Md>* message_data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\lvprot.cpp ===
#include "lvprot.h"
#include "usbreader.h"// TO REMOVE LATER....

#pragma PAGEDCODE
VOID  CLVProtocol::set_WTR_Delay(LONG Delay)
{
	if(device) device->set_WTR_Delay(Delay);
}

#pragma PAGEDCODE
ULONG CLVProtocol::get_WTR_Delay()
{
	if(device) return device->get_WTR_Delay();
	else return 0;
}

#pragma PAGEDCODE
VOID  CLVProtocol::set_Default_WTR_Delay()
{
	if(device) device->set_Default_WTR_Delay();
}

#pragma PAGEDCODE
LONG  CLVProtocol::get_Power_WTR_Delay()
{
	if(device) return device->get_Power_WTR_Delay();
	else return 0;
}


#pragma PAGEDCODE
ULONG CLVProtocol::getCardState()
{
	if(device) return device->getCardState();
	else return 0;
}



#pragma PAGEDCODE
NTSTATUS CLVProtocol::writeAndWait(BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
ULONG BufferLength;
NTSTATUS status;
	if(device)
	{
		if(!pRequest || !RequestLength || !pReply 
			|| !pReplyLength || !*pReplyLength  || RequestLength>=PROTOCOL_OUTPUT_BUFFER_SIZE)
		{

			TRACE("writeAndWait(): INVALID PARAMETERS PROVIDED FOR PROTOCOL!...\n");
			ASSERT(FALSE);
			return STATUS_INVALID_PARAMETER;
		}
		__try
		{
			pOutputBuffer[0] = (UCHAR)RequestLength;
			memory->copy(pOutputBuffer+1,pRequest, RequestLength+1);

			TRACE("LV protocol: writeAndWait()");
			TRACE_BUFFER(pOutputBuffer,RequestLength+1);
			BufferLength = InputBufferLength;
			status = device->writeAndWait(pOutputBuffer,RequestLength+1,pInputBuffer,&BufferLength);
			if(!NT_SUCCESS(status))
			{
				*pReplyLength = 0;
				__leave;
			}
			if(BufferLength>*pReplyLength)
			{
				*pReplyLength = 0;
				status =  STATUS_INSUFFICIENT_RESOURCES;
				__leave;
			}

			//Skip length byte
			if(BufferLength>1)	BufferLength--;
			*pReplyLength = BufferLength;
			if(BufferLength)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
			}

			TRACE("LV protocol: writeAndWait() response");
			TRACE_BUFFER(pReply,BufferLength);
		__leave;
		}
		__finally
		{
		}
		return status;
	}
	return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CLVProtocol::readAndWait(BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
ULONG BufferLength;
NTSTATUS status;
	if(device)
	{
		if(!pRequest || !RequestLength || !pReply 
			|| !pReplyLength || !*pReplyLength  || RequestLength>=PROTOCOL_OUTPUT_BUFFER_SIZE)
		{
			TRACE("readAndWait(): INVALID PARAMETERS PROVIDED FOR PROTOCOL!...\n");
			ASSERT(FALSE);
			return STATUS_INVALID_PARAMETER;
		}
		__try
		{
			pOutputBuffer[0] = (UCHAR)RequestLength;
			memory->copy(pOutputBuffer+1,pRequest, RequestLength+1);

			TRACE("LV protocol: readAndWait()");
			TRACE_BUFFER(pOutputBuffer,RequestLength+1);
			BufferLength = InputBufferLength;
			status = device->readAndWait(pOutputBuffer,RequestLength+1,pInputBuffer,&BufferLength);
			if(!NT_SUCCESS(status))
			{
				TRACE("LV protocol: readAndWait() reports error %8.8lX\n",status);
				*pReplyLength = 0;
				__leave;
			}
			if(BufferLength>*pReplyLength)
			{
				*pReplyLength = 0;
				status =  STATUS_INSUFFICIENT_RESOURCES;
				__leave;
			}

			//Skip length byte
			if(BufferLength>1)	BufferLength--;
			*pReplyLength = BufferLength;
			if(BufferLength)
			{
				memory->copy(pReply,pInputBuffer+1,BufferLength);
			}
			TRACE("LV protocol: readAndWait() response");
			TRACE_BUFFER(pInputBuffer,BufferLength);
			__leave;
		}
		__finally
		{
		}
		return status;
	}
	return STATUS_INVALID_DEVICE_STATE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\protocol.h ===
//-------------------------------------------------------------------
// This is abstract class for generic protocol
// Specific protocols should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		11/09/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __PROTOCOL__
#define __PROTOCOL__

#include "generic.h"
#include "kernel.h"

#define READER_PROTOCOL_LV		1
#define READER_PROTOCOL_GBP		2
#define READER_PROTOCOL_TLP		3

#define PROTOCOL_OUTPUT_BUFFER_SIZE	0x1000
#define PROTOCOL_INPUT_BUFFER_SIZE	0x1000


//class CDevice;
class CUSBReader;
class CDebug;
class CMemory;

#pragma PAGEDCODE
class CProtocol
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CDevice* device;
	//CUSBReader* device;
	CDebug*	 debug;
	CMemory* memory;

	// Internal buffers to manage Xfers...
    ULONG  OutputBufferLength;
    PUCHAR pOutputBuffer;
    ULONG  InputBufferLength;
    PUCHAR pInputBuffer;
protected:
	CProtocol();
	virtual ~CProtocol();
public:	
	CProtocol(CDevice* device);
	//CProtocol(CUSBReader* device);

	virtual  VOID  set_WTR_Delay(LONG Delay) {};
	virtual  ULONG get_WTR_Delay() {return 0;};
	virtual  VOID  set_Default_WTR_Delay() {};
	virtual  LONG  get_Power_WTR_Delay() {return 0;};
	virtual  ULONG getCardState() {return 0;}; 


	virtual  NTSTATUS writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)  {return STATUS_SUCCESS;};
	virtual  NTSTATUS readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)  {return STATUS_SUCCESS;};
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\rdrconfig.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef _READER_CONFIG_
#define _READER_CONFIG_

#include "generic.h"

#pragma PAGEDCODE
// Transparent mode configuration
struct TransparentConfig
{
  BYTE  CFG;
  BYTE  ETU;
  BYTE  EGT;
  BYTE  CWT;
  BYTE  BWI;
  BYTE  Fi;
  BYTE	Di;
};


struct  ReaderConfig 
{
  SHORT     Type;
  USHORT    PresenceDetection;
  USHORT	Vpp;
  BYTE      Voltage;
  BYTE      PTSMode;
  BYTE      PTS0;
  BYTE      PTS1;
  BYTE      PTS2;
  BYTE      PTS3;
  TransparentConfig transparent;
  ULONG     ActiveProtocol;

  ULONG		PowerTimeOut;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\semaphore.h ===
// Gemplus (C) 2000
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.2000
// Change log:
//
#ifndef SEM_INT
#define SEM_INT
#include "generic.h"

class CSemaphore;
#pragma PAGEDCODE
class CSemaphore
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CSemaphore(){};
	virtual ~CSemaphore() {};
public:

	virtual VOID		initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit) = 0;
	virtual LONG		release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait) = 0;
	virtual LONG		getState(IN PRKSEMAPHORE Semaphore) = 0;
};	

#endif//SEMAPHORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\smartcard.cpp ===
#include "smartcard.h"
#include "usbreader.h"

#pragma PAGEDCODE
CSmartCard::CSmartCard()
{ 
	debug	= kernel->createDebug();
	memory = kernel->createMemory();
	irp  = kernel->createIrp();
	lock = kernel->createLock();
	system = kernel->createSystem();
	if(lock)	lock->initializeSpinLock(&CardLock);
	poolingIrp = NULL;
};

#pragma PAGEDCODE
CSmartCard::~CSmartCard()
{ 
	TRACE("Destroing SmartCard...\n");
	if(memory) memory->dispose();
	if(irp)	   irp->dispose();
	if(lock)   lock->dispose();
	if(system) system->dispose();
	if(debug)  debug->dispose();
};

#pragma PAGEDCODE
BOOL CSmartCard::smartCardConnect(CUSBReader* reader)
{
	TRACE("		Connecting smartcard system...\n");
	if(reader)
	{	// Check if smartCard was already initialized...
		if(!reader->isSmartCardInitialized())
		{
		PSMARTCARD_EXTENSION Smartcard;
		NTSTATUS Status;
		USHORT   Len;
			if(isWin98())
			{// At this time string should be already initialized
				Status = SmartcardCreateLink(&DosDeviceName,&reader->getDeviceName()->m_String);
				TRACE("Gemplus USB reader registered with name %ws, status %X\n",DosDeviceName.Buffer,Status);
				if(!NT_SUCCESS(Status))
				{
					TRACE("#### Failed to create Device link! Status %X\n", Status);
					return FALSE;
				}
			}
			else
			{
				TRACE("Registering reader interface at system...\n");	
				if(!reader->registerDeviceInterface(&GUID_CLASS_SMARTCARD))
				{
					TRACE("#### Failed to register device interface...\n");
					return FALSE;
				}
			}

			Smartcard = reader->getCardExtention();
			TRACE("*** Reader reports Smartcard 0x%x\n",Smartcard);
			this->reader = reader;

			memory->zero(Smartcard,sizeof(SMARTCARD_EXTENSION));

			Smartcard->ReaderExtension = (PREADER_EXTENSION)reader;

			Smartcard->Version = SMCLIB_VERSION;

			// Read the name from reader object!!!!!!!
			Len = MAXIMUM_ATTR_STRING_LENGTH;
			reader->getVendorName(Smartcard->VendorAttr.VendorName.Buffer,&Len);
			Smartcard->VendorAttr.VendorName.Length = Len;
			TRACE("	VENDOR NAME - %s\n",Smartcard->VendorAttr.VendorName.Buffer);

			Len = MAXIMUM_ATTR_STRING_LENGTH;
			reader->getDeviceType(Smartcard->VendorAttr.IfdType.Buffer,&Len);
			Smartcard->VendorAttr.IfdType.Length = Len;
			TRACE("	DEVICE TYPE - %s\n",Smartcard->VendorAttr.IfdType.Buffer);

			// Clk frequency in KHz encoded as little endian integer
			Smartcard->ReaderCapabilities.CLKFrequency.Default = SC_IFD_DEFAULT_CLK_FREQUENCY; 
			Smartcard->ReaderCapabilities.CLKFrequency.Max = SC_IFD_MAXIMUM_CLK_FREQUENCY;

			Smartcard->ReaderCapabilities.DataRate.Default = SC_IFD_DEFAULT_DATA_RATE;
			Smartcard->ReaderCapabilities.DataRate.Max = SC_IFD_MAXIMUM_DATA_RATE;

			// reader could support higher data rates
			Smartcard->ReaderCapabilities.DataRatesSupported.List = dataRatesSupported;
			Smartcard->ReaderCapabilities.DataRatesSupported.Entries =
				sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

			Smartcard->VendorAttr.IfdVersion.BuildNumber = 0;

			//	store firmware revision in ifd version
			Smartcard->VendorAttr.IfdVersion.VersionMajor =	0x01;
			Smartcard->VendorAttr.IfdVersion.VersionMinor =	0x00;
			Smartcard->VendorAttr.IfdSerialNo.Length = 0;
			Smartcard->ReaderCapabilities.MaxIFSD = SC_IFD_MAXIMUM_IFSD;

			// Now setup information in our deviceExtension
			Smartcard->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;

			// TODO: get reader type from reader object!!!!!!!!!!!!!!
			// Type of Reader - USB
			Smartcard->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_USB;

			// This reader supports T=0 and T=1
			Smartcard->ReaderCapabilities.SupportedProtocols = 	SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
			Smartcard->ReaderCapabilities.MechProperties = 0;

			Smartcard->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
			Smartcard->SmartcardReply.BufferSize =   MIN_BUFFER_SIZE;	
			Status = SmartcardInitialize(Smartcard);
			if(NT_SUCCESS(Status))
			{
				// It looks like SmartcardInitialize() resets DeviceObject field,
				// So, we have to do it after the call.
				Smartcard->VendorAttr.UnitNo = reader->getDeviceNumber(); 
				Smartcard->OsData->DeviceObject = reader->getSystemDeviceObject();

				TRACE("		Registered device %d with DeviceObject 0x%x\n",Smartcard->VendorAttr.UnitNo,Smartcard->OsData->DeviceObject);
				
				//  (note: RDF_CARD_EJECT and RDF_READER_SWALLOW are not supported)
				// Well... Actually I could define methods at smartcard object as
				// statics and make a link to them. It will work.
				// The reason I created extenal C linkage functions - to 
				// separate smartcard system and our driver. 
				// I think driver actually may not care	about smartcard extention and all
				// settings required by smclib can be done inside our C wrappers and not
				// inside driver objects...
				Smartcard->ReaderFunction[RDF_TRANSMIT]      = smartCard_Transmit;
				Smartcard->ReaderFunction[RDF_SET_PROTOCOL]  = smartCard_SetProtocol;
				Smartcard->ReaderFunction[RDF_CARD_POWER]    = smartCard_Power;
				Smartcard->ReaderFunction[RDF_CARD_TRACKING] = smartCard_Tracking;
				Smartcard->ReaderFunction[RDF_IOCTL_VENDOR]  = smartCard_VendorIoctl;

				reader->setSmartCardInitialized(TRUE);
				TRACE("		***** SmartCard system was initialized correctly! *****\n\n");
				return TRUE;
			}
			else
			{
				TRACE("		##### FAILED to initialize smartcard system...\n");
			}
		}
		else
		{
			TRACE("		##### Smartcard system already active...\n");
		}
	}
	else
	{
		TRACE("		###### Invalid reader object...\n");
	}
	return FALSE;
};

#pragma PAGEDCODE
BOOL CSmartCard::smartCardStart()
{
	return TRUE;
};

#pragma PAGEDCODE
VOID CSmartCard::smartCardDisconnect()
{
	TRACE("		Disconnecting smartcard system...\n");
	if(reader)
	{
	PSMARTCARD_EXTENSION Smartcard;

		Smartcard = reader->getCardExtention();
		if(Smartcard->OsData && Smartcard->OsData->NotificationIrp)
		{
		KIRQL keIrql;
		
			PIRP poolingIrp = Smartcard->OsData->NotificationIrp;
			TRACE("====== COMPLETING NOTIFICATION IRP %8.8lX \n\n",poolingIrp);
			// Guard by spin lock!
			lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
			Smartcard->OsData->NotificationIrp = NULL;
			lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);
			
			lock->acquireCancelSpinLock(&keIrql);
				irp->setCancelRoutine(poolingIrp, NULL);
			lock->releaseCancelSpinLock(keIrql);

			if (poolingIrp->Cancel) poolingIrp->IoStatus.Status = STATUS_CANCELLED;
			else					poolingIrp->IoStatus.Status = STATUS_SUCCESS; 
			poolingIrp->IoStatus.Information = 0;			
			irp->completeRequest(poolingIrp, IO_NO_INCREMENT);
		}
		//Unregister the device
		if(isWin98())
		{
			TRACE("****** Removing device object name %ws \n",DosDeviceName.Buffer);
			system->deleteSymbolicLink(&DosDeviceName);
		}
		else
		{
			TRACE("Setting reader interface state to FALSE...\n");
			reader->unregisterDeviceInterface(reader->getDeviceInterfaceName());
		}


		SmartcardExit(Smartcard); 
		Smartcard->ReaderExtension = NULL;
		reader->setSmartCardInitialized(FALSE);

		reader = NULL;
		TRACE("		SmartCard system was disconnected...\n");
	}
};

// Declare Smclib system callbacks...
#pragma LOCKEDCODE
NTSTATUS smartCard_Transmit(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS Status		 = STATUS_SUCCESS;;
BOOL		Read = FALSE;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
PSCARD_CARD_CAPABILITIES cardCapabilities  = &SmartcardExtension->CardCapabilities;
ULONG		selectedProtocol  = cardCapabilities->Protocol.Selected;
ULONG		protocolRequested = ((PSCARD_IO_REQUEST) SmartcardExtension->OsData->CurrentIrp->AssociatedIrp.SystemBuffer)->dwProtocol;
BYTE * pRequest = (BYTE *)SmartcardExtension->SmartcardRequest.Buffer;
BYTE * pReply = (BYTE *)SmartcardExtension->SmartcardReply.Buffer;
ULONG  RequestLength =  0;
ULONG  ReplyLength   =  0;

    PAGED_CODE();

	DBG_PRINT ("smartCard_Transmit()\n"); 
    if (!Reader || (selectedProtocol != protocolRequested)) 
	{
        DBG_PRINT ("		smartCard_Transmit requested with invalid device state...\n");
		return (STATUS_INVALID_DEVICE_STATE);
    }
	
	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	__try
	{
		//Set the reply buffer length to 0.
		*SmartcardExtension->IoRequest.Information = 0;
		switch (selectedProtocol) 
		{
		case SCARD_PROTOCOL_T0:
			Status = SmartcardT0Request(SmartcardExtension);
			
			RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;
			
			DBG_PRINT("T0 PROTOCOL: request length %d\n",RequestLength);
			if (!NT_SUCCESS(Status)) 
			{
				DBG_PRINT ("smartCard_Transmit: SmartcardT0Request reports error 0x%x...\n",Status);
				__leave;
			}
			if (SmartcardExtension->T0.Le > 0) 
			{
				if (SmartcardExtension->T0.Le > SC_IFD_T0_MAXIMUM_LEX) 
				{
					DBG_PRINT ("smartCard_Transmit:Expected length is too big - %d\n",SmartcardExtension->T0.Le);
					Status = STATUS_BUFFER_TOO_SMALL;
					__leave;
				}
				ReplyLength   =  SmartcardExtension->SmartcardReply.BufferSize;
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					__leave;
				}
				Status = Reader->reader_Read(pRequest,RequestLength,pReply,&ReplyLength);
				Reader->reader_set_Idle();
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_Read() reports error 0x%x\n",Status);
					__leave;
				}
			}
			else
			{
				if (SmartcardExtension->T0.Lc > SC_IFD_T0_MAXIMUM_LC) 
				{
					DBG_PRINT ("smartCard_Transmit:Command length is too big - %d\n",SmartcardExtension->T0.Lc);
					Status = STATUS_BUFFER_TOO_SMALL;
					__leave;
				}

				ReplyLength   =  SmartcardExtension->SmartcardReply.BufferSize;
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_Transmit:Failed to get idle state...\n");
					__leave;
				}
				
				if(!pRequest || ! RequestLength)
				{
					DBG_PRINT("\n Transmit: cardWrite() Buffer %x length %d\n",pRequest,RequestLength);
				}
				Status = Reader->reader_Write(pRequest,RequestLength,pReply,&ReplyLength);
				Reader->reader_set_Idle();
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_Write() reports error 0x%x\n",Status);
					__leave;
				}
			}
		
    		SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;

			DBG_PRINT ("T0 Reply length 0x%x\n",ReplyLength);

			if(NT_SUCCESS(Status))	
			{
				Status = SmartcardT0Reply(SmartcardExtension);
			}
			if(!NT_SUCCESS(Status))
			{
				DBG_PRINT ("smartCard_Transmit: SmartcardT0Reply reports error 0x%x\n",Status);
			}
			break;
		case SCARD_PROTOCOL_T1:
			// Loop for the T=1 management
			if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
			{
				DBG_PRINT ("smartCard_Transmit:Failed to get idle state...\n");
				__leave;
			}

			do 
			{
				// Tell the lib function how many bytes I need for the prologue
				SmartcardExtension->SmartcardRequest.BufferLength = 0;

				Status = SmartcardT1Request(SmartcardExtension);

				RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;

				ReplyLength  =  SmartcardExtension->SmartcardReply.BufferSize;

				DBG_PRINT("T1 PROTOCOL: request, expected reply length %d, %d\n",RequestLength,ReplyLength);
				if (!NT_SUCCESS(Status)) 
				{
					DBG_PRINT ("smartCard_Transmit: SmartcardT1Request reports error 0x%x...\n",Status);
					Reader->reader_set_Idle();
					__leave;
				}
				Status = Reader->reader_translate_request(pRequest,RequestLength,pReply,&ReplyLength, cardCapabilities, SmartcardExtension->T1.Wtx);
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_Transmit: reader_translate_request() reports error 0x%x\n",Status);
					//return Status;  no let smartcard assign proper status
				}

				if (SmartcardExtension->T1.Wtx)
				{
					// Set the reader BWI to the default value
					Reader->setTransparentConfig(cardCapabilities,0);
				}

				// copy buffer(pass by ptr) n length
				SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;

				Status = SmartcardT1Reply(SmartcardExtension);
				if ((Status != STATUS_MORE_PROCESSING_REQUIRED) && (Status != STATUS_SUCCESS) ) 
				{
					DBG_PRINT ("smartCard_Transmit: SmartcardT1Reply reports error 0x%x\n",Status);
				}
			} while (Status == STATUS_MORE_PROCESSING_REQUIRED);

			Reader->reader_set_Idle();
			break;
		default:
			Status = STATUS_DEVICE_PROTOCOL_ERROR;
			__leave;
		}
	}// Try block
	
	__finally
	{
		Reader->releaseRemoveLock();
	}
    return Status;
};

#pragma LOCKEDCODE
NTSTATUS smartCard_VendorIoctl(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
ULONG		ControlCode = SmartcardExtension->MajorIoControlCode;
PUCHAR		pRequest = (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer;
ULONG		RequestLength = SmartcardExtension->IoRequest.RequestBufferLength;
PUCHAR		pReply = (PUCHAR)SmartcardExtension->IoRequest.ReplyBuffer;
ULONG		ReplyLength = SmartcardExtension->IoRequest.ReplyBufferLength;

	PAGED_CODE();
	
	DBG_PRINT ("smartCard_VendorIoctl()\n"); 
    
	if (!Reader) 
	{
		DBG_PRINT ("smartCard_VendorIoctl: Reader is not ready...\n");
        return (STATUS_INVALID_DEVICE_STATE);
    }
    
	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	*SmartcardExtension->IoRequest.Information = 0;

	__try
	{
		switch(ControlCode)
		{
			// For IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE and IOCTL_VENDOR_SMARTCARD_SET_ATTRIBUTE
			// Vendor attribut use by the device
			case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
			case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock())) 
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_VendorAttribute(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: reader_Attibute reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;
			break;
			// For IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE
			// Send a GemCore command to the reader
			case IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_Ioctl(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: cardIoctl reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;

			break;
			// For IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED
			// Change reader speed manually
			case IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED:
				if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
				{
					DBG_PRINT ("smartCard_VendorIoctl:Failed to get idle state...\n");
					__leave;
				}

				Status = Reader->reader_SwitchSpeed(ControlCode,pRequest,RequestLength,pReply,&ReplyLength);

				Reader->reader_set_Idle();

				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT ("smartCard_VendorIoctl: reader_SwitchSpeed reports error 0x%x ...\n", Status);
					ReplyLength = 0;
				}
				else
				{
					// Set value inside CardCabilities
					BYTE  NewTA1 = pRequest[0];

					SmartcardExtension->CardCapabilities.Fl = NewTA1 >> 4;
					SmartcardExtension->CardCapabilities.Dl = NewTA1 & 0x0F;
					// Do not touch ClockRateConversion and BitRateAdjustment!
				}
				*SmartcardExtension->IoRequest.Information = ReplyLength;

			break;
			default:
				Status = STATUS_NOT_SUPPORTED;
			break;
		}
	}

	__finally
	{
		Reader->releaseRemoveLock();
	}
	DBG_PRINT ("smartCard_VendorIoctl Exit Status=%x\n", Status);
    return Status;
};

#pragma PAGEDCODE
// Examine if ATR identifies a specific mode (presence of TA2).
BOOLEAN CSmartCard::CheckSpecificMode(BYTE* ATR, DWORD ATRLength)
{
   DWORD pos, len;


   // ATR[1] is T0.  Examine precense of TD1.
   if (ATR[1] & 0x80)
   {
      // Find position of TD1.
      pos = 2;
      if (ATR[1] & 0x10)
         pos++;
      if (ATR[1] & 0x20)
         pos++;
      if (ATR[1] & 0x40)
         pos++;

      // Here ATR[pos] is TD1.  Examine presence of TA2.
      if (ATR[pos] & 0x10)
      {
         // To be of any interest an ATR must contains at least
         //   TS, T0, TA1, TD1, TA2 [+ T1 .. TK] [+ TCK]
         // Find the maximum length of uninteresting ATR.
         if (ATR[pos] & 0x0F)
            len = 5 + (ATR[1] & 0x0F);
         else
            len = 4 + (ATR[1] & 0x0F);  // In protocol T=0 there is no TCK.

         if (ATRLength > len)  // Interface bytes requires changes.
	 {
            if ((ATR[pos+1] & 0x10) == 0)  // TA2 asks to use interface bytes.
	    {
               return TRUE;
	    }
	 }
      }
   }

   return FALSE;
} // CheckSpecificMode


#pragma LOCKEDCODE
NTSTATUS smartCard_Power(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension; //TO CHANGE LATER...  
ULONG		ControlCode = SmartcardExtension->MinorIoControlCode;
PUCHAR		pReply = (PUCHAR)SmartcardExtension->IoRequest.ReplyBuffer;
ULONG		ReplyLength = SmartcardExtension->IoRequest.ReplyBufferLength;
KIRQL oldirql;
ULONG State;
CSmartCard* smartcard = NULL;

	DBG_PRINT ("smartCard_Power()\n"); 
    if (!Reader) 
	{
		DBG_PRINT ("smartCard_ReaderPower(): Reader is not ready...\n");
        return STATUS_INVALID_DEVICE_STATE;
    }

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	smartcard   = Reader->getSmartCard();

    *SmartcardExtension->IoRequest.Information = 0;
	if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
	{
		DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
		Reader->releaseRemoveLock();
		return Status;
	}
    Status = Reader->reader_Power(ControlCode,pReply,&ReplyLength, FALSE);
	Reader->reader_set_Idle();
	switch(ControlCode) 
	{
    case SCARD_POWER_DOWN: 
		{
			if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
			{
				DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
				Reader->releaseRemoveLock();
				return Status;
			}
			State		= Reader->reader_UpdateCardState();
			if(smartcard)
			{
				KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
				SmartcardExtension->CardCapabilities.ATR.Length = 0;
				SmartcardExtension->ReaderCapabilities.CurrentState = State;
				KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
			}
			Reader->reader_set_Idle();
			if(!NT_SUCCESS(Status))
			{
				DBG_PRINT ("smartCard_ReaderPower: cardPower down reports error 0x%x ...\n", Status);
			}
			Reader->releaseRemoveLock();
			return Status;
		}
		break;
    case SCARD_COLD_RESET:
    case SCARD_WARM_RESET:
		if(!NT_SUCCESS(Status))
		{
			DBG_PRINT ("smartCard_ReaderPower: cardPower up reports error 0x%x ...\n", Status);
	
			*SmartcardExtension->IoRequest.Information = 0;
			KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
			SmartcardExtension->CardCapabilities.ATR.Length = 0;
			if(Status==STATUS_NO_MEDIA)
			{	
				DBG_PRINT("############# Reporting CARD ABSENT!... #############\n");
				SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
			}
			KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
			
			Reader->releaseRemoveLock();
			return Status;
		}
		if(pReply && ReplyLength && (pReply[0]==0x3B || pReply[0]==0x3F) )
		{
			if ((SmartcardExtension->SmartcardReply.BufferSize>=ReplyLength) &&
				(sizeof(SmartcardExtension->CardCapabilities.ATR.Buffer)>=ReplyLength))
			{

				DBG_PRINT("Setting SMCLIB info...\n");
				// Set information...
				*SmartcardExtension->IoRequest.Information =  ReplyLength;
				// Set reply...
				RtlCopyMemory(SmartcardExtension->SmartcardReply.Buffer,pReply,ReplyLength);
				SmartcardExtension->SmartcardReply.BufferLength = ReplyLength;
				// Set ATR...
				RtlCopyMemory(SmartcardExtension->CardCapabilities.ATR.Buffer,pReply,ReplyLength);
				SmartcardExtension->CardCapabilities.ATR.Length = (UCHAR) ReplyLength;
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
				// Parse the ATR string in order to check if it as valid
				// and to find out if the card uses invers convention
				Status = SmartcardUpdateCardCapabilities(SmartcardExtension);
				if(!NT_SUCCESS(Status))
				{
					DBG_PRINT("UpdateCardCaps() reports error 0x%x\n", Status);
					Status = 0;
				}

				// Check if Specific mode is present in TA2
				DBG_PRINT("=========== Checking specific mode....\n");
				if(smartcard->CheckSpecificMode(SmartcardExtension->CardCapabilities.ATR.Buffer,
                  						SmartcardExtension->CardCapabilities.ATR.Length))
				{	// Use automatic protocol switching!
					if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock()))
					{
						DBG_PRINT ("smartCard_Power:Failed to get idle state...\n");
						Reader->releaseRemoveLock();
						return Status;
					}
					
					Status = Reader->reader_Power(ControlCode,pReply,&ReplyLength, TRUE);
					
					Reader->reader_set_Idle();
				}

			}
			else
			{
				// ERROR!!!!!
				Status = STATUS_BUFFER_TOO_SMALL;
				*SmartcardExtension->IoRequest.Information = 0;
				DBG_PRINT ("smartCard_ReaderPower: Failed to copy ATR because of short ATR or Reply buffer...\n");
			}
		}
		else
		{
			//ERROR!!!!
			Status = STATUS_UNRECOGNIZED_MEDIA;
			*SmartcardExtension->IoRequest.Information = 0;
			DBG_PRINT ("smartCard_ReaderPower: Failed to get card ATR...\n");
			KeAcquireSpinLock(smartcard->getCardLock(), &oldirql);
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
			SmartcardExtension->CardCapabilities.ATR.Length = 0;
			KeReleaseSpinLock(smartcard->getCardLock(), oldirql);
		}
		Reader->releaseRemoveLock();
		return Status;
		break;
	}
	Reader->releaseRemoveLock();
    return STATUS_INVALID_PARAMETER;
};

#pragma LOCKEDCODE
NTSTATUS smartCard_SetProtocol(PSMARTCARD_EXTENSION SmartcardExtension)
{
NTSTATUS	Status		 = STATUS_SUCCESS;;
CUSBReader*	Reader = (CUSBReader*) SmartcardExtension->ReaderExtension;   
ULONG		ProtocolMask = SmartcardExtension->MinorIoControlCode;

    PAGED_CODE();
	DBG_PRINT ("smartCard_SetProtocol()\n"); 

    *SmartcardExtension->IoRequest.Information = 0;
    if (!Reader) 
	{
		DBG_PRINT ("######## smartCard_SetProtocol: Reader is not ready...\n");
        return (STATUS_INVALID_DEVICE_STATE);
    }

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T1)
			DBG_PRINT ("******* T1 PROTOCOL REQUESTED ******\n");
	if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T0)
			DBG_PRINT ("******* T0 PROTOCOL REQUESTED ******\n");

    // Check if the card is already in specific state
    // and if the caller wants to have the already selected protocol.
    // We return success if this is the case.
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
        (SmartcardExtension->CardCapabilities.Protocol.Selected & ProtocolMask))
    {
		DBG_PRINT ("Requested protocol %d already was setted.\n",SmartcardExtension->CardCapabilities.Protocol.Selected);
		Reader->releaseRemoveLock();
        return STATUS_SUCCESS;
	}

	if(!NT_SUCCESS(Status = Reader->reader_WaitForIdleAndBlock())) 
	{
		Reader->releaseRemoveLock();
		return Status;
	}

	do {
		// Select T=1 or T=0 and indicate that pts1 follows
		// What is the protocol selected
		DBG_PRINT ("Smartcard: SetProtocol Loop\n");

		if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T1)
		{

			DBG_PRINT ("******* SETTING T1 PROTOCOL ******\n");
			Status = Reader->reader_SetProtocol(SCARD_PROTOCOL_T1, PROTOCOL_MODE_MANUALLY);

			if(NT_SUCCESS(Status))
			{
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
				DBG_PRINT ("******* T1 PROTOCOL WAS SET ******\n");
			}
			
		} else if(SmartcardExtension->CardCapabilities.Protocol.Supported & ProtocolMask & SCARD_PROTOCOL_T0)
		{
			// T0 selection
			DBG_PRINT ("******* SETTING T0 PROTOCOL ******\n");
			Status = Reader->reader_SetProtocol(SCARD_PROTOCOL_T0, PROTOCOL_MODE_MANUALLY);
			if(NT_SUCCESS(Status))
			{
				SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
				DBG_PRINT ("******* T0 PROTOCOL WAS SET ******\n");
			}
		} 
		else 
		{
			Status = STATUS_INVALID_DEVICE_REQUEST;
			DBG_PRINT ("smartCard_SetProtocol: BAD protocol selection...\n");
			SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

			// close only once
			Reader->reader_set_Idle();

			Reader->releaseRemoveLock();
			return Status;
		}

		// Fail to negociate PPS, try PTS_TYPE_DEFAULT
		if( ! NT_SUCCESS(Status))
		{
			if (SmartcardExtension->CardCapabilities.PtsData.Type != PTS_TYPE_DEFAULT)
			{
				DBG_PRINT ("Smartcard: SetProtocol: PPS failed. Trying default parameters...\n");

				//
				// The card did either NOT reply or it replied incorrectly
				// so try default values.
				// Set PtsData Type to Default and do a cold reset
				// 
				SmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;

				Status = Reader->reader_SetProtocol(ProtocolMask, PROTOCOL_MODE_DEFAULT);

				if(NT_SUCCESS(Status))
				{
					Status = SmartcardUpdateCardCapabilities(SmartcardExtension);
				}

				if(NT_SUCCESS(Status))
				{
					DBG_PRINT ("Smartcard: SetProtocol PPS default succeed, TRY AGAIN\n");
					Status = STATUS_MORE_PROCESSING_REQUIRED;
				}
			}
		}
	} while ( Status == STATUS_MORE_PROCESSING_REQUIRED );

	if(NT_SUCCESS(Status))
	{

		DBG_PRINT ("smartCard_SetProtocol: SUCCCESS Finish transaction\n");
        // Now indicate that we're in specific mode 
        // and return the selected protocol to the caller
        //
        SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer = 
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information = 
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
	}
	else
	{
		Status = STATUS_DEVICE_PROTOCOL_ERROR;
		// We failed to connect at any protocol. Just report error.
		DBG_PRINT ("smartCard_SetProtocol: Failed to set any protocol...\n");
		SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
	}

	// Unblock set protocol
	Reader->reader_set_Idle();
	Reader->releaseRemoveLock();
    return Status;
};


// Callback function to cancel tracking Irp
#pragma LOCKEDCODE
NTSTATUS smartCard_CancelTracking(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{							// OnCancelPendingIoctl
CUSBReader* Reader = (CUSBReader*)DeviceObject->DeviceExtension;
PIRP notificationIrp;
CSmartCard* card = NULL;
PSMARTCARD_EXTENSION SmartcardExtention = NULL;
KIRQL ioIrql;
KIRQL keIrql;

	DBG_PRINT ("######### SmartCard: Cancelling card tracking...\n");
	DBG_PRINT ("######### SmartCard: DeviceObject reported - 0x%x, IRP - 0x%x\n",DeviceObject,Irp);
	DBG_PRINT ("######### SmartCard: Reader reported - 0x%x\n",Reader);

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	notificationIrp = NULL;
	card = Reader->getSmartCard();
	notificationIrp = card->getPoolingIrp();
	SmartcardExtention = Reader->getCardExtention();

    ASSERT(Irp == notificationIrp);
	IoReleaseCancelSpinLock(Irp->CancelIrql);

	DBG_PRINT("######### SmartCard: notificationIrp - 0x%x\n",Irp);
    KeAcquireSpinLock(&SmartcardExtention->OsData->SpinLock,&keIrql);
		notificationIrp = SmartcardExtention->OsData->NotificationIrp;
		SmartcardExtention->OsData->NotificationIrp = NULL;
    KeReleaseSpinLock(&SmartcardExtention->OsData->SpinLock,keIrql);
   
    if (notificationIrp) 
	{
		DBG_PRINT("####### CancelTracking: Completing NotificationIrp %lxh\n",notificationIrp);
		IoAcquireCancelSpinLock(&ioIrql);
			IoSetCancelRoutine(notificationIrp, NULL);
		IoReleaseCancelSpinLock(ioIrql);
	  		//	finish the request
        notificationIrp->IoStatus.Status = STATUS_CANCELLED;
	    notificationIrp->IoStatus.Information = 0;
	    IoCompleteRequest(notificationIrp, IO_NO_INCREMENT);
	}
	Reader->releaseRemoveLock();
	return STATUS_CANCELLED;
}



#pragma LOCKEDCODE
NTSTATUS smartCard_Tracking(PSMARTCARD_EXTENSION Smartcard)
{
KIRQL oldIrql;
CUSBReader*	Reader = (CUSBReader*) Smartcard->ReaderExtension;   
	DBG_PRINT ("SmartCard: Card tracking...\n");
	if (!Reader) return	STATUS_INVALID_DEVICE_STATE;

	if (!NT_SUCCESS(Reader->acquireRemoveLock()))	return STATUS_INVALID_DEVICE_STATE;

	if(Smartcard->MajorIoControlCode == IOCTL_SMARTCARD_IS_PRESENT)
	{
		Reader->setNotificationState(SCARD_SWALLOWED);
		DBG_PRINT ("SmartCard: WAITING FOR INSERTION!\n");
	}
	else
	{
		Reader->setNotificationState(SCARD_ABSENT);
		DBG_PRINT ("SmartCard: WAITING FOR REMOVAL!\n");
	}

	if(!Smartcard->OsData || !Smartcard->OsData->NotificationIrp)
	{
		DBG_PRINT ("SmartCard: ========== CARD TRACKING CALLED WITH ZERO IRP!!!!!\n");
		Reader->releaseRemoveLock();
		return STATUS_INVALID_DEVICE_STATE;
	} 

	DBG_PRINT("######### SmartCard: POOLING IRP - %8.8lX \n",Smartcard->OsData->NotificationIrp);
	CSmartCard* card = Reader->getSmartCard();
    IoAcquireCancelSpinLock(&oldIrql);
		IoSetCancelRoutine(Smartcard->OsData->NotificationIrp, smartCard_CancelTracking);
    IoReleaseCancelSpinLock(oldIrql);

	if(card) card->setPoolingIrp(Smartcard->OsData->NotificationIrp);
	Reader->releaseRemoveLock();
	return STATUS_PENDING;
};

#pragma PAGEDCODE
VOID CSmartCard::completeCardTracking()
{
PSMARTCARD_EXTENSION Smartcard;
ULONG CurrentState;
ULONG ExpectedState;
KIRQL ioIrql;
KIRQL keIrql;
PIRP  poolingIrp;

	//DEBUG_START();//Force to debug even if thread disabled it...

	TRACE("SmartCard: completeCardTracking() ...\n");
	Smartcard     = reader->getCardExtention();
	CurrentState  = reader->getCardState();
	ExpectedState = reader->getNotificationState();

	TRACE("SMCLIB Card state is %x\n",Smartcard->ReaderCapabilities.CurrentState);
	TRACE("Current Card state is %x\n",CurrentState);
	TRACE("ExpectedState is %x\n",ExpectedState);

	if(Smartcard && Smartcard->OsData)
	{
		lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
			if(CurrentState < SCARD_SWALLOWED)
			{
				Smartcard->ReaderCapabilities.CurrentState = CurrentState;
			}
			else
			{
				if(Smartcard->ReaderCapabilities.CurrentState<=SCARD_SWALLOWED)
				{
					Smartcard->ReaderCapabilities.CurrentState = CurrentState;
				}
			}

			TRACE("NEW SMCLIB card state is %x\n",Smartcard->ReaderCapabilities.CurrentState);
		lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);
	}

	poolingIrp = NULL;
	if((ExpectedState!= SCARD_UNKNOWN) && (ExpectedState == CurrentState))
	{
		DEBUG_START();//Force to debug even if thread disabled it...
		TRACE("\n=======Expected state %d is reached=====\n\n",ExpectedState);
		// Desired state reached...
		if(Smartcard->OsData && Smartcard->OsData->NotificationIrp)
		{
			setPoolingIrp(NULL);
			reader->setNotificationState(SCARD_UNKNOWN);

			TRACE("====== COMPLETING NOTIFICATION =========\n");
			// Finish requested notification!.....
			lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
				poolingIrp = Smartcard->OsData->NotificationIrp;
			lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);			
			if(poolingIrp)
			{
				TRACE("====== COMPLETING NOTIFICATION IRP %8.8lX \n\n",poolingIrp);
				lock->acquireCancelSpinLock(&ioIrql);
					irp->setCancelRoutine(poolingIrp, NULL);
				lock->releaseCancelSpinLock(ioIrql);

				if(poolingIrp->Cancel)
					poolingIrp->IoStatus.Status  = STATUS_CANCELLED;
				else
  					poolingIrp->IoStatus.Status  = STATUS_SUCCESS;
				poolingIrp->IoStatus.Information = 0;
				lock->acquireSpinLock(&Smartcard->OsData->SpinLock, &keIrql);
					Smartcard->OsData->NotificationIrp = NULL;
				lock->releaseSpinLock(&Smartcard->OsData->SpinLock, keIrql);			
				irp->completeRequest(poolingIrp,IO_NO_INCREMENT);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\smartcard.h ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		08/11/99	-	implemented	
//-------------------------------------------------------------------
#ifndef __SMART_CARD__
#define __SMART_CARD__

#include "generic.h"
#include "kernel.h"


//
//   - IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE defines a specific IOCTL for the Gemplus 
//      Reader to exchange data with the reader without control of the driver.
//   - IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to gets vendor attributes.
//   - IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to sets vendor attributes.
//
#define IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE  CTL_CODE(FILE_DEVICE_SMARTCARD,2048,0,0)
#define IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2049,0,0)
#define IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2050,0,0)
// 2051 is reserved for Gcr420 keyboard reader.
#define IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED  CTL_CODE(FILE_DEVICE_SMARTCARD,2052,0,0)


//
//   - SCARD_CLASS is a macro to know the class of a Tag.
//
#define SCARD_CLASS(Value) (ULONG) (((ULONG)(Value)) >> 16)
//
//   - SCARD_ATTR_SPEC_BAUD_RATE is the Tag to acces at the value of the baud rate (PC/IFD).
//   - SCARD_ATTR_SPEC_CMD_TIMEOUT is the Tag to access at the value of the Cmd Timeout.
//   - SCARD_ATTR_SPEC_POWER_TIMEOUT is the Tag to access at the value of the Power 
//      Timeout.
//   - SCARD_ATTR_SPEC_APDU_TIMEOUT is the Tag to access at the value of the APDU 
//      Timeout.
//
#define SCARD_ATTR_SPEC_BAUD_RATE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0180)
#define SCARD_ATTR_SPEC_CMD_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0181)
#define SCARD_ATTR_SPEC_POWER_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0182)
#define SCARD_ATTR_SPEC_APDU_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0183)
//
// To give possibility for recognition of driver
//
#define SCARD_ATTR_MANUFACTURER_NAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0190)
#define SCARD_ATTR_ORIGINAL_FILENAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0191)

#define GBCLASS_OPEN_SESSION	0x3001
#define GBCLASS_CLOSE_SESSION	0x3002
#define GBCLASS_DRIVER_SCNAME	0x3003
#define GBCLASS_CONNECTION_TYPE 0x3004
#define IOCTL_OPEN_SESSION   CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_OPEN_SESSION,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CLOSE_SESSION  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_CLOSE_SESSION,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DRIVER_SCNAME  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_DRIVER_SCNAME,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CONNECTION_TYPE  CTL_CODE(FILE_DEVICE_BUS_EXTENDER,GBCLASS_CONNECTION_TYPE,METHOD_BUFFERED,FILE_ANY_ACCESS)


#define ATTR_MANUFACTURER_NAME      "Gemplus"
#define ATTR_ORIGINAL_FILENAME      "GrClass.sys"
#define ATTR_LENGTH                 32

#define SC_IFD_DEFAULT_CLK_FREQUENCY      4000
#define SC_IFD_MAXIMUM_CLK_FREQUENCY      4000
#define SC_IFD_DEFAULT_DATA_RATE          10753
#define SC_IFD_MAXIMUM_DATA_RATE          125000
#define SC_IFD_MAXIMUM_IFSD               253// To correct problem with SMCLIB!
#define SC_IFD_T0_MAXIMUM_LEX             256
#define SC_IFD_T0_MAXIMUM_LC              255



// PTS mode parameters
#define PROTOCOL_MODE_DEFAULT			0
#define PROTOCOL_MODE_MANUALLY			1

static ULONG 
   dataRatesSupported[] = { 
     10753,  14337,  15625,  17204,
     20833,  21505,  28674,  31250,
     34409,  41667,  43011,  57348,
     62500,  83333,  86022, 114695,
    125000 
      };

#define GRCLASS_DRIVER_NAME           "GRClass"
#define GRCLASS_VENDOR_NAME           "Gemplus"
#define GRCLASS_READER_TYPE           "GemPC430"


#define REQUEST_TO_NOTIFY_INSERTION		1
#define REQUEST_TO_NOTIFY_REMOVAL		2

#pragma LOCKEDCODE
// Declare Smclib system callbacks...
#ifdef __cplusplus
extern "C"{
#endif
NTSTATUS smartCard_Transmit(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_CancelTracking(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
NTSTATUS smartCard_Tracking(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_VendorIoctl(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_Power(PSMARTCARD_EXTENSION SmartcardExtension);
NTSTATUS smartCard_SetProtocol(PSMARTCARD_EXTENSION SmartcardExtension);
#ifdef __cplusplus
}
#endif

#pragma PAGEDCODE
class CUSBReader;//TO CHANGE LATER...
class CSmartCard
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
	CUSBReader* reader;
	CDebug*	 debug;
	CMemory* memory;
	CLock*   lock;
	CSystem* system;
	CIrp*    irp;

	KEVENT   evCanceled;// set when tracking is canceled...
	PIRP     poolingIrp;
	UNICODE_STRING DosDeviceName;//Used only at Win9x
public:
	KSPIN_LOCK CardLock;
protected:
	virtual ~CSmartCard();
public:
	CSmartCard();
	virtual CUSBReader* getReader() {return reader;};//TO CHANGE LATER...

	virtual BOOL smartCardConnect(CUSBReader* reader);
	virtual VOID smartCardDisconnect();
	virtual BOOL smartCardStart();

	virtual PKSPIN_LOCK getCardLock(){return &CardLock;};
	virtual VOID completeCardTracking();
	virtual VOID setPoolingIrp(PIRP Irp){poolingIrp = Irp;};
	virtual PIRP getPoolingIrp(){return poolingIrp;};
	virtual BOOLEAN CheckSpecificMode(BYTE* ATR, DWORD ATRLength);
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by grclass.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\system.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef SYS_INT
#define SYS_INT
#include "generic.h"

#pragma PAGEDCODE
// This is device interface to system...
class CSystem
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	CSystem(){};
	virtual ~CSystem(){};
public:

	// This object will implement next interfaces...
	virtual NTSTATUS		createDevice(PDRIVER_OBJECT DriverObject,
								ULONG DeviceExtensionSize,
								PUNICODE_STRING DeviceName OPTIONAL,
								DEVICE_TYPE DeviceType,
								ULONG DeviceCharacteristics,
								BOOLEAN Reserved,
								PDEVICE_OBJECT *DeviceObject) {return STATUS_SUCCESS;};
	virtual VOID			deleteDevice(PDEVICE_OBJECT DeviceObject) {};

	virtual PDEVICE_OBJECT	attachDevice(PDEVICE_OBJECT FuncDevice,IN PDEVICE_OBJECT PhysDevice) {return NULL;};
	virtual VOID			detachDevice(PDEVICE_OBJECT TargetDevice) {};

	virtual NTSTATUS		callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp) {return STATUS_SUCCESS;};

	virtual NTSTATUS		registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
								CONST GUID *InterfaceClassGuid,
								PUNICODE_STRING ReferenceString,     OPTIONAL
								PUNICODE_STRING SymbolicLinkName) {return STATUS_SUCCESS;};
	virtual NTSTATUS		setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,BOOLEAN Enable) {return STATUS_SUCCESS;};

	virtual NTSTATUS		createSystemThread(OUT PHANDLE ThreadHandle,
								IN ULONG DesiredAccess,
								IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
								IN HANDLE ProcessHandle OPTIONAL,
								OUT PCLIENT_ID ClientId OPTIONAL,
								IN PKSTART_ROUTINE StartRoutine,
								IN PVOID StartContext) {return STATUS_SUCCESS;};
	virtual NTSTATUS		terminateSystemThread(IN NTSTATUS ExitStatus) {return STATUS_SUCCESS;};
	virtual NTSTATUS		referenceObjectByHandle(IN HANDLE Handle,                                           
								IN ACCESS_MASK DesiredAccess,                               
								IN POBJECT_TYPE ObjectType OPTIONAL,                        
								IN KPROCESSOR_MODE AccessMode,                              
								OUT PVOID *Object,                                          
								OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
								) {return STATUS_SUCCESS;};
	virtual VOID			referenceObject(IN PVOID Object) {};
	virtual VOID			dereferenceObject(IN PVOID Object) {};
	virtual PDEVICE_OBJECT	getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject) {return NULL;};

	virtual NTSTATUS	    ZwClose(IN HANDLE Handle) {return STATUS_SUCCESS;};

	virtual NTSTATUS		createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName) {return STATUS_SUCCESS;};
	virtual NTSTATUS		deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName) {return STATUS_SUCCESS;};

	virtual VOID			invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type) {};

	virtual NTSTATUS		getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
								IN ACCESS_MASK DesiredAccess,
								OUT PFILE_OBJECT *FileObject,
								OUT PDEVICE_OBJECT *DeviceObject) {return STATUS_SUCCESS;};

	virtual VOID			raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql) = 0;
	virtual VOID			lowerIrql (IN KIRQL NewIrql) = 0;
	virtual KIRQL			getCurrentIrql()=0;
	
	virtual VOID			initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue) = 0;
	virtual BOOLEAN			insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry) = 0;
	virtual BOOLEAN			insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey) = 0;
	virtual PKDEVICE_QUEUE_ENTRY	removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue) = 0;
	virtual PKDEVICE_QUEUE_ENTRY	removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey) = 0;
	virtual BOOLEAN			removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry) = 0;


	virtual NTSTATUS		openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
								IN ULONG DevInstKeyType,
								IN ACCESS_MASK DesiredAccess,
								OUT PHANDLE DevInstRegKey
								) = 0;
	virtual NTSTATUS		ZwQueryValueKey(IN HANDLE KeyHandle,
								IN PUNICODE_STRING ValueName,
								IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
								OUT PVOID KeyValueInformation,
								IN ULONG Length,
								OUT PULONG ResultLength) = 0;

	virtual NTSTATUS		getDeviceProperty(IN PDEVICE_OBJECT DeviceObject,
								IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
								IN ULONG BufferLength,
								OUT PVOID PropertyBuffer,
								OUT PULONG ResultLength
								) = 0;

	virtual VOID			initializeFastMutex(IN PFAST_MUTEX FastMutex) = 0;
	virtual VOID			acquireFastMutex(IN PFAST_MUTEX FastMutex) = 0;
	virtual VOID			releaseFastMutex(IN PFAST_MUTEX FastMutex) = 0;
};	

#endif//SYS_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\reader.h ===
// Gemplus (C) 1999
// This object defines any reader interface.
// So all reader should implement it.
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef _READER_
#define _READER_

#include "generic.h"

#pragma PAGEDCODE
class CSmartCard;
class CUSBReader;//TOBE REMOVED
// Abstruct class 
class CReader
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
public:	
	CReader() {};
	virtual  ~CReader(){};

	//virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CDevice* device) {return FALSE;};//TOBE CHANGED
	virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device) {return FALSE;};
	virtual BOOL	 isSmartCardInitialized() {return FALSE;};	
	virtual VOID	 setSmartCardInitialized(BOOL state) {};
	virtual VOID	 initializeSmartCardSystem() {};

	virtual PSMARTCARD_EXTENSION getCardExtention() {return NULL;};
	virtual CSmartCard* getSmartCard() {return NULL;};
	virtual PDEVICE_OBJECT	getSystemDeviceObject() {return NULL;};

	// Synchronization functions...
	virtual VOID	  reader_set_busy() {};
	virtual VOID	  reader_set_Idle() {};
	virtual NTSTATUS  reader_WaitForIdle() {return STATUS_SUCCESS;};
	virtual NTSTATUS  reader_WaitForIdleAndBlock() {return STATUS_SUCCESS;}; 

	// Interface with smartcard system
	virtual ULONG     reader_UpdateCardState() {return 0;};
	//virtual ULONG     getCardState() {return 0;};
	//virtual VOID      setCardState(ULONG state) {};

	virtual NTSTATUS  reader_getVersion(PUCHAR pVersion, PULONG pLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS  reader_setMode(ULONG mode) {return STATUS_SUCCESS;};

	virtual VOID	  setNotificationState(ULONG state) {};
	virtual ULONG	  getNotificationState() {return 0;};
	virtual VOID	  completeCardTracking() {};

#ifdef DEBUG
	// Defines methods to process system requests...
	virtual NTSTATUS reader_Read(IN PIRP Irp) {return STATUS_SUCCESS;}; 
	virtual NTSTATUS reader_Write(IN PIRP Irp) {return STATUS_SUCCESS;};
#endif

	// Define methods to process driver requests...
	virtual NTSTATUS reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation) {return STATUS_SUCCESS;};
	
	virtual NTSTATUS reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx) {return STATUS_SUCCESS;};
	virtual NTSTATUS reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength) {return STATUS_SUCCESS;};
};

#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\syswdm.h ===
//#pragma hdrstop
/*++
	Kernel mode definitions and function prototypes for wdm model
--*/
#ifndef WDM_INCD
#define WDM_INCD

#pragma PAGEDCODE
#ifdef __cplusplus
extern "C"{
#endif

#include <wdm.h>
#include <stdio.h>
#include <stdarg.h>

#ifndef IRP_MN_QUERY_LEGACY_BUS_INFORMATION
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#endif

#if DBG && defined(_X86_)
#undef ASSERT
#define ASSERT(e) if(!(e)){DbgPrint("Assertion failure in"\
__FILE__", line %d: " #e "\n", __LINE__);\
_asm int 3\
}
#endif


#define BOOL BOOLEAN
#define FALSE 0
typedef UCHAR* PBYTE;


#define MSEC	*(-(LONGLONG)10000); //milliseconds 

///////////////////////////////////////////////////////////////////////////////
/************************* LISTS MANIPULATION MACROS **************************/
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.

	/*
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY * volatile Flink;
   struct _LIST_ENTRY * volatile Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

  */
#ifndef LIST_ENTRY_DEF
#define LIST_ENTRY_DEF

//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif //LIST_ENTRY

#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))
#endif

/*******************************************************************************/

#ifndef FIELDOFFSET
	#define FIELDOFFSET(type, field) ((DWORD)(&((type *)0)->field))
#endif


#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))
#endif

/**********************************************************************************/


#ifdef __cplusplus
}
#endif

// Macros to verify allocated objects
#define ALLOCATED_OK(obj) \
	((obj!=(VOID *)0) && NT_SUCCESS((obj)->m_Status))

#define DISPOSE_OBJECT(obj) \
		{if((obj!=(VOID *)0))	obj->dispose(); obj = NULL;}

#define RETURN_VERIFIED_OBJECT(obj) \
if(ALLOCATED_OK(obj)) return obj;	\
else								\
{									\
	DISPOSE_OBJECT(obj);			\
	return NULL;					\
}

// derived class Unicode string
#define TYPE_SYSTEM_ALLOCATED 0
#define TYPE_DRIVER_ALLOCATED 1

extern ULONG ObjectCounter;
//::DBG_PRINT("=== Deleting Object %8.8lX",ptr);\
// Overrides for library new and delete operators.

/*
inline VOID* __cdecl operator new(ULONG size, POOL_TYPE iType)\
{PVOID	pMem; if(pMem = ::ExAllocatePoolWithTag(iType,size,'_GRU'))\
{ ObjectCounter++; ::RtlZeroMemory(pMem,size); DBG_PRINT("\n=== New Object %8.8lX, %d\n",pMem,ObjectCounter);\
	return pMem; \
} else return NULL; };

inline VOID __cdecl operator delete(VOID* ptr)\
{ if(ptr){ObjectCounter--; DBG_PRINT("\n=== Deleting Object %8.8lX, %d\n",ptr,ObjectCounter); ::ExFreePool((PVOID)ptr);}\
};
*/


#pragma LOCKEDCODE
inline VOID* __cdecl operator new(size_t size, POOL_TYPE iType)\
{PVOID	pMem; if(pMem = ::ExAllocatePoolWithTag(iType,size,'URG_'))\
{ ObjectCounter++; ::RtlZeroMemory(pMem,size);\
	return pMem; \
} else return NULL; };

inline VOID __cdecl operator delete(VOID* ptr)\
{ if(ptr){ObjectCounter--; ::ExFreePool((PVOID)ptr);}\
};


#include "generic.h"

#pragma PAGEDCODE
template <class T>
class CLinkedList
{
public:
	NTSTATUS m_Status;
	VOID self_delete(VOID){delete this;};
	virtual VOID dispose(VOID){self_delete();};
protected:
    LIST_ENTRY head;
    KSPIN_LOCK splock;

public:
    CLinkedList()
    {
        InitializeListHead(&head);
        KeInitializeSpinLock(&splock);
    };
    
    BOOLEAN IsEmpty(VOID) { return IsListEmpty(&head); };
    ~CLinkedList()
    {    // if list is still not empty, free all items
		T *p;
        while (p=(T *) ExInterlockedRemoveHeadList(&head,&splock))
        {
			CONTAINING_RECORD(p,T,entry)->dispose();
        }
    };

    VOID New(T *p)
    {
        ExInterlockedInsertTailList(&head,&(p->entry),&splock);
    };

    VOID insertHead(T *p)
    {
        ExInterlockedInsertHeadList(&head,&(p->entry),&splock);
    };

    T*  removeHead(VOID)
    {
        T *p=(T *) ExInterlockedRemoveHeadList(&head,&splock);
        if (p) p=CONTAINING_RECORD(p,T,entry);
        return p;
    };
    VOID remove(T *p)
    {
        RemoveEntryList(&(p->entry));
    };
    
	T*  getNext(T* p)
    {        
		if (p)
		{
		PLIST_ENTRY	Next;
			Next = p->entry.Flink;
			if (Next && (Next!= &head))
			{
				T* pp=CONTAINING_RECORD(Next,T,entry);
				return pp;
			}
			else	return NULL;
		}
		return NULL;	
    };
	
	T*  getFirst()
    {   
		PLIST_ENTRY	Next = head.Flink;
		if (Next && Next!= &head)
		{
			T* p = CONTAINING_RECORD(Next,T,entry);
			return p;
		}
		return NULL;
    };
};

#pragma PAGEDCODE
class CUString 
{ 
public:
	NTSTATUS m_Status;
	VOID self_delete(VOID){delete this;};
	virtual VOID dispose(VOID){self_delete();};
private:
    UCHAR m_bType;
public:
    UNICODE_STRING m_String;
public:
	CUString(USHORT nSize)
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		m_String.MaximumLength = nSize;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,nSize);
		if (!m_String.Buffer) return;  // leaving status the way it is
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);
		m_Status = STATUS_SUCCESS;
	};
	
	CUString(PWCHAR uszString)
	{
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlInitUnicodeString(&m_String,uszString);
	};

	CUString(ANSI_STRING* pString)
	{
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlAnsiStringToUnicodeString(&m_String,pString,TRUE);
	};

	CUString(PCSTR pString)
	{
	ANSI_STRING AnsiString;
		m_Status = STATUS_SUCCESS;
		m_bType = TYPE_SYSTEM_ALLOCATED;
		RtlInitAnsiString(&AnsiString,pString);
		RtlAnsiStringToUnicodeString(&m_String,&AnsiString,TRUE);
	};



	CUString(PUNICODE_STRING uString)
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		m_String.MaximumLength = MAXIMUM_FILENAME_LENGTH;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,MAXIMUM_FILENAME_LENGTH);
		if (!m_String.Buffer) return;  // leaving status the way it is
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);

		RtlCopyUnicodeString(&m_String,uString);
		m_Status = STATUS_SUCCESS;
	};


	CUString(LONG iVal, LONG iBase)  
	{
		m_Status = STATUS_INSUFFICIENT_RESOURCES;
		m_bType = TYPE_DRIVER_ALLOCATED;
		RtlInitUnicodeString(&m_String,NULL);
		USHORT iSize=1;
		LONG iValCopy=(!iVal)?1:iVal;
		while (iValCopy>=1)
		{
			iValCopy/=iBase;
			iSize++;
		}    // now iSize carries the number of digits

		iSize*=sizeof(WCHAR);

		m_String.MaximumLength = iSize;
		m_String.Buffer = (USHORT *)
			ExAllocatePool(PagedPool,iSize);
		if (!m_String.Buffer) return;
		RtlZeroMemory(m_String.Buffer,m_String.MaximumLength);
		m_Status = RtlIntegerToUnicodeString(iVal, iBase, &m_String);
	};

	~CUString()
	{
		if ((m_bType == TYPE_DRIVER_ALLOCATED) && m_String.Buffer) 
			ExFreePool(m_String.Buffer);
	};

	VOID append(UNICODE_STRING *uszString)
	{
		m_Status = RtlAppendUnicodeStringToString(&m_String,uszString);
	};

	VOID copyTo(CUString *pTarget)
	{
		RtlCopyUnicodeString(&pTarget->m_String,&m_String);
	};

	BOOL operator==(CUString cuArg)
	{
		return (!RtlCompareUnicodeString(&m_String,
			&cuArg.m_String,FALSE));
	};

    LONG inline getLength() { return m_String.Length; };
    PWCHAR inline getString() { return m_String.Buffer; };
    VOID inline setLength(USHORT i) { m_String.Length = i; };
};


 // already included
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\thread.cpp ===
#include "thread.h"

// Thread callback...
#pragma LOCKEDCODE
VOID CThread::ThreadFunction(CThread* Thread)
{
	if(Thread) Thread->ThreadRoutine(NULL);
}

#pragma PAGEDCODE
VOID CThread::ThreadRoutine(PVOID context)
{
NTSTATUS status;
	TRACE("================= STARTING THREAD %8.8lX ===============\n", thread);

	// Wait for a request to Start pooling or for
	// someone to kill this thread.
	PVOID mainevents[] = {(PVOID) &evKill,(PVOID) &evStart};
	PVOID pollevents[] = {(PVOID) &evKill,(PVOID) timer->getHandle(),(PVOID) &smOnDemandStart};

	ASSERT(arraysize(mainevents) <= THREAD_WAIT_OBJECTS);
	ASSERT(arraysize(pollevents) <= THREAD_WAIT_OBJECTS);

	BOOLEAN kill = FALSE;	
	while (!kill && thread)
	{	// until told to start or to quit
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);

		// Before going to thread routine thread considered to be Idle 
		if(event) event->set(&evIdle, IO_NO_INCREMENT, FALSE);
		
		status = event->waitForMultipleObjects(arraysize(mainevents),
			mainevents, WaitAny, Executive, KernelMode, FALSE, NULL, NULL);

		if(!NT_SUCCESS(status))
		{	// error in wait
			TRACE("Thread: waitForMultipleObjects failed - %X\n", status);
			break;
		}		
		if (status == STATUS_WAIT_0)
		{
			DEBUG_START();
			TRACE("Request to kill thread arrived...\n");
			TRACE("================= KILLING THREAD! ===============\n");
			break;	// kill event was set
		}

		// Starting the timer with a zero due time will cause us to perform the
		// first poll immediately. Thereafter, polls occur at the POLLING_INTERVAL
		// interval (measured in milliseconds).

		// Now thread is busy...
		if(event) event->clear(&evIdle);

		LARGE_INTEGER duetime = {0};// Signal timer right away!
		timer->set(duetime, PoolingTimeout, NULL);
		while (TRUE)
		{	// Block until time to poll again
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			status = event->waitForMultipleObjects(arraysize(pollevents),
				pollevents, WaitAny, Executive, KernelMode, FALSE, NULL, NULL);
			if (!NT_SUCCESS(status))
			{	// error in wait
				DEBUG_START();
				TRACE("CTread - waitForMultipleObjects failed - %X\n", status);
				TRACE("================= KILLING THREAD! ===============\n");
				timer->cancel();
				kill = TRUE;
				break;
			}
						
			if (status == STATUS_WAIT_0)
			{	// told to quit
				DEBUG_START();
				TRACE("Loop: Request to kill thread arrived...\n");
				TRACE("================= KILLING THREAD! ===============\n");
				timer->cancel();
				status = STATUS_DELETE_PENDING;
				kill = TRUE;
				break;
			}
			
			//if(device)
			if(pfClientThreadFunction)
			{
				if(StopRequested) break;
				// Do device specific thread processing...
				//TRACE("Calling thread %8.8lX function...\n",thread);
				if(status = pfClientThreadFunction(ClientContext))
				{
					TRACE("Device reported error %8.8lX\n",status);
					timer->cancel();
					break;
				}
			}
			else
			{
				DEBUG_START();
				TRACE("================= THREAD FUNCTION POINTER IS NOT SET!! FINISHED... ===============\n");
				TRACE("================= KILLING THREAD! ===============\n");
				status = STATUS_DELETE_PENDING;
				kill = TRUE;
				break;
			}
		}
	}// until told to quit
	TRACE("			Leaving thread %8.8lX...\n", thread);
	if(event) event->set(&evIdle, IO_NO_INCREMENT, FALSE);
	if(event) event->set(&evStopped, IO_NO_INCREMENT, FALSE);
	if(semaphore) semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
 	if(system) system->terminateSystemThread(STATUS_SUCCESS);
}

#pragma PAGEDCODE
CThread::CThread(PCLIENT_THREAD_ROUTINE ClientThreadFunction,PVOID ClientContext, ULONG delay)
{	// StartPollingThread for the device
NTSTATUS status;
HANDLE hthread;
	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	//this->device = device;
	// Create objects..
	event		= kernel->createEvent();
	system		= kernel->createSystem();
	timer		= kernel->createTimer(SynchronizationTimer);
	semaphore	= kernel->createSemaphore();

	debug  = kernel->createDebug();

	StopRequested = FALSE;
	ThreadActive  = FALSE;
	if(ALLOCATED_OK(event))
	{
		event->initialize(&evKill, NotificationEvent, FALSE);
		event->initialize(&evStart, SynchronizationEvent, FALSE);
		event->initialize(&evStopped, NotificationEvent, FALSE);
		event->initialize(&evIdle, NotificationEvent, TRUE);
	}
	// At the begining there is no request to start,
	// so semaphore is not at signal state.
	if(ALLOCATED_OK(semaphore))	semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
	pfClientThreadFunction = ClientThreadFunction;
	this->ClientContext = ClientContext;
	PoolingTimeout = delay; // Default thread pooling interval...
	// Create system thread object...
	status = system->createSystemThread(&hthread, THREAD_ALL_ACCESS, NULL, NULL, NULL,
									(PKSTART_ROUTINE) ThreadFunction, this);
	if(NT_SUCCESS(status))	// Get thread pointer...
	{
		thread = NULL;
		status = system->referenceObjectByHandle(hthread, THREAD_ALL_ACCESS, NULL,
										KernelMode, (PVOID*) &thread, NULL);
		if(!NT_SUCCESS(status))
		{
			TRACE("FAILED TO REFERENCE OBJECT! Error %8.8lX\n", status);
		}
	}
	else TRACE("FAILED TO CREATE SYSTEM THREAD! Error %8.8lX\n", status);

	system->ZwClose(hthread);
	if(NT_SUCCESS(status) &&
		ALLOCATED_OK(event)&&
		ALLOCATED_OK(system)&&
		ALLOCATED_OK(timer)&&
		ALLOCATED_OK(semaphore) && thread)
			m_Status = STATUS_SUCCESS;
} // StartPollingThread

#pragma PAGEDCODE
CThread::~CThread()
{	// StopPollingThread
	DEBUG_START();
	TRACE("Terminating thread %8.8lX...\n", thread);
	if(event) event->set(&evKill, IO_NO_INCREMENT, FALSE);
	StopRequested = TRUE;
	//device = NULL;
	if (thread)
	{	// wait for the thread to die
		if(system && event)
		{
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			event->waitForSingleObject(&evStopped, Executive, KernelMode, FALSE, NULL);
			if(!isWin98()) 
				event->waitForSingleObject(thread, Executive, KernelMode, FALSE, NULL);
			system->dereferenceObject(thread);
			thread = NULL;
		}
	}
	TRACE("Thread terminated...\n");

	if(event)  event->dispose();
	if(system) system->dispose();
	if(timer)  timer->dispose();
	if(semaphore) semaphore->dispose();

	if(debug)  debug->dispose();
}

#pragma PAGEDCODE
VOID CThread::kill()
{
	DEBUG_START();
	TRACE("Killing thread %8.8lX...\n", thread);
	StopRequested = TRUE;

	if(system) 
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	if(event) event->set(&evKill, IO_NO_INCREMENT, FALSE);
	if(event) event->waitForSingleObject(&evStopped, Executive, KernelMode, FALSE, NULL);
}

#pragma PAGEDCODE
VOID CThread::start()
{
	DEBUG_START();
	TRACE("Starting thread %8.8lX...\n", thread);
	if(system) 
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	StopRequested = FALSE;
	ThreadActive  = TRUE;
	// Start Card pooling...
	if(event) event->set(&evStart, IO_NO_INCREMENT, FALSE);
}

#pragma PAGEDCODE
VOID CThread::stop()
{
	DEBUG_START();
	TRACE("Stop thread %8.8lX...\n", thread);
	StopRequested = TRUE;
	ThreadActive  = FALSE;
	if(system)
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
	}
	if(event)	  event->clear(&evStart);
	// Unblock thread if it is blocked...
	if(semaphore) semaphore->release(&smOnDemandStart,0,1,FALSE);
	// Wait for for the thread to go to the idle state...
	if(event)	  event->waitForSingleObject(&evIdle, Executive, KernelMode, FALSE, NULL);
	// Stop thread ...
	if(semaphore) semaphore->initialize(&smOnDemandStart, 0, MAXLONG);
}

#pragma PAGEDCODE
BOOL CThread::isThreadActive()
{
	return ThreadActive;
}

#pragma PAGEDCODE
VOID CThread::setPoolingInterval(ULONG delay)
{
	PoolingTimeout = delay;
};

#pragma PAGEDCODE
VOID CThread::callThreadFunction()
{	// This will force thread function to be called right away.
	// Useful if we want to update some information or
	// start some processing without waiting for the pooling
	// timeout to occure.
	if(semaphore) semaphore->release(&smOnDemandStart,0,1,FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\timer.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __TIMER__
#define __TIMER__
#include "generic.h"

#define DELAY(t)\
{if(t){CTimer* timer = kernel->createTimer(NotificationTimer);\
	if(ALLOCATED_OK(timer)) {timer->delay(t);\
timer->dispose();}}}


#pragma PAGEDCODE
// This class will manage creation and 
// manipulation of driver Timers
class CTimer;
class CTimer
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
KTIMER Timer;
protected:
	CTimer(){};
	virtual ~CTimer(){};
public:
	PKTIMER getHandle(){return &Timer;};
	virtual BOOL set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc) {return FALSE;};
	virtual BOOL cancel() {return FALSE;};
	virtual VOID delay(ULONG Delay) {};
};

#endif//TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\usbdev.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 04.03.1999
// Change log:
//

#ifndef USB_DEV
#define USB_DEV

#include "wdmdev.h"
#include "debug.h"

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning (disable:4200)
#include <usbdi.h>
#include <usbdlib.h>
#pragma warning (default:4200)
#ifdef __cplusplus
}
#endif




// Type of request driver can construct
#define COMMAND_REQUEST		1
#define RESPONSE_REQUEST	2
#define INTERRUPT_REQUEST	3
// Default buffers' sizes (4k)
// This values will be used as a requests to the bus driver.
// It looks like bus driver will not accept values greater then these.
// It will complain with "invalid parameter" status.
// ??? Is this limitation of bus driver or our driver design?
#define DEFAULT_COMMAND_BUFFER_SIZE		0x100
#define DEFAULT_RESPONSE_BUFFER_SIZE	0x100
#define DEFAULT_INTERRUPT_BUFFER_SIZE	0x100
// If we set Xfer size greater then 256, bus driver crashes with GPF
// The problem still is under investigation...
#define GUR_MAX_TRANSFER_SIZE	256


#pragma LOCKEDCODE
// Power request callback
NTSTATUS onPowerRequestCompletion(IN PDEVICE_OBJECT DeviceObject,IN UCHAR MinorFunction,
					IN POWER_STATE PowerState,IN PVOID Context,IN PIO_STATUS_BLOCK IoStatus);
NTSTATUS onPowerIrpComplete(IN PDEVICE_OBJECT NullDeviceObject,IN PIRP Irp,IN PVOID Context);

#pragma PAGEDCODE
class CWDMDevice;

class CUSBDevice : public CWDMDevice
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
private:
	ULONG Idle_conservation;
	ULONG Idle_performance;

	// Max xfer size with our device
	ULONG m_MaximumTransferSize;
	
	// USB device endpoints
	USBD_PIPE_HANDLE m_ControlPipe;
	USBD_PIPE_HANDLE m_InterruptPipe;
	USBD_PIPE_HANDLE m_ResponsePipe;
	USBD_PIPE_HANDLE m_CommandPipe;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR m_DeviceDescriptor;
    // USB configuration handle and ptr for the configuration the
    // device is currently in
	USBD_CONFIGURATION_HANDLE			m_ConfigurationHandle;
    PUSB_CONFIGURATION_DESCRIPTOR		m_Configuration;
    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION m_Interface;

	//Bus drivers set the appropriate values in this structure in response
	//to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
	//alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES Capabilities;

	// used to save the currently-being-handled system-requested power irp request
    //PIRP PowerIrp;

	// Xfer buffers will be dynamically allocated at device start
    ULONG ResponseBufferLength;
    PVOID m_ResponseBuffer;// Bulk IN pipe
	LONG   Response_ErrorNum;

    ULONG CommandBufferLength;
    PVOID m_CommandBuffer;// Bulk OUT pipe
	LONG   Command_ErrorNum;

    ULONG InterruptBufferLength;
    PVOID m_InterruptBuffer;// Interrupt IN pipe
	LONG   Interrupt_ErrorNum;
public:	
	CUSBDevice();
	~CUSBDevice();
	virtual VOID dispose()
	{ 
		removeRef();
		if(!getRefCount()) self_delete();
		else
		{
			TRACE("FAILED TO DISPOSE OBJECT! refcount %x\n",getRefCount());
		}
	};
protected:
	virtual NTSTATUS	PnPHandler(LONG HandlerID,IN PIRP Irp);

	virtual NTSTATUS	PnP_HandleRemoveDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleStartDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleStopDevice(IN PIRP Irp);
	virtual NTSTATUS	PnP_StartDevice();
	virtual VOID		PnP_StopDevice();
	virtual NTSTATUS	PnP_HandleQueryRemove(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleCancelRemove(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryStop(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleCancelStop(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryRelations(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryInterface(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryCapabilities(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryResources(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryResRequirements(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryText(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleFilterResRequirements(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleReadConfig(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleWriteConfig(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleEject(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleSetLock(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryID(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryPnPState(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleQueryBusInfo(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleUsageNotification(IN PIRP Irp);
	virtual NTSTATUS	PnP_HandleSurprizeRemoval(IN PIRP Irp);

private:
	// USB device support functions
	PURB				buildBusTransferRequest(CIoPacket* Irp,UCHAR Command);
	VOID				finishBusTransferRequest(CIoPacket* Irp,UCHAR Command);

	NTSTATUS						QueryBusCapabilities(PDEVICE_CAPABILITIES Capabilities);
	PUSB_DEVICE_DESCRIPTOR			getDeviceDescriptor();
	PUSB_CONFIGURATION_DESCRIPTOR	getConfigurationDescriptor();
	PUSBD_INTERFACE_INFORMATION		activateInterface(PUSB_CONFIGURATION_DESCRIPTOR Configuration);
	NTSTATUS						disactivateInterface();
	// 
	NTSTATUS	resetDevice();
	NTSTATUS	resetPipe(IN USBD_PIPE_HANDLE Pipe);
	NTSTATUS	resetAllPipes();
	NTSTATUS	abortPipes();

	// Low level communication functions...
	virtual NTSTATUS   sendRequestToDevice(CIoPacket* Irp,PIO_COMPLETION_ROUTINE Routine);
	virtual NTSTATUS   sendRequestToDeviceAndWait(CIoPacket* Irp);
	// Handle requests for specific pipes..
	virtual NTSTATUS   readSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe);
	virtual NTSTATUS   writeSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe);
	
	// Support for the reader interface
	virtual NTSTATUS   send(CIoPacket* Irp);
	virtual NTSTATUS   sendAndWait(CIoPacket* Irp);
//	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
//	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);

public:
	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);
	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength);

	virtual NTSTATUS	pnpRequest(IN PIRP Irp);

#define _POWER_
#ifdef _POWER_
	// POWER MANAGEMENT FUNCTIONS
	virtual NTSTATUS	powerRequest(IN PIRP Irp);

	virtual VOID		activatePowerHandler(LONG HandlerID);
	virtual VOID		disActivatePowerHandler(LONG HandlerID);
	virtual NTSTATUS	callPowerHandler(LONG HandlerID,IN PIRP Irp);
	virtual BOOLEAN		setDevicePowerState(IN DEVICE_POWER_STATE DeviceState);
	virtual VOID	    onSystemPowerDown();
	virtual VOID		onSystemPowerUp();
	// Handlers
	virtual NTSTATUS	power_HandleSetPower(IN PIRP Irp);
	virtual NTSTATUS	power_HandleWaitWake(IN PIRP Irp);
	virtual NTSTATUS	power_HandleSequencePower(IN PIRP Irp);
	virtual NTSTATUS	power_HandleQueryPower(IN PIRP Irp);
	// callback

#endif
	// USB device specific implementations of system callbacks
	// They ovewrite base class defaults.
	virtual NTSTATUS open(PIRP Irp) 
	{
		TRACE("***** USB OPEN DEVICE *****\n");
		if (!NT_SUCCESS(acquireRemoveLock()))
			return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
	};//Create
    virtual NTSTATUS close(PIRP Irp)
	{ 
		TRACE("***** USB CLOSE DEVICE *****\n");
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
	};

	virtual NTSTATUS	deviceControl(IN PIRP Irp);
	virtual NTSTATUS    read(IN PIRP Irp);
	virtual NTSTATUS    write(IN PIRP Irp);

	virtual NTSTATUS	createDeviceObjectByName(PDEVICE_OBJECT* ppFdo);
};

#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\usbdev.cpp ===
#ifdef  USBREADER_PROJECT
#ifndef USBDEVICE_PROJECT
#define USBDEVICE_PROJECT
#endif
#endif

#ifdef  USBDEVICE_PROJECT
#pragma message("COMPILING USB DEVICE...")

#include "usbdev.h"
// GUID should be defined outside of any block!
#include "guid.h"

#include "thread.h"

#include "usbreader.h" //TO BE REMOVED

VOID onSendDeviceSetPowerComplete(PDEVICE_OBJECT junk, UCHAR fcn, POWER_STATE state, PPOWER_CONTEXT context, PIO_STATUS_BLOCK pstatus)
{// SendDeviceSetPowerComplete
        context->status = pstatus->Status;
        KeSetEvent(context->powerEvent, EVENT_INCREMENT, FALSE);
}// SendDeviceSetPowerComplete


#pragma PAGEDCODE
CUSBDevice::CUSBDevice()
{
        m_Status = STATUS_INSUFFICIENT_RESOURCES;
        INCLUDE_PNP_FUNCTIONS_NAMES();
        INCLUDE_POWER_FUNCTIONS_NAMES();
        m_Type  = USB_DEVICE;
        m_Flags |= DEVICE_SURPRISE_REMOVAL_OK; 

        m_MaximumTransferSize = GUR_MAX_TRANSFER_SIZE;

        CommandBufferLength       = DEFAULT_COMMAND_BUFFER_SIZE;
        ResponseBufferLength  = DEFAULT_RESPONSE_BUFFER_SIZE;
        InterruptBufferLength = DEFAULT_INTERRUPT_BUFFER_SIZE;


        // Register handlers processed by this device...
        activatePnPHandler(IRP_MN_START_DEVICE);

        activatePnPHandler(IRP_MN_QUERY_REMOVE_DEVICE);
        activatePnPHandler(IRP_MN_REMOVE_DEVICE);
        activatePnPHandler(IRP_MN_SURPRISE_REMOVAL);
        activatePnPHandler(IRP_MN_CANCEL_REMOVE_DEVICE);
        
        activatePnPHandler(IRP_MN_QUERY_STOP_DEVICE);
        activatePnPHandler(IRP_MN_CANCEL_STOP_DEVICE);
        activatePnPHandler(IRP_MN_STOP_DEVICE);

        activatePnPHandler(IRP_MN_QUERY_CAPABILITIES);

        // Register Power handlers processed by driver...
        activatePowerHandler(IRP_MN_SET_POWER);
        activatePowerHandler(IRP_MN_QUERY_POWER);
        TRACE("                         *** New USB device %8.8lX was created ***\n",this);
        m_Status = STATUS_SUCCESS;
}

#pragma PAGEDCODE
CUSBDevice::~CUSBDevice()
{
        waitForIdle();
        TRACE("                         USB device %8.8lX was destroyed ***\n",this);
}

// Function redirects all PnP requests
// This is main entry point for the system (after c wrapper).
// It handles locking device for a PnP requests and redirecting
// it to specific PnP handlers.
// In case of IRP_MN_REMOVE_DEVICE it leaves device locked till
// remove message recieved.
#pragma PAGEDCODE
NTSTATUS        CUSBDevice::pnpRequest(IN PIRP Irp)
{ 
NTSTATUS status;

        if (!NT_SUCCESS(acquireRemoveLock()))
        {
                TRACE("Failed to lock USB device...\n");
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
        ASSERT(stack->MajorFunction == IRP_MJ_PNP);

        ULONG fcn = stack->MinorFunction;
        if (fcn >= arraysize(PnPfcntab))
        {       // some function we don't know about
                TRACE("Unknown PnP function at USB device...\n");
                status = PnP_Default(Irp); 
                releaseRemoveLock();
                return status;
        }

#ifdef DEBUG
        TRACE("PnP request (%s) \n", PnPfcnname[fcn]);
#endif

        // Call real function to handle the request
        status = PnPHandler(fcn,Irp);

        // If we've got PnP request to remove->
        // Keep device locked to prevent futher connections.
        // Device will be unlocked and removed by driver later...
        if (fcn != IRP_MN_REMOVE_DEVICE)        releaseRemoveLock();
        if(!NT_SUCCESS(status))
        {
                if(status != STATUS_NOT_SUPPORTED)
                {
                        TRACE("\n******** PnP handler reported ERROR -> %x\n", status);
                }
        }
        return status;
}

#pragma PAGEDCODE
// Main redirector of all PnP handlers...
NTSTATUS        CUSBDevice::PnPHandler(LONG HandlerID,IN PIRP Irp)
{
        // If Handler is not registered...
        if (HandlerID >= arraysize(PnPfcntab))  return PnP_Default(Irp);
        if(!PnPfcntab[HandlerID])                               return PnP_Default(Irp);
        // Call registered PnP Handler...
        switch(HandlerID)
        {
        case IRP_MN_START_DEVICE:                       return PnP_HandleStartDevice(Irp);
                break;
        case IRP_MN_QUERY_REMOVE_DEVICE:        return PnP_HandleQueryRemove(Irp);
                break;
        case IRP_MN_REMOVE_DEVICE:                      return PnP_HandleRemoveDevice(Irp);
                break;
        case IRP_MN_CANCEL_REMOVE_DEVICE:       return PnP_HandleCancelRemove(Irp);
                break;
        case IRP_MN_STOP_DEVICE:                        return PnP_HandleStopDevice(Irp);
                break;
        case IRP_MN_QUERY_STOP_DEVICE:          return PnP_HandleQueryStop(Irp);
                break;
        case IRP_MN_CANCEL_STOP_DEVICE:         return PnP_HandleCancelStop(Irp);
                break;
        case IRP_MN_QUERY_DEVICE_RELATIONS: return PnP_HandleQueryRelations(Irp);
                break;
        case IRP_MN_QUERY_INTERFACE:            return PnP_HandleQueryInterface(Irp);
                break;
        case IRP_MN_QUERY_CAPABILITIES:         return PnP_HandleQueryCapabilities(Irp);
                break;
        case IRP_MN_QUERY_RESOURCES:            return PnP_HandleQueryResources(Irp);
                break;
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS: 
                                                                                return PnP_HandleQueryResRequirements(Irp);
                break;
        case IRP_MN_QUERY_DEVICE_TEXT:          return PnP_HandleQueryText(Irp);
                break;
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                                                                                return PnP_HandleFilterResRequirements(Irp);
                break;
        case 0x0E:                                                      return PnP_Default(Irp);
                break;
        case IRP_MN_READ_CONFIG:                        return PnP_HandleReadConfig(Irp);
                break;
        case IRP_MN_WRITE_CONFIG:                       return PnP_HandleWriteConfig(Irp);
                break;
        case IRP_MN_EJECT:                                      return PnP_HandleEject(Irp);
                break;
        case IRP_MN_SET_LOCK:                           return PnP_HandleSetLock(Irp);
                break;
        case IRP_MN_QUERY_ID:                           return PnP_HandleQueryID(Irp);
                break;
        case IRP_MN_QUERY_PNP_DEVICE_STATE:     return PnP_HandleQueryPnPState(Irp);
                break;
        case IRP_MN_QUERY_BUS_INFORMATION:      return PnP_HandleQueryBusInfo(Irp);
                break;
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:  return PnP_HandleUsageNotification(Irp);
                break;
        case IRP_MN_SURPRISE_REMOVAL:           return PnP_HandleSurprizeRemoval(Irp);
                break;
        }
        return PnP_Default(Irp);
}

#pragma PAGEDCODE
// Asks object to remove device
// Object itself will be removed at wrapper function
NTSTATUS CUSBDevice::PnP_HandleRemoveDevice(IN PIRP Irp)
{
        // Set device removal state
        m_RemoveLock.removing = TRUE;
        // Do any processing required for *us* to remove the device. This
        // would include completing any outstanding requests, etc.
        PnP_StopDevice();

        // Do not remove actually our device here!
        // It will be done automatically by PnP handler at basic class.

        // Let lower-level drivers handle this request. Ignore whatever
        // result eventuates.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = PnP_Default(Irp);
        // lower-level completed IoStatus already
        return status;
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleStartDevice(IN PIRP Irp)
{
        waitForIdleAndBlock();
        // First let all lower-level drivers handle this request. In this particular
        // sample, the only lower-level driver should be the physical device created
        // by the bus driver, but there could theoretically be any number of intervening
        // bus filter devices. Those drivers may need to do some setup at this point
        // in time before they'll be ready to handle non-PnP IRP's.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        if (!NT_SUCCESS(status))
        {
                TRACE("         ******* BUS DRIVER FAILED START REQUEST! %8.8lX ******",status);
                CLogger*   logger = kernel->getLogger();
                if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());

                return completeDeviceRequest(Irp, status, Irp->IoStatus.Information);
        }

        status = PnP_StartDevice();
        setIdle();

        return completeDeviceRequest(Irp, status, Irp->IoStatus.Information);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleStopDevice(IN PIRP Irp)
{
        PnP_StopDevice();
        m_Started = FALSE;
        // Let lower-level drivers handle this request. Ignore whatever
        // result eventuates.
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = PnP_Default(Irp);
        return status;
}


#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_StartDevice()
{       // StartDevice
NTSTATUS status = STATUS_SUCCESS;
        if(m_Started)
        {
                TRACE("##### Current device was already started!\n");
                ASSERT(!m_Started);
                return STATUS_DEVICE_BUSY;
        }

        __try
        {
                // Do all required processing to start USB device.
                // It will include getting Device and configuration descriptors
                // and selecting specific interface.
                // For now our device support only interface.
                // So, it will be activated at activateInterface().

                m_DeviceDescriptor = getDeviceDescriptor();
                if(!m_DeviceDescriptor)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("\nDeviceDescriptor %8.8lX\n",m_DeviceDescriptor);

                m_Configuration    = getConfigurationDescriptor();
                if(!m_Configuration)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("Configuration %8.8lX\n",m_Configuration);
                
                m_Interface                = activateInterface(m_Configuration);
                if(!m_Interface)
                {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                }

                TRACE("Selected interface %8.8lX\n\n",m_Interface);

                // Allocate Xfer buffers
                if(m_CommandPipe)
                {
                        TRACE("Allocating command buffer (length 0x%x)...\n",CommandBufferLength);
                        m_CommandBuffer   = memory->allocate(NonPagedPool, CommandBufferLength);
                        if(!m_CommandBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
                if(m_ResponsePipe)
                {
                        TRACE("Allocating response buffer (length 0x%x)...\n", ResponseBufferLength);
                        m_ResponseBuffer  = memory->allocate(NonPagedPool, ResponseBufferLength);
                        if(!m_ResponseBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
                if(m_InterruptPipe)
                {
                        TRACE("Allocating interrupt buffer (length 0x%x)...\n", InterruptBufferLength);
                        m_InterruptBuffer = memory->allocate(NonPagedPool, InterruptBufferLength);
                        if(!m_InterruptBuffer)
                        {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                                __leave;
                        }
                }
        }

        __finally
        {
                // Check memory allocations!
                if(!NT_SUCCESS(status))
                {
                        if(m_DeviceDescriptor)  memory->free(m_DeviceDescriptor);
                        if(m_Configuration)             memory->free(m_Configuration);
                        if(m_Interface)                 memory->free(m_Interface);
                        if(m_CommandBuffer)             memory->free(m_CommandBuffer);
                        if(m_ResponseBuffer)    memory->free(m_ResponseBuffer);
                        if(m_InterruptBuffer)   memory->free(m_InterruptBuffer);

                        m_DeviceDescriptor      = NULL;
                        m_Configuration         = NULL;
                        m_Interface                     = NULL;
                        m_CommandBuffer         = NULL;
                        m_ResponseBuffer        = NULL;
                        m_InterruptBuffer       = NULL;
                }
                else
                {
                        // Give chance inhereted devices to initialize...
                        onDeviceStart();

                        TRACE("USB device started successfully...\n\n");
                        // Device has been completely initialized and is ready to run.
                        m_Started = TRUE;
                }
        }
        return status;
}


#pragma PAGEDCODE
// This function used for both Stop and Remove PnP events
// It will undo everything what was done at StartDevice
VOID CUSBDevice::PnP_StopDevice()
{                                                       // StopDevice
        if (!m_Started) return; // device not started, so nothing to do

        TRACE("*** Stop USB Device %8.8lX requested... ***\n", this);


        onDeviceStop();
        // If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
        // This call will also close the pipes; if any user close calls get through,
        // they will be noops
        abortPipes();
        
        //We basically just tell USB this device is now 'unconfigured'
        if(!isSurprizeRemoved()) disactivateInterface();

        // Free resources allocated at startup
        m_ControlPipe   = NULL;
        m_InterruptPipe = NULL;
        m_ResponsePipe  = NULL;
        m_CommandPipe   = NULL;

        if(m_DeviceDescriptor)  memory->free(m_DeviceDescriptor);
        if(m_Configuration)             memory->free(m_Configuration);
        if(m_Interface)                 memory->free(m_Interface);

        if(m_CommandBuffer)             memory->free(m_CommandBuffer);
        if(m_ResponseBuffer)    memory->free(m_ResponseBuffer);
        if(m_InterruptBuffer)   memory->free(m_InterruptBuffer);

        TRACE("*** Device resources released ***\n");
        setIdle();

        m_Started = FALSE;

}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleQueryRemove(IN PIRP Irp)
{
        TRACE("********  QUERY REMOVAL ********\n");
        // Win98 doesn't check for open handles before allowing a remove to proceed,
        // and it may deadlock in IoReleaseRemoveLockAndWait if handles are still
        // open.

        if (isWin98() && m_DeviceObject->ReferenceCount)
        {
                TRACE("Failing removal query due to open handles\n");
                return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleCancelRemove(IN PIRP Irp)
{
        NTSTATUS status;

        status = forwardAndWait(Irp);
        ASSERT(NT_SUCCESS(status));
        
        Irp->IoStatus.Status = STATUS_SUCCESS;

        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);

}

NTSTATUS CUSBDevice::PnP_HandleQueryStop(IN PIRP Irp)
{
        TRACE("********  QUERY STOP ********\n");
        if(isDeviceLocked())
        {
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
        }

        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleCancelStop(IN PIRP Irp)
{
        TRACE("********  CANCEL STOP ********\n");
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        return completeDeviceRequest(Irp, Irp->IoStatus.Status,0);
}

NTSTATUS CUSBDevice::PnP_HandleQueryRelations(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryInterface(IN PIRP Irp)
{
        return PnP_Default(Irp);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::PnP_HandleQueryCapabilities(PIRP Irp)
{
        if(!Irp) return STATUS_INVALID_PARAMETER;
PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
PDEVICE_CAPABILITIES pdc = stack->Parameters.DeviceCapabilities.Capabilities;
        // Check to be sure we know how to handle this version of the capabilities structure
        if (pdc->Version < 1)   return PnP_Default(Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        NTSTATUS status = forwardAndWait(Irp);
        if (NT_SUCCESS(status))
        {                                               // IRP succeeded
                stack = irp->getCurrentStackLocation(Irp);
                pdc = stack->Parameters.DeviceCapabilities.Capabilities;
                if(!pdc) return STATUS_INVALID_PARAMETER;
                //if (m_Flags & DEVICE_SURPRISE_REMOVAL_OK)
                /*{     // Smartcard readers do not support it!
                        //if(!isWin98())        pdc->SurpriseRemovalOK = TRUE;
                }*/
                pdc->SurpriseRemovalOK = FALSE;
                m_DeviceCapabilities = *pdc;    // save capabilities for whoever needs to see them
                TRACE(" Device allows surprize removal - %s\n",(m_DeviceCapabilities.SurpriseRemovalOK?"YES":"NO"));
        }                               // IRP succeeded
        return completeDeviceRequest(Irp, status,Irp->IoStatus.Information);
}// HandleQueryCapabilities



NTSTATUS CUSBDevice::PnP_HandleQueryResources(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryResRequirements(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryText(IN PIRP Irp)
{
        return PnP_Default(Irp);
}

NTSTATUS CUSBDevice::PnP_HandleFilterResRequirements(IN PIRP Irp)
{
        TRACE("Default action for filtering resource requirements...");
        return PnP_Default(Irp);
}

NTSTATUS CUSBDevice::PnP_HandleReadConfig(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleWriteConfig(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleEject(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleSetLock(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryID(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryPnPState(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleQueryBusInfo(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleUsageNotification(IN PIRP Irp)
{
        return PnP_Default(Irp);
}
NTSTATUS CUSBDevice::PnP_HandleSurprizeRemoval(IN PIRP Irp)
{
        TRACE("********  SURPRIZE REMOVAL ********\n");
        return PnP_Default(Irp);
}


// Functions allocate and initialize USB request block.
// It can be used for read/write request on specific Pipe.
// Allocated URB should be free later upon completing of the request.
PURB    CUSBDevice::buildBusTransferRequest(CIoPacket* Irp,UCHAR Command)
{
USHORT  Size;
ULONG   BufferLength;
PURB    Urb = NULL;
PVOID   pBuffer;
ULONG   TransferFlags;
IN USBD_PIPE_HANDLE Pipe = NULL;
ULONG   TransferLength;
        
        if(!Irp) return NULL;
        if(Command == COMMAND_REQUEST)
        {
                BufferLength = CommandBufferLength;
                pBuffer = m_CommandBuffer;
                TransferFlags = USBD_SHORT_TRANSFER_OK;
                Pipe = m_CommandPipe;
                TransferLength = Irp->getWriteLength();
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Command transfer requested...\n");
        }
        else
        if(Command == RESPONSE_REQUEST)
        {
                BufferLength = ResponseBufferLength;
                pBuffer = m_ResponseBuffer;
                TransferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
                Pipe = m_ResponsePipe;
                TransferLength = BufferLength;
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Response transfer requested with number of expected bytes %x\n",Irp->getReadLength());
        }
        else
        if(Command == INTERRUPT_REQUEST)
        {
                BufferLength  = InterruptBufferLength;
                pBuffer = m_InterruptBuffer;
                TransferFlags = USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK;
                Pipe = m_InterruptPipe;
                TransferLength = BufferLength;
                if(!Pipe || !TransferLength)
                {
                        TRACE("##### Requested Pipe or TransferLength == 0 for the requested command %d ...\n", Command);
                        return NULL;
                }
                TRACE("Interrupt transfer requested...\n");
        }
        else
        {
                TRACE("Incorrect command was requested %d", Command);
                return NULL;
        }

        Size = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
        Urb = (PURB) memory->allocate(NonPagedPool, Size);
        if (Urb) 
        {
                memory->zero(Urb, Size);
                memory->zero(pBuffer, BufferLength);
                if(Command == COMMAND_REQUEST) 
                {
                        memory->copy(pBuffer,Irp->getBuffer(), TransferLength);
                        ((PUCHAR)pBuffer)[TransferLength] = 0x00;
                        
                        //TRACE("Command ");
                        //TRACE_BUFFER(pBuffer,TransferLength);
                }

                UsbBuildInterruptOrBulkTransferRequest(Urb,(USHORT) Size,
                                               Pipe,
                                               pBuffer,
                                               NULL,
                                               TransferLength,
                                                                                           TransferFlags,
                                                                                           NULL);
        }
        else
        {
                TRACE("##### ERROR: failed to allocate URB request...\n");
        }

        return Urb;
}

VOID    CUSBDevice::finishBusTransferRequest(CIoPacket* Irp,UCHAR Command)
{
ULONG   BufferLength;
PVOID   pBuffer;
ULONG_PTR   info;

        if(!Irp)
        {
                TRACE(" **** Invalid parameter -> Irp\n");
                return;
        }

        if(!(info = Irp->getInformation())) 
        {
                TRACE(" **** There is no reported information\n");
                return;
        }
        if(Command == COMMAND_REQUEST)
        {
                BufferLength = CommandBufferLength;
                pBuffer      = m_CommandBuffer;
                TRACE("         Command transfer finished with length %d\n",info);
        }
        else
        if(Command == RESPONSE_REQUEST)
        {
                ULONG Length = Irp->getReadLength();
                BufferLength = (ULONG)(info>ResponseBufferLength?ResponseBufferLength:info);
                BufferLength = BufferLength>Length?Length:BufferLength;

                pBuffer = m_ResponseBuffer;
                TRACE("Bus Driver replied with length %d\n",info);
                memory->copy(Irp->getBuffer(),pBuffer, BufferLength);
                if(BufferLength!=info)
                {
                        TRACE("##### Response Buffer short! Buffer length %x  Reply length %x \n",ResponseBufferLength,info);
                }
                //TRACE("Response ");
                //TRACE_BUFFER(pBuffer,BufferLength);
        }
        else
        if(Command == INTERRUPT_REQUEST)
        {
                ULONG Length = Irp->getReadLength();
                BufferLength = (ULONG)(info>InterruptBufferLength?InterruptBufferLength:info);
                BufferLength = BufferLength>Length?Length:BufferLength;
                pBuffer = m_InterruptBuffer;

                TRACE("Bus Driver replied with length %d\n",info);
                memory->copy(Irp->getBuffer(),pBuffer, BufferLength);
                if(BufferLength!=info)
                {
                        TRACE("##### Interrupt Buffer short! Buffer length %x  Reply length %x \n",InterruptBufferLength,info);
                }
                TRACE("Interrupt ");
                TRACE_BUFFER(pBuffer,BufferLength);
        }
        else
        {
                TRACE("Incorrect command was requested %d", Command);
                return;
        }
}


//    This function generates an internal IRP from this driver to the PDO
//    to obtain information on the Physical Device Object's capabilities.
//    We are most interested in learning which system power states
//    are to be mapped to which device power states for honoring IRP_MJ_SET_POWER Irps.
#pragma PAGEDCODE
NTSTATUS        CUSBDevice::QueryBusCapabilities(PDEVICE_CAPABILITIES Capabilities)
{
NTSTATUS status;
CIoPacket* IoPacket;

    PAGED_CODE();

        TRACE("Quering USB bus capabilities...\n");
    // Build an IRP for us to generate an internal query request to the PDO
        IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }
        IoPacket->setTimeout(getCommandTimeout());

        IoPacket->buildStack(getSystemObject(),IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES, 0,Capabilities);
        status = sendRequestToDeviceAndWait(IoPacket);

        DISPOSE_OBJECT(IoPacket);
    return status;
}

#pragma PAGEDCODE
// Function gets device descriptor from the USB bus driver
PUSB_DEVICE_DESCRIPTOR  CUSBDevice::getDeviceDescriptor()
{
PUSB_DEVICE_DESCRIPTOR Descriptor = NULL;
PURB Urb;
ULONG Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket = NULL;

        TRACE("Getting USB device descriptor...\n");
        __try
        {
                Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                if(!Urb)        __leave;
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                Size = sizeof(USB_DEVICE_DESCRIPTOR);
                Descriptor = (PUSB_DEVICE_DESCRIPTOR)memory->allocate(NonPagedPool,Size);
                if(!Descriptor) __leave;
                UsbBuildGetDescriptorRequest(Urb,
                                                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                                                         0,
                                                                         0,
                                                                         Descriptor,
                                                                         NULL,
                                                                         Size,
                                                                         NULL);
                
                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (NT_SUCCESS(Status)) 
                {
                        TRACE("Device Descriptor = %x, len %x\n",
                                                        Descriptor,
                                                        Urb->UrbControlDescriptorRequest.TransferBufferLength);

                        TRACE("\nGemplus USB SmartCard Device Descriptor:\n");
                        TRACE("-------------------------\n");
                        TRACE("bLength 0x%x\n", Descriptor->bLength);
                        TRACE("bDescriptorType 0x%x\n", Descriptor->bDescriptorType);
                        TRACE("bcdUSB 0x%x\n", Descriptor->bcdUSB);
                        TRACE("bDeviceClass 0x%x\n", Descriptor->bDeviceClass);
                        TRACE("bDeviceSubClass 0x%x\n", Descriptor->bDeviceSubClass);
                        TRACE("bDeviceProtocol 0x%x\n", Descriptor->bDeviceProtocol);
                        TRACE("bMaxPacketSize0 0x%x\n", Descriptor->bMaxPacketSize0);
                        TRACE("idVendor 0x%x\n", Descriptor->idVendor);
                        TRACE("idProduct 0x%x\n", Descriptor->idProduct);
                        TRACE("bcdDevice 0x%x\n", Descriptor->bcdDevice);
                        TRACE("iManufacturer 0x%x\n", Descriptor->iManufacturer);
                        TRACE("iProduct 0x%x\n", Descriptor->iProduct);
                        TRACE("iSerialNumber 0x%x\n", Descriptor->iSerialNumber);
                        TRACE("bNumConfigurations 0x%x\n", Descriptor->bNumConfigurations);
                        TRACE("-------------------------\n");
                }
                else 
                {
                        TRACE("#### ERROR: Failed to get device descriptor...\n");
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                }
                __leave;;
        }

        __finally
        {
                if(Urb)                 memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(Descriptor) memory->free(Descriptor);
                        Descriptor = NULL;
                }
                else
                {
                        if(Descriptor)  TRACE("*** Succeed to get device descriptor ***\n");
                }
        }
        return Descriptor;
}

// Function gets confuguration descriptor
PUSB_CONFIGURATION_DESCRIPTOR   CUSBDevice::getConfigurationDescriptor()
{
PUSB_CONFIGURATION_DESCRIPTOR Descriptor = NULL;
PURB Urb;
ULONG Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket = NULL;

        TRACE("Getting USB configuration descriptor...\n");

        __try
        {
                Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                if(!Urb)        __leave;

                Size = sizeof(USB_CONFIGURATION_DESCRIPTOR);  
                while(TRUE)
                {
                        IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                        if(!ALLOCATED_OK(IoPacket)) __leave;
                        IoPacket->setTimeout(getCommandTimeout());

                        Descriptor = (PUSB_CONFIGURATION_DESCRIPTOR)memory->allocate(NonPagedPool,Size);
                        if(!Descriptor) __leave;
   
                        UsbBuildGetDescriptorRequest(Urb,
                                                                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                                                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                                                                 0,
                                                                                 0,
                                                                                 Descriptor,
                                                                                 NULL,
                                                                                 Size,
                                                                                 NULL);

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (Urb->UrbControlDescriptorRequest.TransferBufferLength>0 &&
                                        Descriptor->wTotalLength > Size) 
                        {
                                // If bus driver truncated his descriptor-> resend command with
                                // bus return value
                                Size = Descriptor->wTotalLength;
                                TRACE("Descriptor length retrieved - 0x%x! Getting USB device configuration... ***\n",Size);
                                IoPacket->dispose();
                                IoPacket = NULL;
                                memory->free(Descriptor);
                                Descriptor = NULL;
                                Status = STATUS_INSUFFICIENT_RESOURCES;
                        } 
                        else    break;
                }

                if(NT_SUCCESS(Status))
                {
                        TRACE("\nUSB device Configuration Descriptor = %x, len %x\n",Descriptor,
                                                        Urb->UrbControlDescriptorRequest.TransferBufferLength);
                        TRACE("---------\n");
                        TRACE("bLength 0x%x\n", Descriptor->bLength);
                        TRACE("bDescriptorType 0x%x\n", Descriptor->bDescriptorType);
                        TRACE("wTotalLength 0x%x\n", Descriptor->wTotalLength);
                        TRACE("bNumInterfaces 0x%x\n", Descriptor->bNumInterfaces);
                        TRACE("bConfigurationValue 0x%x\n", Descriptor->bConfigurationValue);
                        TRACE("iConfiguration 0x%x\n", Descriptor->iConfiguration);
                        TRACE("bmAttributes 0x%x\n", Descriptor->bmAttributes);
                        TRACE("MaxPower 0x%x\n", Descriptor->MaxPower);
                        TRACE("---------\n");
                }
                else
                {
                        TRACE("*** Failed to get configuration descriptor ***\n");
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                }
                __leave;
        }

        __finally
        {
                if(Urb)                 memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(Descriptor) memory->free(Descriptor);
                        Descriptor = NULL;
                }
                else
                {
                        if(Descriptor)  TRACE("*** Succeed to get configuration descriptor ***\n");
                }
        }
    return Descriptor;
}

#pragma PAGEDCODE
// Function gets confuguration descriptor
PUSBD_INTERFACE_INFORMATION     CUSBDevice::activateInterface(PUSB_CONFIGURATION_DESCRIPTOR Configuration)
{
PURB Urb = NULL;
USHORT Size;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
USHORT j;

PUSBD_INTERFACE_LIST_ENTRY InterfaceList;
PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor = NULL;
PUSBD_INTERFACE_INFORMATION Interface = NULL;
PUSBD_INTERFACE_INFORMATION UsbInterface = NULL;
ULONG NumberOfInterfaces;
CIoPacket* IoPacket = NULL;

        TRACE("Activating USB device configuration %8.8lX, setting device interface...\n",Configuration);

        if(!Configuration) return NULL;
    // get this from the config descriptor
    NumberOfInterfaces = Configuration->bNumInterfaces;

    // We only support one interface!
        TRACE("\nNumber of interfaces at the configuration - %d \n",NumberOfInterfaces);
        
        // USBD_ParseConfigurationDescriptorEx searches a given configuration
        // descriptor and returns a pointer to an interface that matches the 
        //  given search criteria. 
        // We only support one interface on this device
        if(NumberOfInterfaces==1)
        {
                InterfaceDescriptor = 
                        USBD_ParseConfigurationDescriptorEx(
                                Configuration,
                                Configuration,
                                0, // intreface number, don't care
                                -1, // alt setting, don't care
                                -1, // class, don't care
                                -1, // subclass, don't care
                                -1);// protocol, don't care
        }
        else
        {
                if(NumberOfInterfaces>1)
                {
                        TRACE("Trying next to get interface descriptor for KEYBOARD READER...\n");
                        InterfaceDescriptor = 
                                USBD_ParseConfigurationDescriptorEx(
                                        Configuration,
                                        Configuration,
                                        1, // intreface number 1 for keyboard reader
                                        -1, // alt setting, don't care
                                        -1, // class, don't care
                                        -1, // subclass, don't care
                                        -1);// protocol, don't care
                }
        }

        if (!InterfaceDescriptor) 
        {
                TRACE("##### ERROR: Failed to get interface description...\n");
                return NULL;
        }
    
        InterfaceList = (PUSBD_INTERFACE_LIST_ENTRY)memory->allocate(NonPagedPool,sizeof(USBD_INTERFACE_LIST_ENTRY) * (NumberOfInterfaces+1));
        if(!InterfaceList)
        {
                TRACE("Failed to alloacte memory for the interfacelist...\n");
                return NULL;
        }

        // We support only one interface after current!
    InterfaceList->InterfaceDescriptor = InterfaceDescriptor;
    InterfaceList++; 
    InterfaceList->InterfaceDescriptor = NULL;
    InterfaceList--; 

        __try
        {
                //For now our device support only one interface.
                Urb = USBD_CreateConfigurationRequestEx(Configuration, InterfaceList);
                if(!Urb)        __leave;
   
                Interface = &Urb->UrbSelectConfiguration.Interface;
                TRACE("Pipe MaximumTransferSize set to 0x%x\n",m_MaximumTransferSize);

                for (ULONG i=0; i< Interface->NumberOfPipes; i++) 
                {
                        // perform any pipe initialization here
                        Interface->Pipes[i].MaximumTransferSize = m_MaximumTransferSize;
                        Interface->Pipes[i].PipeFlags = 0;
                }

                TRACE("Building select configuration request...\n");    
                Size = sizeof(struct _URB_SELECT_CONFIGURATION);
                UsbBuildSelectConfigurationRequest(Urb,Size, Configuration);
                
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to Select configuration, ret 0x%x...\n",Status);
                        CLogger*   logger = kernel->getLogger();
                        if(logger) logger->logEvent(GRCLASS_BUS_DRIVER_FAILED_REQUEST,getSystemObject());
                        __leave;
                }

                // Save the configuration handle for this device
                // Well... It is not really nice to initialize it here, but...
                m_ConfigurationHandle = Urb->UrbSelectConfiguration.ConfigurationHandle;
                TRACE("Device Configuration handle 0x%x\n",m_ConfigurationHandle);    

                UsbInterface = (PUSBD_INTERFACE_INFORMATION)memory->allocate(NonPagedPool,Interface->Length);
                if (!UsbInterface) 
                {
                        TRACE(("##### ERROR: Failed to allocate memory for the UsbInterface\n"));
                        __leave;
                }
                // save a copy of the interface information returned
                memory->copy(UsbInterface, Interface, Interface->Length);
                
                TRACE("\nGemplus USB device interface:\n");    
                // Dump the interface to the debugger
                TRACE("---------\n");
                TRACE("NumberOfPipes 0x%x\n", UsbInterface->NumberOfPipes);
                TRACE("Length 0x%x\n", UsbInterface->Length);
                TRACE("Alt Setting 0x%x\n", UsbInterface->AlternateSetting);
                TRACE("Interface Number 0x%x\n", UsbInterface->InterfaceNumber);
                TRACE("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                UsbInterface->Class,
                                UsbInterface->SubClass,
                                UsbInterface->Protocol);
                TRACE("---------\n");

                // Dump the pipe info
                for (j=0; j<Interface->NumberOfPipes; j++) 
                {
                PUSBD_PIPE_INFORMATION pipeInformation;
                        pipeInformation = &UsbInterface->Pipes[j];

                        TRACE("\nGemplus USB device pipe[%d] ",j);    
                        if(pipeInformation->PipeType==UsbdPipeTypeBulk)
                        { 
                                if(pipeInformation->EndpointAddress&0x80)
                                {
                                        TRACE(("(Bulk Response Pipe):\n"));
                                        m_ResponsePipe = pipeInformation->PipeHandle;
                                        TRACE("m_ResponsePipe 0x%x\n", m_ResponsePipe);
                                }
                                else
                                {
                                        TRACE("(Bulk Command pipe):\n");
                                        m_CommandPipe = pipeInformation->PipeHandle;
                                        TRACE("m_CommandPipe 0x%x\n", m_CommandPipe);
                                }
                        }
                        else
                        {
                                if(pipeInformation->PipeType==UsbdPipeTypeInterrupt)
                                {
                                        if(pipeInformation->EndpointAddress&0x80)
                                        {
                                                TRACE(("(Interrupt Response Pipe):\n"));
                                                m_InterruptPipe = pipeInformation->PipeHandle;
                                                TRACE("m_InterruptPipe 0x%x\n", m_InterruptPipe);
                                        }
                                        else
                                        {
                                                TRACE(("(Unexpected Interrupt OUT pipe):\n"));
                                                TRACE("Unexpected pipe 0x%x\n", pipeInformation);
                                        }
                                }
                                else
                                {
                                        TRACE("Unexpected pipe type 0x%x\n", pipeInformation);
                                }
                        }
                        TRACE("---------\n");
                        TRACE("PipeType 0x%x\n", pipeInformation->PipeType);
                        TRACE("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress);
                        TRACE("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize);
                        TRACE("Interval 0x%x\n", pipeInformation->Interval);
                        TRACE("Handle 0x%x\n", pipeInformation->PipeHandle);
                        TRACE("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize);
                }
                TRACE("---------\n");
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                if(InterfaceList)       memory->free(InterfaceList);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        if(UsbInterface) memory->free(UsbInterface);
                        UsbInterface = NULL;
                }
                else
                {
                        if(UsbInterface)        TRACE("*** Succeed to set UsbInterface ***\n");
                }
        }
    return UsbInterface; 
}

#pragma PAGEDCODE
// Function gets confuguration descriptor
NTSTATUS        CUSBDevice::disactivateInterface()
{
PURB Urb = NULL;
USHORT Size;
NTSTATUS Status = STATUS_SUCCESS;
CIoPacket* IoPacket;

        TRACE("Disactivating USB device interface...\n");
        Size = sizeof(struct _URB_SELECT_CONFIGURATION);
    Urb = (PURB)memory->allocate(NonPagedPool,Size);
        if(!Urb)
        {
                TRACE("##### ERROR: Failed to create disable configuration request...\n");
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        //UsbBuildSelectConfigurationRequest(Urb,Size, NULL);
    (Urb)->UrbHeader.Function =  URB_FUNCTION_SELECT_CONFIGURATION;
    (Urb)->UrbHeader.Length = Size;
    (Urb)->UrbSelectConfiguration.ConfigurationDescriptor = NULL;
        
        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to disable device interface..., ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to disactivateInterface() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to disactivateInterface() ***\n");
                }
        }
    return Status;
}

#pragma PAGEDCODE
// Function resets specified pipe
NTSTATUS        CUSBDevice::resetPipe(IN USBD_PIPE_HANDLE Pipe)
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket;

        TRACE("Resetting USB device pipe %8.8lX...\n",Pipe);
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
    Urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    Urb->UrbPipeRequest.PipeHandle = Pipe;

        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to reset Pipe, ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to resetPipe() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to resetPipe() ***\n");
                }
        }
    return Status;
}

#pragma PAGEDCODE
// Function resets specified pipe
NTSTATUS        CUSBDevice::resetDevice()
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
CIoPacket* IoPacket;

        TRACE("Resetting USB device...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Device reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

        __try
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) __leave;
                IoPacket->setTimeout(getCommandTimeout());

                IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_RESET_PORT,Urb);
                Status = sendRequestToDeviceAndWait(IoPacket);
                if (!NT_SUCCESS(Status)) 
                {
                        TRACE("##### ERROR: Failed to reset Device, ret %x...\n",Status);
                }
                __leave;
        }
        __finally
        {
                if(Urb) memory->free(Urb);
                DISPOSE_OBJECT(IoPacket);
                if (!NT_SUCCESS(Status))
                {
                        TRACE("*** Failed to resetPipe() %8.8lX ***\n",Status);
                }
                else
                {
                        TRACE("*** Succeed to resetPipe() ***\n");
                }
        }
    return Status;
}


//      Called as part of sudden device removal handling.
//  Cancels any pending transfers for all open pipes. 
//      If any pipes are still open, call USBD with URB_FUNCTION_ABORT_PIPE
//      Also marks the pipe 'closed' in our saved  configuration info.
NTSTATUS        CUSBDevice::abortPipes()
{
PURB Urb = NULL;
NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
PUSBD_PIPE_INFORMATION Pipe;
CIoPacket* IoPacket;
        
        TRACE("Aborting all USB device pipes...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    for (USHORT i=0; i<m_Interface->NumberOfPipes; i++) 
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) break;
                IoPacket->setTimeout(getCommandTimeout());
        
                Pipe =  &m_Interface->Pipes[i]; // PUSBD_PIPE_INFORMATION  PipeInfo;

                if ( Pipe->PipeFlags ) 
                { // we set this if open, clear if closed
                        Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
                        Urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                        Urb->UrbPipeRequest.PipeHandle = Pipe->PipeHandle;

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (!NT_SUCCESS(Status)) 
                        {
                                TRACE("##### ERROR: Failed to abort Pipe %d\n",i);
                        }
                        Pipe->PipeFlags = FALSE; // mark the pipe 'closed'
                }
                DISPOSE_OBJECT(IoPacket);
        }

        if(Urb) memory->free(Urb);
        TRACE("**** Interface' pipes closed ****\n");
    return STATUS_SUCCESS;;
}

NTSTATUS        CUSBDevice::resetAllPipes()
{
PURB Urb = NULL;
NTSTATUS Status;
PUSBD_PIPE_INFORMATION Pipe;
CIoPacket* IoPacket;

        TRACE("Resetting all USB device pipes...\n");
    Urb = (PURB)memory->allocate(NonPagedPool,sizeof(struct _URB_PIPE_REQUEST));
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe reset...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }

    for (USHORT i=0; i<m_Interface->NumberOfPipes; i++) 
        {
                IoPacket = new (NonPagedPool) CIoPacket(m_pLowerDeviceObject->StackSize);
                if(!ALLOCATED_OK(IoPacket)) break;
                IoPacket->setTimeout(getCommandTimeout());

                Pipe =  &m_Interface->Pipes[i]; // PUSBD_PIPE_INFORMATION  PipeInfo;
                if ( Pipe->PipeFlags ) 
                { // we set this if open, clear if closed
                        Urb->UrbHeader.Length = sizeof (struct _URB_PIPE_REQUEST);
                        Urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
                        Urb->UrbPipeRequest.PipeHandle = Pipe->PipeHandle;

                        IoPacket->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
                        Status = sendRequestToDeviceAndWait(IoPacket);
                        if (!NT_SUCCESS(Status)) 
                        {
                                TRACE("##### ERROR: Failed to abort Pipe %d\n",i);
                        }
                        Pipe->PipeFlags = FALSE; // mark the pipe 'closed'
                }
                DISPOSE_OBJECT(IoPacket);
        }

        if(Urb) memory->free(Urb);
        TRACE(("**** Interface pipes were resetted ****\n"));
    return STATUS_SUCCESS;;
}

// Overwrite base class virtual functions
//Handle IRP_MJ_DEVICE_CONTROL request
NTSTATUS        CUSBDevice::deviceControl(IN PIRP Irp)
{
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
ULONG code      = stack->Parameters.DeviceIoControl.IoControlCode;
//ULONG outlength = stack->Parameters.DeviceIoControl.OutputBufferLength;
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;

        TRACE("IRP_MJ_DEVICE_CONTROL\n");
        //switch (code)
        {                                               // process control operation
        //default:
                TRACE("INVALID_DEVICE_REQUEST\n");
                status = STATUS_INVALID_DEVICE_REQUEST;
        }

        releaseRemoveLock();

        return completeDeviceRequest(Irp, status, info);
}

NTSTATUS        CUSBDevice::read(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
CIoPacket* IoPacket;
        
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        
        TRACE("---- Read request ----\n");

        if(!m_ResponsePipe)
        {
                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_REQUEST, 0);
        }

        if(!NT_SUCCESS(status = waitForIdleAndBlock()))
        {
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        if(Response_ErrorNum)
        {       
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
        }

        IoPacket = new (NonPagedPool) CIoPacket(Irp);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                setIdle();
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
        }

        status = readSynchronously(IoPacket,m_ResponsePipe);

        TRACE("---- Read completed ----\n");
        status = completeDeviceRequest(IoPacket->getIrpHandle(), status, IoPacket->getInformation());

        DISPOSE_OBJECT(IoPacket);

        setIdle();
        releaseRemoveLock();
        return status;
}

NTSTATUS        CUSBDevice::write(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
CIoPacket* IoPacket;
        
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if (!NT_SUCCESS(acquireRemoveLock()))   return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        
        TRACE("---- Write request ----\n");

        if(!m_CommandPipe)
        {
                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_REQUEST, 0);
        }

        if(!NT_SUCCESS(status = waitForIdleAndBlock()))
        {
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }
        if(Command_ErrorNum)
        {       
                NTSTATUS res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
        }

        IoPacket = new (NonPagedPool) CIoPacket(Irp);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                releaseRemoveLock();
                return completeDeviceRequest(Irp, STATUS_INSUFFICIENT_RESOURCES, 0);
        }
        
    status = writeSynchronously(IoPacket,m_CommandPipe);
  
        releaseRemoveLock();
        TRACE("---- Write completed ----\n");
        status = completeDeviceRequest(IoPacket->getIrpHandle(), status, IoPacket->getInformation());

        DISPOSE_OBJECT(IoPacket);

    setIdle();
        releaseRemoveLock();
        return status;
}


NTSTATUS        CUSBDevice::sendRequestToDevice(CIoPacket* IoPacket,PIO_COMPLETION_ROUTINE Routine)
{
        if(!IoPacket) return STATUS_INVALID_PARAMETER;
        IoPacket->copyStackToNext();
        if(Routine) IoPacket->setCompletion(Routine);
        else        IoPacket->setDefaultCompletionFunction();
        return system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
};

// Send request to low level driver and wait for reply
// Current IRP will not be completed, so we can process it and
// complete later. 
// See also description of send() function.
NTSTATUS        CUSBDevice::sendRequestToDeviceAndWait(CIoPacket* IoPacket)
{ // Send request to low level and wait for a reply
NTSTATUS status;
        TRACE("sendAndWait...\n");
        if(!IoPacket) return STATUS_INVALID_PARAMETER;
        IoPacket->setStackDefaults();
        status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
        if(status == STATUS_PENDING)
        {
                TRACE("Waiting for the bus driver to complete...\n");
                ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
                status = IoPacket->waitForCompletion();
                TRACE("Request completed with status %x\n",status);
        }
        return status;
};


NTSTATUS   CUSBDevice::send(CIoPacket* packet)
{
NTSTATUS status;
        if(!packet) return STATUS_INVALID_PARAMETER;
        __try
        {
                if(packet->getMajorIOCtl()==IRP_MJ_READ)
                {
                        if(!m_ResponsePipe)
                        {
                                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }
                        status = readSynchronously(packet,m_ResponsePipe);
                }
                else
                {
                        if(!m_CommandPipe)
                        {
                                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }
                        status = writeSynchronously(packet,m_CommandPipe);
                }
                __leave;
        }
        __finally
        {
        }
        return status;
};

NTSTATUS   CUSBDevice::sendAndWait(CIoPacket* packet)
{
NTSTATUS status = STATUS_SUCCESS;
        if(!packet) return STATUS_INVALID_PARAMETER;
        __try
        {               
                if(packet->getMajorIOCtl()==IRP_MJ_READ)
                {
                        TRACE("---- Packet Read request ----\n");
                        if(!m_ResponsePipe)
                        {
                                TRACE("#### ERROR: Response Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }

                        status = readSynchronously(packet,m_ResponsePipe);
                        TRACE("---- Packet Read completed ----\n");
                }
                else
                {
                        TRACE("---- Packet Write request ----\n");
                        if(!m_CommandPipe)
                        {
                                TRACE("#### ERROR: Command Pipe is not ready yet!...\n");
                                status = STATUS_INVALID_DEVICE_REQUEST;
                                __leave;
                        }

                        status = writeSynchronously(packet,m_CommandPipe);

                        TRACE("---- Packet Write completed ----\n");
                        if(!NT_SUCCESS(status))
                        {
                                TRACE("writeSynchronously reported error %x\n", status);
                        }
                }
                __leave;
        }
        __finally
        {
        }
        return status;
};

NTSTATUS        CUSBDevice::readSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe)
{
NTSTATUS ntStatus = STATUS_SUCCESS;
PURB Urb = NULL;
NTSTATUS Status;
        if(!Irp) return STATUS_INVALID_PARAMETER;
        
        if(Pipe != m_ResponsePipe && Pipe != m_InterruptPipe)
        {
                TRACE("##### ERROR: Invalid device Pipe requested!...\n");
                return STATUS_INVALID_DEVICE_REQUEST;
        }
        Urb = buildBusTransferRequest(Irp,RESPONSE_REQUEST);
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe read...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }
        Irp->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
        Status = sendRequestToDeviceAndWait(Irp);
        if (!NT_SUCCESS(Status)) 
        {
                TRACE("##### ERROR: Bus driver reported error 0x%x\n",Status);
                Response_ErrorNum++;
                Irp->setInformation(0);
        }
        else
        {

                Irp->setInformation(Urb->UrbBulkOrInterruptTransfer.TransferBufferLength);
                finishBusTransferRequest(Irp,RESPONSE_REQUEST);
        }

        USBD_STATUS urb_status = URB_STATUS(Urb);
        TRACE("URB reports status %8.8lX\n",urb_status);

        memory->free(Urb);
        return Status;
}

NTSTATUS        CUSBDevice::writeSynchronously(CIoPacket* Irp,IN USBD_PIPE_HANDLE Pipe)
{
NTSTATUS ntStatus = STATUS_SUCCESS;
PURB Urb = NULL;
NTSTATUS Status;
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if(Pipe != m_CommandPipe)
        {
                TRACE("##### ERROR: Invalid device Pipe requested!...\n");
                return STATUS_INVALID_DEVICE_REQUEST;
        }

        Urb = buildBusTransferRequest(Irp,COMMAND_REQUEST);
        if (!Urb) 
        {
                TRACE("#### ERROR: Failed to allocate Urb at Pipe read...\n");
                return STATUS_INSUFFICIENT_RESOURCES; 
        }
        Irp->buildStack(getSystemObject(),IRP_MJ_INTERNAL_DEVICE_CONTROL, 0, IOCTL_INTERNAL_USB_SUBMIT_URB,Urb);
        Status = sendRequestToDeviceAndWait(Irp);
        if (!NT_SUCCESS(Status)) 
        {
                TRACE("##### ERROR: Bus driver reported error %8.8lX\n",Status);
                Command_ErrorNum++;
        }
        else
        {
                finishBusTransferRequest(Irp,COMMAND_REQUEST);
        }

        USBD_STATUS urb_status = URB_STATUS(Urb);
        TRACE("                 URB reports status %8.8lX\n",urb_status);

        
        Irp->setInformation(0);
        memory->free(Urb);
        return Status;
}


NTSTATUS   CUSBDevice::writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
{
NTSTATUS status;
CIoPacket* IoPacket;
        if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;

        if(Response_ErrorNum || Command_ErrorNum)
        {       
                TRACE("======= RESETTING ERROR CONDITIONS! =========\n");
                NTSTATUS res_status = resetDevice();
                if(NT_SUCCESS(res_status))
                {
                        Command_ErrorNum = 0;
                        Response_ErrorNum = 0;
                }
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET DEVICE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }
                /*
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET RESPONSE PIPE! =========\n");
                        resetDevice();

                        //return STATUS_INVALID_DEVICE_STATE;
                }

                res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET COMMAND PIPE! =========\n");
                        //return STATUS_INVALID_DEVICE_STATE;
                        res_status = resetDevice();
                        if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                        else
                        {
                                *pReplyLength = 0;
                                TRACE("======= FAILED TO RESET DEVICE! =========\n");
                                return STATUS_INVALID_DEVICE_STATE;
                        }
                }
                */
        }

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());

        TRACE("IoPacket with device %x\n",getSystemObject());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
        IoPacket->setWriteLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("                 USB sendAndWait()...\n");
        status = sendAndWait(IoPacket);
        TRACE("                 USB writeAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        // Ignore bus driver reply...
        DISPOSE_OBJECT(IoPacket);

        TRACE(" **** Current WTR %d\n",get_WTR_Delay());
        DELAY(get_WTR_Delay());

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
        IoPacket->setReadLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("                 USB sendAndWait()...\n");
        status = sendAndWait(IoPacket);
        TRACE("                 USB sendAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        *pReplyLength = (ULONG)IoPacket->getInformation();
        IoPacket->getSystemReply(pReply,*pReplyLength);

        //TRACE_BUFFER(pReply,*pReplyLength);
        DISPOSE_OBJECT(IoPacket);
        return status;
};

NTSTATUS   CUSBDevice::readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
{
CIoPacket* IoPacket;
        if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
        if(Response_ErrorNum || Command_ErrorNum)
        {       
                TRACE("======= RESETTING ERROR CONDITIONS! =========\n");
                NTSTATUS res_status = resetDevice();
                if(NT_SUCCESS(res_status))
                {
                        Command_ErrorNum = 0;
                        Response_ErrorNum = 0;
                }
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET DEVICE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }

                /*TRACE("======= RESETTING ERROR CONDITIONS AT PIPES! =========\n");
                NTSTATUS res_status = resetPipe(m_ResponsePipe);
                if(NT_SUCCESS(res_status))      Response_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET RESPONSE PIPE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }

                res_status = resetPipe(m_CommandPipe);
                if(NT_SUCCESS(res_status))      Command_ErrorNum = 0;
                else
                {
                        *pReplyLength = 0;
                        TRACE("======= FAILED TO RESET COMMAND PIPE! =========\n");
                        return STATUS_INVALID_DEVICE_STATE;
                }
                */
        }

        IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
        if(!ALLOCATED_OK(IoPacket))
        {
                DISPOSE_OBJECT(IoPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoPacket->setTimeout(getCommandTimeout());
        IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
        IoPacket->setReadLength(RequestLength);
        IoPacket->copyBuffer(pRequest,RequestLength);

        TRACE("WDM sendAndWait()...\n");
        NTSTATUS status = sendAndWait(IoPacket);
        TRACE("WDM sendAndWait finished: %x\n",status);
        if(!NT_SUCCESS(status))
        {
                *pReplyLength = 0;
                IoPacket->dispose();
                return status;
        }

        *pReplyLength = (ULONG)IoPacket->getInformation();
        IoPacket->getSystemReply(pReply,*pReplyLength);

        //TRACE_BUFFER(pReply,*pReplyLength);
        DISPOSE_OBJECT(IoPacket);
        return status;
};

// Handle IRP_MJ_POWER request
// This routine uses the IRP's minor function code to dispatch a handler
// function (such as HandleSetPower for IRP_MN_SET_POWER). It calls DefaultPowerHandler
// for any function we don't specifically need to handle.
NTSTATUS CUSBDevice::powerRequest(IN PIRP Irp)
{
        if(!Irp) return STATUS_INVALID_PARAMETER;
        if (!NT_SUCCESS(acquireRemoveLock()))
        {
                power->startNextPowerIrp(Irp);  // must be done while we own the IRP
                return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
        }

        PIO_STACK_LOCATION stack = irp->getCurrentStackLocation(Irp);
        ASSERT(stack->MajorFunction == IRP_MJ_POWER);
        ULONG fcn = stack->MinorFunction;
        NTSTATUS status;
        if (fcn >= arraysize(Powerfcntab))
        {       // unknown function
                status = power_Default(Irp);
                releaseRemoveLock();
                return status;
        }

#ifdef DEBUG
        if (fcn == IRP_MN_SET_POWER || fcn == IRP_MN_QUERY_POWER)
                {
                ULONG context = stack->Parameters.Power.SystemContext;
                POWER_STATE_TYPE type = stack->Parameters.Power.Type;


                        TRACE("\n(%s)\nSystemContext %X, ", Powerfcnname[fcn], context);
                        if (type==SystemPowerState)
                        {
                                TRACE("SYSTEM POWER STATE = %s\n", Powersysstate[stack->Parameters.Power.State.SystemState]);
                        }
                        else
                        {
                                TRACE("DEVICE POWER STATE = %s\n", Powerdevstate[stack->Parameters.Power.State.DeviceState]);
                        }
                }
        else
                TRACE("Request (%s)\n", Powerfcnname[fcn]);

#endif // DEBUG

        status = callPowerHandler(fcn,Irp);
        releaseRemoveLock();
        return status;
}

VOID    CUSBDevice::activatePowerHandler(LONG HandlerID)
{
        if (HandlerID >= arraysize(Powerfcntab)) return;
        Powerfcntab[HandlerID] = TRUE;
}

VOID    CUSBDevice::disActivatePowerHandler(LONG HandlerID)
{
        if (HandlerID >= arraysize(Powerfcntab)) return;
        Powerfcntab[HandlerID] = FALSE;
}

NTSTATUS        CUSBDevice::callPowerHandler(LONG HandlerID,IN PIRP Irp)
{
        if(!Powerfcntab[HandlerID]) // If Handler is not registered...
                return power_Default(Irp);
        // Call registered Power Handler...
        // This is virtual function...
        switch(HandlerID)
        {
        case IRP_MN_WAIT_WAKE:          return power_HandleWaitWake(Irp);
                break;
        case IRP_MN_POWER_SEQUENCE:     return power_HandleSequencePower(Irp);
                break;
        case IRP_MN_SET_POWER:          return power_HandleSetPower(Irp);
                break;
        case IRP_MN_QUERY_POWER:        return power_HandleQueryPower(Irp);
                break;
        }
        return power_Default(Irp);
}

#pragma PAGEDCODE
NTSTATUS CUSBDevice::power_HandleSetPower(IN PIRP Irp)
{
PIO_STACK_LOCATION irpStack;
NTSTATUS status = STATUS_SUCCESS;
BOOLEAN fGoingToD0 = FALSE;
POWER_STATE sysPowerState, desiredDevicePowerState;

        if(!Irp) return STATUS_INVALID_PARAMETER;

    irpStack = irp->getCurrentStackLocation (Irp);
        switch (irpStack->Parameters.Power.Type) 
        {
                case SystemPowerState:
                        // Get input system power state
                        sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

#ifdef DEBUG
                        TRACE("Set Power with type SystemPowerState = %s\n",Powersysstate[sysPowerState.SystemState]);
#endif
                        // If system is in working state always set our device to D0
                        //  regardless of the wait state or system-to-device state power map
                        if ( sysPowerState.SystemState == PowerSystemWorking) 
                        {
                                desiredDevicePowerState.DeviceState = PowerDeviceD0;
                                TRACE("PowerSystemWorking, device will be set to D0, state map is not used\n");
                        } 
                        else 
                        {
                                 // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                                if (isEnabledForWakeup()) 
                                {   // got a WAIT_WAKE IRP pending?
                                        // Find the device power state equivalent to the given system state.
                                        // We get this info from the DEVICE_CAPABILITIES struct in our device
                                        // extension (initialized in BulkUsb_PnPAddDevice() )
                                        desiredDevicePowerState.DeviceState = m_DeviceCapabilities.DeviceState[sysPowerState.SystemState];
                                        TRACE("IRP_MN_WAIT_WAKE pending, will use state map\n");
                                } 
                                else 
                                {  
                                        // if no wait pending and the system's not in working state, just turn off
                                        desiredDevicePowerState.DeviceState = PowerDeviceD3;
                                        TRACE("Not EnabledForWakeup and the system's not in the working state,\n  settting PowerDeviceD3(off)\n");
                                }
                        }
                        // We've determined the desired device state; are we already in this state?

#ifdef DEBUG
                        TRACE("Set Power, desiredDevicePowerState = %s\n",
                                Powerdevstate[desiredDevicePowerState.DeviceState]);
#endif

                        if (desiredDevicePowerState.DeviceState != m_CurrentDevicePowerState) 
                        {
                                acquireRemoveLock();// Callback will release the lock
                                // No, request that we be put into this state
                                // by requesting a new Power Irp from the Pnp manager
                                registerPowerIrp(Irp);
                                IoMarkIrpPending(Irp);
                                status = power->requestPowerIrp(getSystemObject(),
                                                                                   IRP_MN_SET_POWER,
                                                                                   desiredDevicePowerState,
                                                                                   // completion routine will pass the Irp down to the PDO
                                                                                   (PREQUEST_POWER_COMPLETE)onPowerRequestCompletion, 
                                                                                   this, NULL);
                        } 
                        else 
                        {   // Yes, just pass it on to PDO (Physical Device Object)
                                irp->copyCurrentStackLocationToNext(Irp);
                                power->startNextPowerIrp(Irp);
                                status = power->callPowerDriver(getLowerDriver(),Irp);
                        }
                        break;
                case DevicePowerState:
#ifdef DEBUG
                        TRACE("Set DevicePowerState %s\n",
                                Powerdevstate[irpStack->Parameters.Power.State.DeviceState]);
#endif
                        // For requests to D1, D2, or D3 ( sleep or off states ),
                        // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
                        // This enables any code checking state to consider us as sleeping or off
                        // already, as this will imminently become our state.

                        // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
                        // to flag that we must set a completion routine and update
                        // deviceExtension->CurrentDevicePowerState there.
                        // In the case of powering up to fully on, we really want to make sure
                        // the process is completed before updating our CurrentDevicePowerState,
                        // so no IO will be attempted or accepted before we're really ready.

                        fGoingToD0 = setDevicePowerState(irpStack->Parameters.Power.State.DeviceState); // returns TRUE for D0
                        if (fGoingToD0) 
                        {
                                acquireRemoveLock();// Callback will release the lock
                                TRACE("Set PowerIrp Completion Routine, fGoingToD0 =%d\n", fGoingToD0);
                                
                                irp->copyCurrentStackLocationToNext(Irp);
                                irp->setCompletionRoutine(Irp,
                                           onPowerIrpComplete,
                                           // Always pass FDO to completion routine as its Context;
                                           // This is because the DriverObject passed by the system to the routine
                                           // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                                           this,
                                           TRUE,            // invoke on success
                                           TRUE,            // invoke on error
                                           TRUE);           // invoke on cancellation of the Irp
                                // Completion routine will set our state and start next power Irp
                        }
                        else
                        {
                                // D3 device state
                                //Device reduces power, so do specific for device processing...
                                onSystemPowerDown();

                                // Report our state to power manager
                                desiredDevicePowerState.DeviceState = PowerDeviceD3;
                                power->declarePowerState(getSystemObject(),DevicePowerState,desiredDevicePowerState);
                                irp->copyCurrentStackLocationToNext(Irp);
                                power->startNextPowerIrp(Irp);
                        }

                        status = power->callPowerDriver(getLowerDriver(),Irp);
                        break;
        } /* case irpStack->Parameters.Power.Type */

        return status;
}

#pragma PAGEDCODE
VOID    CUSBDevice::onSystemPowerDown()
{
        return;
}

#pragma PAGEDCODE
VOID    CUSBDevice::onSystemPowerUp()
{
        return;
}

#pragma PAGEDCODE
BOOLEAN CUSBDevice::setDevicePowerState(IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fRes = FALSE;
    switch (DeviceState) 
        {
    case PowerDeviceD3:
            // Device will be going OFF, 
                // TODO: add any needed device-dependent code to save state here.
                //  ( We have nothing to do in this sample )
        TRACE("SetDevicePowerState() PowerDeviceD3 (OFF)\n");
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD1:
    case PowerDeviceD2:
        // power states D1,D2 translate to USB suspend
#ifdef DEBUG
        TRACE("SetDevicePowerState()  %s\n",Powerdevstate[DeviceState]);
#endif
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD0:
        TRACE("Set Device Power State to PowerDeviceD0(ON)\n");
        // We'll need to finish the rest in the completion routine;
        // signal caller we're going to D0 and will need to set a completion routine
        fRes = TRUE;
        // Caller will pass on to PDO ( Physical Device object )
        break;
    default:
        TRACE(" Bogus DeviceState = %x\n", DeviceState);
    }
    return fRes;
}


/*++

Routine Description:

        This is the completion routine set in a call to PoRequestPowerIrp()
        that was made in ProcessPowerIrp() in response to receiving
    an IRP_MN_SET_POWER of type 'SystemPowerState' when the device was
        not in a compatible device power state. In this case, a pointer to
        the IRP_MN_SET_POWER Irp is saved into the FDO device extension 
        (deviceExtension->PowerIrp), and then a call must be
        made to PoRequestPowerIrp() to put the device into a proper power state,
        and this routine is set as the completion routine.

    We decrement our pending io count and pass the saved IRP_MN_SET_POWER Irp
        on to the next driver

Arguments:

    DeviceObject - Pointer to the device object for the class device.
        Note that we must get our own device object from the Context

    Context - Driver defined context, in this case our own functional device object ( FDO )

Return Value:

    The function value is the final status from the operation.

--*/
#pragma LOCKEDCODE
NTSTATUS onPowerRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PIRP Irp;
    NTSTATUS status;

        if(!Context) return STATUS_INVALID_PARAMETER;

        CUSBReader* device = (CUSBReader*) Context;
        
        // Get the Irp we saved for later processing
        // when we decided to request the Power Irp that this routine 
        // is the completion routine for.
    Irp = device->getPowerIrp();

        // We will return the status set by the PDO for the power request we're completing
    status = IoStatus->Status;
    DBG_PRINT("Enter onPowerRequestCompletion()\n");

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(device->getLowerDriver(),Irp);

    device->unregisterPowerIrp();
    device->releaseRemoveLock();

    DBG_PRINT("Exit  onPowerRequestCompletion()\n");
    return status;
}

/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by BulkUsb_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
#pragma LOCKEDCODE
NTSTATUS        onPowerIrpComplete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    POWER_STATE desiredDevicePowerState;

    DBG_PRINT("Enter onPowerIrpComplete()\n");

        if(!Context) return STATUS_INVALID_PARAMETER;
        
        CUSBReader* device = (CUSBReader*) Context;
    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) IoMarkIrpPending(Irp);
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // We can assert that we're a  device powerup-to D0 request,
    // because that was the only type of request we set a completion routine
    // for in the first place
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    // Now that we know we've let the lower drivers do what was needed to power up,
    //  we can set our device extension flags accordingly
        device->setCurrentDevicePowerState(PowerDeviceD0);
        // Do device specific stuff...
        device->onSystemPowerUp();

    Irp->IoStatus.Status = status;
    device->releaseRemoveLock();

    desiredDevicePowerState.DeviceState = PowerDeviceD0;    
    PoSetPowerState(device->getSystemObject(),DevicePowerState,desiredDevicePowerState);    
    PoStartNextPowerIrp(Irp);


    DBG_PRINT("Exit  onPowerIrpComplete() for the state D0\n");
    return status;
}
#pragma PAGEDCODE
NTSTATUS CUSBDevice::power_HandleWaitWake(IN PIRP Irp)
{
        return power_Default(Irp);
}

NTSTATUS CUSBDevice::power_HandleSequencePower(IN PIRP Irp)
{
        return power_Default(Irp);
}

NTSTATUS CUSBDevice::power_HandleQueryPower(IN PIRP Irp)
{
        TRACE("********  QUERY POWER ********\n");
        if(isDeviceLocked())
        {
                TRACE("******** FAILED TO CHANGE POWER (DEVICE BUSY) ********\n");
                Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
                power->startNextPowerIrp(Irp);  // must be done while we own the IRP
                return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
        }
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        return power_Default(Irp);
}

NTSTATUS        CUSBDevice::createDeviceObjectByName(PDEVICE_OBJECT* ppFdo)
{
NTSTATUS status;
        // Construct device name...
        CUString* index = new (PagedPool) CUString(getDeviceNumber(),10);
        CUString* base  = new (PagedPool) CUString(NT_OBJECT_NAME);
        if(!ALLOCATED_OK(index) || !ALLOCATED_OK(base))
        {
                DISPOSE_OBJECT(index);
                DISPOSE_OBJECT(base);
                return STATUS_INSUFFICIENT_RESOURCES;
        }
        USHORT    size  = (USHORT)(index->getLength() + base->getLength() + sizeof(WCHAR));
        
        // Allocate string with required length
        m_DeviceObjectName = new (NonPagedPool) CUString(size);
        if(!ALLOCATED_OK(m_DeviceObjectName))
        {
                DISPOSE_OBJECT(index);
                DISPOSE_OBJECT(base);
                DISPOSE_OBJECT(m_DeviceObjectName);
                return STATUS_INSUFFICIENT_RESOURCES;
        }

        m_DeviceObjectName->append(&base->m_String);
        m_DeviceObjectName->append(&index->m_String);
        TRACE("Driver registers DeviceObjectName as %ws\n", m_DeviceObjectName->m_String.Buffer);

        delete index;
        delete base;

        status = system->createDevice(m_DriverObject,sizeof(CWDMDevice*),&m_DeviceObjectName->m_String,
                                                        FILE_DEVICE_UNKNOWN,0,FALSE,ppFdo);
        if(!NT_SUCCESS(status))
        {
                TRACE("#### Failed to create physical device! Status %x\n",status);
                delete m_DeviceObjectName;
        }
        return status;
}

#endif  // USBDEVICE_PROJECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\usbreader.cpp ===
//-------------------------------------------------------------------
// This is abstract class for generic device
// Specific devices should use it as a parent device
// Author: Sergey Ivanov
// Log:
//		01.11.99	-	implemented	
//-------------------------------------------------------------------
#ifdef	USBREADER_PROJECT
#pragma message("COMPILING USB READER...")

#ifndef __USB_READER__
#define __USB_READER__

#include "generic.h"
#include "usbreader.h"

#include "smartcard.h"
#include "usbdev.h"
#include "reader.h"

#include "gemcore.h"

#pragma PAGEDCODE
CUSBReader::CUSBReader()
{
ULONG DevID;

	m_Status = STATUS_INSUFFICIENT_RESOURCES;
	m_Type    = USBREADER_DEVICE;
	interface = NULL;
	DevID = incrementDeviceNumber();
	TRACE("########### Creating USBReader with index %d\n",DevID);
	// Each reader creates own smartcard object...
	scard_Initialized = FALSE;
	smartCard = new (NonPagedPool) CSmartCard;

	TRACE("**** Creating pooling thread...  ****\n");		
	// We can not use default device function because it was already used by
	// our Io thread (unless we extend it?)
	// Lets define new thread function and xfer control to it...
	PoolingThread = new (NonPagedPool) CThread((PCLIENT_THREAD_ROUTINE)PoolingThreadFunction,this,
											getDevicePoolingInterval());
	if(!ALLOCATED_OK(PoolingThread))
	{
		DISPOSE_OBJECT(PoolingThread);
		TRACE("****** FAILED TO CREATE POOLING THREAD!\n");
	}
	else
	{
		// Thread which controls asynchronous driver communications
		IoThread = new (NonPagedPool) CThread((PCLIENT_THREAD_ROUTINE)ThreadFunction,this,0);
		if(!ALLOCATED_OK(IoThread))
		{
			DISPOSE_OBJECT(IoThread);
			TRACE("****** FAILED TO CREATE IO THREAD!\n");
		}
		else
		{
			IoThread->start();
			setDeviceState(WORKING);
			m_Status = STATUS_SUCCESS;
		}
	}
	TRACE("********* USB Reader %8.8lX was created with status %8.8lX...\n",this,m_Status);
}

#pragma PAGEDCODE
CUSBReader::~CUSBReader()
{
	TRACE("Destroing USB reader pooling thread...\n");
	
	if(PoolingThread)	PoolingThread->dispose();

	
	if(smartCard)
	{
		TRACE("Disconnecting from smartcard system...\n");
		smartCard->smartCardDisconnect();
		smartCard->dispose();
	}
	if(interface) interface->dispose();
	
	if(IoThread) IoThread->stop();
	cancelAllPendingRequests();
	if(IoThread) IoThread->dispose();

	remove();
	TRACE("********* USB Reader %8.8lX was destroied...\n",this);
}

//Handle IRP_MJ_DEVICE_READ request
#pragma PAGEDCODE
NTSTATUS	CUSBReader::open(IN PIRP Irp)
{
NTSTATUS status;
	TRACE("\n------- USB READER OPEN DEVICE --------\n");
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		status = STATUS_DEVICE_NOT_CONNECTED;
		return completeDeviceRequest(Irp,status,0);
	}
	if(IoThread)
	{
		status = makeRequestPending(Irp,m_DeviceObject,OPEN_REQUEST);
		// Tell thread to start processing 
		if(NT_SUCCESS(status)) 
		{
			TRACE("CALL THREAD FUNCTION...\n");
			IoThread->callThreadFunction();
		}
		else	return completeDeviceRequest(Irp,status,0);
	}
	else
	{
		// IoThread is not ready... Process synchronously!
		status = thread_open(Irp); 
	}
	return status;
}


#pragma PAGEDCODE
NTSTATUS CUSBReader::thread_open(PIRP Irp) 
{
	TRACE("\n------- PROCESSING USB READER OPEN DEVICE --------\n");
	TRACE("DEVICE NUMBER %x\n", this);
	if (!NT_SUCCESS(acquireRemoveLock()))
	{
		TRACE("------- FAILED TO LOCK USB READER --------\n");
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	// Check if device is already active and reports
	// device busy...
	if(isOpenned())
	{
		TRACE("------- USB READER ALREADY OPENNED --------\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DEVICE_BUSY, 0);
	}
	
	if(!NT_SUCCESS(synchronizeDevicePowerState()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* FAILED TO SYNCHRONIZE DEVICE POWER...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_STATE, 0);
	}

	if(PoolingThread) PoolingThread->start();
	
	markAsOpenned();

	TRACE("\n------- USB READER OPENNED! --------\n");
	releaseRemoveLock();
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
};//Create

#pragma PAGEDCODE
VOID CUSBReader::onDeviceStart() 
{
	TRACE("============= PNP START INITIALIZATION ===============\n");
	if(interface)
	{
		if(!interface->isInitialized())
		{
			interface->initialize();
		}
	}	
	
	reader_UpdateCardState();
	setNotificationState(SCARD_SWALLOWED);
	TRACE("============= PNP START INITIALIZATION FINISHED ===============\n");
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::close(PIRP Irp)
{ 
	DEBUG_START();//Force to debug even if thread disable it...
	TRACE("\n------- USB READER CLOSE DEVICE -------\n");
	if(!isOpenned())
	{
		return completeDeviceRequest(Irp, STATUS_SUCCESS, 0);
	}
	// Check lock count to know if some pending calls exist...
	// Finish all pending calls...		
	// Stop Card pooling...
	if(PoolingThread) PoolingThread->stop();

	// Power down card if inserted...
	if(getCardState()== SCARD_SWALLOWED)
	{
	ULONG ResponseBufferLength = 0;
		reader_WaitForIdleAndBlock();
		reader_Power(SCARD_POWER_DOWN,NULL,&ResponseBufferLength, FALSE);
		reader_set_Idle();
	}

	setNotificationState(getCardState());
	completeCardTracking();

	markAsClosed();
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
};


#pragma PAGEDCODE
NTSTATUS	CUSBReader::deviceControl(IN PIRP Irp)
{
NTSTATUS status;
	TRACE("\n----- IRP_MJ_DEVICE_CONTROL ------\n");
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		status = STATUS_DEVICE_NOT_CONNECTED;
		return completeDeviceRequest(Irp,status,0);
	}

	status = thread_deviceControl(Irp);
	return status;
}

// Redefine base class system interface function...
//Handle IRP_MJ_DEVICE_CONTROL request
#pragma PAGEDCODE
NTSTATUS	CUSBReader::thread_deviceControl(IN PIRP Irp)
{							// RequestControl
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;

	if (!NT_SUCCESS(acquireRemoveLock()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED TO AQUIRE REMOVE LOCK...\n");
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	TRACE("----- thread_deviceControl() ------\n");

	if(isSurprizeRemoved())
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED! DEVICE WAS SURPRIZE REMOVED...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}
	
	// This was fix for "device SET_POWER without system SET_POWER"
	// It was seen first on ia64 machine
	// If device was powered off tell system to restore power on this device,
	// wait till device will be at proper state...
	/*if(!NT_SUCCESS(synchronizeDevicePowerState()))
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* FAILED TO SYNCHRONIZE DEVICE POWER...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_INVALID_DEVICE_STATE, 0);
	}
	*/

	// If we've got request but device was not enable yet -> wait for the device!
	// (One of the reasons to disable device - power state change)
	if(!synchronizeDeviceExecution())
	{
		DEBUG_START();//Force to debug even if thread disable it...
		TRACE("******* DIOC: FAILED TO SYNCHRONIZE EXECUTION ...\n");
		releaseRemoveLock();
		return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	}

	// SmartCard system will complete the request,
	// So... We do not need to do it here.
	status = SmartcardDeviceControl(getCardExtention(),Irp);
	TRACE("===== USB reader: SmartcardDeviceControl() returns %8.8lX\n", status);
	releaseRemoveLock();

	if(!NT_SUCCESS(status))
	{// In case of errors force to update card status...
		if(PoolingThread) PoolingThread->callThreadFunction();
	}
	return status;
}

#pragma PAGEDCODE
NTSTATUS 	CUSBReader::cleanup(PIRP Irp)
{
	DEBUG_START();//Force to debug even if thread disable it...
	TRACE("\n----- IRP_MJ_CLEANUP ------\n");

	if(PoolingThread) PoolingThread->stop();
	cancelAllPendingRequests();


	setNotificationState(getCardState());
	completeCardTracking();

	reader_set_Idle();
	TRACE("----- IRP_MJ_CLEANUP FINISHED... ------\n");
	return completeDeviceRequest(Irp, STATUS_SUCCESS, 0); 
}


#pragma LOCKEDCODE
// This is callback function for the attached threads
VOID CUSBReader::PoolingThreadFunction(CUSBReader* device)
{
	if(device) device->PoolingThreadRoutine();
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::PoolingThreadRoutine()
{
NTSTATUS status;
ULONG State;
LONG  TimeOut;
	if(!NT_SUCCESS(status = reader_WaitForIdle())) return status;
	reader_set_busy();
	
	TimeOut = getCommandTimeout();
	setCommandTimeout(10000);//Change get status command timeout!

	DEBUG_STOP();
	State = reader_UpdateCardState();
	TRACE("======>> Card state %x\n",CardState);
	DEBUG_START();

	setCommandTimeout(TimeOut);

	reader_set_Idle();
	return STATUS_SUCCESS;
};	

#pragma LOCKEDCODE
VOID	  CUSBReader::reader_set_busy()
{
	setBusy();
};

#pragma LOCKEDCODE
VOID	  CUSBReader::reader_set_Idle()
{
	setIdle();
};

#pragma LOCKEDCODE
NTSTATUS  CUSBReader::reader_WaitForIdle()
{
	return waitForIdle();
};

#pragma LOCKEDCODE
NTSTATUS  CUSBReader::reader_WaitForIdleAndBlock()
{
	return waitForIdleAndBlock();
};


#ifdef DEBUG
/*
// Overwrite device functions...
NTSTATUS	CUSBReader::read(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
	TRACE("USB reader: IRP_MJ_DEVICE_READ\n");
	if (!NT_SUCCESS(acquireRemoveLock()))	return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);

	status = reader_Read(Irp);
	releaseRemoveLock();
	status = completeDeviceRequest(Irp, status, info);
	return status;
}
NTSTATUS	CUSBReader::write(IN PIRP Irp)
{
NTSTATUS status = STATUS_SUCCESS;
ULONG info = 0;
	TRACE("USB reader: IRP_MJ_DEVICE_WRITE\n");
	if (!NT_SUCCESS(acquireRemoveLock()))	return completeDeviceRequest(Irp, STATUS_DELETE_PENDING, 0);
	status = reader_Write(Irp);
	releaseRemoveLock();
	status = completeDeviceRequest(Irp, status, info);
	return status;
}
*/
#endif


#pragma PAGEDCODE
BOOL	 CUSBReader::createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device)
{
	interface = kernel->createReaderInterface(interfaceType,protocolType,device);
	if(interface)	return TRUE;
	else            return FALSE;
};	

#pragma PAGEDCODE
VOID	 CUSBReader::initializeSmartCardSystem()
{
	if(smartCard)
	{
		CardState = SCARD_UNKNOWN;
		StateToNotify = SCARD_UNKNOWN;
		smartCard->smartCardConnect(this);
	}
};


#pragma PAGEDCODE
VOID	CUSBReader::onSystemPowerDown()
{
	// Stop pooling thread
    TRACE("Stop polling thread going to PowerDeviceD3 (OFF)\n");
	disableDevice();

	if(PoolingThread) {if(PoolingThread->isThreadActive()) setThreadRestart();};
	if(PoolingThread) PoolingThread->stop();
	return;
}

#pragma PAGEDCODE
VOID	CUSBReader::onSystemPowerUp()
{
	// Stop pooling thread
    TRACE("Restore reader state going to PowerDeviceD0 (ON)\n");
	if(interface)
	{
		if(interface->isInitialized())
		{
			// Restore reader mode after power down
			NTSTATUS status = interface->setReaderMode(READER_MODE_NATIVE);
			if(!NT_SUCCESS(status))
			{
				TRACE("Failed to set Gemcore reader mode %x\n",READER_MODE_NATIVE);
			}
		}
	}	
	if(getCardState() >= SCARD_SWALLOWED) setCardState(SCARD_ABSENT);
	completeCardTracking();	

	if(isRequiredThreadRestart())
	{
		TRACE("Starting pooling thread going to PowerDeviceD0 (ON)\n");
		if(PoolingThread) PoolingThread->start();	
	}

	enableDevice();
	return;
}

#pragma PAGEDCODE
BOOLEAN	CUSBReader::setDevicePowerState(IN DEVICE_POWER_STATE DeviceState)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fRes = FALSE;

	DEBUG_START();
	switch (DeviceState) 
	{
    case PowerDeviceD3:
	    // Device will be going OFF, 
		// TODO: add any needed device-dependent code to save state here.
		//  ( We have nothing to do in this sample )
        TRACE("Set Device Power State to PowerDeviceD3 (OFF)\n");
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD1:
    case PowerDeviceD2:
        // power states D1,D2 translate to USB suspend
#ifdef DEBUG
        TRACE("Set Device Power State to %s\n",Powerdevstate[DeviceState]);
#endif
        setCurrentDevicePowerState(DeviceState);
        break;
    case PowerDeviceD0:
        TRACE("Set Device Power State to PowerDeviceD0(ON)\n");
        // We'll need to finish the rest in the completion routine;
        // signal caller we're going to D0 and will need to set a completion routine
        fRes = TRUE;
        // Caller will pass on to PDO ( Physical Device object )
        break;
    default:
        TRACE(" Bogus DeviceState = %x\n", DeviceState);
    }
    return fRes;
}

#pragma PAGEDCODE
ULONG CUSBReader::reader_UpdateCardState()
{
	if(interface)
	{
		CardState = interface->getReaderState();
		completeCardTracking();
	}
	else	CardState = 0;
	return  CardState;
};

#pragma LOCKEDCODE
VOID	CUSBReader::completeCardTracking()
{
	if(smartCard)
	{
		smartCard->completeCardTracking();
	}
};


#pragma PAGEDCODE
NTSTATUS  CUSBReader::reader_getVersion(PUCHAR pVersion, PULONG pLength)
{
	if(interface)	return interface->getReaderVersion(pVersion,pLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_setMode(ULONG mode)
{
	if(interface)	return interface->setReaderMode(mode);
	else return STATUS_INVALID_DEVICE_STATE;
};

#ifdef DEBUG
#pragma PAGEDCODE
NTSTATUS	CUSBReader::reader_Read(IN PIRP Irp)
{
	CIoPacket* request = new (NonPagedPool) CIoPacket(Irp);
	if(!ALLOCATED_OK(request) || !ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(request);
		return completeDeviceRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,0);
	}

	NTSTATUS status = interface->read(request);
	DISPOSE_OBJECT(request);
	return status;
};

#pragma PAGEDCODE
NTSTATUS	CUSBReader::reader_Write(IN PIRP Irp)
{
	CIoPacket* request = new (NonPagedPool) CIoPacket(Irp);
	if(!ALLOCATED_OK(request) || !ALLOCATED_OK(interface))
	{
		DISPOSE_OBJECT(request);
		return completeDeviceRequest(Irp,STATUS_INSUFFICIENT_RESOURCES,0);
	}

	NTSTATUS status = interface->write(request);
	DISPOSE_OBJECT(request);
	return status;
};
#endif

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->readAndWait(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->writeAndWait(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->ioctl(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->SwitchSpeed(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->VendorAttribute(ControlCode,pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific)
{
	if(interface)	return interface->power(ControlCode,pReply,pReplyLength, Specific);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation)
{
	NTSTATUS status;

	if(interface)
	{
		ReaderConfig config = interface->getConfiguration();
		// Update all required configuration fields to set specific protocol

		switch(ProtocolNegociation)
		{
			case PROTOCOL_MODE_DEFAULT: 
				config.PTSMode = PTS_MODE_DISABLED;
				break;
			case PROTOCOL_MODE_MANUALLY:
			default:
				config.PTSMode = PTS_MODE_MANUALLY;
				break;
		}

		config.PTS1 = smartCardExtention.CardCapabilities.PtsData.Fl << 4 | 
			 smartCardExtention.CardCapabilities.PtsData.Dl;

		interface->setConfiguration(config);

		status = interface->setProtocol(ProtocolRequested);
		return status;
	}
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	if(interface)	return interface->setTransparentConfig(cardCapabilities,NewWtx);
	else return STATUS_INVALID_DEVICE_STATE;
};


#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx)
{
	if(interface)	return interface->translate_request(pRequest,RequestLength,pReply,pReplyLength, cardCapabilities, NewWtx);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength)
{
	if(interface)	return interface->translate_response(pRequest,RequestLength,pReply,pReplyLength);
	else return STATUS_INVALID_DEVICE_STATE;
};

#pragma PAGEDCODE
NTSTATUS CUSBReader::PnP_HandleSurprizeRemoval(IN PIRP Irp)
{	// It is PnP internal function.
	// So, device will be locked at PnP entry and
	// we do not need to do it here.
	TRACE("********  USB READER SURPRIZE REMOVAL ********\n");

	// Just stop thread and remove all pending IOs
	if(PoolingThread) PoolingThread->stop();

	setSurprizeRemoved();
	cancelAllPendingRequests();

	return PnP_Default(Irp);
};


VOID CUSBReader::onDeviceStop()
{
	TRACE("********  ON USB READER STOP ********\n");
	// Just stop thread and remove all pending IOs
	if(PoolingThread) PoolingThread->stop();
	//if(IoThread)	  IoThread->stop();
	return;
};

// Reader startIoRequest function
// It will dispatch all pending Io requests
NTSTATUS	CUSBReader::startIoRequest(CPendingIRP* IrpReq) 
{
NTSTATUS status;
	TRACE("		CUSBReader::::startIoRequest() was called...\n");
	// Our child's functions run under protection of child BUSY/IDLE breaks.
	// So, we do not need to check idle state here...
	if(getDeviceState()!=WORKING)
	{
		TRACE("		READER IS NOT AT WORKING STATE... State %x\n",getDeviceState());
		TRACE("		<<<<<< READER IO REQUEST FINISHED WITH STATUS %8.8lX>>>>>>\n",STATUS_DEVICE_NOT_CONNECTED);
		NTSTATUS status = completeDeviceRequest(IrpReq->Irp, STATUS_DEVICE_NOT_CONNECTED, 0);
		IrpReq->dispose();
		return   status;
	}

	// Our reader will support asynchronous communications only for these functions...
	switch(IrpReq->Type)
	{
	case OPEN_REQUEST:
		TRACE("OPEN_REQUEST RECIEVED FROM THREAD...\n");
		status = thread_open(IrpReq->Irp);
		break;
	case IOCTL_REQUEST:
		TRACE("IOCTL_REQUEST RECIEVED FROM THREAD...\n");
		status = thread_deviceControl(IrpReq->Irp);
		break;
	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
	}
	IrpReq->dispose();
	TRACE("		<<<<<< READER IO REQUEST FINISHED WITH STATUS %8.8lX>>>>>>\n",status);
	return status;
};

NTSTATUS CUSBReader::ThreadRoutine()
{
	// If somebody inserted pending request - dispatch it...
	// It will call specific child device startIoRequest().
	// It is up to that device how to handle it.
	// If child device is busy - it can insert this request into
	// child device request queue again and process it later...
	startNextPendingRequest();
	return STATUS_SUCCESS;
};	

#endif
#endif //USBREADER_PROJECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\thread.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __THREAD__
#define __THREAD__
#include "generic.h"
#include "kernel.h"

#pragma PAGEDCODE
class CUSBReader;//TOBE REMOVED
class CTimer;
//class CThread;

typedef
NTSTATUS
(*PCLIENT_THREAD_ROUTINE) (
    IN PVOID RoutineContext
    );
// Default thread pooling interval in ms
#define DEFAULT_THREAD_POOLING_INTERVAL	500

class CThread 
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
private:
KEVENT   evKill;	// set to kill polling thread
KEVENT   evStart;	// set when requested to start, clear when need to stop pooling
KEVENT   evIdle;	// Signals that thread stopped and at Idle state
KEVENT   evStopped;	// set when requested to close thread
PKTHREAD thread;	// polling thread object
KSEMAPHORE smOnDemandStart;// request to repeate operation if semaphore is at Signal state

BOOLEAN  StopRequested;	
BOOLEAN  ThreadActive;	

CDebug*  debug;
CEvent*  event;
CSystem* system;
CTimer*  timer;
CSemaphore* semaphore;

ULONG	 PoolingTimeout;

PCLIENT_THREAD_ROUTINE pfClientThreadFunction;
PVOID ClientContext;

//CDevice* device;
//CUSBReader* device;
protected:
	CThread(){};
	virtual ~CThread();
public:
	//CThread(CDevice* device);
	//CThread(CUSBReader* device);
	CThread(PCLIENT_THREAD_ROUTINE ClientThreadFunction, PVOID ClientContext,
				ULONG delay=DEFAULT_THREAD_POOLING_INTERVAL);
	static VOID ThreadFunction(CThread* thread);

	VOID ThreadRoutine(PVOID context) ;
	PKEVENT  getKillObject(){return &evKill;};
	PKEVENT  getStartObject(){return &evStart;};
	VOID	 kill();
	VOID	 start();
	VOID	 stop();
	BOOL	 isThreadActive();
	VOID	 setPoolingInterval(ULONG delay);
	// Force to call thread function...
	// This is on demand start.
	VOID     callThreadFunction();
};

#endif//THREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\usbreader.h ===
// Gemplus (C) 1999
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 11.01.1999
// Change log:
//
#ifndef USB_READER
#define USB_READER

#include "debug.h"
#include "thread.h"
#include "usbdev.h"
#include "reader.h"


class CUSBDevice;
class CReader;
class CSmartCard;
//class CGemCore;//TOBE REMOVED

#pragma PAGEDCODE
class CUSBReader : public CUSBDevice, public CReader
{
public:
    NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(){self_delete();};
protected:
	virtual  ~CUSBReader();
public:	
	CUSBReader();

	virtual PDEVICE_OBJECT	getSystemDeviceObject()
	{
	PDEVICE_OBJECT pFdo = getSystemObject();

		TRACE("Reader reports device object 0x%x\n",pFdo);
		return pFdo;
	};
	
	virtual VOID	  reader_set_busy();
	virtual VOID	  reader_set_Idle();
	virtual NTSTATUS  reader_WaitForIdle();
	virtual NTSTATUS  reader_WaitForIdleAndBlock();

	// We support asynchronous communications only for Open and DeviceIOControl functions...
	virtual NTSTATUS  open(PIRP Irp); 
	virtual NTSTATUS  thread_open(IN PIRP Irp);
	virtual NTSTATUS  close(PIRP Irp);

	virtual NTSTATUS  deviceControl(IN PIRP Irp);
	virtual NTSTATUS  thread_deviceControl(IN PIRP Irp);

	virtual NTSTATUS  cleanup(PIRP irp);
	//Overwrite some generic USB device handlers
	virtual NTSTATUS  PnP_HandleSurprizeRemoval(IN PIRP Irp);

	virtual VOID	 setNotificationState(ULONG state){StateToNotify = state;};
	virtual ULONG	 getNotificationState(){ return StateToNotify;};

	virtual BOOL	 isSmartCardInitialized(){return scard_Initialized;};	
	virtual VOID	 setSmartCardInitialized(BOOL state) {scard_Initialized = state;};
	
	virtual PSMARTCARD_EXTENSION getCardExtention()
	{
		return &smartCardExtention;
	};
	virtual CSmartCard* getSmartCard()
	{
		return smartCard;
	};

	//virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CDevice* device);//TOBE CHANGED
	virtual BOOL	 createInterface(LONG interfaceType, LONG protocolType,CUSBReader* device);
	
	virtual VOID	 initializeSmartCardSystem();
	virtual ULONG	 reader_UpdateCardState();
	virtual VOID	 completeCardTracking();
	virtual BOOLEAN	 setDevicePowerState(IN DEVICE_POWER_STATE DeviceState);
	// Do specific step on the way system goes down
	virtual VOID	 onSystemPowerDown();
	virtual VOID	 onSystemPowerUp();

	virtual NTSTATUS reader_getVersion(PUCHAR pVersion, PULONG pLength);
	virtual NTSTATUS reader_setMode(ULONG mode);
#ifdef DEBUG
	virtual NTSTATUS reader_Read(IN PIRP Irp);
	virtual NTSTATUS reader_Write(IN PIRP Irp);
#endif
	virtual NTSTATUS reader_Read(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_Write(BYTE* pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_Ioctl(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_SwitchSpeed(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);
	virtual NTSTATUS reader_VendorAttribute(ULONG ControlCode,BYTE* pRequest,ULONG RequestLength,BYTE* pReply,ULONG* pReplyLength);

	virtual NTSTATUS reader_Power(ULONG ControlCode,BYTE* pReply,ULONG* pReplyLength, BOOLEAN Specific);
	virtual NTSTATUS reader_SetProtocol(ULONG ProtocolRequested, UCHAR ProtocolNegociation);
	virtual NTSTATUS setTransparentConfig(PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);

	virtual NTSTATUS reader_translate_request(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength, PSCARD_CARD_CAPABILITIES cardCapabilities, BYTE NewWtx);
	virtual NTSTATUS reader_translate_response(BYTE * pRequest,ULONG RequestLength,BYTE * pReply,ULONG* pReplyLength);

#ifdef DEBUG
//	virtual NTSTATUS	read(IN PIRP Irp);
//	virtual NTSTATUS	write(IN PIRP Irp);
#endif
	static  VOID		PoolingThreadFunction(CUSBReader* device);
	virtual NTSTATUS	PoolingThreadRoutine();
	virtual NTSTATUS	startIoRequest(CPendingIRP* IrpReq);
	virtual NTSTATUS	ThreadRoutine();//Overwrite standard function...

	virtual VOID	 onDeviceStart();
	virtual VOID	 onDeviceStop();
private:
	BOOL scard_Initialized;
	// Interface to communicate with reader from smartCard system...
	CReaderInterface* interface;
	//CGemCore* interface;//TOBE CHANGED

	//ULONG  CardState;
	ULONG  StateToNotify;
	
	CSmartCard* smartCard;
	SMARTCARD_EXTENSION smartCardExtention;

	CThread* PoolingThread;
};


#endif // If defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmdebug.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_DBG_INT
#define WDM_DBG_INT
#include "generic.h"
#include "debug.h"

#pragma PAGEDCODE
class CWDMDebug : public CDebug
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
protected:
	CWDMDebug(){m_Status = STATUS_SUCCESS;active = TRUE;};
	virtual ~CWDMDebug(){};
public:
	static CDebug*  create(VOID);

	/*Open(CDevice*) = 0;
	Close(CDevice*) = 0;
	CopyDebug(CDevice*) = 0;
	Print(...) = 0;
	*/
	virtual VOID	start();
	virtual VOID	stop();

	VOID	trace(PCH Format,... );
	VOID 	trace_no_prefix (PCH Format,...);
	VOID	trace_buffer(PVOID pBuffer,ULONG BufferLength);

};	

#endif//DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmdebug.cpp ===
#include "wdmdebug.h"

#pragma PAGEDCODE
CDebug* CWDMDebug::create(VOID)
{ 
CDebug* d;
	d = new (NonPagedPool) CWDMDebug; 
	DBG_PRINT("***** New Debug Object was created 0x%x\n",d);
	RETURN_VERIFIED_OBJECT(d);
}

#pragma PAGEDCODE
VOID CWDMDebug::dispose(VOID)
{ 
LONG Usage;
	Usage = decrementUsage();
	if(Usage<=0)
	{
		trace("**** Deleting Debug Object 0x%x\n",this);
		self_delete();
	}
}

#pragma PAGEDCODE
VOID CWDMDebug::trace (PCH Format,...)
{
	if(!active) return;

va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	::DBG_PRINT(strTempo);
}
#pragma PAGEDCODE
VOID CWDMDebug::trace_no_prefix (PCH Format,...)
{
	if(!active) return;

va_list argpoint;
CHAR  strTempo[1024];
	va_start(argpoint,Format);
	vsprintf(strTempo,Format,argpoint);
	va_end(argpoint);
	::DBG_PRINT_NO_PREFIX(strTempo);
}

#pragma PAGEDCODE
VOID	CWDMDebug::trace_buffer(PVOID pBuffer,ULONG BufferLength)
{
	if(!active) return;
	trace_no_prefix("\n	");
	for(USHORT i=0;i<BufferLength;i++)
	{
		trace_no_prefix("%2.2x ", ((PUCHAR)pBuffer)[i]);
		if(i && !(i%10)) trace_no_prefix("\n	");
	}
	trace_no_prefix("\n");

}
#pragma PAGEDCODE
VOID	CWDMDebug::start()
{
	active = TRUE;
}
#pragma PAGEDCODE
VOID	CWDMDebug::stop()
{
	active = FALSE;
}



///////////////////////////////////////////////////////////////////
// Trace output
//
/*
VOID Trace::Trace(TRACE_LEVEL Level, PCHAR fmt, ...)
{
	int outLen;

	if (Level >= m_TraceLevel)
	{
	// Send the message
		va_list ap;
		va_start(ap, fmt);
		char buf[SCRATCH_BUF_SIZE];

	// format string to buffer
		outLen = _vsnprintf(buf+m_PrefixLength, SCRATCH_BUF_SIZE-m_PrefixLength, fmt, ap);

	// Copy prefix string to buffer
		if (m_Prefix != NULL)
			memcpy(buf, m_Prefix, m_PrefixLength);

	// output to debugger if requested
		if (m_TargetMask & TRACE_DEBUGGER)
			DBG_PRINT(buf);
				
	// output to monitor if requested
		if ((m_Post != 0) && (m_TargetMask & TRACE_MONITOR))
			m_Post(m_Channel, buf + (m_NeedPrefix ? 0 : m_PrefixLength));

	// if the last char was a newline, need prefix next time
		m_NeedPrefix = (buf[m_PrefixLength+outLen-1] == '\n');
	}

	// break if requested
	if ((BREAK_LEVEL) Level >= m_BreakLevel)
		DbgBreakPoint();
}

///////////////////////////////////////////////////////////////////
// Destructor
//
Trace::~Trace(VOID)
{
	if (m_Close && (m_Channel != NULL))
		m_Close(m_Channel);
	if (m_FreeOnDestroy && m_Prefix)
		delete m_Prefix;
}
*/
// End of system function remapping
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmlock.cpp ===
#include "wdmlock.h"

#pragma PAGEDCODE
CLock* CWDMLock::create(VOID)
{ return new (NonPagedPool) CWDMLock; }

#pragma PAGEDCODE
VOID	CWDMLock::initializeSpinLock(PKSPIN_LOCK SpinLock)
{
	  KeInitializeSpinLock(SpinLock);
}

#pragma PAGEDCODE
VOID	CWDMLock::acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql)
{
	  KeAcquireSpinLock(SpinLock,oldIrql);
}

#pragma PAGEDCODE
VOID	CWDMLock::releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql)
{
	  KeReleaseSpinLock(SpinLock,oldIrql);
}

#pragma PAGEDCODE
VOID	CWDMLock::acquireCancelSpinLock(PKIRQL Irql)
{
	::IoAcquireCancelSpinLock(Irql);
}

#pragma PAGEDCODE
VOID	CWDMLock::releaseCancelSpinLock(KIRQL Irql)
{
	::IoReleaseCancelSpinLock(Irql);
}


#pragma PAGEDCODE
LONG	CWDMLock::interlockedIncrement(IN PLONG  Addend)
{
	return ::InterlockedIncrement(Addend);
}

#pragma PAGEDCODE
LONG	CWDMLock::interlockedDecrement(IN PLONG  Addend)
{
	return ::InterlockedDecrement(Addend);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmint.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_INT_INT
#define WDM_INT_INT
#include "generic.h"
#include "int.h"

#pragma PAGEDCODE
class CWDMInterrupt : public CInterrupt
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMInterrupt(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMInterrupt(){};
public:
	static CInterrupt*  create(VOID);

	virtual NTSTATUS	connect(OUT PKINTERRUPT *InterruptObject,
							IN PKSERVICE_ROUTINE ServiceRoutine,
							IN PVOID ServiceContext,
							IN PKSPIN_LOCK SpinLock OPTIONAL,
							IN ULONG Vector,
							IN KIRQL Irql,
							IN KIRQL SynchronizeIrql,
							IN KINTERRUPT_MODE InterruptMode,
							IN BOOLEAN ShareVector,
							IN KAFFINITY ProcessorEnableMask,
							IN BOOLEAN FloatingSave
							);

	virtual VOID		disconnect(IN PKINTERRUPT InterruptObject);
	virtual VOID		initializeDpcRequest(IN PDEVICE_OBJECT pFdo,IN PDEFERRED_FUNCTION DpcForIsr);
	virtual BOOLEAN		synchronizeExecution (	IN PKINTERRUPT Interrupt,
												IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
												IN PVOID SynchronizeContext);         

};	

#endif//CInterrupt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmint.cpp ===
#include "wdmint.h"

#pragma PAGEDCODE
CInterrupt* CWDMInterrupt::create(VOID)
{ return new (NonPagedPool) CWDMInterrupt; }

#pragma PAGEDCODE
NTSTATUS	CWDMInterrupt::connect(OUT PKINTERRUPT *InterruptObject,
					IN PKSERVICE_ROUTINE ServiceRoutine,
					IN PVOID ServiceContext,
					IN PKSPIN_LOCK SpinLock OPTIONAL,
					IN ULONG Vector,
					IN KIRQL Irql,
					IN KIRQL SynchronizeIrql,
					IN KINTERRUPT_MODE InterruptMode,
					IN BOOLEAN ShareVector,
					IN KAFFINITY ProcessorEnableMask,
					IN BOOLEAN FloatingSave	)
{

	return	::IoConnectInterrupt(InterruptObject,ServiceRoutine,ServiceContext,
						SpinLock,Vector,Irql,SynchronizeIrql,
						InterruptMode,ShareVector,ProcessorEnableMask,FloatingSave);
}

#pragma PAGEDCODE
VOID		CWDMInterrupt::disconnect(IN PKINTERRUPT InterruptObject)
{
	::IoDisconnectInterrupt(InterruptObject);
}


#pragma PAGEDCODE
VOID CWDMInterrupt::initializeDpcRequest(IN PDEVICE_OBJECT DeviceObject,IN PDEFERRED_FUNCTION DpcForIsr)
{
	IoInitializeDpcRequest(DeviceObject, DpcForIsr);
	//::KeInitializeDpc( &(DeviceObject)->Dpc,DpcForIsr,NULL);
}

#pragma PAGEDCODE
BOOLEAN		CWDMInterrupt::synchronizeExecution (IN PKINTERRUPT Interrupt,
									IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    
									IN PVOID SynchronizeContext)
{
	return ::KeSynchronizeExecution (Interrupt,SynchronizeRoutine,SynchronizeContext);         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmirp.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef WDM_IRP_INT
#define WDM_IRP_INT
#include "generic.h"
#include "irp.h"

#pragma PAGEDCODE
class CWDMIrp : public CIrp
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMIrp(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMIrp(){};
public:
	static  CIrp*  create(VOID);

	virtual PIRP		allocate(CCHAR StackSize,BOOLEAN ChargeQuota);
	virtual	VOID		initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize);
	virtual	USHORT		sizeOfIrp(IN CCHAR StackSize);

	virtual VOID		free(PIRP Irp);
	virtual PIRP		buildDeviceIoControlRequest(
						   IN ULONG IoControlCode,
						   IN PDEVICE_OBJECT DeviceObject,
						   IN PVOID InputBuffer OPTIONAL,
						   IN ULONG InputBufferLength,
						   IN OUT PVOID OutputBuffer OPTIONAL,
						   IN ULONG OutputBufferLength,
						   IN BOOLEAN InternalDeviceIoControl,
						   IN PKEVENT Event,
						   OUT PIO_STATUS_BLOCK IoStatusBlock
						   );

	virtual PIRP		buildSynchronousFsdRequest(
							IN ULONG MajorFunction,
							IN PDEVICE_OBJECT DeviceObject,
							IN OUT PVOID Buffer OPTIONAL,
							IN ULONG Length OPTIONAL,
							IN PLARGE_INTEGER StartingOffset OPTIONAL,
							IN PKEVENT Event,
							OUT PIO_STATUS_BLOCK IoStatusBlock
							);

	virtual PIO_STACK_LOCATION	getCurrentStackLocation(PIRP Irp);
	virtual PIO_STACK_LOCATION	getNextStackLocation(PIRP Irp);
	virtual VOID		skipCurrentStackLocation(PIRP Irp);
	virtual VOID		setNextStackLocation(IN PIRP Irp);
	virtual VOID		markPending(PIRP Irp);
	virtual VOID		copyCurrentStackLocationToNext(PIRP Irp);
	virtual VOID		setCompletionRoutine(PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
					PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel );
	virtual PDRIVER_CANCEL	setCancelRoutine(PIRP Irp, PDRIVER_CANCEL NewCancelRoutine );
	virtual VOID		completeRequest(PIRP Irp,CCHAR PriorityBoost);
	virtual VOID		startPacket(PDEVICE_OBJECT DeviceObject,PIRP Irp,PULONG Key,PDRIVER_CANCEL CancelFunction);
	virtual VOID		startNextPacket(PDEVICE_OBJECT DeviceObject,BOOLEAN Cancelable);

	// Should it go to interrupt??
	virtual VOID		requestDpc(PDEVICE_OBJECT DeviceObject,PIRP Irp,PVOID Context);

	virtual VOID		cancel(PIRP Irp);
};	

#endif//WDMIRP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmirp.cpp ===
#include "wdmirp.h"

#pragma PAGEDCODE
CIrp* CWDMIrp::create(VOID)
{ return new (NonPagedPool) CWDMIrp; }

#pragma PAGEDCODE
PIRP	CWDMIrp::allocate(IN CCHAR StackSize,IN BOOLEAN ChargeQuota)
{
	return ::IoAllocateIrp(StackSize,ChargeQuota);
}

#pragma PAGEDCODE
VOID	CWDMIrp::initialize(PIRP Irp,USHORT PacketSize,CCHAR StackSize)
{
	::IoInitializeIrp(Irp,PacketSize,StackSize);
}

#pragma PAGEDCODE
USHORT	CWDMIrp::sizeOfIrp(IN CCHAR StackSize)
{
	return IoSizeOfIrp(StackSize);
}

#pragma PAGEDCODE
VOID	CWDMIrp::free(IN PIRP Irp)
{
	::IoFreeIrp(Irp);
}

#pragma PAGEDCODE
VOID	CWDMIrp::cancel(IN PIRP Irp)
{
	::IoCancelIrp(Irp);
}

#pragma PAGEDCODE
PIO_STACK_LOCATION	CWDMIrp::getCurrentStackLocation(IN PIRP Irp)
{
	return IoGetCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
PIO_STACK_LOCATION	CWDMIrp::getNextStackLocation(IN PIRP Irp)
{
	return IoGetNextIrpStackLocation(Irp);
}

#pragma PAGEDCODE
VOID	CWDMIrp::skipCurrentStackLocation(IN PIRP Irp)
{
	IoSkipCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
VOID		CWDMIrp::copyCurrentStackLocationToNext(IN PIRP Irp)
{
	IoCopyCurrentIrpStackLocationToNext(Irp);
}

#pragma PAGEDCODE
VOID		CWDMIrp::setNextStackLocation(IN PIRP Irp)
{
	IoSetNextIrpStackLocation(Irp);
}


#pragma PAGEDCODE
VOID	CWDMIrp::markPending(IN PIRP Irp)
{
	IoMarkIrpPending(Irp);
}



#pragma PAGEDCODE
PDRIVER_CANCEL	CWDMIrp::setCancelRoutine(IN PIRP Irp, PDRIVER_CANCEL NewCancelRoutine )
{
	return IoSetCancelRoutine(Irp, NewCancelRoutine);
}

#pragma PAGEDCODE
VOID	CWDMIrp::startPacket(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp,IN PULONG Key, IN PDRIVER_CANCEL CancelFunction)
{
	::IoStartPacket(DeviceObject,Irp,Key,CancelFunction);
}

#pragma PAGEDCODE
VOID	CWDMIrp::startNextPacket(IN PDEVICE_OBJECT DeviceObject,IN BOOLEAN Cancelable)
{
	::IoStartNextPacket(DeviceObject,Cancelable);
}

#pragma PAGEDCODE
VOID	CWDMIrp::completeRequest(IN PIRP Irp,IN CCHAR PriorityBoost)
{
	IoCompleteRequest(Irp,PriorityBoost);
}

#pragma PAGEDCODE
VOID	CWDMIrp::requestDpc(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp,PVOID Context)
{
	IoRequestDpc(DeviceObject,Irp,Context);
}

#pragma PAGEDCODE
VOID	CWDMIrp::setCompletionRoutine( IN PIRP Irp, PIO_COMPLETION_ROUTINE Routine, 
				PVOID Context, BOOLEAN Success, BOOLEAN Error, BOOLEAN Cancel )
{
	IoSetCompletionRoutine(Irp,Routine,Context,Success,Error,Cancel);
}


#pragma PAGEDCODE
PIRP	CWDMIrp::buildDeviceIoControlRequest(
					   IN ULONG IoControlCode,
					   IN PDEVICE_OBJECT DeviceObject,
					   IN PVOID InputBuffer OPTIONAL,
					   IN ULONG InputBufferLength,
					   IN OUT PVOID OutputBuffer OPTIONAL,
					   IN ULONG OutputBufferLength,
					   IN BOOLEAN InternalDeviceIoControl,
					   IN PKEVENT Event,
					   OUT PIO_STATUS_BLOCK IoStatusBlock
					   )
{
	return IoBuildDeviceIoControlRequest(IoControlCode,
       DeviceObject,
       InputBuffer,
       InputBufferLength,
       OutputBuffer,
       OutputBufferLength,
       InternalDeviceIoControl,
       Event,
       IoStatusBlock
       );
}


#pragma PAGEDCODE
PIRP	CWDMIrp::buildSynchronousFsdRequest(
				IN ULONG MajorFunction,
				IN PDEVICE_OBJECT DeviceObject,
				IN OUT PVOID Buffer OPTIONAL,
				IN ULONG Length OPTIONAL,
				IN PLARGE_INTEGER StartingOffset OPTIONAL,
				IN PKEVENT Event,
				OUT PIO_STATUS_BLOCK IoStatusBlock
				)
{
	return IoBuildSynchronousFsdRequest(MajorFunction,
			DeviceObject, Buffer, Length, StartingOffset, Event, IoStatusBlock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmdev.h ===
//-------------------------------------------------------------------
// This is implementation of WDM device
// Author: Sergey Ivanov
// Log:
//		10/01/99	-	implemented	
//-------------------------------------------------------------------

#ifndef __WDM_ADAPTER__
#define __WDM_ADAPTER__
#include "kernel.h"

#pragma LOCKEDCODE

class CPendingIRP;
class CLinkedList;


#pragma PAGEDCODE
// This is adapter class
// It defines default device methods specific for any WDM.
class CWDMDevice : public CDevice
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
protected:
    NTSTATUS device_Default(PIRP Irp)
    {
	// Default functions to handle requests...
	// By default we do not handle any requests if 
	// they are not reimplimented.
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Information = 0;
        irp->completeRequest(Irp,IO_NO_INCREMENT);
        return STATUS_IO_DEVICE_ERROR;
    };

	NTSTATUS PnP_Default(IN PIRP Irp)
	{
		// Default device does not do anything.
		// So let's just transfer request to low level driver...
		irp->skipCurrentStackLocation(Irp);
		return system->callDriver(m_pLowerDeviceObject, Irp);
	};

	NTSTATUS power_Default(IN PIRP Irp)
	{
		// Default device does not do anything.
		// So let's just transfer request to low level driver...
		power->startNextPowerIrp(Irp);	// must be done while we own the IRP
		irp->skipCurrentStackLocation(Irp);
		return power->callPowerDriver(m_pLowerDeviceObject, Irp);
	}

	NTSTATUS	completeDeviceRequest(PIRP Irp, NTSTATUS status, ULONG_PTR info)
	{	
		// Complete current request with given information

		if (Irp->PendingReturned)
		{
			irp->getCurrentStackLocation(Irp)->Control &=  ~SL_PENDING_RETURNED;
		}

		Irp->IoStatus.Status = status;
		Irp->IoStatus.Information = info;
		irp->completeRequest(Irp,IO_NO_INCREMENT);
		return status;
	}
public:	
	// Redefine base class methods..
	CWDMDevice()
	{
	    m_Status = STATUS_INSUFFICIENT_RESOURCES;
		Signature[0]=L'I';
        Signature[1]=L'S';
        Signature[2]=L'V';

		initialized = FALSE;		
		if(createDeviceObjects())
		{
			//Default our interface
			memory->copy(&InterfaceClassGuid,&GUID_CLASS_GRCLASS,sizeof(GUID));

			// It is reqired to initialize our object directly 
			// through createDeviceObjects() function.
			event->initialize(&IdleState,SynchronizationEvent, TRUE);
			// This event will signal if device is ready to process requests...
			event->initialize(&m_evEnabled,NotificationEvent,TRUE);
			initializeRemoveLock();		
			m_Status = STATUS_SUCCESS;
		}

		Idle_conservation = 0;
		Idle_performance  = 0;
		m_VendorNameLength = 0;
		m_DeviceTypeLength = 0;

		TRACE("WDM device created...\n");
	};

    ~CWDMDevice()
	{
		TRACE("				Destroing WDM device %8.8lX ...\n", this);
		if(!m_RemoveLock.removing)
		{
			TRACE("######## ERROR: surprize destroing...\n");
			remove();
		}
        
		unregisterDeviceInterface(getDeviceInterfaceName());

		Signature[0]++;
        Signature[1]++;

		removeDeviceObjects();
	};


	BOOL checkValid(VOID)
    {
		if(!initialized) return FALSE;

        return (Signature[0]==L'I' && Signature[1]==L'S' 
            && Signature[2]==L'V');
    };

	// It is alright to create device directly or 
	// to call the function
	virtual CDevice*	create(VOID)
	{
		CDevice* obj = new (NonPagedPool) CWDMDevice;
		RETURN_VERIFIED_OBJECT(obj);
	};
	

	virtual VOID dispose()
	{
		TRACE("Destroing WDM device...\n");
		if(!m_RemoveLock.removing)
		{
			TRACE("######## ERROR: surprize destroing...\n");
			remove();
		}
        Signature[0]++;
        Signature[1]++;
		removeDeviceObjects();

		// The device is link to the system.
		// So let system to remove device first and
		// after this we will remove device object...
		//self_delete();
	};

	BOOL createDeviceObjects()
	{
		debug	= kernel->createDebug();
		system	= kernel->createSystem();
		lock	= kernel->createLock();
		irp		= kernel->createIrp();
		event	= kernel->createEvent();
		power	= kernel->createPower();
		memory	= kernel->createMemory();

        m_IoRequests = new (NonPagedPool) CLinkedList<CPendingIRP>;
		if(!system || !irp || !event || !power || !lock 
			|| !memory || !m_IoRequests)
		{
			removeDeviceObjects();
			return FALSE;
		}
		TRACE("WDM device objects created...\n");
		initialized = TRUE;
		return TRUE;
	};

	VOID removeDeviceObjects()
	{
		TRACE("Destroing WDM device objects...\n");

		if(m_IoRequests) delete m_IoRequests;

		if(lock)		lock->dispose();
		if(irp)			irp->dispose();
		if(event)		event->dispose();

		if(power)		power->dispose();
		if(memory)		memory->dispose();

		if(system)		system->dispose();
		if(debug)		debug->dispose();
		initialized = FALSE;
	};

	// This part contains device synchronization functions.
	// They should be used to synchronize device removal.
	// So basically any access to device should be started with acquireRemoveLock()
	// and finished with releaseRemoveLock()...
	#pragma PAGEDCODE
	VOID initializeRemoveLock()
	{							// InitializeRemoveLock
		PAGED_CODE();
		event->initialize(&m_RemoveLock.evRemove, NotificationEvent, FALSE);
		m_RemoveLock.usage = 1;
		m_RemoveLock.removing = FALSE;
	}							// InitializeRemoveLock

	#pragma LOCKEDCODE
	NTSTATUS acquireRemoveLock()
	{ 
		LONG usage = lock->interlockedIncrement(&m_RemoveLock.usage);

		if (m_RemoveLock.removing)
		{						// removal in progress
			if (lock->interlockedDecrement(&m_RemoveLock.usage) == 0)
				event->set(&m_RemoveLock.evRemove,IO_NO_INCREMENT,FALSE);

			TRACE("LOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
			TRACE("****** FAILED TO LOCK WDM DEVICE! REMOVE REQUEST IS ACTIVE! *******\n");
			return STATUS_DELETE_PENDING;
		}
		//TRACE("LOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
		return STATUS_SUCCESS;
	};

	#pragma PAGEDCODE
	VOID	releaseRemoveLock()
	{ 
		ULONG usage;
		if(m_Type==BUS_DEVICE)
		{	//???????????????????????- BIG BIG BUG!!!
			// It is connected only to BUS device!
			// At some conditions not all remove locks was released properly.
			// For other devices it is not appeared at all.
			if(m_RemoveLock.usage<0) m_RemoveLock.usage = 0;
			if (!m_RemoveLock.removing)
			{
				if(m_RemoveLock.usage<2) m_RemoveLock.usage = 2;
			}

		}

		if (usage = lock->interlockedDecrement(&m_RemoveLock.usage) == 0)
				event->set(&m_RemoveLock.evRemove,IO_NO_INCREMENT,FALSE);
		//TRACE("UNLOCK: m_RemoveLock.usage %d\n",m_RemoveLock.usage);
	};

	#pragma PAGEDCODE
	VOID	releaseRemoveLockAndWait()
	{						
		PAGED_CODE();
		TRACE("REMOVING DEVICE...\n");
		m_RemoveLock.removing = TRUE;
		// We are going to remove device.
		// So if somebody is waiting for the active device,
		// first allow them to fail request and complete Irp
		event->set(&m_evEnabled,IO_NO_INCREMENT,FALSE);

		releaseRemoveLock();
		releaseRemoveLock();
		// Child device at bus could be removed by the Bus itself
		// In this case it will not have second AquireRemoveLock from PnP system!
		if(m_Type == CHILD_DEVICE) 
			if(m_RemoveLock.usage<0) m_RemoveLock.usage = 0;
		TRACE("LOCK COUNT ON REMOVING %x\n",m_RemoveLock.usage);
		//ASSERT(m_RemoveLock.usage==0);
		event->waitForSingleObject(&m_RemoveLock.evRemove, Executive, KernelMode, FALSE, NULL);
	}

	BOOL isDeviceLocked()
	{
		lock->interlockedIncrement(&m_RemoveLock.usage);
		// Add device will increment Usage!
		// Current request will add more...
		if(lock->interlockedDecrement(&m_RemoveLock.usage)<=2)
		{
			return FALSE;
		}
		TRACE("Current lock count %d\n",m_RemoveLock.usage);
		return TRUE;
	};

	// Contrary to RemoveLock disableDevice() stops and blocks any active request
	// INSIDE driver. It will not fail the request but will synchronize its
	// execution.
	VOID	disableDevice()
	{
		TRACE("********** DISABLING DEVICE...***********\n");
		event->clear(&m_evEnabled);
	} 

	VOID	enableDevice()
	{
		TRACE("********** ENABLING DEVICE...***********\n");
		event->set(&m_evEnabled,IO_NO_INCREMENT,FALSE);
	}


	BOOL	synchronizeDeviceExecution()
	{	// If device is not ready to process requests, block waiting for the device
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
		NTSTATUS status  = event->waitForSingleObject(&m_evEnabled, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status) || m_RemoveLock.removing) return FALSE;
		return TRUE;
	}
	// Functions to synchronize device execution
	VOID		setBusy()
	{
		event->clear(&IdleState);
		//TRACE("\n			DEVICE BUSY\n");
	};
	
	VOID		setIdle()
	{
		event->set(&IdleState,IO_NO_INCREMENT,FALSE);
		//TRACE("\n			DEVICE IDLE\n");
	};
	
	NTSTATUS	waitForIdle()
	{
		ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
		NTSTATUS status  = event->waitForSingleObject(&IdleState, Executive,KernelMode, FALSE, NULL);
		if(!NT_SUCCESS(status))	return STATUS_IO_TIMEOUT;
		return STATUS_SUCCESS;
	};
	NTSTATUS	waitForIdleAndBlock()
		{
		if(NT_SUCCESS(waitForIdle()))
		{ 
			setBusy();
			return STATUS_SUCCESS;
		}
		else return STATUS_IO_TIMEOUT;
	};
	
	BOOL	registerDeviceInterface(const GUID* Guid)
	{
		if(isDeviceInterfaceRegistered())
		{
			TRACE("Device interface already active...\n");	
			return TRUE;		
		}
		
		if(memory) memory->copy(&InterfaceClassGuid, Guid,sizeof(GUID));

		TRACE("Registering device interface at system...\n");	
		NTSTATUS Status = system->registerDeviceInterface(getPhysicalObject(),
						&InterfaceClassGuid, NULL, getDeviceInterfaceName());
		if(!NT_SUCCESS(Status))
		{
			TRACE("#### Failed to register device interface...\n");
			return FALSE;
		}
		system->setDeviceInterfaceState(getDeviceInterfaceName(),TRUE);
		m_DeviceInterfaceRegistered = TRUE;
		return TRUE;
	};

	VOID	unregisterDeviceInterface(UNICODE_STRING* InterfaceName)
	{
		if(isDeviceInterfaceRegistered())		
		{
			TRACE("Unregistering device interface...\n");	
			system->setDeviceInterfaceState(InterfaceName,FALSE);
		}
		m_DeviceInterfaceRegistered = FALSE;
	};

	virtual NTSTATUS setVendorName(const PCHAR Name,USHORT Length)
	{
		m_VendorNameLength = Length<MAXIMUM_ATTR_STRING_LENGTH? Length:MAXIMUM_ATTR_STRING_LENGTH;
		if(!m_VendorNameLength) return STATUS_INVALID_PARAMETER;
		memory->copy(m_VendorName, Name, m_VendorNameLength);
		return STATUS_SUCCESS;

	};
	virtual NTSTATUS getVendorName(PUCHAR Name,PUSHORT pLength)
	{
		USHORT Len = m_VendorNameLength<*pLength? m_VendorNameLength:*pLength;
		*pLength = Len;
		if(!Len)	return STATUS_INVALID_PARAMETER;
		memory->copy(Name, m_VendorName, Len);
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS setDeviceType(const PCHAR Type,USHORT Length)
	{
		m_DeviceTypeLength = Length<MAXIMUM_ATTR_STRING_LENGTH? Length:MAXIMUM_ATTR_STRING_LENGTH;
		if(!m_DeviceTypeLength) return STATUS_INVALID_PARAMETER;
		memory->copy(m_DeviceType, Type, m_DeviceTypeLength);
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS getDeviceType(PUCHAR Type,PUSHORT pLength)
	{
		USHORT Len = m_DeviceTypeLength<*pLength? m_DeviceTypeLength:*pLength;
		*pLength = Len;
		if(!Len)	return STATUS_INVALID_PARAMETER;
		memory->copy(Type, m_DeviceType, Len);
		return STATUS_SUCCESS;
	};

	// This is basic PnP part of driver.
	// It allows to add and remove device.
	// Specific PnP request should be reimplemented by clients...
	virtual NTSTATUS	createDeviceObjectByName(PDEVICE_OBJECT* ppFdo)
	{
		if(!ALLOCATED_OK(system)) return STATUS_INSUFFICIENT_RESOURCES;
		// By default we will create autogenerated name...
		// Specific implementations can overwrite the function to 
		// change the functionality.
		return system->createDevice(m_DriverObject,sizeof(CWDMDevice*),NULL,
							FILE_DEVICE_UNKNOWN,FILE_AUTOGENERATED_DEVICE_NAME,FALSE,ppFdo);
	};

	virtual NTSTATUS	registerDevicePowerPolicy()
	{	// By default all devices at startup are ON
		if(!ALLOCATED_OK(power)) return STATUS_INSUFFICIENT_RESOURCES;
		POWER_STATE state;
		state.DeviceState = PowerDeviceD0;
		power->declarePowerState(m_DeviceObject, DevicePowerState, state);

		if(m_PhysicalDeviceObject)
		{
			m_CurrentDevicePowerState = PowerDeviceD0;
			m_Idle = power->registerDeviceForIdleDetection(m_PhysicalDeviceObject,Idle_conservation,Idle_performance, PowerDeviceD3);
		}		
		return STATUS_SUCCESS;
	};
	
	virtual NTSTATUS	initializeInterruptSupport()
	{	
		// Here is where we can initialize our DPC (Deferred Procedure Call) object
		// that allows our interrupt service routine to request a DPC to finish handling
		// a device interrupt.
		// At default WDM device we do not do this.
		//interrupt->initializeDpcRequest(m_DeviceObject,&CALLBACK_FUNCTION(DpcForIsr));	
		return STATUS_SUCCESS;
	};

	NTSTATUS	add(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT pPdo)
	{
	NTSTATUS status;
	PDEVICE_OBJECT pFdo;
		if(!ALLOCATED_OK(system)) return STATUS_INSUFFICIENT_RESOURCES;
		TRACE("Add with Driver	%8.8lX,	pPDO %8.8lX\n",DriverObject, pPdo);

		// Init first our objects...
		m_DriverObject = DriverObject;
		m_PhysicalDeviceObject = pPdo;
		// create Fdo for the registered objects.
		// Clients can overwrite device object name and it's visibility.
		status = createDeviceObjectByName(&pFdo);
		if(!NT_SUCCESS(status))
		{
			TRACE("#### Failed to create physical device! Status %x\n",status);
			DISPOSE_OBJECT(m_DeviceObjectName);
			return status;
		}

		TRACE("		Device object was created  %8.8lX\n",pFdo);
		m_DeviceObject = pFdo;
		m_Added = TRUE;

		CLogger* logger = kernel->getLogger();

		if(pPdo)
		{
			m_pLowerDeviceObject = system->attachDevice(pFdo, pPdo);
			if(!m_pLowerDeviceObject)
			{
				TRACE("#### Failed to get lower device object...\n");
				if(ALLOCATED_OK(logger)) 
					logger->logEvent(GRCLASS_FAILED_TO_ADD_DEVICE,getSystemObject());
				system->deleteDevice(pFdo);
				return STATUS_NO_SUCH_DEVICE;
			}
		}
		else m_pLowerDeviceObject = NULL;

		
		initializeInterruptSupport();

		pFdo->Flags |= DO_BUFFERED_IO;
		pFdo->Flags |= DO_POWER_PAGABLE;
		pFdo->Flags &= ~DO_DEVICE_INITIALIZING;

		registerDevicePowerPolicy();
		TRACE("WDM device added...\n");
		return STATUS_SUCCESS;
	};

	VOID	remove()
	{
		if(!m_Added) return;
		TRACE("Removing WDM device...\n");
		// Wait untill we finished all activity at device
		releaseRemoveLockAndWait();

		// Remove device from our system
		TRACE("Unregistering device from kernel...\n");
		kernel->unregisterObject(getSystemObject());

		TRACE("Removing device object name...\n");
		if(m_DeviceObjectName) delete m_DeviceObjectName;
		m_DeviceObjectName = NULL;

		if(m_pLowerDeviceObject)
		{
			TRACE("Detaching device from system...\n");
			system->detachDevice(m_pLowerDeviceObject);
		}
		TRACE("WDM device removed...\n");

		// Tell our system - device removed...
		m_Added = FALSE;

		// Removing device from system could result in
		// requesting Unload() from system if the device was last registered device.
		// So, this call should be last call AFTER disposing the device.
	};

	virtual VOID onDeviceStop()
	{
		return;
	};


	NTSTATUS	forward(PIRP Irp, PIO_COMPLETION_ROUTINE Routine)
	{
	CIoPacket* IoPacket;
		// This function sends the current request
		// If completion routine is not set it will complete
		// the request by default(it means without doing anything special).
		TRACE("WDM forward()...\n");
		IoPacket = new (NonPagedPool) CIoPacket(Irp);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		IoPacket->copyCurrentStackToNext();
		if(Routine)	IoPacket->setCompletion(Routine);
		else        IoPacket->setDefaultCompletionFunction();
		NTSTATUS status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
		
		DISPOSE_OBJECT(IoPacket);
		return status;
	};
	// Send the current request to low level driver and wait for reply
	// Current IRP will not be completed, so we can process it and
	// complete later. 
	// See also description of send() function.
	NTSTATUS	forwardAndWait(PIRP Irp)
	{ // Send request to low level and wait for a reply
	CIoPacket* IoPacket;
	
		TRACE("WDM forwardAndWait()...\n");
		IoPacket = new (NonPagedPool) CIoPacket(Irp);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES; 
		}
		IoPacket->setCurrentStack();
		IoPacket->setStackDefaults();
		NTSTATUS status = system->callDriver(getLowerDriver(),IoPacket->getIrpHandle());
		if(status == STATUS_PENDING)
		{
			TRACE("Waiting for the bus driver to complete...\n");
			ASSERT(system->getCurrentIrql()<=DISPATCH_LEVEL);
			status = IoPacket->waitForCompletion();
			TRACE("Request completed with status %x\n",status);
		}

		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	// WDM by default just forwards requests...
	virtual NTSTATUS   send(CIoPacket* Irp)
	{
		TRACE("WDM sendRequestToDevice()\n");
		if(Irp)	return forward(Irp->getIrpHandle(),NULL);
		else return STATUS_INVALID_PARAMETER;
	};

	virtual NTSTATUS   sendAndWait(CIoPacket* Irp)
	{
		TRACE("WDM sendRequestToDeviceAndWait()\n");
		if(Irp)	return forwardAndWait(Irp->getIrpHandle());
		else return STATUS_INVALID_PARAMETER;
	};

	// Define device interface functions
	virtual  NTSTATUS   write(PUCHAR pRequest,ULONG RequestLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		TRACE("IoPacket with device %x\n",getSystemObject());
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
		IoPacket->setWriteLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);

		TRACE("WDM write()...\n");
		NTSTATUS status = send(IoPacket);
		TRACE("WDM write finished: %x\n", status);

		DISPOSE_OBJECT(IoPacket);
		return status;
	};
	
	virtual  NTSTATUS   writeAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		TRACE("IoPacket with device %x\n",getSystemObject());
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_WRITE);
		IoPacket->setWriteLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);

		TRACE("WDM sendAndWait()...\n");
		NTSTATUS status = sendAndWait(IoPacket);
		TRACE("WDM writeAndWait finished: %x\n",status);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			DISPOSE_OBJECT(IoPacket);
			return status;
		}

		*pReplyLength = (ULONG)IoPacket->getInformation();
		IoPacket->getSystemReply(pReply,*pReplyLength);
		//TRACE_BUFFER(pReply,*pReplyLength);
		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	virtual  NTSTATUS   readAndWait(PUCHAR pRequest,ULONG RequestLength,PUCHAR pReply,ULONG* pReplyLength)
	{
	CIoPacket* IoPacket;
		if(!pRequest || !RequestLength || !pReply || !pReplyLength) return STATUS_INVALID_PARAMETER;
		IoPacket = new (NonPagedPool) CIoPacket(getLowerDriver()->StackSize);
		if(!ALLOCATED_OK(IoPacket))
		{
			DISPOSE_OBJECT(IoPacket);
			return STATUS_INSUFFICIENT_RESOURCES;
		}
		IoPacket->setTimeout(getCommandTimeout());
		IoPacket->buildStack(getSystemObject(),IRP_MJ_READ);
		IoPacket->setReadLength(RequestLength);
		IoPacket->copyBuffer(pRequest,RequestLength);
	
		TRACE("WDM sendAndWait()...\n");
		NTSTATUS status = sendAndWait(IoPacket);
		TRACE("WDM sendAndWait finished: %x\n",status);
		if(!NT_SUCCESS(status))
		{
			*pReplyLength = 0;
			DISPOSE_OBJECT(IoPacket);
			return status;
		}

		*pReplyLength = (ULONG)IoPacket->getInformation();
		IoPacket->getSystemReply(pReply,*pReplyLength);

		TRACE_BUFFER(pReply,*pReplyLength);
		DISPOSE_OBJECT(IoPacket);
		return status;
	};

	NTSTATUS synchronizeDevicePowerState()
	{
		if (m_CurrentDevicePowerState!=PowerDeviceD0) 
		{
			NTSTATUS status;
			TRACE("RESTORING DEVICE POWER ON from state %d!\n",m_CurrentDevicePowerState);
			status = sendDeviceSetPower(PowerDeviceD0,TRUE);
			if(!NT_SUCCESS(status))
			{
				TRACE("FAILED TO SET POWER ON DEVICE STATE!\n");
				return status;
			}
		}
		return STATUS_SUCCESS;
	}

	NTSTATUS sendDeviceSetPower(DEVICE_POWER_STATE devicePower, BOOLEAN wait)
	{// SendDeviceSetPower
	POWER_STATE state;
	NTSTATUS status;

		state.DeviceState = devicePower;
		if (wait)
		{// synchronous operation
			KEVENT Event;
			event->initialize(&Event, NotificationEvent, FALSE);
			POWER_CONTEXT context = {&Event};

			status = power->requestPowerIrp(getPhysicalObject(), IRP_MN_SET_POWER, state,
				(PREQUEST_POWER_COMPLETE) onSendDeviceSetPowerComplete, &context, NULL);
			if (status == STATUS_PENDING)
			{
				event->waitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
				status = context.status;
			}
		}// synchronous operation
		else
			status = power->requestPowerIrp(getPhysicalObject(), IRP_MN_SET_POWER, 
						state, NULL, NULL, NULL);
		
		return status;
	}// SendDeviceSetPower
	// These functions define default interface with system.
	// Clients should redefine them if they would like to have
	// specific functionality.
	virtual NTSTATUS pnpRequest(IN PIRP irp){return PnP_Default(irp);};
	virtual NTSTATUS powerRequest(PIRP irp) {return power_Default(irp);};
	
	// By default we allow user to get connection with device
	virtual NTSTATUS open(PIRP irp) {return completeDeviceRequest(irp, STATUS_SUCCESS, 0); };//Create
    virtual NTSTATUS close(PIRP irp){return completeDeviceRequest(irp, STATUS_SUCCESS, 0); };

	virtual NTSTATUS read(PIRP irp) { return device_Default(irp); };
    virtual NTSTATUS write(PIRP irp) { return device_Default(irp); };

    virtual NTSTATUS deviceControl(PIRP irp) { return device_Default(irp);};
    
    virtual NTSTATUS cleanup(PIRP irp) { return device_Default(irp); };
    virtual NTSTATUS flush(PIRP irp) { return device_Default(irp); };
	// Standard system startIo
	// Actually we do not use it for now. 
	// Instead we have our own synchronization facilities.
	virtual VOID	 startIo(PIRP irp){};
//---------------------------------------------------------------------------//
//					SYNCHRONIZATION FACILITIES								 //
//---------------------------------------------------------------------------//
// To make synchronization at the driver we have to store and make pending
// all our requests.
// Specific devices should set specific thread which will start all pending Irp. 	
//---------------------------------------------------------------------------//
	// CALLBACK FUNCTION:
	// This function will not only complete current Irp but also will dispose
	// corresponding IoRequest if any was pending at driver.
#pragma LOCKEDCODE
	virtual  VOID	 cancelPendingIrp(PIRP Irp)
	{
	KIRQL ioIrql;
		// 1.
		// We keep pending Irp inside list of IoRequests.
		// So we do not need to warry about removing Irp from a queue...
		// 2.
		// As soon as IoRequest started, we do not allow to cancel it.
		// So, in this case this function will not be called and it is responsibility
		// of the driver to finish (or cancel) active IoRequest.
		// It means this function should not warry about active (and removed from our queue)
		// IoRequests. But it has to warry about not yet started requests...

		
		TRACE("		 CANCELLING IRP %8.8lX...\n", Irp);
		// Release cancel spin lock if somebody own it...
		lock->releaseCancelSpinLock(Irp->CancelIrql);

		// Get our own spin lock in case somebody desided to cancel this Irp 
		lock->acquireCancelSpinLock(&ioIrql);
		// Reset our cancel routine to prevent it being called... 
		irp->setCancelRoutine(Irp, NULL);

		// If Irp was on the queue - remove IoRequest from queue...
		if(m_IoRequests)
		{
			CPendingIRP* IrpReq = m_IoRequests->getFirst();
			while (IrpReq) 
			{
				if(IrpReq->Irp == Irp)
				{	// We found our Irp.
					m_IoRequests->remove(IrpReq);
					TRACE("		IO REQUEST WAS DISPOSED...\n");
					IrpReq->dispose();
					break;
				}
				IrpReq = m_IoRequests->getNext(IrpReq);
			}
		}


		if(m_OpenSessionIrp == Irp)
		{
			TRACE("		OPEN SESSION IRP WAS CANCELLED...\n");
			m_OpenSessionIrp = NULL;
		}

		// Complete Irp as canceled...
		Irp->IoStatus.Status = STATUS_CANCELLED;
		Irp->IoStatus.Information = 0;
		// Release our spin lock...
		lock->releaseCancelSpinLock(ioIrql);
		TRACE("		IRP %8.8lX WAS CANCELLED...\n", Irp);
		irp->completeRequest(Irp, IO_NO_INCREMENT);
	};
#pragma PAGEDCODE

	virtual CLinkedList<CPendingIRP>* getIoRequestsQueue()
	{	
        return m_IoRequests;
	};


	virtual NTSTATUS makeRequestPending(PIRP Irp_request,PDEVICE_OBJECT toDeviceObject,PENDING_REQUEST_TYPE Type)
	{
	KIRQL OldIrql;

		lock->acquireCancelSpinLock(&OldIrql);
		if (Irp_request->Cancel) 
		{            
			TRACE("		<<<<<< IO REQUEST CANCELLED... %8.8lX>>>>>>\n",Irp_request);
			lock->releaseCancelSpinLock(OldIrql);
			return STATUS_CANCELLED;
		} 
		else 
		{
			TRACE("		<<<<<< IO REQUEST PENDING %8.8lX>>>>>>\n",Irp_request);

			CPendingIRP* IrpReq = new (NonPagedPool) CPendingIRP(Irp_request,Type,toDeviceObject);
			if(!IrpReq)
			{
				lock->releaseCancelSpinLock(OldIrql);
				TRACE("ERROR! FAILED TO ALLOCATE IoRequest. LOW ON MEMORY!\n");
				return completeDeviceRequest(Irp_request,STATUS_INSUFFICIENT_RESOURCES,0);
			}

			Irp_request->IoStatus.Information=0;
			Irp_request->IoStatus.Status=STATUS_PENDING;
			irp->setCancelRoutine(Irp_request, CALLBACK_FUNCTION(cancelPendingIrp));
			lock->releaseCancelSpinLock(OldIrql);
			irp->markPending(Irp_request); 
			m_IoRequests->New(IrpReq);
			return STATUS_PENDING;
		}
	};

	// Cancel current pending IO request 
	virtual NTSTATUS cancelPendingRequest(CPendingIRP* IrpReq)
	{
		// Next function will remove and dispose our request...
		cancelPendingIrp(IrpReq->Irp);
		return STATUS_CANCELLED;
	};
	
	// Cancel all pending IO requests
	virtual NTSTATUS cancelAllPendingRequests()
	{
		// Next function will remove and dispose our request...
		if(m_IoRequests)
		{
			CPendingIRP* IrpReqNext;
			CPendingIRP* IrpReq = m_IoRequests->getFirst();
			while (IrpReq) 
			{
				IrpReqNext = m_IoRequests->getNext(IrpReq);
				cancelPendingRequest(IrpReq);// This  call will dispose request...
				IrpReq = IrpReqNext;
			}
		}
		if(m_OpenSessionIrp)	cancelPendingIrp(m_OpenSessionIrp);
		return STATUS_CANCELLED;
	};


	// Checks if request queue is empty and if it is NOT - starts next request...
	// This function will be called by the Irp processing thread.
	virtual NTSTATUS startNextPendingRequest()
	{
		TRACE("		startNextPendingRequest() was called...\n");
		if (!m_IoRequests->IsEmpty())
		{	
		KIRQL OldIrql;
		CDevice* device;
		NTSTATUS status;
			CPendingIRP* IrpReq	=	m_IoRequests->removeHead();
			if(!IrpReq) return STATUS_INVALID_PARAMETER;
			
			lock->acquireCancelSpinLock(&OldIrql);
			// Now Irp can not be canceled!
			irp->setCancelRoutine(IrpReq->Irp, NULL);
			if (IrpReq->Irp->Cancel) 
			{            
				lock->releaseCancelSpinLock(OldIrql);
				// Current Irp was already canceled,
				// Cancel function will be called shortly.
				// So just forget about current Irp.
				return STATUS_SUCCESS;;
			} 
			lock->releaseCancelSpinLock(OldIrql);
	
			device = (CDevice*)IrpReq->DeviceObject->DeviceExtension;
			// Call device specific startIo function...
			TRACE("		Device startIoRequest() was called...\n");
			if(device) status = device->startIoRequest(IrpReq);
			else	   status = STATUS_INVALID_DEVICE_STATE;
			return status;
		}
		return STATUS_SUCCESS;
	};

	virtual NTSTATUS ThreadRoutine()
	{
	//NTSTATUS status;
		//if(!NT_SUCCESS(status = waitForIdleAndBlock())) return status;
		// If somebody inserted pending request - dispatch it...
		// It will call specific child device startIoRequest().
		// It is up to that device how to handle it.
		// If child device is busy - it can insert this request into
		// child device request queue again and process it later...
		startNextPendingRequest();
		//setIdle();
		return STATUS_SUCCESS;
	};	


	// Device specific function which processes pending requests...
	// It will be redefined by specific devices.
	// This function always should be virtual because
	// we expect specific device behaviour...
	virtual NTSTATUS startIoRequest(CPendingIRP* IoReq) 
	{ 
		// Default startIo just cancel current request.
		// IoReq will be disposed...
		if(IoReq)
		{
			cancelPendingRequest(IoReq);
		}
		return STATUS_SUCCESS;
	};
};

#endif //If not defined
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmevent.h ===
#ifndef WDM_EV_INT
#define WDM_EV_INT
#include "generic.h"
#include "event.h"

#pragma PAGEDCODE
class CWDMEvent : public CEvent
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMEvent(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMEvent(){};
public:
	static CEvent*  create(VOID);
	
	virtual VOID		initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State);
	virtual VOID		clear(PRKEVENT Event);
	virtual LONG		reset(PRKEVENT Event);
	virtual LONG		set(PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait);

	virtual NTSTATUS	waitForSingleObject (PVOID Object,
							KWAIT_REASON WaitReason,IN KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout);
	virtual NTSTATUS	waitForMultipleObjects(ULONG Count,
							PVOID Object[],
							WAIT_TYPE WaitType,
							KWAIT_REASON WaitReason,
							KPROCESSOR_MODE WaitMode,
							BOOLEAN Alertable,
							PLARGE_INTEGER Timeout,
							PKWAIT_BLOCK WaitBlockArray);

};	

#endif//WDM_EV_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmevent.cpp ===
#include "wdmevent.h"

#pragma PAGEDCODE
CEvent* CWDMEvent::create(VOID)
{ return new (NonPagedPool) CWDMEvent; }

#pragma PAGEDCODE
VOID	CWDMEvent::initialize(IN PRKEVENT Event,IN EVENT_TYPE Type,IN BOOLEAN State)
{
	::KeInitializeEvent(Event,Type,State);
}


#pragma PAGEDCODE
VOID	CWDMEvent::clear(IN PRKEVENT Event)
{
	::KeClearEvent (Event);
}

#pragma PAGEDCODE
LONG	CWDMEvent::reset(IN PRKEVENT Event)
{
	return ::KeResetEvent (Event);
}

#pragma PAGEDCODE
LONG	CWDMEvent::set(IN PRKEVENT Event,IN KPRIORITY Increment,IN BOOLEAN Wait)
{
	return ::KeSetEvent (Event,Increment,Wait);
}

#pragma PAGEDCODE
NTSTATUS	CWDMEvent::waitForSingleObject (IN PVOID Object,
						IN KWAIT_REASON WaitReason,IN KPROCESSOR_MODE WaitMode,
						IN BOOLEAN Alertable,
						IN PLARGE_INTEGER Timeout OPTIONAL)
{
	ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
	return ::KeWaitForSingleObject (Object,WaitReason,WaitMode,Alertable,Timeout);
}

#pragma PAGEDCODE
NTSTATUS	CWDMEvent::waitForMultipleObjects(ULONG Count,
						PVOID Object[],
						WAIT_TYPE WaitType,
						KWAIT_REASON WaitReason,
						KPROCESSOR_MODE WaitMode,
						BOOLEAN Alertable,
						PLARGE_INTEGER Timeout,
						PKWAIT_BLOCK WaitBlockArray)
{
	ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
	return ::KeWaitForMultipleObjects(Count,Object,WaitType,
							WaitReason,	WaitMode,Alertable,
							Timeout,WaitBlockArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmlog.h ===
#ifndef __WDM_LOG__
#define __WDM_LOG__
#include "logger.h"

#pragma PAGEDCODE
class CWDMLogger : public CLogger
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID);
private:
	PWSTR m_LoggerName;
protected:
	CWDMLogger();
public:
	CWDMLogger(PWSTR LoggerName);
	virtual ~CWDMLogger();
	static CLogger* create(VOID);

	virtual VOID logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo);
};

#endif//LOGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmmem.cpp ===
#include "wdmmem.h"

#pragma PAGEDCODE
CMemory* CWDMMemory::create(VOID)
{ return new (NonPagedPool) CWDMMemory; }

#pragma PAGEDCODE
VOID*	CWDMMemory::allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes)
{
	if(!NumberOfBytes) return NULL;
	//return ::ExAllocatePool(PoolType,NumberOfBytes);
	return ::ExAllocatePoolWithTag(PoolType,NumberOfBytes,'_GRU');
}

#pragma PAGEDCODE
VOID	CWDMMemory::zero(IN PVOID pMem,IN SIZE_T size)
{
	::RtlZeroMemory(pMem,size);
}

#pragma PAGEDCODE
VOID	CWDMMemory::free(IN PVOID pMem)
{
	::ExFreePool((PVOID)pMem);
}

#pragma PAGEDCODE
VOID	CWDMMemory::copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length)
{
	::RtlCopyMemory(Destination,Source,Length);
}

#pragma PAGEDCODE
PVOID CWDMMemory::mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType)
{
	return ::MmMapIoSpace(PhysicalAddress,NumberOfBytes,CacheType);
}

#pragma PAGEDCODE
VOID CWDMMemory::unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes)
{
	::MmUnmapIoSpace (BaseAddress,NumberOfBytes);
}

#pragma PAGEDCODE
VOID	CWDMMemory::set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill)
{
	::RtlFillMemory(Destination,Length,(UCHAR)Fill);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmlock.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDM_LOCK_INT
#define WDM_LOCK_INT
#include "generic.h"
#include "lock.h"

#pragma PAGEDCODE
class CWDMLock : public CLock
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMLock(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMLock(){};
public:
	static  CLock*  create();

	virtual VOID	initializeSpinLock(PKSPIN_LOCK SpinLock);
	virtual VOID	acquireSpinLock(PKSPIN_LOCK SpinLock, PKIRQL oldIrql);
	virtual VOID	releaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL oldIrql);
	virtual VOID	acquireCancelSpinLock(PKIRQL Irql);
	virtual VOID	releaseCancelSpinLock(KIRQL Irql);
	virtual LONG	interlockedIncrement(IN PLONG  Addend);
	virtual LONG	interlockedDecrement(IN PLONG  Addend);

};	

#endif//CWDMLock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmlog.cpp ===
#include "generic.h"
#include "logger.h"
#include "wdmlog.h"

#pragma PAGEDCODE
CWDMLogger::CWDMLogger()
{
	m_LoggerName = L"GRClass";
}

#pragma PAGEDCODE
CWDMLogger::CWDMLogger(PWSTR LoggerName)
{
	wcscpy(m_LoggerName,LoggerName);
	m_Status = STATUS_SUCCESS;
}

#pragma PAGEDCODE
CWDMLogger::~CWDMLogger()
{
}

#pragma PAGEDCODE
VOID CWDMLogger::logEvent(NTSTATUS ErrorCode, PDEVICE_OBJECT fdo)
{	// Win98 doesn't support event logging, so don't bother
	if (isWin98())
	{
		switch(ErrorCode)
		{
		case GRCLASS_START_OK:
			DBG_PRINT("Logger: GrClass driver was initialized succesfuly!\n");
			break;
		case GRCLASS_FAILED_TO_ADD_DEVICE:
			DBG_PRINT("Logger: ######### GrClass failed to add device!\n");
			break;
		case GRCLASS_FAILED_TO_CREATE_INTERFACE:
			DBG_PRINT("Logger: ######### GrClass failed to create interface object!\n");
			break;
		case GRCLASS_FAILED_TO_CREATE_READER:
			DBG_PRINT("Logger: ######### GrClass failed to create reader object!\n");
			break;
		case GRCLASS_BUS_DRIVER_FAILED_REQUEST:
			DBG_PRINT("Logger: ######### Bus driver failed GrClass driver request!\n");
			break;
		}
		return;
	}
	else
	{
		ULONG packetlen = (wcslen(m_LoggerName) + 1) * sizeof(WCHAR) + sizeof(IO_ERROR_LOG_PACKET) + 4;
		// packet will be too big
		if (packetlen > ERROR_LOG_MAXIMUM_SIZE)	return;

		PIO_ERROR_LOG_PACKET p = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(fdo, (UCHAR) packetlen);
		if (!p)	return;

		memset(p, 0, sizeof(IO_ERROR_LOG_PACKET));
		p->MajorFunctionCode = IRP_MJ_PNP;
		p->ErrorCode = ErrorCode;
		p->DumpDataSize = 4;
		p->DumpData[0] = 0x2A2A2A2A;

		p->StringOffset = sizeof(IO_ERROR_LOG_PACKET) + p->DumpDataSize - sizeof(ULONG);
		p->NumberOfStrings = 1;
		wcscpy((PWSTR) ((PUCHAR) p + p->StringOffset), m_LoggerName);

		IoWriteErrorLogEntry(p);
	}
}


#pragma PAGEDCODE
CLogger* CWDMLogger::create(VOID)
{ 
CLogger* logger;
	logger = new (NonPagedPool) CWDMLogger; 
	if (isWin98())	DBG_PRINT("***** New Logger Object was created 0x%x\n",logger);
	RETURN_VERIFIED_OBJECT(logger);
}

#pragma PAGEDCODE
VOID CWDMLogger::dispose(VOID)
{ 
LONG Usage;
	Usage = decrementUsage();
	if(Usage<=0)
	{
		if (isWin98())	DBG_PRINT("**** Deleting Logger Object 0x%x\n",this);
		self_delete();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmsem.cpp ===
#include "wdmsem.h"

#pragma PAGEDCODE
CSemaphore* CWDMSemaphore::create(VOID)
{ return new (NonPagedPool) CWDMSemaphore; }

#pragma PAGEDCODE
VOID	CWDMSemaphore::initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit)
{
	::KeInitializeSemaphore (Semaphore,Count,Limit);
}

#pragma PAGEDCODE
LONG	CWDMSemaphore::release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait)
{
	return ::KeReleaseSemaphore(Semaphore,Increment,Adjustment,Wait);

}

#pragma PAGEDCODE
LONG	CWDMSemaphore::getState(IN PRKSEMAPHORE Semaphore)
{
	return KeReadStateSemaphore(Semaphore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmpower.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDM_PWR_INT
#define WDM_PWR_INT
#include "generic.h"
#include "power.h"

#pragma PAGEDCODE
class CWDMPower : public CPower
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMPower(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMPower(){};
public:
	static CPower*  create(VOID);

	virtual PULONG		registerDeviceForIdleDetection (
							IN PDEVICE_OBJECT     DeviceObject,
							IN ULONG              ConservationIdleTime,
							IN ULONG              PerformanceIdleTime,
							IN DEVICE_POWER_STATE State
							);

	virtual POWER_STATE	declarePowerState(IN PDEVICE_OBJECT   DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State);

	virtual VOID		startNextPowerIrp(IN PIRP Irp);
	virtual VOID		skipCurrentStackLocation(PIRP Irp);

	
	virtual NTSTATUS	callPowerDriver (IN PDEVICE_OBJECT DeviceObject,IN OUT PIRP Irp);
	virtual VOID		setPowerDeviceBusy(PULONG	IdlePointer);
	virtual NTSTATUS	requestPowerIrp(
						IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL);
};	

#endif//POWER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmpower.cpp ===
#include "wdmpower.h"

#pragma PAGEDCODE
CPower* CWDMPower::create(VOID)
{ return new (NonPagedPool) CWDMPower; }

#pragma PAGEDCODE
PULONG		CWDMPower::registerDeviceForIdleDetection (
						IN PDEVICE_OBJECT     DeviceObject,
						IN ULONG              ConservationIdleTime,
						IN ULONG              PerformanceIdleTime,
						IN DEVICE_POWER_STATE State	)
{
	return	::PoRegisterDeviceForIdleDetection (DeviceObject,
				ConservationIdleTime,PerformanceIdleTime,State);
}

#pragma PAGEDCODE
POWER_STATE	CWDMPower::declarePowerState(IN PDEVICE_OBJECT DeviceObject,IN POWER_STATE_TYPE Type,IN POWER_STATE State)
{
	return ::PoSetPowerState(DeviceObject,Type,State);
}


#pragma PAGEDCODE
VOID		CWDMPower::startNextPowerIrp(IN PIRP Irp)
{
	::PoStartNextPowerIrp(Irp);
}

#pragma PAGEDCODE
NTSTATUS		CWDMPower::callPowerDriver (IN PDEVICE_OBJECT pFdo,IN OUT PIRP Irp)
{
	return ::PoCallDriver (pFdo,Irp);
}

#pragma PAGEDCODE
VOID		CWDMPower::setPowerDeviceBusy(PULONG	IdlePointer)
{
	PoSetDeviceBusy(IdlePointer);
}

#pragma PAGEDCODE
VOID		CWDMPower::skipCurrentStackLocation(IN PIRP Irp)
{
	IoSkipCurrentIrpStackLocation(Irp);
}

#pragma PAGEDCODE
NTSTATUS		CWDMPower::requestPowerIrp(
						IN PDEVICE_OBJECT DeviceObject,
						IN UCHAR MinorFunction,
						IN POWER_STATE PowerState,
						IN PREQUEST_POWER_COMPLETE CompletionFunction,
						IN PVOID Context,
						OUT PIRP *Irp OPTIONAL)
{
	return ::PoRequestPowerIrp(DeviceObject,MinorFunction,PowerState,
								CompletionFunction,Context,Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmmem.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:

#ifndef WDM_MEM_INT
#define WDM_MEM_INT
#include "generic.h"
#include "memory.h"

#pragma PAGEDCODE
class CWDMMemory : public CMemory
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMMemory(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMMemory(){};
public:
	static  CMemory*  create(VOID);
	virtual PVOID		allocate(IN POOL_TYPE PoolType,IN SIZE_T NumberOfBytes);
	virtual VOID		zero(IN PVOID pMem,IN SIZE_T size);
	virtual VOID		free(IN PVOID pMem);
	virtual VOID		copy(IN VOID UNALIGNED *Destination,IN CONST VOID UNALIGNED *Source, IN SIZE_T Length);

	virtual PVOID		mapIoSpace(IN PHYSICAL_ADDRESS PhysicalAddress,IN SIZE_T NumberOfBytes,IN MEMORY_CACHING_TYPE CacheType);
	virtual VOID		unmapIoSpace(IN PVOID BaseAddress,IN SIZE_T NumberOfBytes);
	virtual VOID		set(IN VOID UNALIGNED *Destination,IN SIZE_T Length,LONG Fill);

};	

#endif//MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmtimer.h ===
// Gemplus (C) 1999
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//

#ifndef __WDM_TIMER__
#define __WDM_TIMER__
#include "generic.h"
#include "timer.h"

#pragma PAGEDCODE
// This class will manage creation and 
// manipulation of driver Timers
class CWDMTimer : public CTimer
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMTimer(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMTimer();
public:
	CWDMTimer(TIMER_TYPE Type);

	static CTimer* create(TIMER_TYPE Type);

	virtual BOOL set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc);
	virtual BOOL cancel();
	VOID	delay(ULONG Delay);

};

#endif//WDM_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmtimer.cpp ===
#include "wdmtimer.h"

#pragma PAGEDCODE
CTimer* CWDMTimer::create(TIMER_TYPE Type)
{ 
	return new (NonPagedPool) CWDMTimer(Type);
}

#pragma PAGEDCODE
CWDMTimer::CWDMTimer(TIMER_TYPE Type)
{
	KeInitializeTimerEx(&Timer, Type);
};

#pragma PAGEDCODE
CWDMTimer::~CWDMTimer()
{
	KeCancelTimer(&Timer);
};

#pragma PAGEDCODE
BOOL CWDMTimer::set(LARGE_INTEGER DueTime,LONG Period,PKDPC Dpc)
{
	return KeSetTimerEx(&Timer,DueTime, Period, Dpc);
};

#pragma PAGEDCODE
BOOL CWDMTimer::cancel()
{
	return KeCancelTimer(&Timer);
};

#pragma PAGEDCODE
VOID CWDMTimer::delay(ULONG Delay)
{
LARGE_INTEGER duetime;
    // Waits for the Timeout to be elapsed.
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    duetime.QuadPart = -(LONGLONG)(Delay * 10L * 1000L);
    set(duetime,0,NULL);
    KeWaitForSingleObject(&Timer, Executive, KernelMode, FALSE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmsem.h ===
// Gemplus (C) 2000
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.2000
// Change log:
//
#ifndef WDEM_SEM_INT
#define WDM_SEM_INT
#include "generic.h"
#include "semaphore.h"

#pragma PAGEDCODE
class CWDMSemaphore: public CSemaphore
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMSemaphore(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMSemaphore(){};
public:
	static CSemaphore* create(VOID);
	
	virtual VOID		initialize(IN PRKSEMAPHORE Semaphore, IN LONG Count, IN LONG Limit);
	virtual LONG		release(IN PRKSEMAPHORE Semaphore,IN KPRIORITY Increment,IN LONG Adjustment,IN BOOLEAN Wait);
	virtual LONG		getState(IN PRKSEMAPHORE Semaphore);
};	

#endif//SEMAPHORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmsys.h ===
// Gemplus (C) 1999
// This is main Driver object for the driver.
//
// Version 1.0
// Author: Sergey Ivanov
// Date of creation - 18.05.1999
// Change log:
//
#ifndef WDMSYS_INT
#define WDMSYS_INT
#include "generic.h"
#include "system.h"

#pragma PAGEDCODE
// Interface to general system services...
class CWDMSystem : public CSystem
{
public:
	NTSTATUS m_Status;
	SAFE_DESTRUCTORS();
	virtual VOID dispose(VOID){self_delete();};
protected:
	CWDMSystem(){m_Status = STATUS_SUCCESS;};
	virtual ~CWDMSystem(){};
public:
	static CSystem*  create(VOID);

	// This object will implement next interfaces...
	virtual NTSTATUS	createDevice(PDRIVER_OBJECT DriverObject,
							ULONG DeviceExtensionSize,
							PUNICODE_STRING DeviceName OPTIONAL,
							DEVICE_TYPE DeviceType,
							ULONG DeviceCharacteristics,
							BOOLEAN Reserved,
							PDEVICE_OBJECT *DeviceObject);

	virtual VOID			deleteDevice(PDEVICE_OBJECT DeviceObject);

	virtual PDEVICE_OBJECT	attachDevice(PDEVICE_OBJECT FuncDevice,IN PDEVICE_OBJECT PhysDevice);
	virtual VOID			detachDevice(PDEVICE_OBJECT TargetDevice);

	virtual NTSTATUS		callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp);

	virtual NTSTATUS	registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
							CONST GUID *InterfaceClassGuid,
							PUNICODE_STRING ReferenceString,     OPTIONAL
							PUNICODE_STRING SymbolicLinkName);
	virtual NTSTATUS	setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,BOOLEAN Enable);

	virtual NTSTATUS		createSystemThread(OUT PHANDLE ThreadHandle,
								IN ULONG DesiredAccess,
								IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
								IN HANDLE ProcessHandle OPTIONAL,
								OUT PCLIENT_ID ClientId OPTIONAL,
								IN PKSTART_ROUTINE StartRoutine,
								IN PVOID StartContext);
	virtual NTSTATUS		terminateSystemThread(IN NTSTATUS ExitStatus);

	virtual NTSTATUS		referenceObjectByHandle(IN HANDLE Handle,                                           
								IN ACCESS_MASK DesiredAccess,                               
								IN POBJECT_TYPE ObjectType OPTIONAL,                        
								IN KPROCESSOR_MODE AccessMode,                              
								OUT PVOID *Object,                                          
								OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
								);
	virtual VOID			referenceObject(IN PVOID Object);
	virtual VOID			dereferenceObject(IN PVOID Object);
	virtual PDEVICE_OBJECT	getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject);

	virtual NTSTATUS	    ZwClose(IN HANDLE Handle);

	virtual NTSTATUS		createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName);
	virtual NTSTATUS		deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName);
	virtual VOID			invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type);
	virtual NTSTATUS		getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
								IN ACCESS_MASK DesiredAccess,
								OUT PFILE_OBJECT *FileObject,
								OUT PDEVICE_OBJECT *DeviceObject);

	virtual VOID			raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql);
	virtual VOID			lowerIrql (IN KIRQL NewIrql);
	virtual KIRQL			getCurrentIrql();

	virtual VOID			initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue);
	virtual BOOLEAN			insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);
	virtual BOOLEAN			insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey);
	virtual PKDEVICE_QUEUE_ENTRY	removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue);
	virtual PKDEVICE_QUEUE_ENTRY	removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey);
	virtual BOOLEAN			removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry);

	virtual NTSTATUS		openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
								IN ULONG DevInstKeyType,
								IN ACCESS_MASK DesiredAccess,
								OUT PHANDLE DevInstRegKey
								);

	virtual NTSTATUS		ZwQueryValueKey(IN HANDLE KeyHandle,
								IN PUNICODE_STRING ValueName,
								IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
								OUT PVOID KeyValueInformation,
								IN ULONG Length,
								OUT PULONG ResultLength
								);
	virtual NTSTATUS		getDeviceProperty(IN PDEVICE_OBJECT DeviceObject,
								IN DEVICE_REGISTRY_PROPERTY DeviceProperty,
								IN ULONG BufferLength,
								OUT PVOID PropertyBuffer,
								OUT PULONG ResultLength
								);


	virtual VOID			initializeFastMutex(IN PFAST_MUTEX FastMutex);
	virtual VOID			acquireFastMutex(IN PFAST_MUTEX FastMutex);
	virtual VOID			releaseFastMutex(IN PFAST_MUTEX FastMutex);
};	

#endif //WDMSYS_INT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprcmd.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	gprcmd.h 

Description: 
	 This module holds the prototypes of the functions 
	 from gprcmd.c   
Environment:
	Kernel Mode

Revision History: 
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/


//   Include
//   - smclib.h: smart card library definitions.
#include <smclib.h>


#ifndef _GPRCMD_
#define _GPRCMD_


//
// To give possibility for recognition of driver
//

#define ATTR_MANUFACTURER_NAME      "Gemplus"
#define ATTR_ORIGINAL_FILENAME      "Gpr400.sys"
#define ATTR_LENGTH                 32

//
//   - SCARD_ATTR_SPEC_BAUD_RATE is the Tag for the speed in use between the 
//      system and the reader.
//   - SCARD_ATTR_SPEC_CMD_TIMEOUT is the Tag for the value of the Cmd Timeout.
//   - SCARD_ATTR_SPEC_POWER_TIMEOUT is the Tag for the value of the Power 
//      Timeout.
//   - SCARD_ATTR_SPEC_APDU_TIMEOUT is the Tag to access at the value of the APDU 
//      Timeout.
//
#define SCARD_ATTR_SPEC_BAUD_RATE SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0180)
#define SCARD_ATTR_SPEC_CMD_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0181)
#define SCARD_ATTR_SPEC_POWER_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0182)
#define SCARD_ATTR_SPEC_APDU_TIMEOUT SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0183)
#define SCARD_ATTR_MANUFACTURER_NAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0190)
#define SCARD_ATTR_ORIGINAL_FILENAME  SCARD_ATTR_VALUE(SCARD_CLASS_VENDOR_DEFINED,0x0191)


//
//   - IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE defines a specific IOCTL for the Gemplus 
//      Reader to exchange data with the reader without control of the driver.
//   - IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to gets vendor attributes.
//   - IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE defines a specific IOCTL for the Gemplus 
//      Reader to sets vendor attributes.
//
#define IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE  CTL_CODE(FILE_DEVICE_SMARTCARD,2048,0,0)
#define IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2049,0,0)
#define IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE CTL_CODE(FILE_DEVICE_SMARTCARD,2050,0,0)
// 2051 is reserved for Gcr420 keyboard reader.
#define IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED  CTL_CODE(FILE_DEVICE_SMARTCARD,2052,0,0)


#define LOWORD(l)   ((USHORT)(l))
#define HIWORD(l)   ((USHORT)(((UINT)(l)) >> 16))
#define LOBYTE(w)   ((UCHAR)(w))
#define HIBYTE(w)   ((UCHAR)(((USHORT)(w)) >> 8))


USHORT	ATRLen 
(
    UCHAR *ATR,
    USHORT MaxChar
);

BOOLEAN NeedToSwitchWithoutPTS
( 
    BYTE *ATR,
    DWORD LengthATR
);

NTSTATUS ValidateDriver
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);

NTSTATUS Update
(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr, 
    UCHAR Value
);


NTSTATUS UpdateORL
(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr, 
    UCHAR Value
);

NTSTATUS T0toT1
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);

NTSTATUS T1toT0
(
    PSMARTCARD_EXTENSION pSmartcardExtension
);


//
//   Icc Functions
//
//  - IccColdReset
//  - IccWarmReset
//  - IccPowerDown
//  - IccIsoOutput
//  - IccIsoInput
//  - IccIsoT1
//

NTSTATUS IccColdReset
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IccPowerDown
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS IccIsoOutput
(
   PSMARTCARD_EXTENSION SmartcardExtension,
   const UCHAR			Command[5],
         USHORT			*RespLen,
         UCHAR			RespBuff[]
);
NTSTATUS IccIsoInput
(
   PSMARTCARD_EXTENSION	SmartcardExtension,
   const UCHAR			Command[5],
   const UCHAR			Data[],
         USHORT			*RespLen,
         UCHAR			RespBuff[]
);
NTSTATUS IccIsoT1
(
   PSMARTCARD_EXTENSION SmartcardExtension,
   const USHORT			CmdLen, 
   const UCHAR			Cmd[],
         USHORT			*RspLen,
         UCHAR			Rsp[] 
);


//
//   Ifd Functions
//
//  - IfdReset
//  - IfdCheck
//  - IfdPowerDown
//
NTSTATUS IfdReset
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdCheck
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdPowerDown
(
   PSMARTCARD_EXTENSION SmartcardExtension
);

NTSTATUS IfdConfig
(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   UCHAR  TA1
);

//
//   Driver callback Functions
//
//  - GprCbReaderPower
//  - GprCbTransmit
//  - GprCbSetProtocol
//  - GprCbSetupCardTracking
//  - GprCbVendorIoctl
//
NTSTATUS GprCbReaderPower
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbTransmit
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbSetProtocol
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbSetupCardTracking
(
   PSMARTCARD_EXTENSION SmartcardExtension
);
NTSTATUS GprCbVendorIoctl
(
   PSMARTCARD_EXTENSION SmartcardExtension
);


//   Icc detection utilities
//
//   - AskForCardPresence
//
NTSTATUS AskForCardPresence
(
  PSMARTCARD_EXTENSION SmartcardExtension
);

//
//   Specific
//
//   - SpecificTag
//   - SwitchSpeed
//

NTSTATUS SpecificTag
(
	PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD                IoControlCode,
    DWORD                BufferInLen,
    BYTE                *BufferIn,
    DWORD                BufferOutLen,
    BYTE                *BufferOut,
    DWORD               *LengthOut
);


NTSTATUS SwitchSpeed
(
	PSMARTCARD_EXTENSION   SmartcardExtension,
	ULONG                  BufferInLen,
	PUCHAR                 BufferIn,
	ULONG                  BufferOutLen,
	PUCHAR                 BufferOut,
	PULONG                 LengthOut
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gempc430\wdmsys.cpp ===
#include "wdmsys.h"

#pragma PAGEDCODE
CSystem* CWDMSystem::create(VOID)
{ return new (NonPagedPool) CWDMSystem; }

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::createDevice(PDRIVER_OBJECT DriverObject,
							ULONG DeviceExtensionSize,
							PUNICODE_STRING DeviceName OPTIONAL,
							DEVICE_TYPE DeviceType,
							ULONG DeviceCharacteristics,
							BOOLEAN Reserved,
							PDEVICE_OBJECT *DeviceObject)
{
	return	::IoCreateDevice(DriverObject,DeviceExtensionSize,DeviceName,
		DeviceType,DeviceCharacteristics,Reserved,DeviceObject);
}

#pragma PAGEDCODE
VOID	CWDMSystem::deleteDevice(PDEVICE_OBJECT DeviceObject)
{
	::IoDeleteDevice(DeviceObject);
}

#pragma PAGEDCODE
PDEVICE_OBJECT	CWDMSystem::attachDevice(PDEVICE_OBJECT SourceDevice,PDEVICE_OBJECT TargetDevice)
{
	return ::IoAttachDeviceToDeviceStack(SourceDevice,TargetDevice);
}

#pragma PAGEDCODE
VOID	CWDMSystem::detachDevice(PDEVICE_OBJECT TargetDevice)
{
	::IoDetachDevice(TargetDevice);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::callDriver(PDEVICE_OBJECT DeviceObject,PIRP Irp)
{
	return IoCallDriver(DeviceObject,Irp);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::registerDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
							CONST GUID *InterfaceClassGuid,
							PUNICODE_STRING ReferenceString,
							PUNICODE_STRING SymbolicLinkName)
{
	return ::IoRegisterDeviceInterface(PhysicalDeviceObject,
							InterfaceClassGuid,
							ReferenceString,SymbolicLinkName);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::setDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName,
							BOOLEAN Enable	)
{
	return ::IoSetDeviceInterfaceState(SymbolicLinkName,Enable);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::createSystemThread(
					OUT PHANDLE ThreadHandle,
					IN ULONG DesiredAccess,
					IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
					IN HANDLE ProcessHandle OPTIONAL,
					OUT PCLIENT_ID ClientId OPTIONAL,
					IN PKSTART_ROUTINE StartRoutine,
					IN PVOID StartContext)
{
	return PsCreateSystemThread(ThreadHandle,DesiredAccess,ObjectAttributes,
					ProcessHandle,ClientId,	StartRoutine,StartContext);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::terminateSystemThread(IN NTSTATUS ExitStatus)
{
	return PsTerminateSystemThread(ExitStatus);
}

#pragma PAGEDCODE
NTSTATUS CWDMSystem::referenceObjectByHandle(                                      
					IN HANDLE Handle,                                           
					IN ACCESS_MASK DesiredAccess,                               
					IN POBJECT_TYPE ObjectType OPTIONAL,                        
					IN KPROCESSOR_MODE AccessMode,                              
					OUT PVOID *Object,                                          
					OUT POBJECT_HANDLE_INFORMATION HandleInformation OPTIONAL   
					)
{
	return	ObReferenceObjectByHandle(Handle,DesiredAccess,ObjectType,AccessMode,Object,HandleInformation);
}


#pragma PAGEDCODE
VOID CWDMSystem::referenceObject(IN PVOID Object)                                      
{
	ObReferenceObject(Object);
}

#pragma PAGEDCODE
VOID	CWDMSystem::dereferenceObject(IN PVOID Object)
{
	ObfDereferenceObject(Object);
}

#pragma PAGEDCODE
PDEVICE_OBJECT	CWDMSystem::getAttachedDeviceReference(IN PDEVICE_OBJECT DeviceObject)
{
	return ::IoGetAttachedDeviceReference(DeviceObject);
}

NTKERNELAPI                                 
PDEVICE_OBJECT                              
IoGetAttachedDeviceReference(               
    IN PDEVICE_OBJECT DeviceObject          
    );  


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::ZwClose(IN HANDLE Handle)
{
	return ::ZwClose(Handle);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::createSymbolicLink(IN PUNICODE_STRING SymbolicLinkName,IN PUNICODE_STRING DeviceName)
{
	return ::IoCreateSymbolicLink(SymbolicLinkName,DeviceName);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::deleteSymbolicLink(IN PUNICODE_STRING SymbolicLinkName)
{
	return ::IoDeleteSymbolicLink(SymbolicLinkName);
}

#pragma PAGEDCODE
VOID	CWDMSystem::invalidateDeviceRelations(IN PDEVICE_OBJECT DeviceObject,IN DEVICE_RELATION_TYPE Type)
{
	IoInvalidateDeviceRelations(DeviceObject,Type);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::getDeviceObjectPointer(IN PUNICODE_STRING ObjectName,
							IN ACCESS_MASK DesiredAccess,
							OUT PFILE_OBJECT *FileObject,
							OUT PDEVICE_OBJECT *DeviceObject)
{

	return IoGetDeviceObjectPointer(ObjectName,DesiredAccess,FileObject,DeviceObject);
}


#pragma PAGEDCODE
VOID	CWDMSystem::raiseIrql(IN KIRQL NewIrql,OUT KIRQL* oldIrql)
{
	KeRaiseIrql(NewIrql,oldIrql);
};

#pragma PAGEDCODE
VOID	CWDMSystem::lowerIrql (IN KIRQL NewIrql)
{
	KeLowerIrql(NewIrql);
};

#pragma PAGEDCODE
KIRQL	CWDMSystem::getCurrentIrql ()
{
	return	KeGetCurrentIrql();
};

#pragma PAGEDCODE
VOID	CWDMSystem::initializeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue)
{
	KeInitializeDeviceQueue (DeviceQueue);
};

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::insertDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry)
{
	return KeInsertDeviceQueue (DeviceQueue,DeviceQueueEntry);
}

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::insertByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,IN ULONG SortKey)
{
	return KeInsertByKeyDeviceQueue(DeviceQueue,DeviceQueueEntry,SortKey);
}

#pragma PAGEDCODE
PKDEVICE_QUEUE_ENTRY	CWDMSystem::removeDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue)
{
	return KeRemoveDeviceQueue (DeviceQueue);
}

#pragma PAGEDCODE
PKDEVICE_QUEUE_ENTRY	CWDMSystem::removeByKeyDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN ULONG SortKey)
{
	return KeRemoveByKeyDeviceQueue (DeviceQueue,SortKey);
}

#pragma PAGEDCODE
BOOLEAN	CWDMSystem::removeEntryDeviceQueue(IN PKDEVICE_QUEUE DeviceQueue,IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry)
{
	return KeRemoveEntryDeviceQueue(DeviceQueue,DeviceQueueEntry);
}


#pragma PAGEDCODE
NTSTATUS	CWDMSystem::openDeviceRegistryKey(IN PDEVICE_OBJECT DeviceObject,
							IN ULONG DevInstKeyType,
							IN ACCESS_MASK DesiredAccess,
							OUT PHANDLE DevInstRegKey)
{

	return IoOpenDeviceRegistryKey(DeviceObject,DevInstKeyType,DesiredAccess,DevInstRegKey);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::ZwQueryValueKey(IN HANDLE KeyHandle,
							IN PUNICODE_STRING ValueName,
							IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
							OUT PVOID KeyValueInformation,
							IN ULONG Length,
							OUT PULONG ResultLength)
{
	return ZwQueryValueKey(KeyHandle,ValueName,KeyValueInformationClass,KeyValueInformation,
						Length,ResultLength);
}

#pragma PAGEDCODE
NTSTATUS	CWDMSystem::getDeviceProperty(
							IN PDEVICE_OBJECT DeviceObject,
							IN DEVICE_REGISTRY_PROPERTY Property,
							IN ULONG BufferLength,
							OUT PVOID PropertyBuffer,
							OUT PULONG ResultLength	)
{

	return IoGetDeviceProperty(DeviceObject,Property,BufferLength,PropertyBuffer,ResultLength);
/*

// Define PnP Device Property for IoGetDeviceProperty
#define DEVICE_PROPERTY_TABSIZE		DevicePropertyEnumeratorName+1

WCHAR* DeviceProperty[DEVICE_PROPERTY_TABSIZE];

DeviceProperty[DevicePropertyDeviceDescription] = L"DeviceDesc";
DeviceProperty[DevicePropertyHardwareID] = L"HardwareID";
DeviceProperty[DevicePropertyCompatibleIDs] = L"CompatibleIDs";
DeviceProperty[DevicePropertyBootConfiguration] = L"BootConfiguration";
DeviceProperty[DevicePropertyBootConfigurationTranslated] = L"BootConfigurationTranslated";
DeviceProperty[DevicePropertyClassName] = L"ClassName";
DeviceProperty[DevicePropertyClassGuid] = L"ClassGuid";
DeviceProperty[DevicePropertyDriverKeyName] = L"DriverKeyName";
DeviceProperty[DevicePropertyManufacturer] = L"Manufacturer";
DeviceProperty[DevicePropertyFriendlyName] = L"FriendlyName";
DeviceProperty[DevicePropertyLocationInformation] = L"LocationInformation";
DeviceProperty[DevicePropertyPhysicalDeviceObjectName] = L"PhysicalDeviceObjectName";
DeviceProperty[DevicePropertyBusTypeGuid] = L"BusTypeGuid";
DeviceProperty[DevicePropertyLegacyBusType] = L"LegacyBusType";
DeviceProperty[DevicePropertyBusNumber] = L"BusNumber";
DeviceProperty[DevicePropertyEnumeratorName] = L"EnumeratorName";

	if (isWin98())
	{						// use registry
		HANDLE hkey;
		status = IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DEVICE, KEY_READ, &hkey);

		if (NT_SUCCESS(status))
		{					// get & report description
			UNICODE_STRING valname;
			RtlInitUnicodeString(&valname, L"DeviceDesc");

			kernel->RegistryPath = new (NonPagedPool)CUString(RegistryPath);
    
			ULONG size = 0;
			status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, NULL, 0, &size);
			if (status != STATUS_OBJECT_NAME_NOT_FOUND && size)
				{					// value exists
				PKEY_VALUE_PARTIAL_INFORMATION vpip = (PKEY_VALUE_PARTIAL_INFORMATION) ExAllocatePool(PagedPool, size);
				status = ZwQueryValueKey(hkey, &valname, KeyValuePartialInformation, vpip, size, &size);
				if (NT_SUCCESS(status))
					KdPrint((DRIVERNAME " - AddDevice has succeeded for '%ws' device\n", vpip->Data));
				ExFreePool(vpip);
				}				// value exists
			ZwClose(hkey);
		}					// get & report description
	}						// use registry
	else
	{						// get property
		status = IoGetDeviceProperty(DeviceObject,DeviceProperty,BufferLength,PropertyBuffer,ResultLength);
	}						// get property
*/
}

#pragma PAGEDCODE
VOID		CWDMSystem::initializeFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExInitializeFastMutex (FastMutex);
}

#pragma PAGEDCODE
VOID		CWDMSystem::acquireFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExAcquireFastMutex (FastMutex);
}

#pragma PAGEDCODE
VOID		CWDMSystem::releaseFastMutex(IN PFAST_MUTEX FastMutex)
{
	ExReleaseFastMutex(FastMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprelcmd.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	gprelcmd.c

Description: 
	  This module holds the functions used for the PC Card I/O. 
Environment:
	Kernel Mode

Revision History: 
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
	24/03/99: V1.00.004  (Y. Nadeau)
		- Fix to GprllWait to work in DPC
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/


//
//	Include section:
//	   - stdio.h: standards definitons.
//	   - ntddk.h: DDK Windows NT general definitons.
//	   - ntdef.h: Windows NT general definitons.
//
#include <stdio.h>
#include <ntddk.h>
#include <ntdef.h>

#include "gprelcmd.h"

//
// Function definition section:
//
     
#if DBG
void GPR_Debug_Buffer(
   PUCHAR pBuffer,
   DWORD Lenght)
{
   USHORT index;

   SmartcardDebug(
      DEBUG_TRACE,
      (" LEN=%d CMD=",
      Lenght)
      );
   for(index=0;index<Lenght;index++)
   {
      SmartcardDebug(
         DEBUG_TRACE,
         ("%02X,",
         pBuffer[index])
         );
   }
   SmartcardDebug(
      DEBUG_TRACE,
      ("\n")
      );
}
#endif



NTSTATUS GDDK_Translate(
    const BYTE  IFDStatus,
    const UCHAR Tag
    )
/*++

Routine Description:

 Translate IFD status in NT status codes.

Arguments:

   IFDStatus   - is the value to translate.
   IoctlType  - is the current smart card ioctl.
               
Return Value:

    the translated code status.

--*/
{
    switch (IFDStatus)
    {
        case 0x00 : return STATUS_SUCCESS;
        case 0x01 : return STATUS_NO_SUCH_DEVICE;
        case 0x02 : return STATUS_NO_SUCH_DEVICE;
        case 0x03 : return STATUS_INVALID_PARAMETER; 
        case 0x04 : return STATUS_IO_TIMEOUT;
        case 0x05 : return STATUS_INVALID_PARAMETER;
        case 0x09 : return STATUS_INVALID_PARAMETER;
        case 0x0C : return STATUS_DEVICE_PROTOCOL_ERROR;
        case 0x0D : return STATUS_SUCCESS;
        case 0x10 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x11 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x12 : return STATUS_INVALID_PARAMETER;
        case 0x13 : return STATUS_CONNECTION_ABORTED;
        case 0x14 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x15 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x16 : return STATUS_INVALID_PARAMETER;
        case 0x17 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x18 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x19 : return STATUS_INVALID_PARAMETER;
        case 0x1A : return STATUS_INVALID_PARAMETER;
        case 0x1B : return STATUS_INVALID_PARAMETER;
        case 0x1C : return STATUS_INVALID_PARAMETER;
        case 0x1D : return STATUS_UNRECOGNIZED_MEDIA;
        case 0x1E : return STATUS_INVALID_PARAMETER;
        case 0x1F : return STATUS_INVALID_PARAMETER;
        case 0x20 : return STATUS_INVALID_PARAMETER;
        case 0x30 : return STATUS_IO_TIMEOUT;
        case 0xA0 : return STATUS_SUCCESS;
        case 0xA1 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xA2 : 
            if      (Tag == OPEN_SESSION_CMD)
                    { return STATUS_UNRECOGNIZED_MEDIA;}
            else 
                    { return STATUS_IO_TIMEOUT;        }
        case 0xA3 : return STATUS_PARITY_ERROR;
        case 0xA4 : return STATUS_REQUEST_ABORTED;
        case 0xA5 : return STATUS_REQUEST_ABORTED;
        case 0xA6 : return STATUS_REQUEST_ABORTED;
        case 0xA7 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xCF : return STATUS_INVALID_PARAMETER;
        case 0xE4 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xE5 : return STATUS_SUCCESS;
        case 0xE7 : return STATUS_SUCCESS;
        case 0xF7 : return STATUS_NO_MEDIA;
        case 0xF8 : return STATUS_UNRECOGNIZED_MEDIA;
        case 0xFB : return STATUS_NO_MEDIA;

        default   : return STATUS_INVALID_PARAMETER;
    }
}



/*++

  Routine Description : 
	Read a byte at IO address

--*/
BOOLEAN  G_ReadByte(const USHORT BIOAddr,UCHAR *Value)
{
	*Value = READ_PORT_UCHAR((PUCHAR) BIOAddr);
	return(TRUE);
}



/*++

  Routine Description : 
	Write a byte at IO address

--*/
BOOLEAN  G_WriteByte(const USHORT BIOAddr,UCHAR *Value)
{
	WRITE_PORT_UCHAR((PUCHAR) BIOAddr,*Value);
	return(TRUE);
}


/*++

  Routine Description : 
	Read a buffer of "Len" bytes at IO address
--*/
BOOLEAN  G_ReadBuf(const USHORT BIOAddr,const USHORT Len,UCHAR *Buffer)
{                                                                      
    USHORT i;

	for(i=0;i<Len;i++)
    {
		*(Buffer+i) = READ_PORT_UCHAR((UCHAR *) UlongToPtr(BIOAddr+i));
	}						   
#if DBG
   // Excluse reader status reply
   if(! ((Buffer[0] == 0xA2) && (Buffer[1]==4)) )
   {
	   SmartcardDebug(
         DEBUG_TRACE,
         ("%s!G_ReadBuf:",
         SC_DRIVER_NAME)
         );
	   GPR_Debug_Buffer(Buffer, Len );
   }
#endif		
	return(TRUE);
}


/*++

  Routine Description : 
	Write a buffer of "Len" bytes at IO address
--*/
BOOLEAN  G_WriteBuf(const USHORT BIOAddr,const USHORT Len,UCHAR *Buffer)
{

    USHORT i;

	for(i=0;i<Len;i++)
    {
		WRITE_PORT_UCHAR((UCHAR *) UlongToPtr(BIOAddr + i),*(Buffer+i));
	}	
#if DBG
   // Excluse reader status cmd
   if(! ((Buffer[0] == 0xA0) && (Buffer[2] == 0x02)) )
   {
	   SmartcardDebug(
         DEBUG_TRACE,
         ("%s!G_WriteBuf:",
         SC_DRIVER_NAME)
         );
	   GPR_Debug_Buffer(Buffer,Len);
   }
#endif
   
	return(TRUE);

}



/*++

  Routine Description : 
	Mask a register located at a specified address with a specified 
	byte
--*/
BOOLEAN  G_MaskRegister(
    const USHORT BIOAddr,
    const UCHAR Mask,
    const UCHAR BitState)
{
	if(BitState == 0)
    {
		WRITE_PORT_UCHAR((PUCHAR)BIOAddr,(UCHAR) (READ_PORT_UCHAR((PUCHAR)BIOAddr) & ~Mask));   
	}
	else
    {	
		WRITE_PORT_UCHAR((PUCHAR)BIOAddr,(UCHAR) (READ_PORT_UCHAR((PUCHAR)BIOAddr) | Mask));   
	}

	return(TRUE);
}


/*++

  Routine Description : 
	Read a byte to an input address port
--*/
UCHAR  GprllReadRegister(
	const PREADER_EXTENSION      pReaderExt,
	const SHORT					GPRRegister
	)
{   
    //
    // Locals variables:
    //   value holds the result of the read operation.
    //
    UCHAR value;

    value = 0x0;
	G_ReadByte((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) GPRRegister),
		&value 
		);

	return(value);
}



/*++

  Routine Description : 
	Call the G_MaskRegister function in the lower level 
--*/
void  GprllMaskHandshakeRegister(
	const PREADER_EXTENSION      pReaderExt,
	const UCHAR                 Mask,
	const UCHAR                 BitState
	)
{
	G_MaskRegister((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) 
			+ (const USHORT) REGISTER_HANDSHAKE),
		(const UCHAR) Mask,
		(const UCHAR) BitState);
	// YN	
    // get hardware time to update register
    GprllWait(1);
}



NTSTATUS GprllKeWaitAckEvent(
    const	PREADER_EXTENSION	pReaderExt,
    const	UCHAR				Tx
    )
/*++
    Routine Description:
    This function Wait the acknowledge of the GPR after
    a send command to IOPort.  We made a smart verification
    of the timer depending of the Tag command. 
  
    Arguments In:
        pReaderExt holds the pointer to the READER_EXTENSION structure.
        Tx holds the command type
    Return Value:
    NTStatus
--*/
{
    UCHAR T; // Tag return
    LARGE_INTEGER lTimeout;
    NTSTATUS      NTStatus = STATUS_SUCCESS;
    ULONG       NbLoop = 0;
    ULONG       NbSecondTotal;
    ULONG       ElapsedSecond = 0;
    ULONG       TimeInLoop =1;
    BOOLEAN     Continue = TRUE;
    ULONG       i = 0;

	ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    // Make a smart timer depending on type of command
    if( (Tx & 0xf0) == APDU_EXCHANGE_CMD)
    {
        NbSecondTotal = pReaderExt->CmdTimeOut;
    }
    else 
    {
        NbSecondTotal = GPR_CMD_TIME;
    }

    NbLoop = (NbSecondTotal / TimeInLoop);

    while( (Continue) && (ElapsedSecond < NbSecondTotal) )
    {
        ElapsedSecond += TimeInLoop;

        lTimeout.QuadPart = -((LONGLONG)TimeInLoop * 10000000);

        //Wait the acknowledge of the GPR
        NTStatus = KeWaitForSingleObject(
            &(pReaderExt->GPRAckEvent),
            Executive,
            KernelMode,
            TRUE,
            &lTimeout
            );

        if(NTStatus == STATUS_TIMEOUT)
        {
            // Verify if the reader was been
            // remove during exchange

            lTimeout.QuadPart = 0;

            NTStatus = KeWaitForSingleObject(         
                &(pReaderExt->ReaderRemoved),
                Executive,
                KernelMode,
                FALSE,
                &lTimeout
                );
			SmartcardDebug( 
				DEBUG_PROTOCOL, 
				( "%s!GprllKeWaitAckEvent: TIMEOUT KeWaitForSingleObject=%X(hex)\n",
				SC_DRIVER_NAME,
				NTStatus)
				);

            if (NTStatus == STATUS_SUCCESS)
            {
                NTStatus = STATUS_DEVICE_REMOVED;
                Continue = FALSE;
            }
            // Read the T register
            // <== Test if GPR hasn't been removed STATUS_DEVICE_NOT_CONNECTED


            // Reading T out
            T = GprllReadRegister(pReaderExt,REGISTER_T);
            if ( T == 0xFF )
            {
                NTStatus = STATUS_DEVICE_REMOVED;
                Continue = FALSE;
            }
            // Else is a Timeout
        }
        else
        {
            Continue = FALSE;
            NTStatus = STATUS_SUCCESS;
        }
    }
    return NTStatus;
}



NTSTATUS GprllTLVExchange(
    const	PREADER_EXTENSION	pReaderExt,
    const	UCHAR				Ti, 
    const	USHORT				Li, 
    const	UCHAR				*Vi,
            UCHAR				*To, 
            USHORT				*Lo, 
            UCHAR				*Vo
    )
/*++

    Routine Description : 
        Exchange data with GPR with a TLV command.

    Arguments 
    In:
        pReaderExt holds the pointer to the READER_EXTENSION structure.
        Ti holds the command type
        Li holds the command length
        Vi holds the command data

    Out:      
        To holds the command response type
        Lo holds the command response length
        Vo holds the command response data

    Return Value
    NTStatus

        STATUS_SUCCESS is Ok 
        else if an error condition is raised:
        STATUS_DEVICE_PROTOCOL_ERROR
        STATUS_INVALID_DEVICE_STATE
        STATUS_DEVICE_NOT_CONNECTED
        STATUS_UNRECOGNIZED_MEDIA

        and others received IFDstatus corresponding to NTSTATUS

--*/
{
    // Local variables
    // - T  is type of TLV protocol                    
    // - new_Ti is the Ti modified
    // - L  is length in TLV protocol   
    // - V  is data filed in TLV protocol

    NTSTATUS NTStatus = STATUS_SUCCESS;
    UCHAR T;
    UCHAR new_Ti;
    USHORT L;
    UCHAR V[GPR_BUFFER_SIZE];

    //Verification of Li
    if ( (USHORT) Li >= GPR_BUFFER_SIZE )
    {
        return (STATUS_DEVICE_PROTOCOL_ERROR);
    }

	new_Ti = Ti;

    //
    // Write the TLV 
    // by Write TLV if Li <= 28 or By ChainIn if Li > 28
    //
    if (Li<=MAX_V_LEN)
    {
        GprllSendCmd(pReaderExt,new_Ti,Li,Vi);                 
        
        NTStatus = GprllKeWaitAckEvent(
            pReaderExt,
            Ti
            );

        if (STATUS_SUCCESS != NTStatus)
        {
			// YN
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
			
            return NTStatus;
        }

		// GPR Command to read I/O Window: 
		// In the handshake register, set to 0 bit 2(IREQ) , and set to 1 bit 1 (INTR)

    }
    else
    {
        NTStatus = GprllSendChainUp( 
            pReaderExt,
            new_Ti,
            Li,
            Vi
            );

        if (STATUS_SUCCESS != NTStatus)
        {
			// YN
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

           return(NTStatus);
        } 
    }

    // Read the T register, need to know if new data to exchange
    T = pReaderExt->To;

    // Read Answer by Read TLV  or Chain Out method if To = Ti + 6
    if ( T == (new_Ti + 6) )
    {
        NTStatus = GprllReadChainUp(pReaderExt,&T,&L,V);
        
        if (STATUS_SUCCESS != NTStatus )
        {
			// YN
            GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

            return(NTStatus);
        }
    }
    else
    {
        L = pReaderExt->Lo;
        ASSERT(pReaderExt->Vo !=0);
        memcpy(V,pReaderExt->Vo,L);
        GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
    }  
   
    // Verify if Response buffer len is large enough
    // to contain data received from the reader
    //

    if( L > *Lo )
    {
        *To=T;
        *Lo=1;
        Vo[0]=14;
        return(STATUS_UNRECOGNIZED_MEDIA);
    }

    // Translate answer
    *To=T;
    *Lo=L;
    memcpy(Vo,V,(SHORT)L);

    return (GDDK_Translate(Vo[0], Ti));
}





void  GprllSendCmd(  
	const PREADER_EXTENSION	pReaderExt,
	const UCHAR				Ti, 
	const USHORT			Li,
	const UCHAR				*Vi
	)
/*++

  Routine Description : 
	Write TLV into I/O Window and
	Send Command to GPR to read I/O Window

  Arguments:
     pReaderExt holds the pointer to the READER_EXTENSION structure.
     Ti holds the command type
     Li holds the command length
     Vi holds the command data
--*/
{
    // Local variables
    //   - TLV is an intermediate buffer.
    UCHAR TLV[2 + MAX_V_LEN];
    USHORT Li_max;
	
	//Write Ti, Li and Vi[]
	TLV[0] = Ti;
	TLV[1] = (UCHAR) Li;
	ASSERT(Vi != 0);

    Li_max = Li;

    if (Li_max > MAX_V_LEN)
    {
        Li_max = MAX_V_LEN;
    }
	memcpy(TLV+2,Vi,Li_max);
	G_WriteBuf((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) REGISTER_T),
		(const USHORT) (Li_max + 2),
		(UCHAR *) TLV
		);

	// GPR Command to read I/O Window: 
	// In the handshake register, set to 0 bit 2(IREQ) , and set to 1 bit 1 (INTR)
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_INTR,1);
}



void  GprllReadResp(
	const	PREADER_EXTENSION	pReaderExt
	)
/*++

  Routine Description : 
	Read no chainning TLV into I/O Window and
	Send Command to GPR to read I/O Window

  Arguments
  In:           
     pReaderExt holds the pointer to the READER_EXTENSION structure.

  Out:     
     To holds the command response type
     Lo holds the command response length
     Vo holds the command response data
--*/
{
    //Local variables
    //   - TLV is an intermediate buffer.

    UCHAR TLV[2 + MAX_V_LEN];

    TLV[0] = 0x0;
    // Read To, Lo and Vo[]
	G_ReadBuf((const USHORT)
		(((const USHORT) (pReaderExt->BaseIoAddress)) + (const USHORT) REGISTER_T),
		MAX_V_LEN + 2,
		TLV);
	
	pReaderExt->To = TLV[0];
    // maximum number of character is set by the TLV buffer
	pReaderExt->Lo = TLV[1];

    if (pReaderExt->Lo > MAX_V_LEN)
    {
        pReaderExt->Lo = MAX_V_LEN;
    }


	memcpy(pReaderExt->Vo,TLV+2,pReaderExt->Lo);

    // Acquit the Hand shake: 
    // In the handshake register, set to 0 bit 2 (BUSY/IREQ)
	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
}


NTSTATUS GprllSendChainUp(
	const PREADER_EXTENSION	pReaderExt,
	const UCHAR				Ti,
	const USHORT			Li,
	const UCHAR				*Vi
	)
/*++

  Routine Description : Send chainning TLV to GPR

  Arguments:
  In:
     pReaderExt holds the pointer to the READER_EXTENSION structure.
     Ti holds the command type
     Li holds the command length
     Vi holds the command data

 Out:    Nothing
--*/
{
    //	Local variables
    //	   - Tc is type of TLV protocol ( TLV chaining method )   
    //	   - Lc is Length of TLV protocol ( chaining method )    
    //	   - Vc is 28 bytes max of data to send
    //	   - Length is an temporary var to store Li   
    UCHAR Tc;
    UCHAR Response;
    UCHAR Lo;
    USHORT Lc;
    USHORT Length;
    UCHAR  Vc[MAX_V_LEN];
    NTSTATUS NTStatus = STATUS_SUCCESS;

	Length=Li;

	//Prepare Tc (Add 4 to Ti for chaining method)
	Tc=Ti+4; 
    Vc[0] = 0x0;
	while ( Length > 0 )
    {
        //Prepare Lc
        //If length TLV > 28 Length = 28 else it's last command L = Length
		if ( Length > MAX_V_LEN )
        {
			Lc=MAX_V_LEN;     
		}
		else
        {
			Lc=Length; 
			Tc=Ti;
		}
		//Prepare Vc
		memcpy(Vc,Vi+Li-Length,Lc);

		//Write to I/O window
        // Dont need the answer - handled by the interrupt function.
		GprllSendCmd(pReaderExt,Tc,Lc,Vc);
      
        NTStatus = GprllKeWaitAckEvent(
            pReaderExt,
            Ti
            );
        if(STATUS_SUCCESS != NTStatus)
        {
            return NTStatus;
        }

		//If an error test Response
		Response = GprllReadRegister(pReaderExt,REGISTER_V);

        if(0x00 != Response)
        {
			Lo = GprllReadRegister(pReaderExt,REGISTER_L);
			if (Lo == 0x01)
            {
               return (GDDK_Translate(Response, Ti));
			}
			else
            {
                // This is not a exchange is a cmd to reader
                // we don't care about the reader status.
				return (NTStatus);
			}
		}
		Length=Length-Lc;
	}
   return(NTStatus);
}



NTSTATUS GprllReadChainUp(
	const	PREADER_EXTENSION	pReaderExt,
			UCHAR				*To, 
			USHORT				*Lo,
			UCHAR				*Vo
	)
/*++

  Routine Description : Receive chainning TLV response from GPR

  Arguments
  In:   
     pReaderExt holds the pointer to the READER_EXTENSION structure.

  Out:     
     To holds the command response type
     Lo holds the command response length
     Vo holds the command response data
--*/
{
//	Local variables
//	   - Tc is type of TLV protocol ( TLV chaining method )   
//	   - Lc is Length of TLV protocol ( chaining method )    
//	   - Length is an temporary var to store Lo
    UCHAR Tc;
    USHORT Lc;
    SHORT Lenght;
    NTSTATUS NTStatus = STATUS_SUCCESS;
	
	// Reading T out
	Tc = GprllReadRegister(pReaderExt,REGISTER_T);
	*To=Tc-4; 

	Lenght = 0;
	do
    {
		// Read TLV
		Tc = pReaderExt->To;
		Lc = pReaderExt->Lo;
		ASSERT(pReaderExt->Vo != 0);

        // The Vo buffer is limited by the caller local variable.
        if ( Lenght + (SHORT) pReaderExt->Lo > GPR_BUFFER_SIZE)
        {
            return (STATUS_BUFFER_TOO_SMALL);
        }

        memcpy(Vo+Lenght,pReaderExt->Vo,pReaderExt->Lo);

        GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);

        // Prepare Lo
        *Lo=(USHORT)Lenght+Lc;
        Lenght=Lenght+Lc;
		
		// GPR send the next Chainning TLV
		// In the handshake register, set to 0 bit 2(IREQ) and set to 1 bit 1 (INTR)
		if ((*To) != Tc )
        {
        	GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_IREQ,0);
			GprllMaskHandshakeRegister(pReaderExt,HANDSHAKE_INTR,1);

            NTStatus = GprllKeWaitAckEvent(
                pReaderExt,
                *To
                );

            if(STATUS_SUCCESS != NTStatus)
            {
                return NTStatus;
            }
		}

		// (End do) if To=Tc -> Last Chainning TLV
	} while( (*To) != Tc ); 

	return(NTStatus);
}


void GprllWait(
    const LONG lWaitingTime
	)
/*++

  Routine Description : This function puts the driver in a waiting state
  for a timeout.  If IRQL < DISPATCH_LEVEL, use normal fonction to process
  this delay.  use KeStallExecutionProcessor, just when GprllWait is called
  in the context of DPC routine.

  Arguments
	pReaderExt: Pointer to the current ReaderExtension structure.
	lWaitingTime: Timeout value in ms
--*/
{
    LARGE_INTEGER Delay;

	if( KeGetCurrentIrql() >= DISPATCH_LEVEL )
	{
		ULONG	Cnt = 20 * lWaitingTime;

		while( Cnt-- )
		{
			//	KeStallExecutionProcessor: counted in us
			KeStallExecutionProcessor( 50 );
		}
	}
	else
	{
		Delay.QuadPart = (LONGLONG)-10 * 1000 * lWaitingTime;

		//	KeDelayExecutionThread: counted in 100 ns
		KeDelayExecutionThread( KernelMode, FALSE, &Delay );
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprcmd.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
	gprcmd.c

Description:
	This is the module which holds the calls to the readers
    functions.

Environment:
	Kernel Mode

Revision History:
    06/04/99:            (Y. Nadeau + M. Veillette)
      - Code Review
    12/03/99: V1.00.005  (Y. Nadeau)
      - Fix Set protocol to give reader the time to process the change
    18/09/98: V1.00.004  (Y. Nadeau)
      - Correction for NT5 beta 3
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/
//
// Include section:
//   - stdio.h: standards definitons.
//   - ntddk.h: DDK Windows NT general definitons.
//   - ntdef.h: Windows NT general definitons.
//
#include <stdio.h>
#include <ntddk.h>
#include <ntdef.h>

//
//   - gprcmd.h: common definition for this module.
//   - gprnt.h: public interface definition for the NT module.
//   - gprelcmd.h :  elementary commands profile
//   - gemerror.h : Gemplus error codes

#include "gprnt.h"
#include "gprcmd.h"
#include "gprelcmd.h"

#pragma alloc_text(PAGEABLE, GprCbSetProtocol)
#pragma alloc_text(PAGEABLE, GprCbTransmit)
#pragma alloc_text(PAGEABLE, GprCbVendorIoctl)


//
//   Master driver code to load in RAM
//
UCHAR MASTER_DRIVER[133]={
	0xC2,0xB5,0x12,0x14,0xC6,0xFC,0x78,0x00,0x7B,0x00,0x90,0x07,0xDF,0xE0,0xD2,0xE4,
	0xF0,0xEB,0xF8,0x12,0x14,0xD0,0x12,0x0D,0x9B,0x40,0x5C,0x0B,0xDC,0xF3,0xD2,0xB4,
	0x90,0x07,0xDF,0xE0,0xC2,0xE4,0xF0,0x90,0x06,0xD4,0xE4,0xF5,0x15,0xF5,0x11,0xC2,
	0x4D,0xA3,0x05,0x11,0x75,0x34,0x0A,0x75,0x37,0x00,0x75,0x38,0x40,0x12,0x0B,0x75,
	0x20,0x20,0x3B,0xF0,0xA3,0x05,0x11,0x7B,0x01,0x12,0x0B,0x75,0x20,0x20,0x2F,0xF0,
	0xA3,0x05,0x11,0x7C,0x03,0x33,0x33,0x50,0x01,0x0B,0xDC,0xFA,0x12,0x0B,0x75,0x20,
	0x20,0x1C,0xF0,0xA3,0x05,0x11,0xDB,0xF4,0xE4,0x90,0x06,0xD4,0xF0,0x75,0x16,0x00,
	0x75,0x15,0x00,0x12,0x14,0x15,0x22,0x74,0x0C,0x75,0x11,0x01,0x80,0xEB,0x74,0x0D,
	0x75,0x11,0x01,0x80,0xE4
	};


// Hard coded structure for different values of TA1.
// eg. If TA= 0x92 is to set, this array of structure can be scanned and
// for member variable TA1 = 0x92 and that values can be written to 
// approptiate location.
// This is done in ConfigureTA1() function.
struct tagCfgTa1
{
	BYTE TA1;
	BYTE ETU1;
	BYTE ETU2;
	BYTE ETU1P;
} cfg_ta1[] = {	

//	{ 0x15, 0x01, 0x01, 0x01 },
//	{ 0x95, 0x01, 0x01, 0x01 },

//	{ 0x25, 0x03, 0x02, 0x01 },
	
//	{ 0x14, 0x05, 0x03, 0x01 },
//	{ 0x35, 0x05, 0x03, 0x01 },
	
//	{ 0xa5, 0x04, 0x02, 0x01 },
	
//	{ 0x94, 0x07, 0x04, 0x02 },
//	{ 0xb5, 0x07, 0x04, 0x02 },
	
//	{ 0x24, 0x09, 0x04, 0x04 },
//	{ 0x45, 0x09, 0x04, 0x04 },
	
	{ 0x13, 0x0d, 0x06, 0x09 },
	{ 0x34, 0x0d, 0x06, 0x09 },
	{ 0x55, 0x0d, 0x06, 0x09 },
	
	{ 0xa4, 0x0c, 0x06, 0x08 },
	{ 0xc5, 0x0c, 0x06, 0x08 },
	
	{ 0x65, 0x10, 0x08, 0x0c },

	{ 0x93, 0x11, 0x09, 0x0d },
	{ 0xb4, 0x11, 0x09, 0x0d },
	{ 0xd5, 0x11, 0x09, 0x0d },

	{ 0x23, 0x14, 0x0a, 0x10 },
	{ 0x44, 0x14, 0x0a, 0x10 },


	{ 0x12, 0x1c, 0x0e, 0x15 },
	{ 0x33, 0x1c, 0x0e, 0x15 },
	{ 0x54, 0x1c, 0x0e, 0x15 },

	{ 0xa3, 0x1c, 0x0f, 0x15 },
	{ 0xc4, 0x1c, 0x0f, 0x15 },

	{ 0x64, 0x24, 0x12, 0x20 },

	{ 0x92, 0x26, 0x14, 0x22 },
	{ 0xb3, 0x26, 0x14, 0x22 },
	{ 0xd4, 0x26, 0x14, 0x22 },


	{ 0x22, 0x2b, 0x16, 0x27 },
	{ 0x43, 0x2b, 0x16, 0x27 },


	{ 0x11, 0x3b, 0x1e, 0x37 },
	{ 0x32, 0x3b, 0x1e, 0x37 },
	{ 0x53, 0x3b, 0x1e, 0x37 },

//	{ 0x71, 0x55, 0x2b, 0x51 },
//	{ 0x91, 0x55, 0x2b, 0x51 },

	{ 0, 0, 0, 0 }

};



USHORT	ATRLen (UCHAR *ATR, USHORT MaxChar)
/*++

  Routine Description :
	Used to calculate the ATR length according to its content.
  Arguments
	ATR - string to analyze
    MaxChar - Maximum number of characters to verify.
--*/
{
    USHORT Len;
    UCHAR T0;
    UCHAR Yi;
    BOOLEAN	EndInterChar;
    BOOLEAN	TCKPresent=FALSE;

	T0 = ATR[1];
	Len= 2;  // TS + T0

	Yi= (T0 & 0xF0);

    EndInterChar = FALSE;
	do
    {
		if (Yi & 0x10)
        {
            Len++; //TAi
        }
		if (Yi & 0x20)
        {
            Len++; //TBi
        }
		if (Yi & 0x40)
        {
            Len++; //TCi
        }
		if (Yi & 0x80)
        {
			Yi = ATR[Len];
			if((Yi & 0x0F)!=0)
            {
				TCKPresent=TRUE;
			}

			Len++; //TDi
		}
		else
        {
		    EndInterChar = TRUE;
		}
    } while(EndInterChar == FALSE);

	Len = Len + (T0 & 0x0F);

	if(TCKPresent==TRUE)
    {
		Len = Len+1; //TCK
	}

	return (Len);
}



BOOLEAN NeedToSwitchWithoutPTS( 
    BYTE *ATR,
    DWORD LengthATR
    )
/*++

  Routine Description : 
	Examine if ATR identifies a specific mode (presence of TA2).
  Arguments
	ATR - string to analyze
    LengthATR - Length of ATR.
--*/

{
   DWORD pos, len;

   // ATR[1] is T0.  Examine precense of TD1.
   if (ATR[1] & 0x80)
   {
      // Find position of TD1.
      pos = 2;
      if (ATR[1] & 0x10)
         pos++;
      if (ATR[1] & 0x20)
         pos++;
      if (ATR[1] & 0x40)
         pos++;

      // Here ATR[pos] is TD1.  Examine presence of TA2.
      if (ATR[pos] & 0x10)
      {
         // To be of any interest an ATR must contains at least
         //   TS, T0, TA1, TD1, TA2 [+ T1 .. TK] [+ TCK]
         // Find the maximum length of uninteresting ATR.
         if (ATR[pos] & 0x0F)
            len = 5 + (ATR[1] & 0x0F);
         else
            len = 4 + (ATR[1] & 0x0F);  // In protocol T=0 there is no TCK.

         if (LengthATR > len)  // Interface bytes requires changes.
            if ((ATR[pos+1] & 0x10) == 0)  // TA2 asks to use interface bytes.
               return TRUE;
      }
   }

   return FALSE;
}



NTSTATUS ValidateDriver( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
	Validate the Master driver loaded in RAM at address 2100h
  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];


	Vi[0] = 0x83;  // DIR
	Vi[1] = 0x21;  // ADR MSB
	Vi[2] = 0x00;  // ADR LSB
    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

    // return a NTSTATUS
    lStatus = GprllTLVExchange (
		pReaderExt,
		VALIDATE_DRIVER_CMD,
		3,
		Vi,
		&To,
		&Lo,
		Vo
		);

    return (lStatus);

}



NTSTATUS Update(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr,
    UCHAR Value)
/*++

  Routine Description :
	Write a value in RAM
  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
	Addr: Address in RAM
	Value: Value to write
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

	Vi[0]= 0x01;
	Vi[1]= Addr;
	Vi[2]= Value;

    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		UPDATE_CMD,
		0x03,
		Vi,
		&To,
        &Lo,
		Vo
		);

    return (lStatus);

}

NTSTATUS UpdateORL(
    PSMARTCARD_EXTENSION pSmartcardExtension,
    UCHAR Addr,
    UCHAR Value)
/*++

  Routine Description :
	Write a value in RAM with OR mask
  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];


	Vi[0]= 0x02;
	Vi[1]= Addr;
    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		UPDATE_CMD,
		0x02,
		Vi,
		&To,
        &Lo,
		Vo
		);

    if (STATUS_SUCCESS != lStatus)
    {
        return (lStatus);
    }


	Vi[0]= 0x01;
	Vi[1]= Addr;
	Vi[2] = Vo[1] | Value;

    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		UPDATE_CMD,
		0x03,
		Vi,
		&To,
        &Lo,
		Vo
		);

    return (lStatus);
}


NTSTATUS T0toT1( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
	OS patch to put the reader in T1 mode
  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    NTSTATUS lStatus = STATUS_SUCCESS;

    // Verify each update to be done
    lStatus = Update(pSmartcardExtension,0x09,0x03);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x20,0x03);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x48,0x00);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x49,0x0F);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x4A,0x20);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x4B,0x0B);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x4C,0x40);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }
	
	lStatus = UpdateORL(pSmartcardExtension,0x2A,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	// Give the reader the time to process the change
	GprllWait(100);

    return (STATUS_SUCCESS);
}

NTSTATUS T1toT0( PSMARTCARD_EXTENSION pSmartcardExtension)
/*++

  Routine Description :
	OS patch to put the reader in T0 mode
  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;

    lStatus = Update(pSmartcardExtension,0x09,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	lStatus = Update(pSmartcardExtension,0x20,0x02);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }


	// Give the reader the time to process the change
	GprllWait(100);

    return (STATUS_SUCCESS);
}



NTSTATUS IccColdReset(
	PSMARTCARD_EXTENSION pSmartcardExtension
	)
/*++

  Routine Description :
	Cold reset function.
	The delay between the power down & the power up is strored
	in the PowerTimeout field of the READER_EXTENSION structure.
	The default value is 0.

  Arguments

	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //
    //	Local variables:
    //	- pReaderExt holds the pointer to the current ReaderExtension structure
    //	- lStatus holds the status to return.
    //	- Vi Holds the input buffer of the TLV commnand.
    //	- To holds the Tag of the returned TLV.
    //	- Lo holds the Length of the buffer of the returned TLV.
    //	- Vo holds the Buffer of the returned TLV.
    //	- RespLen holds the Length of the buffer of the TLV returned by the power up command.
    //	- Rbuff holds  the buffer of the TLV returned by the power up command.
    //
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT RespLen;
    UCHAR RespBuff[GPR_BUFFER_SIZE];
    UCHAR BWTimeAdjust;
    USHORT MaxChar;


	// Send power on command (GprllTLVExchange: T= 20h, L = 0)
	// <= response
    // Output variable initialisation
	RespLen = GPR_BUFFER_SIZE;

    To = 0x00;
    RespBuff[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		OPEN_SESSION_CMD,
		0x00,
		Vi,	
		&To,
		&RespLen,
		RespBuff
		);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	// Correct  the WTX pb
    // Get the value set by the reader
	Vi [0]=0x02;
	Vi [1]=0x4A;

    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		UPDATE_CMD,
		0x02,
		Vi,	
		&To,
		&Lo,
		Vo
		);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }


    // adjust the value of the BWT
    if(Vo[1] >= 0x80)
    {
        BWTimeAdjust = 0xff;
    }
    else
    {
   	    BWTimeAdjust = Vo[1] * 2;
    }

	lStatus = Update(pSmartcardExtension,0x4A,BWTimeAdjust);


	if (lStatus == STATUS_SUCCESS)
    {

        // Get the ATR length from this function
        MaxChar = RespLen - 1;
		RespLen = ATRLen(RespBuff+1, MaxChar) + 1;
		
        //
        // Copy ATR to smart card struct (remove the reader status byte)
		// The lib needs the ATR for evaluation of the card parameters
        //
        // Verification if Response buffer is larger than ATR buffer.
        //
        if (
            (pSmartcardExtension->SmartcardReply.BufferSize >= (ULONG) (RespLen - 1)) &&
            (sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer) >= (ULONG)(RespLen - 1))
            )
        {

		    RtlCopyMemory(
			    pSmartcardExtension->SmartcardReply.Buffer,
			    RespBuff + 1,
			    RespLen - 1
			    );
		
		    pSmartcardExtension->SmartcardReply.BufferLength = (ULONG) (RespLen - 1);
		
		    RtlCopyMemory(
			    pSmartcardExtension->CardCapabilities.ATR.Buffer,
			    pSmartcardExtension->SmartcardReply.Buffer,
			    pSmartcardExtension->SmartcardReply.BufferLength
			    );

		    pSmartcardExtension->CardCapabilities.ATR.Length =
			    (UCHAR) pSmartcardExtension->SmartcardReply.BufferLength ;


		    pSmartcardExtension->CardCapabilities.Protocol.Selected =
			    SCARD_PROTOCOL_UNDEFINED;

		    // Parse the ATR string in order to check if it as valid
		    // and to find out if the card uses invers convention
		    lStatus = SmartcardUpdateCardCapabilities(pSmartcardExtension);

		    if (lStatus == STATUS_SUCCESS)
            {
			    RtlCopyMemory(
				    pSmartcardExtension->IoRequest.ReplyBuffer,
				    pSmartcardExtension->CardCapabilities.ATR.Buffer,
				    pSmartcardExtension->CardCapabilities.ATR.Length
				    );

			    *pSmartcardExtension->IoRequest.Information =
				    pSmartcardExtension->SmartcardReply.BufferLength;

				//
				// Implicite protocol and parameters selection?
				// Verify if TA2 require to switch in TA1
				//
                if ( NeedToSwitchWithoutPTS(
                      pSmartcardExtension->CardCapabilities.ATR.Buffer,
                      pSmartcardExtension->CardCapabilities.ATR.Length) == FALSE)
				{
					// send reader parameters
				    IfdConfig(pSmartcardExtension, 0x11);
				}
		    }
        }
        else
        {
            lStatus = STATUS_BUFFER_TOO_SMALL;
        }

	}
	return (lStatus);
}



NTSTATUS IccPowerDown(
	PSMARTCARD_EXTENSION pSmartcardExtension
	)
/*++

  Routine Description : ICC power down function

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //	Local variables:
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - lStatus holds the status to return.
    //	 - Vi Holds the input buffer of the TLV commnand.
    //	 - To holds the Tag of the returned TLV.
    //	 - Lo holds the Length of the buffer of the returned TLV.
    //	 - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

	// Power down

    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		CLOSE_SESSION_CMD,
		0x00,
		Vi,
		&To,
		&Lo,
		Vo
		);
	
    if (lStatus == STATUS_SUCCESS)
    {
        pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
	}

   return (lStatus);
}



NTSTATUS IccIsoOutput(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   const UCHAR      pCommand[5],
   USHORT           *pRespLen,
   UCHAR            pRespBuff[]
	)
/*++

  Routine Description : This function sends an ISO OUT command to the card

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
	pCommand : Iso out command to send.
	pRespLen :  in  - maximum buffer size available
                out - returned buffer length.
	pRespBuff: returned buffer
--*/
{
    //	Local variables:
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - lStatus holds the status to return.
    //	 - Vi Holds the input buffer of the TLV commnand.
    //	 - To holds the Tag of the returned TLV.
    //	 - Lo holds the Length of the buffer of the returned TLV.
    //	 - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE]= { 0x01 };
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

	//   The five command bytes are added in cmd buffer.
	RtlCopyMemory(Vi + 1, pCommand, 5);

	//   The command is send to IFD.
	//   Fields RespLen and RespBuff are updates
	//   <= sResponse
    Lo = *pRespLen;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		APDU_EXCHANGE_CMD,
		6,
		Vi,
		&To,
		&Lo,
		Vo
		);

	if (lStatus != STATUS_SUCCESS)
    {
		*pRespLen = 0;
	}
	else
    {

        // To correct the bug of GPR400 version 1.0
		// If the response is 0xE7 then correct the response
		if (
           (Lo != 1) &&
           (pReaderExt->OsVersion<= 0x10 )&&
           (Vo[0]==0xE7)
           )
        {
            Lo = 0x03;
        }

        RtlCopyMemory(pRespBuff, Vo, Lo);
        *pRespLen = Lo;
	}
	return (lStatus);
}

NTSTATUS IccIsoInput(
	PSMARTCARD_EXTENSION pSmartcardExtension,
	const UCHAR        pCommand[5],
	const UCHAR        pData[],
		 USHORT      *pRespLen,
		 BYTE         pRespBuff[]
	)
/*++

  Routine Description : This function sends an ISO IN command to the card

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
	pCommand : Iso out command to send.
	pData : data to send.
	pRespLen :  in  - maximum buffer size available
                out - returned buffer length.
	pRespBuff: returned buffer
--*/
{
    //	Local variables:
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - Ti holds the apdu command tag.
    //	 - Li holds the Iso out command length.
    //	 - Vi holds Icc ISO In command whose format is
    //		  <DIR=0x00> <CLA> <INS> <P1> <P2> <Length> [ Data ]
    //		   Length = Length  + Dir + CLA + INS + P1 + P2
    //	 - To holds the response tag
    //	 - Lo holds th response buffer length.
    //	 - Vo holds the response buffer
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR Vi[GPR_BUFFER_SIZE] = { 0x00 };
	UCHAR Ti = APDU_EXCHANGE_CMD;
	UCHAR To;
	UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT Li;
    USHORT Lo;
    NTSTATUS lStatus=STATUS_SUCCESS;

	// Length of the the TLV = Length of data + 6
	Li = pCommand[4]+6,

	// The five command bytes are added in cmd buffer.
	RtlCopyMemory(Vi + 1, pCommand, 5);
	
	//The data field is added.
	RtlCopyMemory(Vi + 6, pData, pCommand[4]);

	// The command is send to IFD.
	// Fields RespLen and RespBuff are updates
    // <= sResponse
    Lo = *pRespLen;

	lStatus = GprllTLVExchange(
		pReaderExt,
		Ti,
		Li,
		Vi,
		&To,
		&Lo,
		Vo
		);

	if (lStatus == STATUS_SUCCESS)
    {
		*pRespLen = Lo;
		RtlCopyMemory(pRespBuff, Vo, Lo);
	}
	else
    {
		*pRespLen = 0;
	}

   return (lStatus);
}



NTSTATUS IccIsoT1(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   const USHORT     Li,
   const UCHAR      Vi[],
         USHORT     *Lo,
         UCHAR      Vo[]
	)
/*++


  Routine Description :  This function sends a T=1 frame to the card



  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
	Li : Length of the frame to send.
	Vi : frame to send.
	Lo :  in  - maximum buffer size available
          out - Length of the response buffer.
	Vo : Response buffer.
--*/
{
    //   Local variables:
    // - pReaderExt holds the pointer to the current ReaderExtension structure
    // - Ti Tag in TLV structure to send.
    // - To Tag in response TLV structure.
    UCHAR Ti = APDU_EXCHANGE_CMD;
    UCHAR To;
    NTSTATUS lStatus = STATUS_SUCCESS;
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;

    To = 0x00;

    // Return value for To is not needed, The function GprllTLVExchange verify that
    // it corresponds to the Ti
	lStatus = GprllTLVExchange(
		pReaderExt,
		Ti,
		Li,
		Vi,
		&To,
		Lo,
		Vo
		);
	
	return (lStatus);
}



NTSTATUS IfdConfig(
   PSMARTCARD_EXTENSION pSmartcardExtension,
   UCHAR  TA1
)
/*++

  Routine Description : This function Sets the correct internal values of the reader
               regarding the TA1 of the ATR.

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //	Local variables:
    //	 - sResponse holds the called function responses.
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - lStatus holds the status to return.
    //	 - Vi Holds the input buffer of the TLV commnand.
    //	 - To holds the Tag of the returned TLV.
    //	 - Lo holds the Length of the buffer of the returned TLV.
    //	 - Vo holds the Buffer of the returned TLV.
    //
    UCHAR Card_ETU1;
    UCHAR Card_ETU2;
    UCHAR Card_ETU1P;
    UCHAR Card_TA1;
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;   
    NTSTATUS lStatus = STATUS_SUCCESS;
    USHORT i = 0;

    // search TA1 parameters
    do {
	    if ( TA1 == cfg_ta1[i].TA1 )
        {
		    break;
        }
	    i++;
    } while ( cfg_ta1[i].TA1 != 0 );


    if(cfg_ta1[i].TA1 != 0)
    {
	    Card_TA1  = cfg_ta1[i].TA1;
	    Card_ETU1 =	cfg_ta1[i].ETU1;
	    Card_ETU2 =	cfg_ta1[i].ETU2;
	    Card_ETU1P=	cfg_ta1[i].ETU1P;
    }
    else
    {
        // Default value 9600
	    Card_TA1  = 0x11;
	    Card_ETU1 =	0x3B;
	    Card_ETU2 =	0x1E;
	    Card_ETU1P=	0x37;
    }

    // Verify each update to be done

	//Set the TA1
	lStatus = Update(pSmartcardExtension,0x32,Card_TA1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

	//Set the Card ETU1
	lStatus = Update(pSmartcardExtension,0x35,Card_ETU1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Card ETU2
	lStatus = Update(pSmartcardExtension,0x36,Card_ETU2);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Card ETU1 P
	lStatus = Update(pSmartcardExtension,0x39,Card_ETU1P);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save TA1
	lStatus = Update(pSmartcardExtension,0x3A,Card_TA1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU1
	lStatus = Update(pSmartcardExtension,0x3D,Card_ETU1);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU2
	lStatus = Update(pSmartcardExtension,0x3E,Card_ETU2);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    //Set the Save ETU1 P
	lStatus = Update(pSmartcardExtension,0x41,Card_ETU1P);
    if (lStatus != STATUS_SUCCESS)
    {
        return (lStatus);
    }

    // Give the reader the time to process the change
	GprllWait(100);

    return (STATUS_SUCCESS);

}


NTSTATUS IfdCheck(
	PSMARTCARD_EXTENSION pSmartcardExtension
	)
/*++

  Routine Description : This function performs a software reset of the GPR400 using 
		the Handshake register and TEST if hardware okay.

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //	Local variables:
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //   - HandShakeRegister
    //
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR HandShakeRegister;

#if DBG
    SmartcardDebug( 
        DEBUG_ERROR, 
        ( "%s!IfdCheck: Enter\n",
        SC_DRIVER_NAME)
        );
#endif

    // In the case that system reboot for Hibernate in
    // Power management. The GPR400 signal a device was been remove
    // but we have to request a second time to have the actual
    // state of the reader.

	HandShakeRegister = GprllReadRegister(pReaderExt,REGISTER_HANDSHAKE);

    SmartcardDebug( 
        DEBUG_DRIVER, 
        ("%s!IfdCheck: Read HandShakeRegister value:%x\n",
        SC_DRIVER_NAME, HandShakeRegister)
        );

	//Set to 1 the Master Reset bit from Handshake register
	GprllMaskHandshakeRegister(pReaderExt,0x01,1);

	//Wait 10 ms
	GprllWait(10);
	
	//Reset the Master Reset bit from Handshake register
	GprllMaskHandshakeRegister(pReaderExt,0x01,0);

	//Wait 80 ms
	GprllWait(80);

	HandShakeRegister = GprllReadRegister(pReaderExt,REGISTER_HANDSHAKE);

    SmartcardDebug( 
        DEBUG_DRIVER, 
        ("%s!IfdCheck: Read HandShakeRegister 2nd time value:%x\n",
        SC_DRIVER_NAME, HandShakeRegister)
        );

	if(HandShakeRegister != 0x80)
	{
		// Return reader IO problem
		return (STATUS_IO_DEVICE_ERROR);
	}

    return (STATUS_SUCCESS);
}


NTSTATUS IfdReset(
	PSMARTCARD_EXTENSION pSmartcardExtension
	)
/*++

  Routine Description : This function performs a software reset of the GPR400 using
		the Handshake register.

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    //	Local variables:
    //	 - sResponse holds the called function responses.
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - lStatus holds the status to return.
    //	 - Vi Holds the input buffer of the TLV commnand.
    //	 - To holds the Tag of the returned TLV.
    //	 - Lo holds the Length of the buffer of the returned TLV.
    //	 - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

#if DBG
    SmartcardDebug(
        DEBUG_TRACE,
        ( "%s!IfdReset: Enter\n",
        SC_DRIVER_NAME)
        );
#endif

    // In the case that system reboot for Hibernate in
    // Power management. The GPR400 signal a device was been remove
    // but we have to request a second time to have the actual
    // state of the reader.

	//Set to 1 the Master Reset bit from Handshake register
	GprllMaskHandshakeRegister(pReaderExt,0x01,1);

	//Wait 10 ms
	GprllWait(10);
	
	//Reset the Master Reset bit from Handshake register
	GprllMaskHandshakeRegister(pReaderExt,0x01,0);

	//Wait 80 ms
	GprllWait(80);

	//Read the GPR status
	Vi[0] = 0x00;
	Lo = GPR_BUFFER_SIZE;

	lStatus = GprllTLVExchange (
		pReaderExt,
		CHECK_AND_STATUS_CMD,
		0x01,
		Vi,
		&To,
		&Lo,
		Vo
		);

#if DBG
      SmartcardDebug(
         DEBUG_TRACE,
         ( "%s!IfdReset: GprllTLVExchange status= %x\n",
         SC_DRIVER_NAME, lStatus)
         );
#endif		

    	if (lStatus != STATUS_SUCCESS)
    	{
	    SmartcardDebug(
	        DEBUG_TRACE,
	        ( "%s!IfdReset: GprllTLVExchange() failed! Leaving.....\n",
        	SC_DRIVER_NAME)
	        );
	
        	return (lStatus);
	}

	//Memorize the GPR400 version
	pReaderExt->OsVersion = Vo[1];

	pSmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
		pReaderExt->OsVersion & 0x0f;

	pSmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
		(pReaderExt->OsVersion & 0xf0) >> 4;

	    SmartcardDebug(
        	DEBUG_TRACE,
	        ( "%s!IfdReset: Loading Master driver...\n",
       		SC_DRIVER_NAME)
	        );
	
	//Load the Master Driver in RAM at @2100h
	Vi[0] = 0x02;  // DIR
	Vi[1] = 0x01 ; // ADR MSB
	Vi[2] = 0x00 ; // ADR LSB
	memcpy(&Vi[3], MASTER_DRIVER, sizeof(MASTER_DRIVER));
    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange (
		pReaderExt,
		LOAD_MEMORY_CMD,
        sizeof(MASTER_DRIVER) + 3,
		Vi,
		&To,
		&Lo,
		Vo
		);
    if (lStatus != STATUS_SUCCESS)
    {
	    SmartcardDebug(
	        DEBUG_TRACE,
	        ( "%s!IfdReset: GprllTLVExchange() failed! Leaving.....\n",
        	SC_DRIVER_NAME)
	        );
        return (lStatus);
    }

    lStatus = ValidateDriver(pSmartcardExtension);
    if (lStatus != STATUS_SUCCESS)
    {
	    SmartcardDebug(
	        DEBUG_TRACE,
	        ( "%s!IfdReset: ValidateDriver() failed! Leaving.....\n",
        	SC_DRIVER_NAME)
	        );
        return (lStatus);
    }

    return (STATUS_SUCCESS);

}



NTSTATUS IfdPowerDown(
	PSMARTCARD_EXTENSION pSmartcardExtension
	)
/*++

  Routine Description :
	This function powers down the IFD

  Arguments
	pSmartcardExtension: Pointer to the SmartcardExtension structure.

  --*/
{
    //	Local variables:
    //	 - sResponse holds the called function responses.
    //	 - pReaderExt holds the pointer to the current ReaderExtension structure
    //	 - lStatus holds the status to return.
    //	 - Vi Holds the input buffer of the TLV commnand.
    //	 - To holds the Tag of the returned TLV.
    //	 - Lo holds the Length of the buffer of the returned TLV.
    //	 - Vo holds the Buffer of the returned TLV.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    NTSTATUS lStatus = STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];

	// Put the GPR in Power-down mode (GprllTLVExchange T=0x40, L=1 and V=0x00)
	// <==      response of the GprllTLVExchange
	Vi[0] = 0x00;
    // Output variable initialisation
	Lo = GPR_BUFFER_SIZE;
    To = 0x00;
    Vo[0] = 0x00;

	lStatus = GprllTLVExchange(
		pReaderExt,
		POWER_DOWN_GPR_CMD,
		0x01,
		Vi,
		&To,
		&Lo,
		Vo
		);

	return (lStatus);
}


NTSTATUS GprCbReaderPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

  Routine Description :
   This function is called by the Smart card library when a
     IOCTL_SMARTCARD_POWER occurs.
   This function provides 3 differents functionnality, depending of the minor
   IOCTL value
     - Cold reset (SCARD_COLD_RESET),
     - Warm reset (SCARD_WARM_RESET),
     - Power down (SCARD_POWER_DOWN).

  Arguments
      - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus = STATUS_SUCCESS;
	PREADER_EXTENSION pReader;

	ASSERT(SmartcardExtension != NULL);

	pReader = SmartcardExtension->ReaderExtension;
	waitForIdleAndBlock(pReader);
	switch(SmartcardExtension->MinorIoControlCode)
    {
		case SCARD_POWER_DOWN:
			//Power down the ICC
			lStatus = IccPowerDown(SmartcardExtension);
			break;

		case SCARD_COLD_RESET:
			// Power up the ICC after a power down and a PowerTimeout waiting time.
			lStatus = IccPowerDown(SmartcardExtension);
            if(lStatus != STATUS_SUCCESS)
            {
                break;
            }

	        // Waits for the Power Timeout to be elapsed before the reset command.
	        GprllWait(SmartcardExtension->ReaderExtension->PowerTimeOut);

		case SCARD_WARM_RESET:
			lStatus = IccColdReset(SmartcardExtension);
			break;

		default:
			lStatus = STATUS_NOT_SUPPORTED;
	}

	setIdle(pReader);
	return lStatus;
}

NTSTATUS GprCbTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

  Routine Description :

     This function is called by the Smart card library when a
     IOCTL_SMARTCARD_TRANSMIT occurs.
   This function is used to transmit a command to the card.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus=STATUS_SUCCESS;
    PUCHAR requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;
    PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
    PULONG requestLength = &SmartcardExtension->SmartcardRequest.BufferLength;
    PULONG replyLength = &SmartcardExtension->SmartcardReply.BufferLength;
    USHORT sRespLen;
    UCHAR pRespBuff[GPR_BUFFER_SIZE];
	PREADER_EXTENSION pReader;

	PAGED_CODE();
	ASSERT(SmartcardExtension != NULL);

	*requestLength = 0;
    sRespLen = 0;
    pRespBuff[0] = 0x0;

	pReader = SmartcardExtension->ReaderExtension;
	waitForIdleAndBlock(pReader);
	switch (SmartcardExtension->CardCapabilities.Protocol.Selected)
    {
		// Raw
		case SCARD_PROTOCOL_RAW:
			lStatus = STATUS_INVALID_DEVICE_STATE;
			break;

		// T=0
		case SCARD_PROTOCOL_T0:
			lStatus = SmartcardT0Request(SmartcardExtension);
			if (lStatus != STATUS_SUCCESS)
            {
				setIdle(pReader);
				return lStatus;
			}

			sRespLen = GPR_BUFFER_SIZE;
            pRespBuff[0] = 0x0;
			
			if (SmartcardExtension->T0.Le > 0)
            {
				// ISO OUT command	if BufferLength = 5
				lStatus = IccIsoOutput(
					SmartcardExtension,
					( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
					&sRespLen,
					pRespBuff
					);
			}
			else
            {
				// ISO IN command	if BufferLength >5 or BufferLength = 4
				lStatus = IccIsoInput(
					SmartcardExtension,
					( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
					( UCHAR *) SmartcardExtension->SmartcardRequest.Buffer+5,
					&sRespLen,
					pRespBuff
					);
			}
			if (lStatus != STATUS_SUCCESS)
            {
				setIdle(pReader);
				return lStatus;
			}
			// Copy the response command without the reader status

            // Verify if the buffer is large enough
            if (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG)(sRespLen - 1))
            {
			    RtlCopyMemory(
				    SmartcardExtension->SmartcardReply.Buffer,
				    pRespBuff + 1,
				    sRespLen - 1);
			    SmartcardExtension->SmartcardReply.BufferLength =
				    (ULONG) (sRespLen - 1);
            }
            else
            {
                        // SmartcardT0Reply must be called; prepare this call.
                    SmartcardExtension->SmartcardReply.BufferLength = 0;
            }
			lStatus = SmartcardT0Reply(SmartcardExtension);
			
			break;
		// T=1
		case SCARD_PROTOCOL_T1:

			do
            {
				SmartcardExtension->SmartcardRequest.BufferLength = 0;
				lStatus = SmartcardT1Request(SmartcardExtension);
				if(lStatus != STATUS_SUCCESS)
                {
					setIdle(pReader);
					return lStatus;
				}

				sRespLen = GPR_BUFFER_SIZE;
                pRespBuff[0] = 0x0;
				lStatus = IccIsoT1(
					SmartcardExtension,
					(USHORT) SmartcardExtension->SmartcardRequest.BufferLength,
					(UCHAR *) SmartcardExtension->SmartcardRequest.Buffer,
					&sRespLen,
					pRespBuff);

				if(lStatus != STATUS_SUCCESS)
                {
					// do not try to access the reader anymore.
					if(lStatus == STATUS_DEVICE_REMOVED)
					{
						setIdle(pReader);
						return lStatus;
					}
						// Let the SmartcardT1Reply determine the status
					sRespLen = 1;
				}
				// Copy the response of the reader in the reply buffer
				// Remove the status of the reader
                // Verify if the buffer is large enough
                if (SmartcardExtension->SmartcardReply.BufferSize >= (ULONG)(sRespLen - 1))
                {
				    RtlCopyMemory(
					    SmartcardExtension->SmartcardReply.Buffer,
					    pRespBuff + 1 ,
					    sRespLen - 1
					    );
				    SmartcardExtension->SmartcardReply.BufferLength =
					    (ULONG) sRespLen - 1;
                }
                else
                {
                    // SmartcardT1Reply must be called; prepare this call.
                    SmartcardExtension->SmartcardReply.BufferLength = 0;
                }

				lStatus = SmartcardT1Reply(SmartcardExtension);

            } while(lStatus == STATUS_MORE_PROCESSING_REQUIRED);
			break;
		default:
			lStatus = STATUS_INVALID_DEVICE_REQUEST;
			break;
	}

	setIdle(pReader);
	return lStatus;
}


NTSTATUS GprCbSetProtocol(
   PSMARTCARD_EXTENSION SmartcardExtension
)
/*++

  Routine Description :

      This function is called by the Smart card library when a
	  IOCTL_SMARTCARD_SET_PROTOCOL occurs.
	The minor IOCTL value holds the protocol to set.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
--*/
{
    NTSTATUS lStatus=STATUS_SUCCESS;
    UCHAR Vi[GPR_BUFFER_SIZE];
    UCHAR To;
    USHORT Lo;
    UCHAR Vo[GPR_BUFFER_SIZE];
    READER_EXTENSION *pReaderExt = SmartcardExtension->ReaderExtension;
    UCHAR PTS0=0;
    UCHAR Value = 0;
	PREADER_EXTENSION pReader;



	PAGED_CODE();
	ASSERT(SmartcardExtension != NULL);


	pReader = SmartcardExtension->ReaderExtension;
	
	waitForIdleAndBlock(pReader);
    
    //	Check if the card is already in specific state
    //	and if the caller wants to have the already selected protocol.
    //	We return success if this is the case.
    //
	*SmartcardExtension->IoRequest.Information = 0x00;

	if ( SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC &&
		 ( SmartcardExtension->CardCapabilities.Protocol.Selected &
		   SmartcardExtension->MinorIoControlCode
         )
       )
    {
		lStatus = STATUS_SUCCESS;
	}
	else
    {
        __try
        {
		    if (SmartcardExtension->CardCapabilities.Protocol.Supported &
			    SmartcardExtension->MinorIoControlCode &
			    SCARD_PROTOCOL_T1)
            {

                // select T=1
	            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T1;
			    PTS0= 0x11;
            }
		    else if (SmartcardExtension->CardCapabilities.Protocol.Supported &
				    SmartcardExtension->MinorIoControlCode &
				    SCARD_PROTOCOL_T0)
            {

                // select T=0
	            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
			    PTS0 = 0x10;

	        }
            else
            {
                lStatus = STATUS_INVALID_DEVICE_REQUEST;
                __leave;
            }


		    // Send the PTS function
		    Vi[0] = 0xFF;
		    Vi[1] = PTS0;
		    Vi[2] = SmartcardExtension->CardCapabilities.PtsData.Fl <<4 |
			    SmartcardExtension->CardCapabilities.PtsData.Dl;
		    Vi[3] = (0xFF ^ PTS0) ^ Vi[2];

	        Lo = GPR_BUFFER_SIZE;
            To = 0x00;
            Vo[0] = 0x00;


            // Status of the PTS could be STATUS SUCCESS
            // or STATUS_DEVICE_PROTOCOL_ERROR if failed.
            lStatus = GprllTLVExchange(
                pReaderExt,
                EXEC_MEMORY_CMD,
                0x04,
                Vi,
                &To,
                &Lo,
                Vo
                );

#if DBG
            SmartcardDebug(
                DEBUG_TRACE,
                ( "%s!IfdReset: GprCbSetProtocol status= %x\n",
                SC_DRIVER_NAME, lStatus)
                );
#endif		

            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }


            // reader should reply status byte of 00 or 12
            // the rest is other problem with no relation with
            // the PTS negociation
            lStatus = STATUS_SUCCESS;

		    // Put the reader in the right protocol
		    if (SmartcardExtension->CardCapabilities.Protocol.Selected == SCARD_PROTOCOL_T1)
            {
			    lStatus = T0toT1(SmartcardExtension);
		    }
		    else
            {
			    lStatus = T1toT0(SmartcardExtension);
		    }
            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }


		    lStatus = IfdConfig(SmartcardExtension, 0x11);
            if (lStatus != STATUS_SUCCESS)
            {
                __leave;
            }

        }
            // we change the error code to a protocol error.
        __finally
        {
            if (lStatus != STATUS_SUCCESS &&
                lStatus != STATUS_INVALID_DEVICE_REQUEST
                )
            {
                lStatus = STATUS_DEVICE_PROTOCOL_ERROR;
            }
        }
   }

   
    //
    //	Set the reply buffer length to sizeof(ULONG).
    //	Check if status SUCCESS, store the selected protocol.
    //

	if (lStatus == STATUS_SUCCESS)
    {
	    *SmartcardExtension->IoRequest.Information =
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);

		*( PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
			SmartcardExtension->CardCapabilities.Protocol.Selected;

		SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
	}
    else
    {
        SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_UNDEFINED;
        *SmartcardExtension->IoRequest.Information = 0;
    }

	setIdle(pReader);
    return lStatus;

}


NTSTATUS AskForCardPresence(
    PSMARTCARD_EXTENSION pSmartcardExtension
)
/*++

  Routine Description :
	
	This functions send a TLV command to the reader to know if there
	is a card inserted.

	The function does not wait to the answer. The treatment of the
	answer is done in the interrupt routine.

  Arguments
	
	  pSmartcardExtension: Pointer to the SmartcardExtension structure.
--*/
{
    // Local variables:
    //  - pReaderExt holds the pointer to the current ReaderExtension structure
    //  - V holds the value for the TLV comand.
    READER_EXTENSION *pReaderExt = pSmartcardExtension->ReaderExtension;
    UCHAR V=0x02;

	GprllSendCmd(pReaderExt,CHECK_AND_STATUS_CMD,1,&V);

	return (STATUS_SUCCESS);
}


NTSTATUS SpecificTag(
	PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD                IoControlCode,
    DWORD                BufferInLen,
    BYTE                *BufferIn,
    DWORD                BufferOutLen,
    BYTE                *BufferOut,
    DWORD               *LengthOut
)
/*++


  Routine Description :
   This function is called when a specific Tag request occurs.

  Arguments
    - SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.
    - IoControlCode holds the IOCTL value.
--*/
{
    ULONG TagValue;
    PREADER_EXTENSION pReaderExtension = SmartcardExtension->ReaderExtension;

    //Set the reply buffer length to 0.
    *LengthOut = 0;

	//Verify the length of the Tag
	//<==   STATUS_BUFFER_TOO_SMALL
	if (BufferInLen < (DWORD) sizeof(TagValue))
    {
		return(STATUS_BUFFER_TOO_SMALL);
	}


    TagValue = (ULONG) *((PULONG)BufferIn);

	//Switch for the different IOCTL:
	//Get the value of one tag (IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE)
	//Switch for the different Tags:
	switch(IoControlCode)
    {
		case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
			switch (TagValue)
            {
				// Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
				//   Verify the length of the output buffer.
				// <==               STATUS_BUFFER_TOO_SMALL
				//   Update the output buffer and the length.
				// <==               STATUS_SUCCESS
				case SCARD_ATTR_SPEC_POWER_TIMEOUT:
					if ( BufferOutLen < (DWORD) sizeof(pReaderExtension->PowerTimeOut))
                    {
						return(STATUS_BUFFER_TOO_SMALL);
					}
					ASSERT(BufferOut != 0);
					memcpy(
						BufferOut,
						&pReaderExtension->PowerTimeOut,
						sizeof(pReaderExtension->PowerTimeOut)
						);
					
					*(LengthOut) =
						(ULONG) sizeof(pReaderExtension->PowerTimeOut);
					
					return STATUS_SUCCESS;
					break;
				// Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
				//   Verify the length of the output buffer.
				// <==               STATUS_BUFFER_TOO_SMALL
				//   Update the output buffer and the length.
				// <==               STATUS_SUCCESS
				case SCARD_ATTR_SPEC_CMD_TIMEOUT:
					if (BufferOutLen < (DWORD) sizeof(pReaderExtension->CmdTimeOut))
                    {
						return(STATUS_BUFFER_TOO_SMALL);
					}
					ASSERT(BufferOut != 0);
					memcpy(
						BufferOut,
						&pReaderExtension->CmdTimeOut,
						sizeof(pReaderExtension->CmdTimeOut)
						);
					*(LengthOut) =
						(ULONG) sizeof(pReaderExtension->CmdTimeOut);
					
					return STATUS_SUCCESS;
					
					break;

				case SCARD_ATTR_MANUFACTURER_NAME:
					if (BufferOutLen < ATTR_LENGTH)
					{
						return STATUS_BUFFER_TOO_SMALL;
					}
					// Copy the string of the Manufacturer Name

					memcpy(
						BufferOut,
						ATTR_MANUFACTURER_NAME,
						sizeof(ATTR_MANUFACTURER_NAME)
						);

					*(LengthOut) = (ULONG)sizeof(ATTR_MANUFACTURER_NAME);

					return STATUS_SUCCESS;
					break;

				case SCARD_ATTR_ORIGINAL_FILENAME:
					if (BufferOutLen < ATTR_LENGTH)
					{
						return STATUS_BUFFER_TOO_SMALL;
					}
					// Copy the string of the Original file name of the current driver
					memcpy(
						BufferOut,
						ATTR_ORIGINAL_FILENAME,
						sizeof(ATTR_ORIGINAL_FILENAME)
						);

					*(LengthOut) = (ULONG)sizeof(ATTR_ORIGINAL_FILENAME);

					return STATUS_SUCCESS;
					break;

				// Unknown tag
				// <==            STATUS_NOT_SUPPORTED
				default:
					return STATUS_NOT_SUPPORTED;
					break;
			}
			break;

        // Set the value of one tag (IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE)
		// Switch for the different Tags:
		case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
			switch (TagValue)
            {
				// Power Timeout (SCARD_ATTR_SPEC_POWER_TIMEOUT)
				// Verify the length of the input buffer.
				// <==               STATUS_BUFFER_TOO_SMALL
				// Update the value.
				// <==               STATUS_SUCCESS


				case SCARD_ATTR_SPEC_POWER_TIMEOUT:
					if (  BufferInLen <
						(DWORD)  (sizeof(pReaderExtension->PowerTimeOut) +
						sizeof(TagValue))
                        )
                    {
						return(STATUS_BUFFER_TOO_SMALL);
					}
					ASSERT(BufferIn !=0);
					memcpy(
						&pReaderExtension->PowerTimeOut,
						BufferIn + sizeof(TagValue),
						sizeof(pReaderExtension->PowerTimeOut)
						);
					return STATUS_SUCCESS;
					break;
				// Command Timeout (SCARD_ATTR_SPEC_CMD_TIMEOUT)
				// Verify the length of the input buffer.
				// <==               STATUS_BUFFER_TOO_SMALL
				// Update the value.
				// <==               STATUS_SUCCESS


				case SCARD_ATTR_SPEC_CMD_TIMEOUT:
					if ( BufferInLen <
						(DWORD) (   sizeof(pReaderExtension->CmdTimeOut) +
						sizeof(TagValue))
                        )
                    {
						return(STATUS_BUFFER_TOO_SMALL);
					}
					ASSERT(BufferIn != 0);
					memcpy(
						&pReaderExtension->CmdTimeOut,
						BufferIn + sizeof(TagValue),
						sizeof(pReaderExtension->CmdTimeOut)
						);
					return STATUS_SUCCESS;
					break;
				// Unknown tag
				// <==            STATUS_NOT_SUPPORTED
				default:
					return STATUS_NOT_SUPPORTED;
			}
			break;
		default:
			return STATUS_NOT_SUPPORTED;
	}
}


NTSTATUS SwitchSpeed(
	PSMARTCARD_EXTENSION   SmartcardExtension,
	ULONG                  BufferInLen,
	PUCHAR                 BufferIn,
	ULONG                  BufferOutLen,
	PUCHAR                 BufferOut,
	PULONG                 LengthOut
	)
/*++

Routine Description:

   This function is called when apps want to switch reader speed after a
   proprietary switch speed (switch protocol) command has been sent to the
   smart card.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.
   BufferInLen          - holds the length of the input data.
   BufferIn             - holds the input data.  TA1.  If 0 
   BufferOutLen         - holds the size of the output buffer.
   BufferOut            - the output buffer. Reader status code.
   LengthOut            - holds the length of the output data.

  Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.

--*/
{
    NTSTATUS status;
    BYTE  NewTA1;
	ULONG i;

    ASSERT(SmartcardExtension != NULL);

    *LengthOut = 0;
    // Just checking if IOCTL exists.
    if (BufferInLen == 0)
    {
        SmartcardDebug(
           DEBUG_INFO,
           ("%s!SwitchSpeed: Just checking IOCTL.\n",
           SC_DRIVER_NAME)
           );
        return(STATUS_SUCCESS);
    }
    else
    {
        NewTA1 = BufferIn[0];
		i = 0;
		// Verify if this TA1 is support by the GPR400
		do {
			if ( NewTA1 == cfg_ta1[i].TA1 )
			{
				// TA1 Found!
				break;
			}
			i++;
		} while ( cfg_ta1[i].TA1 != 0 );
	}

	// If 0 means TA1 not found
    if(cfg_ta1[i].TA1 != 0)
	{
        SmartcardDebug(
           DEBUG_INFO,
           ("%s!GDDK_0ASwitchSpeed: 0x%X\n",
           SC_DRIVER_NAME, NewTA1)
           );
		status = IfdConfig(SmartcardExtension, NewTA1);
	}
	else
	{
		// TA1 not supported
		return STATUS_NOT_SUPPORTED;
	}

    return status;
}



NTSTATUS GprCbVendorIoctl(
	PSMARTCARD_EXTENSION   SmartcardExtension
)
/*++

  Routine Description :

   This routine is called when a vendor IOCTL_SMARTCARD_ is send to the driver.

  Arguments
	- SmartcardExtension is a pointer on the SmartCardExtension structure of
      the current device.

  Return Value:

    STATUS_SUCCESS          - We could execute the request.
    STATUS_BUFFER_TOO_SMALL - The output buffer is to small.
    STATUS_NOT_SUPPORTED    - We could not support the Ioctl specified.
--*/
{
    PREADER_EXTENSION pReaderExtension = SmartcardExtension->ReaderExtension;
    UCHAR To;
	UCHAR Vo[GPR_BUFFER_SIZE];
    USHORT Lo;
    USHORT BufferInLen = 0;
    NTSTATUS lStatus=STATUS_SUCCESS;
	PREADER_EXTENSION pReader;

	PAGED_CODE();
	ASSERT(SmartcardExtension != NULL);

   // Set the reply buffer length to 0.
	*SmartcardExtension->IoRequest.Information = 0;


	pReader = SmartcardExtension->ReaderExtension;
	
	waitForIdleAndBlock(pReader);
	
	//Switch for the different IOCTL:

	switch(SmartcardExtension->MajorIoControlCode)
    {

        case IOCTL_SMARTCARD_VENDOR_GET_ATTRIBUTE:
        case IOCTL_SMARTCARD_VENDOR_SET_ATTRIBUTE:
            SpecificTag(
			    SmartcardExtension,
			    (ULONG)  SmartcardExtension->MajorIoControlCode,
			    (ULONG)  SmartcardExtension->IoRequest.RequestBufferLength,
			    (PUCHAR) SmartcardExtension->IoRequest.RequestBuffer,
			    (ULONG)  SmartcardExtension->IoRequest.ReplyBufferLength,
			    (PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer,
			    (PULONG) SmartcardExtension->IoRequest.Information
			    );
        break;


	    // IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:
	    // Translate the buffer to TLV and send it to the reader.
	    case IOCTL_SMARTCARD_VENDOR_IFD_EXCHANGE:

		    if(SmartcardExtension->IoRequest.ReplyBufferLength < 3)
		    {
				setIdle(pReader);
				return(STATUS_INVALID_BUFFER_SIZE);
		    }

            BufferInLen = (SmartcardExtension->IoRequest.RequestBuffer[2]*0x100)
			       +  SmartcardExtension->IoRequest.RequestBuffer[1];

		    if( (ULONG) BufferInLen > (SmartcardExtension->IoRequest.ReplyBufferLength - 3))
		    {
				setIdle(pReader);
			    return(STATUS_INVALID_BUFFER_SIZE);
		    }

            Lo = GPR_BUFFER_SIZE;
            To = 0x00;
            Vo[0] = 0x00;

		    lStatus = GprllTLVExchange(
			    pReaderExtension,
			    (const BYTE) SmartcardExtension->IoRequest.RequestBuffer[0],
			    (const USHORT) BufferInLen,
			    (const BYTE *) &(SmartcardExtension->IoRequest.RequestBuffer[3]),
			    &To,
			    &Lo,
			    Vo
			    );

            if (lStatus != STATUS_SUCCESS)
            {
				setIdle(pReader);
                return (lStatus);
            }

            // Check if there is enough space in the reply buffer
		    if((ULONG)(Lo+3) > SmartcardExtension->IoRequest.ReplyBufferLength)
            {
				setIdle(pReader);
			    return(STATUS_INVALID_BUFFER_SIZE);
		    }
		    else
            {
			    ASSERT(SmartcardExtension->IoRequest.ReplyBuffer != 0);
			    SmartcardExtension->IoRequest.ReplyBuffer[0] = To;
			    SmartcardExtension->IoRequest.ReplyBuffer[1] = LOBYTE(Lo);
			    SmartcardExtension->IoRequest.ReplyBuffer[2] = HIBYTE(Lo);
			    memcpy((SmartcardExtension->IoRequest.ReplyBuffer)+3,Vo,Lo);

			    *(SmartcardExtension->IoRequest.Information) = (DWORD) (Lo + 3);
				setIdle(pReader);
			    return(STATUS_SUCCESS);
		    }		
		//
		// For IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED
		//   Call the SwitchSpeed function
		//
		case IOCTL_SMARTCARD_VENDOR_SWITCH_SPEED:
			lStatus = SwitchSpeed(
				SmartcardExtension,
				(ULONG)  SmartcardExtension->IoRequest.RequestBufferLength,
				(PUCHAR) SmartcardExtension->IoRequest.RequestBuffer,
				(ULONG)  SmartcardExtension->IoRequest.ReplyBufferLength,
				(PUCHAR) SmartcardExtension->IoRequest.ReplyBuffer,
				(PULONG) SmartcardExtension->IoRequest.Information
				);
			break;

	    default:
			setIdle(pReader);
		    return STATUS_NOT_SUPPORTED;
	}
	setIdle(pReader);
    return lStatus;
}



NTSTATUS GprCbSetupCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
)
/*++

Routine Description:

   This function is called by the Smart card library when an
     IOCTL_SMARTCARD_IS_PRESENT or IOCTL_SMARTCARD_IS_ABSENT occurs.

Arguments:

   SmartcardExtension   - is a pointer on the SmartCardExtension structure of
                           the current device.

Return Value:

    STATUS_PENDING                - The request is in a pending mode.

--*/
{

    NTSTATUS NTStatus = STATUS_PENDING;
    POS_DEP_DATA pOS = NULL;
    KIRQL oldIrql;

	PAGED_CODE();
    ASSERT(SmartcardExtension != NULL);

	//
	//Initialize
	//
	pOS = SmartcardExtension->OsData;

	//
	//Set cancel routine for the notification IRP.
	//
	IoAcquireCancelSpinLock(&oldIrql);

	IoSetCancelRoutine(
		pOS->NotificationIrp,
		GprCancelEventWait
		);

	IoReleaseCancelSpinLock(oldIrql);

	NTStatus = STATUS_PENDING;

	return (NTStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprnt.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
    gprnt.h 

Description: 
    This module holds the prototypes of the functions 
    from gprnt.C + MACRO and structures declarations 
Environment:
    Kernel Mode

Revision History:
    22/11/98: V1.00.004  (Y. Nadeau)
      - Add KEvent ReaderRemoved
    06/05/98: V1.00.003  (P. Plouidy)
        - Power management for NT5 
    10/02/98: V1.00.002  (P. Plouidy)
        - Plug and Play for NT5 
    03/07/97: V1.00.001  (P. Plouidy)
        - Start of development.


--*/

#define SMARTCARD_POOL_TAG 'bGCS'

//
//   Include
//
// - smclib.h: smart card library definitions.
//
#include <ntddk.h>
#include <smclib.h>

#ifndef _GPRNT_
#define _GPRNT_


//
//   Constant section
//

#define SC_VENDOR_NAME          "Gemplus"
#define SC_DRIVER_NAME          "GPR400"
#define SC_IFD_TYPE             "GPR400"

#define GPR_DEFAULT_FREQUENCY   3686
#define GPR_MAX_FREQUENCY       3686    
#define GPR_MAX_IFSD            253
#define GPR_DEFAULT_DATARATE    9909    
#define GPR_MAX_DATARATE        9909 
#define GPR_MAX_DEVICE          4
#define GPR_DEFAULT_TIME        120l     // Exchange Cmd
#define GPR_CMD_TIME            5        // Gpr Cmd only
#define GPR_DEFAULT_POWER_TIME  0
#define GPR_BUFFER_SIZE         262


// DRIVER FLAVOR
// 0 : Gemplus GPR400
// 1 : IBM IBM400
// 2 : COMPAQ PC_CARD_SMARTCARD_READER
// ...

#define DF_GPR400               0
#define DF_IBM400               1
#define DF_CPQ400               2

#define SZ_VENDOR_NAME          "GEMPLUS"
#define SZ_VENDOR_NAME_IBM      "IBM"
#define SZ_VENDOR_NAME_COMPAQ   "COMPAQ"

#define SZ_READER_NAME          "GPR400"
#define SZ_READER_NAME_IBM      "IBM400"
#define SZ_READER_NAME_COMPAQ   "PC_CARD_SMARTCARD_READER"

#define GPR400_ID               "\\??\\PCMCIA#GEMPLUS-GPR400"
#define COMPAQ_ID               "\\??\\PCMCIA#COMPAQ-PC_Card_SmartCard_Reader-446E"

#define CHECK_ID_LEN            25 // Check first 25 bytes!

//
//   MACRO declarations.
//
#ifndef SMARTCARD_NT_LOG
#define SMARTCARD_NT_LOG(pObj, lErrCode, pwszStr, ulDump) \
            do { \
                if (lErrCode != 0) { \
                    SmartcardLogError(pObj, \
                                      lErrCode, \
                                      pwszStr, \
                                      ulDump); } \
            } while (0)
#endif

#ifndef NT_FAIL
#define NT_FAIL(status)         (((NTSTATUS) (status)) < 0)
#endif

#ifndef IS_POINTER_INVALID
#define IS_POINTER_INVALID(p)       (!IS_POINTER_VALID(p))
#endif

#ifndef IS_POINTER_VALID
#define IS_POINTER_VALID(p) \
                    ((BOOLEAN) ((p != NULL) ? TRUE : FALSE))
#endif

#ifndef IS_HANDLE_VALID
#define IS_HANDLE_VALID(h) \
                    ((BOOLEAN) ((h == NULL) ? FALSE : TRUE))
#endif

#ifndef IS_HANDLE_INVALID
#define IS_HANDLE_INVALID(h)    (!IS_HANDLE_VALID(h))
#endif

#ifndef INIT_STRING
#define INIT_STRING(s) \
                    s.Length = 0; \
                    s.MaximumLength = 0; \
                    s.Buffer = NULL
#endif

//
//   Data structures.
//

//  PCMCIA_READER_CONFIG:Configuration data structure for PC Card readers.
typedef struct _PCMCIA_READER_CONFIG {
    KIRQL       Level;
    KAFFINITY   Affinity;
    ULONG       Vector;
    USHORT      BufferSize;
    USHORT      Reserved;
 } PCMCIA_READER_CONFIG, *PPCMCIA_READER_CONFIG, *LPPCMCIA_READER_CONFIG;

typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;


typedef enum _ACTION {
    
    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;


//  GPR400_REGISTERS: GPR400 I/O registers
typedef struct _GPR400_REGISTERS {
    UCHAR  ucHandshake;         
    UCHAR  ucProgram;           
    UCHAR  ucT;                 
    UCHAR  ucL;                 
    UCHAR  ucV; 
    UCHAR  Dummy[3];            
 } GPR400_REGISTERS, *PGPR400_REGISTERS, *LPGPR400_REGISTERS;


//  READER_EXTENSION:
typedef struct _READER_EXTENSION {
    
    ULONG                   CmdTimeOut;
    ULONG                   PowerTimeOut;
    PGPR400_REGISTERS       BaseIoAddress;
    PCMCIA_READER_CONFIG    ConfigData;
    KEVENT                  GPRAckEvent;
    KEVENT                  GPRIccPresEvent;

    KDPC                    CardDpcObject;
    KTIMER                  CardDetectionTimer;

    UCHAR                   OsVersion;
    USHORT                  Lo;
    UCHAR                   To;
    PUCHAR                  Vo;
    READER_POWER_STATE      ReaderPowerState;
    BOOLEAN                 PowerRequest;
    PDEVICE_OBJECT          AttachedDeviceObject;
    BOOLEAN                 CardPresent;
    // Used to signal that the device has been removed
    KEVENT                  ReaderRemoved; 
    BOOLEAN                 NewDevice;

    KEVENT                  IdleState;
    BOOLEAN                 RestartCardDetection;

 } READER_EXTENSION, *PREADER_EXTENSION, *LPREADER_EXTENSION;


//  DEVICE_EXTENSION:
typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT      DeviceObject;
    PDEVICE_OBJECT      PhysicalDeviceObject;
    PKINTERRUPT         InterruptObject;
    PKSERVICE_ROUTINE   InterruptServiceRoutine;
    KDPC                DpcObject;
    PVOID               IsrContext;
    SMARTCARD_EXTENSION SmartcardExtension;
    UNICODE_STRING      PnPDeviceName;
    LONG                IoCount;
    KSPIN_LOCK          SpinLock;
    BOOLEAN             OpenFlag;
    LONG                PowerState;
    KEVENT              ReaderStarted;
    KEVENT              ReaderClosed;

    // A worker thread to startup GPR gently
    PIO_WORKITEM        GprWorkStartup;
    LONG                DriverFlavor;  // GPR400(default), IBM400 or CPQ400?

    PIRP PowerIrp;
 } DEVICE_EXTENSION, *PDEVICE_EXTENSION, *LPDEVICE_EXTENSION;


//
//  Prototype section:
//
NTSTATUS DriverEntry
(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
);

NTSTATUS GprAddDevice
(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject
);

NTSTATUS GprSystemControl
(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
);

NTSTATUS GprDeviceControl
(
   PDEVICE_OBJECT DeviceObject,
   PIRP Irp
);

NTSTATUS GprCleanup
(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
);

BOOLEAN GprIsr
(
    IN PKINTERRUPT pkInterrupt,
    IN PVOID pvContext
);

NTSTATUS
GprCancelEventWait
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);


VOID GprCardEventDpc
(
    PKDPC               Dpc,
    PDEVICE_OBJECT      DeviceObject,
    PDEVICE_EXTENSION   pDevExt,
    PSMARTCARD_EXTENSION SmartcardExtension
);

VOID GprCardPresenceDpc
(
    IN PKDPC pDpc,
    IN PVOID pvContext,
    IN PVOID pArg1,
    IN PVOID pArg2
);

NTSTATUS GprDispatchPnp
(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
);

NTSTATUS GprCallPcmciaDriver
(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
);

NTSTATUS GprStartDevice
(
    PDEVICE_OBJECT DeviceObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
);


VOID GprStopDevice
( 
    PDEVICE_OBJECT DeviceObject
);

VOID GprUnloadDriver
( 
    PDRIVER_OBJECT DriverObject 
);

VOID GprUnloadDevice
( 
    PDEVICE_OBJECT DeviceObject
);

NTSTATUS GprCreateClose
(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
);

NTSTATUS GprComplete 
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
);
NTSTATUS GprCreateDevice
(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PDEVICE_OBJECT *DeviceObject
);

/*
VOID GprSystemPowerCompletion
(    
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,    
    IN POWER_STATE PowerState,    
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus    
);

NTSTATUS GprDevicePowerCompletion
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
);
*/

VOID GprFinishPendingRequest
( 
    PDEVICE_OBJECT  DeviceObject,
    NTSTATUS        NTStatus
);

VOID GprWorkStartup
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
);

VOID        setBusy(PREADER_EXTENSION Device);
VOID        setIdle(PREADER_EXTENSION Device);
NTSTATUS    waitForIdle(PREADER_EXTENSION Device);
NTSTATUS    waitForIdleAndBlock(PREADER_EXTENSION Device);
NTSTATUS    testForIdleAndBlock(PREADER_EXTENSION Device);


NTSTATUS GprPower
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS power_HandleQueryPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS power_HandleSetPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS    onDevicePowerUpComplete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceObject
    );

NTSTATUS onPowerRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

#define ATTACHED_DEVICE_OBJECT deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ammi.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void 
AMMITestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider AMMITestCard(AMMITestCardEntry);

static ULONG
AMMITestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
AMMITestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PUCHAR l_pbResult;
    UCHAR l_rgbBuffer[512];
	
    // Generate a 'test' pattern which will be written to the card
    for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

        l_rgbBuffer[l_uIndex + 5] = (UCHAR) l_uIndex;             	
    }

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\x00\x10",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Test read of 256 bytes
            ULONG l_uNumBytes = 256;
            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

		    l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xb0\x00\x00\x00",
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                );

            TEST_END();
		    break;         	
        }

	    case 2: {

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\x00\x10",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Test write of 255 bytes
            ULONG l_uNumBytes = 255;
            TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);

            // set the number of bytes we want to write to the card
            memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);

            l_rgbBuffer[4] = (BYTE) l_uNumBytes;

		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                l_uNumBytes + 5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, 0
                );

            TEST_END();
		    break;         	
        }

        case 3: {

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
         	
            TestStart("SELECT FILE EFresult");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\xa0\x00",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x61, 0x15,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY FILE EFresult");

            // apdu for read binary
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes we want to read
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE_HEADER);

            // read in the header of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE_HEADER) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER)], 
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            // get the card reset count
            PT0_RESULT_FILE_HEADER l_pCResultFileHeader;
            l_pCResultFileHeader = (PT0_RESULT_FILE_HEADER) l_pbResult;
            BYTE l_bCardResetCount = l_pCResultFileHeader->CardResetCount;

            // set the offset from where we want to read
            l_rgbBuffer[3] = (BYTE) l_pCResultFileHeader->Offset;
            // Append number of bytes
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE);

            // read in the result data of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE)], 
                l_pbResult[sizeof(T0_RESULT_FILE) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            // Now check the result file. 
            PT0_RESULT_FILE l_pCResultFile = (PT0_RESULT_FILE) l_pbResult;

            // check if the card received a proper PTS
            TestStart("'PTS'");
            TestCheck(
                l_pCResultFile->PTS.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->PTS.Result & 0x01) != 1, 
                "Smart card received not PTS1"
                );
            TEST_END();

            TestStart("'PTS data check'");
            TestCheck(
                l_pCResultFile->PTSDataCheck.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->PTSDataCheck.Result) == 0, 
                "Smart card received incorrect data"
                );
            TEST_END();
            return IFDSTATUS_END;
        }
	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
AMMITestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(AMMITestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(AMMITestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("AMMI");

    // Name of our card
    in_CCardProvider.SetAtr(
        (PBYTE) "\x3b\x7e\x13\x00\x00\x80\x53\xff\xff\xff\x62\x00\xff\x71\xbf\x83\x03\x90\x00", 
        19
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\bull.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include "winsmcrd.h"

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);
                                                                                          
static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{

	ULONG l_auNumBytes[] = { 1 , 25, 50, 75, 100, 125, 150, 175, 200, 225, 254 };
    
     
    ULONG l_uNumBytes = l_auNumBytes[10];
    
	ULONG l_lResult;
    ULONG l_uResultLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
	ULONG l_uTest;
	UCHAR Buf_Tempo[9];
	ULONG l_Tempo;
	ULONG Adresse;

    switch (in_CCardProvider.GetTestNo()) {

        case 1:
            TestStart("Buffer boundary test");

            //
            // Check if the reader correctly determines that
            // our receive buffer is too small
            //
            in_CReader.SetReplyBufferSize(9);
            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x84\x00\x00\x08",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult == ERROR_INSUFFICIENT_BUFFER,
                "Transmit should fail due to too small buffer"
                );

            TestEnd();

            in_CReader.SetReplyBufferSize(2048);
        	break;

	    case 2:			
			TestStart("3 byte APDU");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC4\x00",
				3,										
				&l_pchResult,
				&l_uResultLength
				);

            TestCheck(
                l_lResult, "==", ERROR_INVALID_PARAMETER,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 3:			
			// Get Challenge
			TestStart("GET CHALLENGE");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC4\x00\x00\x08",
				5,										
				&l_pchResult,
				&l_uResultLength
				);

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 10,
                l_pchResult[8], l_pchResult[9], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            //
			// Submit Alternate Identification Code (AID)
	        //
			TestStart("VERIFY PIN");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\x38\x00\x00\x0A\x01\x02\x03\x04\x05\x06\x07\x08\x09\0x0A",
				15,
				&l_pchResult,
				&l_uResultLength
				); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x08,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 4:
			// Translate of 4 byte APDU (Search for next blank word)
			TestStart("SEARCH BLANK WORD");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xA0\x00\x00",		// Search for next blank word
				4,
				&l_pchResult,
				&l_uResultLength
				);
		
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

			// Read result of Search for next blank word
			TestStart("GET RESPONSE");

			l_lResult = in_CReader.Transmit(
				(PUCHAR) "\xBC\xC0\x00\x00\x08",		// Read Result command 
				5,										
				&l_pchResult,
				&l_uResultLength
				);
		
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 10,
                l_pchResult[8], l_pchResult[9], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

    	case 5:	
			// Select Working File 2F01
			TestStart("Lc byte incorrect");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x2F",
				6,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_INVALID_PARAMETER,
                0, 0, 
                0, 0, 0, 0,
                NULL, NULL, NULL
                );

            TEST_END();
            break;

    	case 6:	
            //
			// Select Working File 2F01
            //
			TestStart("SELECT FILE");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x2F\x01",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
			// Erase memory with restart of work waiting time
			TestStart("ERASE BINARY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x0E\x00\x00\x02\x00\x78",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
            // Generate a 'test' pattern which will be written to the card
            for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

                l_rgchBuffer[l_uIndex] = (UCHAR) l_uIndex;             	
            }
			
            // Tpdu for write binary. TB100L can write only 4 byte 4 byte
            memcpy(Buf_Tempo, "\xBC\xD0", 2);	// writting order
			Buf_Tempo[4] = 0x4;					//write 4 bytes in the card
			
            // This is the amount of bytes we write to the card 
            l_uTest = 0;
			Adresse = 0;

			while (l_uTest < 256) {
				
				for(l_Tempo=5 ; l_Tempo < 9; l_Tempo++){

					 Buf_Tempo[l_Tempo] = l_rgchBuffer[l_uTest++];
					 
				 }
					
				 Buf_Tempo[2] = 00;				// Writting address
				 Buf_Tempo[3] = (UCHAR) Adresse++;
			 
			    //
                // Write 
                //
       			TestStart("WRITE BINARY - 4 bytes (%03d)",Adresse);
                            
                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_lResult = in_CReader.Transmit(
                    Buf_Tempo,
                    9,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();
			}
				
			// Read 256 bytes 
			TestStart("READ BINARY - 256 bytes");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xB0\x00\x00\x00",
				5,
                &l_pchResult,
                &l_uResultLength
                );
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 4,
                l_pchResult[256], l_pchResult[257], 0x90, 0x00,
                l_pchResult, l_rgchBuffer , l_uNumBytes + 2
                );

            TEST_END();
			break;

	    case 7:
            //
			// Command with Slave Mode
			// Data bytes transferred subsequently (INS')
            //
	
			TestStart("GENERATE TEMP KEY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x80\x00\x00\x02\x12\x00",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x08,
                NULL, NULL, NULL
                );

            TEST_END();
			break;

	    case 8:
	        // Select Master File 3F00
			TestStart("SELECT FILE");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\xA4\x00\x00\x02\x3F\x00",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			
			// Erase memory on an invalid file => mute card
			TestStart("ERASE BINARY");

			l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xBC\x0E\x00\x00\x02\x00\x78",
				7,
                &l_pchResult,
                &l_uResultLength
                ); 
			
            TestCheck(
                l_lResult, "==", ERROR_SEM_TIMEOUT,
                NULL, NULL, 
                NULL, NULL, 
                NULL, NULL, 
                NULL, NULL, NULL
                );

            TEST_END();
            return IFDSTATUS_END;
	
	    default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;
}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description: 
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("Bull");

    // Maximum number of tests
    in_CCardProvider.SetAtr((PBYTE) "\x3f\x67\x25\x00\x21\x20\x00\x0F\x68\x90\x00", 11);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprnt.c ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name:
   Gprnt.C

Description:
   This is the main module which holds:
      - the main functions for a standard DDK NT  driver
      - the IOCTL functions defined for this driver.

Environment:
   Kernel Mode

Revision History:
    08/10/99: Y. Nadeau
      - Make a version for Compaq PC-CARD Reader.
    06/04/98: (Y. Nadeau M. Veillette)
      - Code review
    18/11/98: V1.00.006  (Y. Nadeau)
      - Add log errors at startup, and Cleanup revised.
    16/10/98: V1.00.005  (Y. Nadeau)
      - Remove DEVICEID in IoCreateDevice (Klaus)
    18/09/98: V1.00.004  (Y. Nadeau)
      - Correction for NT5 beta 3
   06/05/98: V1.00.003  (P. Plouidy)
      - Power management for NT5
   10/02/98: V1.00.002  (P. Plouidy)
      - Plug and Play for NT5
   03/07/97: V1.00.001  (P. Plouidy)
      - Start of development.


--*/

#include <stdio.h>
#include "gprnt.h"
#include "gprcmd.h"
#include "gprelcmd.h"
#include "logmsg.h"

//
// Pragma section
//

#pragma alloc_text (INIT,DriverEntry)
#pragma alloc_text (PAGEABLE,GprAddDevice)
#pragma alloc_text (PAGEABLE,GprCreateDevice)
#pragma alloc_text (PAGEABLE,GprUnloadDevice)
#pragma alloc_text (PAGEABLE,GprUnloadDriver)


#if DBG
#pragma optimize ("",off)
#endif

//
// Constant section
//  - MAX_DEVICES is the maximum number of device supported
//  - POLLING_TIME polling frequency in ms
//
#define MAX_DEVICES   4
#define POLLING_TIME 500


ULONG dataRatesSupported[] = {9909};

//
// Global variable section
// bDeviceSlot is an array of boolean to signal if a device is already created.
//
BOOLEAN bDeviceSlot[GPR_MAX_DEVICE];


NTSTATUS DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
   )
/*++

Routine description:
    This routine is called at system initialization time to initialize
    this driver.
Arguments
   DriverObject - supplies the driver object.
   RegistryPath - supplies the registry path for this driver.
Return Value:

   STATUS_SUCCESS We could initialize at least one device
--*/
{

   SmartcardDebug(
      DEBUG_INFO,
      ("%s!DriverEntry: Enter - %s %s\n",
      SC_DRIVER_NAME,
      __DATE__,
      __TIME__)
      );

    //   Initialization of the Driver Object with driver's entry points.
    DriverObject->DriverUnload               = GprUnloadDriver;
    DriverObject->DriverExtension->AddDevice = GprAddDevice;

    DriverObject->MajorFunction[IRP_MJ_PNP]     = GprDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_CREATE]  = GprCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   = GprCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = GprCleanup;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = GprPower;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]   = GprDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]   = GprSystemControl;

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!DriverEntry: Exit\n",
      SC_DRIVER_NAME)
      );
   return (STATUS_SUCCESS);
}


NTSTATUS GprAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
   )
/*++

Routine Description:
   Add device routine

Arguments
   DriverObject point to the driver object.
   PhysicalDeviceObject point to the PDO for the pnp device added

Return Value:
   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES
*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    ANSI_STRING DeviceID;

   PAGED_CODE();
   ASSERT(DriverObject != NULL);
   ASSERT(PhysicalDeviceObject != NULL);

   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GprAddDevice: Enter\n",
      SC_DRIVER_NAME)
      );

   __try
    {
        PDEVICE_EXTENSION DeviceExtension;
        LONG DeviceIdLength;
      //
      // try to create the device
      //
      NTStatus = GprCreateDevice(
            DriverObject,
            PhysicalDeviceObject,
            &DeviceObject
            );

      if (NTStatus != STATUS_SUCCESS)
        {
         SmartcardDebug(
            DEBUG_ERROR,
            ( "%s!GprAddDevice: GprCreateDevice=%X(hex)\n",
            SC_DRIVER_NAME,
            NTStatus)
            );
            __leave;
      }
      //
      // Attach the physicalDeviceObject to the new created device
      //

      DeviceExtension = DeviceObject->DeviceExtension;

      DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject = IoAttachDeviceToDeviceStack(
         DeviceObject,
         PhysicalDeviceObject
         );

      ASSERT(DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject != NULL);

      if (DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject == NULL)
        {
            NTStatus = STATUS_UNSUCCESSFUL;
            __leave;
        }

      //
      // Register the new device object
      //
      NTStatus = IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            &SmartCardReaderGuid,
            NULL,
            &DeviceExtension->PnPDeviceName
            );

        RtlUnicodeStringToAnsiString(&DeviceID, &DeviceExtension->PnPDeviceName, TRUE);

        DeviceIdLength = (LONG) RtlCompareMemory(DeviceID.Buffer, COMPAQ_ID, CHECK_ID_LEN);

        SmartcardDebug( 
            DEBUG_ERROR, 
            ( "%s!GprAddDevice: DeviceIdLength = %d, PnPDeviceName=%s\n",
            SC_DRIVER_NAME, DeviceIdLength, DeviceID.Buffer)
            );

        // it's a DeviceID of COMPAQ ?
        if( DeviceIdLength == CHECK_ID_LEN)
        {
            SmartcardDebug(
                DEBUG_INFO,
                ( "%s!GprAddDevice: Compaq reader detect!\n",
                SC_DRIVER_NAME)
                );

            DeviceExtension->DriverFlavor = DF_CPQ400;
        }

        //  Initialize the vendor information.
        //  Driver flavor
        // 
        switch (DeviceExtension->DriverFlavor)
        {
        case DF_IBM400:
            // IBM IBM400
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
                SZ_VENDOR_NAME_IBM, sizeof(SZ_VENDOR_NAME_IBM));
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
                SZ_READER_NAME_IBM, sizeof(SZ_READER_NAME_IBM));
            DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Length = sizeof(SZ_VENDOR_NAME_IBM);
            DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Length = sizeof(SZ_READER_NAME_IBM);
            break;
        case DF_CPQ400:
            // COMPAQ PC_CARD_SMARTCARD_READER
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
                SZ_VENDOR_NAME_COMPAQ, sizeof(SZ_VENDOR_NAME_COMPAQ));
            RtlCopyMemory(DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
                SZ_READER_NAME_COMPAQ, sizeof(SZ_READER_NAME_COMPAQ));
            DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Length = sizeof(SZ_VENDOR_NAME_COMPAQ);
            DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Length = sizeof(SZ_READER_NAME_COMPAQ);
            break;
        default:
            // Gemplus GPR400
            break;
        }

        SmartcardDebug(
            DEBUG_INFO,
            ( "%s!GprAddDevice: DriverFlavor VendorName:%s  IfdType:%s UnitNo:%d\n",
            SC_DRIVER_NAME,
            DeviceExtension->SmartcardExtension.VendorAttr.VendorName.Buffer,
            DeviceExtension->SmartcardExtension.VendorAttr.IfdType.Buffer,
            DeviceExtension->SmartcardExtension.VendorAttr.UnitNo)
            );

        RtlFreeAnsiString(&DeviceID);

        ASSERT(NTStatus == STATUS_SUCCESS);

        DeviceObject->Flags |= DO_BUFFERED_IO;
        DeviceObject->Flags |= DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   }
   __finally
    {
        if (NTStatus != STATUS_SUCCESS)
        {
            GprUnloadDevice(DeviceObject);
        }
   }

   SmartcardDebug(
        DEBUG_DRIVER,
        ( "%s!GprAddDevice: Exit =%X(hex)\n",
        SC_DRIVER_NAME,
        NTStatus)
        );

   return NTStatus;
}


NTSTATUS GprCreateDevice(
   IN  PDRIVER_OBJECT DriverObject,
   IN PDEVICE_OBJECT PhysicalDeviceObject,
   OUT PDEVICE_OBJECT *DeviceObject
   )
/*++

Routine description:
   This routine creates an object for the physical device specified
   and sets up the deviceExtension

Arguments:
   DriverObject   context of call
   DeviceObject   ptr to the created device object

Return value:
   STATUS_SUCCESS
--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG DeviceInstance;
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;

   PAGED_CODE();
   ASSERT(DriverObject != NULL);
   ASSERT(PhysicalDeviceObject != NULL);

   *DeviceObject = NULL;

   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GprCreateDevice: Enter\n",
      SC_DRIVER_NAME)
      );

   __try
    {
        for( DeviceInstance = 0; DeviceInstance < GPR_MAX_DEVICE; DeviceInstance++ )
        {
            if (bDeviceSlot[DeviceInstance] == FALSE)
            {
                bDeviceSlot[DeviceInstance] = TRUE;
                break;
            }
        }


      // Create the device object
      NTStatus = IoCreateDevice(
         DriverObject,
         sizeof(DEVICE_EXTENSION),
         NULL,
         FILE_DEVICE_SMARTCARD,
         0,
         TRUE,
         DeviceObject
         );

        if (NTStatus != STATUS_SUCCESS)
        {
           SmartcardDebug(
                DEBUG_ERROR,
                ( "%s!GprCreateDevice: IoCreateDevice status=%X(hex)\n",
                SC_DRIVER_NAME,
                NTStatus)
                );

            SmartcardLogError(
                DriverObject,
                GEMSCR0D_ERROR_CLAIM_RESOURCES,
                NULL,
                0
                );

            __leave;
        }
        ASSERT(DeviceObject != NULL);

        // set up the device extension.
        DeviceExtension = (*DeviceObject)->DeviceExtension;

        ASSERT(DeviceExtension != NULL);

        SmartcardExtension = &DeviceExtension->SmartcardExtension;

      // allocate the reader extension
      SmartcardExtension->ReaderExtension = ExAllocatePool(
         NonPagedPool,
         sizeof( READER_EXTENSION ),
         );

      if( SmartcardExtension->ReaderExtension == NULL )
        {

         SmartcardLogError(
            DriverObject,
            GEMSCR0D_ERROR_CLAIM_RESOURCES,
            NULL,
            0
            );

            SmartcardDebug(
                DEBUG_ERROR,
                ( "%s!GprCreateDevice: ReaderExtension failed %X(hex)\n",
                SC_DRIVER_NAME,
                NTStatus )
                );


         NTStatus = STATUS_INSUFFICIENT_RESOURCES;
         __leave;
      }

      RtlZeroMemory(
            SmartcardExtension->ReaderExtension,
            sizeof( READER_EXTENSION )
            );

      // allocate the Vo Buffer
      SmartcardExtension->ReaderExtension->Vo = ExAllocatePool(
         NonPagedPool,
         GPR_BUFFER_SIZE
         );

      if( SmartcardExtension->ReaderExtension->Vo == NULL )
        {

            SmartcardLogError(
                DriverObject,
                GEMSCR0D_ERROR_CLAIM_RESOURCES,
                NULL,
                0
                );

            SmartcardDebug(
                DEBUG_ERROR,
                ( "%s!GprCreateDevice: Vo buffer failed %X(hex)\n",
                SC_DRIVER_NAME,
                NTStatus )
                );


            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        RtlZeroMemory(
            SmartcardExtension->ReaderExtension->Vo,
            GPR_BUFFER_SIZE
            );

        // Used for device removal notification
        KeInitializeEvent(
            &(SmartcardExtension->ReaderExtension->ReaderRemoved),
            NotificationEvent,
            FALSE
            );

        //
        // GPR400 acknowledge event initialization
        //
        KeInitializeEvent(
            &(SmartcardExtension->ReaderExtension->GPRAckEvent),
            SynchronizationEvent,
            FALSE
            );

        KeInitializeEvent(
            &(SmartcardExtension->ReaderExtension->GPRIccPresEvent),
            SynchronizationEvent,
            FALSE
            );

        // Setup the DPC routine to be called after the ISR completes.
        KeInitializeDpc(
            &DeviceExtension->DpcObject,
            GprCardEventDpc,
            *DeviceObject                 // should be DeviceExtension
            );

        // Card presence polling DPC routine initialization
        KeInitializeDpc(
            &SmartcardExtension->ReaderExtension->CardDpcObject,
            GprCardPresenceDpc,
            DeviceExtension
            );

        // Initialization of the card detection timer
        KeInitializeTimer(
            &(SmartcardExtension->ReaderExtension->CardDetectionTimer)
            );

        // This event signals Start/Stop notification
        KeInitializeEvent(
            &DeviceExtension->ReaderStarted,
            NotificationEvent,
            FALSE
            );

        // Used to keep track of open calls
        KeInitializeEvent(
            &DeviceExtension->ReaderClosed,
            NotificationEvent,
            TRUE
            );

        // Used to keep track of open calls
        KeInitializeEvent(
            &SmartcardExtension->ReaderExtension->IdleState,
            SynchronizationEvent,
            TRUE
            );

        SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;

        // void function, This routine must be called
        // before an initial call to KeAcquireSpinLock
        KeInitializeSpinLock(&DeviceExtension->SpinLock);

      // This worker thread is use to start de GPR in Power mode
      DeviceExtension->GprWorkStartup = IoAllocateWorkItem(
         *DeviceObject
         );
      if( DeviceExtension->GprWorkStartup == NULL )
        {
            SmartcardLogError(
                DriverObject,
                GEMSCR0D_ERROR_CLAIM_RESOURCES,
                NULL,
                0
                );

            SmartcardDebug(
                DEBUG_ERROR,
                ( "%s!GprCreateDevice: GprWorkStartup failed %X(hex)\n",
                SC_DRIVER_NAME,
                NTStatus )
                );


            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        // Now setup information in our deviceExtension.
        SmartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;
        SmartcardExtension->ReaderCapabilities.MechProperties = 0;

        // enter correct version of the lib
        SmartcardExtension->Version = SMCLIB_VERSION;

        // Setup the Smartcard support functions that we implement.
        SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =    GprCbReaderPower;
        SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =      GprCbTransmit;
        SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  GprCbSetProtocol;
        SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] =   GprCbSetupCardTracking;
        SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  GprCbVendorIoctl;

        DeviceExtension->PowerState = PowerDeviceD0;

        //  Initialize the vendor information.
        strcpy(SmartcardExtension->VendorAttr.VendorName.Buffer, SC_VENDOR_NAME);
        strcpy(SmartcardExtension->VendorAttr.IfdType.Buffer, SC_IFD_TYPE);

        SmartcardExtension->VendorAttr.VendorName.Length = (USHORT)strlen(SC_VENDOR_NAME);
        SmartcardExtension->VendorAttr.IfdType.Length =  (USHORT)strlen(SC_IFD_TYPE);
        SmartcardExtension->VendorAttr.UnitNo = DeviceInstance;

        DeviceExtension->DriverFlavor = DF_GPR400;
        //
        // Reader capabilities:
        // - the type of the reader (SCARD_READER_TYPE_PCMCIA)
        // - the protocols supported by the reader (SCARD_PROTOCOL_T0, SCARD_PROTOCOL_T1)
        // - the mechanical characteristic of the reader:
        // Verify if the reader can supports the detection of the card
        // insertion/removal. Only the main reader supports this functionnality.
        // - the default clock frequency
        // - the maximum clock frequency
        // - the default data rate
        // - the maximum data rate
        // - the maximum IFSD
        //
        SmartcardExtension->ReaderCapabilities.ReaderType =
            SCARD_READER_TYPE_PCMCIA;
        SmartcardExtension->ReaderCapabilities.SupportedProtocols =
            SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;
        SmartcardExtension->ReaderCapabilities.Channel              = DeviceInstance;
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = GPR_DEFAULT_FREQUENCY;
        SmartcardExtension->ReaderCapabilities.CLKFrequency.Max     = GPR_MAX_FREQUENCY;
        SmartcardExtension->ReaderCapabilities.MaxIFSD              = GPR_MAX_IFSD;
        SmartcardExtension->ReaderCapabilities.DataRate.Default     = GPR_DEFAULT_DATARATE;
        SmartcardExtension->ReaderCapabilities.DataRate.Max         = GPR_MAX_DATARATE;
        //
        // Reader capabilities (continue):
        // - List all the supported data rates
        //
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
            dataRatesSupported;
        SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
            sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);

        //
        //  Reader Extension:
        //- the command timeout for the reader (GPR_DEFAULT_TIME)
        //
        SmartcardExtension->ReaderExtension->CmdTimeOut     = GPR_DEFAULT_TIME;
        SmartcardExtension->ReaderExtension->PowerTimeOut   = GPR_DEFAULT_POWER_TIME;

        //
        // Flag will prevent completion of the request
        // when the system will be waked up again.
        //
        SmartcardExtension->ReaderExtension->PowerRequest   = FALSE;

        //
        // Flag to know we strating a new device, not an hibernation mode.
        //
        SmartcardExtension->ReaderExtension->NewDevice  = TRUE;

        SmartcardExtension->SmartcardRequest.BufferSize = MIN_BUFFER_SIZE;
        SmartcardExtension->SmartcardReply.BufferSize   = MIN_BUFFER_SIZE;

        NTStatus = SmartcardInitialize(SmartcardExtension);

      if (NTStatus != STATUS_SUCCESS)
        {
            SmartcardLogError(
                DriverObject,
                GEMSCR0D_ERROR_CLAIM_RESOURCES,
                NULL,
                0
                );
            SmartcardDebug(
                DEBUG_ERROR,
                ( "%s!GprCreateDevice: SmartcardInitialize failed %X(hex)\n",
                SC_DRIVER_NAME,
                NTStatus )
                );

            __leave;
        }

        //
        // tell the lib our device object & create
        // symbolic link
        //
        SmartcardExtension->OsData->DeviceObject = *DeviceObject;

        // save the current power state of the reader
        SmartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderWorking;
    }
    __finally
    {
        if (NTStatus != STATUS_SUCCESS)
        {
            // Do the driver unload in the calling function.
        }

        SmartcardDebug(
            DEBUG_DRIVER,
            ( "%s!GprCreateDevice: Exit %X(hex)\n",
            SC_DRIVER_NAME,
            NTStatus )
            );
    }
    return NTStatus;
}


NTSTATUS GprStartDevice(
   PDEVICE_OBJECT DeviceObject,
   PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
   )
/*++
Routine Description
   get the actual configuration from the passed FullResourceDescriptor
   and initializes the reader hardware

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptor;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION pSCardExt = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION pReaderExt = pSCardExt->ReaderExtension;
    NTSTATUS NTStatus = STATUS_SUCCESS;
    ULONG Count;
    PCMCIA_READER_CONFIG *pConfig = NULL;


    ASSERT(DeviceObject != NULL);
    ASSERT(FullResourceDescriptor != NULL);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprStartDevice: Enter \n",
      SC_DRIVER_NAME)
      );

   // Get the number of resources we need
   Count = FullResourceDescriptor->PartialResourceList.Count;

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprStartDevice: Resource Count = %d\n",
      SC_DRIVER_NAME,
      Count)
      );

   PartialDescriptor = FullResourceDescriptor->PartialResourceList.PartialDescriptors;

   pConfig = &(pReaderExt->ConfigData);
   //
   // parse all partial descriptors
   //

   while(Count--)
    {
      switch(PartialDescriptor->Type)
        {
         case CmResourceTypePort:
            {
            //
            // 0 - memory, 1 - IO
            //
            ULONG AddressSpace = 1;

            pReaderExt->BaseIoAddress =
               (PGPR400_REGISTERS) UlongToPtr(PartialDescriptor->u.Port.Start.LowPart);

            ASSERT(PartialDescriptor->u.Port.Length >= 4);


            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!GprStartDevice: IoBase = %lxh\n",
               SC_DRIVER_NAME,
               pReaderExt->BaseIoAddress)
               );
            break;
            }

         case CmResourceTypeInterrupt:
            {
            KINTERRUPT_MODE   Mode;
            BOOLEAN  Shared;

            Mode = (
               PartialDescriptor->Flags &
               CM_RESOURCE_INTERRUPT_LATCHED ?
               Latched : LevelSensitive
               );

            Shared = (
               PartialDescriptor->ShareDisposition ==
               CmResourceShareShared
               );

            pConfig->Vector = PartialDescriptor->u.Interrupt.Vector;
            pConfig->Affinity = PartialDescriptor->u.Interrupt.Affinity;
            pConfig->Level = (KIRQL) PartialDescriptor->u.Interrupt.Level;

                //
                // store IRQ to allow query configuration
                //
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!GprStartDevice: Irq Vector: %d\n",
                    SC_DRIVER_NAME,
                    PartialDescriptor->u.Interrupt.Vector)
                    );
                DeviceExtension->InterruptServiceRoutine = GprIsr;
                DeviceExtension->IsrContext = DeviceExtension;
                //
                //connect the driver's isr
                //
                NTStatus = IoConnectInterrupt(
                    &DeviceExtension->InterruptObject,
                    DeviceExtension->InterruptServiceRoutine,
                    DeviceExtension->IsrContext,
                    NULL,
                    pConfig->Vector,
                    pConfig->Level,
                    pConfig->Level,
                    Mode,
                    Shared,
                    pConfig->Affinity,
                    FALSE
                    );

                break;
            }
         default:
            NTStatus = STATUS_UNSUCCESSFUL;
            break;
      }
      PartialDescriptor++;
   }

   __try
    {
      //
      // IOBase initialized ?
      //
      if( pReaderExt->BaseIoAddress == NULL )
        {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprStartDevice: No IO \n",
                SC_DRIVER_NAME)
                );
            //
            // under NT 4.0 the failure of this fct for the second reader
            // means there is only one device
            //
            SmartcardLogError(
                DeviceObject,
                GEMSCR0D_ERROR_IO_PORT,
                NULL,
                0
                );

            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
      }
        //
        // irq connected ?
        //
        if( DeviceExtension->InterruptObject == NULL )
        {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprStartDevice: No Irq \n",
                SC_DRIVER_NAME)
                );

            SmartcardLogError(
                DeviceObject,
                GEMSCR0D_ERROR_INTERRUPT,
                NULL,
                0
                );

            NTStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        // YN
        //
        // GPR400 Check Hardware
        //
        NTStatus = IfdCheck(pSCardExt);

        if (NTStatus != STATUS_SUCCESS)
        {
            SmartcardDebug( 
                DEBUG_INFO, 
                ("%s!GprStartDevice: ####### Reader is at bad state...\n",
                SC_DRIVER_NAME)
                );

            SmartcardLogError(
                DeviceObject,
                GEMSCR0D_UNABLE_TO_INITIALIZE,
                NULL,
                0
                );
            
            // Unblock reader
            KeClearEvent(&pReaderExt->ReaderRemoved);
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

            __leave;
        }

        // StartGpr in a worker thread.
        IoQueueWorkItem(
            DeviceExtension->GprWorkStartup,
            (PIO_WORKITEM_ROUTINE) GprWorkStartup,
            DelayedWorkQueue,
            NULL
            );
        //
        // Put interface here
        //
        NTStatus = IoSetDeviceInterfaceState(
            &DeviceExtension->PnPDeviceName,
            TRUE
            );

        // signal that the reader has been started have been put
        // in the worker thread.
        //KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
    }
    __finally
    {
        if (!NT_SUCCESS(NTStatus))
        {
            DeviceExtension->OpenFlag = FALSE;
            GprStopDevice(DeviceObject);
        }

      SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!GprStartDevice: Exit %X(hex)\n",
         SC_DRIVER_NAME,
         NTStatus)
         );
    }
      return NTStatus;
}


VOID GprStopDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

  Routine Description
   Disconnect the interrupt used by the device & unmap the IO port

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION pSCardExt = NULL;

   ASSERT(DeviceObject != NULL);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprStopDevice: Enter \n",
      SC_DRIVER_NAME)
      );

   DeviceExtension = DeviceObject->DeviceExtension;
   pSCardExt = &(DeviceExtension->SmartcardExtension);

   //
   // disconnect the interrupt
   //
   if( DeviceExtension->InterruptObject != NULL )
    {
      IoDisconnectInterrupt(DeviceExtension->InterruptObject);
      DeviceExtension->InterruptObject = NULL;
   }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprStopDevice: Exit \n",
      SC_DRIVER_NAME)
      );
}

NTSTATUS
GprSystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
   
   PDEVICE_EXTENSION DeviceExtension; 
   PSMARTCARD_EXTENSION SmartcardExtension; 
   PREADER_EXTENSION ReaderExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(ReaderExtension->AttachedDeviceObject, Irp);
      
   return status;

} 



NTSTATUS GprDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
   )
/*++

Routine description
   this is the IOCTL dispatch function
--*/
{

   PDEVICE_EXTENSION DeviceExtension = NULL;
   PSMARTCARD_EXTENSION SmartcardExtension = NULL;
   NTSTATUS NTStatus = STATUS_SUCCESS;
   LARGE_INTEGER Timeout;
   KIRQL irql;

   ASSERT(DeviceObject != NULL);
   ASSERT(Irp != NULL);

   DeviceExtension = DeviceObject->DeviceExtension;
   ASSERT(DeviceExtension != NULL);

   SmartcardExtension = &(DeviceExtension->SmartcardExtension);
   ASSERT(SmartcardExtension != NULL);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprDeviceControl: Enter\n",SC_DRIVER_NAME));


   KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);

   if(DeviceExtension->IoCount == 0)
   {

      KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);
      NTStatus = KeWaitForSingleObject(
         &DeviceExtension->ReaderStarted,
         Executive,
         KernelMode,
         FALSE,
         NULL);

      ASSERT(NTStatus == STATUS_SUCCESS);
      KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);
   }

   ASSERT(DeviceExtension->IoCount >= 0);
   DeviceExtension->IoCount++;
   KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);

   Timeout.QuadPart = 0;

   NTStatus = KeWaitForSingleObject(
      &(SmartcardExtension->ReaderExtension->ReaderRemoved),
      Executive,
      KernelMode,
      FALSE,
      &Timeout
      );

   if (NTStatus == STATUS_SUCCESS)
   {
      NTStatus = STATUS_DEVICE_REMOVED;
   }
   else
   {
      // Remove before doing the card detection
      //NTStatus = SmartcardAcquireRemoveLock(SmartcardExtension);
      NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'tcoI');

      // Cancel the card detection timer
      if( ! KeReadStateTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer)))
      {
         // Prevent restarting timer by sync functions
         KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
      }

      AskForCardPresence(SmartcardExtension);
      Timeout.QuadPart = -(100 * POLLING_TIME);

      KeWaitForSingleObject(
         &(DeviceExtension->SmartcardExtension.ReaderExtension->GPRIccPresEvent),
         Executive,
         KernelMode,
         FALSE,
         &Timeout
         );
   }

   if(NTStatus != STATUS_SUCCESS)
   {
      // The device has been removed. Fail the call
      KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);
      DeviceExtension->IoCount--;
      KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
      NTStatus = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp,IO_NO_INCREMENT);
      SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!GprDeviceControl: Exit %x\n"
         ,SC_DRIVER_NAME
         ,NTStatus)
         );
      return(STATUS_DEVICE_REMOVED);
   }

   ASSERT(DeviceExtension->SmartcardExtension.ReaderExtension->ReaderPowerState ==
        PowerReaderWorking);

   NTStatus = SmartcardDeviceControl(
      &DeviceExtension->SmartcardExtension,
      Irp
      );

    //   Restart the card detection timer
   Timeout.QuadPart = -(10000 * POLLING_TIME);
   KeSetTimer(
      &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
      Timeout,
      &SmartcardExtension->ReaderExtension->CardDpcObject
      );

   //SmartcardReleaseRemoveLock(SmartcardExtension);
   SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'tcoI');

   KeAcquireSpinLock(&DeviceExtension->SpinLock,&irql);

   DeviceExtension->IoCount--;
   ASSERT(DeviceExtension->IoCount >= 0);

   KeReleaseSpinLock(&DeviceExtension->SpinLock,irql);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprDeviceControl: Exit %x\n"
      ,SC_DRIVER_NAME
      ,NTStatus)
      );

   return (NTStatus);
}


VOID GprFinishPendingRequest(
   PDEVICE_OBJECT DeviceObject,
   NTSTATUS    NTStatus
   )
/*++

Routine Description :

   finishes a pending tracking request if the interrupt is served or the device
   will be unloaded

Arguments
   DeviceObject   context of the request
   NTStatus    status to report to the calling process

Return Value

  STATUS_SUCCESS
--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    KIRQL CurrentIrql;
    PIRP PendingIrp;

    ASSERT(DeviceObject != NULL);


   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;

   if( SmartcardExtension->OsData->NotificationIrp != NULL )
    {
        SmartcardDebug(
            DEBUG_DRIVER,
            ( "%s!GprFinishPendingRequest: Completing Irp %lx\n",
            SC_DRIVER_NAME,
            SmartcardExtension->OsData->NotificationIrp)
            );

        PendingIrp = SmartcardExtension->OsData->NotificationIrp;

        IoAcquireCancelSpinLock( &CurrentIrql );
        IoSetCancelRoutine( PendingIrp, NULL );
        IoReleaseCancelSpinLock( CurrentIrql );
        //
        // finish the request
        //
        PendingIrp->IoStatus.Status = NTStatus;
        PendingIrp->IoStatus.Information = 0;

        IoCompleteRequest(PendingIrp, IO_NO_INCREMENT );
        //
        // reset the tracking context to enable tracking
        //
        SmartcardExtension->OsData->NotificationIrp = NULL;
    }
}


NTSTATUS GprCallPcmciaDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description :

   Send an Irp to the pcmcia driver and wait until the pcmcia driver has
   finished the request.

   To make sure that the pcmcia driver will not complete the Irp we first
   initialize an event and set our own completion routine for the Irp.

   When the pcmcia driver has processed the Irp the completion routine will
   set the event and tell the IO manager that more processing is required.

   By waiting for the event we make sure that we continue only if the pcmcia
   driver has processed the Irp completely.

Arguments
   DeviceObject   context of call
   Irp            Irp to send to the pcmcia driver

Return Value
   status returned by the pcmcia driver
--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KEVENT Event;

   ASSERT(DeviceObject != NULL);
   ASSERT(Irp != NULL);

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // initialize an event for process synchronization. the event is passed
    // to our completion routine and will be set if the pcmcia driver is done
    //
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    //
    // Our IoCompletionRoutine sets only our event
    //
    IoSetCompletionRoutine (
        Irp,
        GprComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the pcmcia driver
    //
    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER)
    {
        NTStatus = PoCallDriver(
            DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject,
            Irp
            );
    }
    else
    {
        NTStatus = IoCallDriver(
            DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject,
            Irp
            );
    }

    //
    // Wait until the pcmcia driver has processed the Irp
    //
    if (NTStatus == STATUS_PENDING)
    {
        NTStatus = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        if (NTStatus == STATUS_SUCCESS)
        {
            NTStatus = Irp->IoStatus.Status;
        }
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCallPcmciaDriver: Exit %x\n",
        SC_DRIVER_NAME,
        NTStatus)
        );

    return NTStatus;
}


NTSTATUS GprComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++
Routine Description:
   Completion routine for an Irp sent to the pcmcia driver. The event will
   be set to notify that the pcmcia driver is done. The routine will not
   'complete' the Irp, so the caller of GprCallPcmciaDriver can continue.

Arguments:
   DeviceObject   context of call
   Irp            Irp to complete
   Event       Used by GprCallPcmciaDriver for process synchronization

Return Value

   STATUS_CANCELLED              Irp was cancelled by the IO manager
   STATUS_MORE_PROCESSING_REQUIRED     Irp will be finished by caller of
                              GprCallPcmciaDriver
--*/
{
   UNREFERENCED_PARAMETER (DeviceObject);

   ASSERT(Irp != NULL);
   ASSERT(Event != NULL);


    if (Irp->Cancel)
    {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }
//    else
//    {
//        Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
//    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS GprDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
   )
/*++

Routine Description
   driver callback for pnp manager
   Request:             Action:

   IRP_MN_START_DEVICE        Notify the pcmcia driver about the new device
                        and start the device

   IRP_MN_STOP_DEVICE         Free all resources used by the device and tell
                        the pcmcia driver that the device was stopped

   IRP_MN_QUERY_REMOVE_DEVICE If the device is opened (i.e. in use) an error will
                        be returned to prevent the PnP manager to stop
                        the driver

   IRP_MN_CANCEL_REMOVE_DEVICE   just notify that we can continue without any
                        restrictions

   IRP_MN_REMOVE_DEVICE    notify the pcmcia driver that the device was
                        removed, stop & unload the device

   All other requests will be passed to the pcmcia driver to ensure correct processing.

Arguments:
   Device Object  context of call
   Irp            irp from the PnP manager

Return value

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   status returned by pcmcia driver
--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = NULL;
    PIO_STACK_LOCATION IrpStack;              
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;
    LARGE_INTEGER Timeout;

   ASSERT(DeviceObject != NULL);
   ASSERT(Irp != NULL);

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprDispatchPnp: Enter\n",
        SC_DRIVER_NAME)
        );

    smartcardExtension = &(DeviceExtension->SmartcardExtension);
    //NTStatus = SmartcardAcquireRemoveLock(smartcardExtension);
    NTStatus = SmartcardAcquireRemoveLockWithTag(smartcardExtension, ' PnP');

    ASSERT(NTStatus == STATUS_SUCCESS);
    if (NTStatus != STATUS_SUCCESS)
    {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = NTStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return NTStatus;
    }


//   Irp->IoStatus.Information = 0;
   IrpStack = IoGetCurrentIrpStackLocation(Irp);
    Timeout.QuadPart = 0;


   //
   // Now look what the PnP manager wants...
   //
    switch(IrpStack->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            //
            // Now we should connect to our resources (Irql, Io etc.)
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_START_DEVICE\n",
                SC_DRIVER_NAME)
                );

            //
            // We have to call the underlying driver first
            //
            NTStatus = GprCallPcmciaDriver(
                DeviceObject,
                Irp
                );

            ASSERT(NT_SUCCESS(NTStatus));

            if (NT_SUCCESS(NTStatus))
            {
                NTStatus = GprStartDevice(
                    DeviceObject,
                    &IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]
                    );
            }
            break;
        case IRP_MN_QUERY_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnP: IRP_MN_QUERY_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

            KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
            if (DeviceExtension->IoCount > 0)
            {
                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                NTStatus = STATUS_DEVICE_BUSY;

            }
            else
            {
                // stop processing requests
                KeClearEvent(&DeviceExtension->ReaderStarted);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                    NTStatus = GprCallPcmciaDriver(
                    DeviceObject,
                    Irp
                    );
            }
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnP: IRP_MN_CANCEL_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

            NTStatus = GprCallPcmciaDriver(
                DeviceObject,
                Irp
                );

            if (NTStatus == STATUS_SUCCESS)
            {
                // we can continue to process requests
                KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
            }
            break;

        case IRP_MN_STOP_DEVICE:
            //
            // Stop the device.
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_STOP_DEVICE\n",
                SC_DRIVER_NAME)
                );

            GprStopDevice(DeviceObject);

            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            // Remove our device
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_QUERY_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

            // disable the reader
            NTStatus = IoSetDeviceInterfaceState(
                &DeviceExtension->PnPDeviceName,
                FALSE
                );

            SmartcardDebug(
                DEBUG_TRACE,
                ("%s!GprDispatchPnp: Set Pnp Interface state to FALSE, status=%x\n",
                SC_DRIVER_NAME,
                NTStatus)
                );
            if (NTStatus != STATUS_SUCCESS)
            {
                break;
            }

            //
            // check if the reader has been opened
            // Note: This call only checks and does NOT wait for a close
            //
            Timeout.QuadPart = 0;

            NTStatus = KeWaitForSingleObject(
                &DeviceExtension->ReaderClosed,
                Executive,
                KernelMode,
                FALSE,
                &Timeout
                );

            if (NTStatus == STATUS_TIMEOUT)
            {
                // someone is connected, enable the reader and fail the call
                IoSetDeviceInterfaceState(
                    &DeviceExtension->PnPDeviceName,
                    TRUE
                    );
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GprDispatchPnp: Set Pnp Interface state to TRUE\n",
                    SC_DRIVER_NAME)
                    );

                NTStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            // pass the call to the next driver in the stack
            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // Removal of device has been cancelled
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
            if (NTStatus == STATUS_SUCCESS)
            {
                NTStatus = IoSetDeviceInterfaceState(
                    &DeviceExtension->PnPDeviceName,
                    TRUE
                    );
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("%s!GprDispatchPnp: Set Pnp Interface state to TRUE, status=%s\n",
                    SC_DRIVER_NAME,
                    NTStatus)
                    );
            }
            break;

        case IRP_MN_REMOVE_DEVICE:

            //
            // Remove our device
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_REMOVE_DEVICE\n",
                SC_DRIVER_NAME)
                );

            KeSetEvent(&(smartcardExtension->ReaderExtension->ReaderRemoved), 0, FALSE);

            GprStopDevice(DeviceObject);

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: call pcmcia\n",
                SC_DRIVER_NAME,
            NTStatus)
                );

            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: Finish with unload driver\n",
                SC_DRIVER_NAME,
            NTStatus)
                );

            GprUnloadDevice(DeviceObject);

            deviceRemoved = TRUE;
            break;

        case IRP_MN_SURPRISE_REMOVAL:

            //
            // Unexpectedly removed our Reader
            //
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDispatchPnp: IRP_MN_SURPRISE_REMOVAL\n",
                SC_DRIVER_NAME)
                );
            if( DeviceExtension->InterruptObject != NULL )
            {
               IoDisconnectInterrupt(DeviceExtension->InterruptObject);
               DeviceExtension->InterruptObject = NULL;
            }


            KeSetEvent(&(smartcardExtension->ReaderExtension->ReaderRemoved), 0, FALSE);

            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);

            break;

        default:
            // This might be an Irp that is only useful
            // for the underlying bus driver
            NTStatus = GprCallPcmciaDriver(DeviceObject, Irp);
            irpSkipped = TRUE;
            break;
   }

    if(!irpSkipped) {
      Irp->IoStatus.Status = NTStatus;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    if (deviceRemoved == FALSE)
    {
        SmartcardReleaseRemoveLockWithTag(smartcardExtension, ' PnP');
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprDispatchPnp: Exit %x\n",
        SC_DRIVER_NAME,
        NTStatus)
        );
    return NTStatus;
}


BOOLEAN GprIsr(
    IN PKINTERRUPT pkInterrupt,
    IN PVOID pvContext
   )
/*++

Routine Description

  Interrupt Service routine called when an exchange has been processed by the GPR

--*/
{
    PDEVICE_EXTENSION DeviceExtension = NULL;

    ASSERT(pvContext != NULL);

    DeviceExtension = (PDEVICE_EXTENSION) pvContext;

   //
   //Request a DPC which will complete the pending User I/O Request
   //Packet (aka, IRP), if there is one.
   //
   KeInsertQueueDpc(
      &DeviceExtension->DpcObject,
      DeviceExtension,
        &DeviceExtension->SmartcardExtension
      );
    return (TRUE);
}


NTSTATUS GprCleanup(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   )
/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
    NTSTATUS NTStatus = STATUS_SUCCESS;

   ASSERT(DeviceObject != NULL);
   ASSERT(Irp != NULL);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCleanUp: Enter\n",
        SC_DRIVER_NAME)
        );

    IoAcquireCancelSpinLock(&(Irp->CancelIrql));

    if (SmartcardExtension->OsData->NotificationIrp)
    {
        // We need to complete the notification irp
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp,
            NULL
            );

        GprCancelEventWait(
            DeviceObject,
            SmartcardExtension->OsData->NotificationIrp
            );
    }
    else
    {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCleanUp: Completing IRP %lx\n",
        SC_DRIVER_NAME,
        Irp)
        );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCleanUp: IoCompleteRequest\n",
        SC_DRIVER_NAME)
        );

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCleanUp: exit %x\n",
        SC_DRIVER_NAME,
        NTStatus)
        );

    return (NTStatus);
}


NTSTATUS GprCancelEventWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprCancelEventWait: Enter\n",
      SC_DRIVER_NAME)
      );

    ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

    SmartcardExtension->OsData->NotificationIrp = NULL;

   Irp->IoStatus.Information = 0;
   Irp->IoStatus.Status = STATUS_CANCELLED;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCancelEventWait: Request completed Irp = %lx\n",
        SC_DRIVER_NAME,
        Irp)
        );

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprCancelEventWait: Exit\n",
        SC_DRIVER_NAME)
        );

    return STATUS_CANCELLED;

}


VOID GprCardEventDpc(
    PKDPC                   Dpc,
    PDEVICE_OBJECT          DeviceObject,
   PDEVICE_EXTENSION    DeviceExtension,
   PSMARTCARD_EXTENSION    SmartcardExtension
    )
/*++

Routine Description :

    DPC routine for interrupts generated by the reader when a card is
    inserted/removed. This routine is called only when there is a user
    pending request on an insertion/removal IOCTL call. It will check
    if the Irp exists and its not being cancelled, and it will then
    complete it to signal the user event.
--*/
{
    ULONG OldState;
    ULONG NewState;
    READER_EXTENSION *pReaderExt;

    ASSERT (DeviceExtension != NULL);

//    SmartcardExtension = &(DeviceExtension->SmartcardExtension);
    ASSERT (SmartcardExtension != NULL);

    pReaderExt = SmartcardExtension->ReaderExtension;
    ASSERT (pReaderExt != NULL);
    // Read reader status response from the reader.
    GprllReadResp(pReaderExt);

    ASSERT(pReaderExt->Vo != NULL);

    OldState = SmartcardExtension->ReaderCapabilities.CurrentState;

    if((pReaderExt->To==0xA2) && (pReaderExt->Lo==4))
    {
        //
        // The TLV answer indicates the status of the card (inserted/removed)
        //
        if ( (pReaderExt->Vo[1] & 0x80) == 0x80)
        {
            if(SmartcardExtension->ReaderCapabilities.CurrentState <3)
            {
                NewState = SCARD_SWALLOWED;
            }
            else
            {
                NewState = SmartcardExtension->ReaderCapabilities.CurrentState;
            }
        }
        else
        {
            NewState = SCARD_ABSENT;
        }

        // register this state
        SmartcardExtension->ReaderCapabilities.CurrentState = NewState;
    }
    else
    {
        KeSetEvent(&(SmartcardExtension->ReaderExtension->GPRAckEvent),0,FALSE);
    }
    //
    // If the caller was waiting on a IOCTL_SMARTCARD_IS_PRESENT or
    // IOCTL_SMARTCARD_IS_ABSENT command, complete the request, but
    // check first if its being cancelled!
    //
    if(  (OldState != SmartcardExtension->ReaderCapabilities.CurrentState))
    {
        GprFinishPendingRequest( DeviceObject, STATUS_SUCCESS );
    }

}


VOID GprCardPresenceDpc(
    IN PKDPC pDpc,
    IN PVOID pvContext,
    IN PVOID pArg1,
    IN PVOID pArg2
   )
/*++

  Routine Description:
   This is the DPC routine called by polling to detect the card insertion/removal
--*/
{
PDEVICE_EXTENSION pDevExt = NULL;
PSMARTCARD_EXTENSION SmartcardExtension = NULL;
LARGE_INTEGER Timeout;
NTSTATUS status;
   UNREFERENCED_PARAMETER (pArg1);
   UNREFERENCED_PARAMETER (pArg2);


   pDevExt = (PDEVICE_EXTENSION) pvContext;
   SmartcardExtension = &(pDevExt->SmartcardExtension);

    
//   SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  ENTER\n"));

   // ISV
   // If wait conditions can be satisfied - get hardware.
   // Otherwise - just restart Timer to test it next time...
   status = testForIdleAndBlock(SmartcardExtension->ReaderExtension);
   if(NT_SUCCESS(status))
   {
       //  Send TLV command, to know card state,
        //  We don't care about return status, we get the response
        //  from the Interrupt
//       SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  GOT ACCESS! status %x\n", status));
       AskForCardPresence(SmartcardExtension);
       // Release hardware
       setIdle(SmartcardExtension->ReaderExtension);
   }

   if(!KeReadStateEvent(&(SmartcardExtension->ReaderExtension->ReaderRemoved))) {
   
       // Restart the polling timer
       Timeout.QuadPart = -(10000 * POLLING_TIME);
       KeSetTimer(&(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                  Timeout,
                  &SmartcardExtension->ReaderExtension->CardDpcObject
                  );
   }

//   SmartcardDebug(DEBUG_DRIVER,("------ CARD PRESENCE DPC ->  EXIT\n"));
}



VOID GprUnloadDevice(
   PDEVICE_OBJECT DeviceObject
   )
/*++

    Routine description

    close connections to smclib.sys and the pcmcia driver, delete symbolic
    link and mark the slot as unused.

    Arguments

    DeviceObject  device to unload
--*/
{
    PDEVICE_EXTENSION DeviceExtension;

    PAGED_CODE();

   ASSERT(DeviceObject != NULL);

   if (DeviceObject == NULL)
    {
        return;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprUnloadDevice: Enter \n",
        SC_DRIVER_NAME)
        );

    DeviceExtension = DeviceObject->DeviceExtension;

    ASSERT(
        DeviceExtension->SmartcardExtension.VendorAttr.UnitNo <
        GPR_MAX_DEVICE
        );

    if(DeviceExtension->PnPDeviceName.Buffer != NULL)
    {
        // disble our device so no one can open it
        IoSetDeviceInterfaceState(
            &DeviceExtension->PnPDeviceName,
            FALSE
            );
    }

   // Mark this slot as available
   bDeviceSlot[DeviceExtension->SmartcardExtension.VendorAttr.UnitNo] = FALSE;

   // report to the lib that the device will be unloaded
   if(DeviceExtension->SmartcardExtension.OsData != NULL)
    {
        //  finish pending tracking requests
        GprFinishPendingRequest(DeviceObject, STATUS_CANCELLED);

        ASSERT(DeviceExtension->SmartcardExtension.OsData->NotificationIrp == NULL);

        // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(&DeviceExtension->SmartcardExtension);
   }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL)
    {
         // Free under reader stuff
        if(!KeReadStateTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer)))
        {
            // Prevent restarting timer by sync functions
            KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
        }

        // Detach from the pcmcia driver
        if (DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject)
        {
            IoDetachDevice(
                DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject
                );

            DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject = NULL;
        }

        // free output buffer
        if (DeviceExtension->SmartcardExtension.ReaderExtension->Vo)
        {
            ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension->Vo);
            DeviceExtension->SmartcardExtension.ReaderExtension->Vo = NULL;
        }

        // free ReaderExtension structure
        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

   if (DeviceExtension->GprWorkStartup != NULL)
   {
      IoFreeWorkItem(DeviceExtension->GprWorkStartup);
        DeviceExtension->GprWorkStartup = NULL;
   }

   if(DeviceExtension->SmartcardExtension.OsData != NULL)
    {
      SmartcardExit(&DeviceExtension->SmartcardExtension);
    }

    if(DeviceExtension->PnPDeviceName.Buffer != NULL)
    {
        RtlFreeUnicodeString(&DeviceExtension->PnPDeviceName);
        DeviceExtension->PnPDeviceName.Buffer = NULL;
    }

    // delete the device object
    IoDeleteDevice(DeviceObject);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprUnloadDevice: Exit \n",
        SC_DRIVER_NAME)
        );

    return;
}


VOID GprUnloadDriver(
   PDRIVER_OBJECT DriverObject
   )
/*++

  Routine  Description :
   unloads all devices for a given driver object

  Arguments
   DriverObject   context of driver
--*/
{

    PAGED_CODE();

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!GprUnloadDriver\n",
      SC_DRIVER_NAME)
      );
}


NTSTATUS GprCreateClose(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++
    Routine Description
    Create / Close Device function
--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;
    PIO_STACK_LOCATION IrpStack;
    LARGE_INTEGER Timeout;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   IrpStack       = IoGetCurrentIrpStackLocation( Irp );

   // Initialize
   Irp->IoStatus.Information = 0;

   // dispatch major function
   switch( IrpStack->MajorFunction )
    {
        case IRP_MJ_CREATE:

           SmartcardDebug(
              DEBUG_DRIVER,
              ("%s!GprCreateClose: OPEN DEVICE\n",
              SC_DRIVER_NAME)
              );

            NTStatus = SmartcardAcquireRemoveLockWithTag(SmartcardExtension, 'lCrC');
            if (NTStatus != STATUS_SUCCESS)
            {
                NTStatus = STATUS_DEVICE_REMOVED;
            }
            else
            {
                Timeout.QuadPart = 0;

                // test if the device has been opened already
                NTStatus = KeWaitForSingleObject(
                    &DeviceExtension->ReaderClosed,
                    Executive,
                    KernelMode,
                    FALSE,
                    &Timeout
                    );

                if (NTStatus == STATUS_SUCCESS)
                {
                    DeviceExtension->OpenFlag = TRUE;
                    SmartcardDebug(
                        DEBUG_DRIVER,
                        ("%s!GprCreateClose: Set Card Detection timer\n",
                        SC_DRIVER_NAME)
                        );

                    // start the detection timer
                    Timeout.QuadPart = -(10000 * POLLING_TIME);
                    KeSetTimer(
                        &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
                        Timeout,
                        &SmartcardExtension->ReaderExtension->CardDpcObject
                        );

                    KeClearEvent(&DeviceExtension->ReaderClosed);
                }
                else
                {
                    // the device is already in use
                    NTStatus = STATUS_UNSUCCESSFUL;

                    // release the lock
                    //SmartcardReleaseRemoveLock(SmartcardExtension);
                    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'lCrC');

                }
            }

           SmartcardDebug(
              DEBUG_DRIVER,
              ("%s!GprCreateClose: OPEN DEVICE EXIT %x\n",
              SC_DRIVER_NAME, NTStatus)
              );
            break;

        case IRP_MJ_CLOSE:
           SmartcardDebug(
              DEBUG_DRIVER,
              ("%s!GprCreateClose: CLOSE DEVICE\n",
              SC_DRIVER_NAME)
              );

            // Cancel the card detection timer
            //SmartcardReleaseRemoveLock(SmartcardExtension);
            SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'lCrC');

            KeSetEvent(&DeviceExtension->ReaderClosed, 0, FALSE);

            if(DeviceExtension->OpenFlag == TRUE)
            {
                if(!KeReadStateTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer)))
                {
                    SmartcardDebug(
                        DEBUG_DRIVER,
                        ("%s!GprCreateClose: Cancel Detection timer\n",
                        SC_DRIVER_NAME)
                        );
                    // Prevent restarting timer by sync functions
                    KeCancelTimer(&(DeviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
                }
                DeviceExtension->OpenFlag = FALSE;
            }
           SmartcardDebug(
              DEBUG_DRIVER,
              ("%s!GprCreateClose: CLOSE DEVICE EXIT %x\n",
              SC_DRIVER_NAME, NTStatus)
              );
            break;

        default:
            NTStatus = STATUS_INVALID_DEVICE_REQUEST;
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprCreateClose: Exit %x\n",
                SC_DRIVER_NAME,
                NTStatus)
                );
            break;
   }

    Irp->IoStatus.Status = NTStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return NTStatus;
}



/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
/*VOID GprSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject     = deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject;
    UNREFERENCED_PARAMETER (MinorFunction);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprSystemPowerCompletion: Enter\n",
        SC_DRIVER_NAME)
        );

    //Irp->IoStatus.Information = 0;
    //Irp->IoStatus.Status = IoStatus->Status;

    //SmartcardReleaseRemoveLock(SmartcardExtension);
    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');


    if (PowerState.SystemState == PowerSystemWorking)
    {
        PoSetPowerState (
            DeviceObject,
            SystemPowerState,
            PowerState
            );
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);
    PoStartNextPowerIrp(Irp);
    PoCallDriver(AttachedDeviceObject,Irp);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprSystemPowerCompletion: Exit\n",
        SC_DRIVER_NAME)
        );

    return;
}
*/

/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
/*NTSTATUS GprDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS NTStatus;
    LARGE_INTEGER Timeout;


   ASSERT(SmartcardExtension != NULL);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprDevicePowerCompletion: Enter\n",
        SC_DRIVER_NAME)
        );

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    //SmartcardReleaseRemoveLock(SmartcardExtension);
    SmartcardReleaseRemoveLockWithTag(SmartcardExtension, 'rwoP');


    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State
        );

    PoStartNextPowerIrp(Irp);

    // Inform that Power mode is finish!
    SmartcardExtension->ReaderExtension->PowerRequest = FALSE;

    //
    // GPR400 Check Hardware
    //
    NTStatus = IfdCheck(SmartcardExtension);

    if (NTStatus == STATUS_SUCCESS)
    {
    // StartGpr in a worker thread.
   IoQueueWorkItem(
       deviceExtension->GprWorkStartup,
       (PIO_WORKITEM_ROUTINE) GprWorkStartup,
       DelayedWorkQueue,
       NULL
       );
    }
    else
    {
        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!GprDevicePowerCompletion: Reader in Bad State\n",
            SC_DRIVER_NAME)
            );
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprDevicePowerCompletion: Exit\n",
        SC_DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}
*/


VOID GprWorkStartup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:
    This function start the GPR after the power completion is completed.
   This function runs as a system thread at IRQL == PASSIVE_LEVEL.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
    LARGE_INTEGER Timeout;
    NTSTATUS NTStatus;
    USHORT i = 0;
    BOOLEAN ContinueLoop = TRUE;

    UNREFERENCED_PARAMETER(Context);

  SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> ENTER\n"));


 /*   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GprWorkStartup: Enter\n",
        DRIVER_NAME)
      );
*/
   ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

   //    remove this call, use a work thread. Klaus!
    //
    // Reset the reader
    //
    waitForIdleAndBlock(SmartcardExtension->ReaderExtension);
    while( ContinueLoop )
    {

         NTStatus = IfdReset(SmartcardExtension);

        i++;

        if(NTStatus == STATUS_SUCCESS)
        {
            ContinueLoop = FALSE;
        }
        else if (i >= 3)
        {
            ContinueLoop= FALSE;
        }
        else if ( NTStatus == STATUS_DEVICE_REMOVED)
        {
            ContinueLoop= FALSE;
        }
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprWorkStartup: IfdReset Status: %x\n",
        SC_DRIVER_NAME, NTStatus)
        );

   if (NTStatus != STATUS_SUCCESS)
    {

        SmartcardLogError(
            DeviceObject,
            GEMSCR0D_UNABLE_TO_INITIALIZE,
            NULL,
            0
            );

        //  Advise that reader is ready for working
        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

        if(SmartcardExtension->ReaderExtension->RestartCardDetection)
        {
        LARGE_INTEGER Timeout;
           SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;
            //   Restart the card detection timer
           Timeout.QuadPart = -(10000 * POLLING_TIME);
           KeSetTimer(
              &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
              Timeout,
              &SmartcardExtension->ReaderExtension->CardDpcObject
              );
           SmartcardDebug(DEBUG_DRIVER,("           CARD DETECTION RESTARTED!\n"));
        }

        setIdle(SmartcardExtension->ReaderExtension);
        SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> EXIT\n"));
        return;

   }


    // Do appropriate stuff for resume of hibernate mode.
    if( SmartcardExtension->ReaderExtension->NewDevice == FALSE )
    {
        //  Restart the card detection timer
        Timeout.QuadPart = -(10000 * POLLING_TIME);
        KeSetTimer(
            &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
            Timeout,
            &SmartcardExtension->ReaderExtension->CardDpcObject
            );

        // If a card was present before power down or now there is
        // a card in the reader, we complete any pending card monitor
        // request, since we do not really know what card is now in the
        // reader.
        //
        if(SmartcardExtension->ReaderExtension->CardPresent ||
            SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT)
        {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!GprDevicePowerCompletion: GprFinishPendingRequest\n",
                SC_DRIVER_NAME)
                );
            GprFinishPendingRequest(
                DeviceObject,
                STATUS_SUCCESS
                );
        }
    }

    // Device initialization finish,
    // NewDevice help to know it we are in hibernation mode or non
    SmartcardExtension->ReaderExtension->NewDevice = FALSE;

   // Advise that reader is ready for working
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    if(SmartcardExtension->ReaderExtension->RestartCardDetection)
    {
    LARGE_INTEGER Timeout;
       SmartcardExtension->ReaderExtension->RestartCardDetection = FALSE;
        //   Restart the card detection timer
       Timeout.QuadPart = -(10000 * POLLING_TIME);
       KeSetTimer(
          &(SmartcardExtension->ReaderExtension->CardDetectionTimer),
          Timeout,
          &SmartcardExtension->ReaderExtension->CardDpcObject
          );
       SmartcardDebug(DEBUG_DRIVER,("           CARD DETECTION RESTARTED!\n"));
    }

    setIdle(SmartcardExtension->ReaderExtension);
   
    SmartcardDebug(DEBUG_DRIVER,("------ WORK STARTUP -> EXIT\n"));

   /*
   SmartcardDebug(
      DEBUG_DRIVER,
      ( "%s!GprWorkStartup: Exit\n",
        DRIVER_NAME)
      );
*/
}



/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
/*NTSTATUS GprPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprPower: Enter\n",
        SC_DRIVER_NAME)
        );

    //status = SmartcardAcquireRemoveLock(smartcardExtension);
    status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');


    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status))
    {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject =
        deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject;


    if (irpStack->Parameters.Power.Type == DevicePowerState &&
        irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        switch (irpStack->Parameters.Power.State.DeviceState)
        {
            case PowerDeviceD0:
                // Turn on the reader
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!GprPower: PowerDevice D0\n",
                    SC_DRIVER_NAME)
                    );

                //
                // First, we send down the request to the bus, in order
                // to power on the port. When the request completes,
                // we turn on the reader
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine (
                    Irp,
                    GprDevicePowerCompletion,
                    smartcardExtension,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                action = WaitForCompletion;
                break;

            case PowerDeviceD3:
                // Turn off the reader
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!GprPower: PowerDevice D3\n",
                    SC_DRIVER_NAME)
                    );

                PoSetPowerState (
                    DeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State
                    );

                // save the current card state
                smartcardExtension->ReaderExtension->CardPresent =
                    smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

                if (smartcardExtension->ReaderExtension->CardPresent)
                {
                    smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                    GprCbReaderPower(smartcardExtension);
                }

                //
                // If there is a pending card tracking request, setting
                // this flag will prevent completion of the request
                // when the system will be waked up again.
                //
                smartcardExtension->ReaderExtension->PowerRequest = TRUE;

                // save the current power state of the reader
                smartcardExtension->ReaderExtension->ReaderPowerState =
                    PowerReaderOff;

                // cancel the card detection timer
                if(!KeReadStateTimer(&(deviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer)))
                {
                    // Prevent restarting timer by sync functions
                    KeCancelTimer(&(deviceExtension->SmartcardExtension.ReaderExtension->CardDetectionTimer));
                }

                // power down the reader
                // We don't care about return status of this function
                IfdPowerDown(smartcardExtension);

                action = SkipRequest;

                break;

            default:
                ASSERT(FALSE);
                action = SkipRequest;
                break;
        }
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState)
    {
        //
        // The system wants to change the power state.
        // We need to translate the system power state to
        // a corresponding device power state.
        //

        POWER_STATE_TYPE powerType = DevicePowerState;

        ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
            PowerReaderUnspecified);

        switch(irpStack->MinorFunction)
        {
            KIRQL irql;

            case IRP_MN_QUERY_POWER:

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!GprPower: Query Power\n",
                    SC_DRIVER_NAME)
                    );

                //
                // By default we succeed and pass down
                //

                action = SkipRequest;
                Irp->IoStatus.Status = STATUS_SUCCESS;

                switch (irpStack->Parameters.Power.State.SystemState)
                {
                    case PowerSystemMaximum:
                    case PowerSystemWorking:
                    case PowerSystemSleeping1:
                    case PowerSystemSleeping2:
                       break;

                    case PowerSystemSleeping3:
                    case PowerSystemHibernate:
                    case PowerSystemShutdown:

                        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                        if (deviceExtension->IoCount == 0)
                        {
                            // Block any further ioctls
                            KeClearEvent(&deviceExtension->ReaderStarted);
                        }
                        else
                        {
                            // can't go to sleep mode since the reader is busy.
                            status = STATUS_DEVICE_BUSY;
                            action = CompleteRequest;
                        }
                        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                        break;
                }
                break;


            case IRP_MN_SET_POWER:

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!GprPower: PowerSystem S%d\n",
                    SC_DRIVER_NAME,
                    irpStack->Parameters.Power.State.SystemState - 1)
                    );

                switch (irpStack->Parameters.Power.State.SystemState)
                {
                    case PowerSystemMaximum:
                    case PowerSystemWorking:
                    case PowerSystemSleeping1:
                    case PowerSystemSleeping2:

                        if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                            PowerReaderWorking)
                        {
                            // We're already in the right state
                     KeSetEvent(&deviceExtension->ReaderStarted,0,FALSE);
                            action = CompleteRequest;
                            break;
                        }

                        powerState.DeviceState = PowerDeviceD0;

                        // wake up the underlying stack...
                        action = MarkPending;
                        break;

                    case PowerSystemSleeping3:
                    case PowerSystemHibernate:
                    case PowerSystemShutdown:

                        if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                        PowerReaderOff)
                        {
                            // We're already in the right state
                            action = CompleteRequest;
                            break;
                        }

                        powerState.DeviceState = PowerDeviceD3;

                        // first, inform the power manager of our new state.
                        PoSetPowerState (
                            DeviceObject,
                            SystemPowerState,
                            powerState
                            );
                        action = MarkPending;
                        break;

                    default:
                        ASSERT(FALSE);
                        action = CompleteRequest;
                        break;
                }
        }
    }

    switch (action)
    {
        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            //SmartcardReleaseRemoveLock(smartcardExtension);
            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;

        case MarkPending:
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                GprSystemPowerCompletion,
                Irp,
                NULL
                );
            ASSERT(status == STATUS_PENDING);
         break;

        case SkipRequest:
            //SmartcardReleaseRemoveLock(smartcardExtension);
            SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprPower: Exit %lx\n",
        SC_DRIVER_NAME,
        status)
        );

    return status;
}
*/

// Functions to synchronize device execution
VOID        setBusy(PREADER_EXTENSION Device)
{
    KeClearEvent(&Device->IdleState);
    SmartcardDebug(DEBUG_DRIVER,("          DEVICE BUSY\n"));
};

VOID        setIdle(PREADER_EXTENSION Device)
{
LARGE_INTEGER Timeout;
    KeSetEvent(&Device->IdleState,IO_NO_INCREMENT,FALSE);
    SmartcardDebug(DEBUG_DRIVER,("          DEVICE IDLE\n"));
};

NTSTATUS    waitForIdle(PREADER_EXTENSION Device)
{
NTSTATUS status;
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    status  = KeWaitForSingleObject(&Device->IdleState, Executive,KernelMode, FALSE, NULL);
    if(!NT_SUCCESS(status)) return STATUS_IO_TIMEOUT;
    return STATUS_SUCCESS;
};

NTSTATUS    waitForIdleAndBlock(PREADER_EXTENSION Device)
{
    if(NT_SUCCESS(waitForIdle(Device)))
    { 
        setBusy(Device);
        return STATUS_SUCCESS;
    }
    else return STATUS_IO_TIMEOUT;
};

NTSTATUS    testForIdleAndBlock(PREADER_EXTENSION Device)
{
    ASSERT(KeGetCurrentIrql()<=DISPATCH_LEVEL);
    if(KeReadStateEvent(&Device->IdleState))
    {
        setBusy(Device);
        return STATUS_SUCCESS;
    }
    return STATUS_IO_TIMEOUT;
};

//-------------------------------------------------------------

NTSTATUS GprPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack, 
    because this driver knows about the connected reader. 
    Therefor this driver will translate system power states
    to device power states.
    
Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

    status = STATUS_SUCCESS;
    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!GprPower: Enter\n",
        SC_DRIVER_NAME)
        );

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!GprPower: Irp = %lx\n",
        SC_DRIVER_NAME, 
        Irp)
        );

    
    if(irpStack->MinorFunction == IRP_MN_QUERY_POWER)
        status = power_HandleQueryPower(DeviceObject,Irp);
    else if(irpStack->MinorFunction == IRP_MN_SET_POWER)
        status = power_HandleSetPower(DeviceObject,Irp);
    else 
    {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!GprPower: **** Forwarding Power request down...\n",
                SC_DRIVER_NAME)
                );

            // Default device does not do anything.
            // So let's just transfer request to low level driver...
            PoStartNextPowerIrp(Irp);// must be done while we own the IRP
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);       
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!GprPower: Exit %lx\n",
        SC_DRIVER_NAME,
        status)
        );
    return status;  
}

// Manages set power requests
NTSTATUS power_HandleSetPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
PIO_STACK_LOCATION irpStack;
NTSTATUS status = STATUS_SUCCESS;
POWER_STATE sysPowerState, desiredDevicePowerState;
PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

    if(!Irp) return STATUS_INVALID_PARAMETER;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (irpStack->Parameters.Power.Type) 
    {
        case SystemPowerState:
            // Get input system power state
            sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!power_HandleSetPower: PowerSystem S%d\n",
                SC_DRIVER_NAME,
                irpStack->Parameters.Power.State.SystemState - 1)
                );

            // If system is in working state always set our device to D0
            //  regardless of the wait state or system-to-device state power map
            if ( sysPowerState.SystemState == PowerSystemWorking) 
            {
                desiredDevicePowerState.DeviceState = PowerDeviceD0;
                KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!power_HandleSetPower: PowerSystemWorking, Setting device power D0(ON)...\n",
                    SC_DRIVER_NAME)
                    );
            } 
            else 
            {
                //System reduces power, so do specific for device processing...
                // if no wait pending and the system's not in working state, just turn off
                desiredDevicePowerState.DeviceState = PowerDeviceD3;
                SmartcardDebug(DEBUG_ERROR,
                    ("%s!power_HandleSetPower: Going Device Power D3(off)\n",
                    SC_DRIVER_NAME));
            }

            // We've determined the desired device state; are we already in this state?
            if(smartcardExtension->ReaderExtension->ReaderPowerState != desiredDevicePowerState.DeviceState)
            {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!power_HandleSetPower: Requesting to set DevicePower D%d\n",
                SC_DRIVER_NAME,
                desiredDevicePowerState.DeviceState - 1));

                // Callback will release the lock
                status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');

                IoMarkIrpPending(Irp);

                // No, request that we be put into this state
                // by requesting a new Power Irp from the Pnp manager
                deviceExtension->PowerIrp = Irp;
                status = PoRequestPowerIrp (DeviceObject,
                                           IRP_MN_SET_POWER,
                                           desiredDevicePowerState,
                                           // completion routine will pass the Irp down to the PDO
                                           (PREQUEST_POWER_COMPLETE)onPowerRequestCompletion, 
                                           DeviceObject, NULL);
            } 
            else 
            {   // Yes, just pass it on to PDO (Physical Device Object)
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                status = PoCallDriver(AttachedDeviceObject, Irp);       
            }
            break;
        case DevicePowerState:
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!power_HandleSetPower: Setting Device Power D%d\n",
                SC_DRIVER_NAME,
                irpStack->Parameters.Power.State.DeviceState - 1));

            // For requests to D1, D2, or D3 ( sleep or off states ),
            // sets deviceExtension->CurrentDevicePowerState to DeviceState immediately.
            // This enables any code checking state to consider us as sleeping or off
            // already, as this will imminently become our state.

            // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
            // to flag that we must set a completion routine and update
            // deviceExtension->CurrentDevicePowerState there.
            // In the case of powering up to fully on, we really want to make sure
            // the process is completed before updating our CurrentDevicePowerState,
            // so no IO will be attempted or accepted before we're really ready.

            if(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD3)
            {
                // save the current card state
                smartcardExtension->ReaderExtension->CardPresent = 
                    smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;
                if (smartcardExtension->ReaderExtension->CardPresent) 
                {
                    SmartcardDebug(
                        DEBUG_DRIVER,
                        ("%s!power_HandleSetPower: Power down card....\n",
                        SC_DRIVER_NAME));

                    smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                    GprCbReaderPower(smartcardExtension);
                }

                if(!KeReadStateTimer(&smartcardExtension->ReaderExtension->CardDetectionTimer))
                {
                    SmartcardDebug(DEBUG_DRIVER,("          STOP CARD DETECTION!\n"));
                    smartcardExtension->ReaderExtension->RestartCardDetection = TRUE;
                    // Stop detection for during power events
                    KeCancelTimer(&smartcardExtension->ReaderExtension->CardDetectionTimer);
                }

                // If there is a pending card tracking request, setting
                // this flag will prevent completion of the request 
                // when the system will be waked up again.
                smartcardExtension->ReaderExtension->PowerRequest = TRUE;

                desiredDevicePowerState.DeviceState = PowerDeviceD3;
                PoSetPowerState(DeviceObject,DevicePowerState,desiredDevicePowerState);
                // save the current power state of the reader
                smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;
                // Forward Irp down...
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
            }
            else
            {
                status = SmartcardAcquireRemoveLockWithTag(smartcardExtension, 'rwoP');
                
                SmartcardDebug(DEBUG_ERROR,
                    ("%s!power_HandleSetPower: Going to device power D0...\n",
                    SC_DRIVER_NAME));

                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                       onDevicePowerUpComplete,
                       // Always pass FDO to completion routine as its Context;
                       // This is because the DriverObject passed by the system to the routine
                       // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                       DeviceObject,
                       TRUE,            // invoke on success
                       TRUE,            // invoke on error
                       TRUE);           // invoke on cancellation of the Irp
            }
            status = PoCallDriver(AttachedDeviceObject, Irp);       
            break;
    } 
    return status;
}


// Manages device power up 
NTSTATUS    onDevicePowerUpComplete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID DeviceObject
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    POWER_STATE desiredDevicePowerState;

    SmartcardDebug(DEBUG_DRIVER,
        ("%s!onDevicePowerUpComplete: Enter Device Power Up...\n",
        SC_DRIVER_NAME));

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) IoMarkIrpPending(Irp);
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // We can assert that we're a  device powerup-to D0 request,
    // because that was the only type of request we set a completion routine
    // for in the first place
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    // We've got power up request, so...
    // Report everybody that reader is powered up again!
    smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderWorking;

    // GPR400 Check Hardware
    if(NT_SUCCESS(IfdCheck(smartcardExtension)))
    {
    // StartGpr in a worker thread.
   IoQueueWorkItem(
       deviceExtension->GprWorkStartup,
       (PIO_WORKITEM_ROUTINE) GprWorkStartup,
       DelayedWorkQueue,
       NULL);
    }
    else
    {
        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!GprDevicePowerCompletion: Reader is in Bad State\n",
            SC_DRIVER_NAME)
            );
    }

    smartcardExtension->ReaderExtension->PowerRequest = FALSE;

    // Now that we know we've let the lower drivers do what was needed to power up,
    //  we can set our device extension flags accordingly

    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

    // Report our state to Power manager...
    desiredDevicePowerState.DeviceState = PowerDeviceD0;
    PoSetPowerState(DeviceObject,DevicePowerState,desiredDevicePowerState);
    PoStartNextPowerIrp(Irp);

    SmartcardDebug(DEBUG_DRIVER,
        ("%s!onDevicePowerUpComplete: Exit for the device state D0...\n",
        SC_DRIVER_NAME));
    return status;
}

// Manages system power transitions
NTSTATUS onPowerRequestCompletion(
    IN PDEVICE_OBJECT       NullDeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                DeviceObject,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = ((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;
    PIRP Irp;

    SmartcardDebug(DEBUG_DRIVER,
        ("%s!onPowerRequestCompletion: Enter...\n",
        SC_DRIVER_NAME));

    // Get the Irp we saved for later processing in BulkUsb_ProcessPowerIrp()
    // when we decided to request the Power Irp that this routine 
    // is the completion routine for.
    Irp = deviceExtension->PowerIrp;

    // We will return the status set by the PDO for the power request we're completing
    status = IoStatus->Status;
    smartcardExtension->ReaderExtension->ReaderPowerState = PowerState.DeviceState;

    // we must pass down to the next driver in the stack
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Calling PoStartNextPowerIrp() indicates that the driver is finished
    // with the previous power IRP, if any, and is ready to handle the next power IRP.
    // It must be called for every power IRP.Although power IRPs are completed only once,
    // typically by the lowest-level driver for a device, PoStartNextPowerIrp must be called
    // for every stack location. Drivers must call PoStartNextPowerIrp while the current IRP
    // stack location points to the current driver. Therefore, this routine must be called
    // before IoCompleteRequest, IoSkipCurrentStackLocation, and PoCallDriver.

    PoStartNextPowerIrp(Irp);

    // PoCallDriver is used to pass any power IRPs to the PDO instead of IoCallDriver.
    // When passing a power IRP down to a lower-level driver, the caller should use
    // IoSkipCurrentIrpStackLocation or IoCopyCurrentIrpStackLocationToNext to copy the IRP to
    // the next stack location, then call PoCallDriver. Use IoCopyCurrentIrpStackLocationToNext
    // if processing the IRP requires setting a completion routine, or IoSkipCurrentStackLocation
    // if no completion routine is needed.

    PoCallDriver(AttachedDeviceObject,Irp);

    deviceExtension->PowerIrp = NULL;
    SmartcardReleaseRemoveLockWithTag(smartcardExtension, 'rwoP');

    SmartcardDebug(DEBUG_DRIVER,
        ("%s!onPowerRequestCompletion: Exit...\n",
        SC_DRIVER_NAME));
    return status;
}

NTSTATUS power_HandleQueryPower(PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
PDEVICE_OBJECT AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;
NTSTATUS status = STATUS_SUCCESS;
KIRQL irql;

    SmartcardDebug(
        DEBUG_ERROR,
        ("%s!power_HandleQueryPower: Enter QueryPower...\n",
        SC_DRIVER_NAME));

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount != 0)
    {   // can't go to sleep mode since the reader is busy.
        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);                
        status = Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        Irp->IoStatus.Information = 0;
        PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);        
        return status;
    }

    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);                

    // Block any further ioctls
    KeClearEvent(&deviceExtension->ReaderStarted);
    
    SmartcardDebug(DEBUG_DRIVER,
        ("%s!power_HandleQueryPower: Reader BLOCKED!!!!!!!...\n",
        SC_DRIVER_NAME));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    status = PoCallDriver(AttachedDeviceObject, Irp);   
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\giesecke.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

#define BYTES_PER_BLOCK 64

void 
GDTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider GDTestCard(GDTestCardEntry);

static ULONG
GDTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Set protocol to T=0 | T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
GDTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uBlock, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
	
	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {

            ULONG l_uNumBytes = 256;

            // write some data to the test file using T=0

            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            ULONG l_uState;
            TestStart("Check reader state");
            l_lResult = in_CReader.GetState(&l_uState);
            TEST_CHECK_SUCCESS(
                "Ioctl IOCTL_SMARTCARD_GET_STATE failed", 
                l_lResult
                );
            TestCheck(
                l_uState == SCARD_NEGOTIABLE,
                "Invalid reader state.\nReturned %d\nExpected %d",
                l_uState,
                SCARD_NEGOTIABLE
                );
            TestEnd();

            TestStart("Set protocol T=0");
            l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\x00\x01",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x61, 0x09,
                NULL, NULL, 0
                );

            TEST_END();     	

            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);

            for (l_uBlock = 0; l_uBlock < l_uNumBytes; l_uBlock += BYTES_PER_BLOCK) {
             	
                // apdu for write binary
                memcpy(l_rgchBuffer, "\x00\xd6\x00", 3);

                // offset within the file we want to write to
                l_rgchBuffer[3] = (UCHAR) l_uBlock;

                // Append number of bytes 
                l_rgchBuffer[4] = (UCHAR) BYTES_PER_BLOCK;

                // append pattern to buffer;
                for (l_uIndex = 0; l_uIndex < BYTES_PER_BLOCK; l_uIndex++) {

                    l_rgchBuffer[5 + l_uIndex] = (UCHAR) (l_uBlock + l_uIndex);
                }

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + BYTES_PER_BLOCK,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );
            }

            TEST_END();

            //
            // read the data back using T=1
            //

            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
            TestEnd();

            TestStart("Set protocol T=1");
            l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();

            // select a file
            TestStart("SELECT FILE EFptsDataCheck");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x00\x00\x02\x00\x01",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 11,
                l_pchResult[9], l_pchResult[10], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

            for (l_uBlock = 0; l_uBlock < l_uNumBytes; l_uBlock += BYTES_PER_BLOCK) {
             	
                // apdu for read binary 
                memcpy(l_rgchBuffer, "\x00\xb0\x00", 3);

                // offset within the file we want to read from
                l_rgchBuffer[3] = (UCHAR) l_uBlock;

                // Append number of bytes (note: the buffer contains the pattern already)
                l_rgchBuffer[4] = (UCHAR) BYTES_PER_BLOCK;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                // append pattern to buffer;
                for (l_uIndex = 0; l_uIndex < BYTES_PER_BLOCK; l_uIndex++) {

                    l_rgchBuffer[l_uIndex] = (UCHAR) (l_uBlock + l_uIndex);
                }

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, (l_uNumBytes / 4) + 2,
                    l_pchResult[BYTES_PER_BLOCK], l_pchResult[BYTES_PER_BLOCK + 1], 0x90, 0x00,
                    l_pchResult, l_rgchBuffer, BYTES_PER_BLOCK
                    );
            }
		    
            TEST_END();
            return IFDSTATUS_END;
        }

	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
GDTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(GDTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(GDTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("G & D");

    // ATR of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3B\xBF\x18\x00\xC0\x20\x31\x70\x52\x53\x54\x41\x52\x43\x4F\x53\x20\x53\x32\x31\x20\x43\x90\x00\x9C", 25);
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xbf\x18\x00\x80\x31\x70\x35\x53\x54\x41\x52\x43\x4f\x53\x20\x53\x32\x31\x20\x43\x90\x00\x9b", 24);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\errmap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       errmap.c
//
//--------------------------------------------------------------------------

typedef long LONG;
typedef LONG NTSTATUS;
#include <ntstatus.h>
#include <winerror.h>

//#define WIN32_NO_STATUS
#include "errmap.h"       

LONG                               
MapWinErrorToNtStatus(
    LONG in_uErrorCode
    )
{
    LONG i;

    for (i = 0; i < sizeof(CodePairs) / sizeof(CodePairs[0]); i += 2) {

        if (CodePairs[i + 1] == in_uErrorCode) {

            return CodePairs[i];
         	
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\gpr400\gprelcmd.h ===
/*++
                 Copyright (c) 1998 Gemplus Development

Name: 
	Gprelcmd.h 

Description: 
	 Fonctions enable to access and to deal with GPR. PC/SC version
     Header file.   
Environment:
	Kernel Mode

Revision History: 
	06/05/98: V1.00.003  (P. Plouidy)
		- Power management for NT5 
	10/02/98: V1.00.002  (P. Plouidy)
		- Plug and Play for NT5 
	03/07/97: V1.00.001  (P. Plouidy)
		- Start of development.


--*/
#include "gprnt.h"
//
// Name definition:
//   _GPRELCMD_ is used to avoid multiple inclusion.
//
#ifndef _GPRELCMD_
#define _GPRELCMD_

//
//   Constants section:
// - REGISTER_HANDSHAKE, REGISTER_PRG, REGISTER_T, REGISTER_L and REGISTER_V are
//   the offset address in the GPR.
// - HANDSHAKE_INTR defines the mask for INTR bit in the handshake register.
// - HANDSHAKE_IREQ defines the mask for IREQ bit in the handshake register.
// - MAX_V_LEN defines the maximum length data for a TLV command.
//

#define REGISTER_HANDSHAKE       0x00
#define REGISTER_PRG             0x01
#define REGISTER_T               0x02
#define REGISTER_L               0x03
#define REGISTER_V               0x04
#define HANDSHAKE_INTR           0x02
#define HANDSHAKE_IREQ           0x04
#define MAX_V_LEN                28


//
//   GPR400 commands definitions:
//
#define DEFINE_TYPE_CMD          0x50
#define OPEN_SESSION_CMD         0x20
#define CLOSE_SESSION_CMD        0x10
#define APDU_EXCHANGE_CMD        0x30
#define VALIDATE_DRIVER_CMD      0x70
#define POWER_DOWN_GPR_CMD       0x40
#define LOAD_MEMORY_CMD          0x60
#define READ_MEMORY_CMD          0x80
#define EXEC_MEMORY_CMD          0x90
#define CHECK_AND_STATUS_CMD     0xA0
#define INIT_ENCRYPTION_CMD      0xB0
#define UPDATE_CMD               0xF0


//
// Debug prototypes 
//
#if DBG

void GPR_Debug_Buffer
(
   PUCHAR pBuffer,
   DWORD Lenght
);

#endif

//
// Prototype section
//


NTSTATUS GDDK_Translate
(
    const BYTE  IFDStatus,
    const UCHAR Tag
);

BOOLEAN  G_ReadByte
(
    const USHORT BIOAddr,
    UCHAR *Value
);

BOOLEAN  G_WriteByte
(
    const USHORT BIOAddr,
    UCHAR *Value
);

BOOLEAN  G_ReadBuf
(
    const USHORT BIOAddr,
    const USHORT Len,
    UCHAR *Buffer
);

BOOLEAN  G_WriteBuf
(
    const USHORT BIOAddr,
    const USHORT Len,
    UCHAR *Buffer
);


UCHAR GprllReadRegister
(
   const PREADER_EXTENSION      pReaderExt,
   const SHORT					GPRRegister
);
void GprllMaskHandshakeRegister
(
	const PREADER_EXTENSION		pReaderExt,
	const UCHAR                 Mask,
	const UCHAR                 BitState
);
NTSTATUS GprllTLVExchange
(
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti, 
   const USHORT				Li, 
   const UCHAR				*Vi,
         UCHAR				*To, 
         USHORT				*Lo, 
         UCHAR				*Vo
);
void GprllSendCmd
(  
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti, 
   const USHORT				Li,
   const UCHAR				*Vi
);
void GprllReadResp
(
   const PREADER_EXTENSION	pReaderExt
);
NTSTATUS GprllSendChainUp
(
   const PREADER_EXTENSION	pReaderExt,
   const UCHAR				Ti,
   const USHORT				Li,
   const UCHAR				*Vi
);
NTSTATUS GprllReadChainUp
(
   const PREADER_EXTENSION	pReaderExt,
         UCHAR				*To, 
         USHORT				*Lo,
         UCHAR				*Vo
);

//	GprllWait
//
void GprllWait
(
	const LONG					lWaitingTime
);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ifdmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdmsg.cpp
//
//--------------------------------------------------------------------------

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

// Our log file
static FILE *g_pLogFile;

// These are used by the Testxxx functions
static BOOL g_bTestFailed;
static BOOL g_bReaderFailed;
static BOOL g_bTestStart;

void
LogOpen(
    PCHAR in_pchFileName
    )
{
    CHAR l_rgchFileName[128];

    sprintf(l_rgchFileName, "%s.log", in_pchFileName);
    g_pLogFile = fopen(l_rgchFileName, "w"); 	
}

void
LogMessage(
    PCHAR in_pchFormat,
    ...
    )
{
    CHAR l_rgchBuffer[128];
    va_list l_pArg;

    va_start(
        l_pArg, 
        in_pchFormat
        );

    vsprintf(
        l_rgchBuffer,
        in_pchFormat, 
        l_pArg
        ); 	

    printf("%s\n", l_rgchBuffer);
    if (g_pLogFile) {
        
        fprintf(g_pLogFile, "%s\n", l_rgchBuffer);
    }
}

void 
TestStart(
    PCHAR in_pchFormat,
    ...
    )
{ 	                                
    CHAR l_rgchBuffer[128];
    va_list l_pArg;

    if (g_bTestStart) {

        printf("\n*** WARNING: Missing TestResult() call\n");
    }

    g_bTestStart = TRUE;
    g_bTestFailed = FALSE;

    va_start(l_pArg, in_pchFormat);
    vsprintf(l_rgchBuffer, in_pchFormat, l_pArg);

    printf("   %-50s", l_rgchBuffer);
    if (g_pLogFile) {
        
        fprintf(g_pLogFile, "   %-50s", l_rgchBuffer);
    }
}

static 
void 
TestMsg(
    BOOL in_bTestEnd,
    BOOL in_bTestResult,
    PCHAR in_pchFormat,
    va_list in_pArg
    )
{     	
    CHAR l_rgchBuffer[2048];

    if (in_bTestEnd && g_bTestStart == FALSE) {

        printf("\n*** WARNING: Missing TestStart() call\n");
    }

    vsprintf(l_rgchBuffer, in_pchFormat, in_pArg);

    if (in_bTestResult == FALSE && g_bTestFailed == FALSE) {

        g_bTestFailed = TRUE;
        g_bReaderFailed = TRUE;
        printf("* FAILED\n-  %s\n", l_rgchBuffer);

        if (g_pLogFile) {
         	
            fprintf(g_pLogFile, "* FAILED\n-  %s\n", l_rgchBuffer);
        }
    }

    if (in_bTestEnd) {

        if (g_bTestFailed != TRUE) {
         	
            printf("  Passed\n");

            if (g_pLogFile) {
         	    
                fprintf(g_pLogFile, "   Passed\n");
            }
        }
    }
}

void 
TestCheck(
    BOOL in_bResult,
    PCHAR in_pchFormat,
    ...
    )
{
    va_list l_pArg;

    va_start(l_pArg, in_pchFormat);
    TestMsg(FALSE, in_bResult, in_pchFormat, l_pArg);
}

void
TestCheck(
    ULONG in_lResult,
    const PCHAR in_pchOperator,
    const ULONG in_uExpectedResult,
    ULONG in_uResultLength,
    ULONG in_uExpectedLength,
    UCHAR in_chSw1,
    UCHAR in_chSw2,
    UCHAR in_chExpectedSw1,
    UCHAR in_chExpectedSw2,
    PUCHAR in_pchData,
    PUCHAR in_pchExpectedData,
    ULONG  in_uDataLength
    )
/*++

Routine Description:

    This function checks the return code, the number of bytes
    returned, the card status bytes and the data returned by 
    a call to CReader::Transmit. 
    
--*/
{
    if (strcmp(in_pchOperator, "==") == 0 &&
        in_lResult != in_uExpectedResult ||
        strcmp(in_pchOperator, "!=") == 0 &&
        in_lResult == in_uExpectedResult) {

        TestCheck(
            FALSE,
            "IOCTL call failed:\nReturned %8lxH (NTSTATUS %8lxH)\nExpected %s%8lxH (NTSTATUS %8lxH)",
            in_lResult,
            MapWinErrorToNtStatus(in_lResult),
            (strcmp(in_pchOperator, "!=") == 0 ? "NOT " : ""),
            in_uExpectedResult,
            MapWinErrorToNtStatus(in_uExpectedResult)
            );

    } else if (in_uResultLength != in_uExpectedLength) {

        TestCheck(
            FALSE,
            "IOCTL returned wrong number of bytes:\nReturned %3ld bytes\nExpected %3ld bytes",
            in_uResultLength,
            in_uExpectedLength
            );

    } else if (in_chSw1 != in_chExpectedSw1 ||
               in_chSw2 != in_chExpectedSw2){

        TestCheck(
            FALSE,
            "Card returned wrong status:\nStatus SW1 = %02x SW2 = %02x\nExpected SW1 = %02x SW2 = %02x",
            in_chSw1,
            in_chSw2,
            in_chExpectedSw1,
            in_chExpectedSw2
            );

    } else if (memcmp(in_pchData, in_pchExpectedData, in_uDataLength)) {

        CHAR l_rgchData[2048], l_rgchExpectedData[2048];

        for (ULONG i = 0; i < in_uDataLength; i++) {

            sprintf(l_rgchData + i * 3, "%02X ", in_pchData[i]);
            sprintf(l_rgchExpectedData + i * 3, "%02X ", in_pchExpectedData[i]);

            if ((i + 1) % 24 == 0) {

                l_rgchData[i * 3 + 2] = '\n';
                l_rgchExpectedData[i * 3 + 2] = '\n';             	
            }         	
        }
              	
        TestCheck(
            FALSE,
            "IOCTL returned incorrect data:\nData returned:\n%s\nExpected data:\n%s",
            l_rgchData, 
            l_rgchExpectedData
            );
    }
}

void
TestEnd(
    void
    )
/*++

Routine Description:

    A call to this function marks the end of a test sequence.
    A sequence is usually look like:

    TestStart(Message)
    CReaderTransmit or DeviceIoControl
    TestCheck(...)
    TestEnd()
	
--*/
{
#ifdef _M_ALPHA
    va_list l_pArg;
#else
    va_list l_pArg = NULL;
#endif
    TestMsg(TRUE, TRUE, "", l_pArg);
    g_bTestStart = FALSE;
}

BOOL
TestFailed(
    void
    )
{
    return g_bTestFailed;
}

BOOL
ReaderFailed(
	void
	)
{
 	return g_bReaderFailed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ibm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ibm.cpp
//
//--------------------------------------------------------------------------

/*++

Module Name:

    ibmmfc41.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Environment:

    Win32 application

Revision History :

    Jan 1998 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);
                                                  
                                          
static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult;
    ULONG l_uResultLength, l_uExpectedLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512], l_rgchBuffer2[512];

    switch (in_CCardProvider.GetTestNo()) {

	    case 1: {
            //
            // select a file 0007 and write data pattern 0 to N-1 to the card. 
			// Then read the data back and verify correctness. 
            // Check IFSC and IFSD above card limits
            //

            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

            if (TestFailed()) {
                
				return IFDSTATUS_FAILED;
            }

            //
            // Do a couple of writes and reads up to maximum size
			// Check behaviour above IFSC and IFSD Limits
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_auNumBytes[] = { 1 , 25, 50, 75, 100, 125, 128, 150, 175, 200, 225, 250, 254 };
    
            time_t l_TimeStart;
			time(&l_TimeStart); 

            for (ULONG l_uTest = 0; l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];
             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

				if (l_uNumBytes <= 128) {

                    TestCheck(
                        l_lResult, "==", ERROR_SUCCESS,
                        l_uResultLength, 2,
                        l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                        NULL, NULL, NULL
                        );

                } else {
                 	
                    TestCheck(
                        l_lResult, "==", ERROR_SUCCESS,
                        l_uResultLength, 2,
                        l_pchResult[0], l_pchResult[1], 0x67, 0x00,
                        NULL, NULL, NULL
                        );
                }

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s)", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                //
                // check if the right number of bytes has been returned
                //
				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uExpectedLength], 
                    l_pchResult[l_uExpectedLength + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uExpectedLength
                    );

                TEST_END();
            }

            time_t l_TimeEnd;
            time(&l_TimeEnd); 
            CTime l_CTimeStart(l_TimeStart);
            CTime l_CTimeEnd(l_TimeEnd);
            CTimeSpan l_CTimeElapsed = l_CTimeEnd - l_CTimeStart;
            if (l_CTimeElapsed.GetTotalSeconds() < 10) {

                LogMessage(
                    "Reader performance is good (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
             	
            } else if (l_CTimeElapsed.GetTotalSeconds() < 30) {

                LogMessage(
                    "Reader performance is average (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
             	
            } else {

                LogMessage(
                    "Reader performance is bad (%u sec)", 
                    l_CTimeElapsed.GetTotalSeconds()
                    );
            }
            break;
		}

		case 2: {
            //
            // Select a file 0007 and write alternately pattern 55 and AA 
			// to the card. 
			// Read the data back and verify correctness after each write. 
            //
            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();
            //
            // Do a couple of writes and reads alternately 
			// with patterns 55h and AAh 
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR)  0x55;    
				l_rgchBuffer2[5 + l_uIndex] = (UCHAR) 0xAA;  
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_uNumBytes = 128; 

            for (ULONG l_uTest = 0; l_uTest < 2; l_uTest++) {

             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern 55h", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern 55h", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uExpectedLength
                    );

                TEST_END();

				//
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern AAh", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 
                    0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern AAh", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer2 + 5, min(l_uExpectedLength,125)
                    );

                TEST_END();
            }

        	break;         	
		}

		case 3: {
            
            // select a file 0007 and write alternately pattern 00 and FF 
			// to the card. 
			// Read the data back and verify correctness after each write. 


            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

            //
            // Do a couple of writes and reads alternately 
			// with patterns 00h and FFh 
            //

            //
            // Generate a 'test' pattern which will be written to the card
            //
            for (l_uIndex = 0; l_uIndex < 254; l_uIndex++) {

                l_rgchBuffer[5 + l_uIndex] = (UCHAR)  0x00;    
				l_rgchBuffer2[5 + l_uIndex] = (UCHAR) 0xFF;  
            }

            //
            // This is the amount of bytes we write to the card in each loop
            //
            ULONG l_uNumBytes = 128; 

            for (ULONG l_uTest = 0; l_uTest < 2; l_uTest++) {

             	
                //
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern 00h", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern 00h", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, 
                    l_rgchBuffer + 5, 
                    l_uExpectedLength
                    );

                TEST_END();

				//
                // Write 
                //
                TestStart("WRITE BINARY %3d Byte(s) Pattern FFh", l_uNumBytes);
                            
                //
                // Tpdu for write binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xd6\x00\x00", 4);

                //
                // Append number of bytes (note: the buffer contains the pattern already)
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5 + l_uNumBytes,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pchResult[0], l_pchResult[1], 
                    0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();

                //
                // Read
                //
                TestStart("READ  BINARY %3d Byte(s) Pattern FFh", l_uNumBytes);

                //
                // tpdu for read binary
                //
                memcpy(l_rgchBuffer2, "\xa4\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer2[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer2,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

				l_uExpectedLength = min(128, l_uNumBytes);

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uExpectedLength + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, 
                    l_rgchBuffer2 + 5, 
                    min(l_uExpectedLength,125)
                    );

                TEST_END();
            }
        	break;         	
		}

		case 4: {
			//
			// Select Command for Nonexisting File
			//

            TestStart("SELECT NONEXISTING FILE");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x77\x77",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x94, 0x04,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 5: {
			//
			// Select Command without Fileid
			//
			TestStart("SELECT COMMAND WITHOUT FILEID");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00",
                4,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 6: {
			//
			// Select Command with path too short
			//
			
           TestStart("SELECT COMMAND PATH WITH PATH TOO SHORT");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x01\x77",
                6,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 7: {
			//
			// Select Command with wrong Lc
			//
			
           TestStart("SELECT COMMAND PATH WITH WRONG LC");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x08\x00",
                6,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 8: {
			//
			// Select Command too short
			//

           TestStart("SELECT COMMAND TOO SHORT");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00",
                3,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x6f, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 9: {
			//
			// Select Command with invalid P2
			//

           TestStart("SELECT COMMAND WITH INVALID P2");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x02\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x6b, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 10: {
			//
			// Select command without fileid but with Le
			//
			
			TestStart("SELECT COMMAND WITHOUT FILEID BUT WITH Le");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x00",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x67, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();
			break;
		}

		case 11: {
			//
			// Use Change Speed command to simulate unresponsive card
			//

            //
            // Select a file
            //
            TestStart("SELECT FILE 0007");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 16,
                l_pchResult[14], l_pchResult[15], 0x90, 0x00,
                l_pchResult, 
                (PUCHAR) "\x63\x0c\x03\xe8\x00\x07\x00\x00\x00\xff\xff\x11\x01\x00\x90\x00", 
                l_uResultLength
                );

            TEST_END();

			//
			// Perform change speed command to simulate unresponsive card 
			//
            TestStart("CHANGE SPEED");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xb6\x42\x00\x40",
                4,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            //
            // Select a file to verify bad return code
            //
            TestStart("SELECT FILE 0007 WILL GET NO VALID RESPONSE");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\xa4\xa4\x00\x00\x02\x00\x07",
                7,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "!=", ERROR_SUCCESS,
                NULL, NULL,
                NULL, NULL,
                NULL, NULL,
                NULL, NULL, NULL
                );

            TEST_END();
            return IFDSTATUS_END;
		}

        default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;
}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("IBM");

    in_CCardProvider.SetAtr((PBYTE) "\x3b\xef\x00\xff\x81\x31\x86\x45\x49\x42\x4d\x20\x4d\x46\x43\x34\x30\x30\x30\x30\x38\x33\x31\x43", 24);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\errmap.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    errmap.h

Abstract:

    defines an array for mapping nt-status codes to win32 error codes

Environment:

    Windows95 / Memphis static VxD

Notes:

    This files stems originally from \nt\private\ntos\rtl\error.h

Revision History:

    - Copied June 1997 by Klaus Schutz 

--*/

LONG CodePairs[] = {

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NOT_MZ, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_LE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_NE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_WIN_16, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_PARAMETER,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,
    STATUS_REMOTE_STORAGE_NOT_ACTIVE, ERROR_REMOTE_STORAGE_NOT_ACTIVE,
    STATUS_REMOTE_STORAGE_MEDIA_ERROR, ERROR_REMOTE_STORAGE_MEDIA_ERROR,
    STATUS_NO_TRACKING_SERVICE, ERROR_NO_TRACKING_SERVICE,

    STATUS_JOURNAL_DELETE_IN_PROGRESS, ERROR_JOURNAL_DELETE_IN_PROGRESS,
    STATUS_JOURNAL_NOT_ACTIVE, ERROR_JOURNAL_NOT_ACTIVE,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_RXACT_INVALID_STATE, ERROR_RXACT_INVALID_STATE,

    STATUS_RXACT_COMMIT_FAILURE, ERROR_RXACT_COMMIT_FAILURE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,

    STATUS_ENCRYPTION_FAILED,          ERROR_ENCRYPTION_FAILED,
    STATUS_DECRYPTION_FAILED,          ERROR_DECRYPTION_FAILED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_NO_RECOVERY_POLICY,
    STATUS_NO_EFS,                     ERROR_NO_EFS,
    STATUS_WRONG_EFS,                  ERROR_WRONG_EFS,
    STATUS_NO_USER_KEYS,               ERROR_NO_USER_KEYS,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_FLOPPY_ID_MARK_NOT_FOUND, ERROR_FLOPPY_ID_MARK_NOT_FOUND,

    STATUS_FLOPPY_WRONG_CYLINDER, ERROR_FLOPPY_WRONG_CYLINDER,

    STATUS_FLOPPY_UNKNOWN_ERROR, ERROR_FLOPPY_UNKNOWN_ERROR,

    STATUS_FLOPPY_BAD_REGISTERS, ERROR_FLOPPY_BAD_REGISTERS,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    STATUS_WMI_GUID_NOT_FOUND, ERROR_WMI_GUID_NOT_FOUND,
    STATUS_WMI_INSTANCE_NOT_FOUND, ERROR_WMI_INSTANCE_NOT_FOUND,
    STATUS_WMI_ITEMID_NOT_FOUND, ERROR_WMI_ITEMID_NOT_FOUND,
    STATUS_WMI_TRY_AGAIN, ERROR_WMI_TRY_AGAIN,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,

    STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY,ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY,

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE,ERROR_DS_NO_ATTRIBUTE_OR_VALUE,

    STATUS_DS_INVALID_ATTRIBUTE_SYNTAX,ERROR_DS_INVALID_ATTRIBUTE_SYNTAX,

    STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED,ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED,

    STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS,ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS,

    STATUS_DS_BUSY,ERROR_DS_BUSY,

    STATUS_DS_UNAVAILABLE,ERROR_DS_UNAVAILABLE,

    STATUS_DS_NO_RIDS_ALLOCATED,ERROR_DS_NO_RIDS_ALLOCATED,

    STATUS_DS_NO_MORE_RIDS,ERROR_DS_NO_MORE_RIDS,

    STATUS_DS_INCORRECT_ROLE_OWNER,ERROR_DS_INCORRECT_ROLE_OWNER,

    STATUS_DS_RIDMGR_INIT_ERROR,ERROR_DS_RIDMGR_INIT_ERROR,

    STATUS_DS_OBJ_CLASS_VIOLATION,ERROR_DS_OBJ_CLASS_VIOLATION,

    STATUS_DS_CANT_ON_NON_LEAF,ERROR_DS_CANT_ON_NON_LEAF,

    STATUS_DS_CANT_ON_RDN,ERROR_DS_CANT_ON_RDN,

    STATUS_DS_CROSS_DOM_MOVE_FAILED,ERROR_DS_CROSS_DOM_MOVE_ERROR,

    STATUS_DS_GC_NOT_AVAILABLE,ERROR_DS_GC_NOT_AVAILABLE,

    STATUS_SHARED_POLICY,ERROR_SHARED_POLICY,

    STATUS_POLICY_OBJECT_NOT_FOUND,ERROR_POLICY_OBJECT_NOT_FOUND,

    STATUS_POLICY_ONLY_IN_DS,ERROR_POLICY_ONLY_IN_DS,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    // Terminal Server Entries

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ifdtest.cpp ===
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

class CCardProvider *CCardProvider::s_pFirst;

#define INSERT_CARD "Please insert smart card"
#define REMOVE_CARD "Please remove smart card"

PCHAR
CAtr::GetAtrString(
    PCHAR in_pchBuffer
    )
{
    for (ULONG i = 0; i < m_uAtrLength; i++) {

        sprintf(in_pchBuffer + i * 3, "%02X ", m_rgbAtr[i]);
    }

    return in_pchBuffer;
}

CCardProvider::CCardProvider(
    void
    )
{
    m_pNext = NULL;
    m_uTestNo = 0;
    m_bCardTested = FALSE;
    m_bTestFailed = FALSE;
    m_pSetProtocol = NULL;
    m_pCardTest = NULL;
}

CCardProvider::CCardProvider(
    void (*in_pEntryFunction)(class CCardProvider&)
    )
/*++

Routine Description:
   Constructor for class CCardProvider.
    This constructor is called for every card that is to be tested.
    It creates a new instance and appends it to a singly linked list

Arguments:

    Pointer to function that registers all test functions

--*/
{
    class CCardProvider *l_pCardProvider;

    *this = CCardProvider();

    if (s_pFirst == NULL) {

        s_pFirst = new CCardProvider;
        l_pCardProvider = s_pFirst;

    } else {

        l_pCardProvider = s_pFirst;

        while (l_pCardProvider->m_pNext) {

            l_pCardProvider = l_pCardProvider->m_pNext;
        }

        l_pCardProvider->m_pNext = new CCardProvider;
        l_pCardProvider = l_pCardProvider->m_pNext;
    }

    (*in_pEntryFunction)(*l_pCardProvider);
}

BOOL
CCardProvider::CardsUntested(
    void
    )
{
    class CCardProvider *l_pCCardProvider = s_pFirst;

    while (l_pCCardProvider) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            return TRUE;
        }

        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }

    return FALSE;
}

void
CCardProvider::CardTest(
    class CReader& io_pCReader,
    ULONG in_uTestNo
    )
/*++

Routine Description:

    Calls every registered card provider in the list until one of
    the providers indicates that it recognized the card

Arguments:

    io_pCReader - reference to the test structure

Return Value:

    IFDSTATUS value

--*/
{
    class CCardProvider *l_pCCardProvider = s_pFirst;
    ULONG l_uStatus;

    while (l_pCCardProvider) {

        if ( l_pCCardProvider->IsValidAtr(io_pCReader.GetAtr()) ) {

            if (l_pCCardProvider->m_bCardTested) {

                // We tested this card already
                LogMessage("Card has been tested already. Please remove the card");
                return;
            }

            l_pCCardProvider->m_bCardTested = TRUE;
            LogMessage(
                "\nTesting card %s",
                (LPCSTR) l_pCCardProvider->m_CCardName
                );

            if (l_pCCardProvider->m_pSetProtocol == NULL) {

                return;
            }

            // Call card provider function
            l_uStatus = (*l_pCCardProvider->m_pSetProtocol)(
                *l_pCCardProvider,
                io_pCReader
                );

            if (l_uStatus == IFDSTATUS_END) {

                return;
            }

            if (l_uStatus != IFDSTATUS_SUCCESS) {

                return;
            }

            // Check if the card test function pointer exists
            if (l_pCCardProvider->m_pCardTest == NULL) {

                return;
            }

            if (in_uTestNo) {

            // user wants to run only a single test
                l_pCCardProvider->m_uTestNo = in_uTestNo;

                LogMessage("Test No. %2d", l_pCCardProvider->m_uTestNo);

                // Call card provider function
                l_uStatus = (*l_pCCardProvider->m_pCardTest)(
                    *l_pCCardProvider,
                    io_pCReader
                    );

                return;
            }

         // run the whole test set
            for (l_pCCardProvider->m_uTestNo = 1; ;l_pCCardProvider->m_uTestNo++) {

                LogMessage("Test No. %2d", l_pCCardProvider->m_uTestNo);

                // Call card provider function
                l_uStatus = (*l_pCCardProvider->m_pCardTest)(
                    *l_pCCardProvider,
                    io_pCReader
                    );

                if (l_uStatus != IFDSTATUS_SUCCESS) {

                    return;
                }
            }
        }
        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }

    PCHAR l_rgbAtrBuffer = new CHAR[256];

    LogMessage("Card unknown!");
    LogMessage("       CURRENT CARD");
    LogMessage("       %s", io_pCReader.GetAtrString(l_rgbAtrBuffer));

    for (l_pCCardProvider = s_pFirst;
         l_pCCardProvider;
         l_pCCardProvider = l_pCCardProvider->m_pNext) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            LogMessage("    *  %s", (LPCSTR) l_pCCardProvider->m_CCardName);
            for (int i = 0; i < MAX_NUM_ATR && l_pCCardProvider->m_CAtr[i].GetLength(); i++) {
        
                LogMessage("       %s", l_pCCardProvider->m_CAtr[i].GetAtrString(l_rgbAtrBuffer));
            }
        }
    }

   delete l_rgbAtrBuffer;

    LogMessage("Please remove card");
}

void
CCardProvider::ListUntestedCards(
    void
    )
/*++

Routine Description:
    Prints a list of all cards that have not been tested

--*/
{
    class CCardProvider *l_pCCardProvider = s_pFirst;

    while (l_pCCardProvider) {

        if (l_pCCardProvider->m_bCardTested == FALSE) {

            LogMessage("    *  %s", (LPCSTR) l_pCCardProvider->m_CCardName);
        }

        l_pCCardProvider = l_pCCardProvider->m_pNext;
    }
}

void
CCardProvider::SetAtr(
    BYTE in_rgbAtr[],
    ULONG in_uAtrLength
    )
/*++

Routine Description:
   Sets the ATR of the card

Arguments:
    in_rgchAtr - the atr string
    in_uAtrLength - length of the atr

--*/
{
    for (int i = 0; i < MAX_NUM_ATR; i++) {

        if (m_CAtr[i].GetLength() == 0) {

           m_CAtr[i] = CAtr(in_rgbAtr, in_uAtrLength);
           return;
        }
    }
}

void
CCardProvider::SetCardName(
    CHAR in_rgchCardName[]
    )
/*++

Routine Description:
    Sets a friendly name for the card

Arguments:
    in_rgchCardName - Friendly name for the card

--*/
{
    m_CCardName = in_rgchCardName;
}

void
CheckCardMonitor(
    CReader &in_CReader
    )
{
    ULONG l_lResult, l_uReplyLength, l_lTestNo = 1;
    time_t l_lStartTime;
    BOOL l_bResult;
    OVERLAPPED l_Ovr;
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

    LogMessage("=============================");
    LogMessage("Part A: Checking card monitor");
    LogMessage("=============================");

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();
    TestStart("%2d. %s", l_lTestNo++, INSERT_CARD);
    l_lResult = in_CReader.WaitForCardInsertion();
    TEST_CHECK_SUCCESS("Reader failed card insertion monitor", l_lResult);
    TestEnd();

    TestStart("%2d. IOCTL_SMARTCARD_IS_PRESENT", l_lTestNo++);
      l_bResult = DeviceIoControl (
        l_hReader,
      IOCTL_SMARTCARD_IS_PRESENT,
      NULL,
      0,
      NULL,
      0,
      &l_uReplyLength,
      &l_Ovr
        );

    TestCheck(
        l_bResult == TRUE,
        "DeviceIoControl should return TRUE with card inserted"
        );
    TestEnd();

    TestStart("%2d. %s", l_lTestNo++, REMOVE_CARD);
    l_lResult = in_CReader.WaitForCardRemoval();
    TEST_CHECK_SUCCESS("Reader failed card removal monitor", l_lResult);
    TestEnd();

    TestStart("%2d. IOCTL_SMARTCARD_IS_ABSENT", l_lTestNo++);
      l_bResult = DeviceIoControl (
        l_hReader,
      IOCTL_SMARTCARD_IS_ABSENT,
      NULL,
      0,
      NULL,
      0,
      &l_uReplyLength,
      &l_Ovr
        );

    TestCheck(
        l_bResult == TRUE,
        "DeviceIoControl should return TRUE with card removed"
        );
    TestEnd();

    TestStart("%2d. Insert and remove a smart card repeatedly", l_lTestNo++);

    for (l_lStartTime = time(NULL); time(NULL) - l_lStartTime < 15;) {

        l_lResult = in_CReader.ColdResetCard();
#ifdef insert_remove_alternate
          l_bResult = DeviceIoControl (
            l_hReader,
          IOCTL_SMARTCARD_IS_PRESENT,
          NULL,
          0,
          NULL,
          0,
          &l_uReplyLength,
          &l_Ovr
            );

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            l_hReader,
            &l_Ovr,
            &l_uReplyLength,
            FALSE
            );

        l_lResult = GetLastError();

        TestCheck(
            l_bResult == TRUE && l_lResult == ERROR_SUCCESS ||
            l_bResult == FALSE &&
            (l_lResult == ERROR_IO_INCOMPLETE ||
             l_lResult == ERROR_BUSY ||
             l_lResult == ERROR_IO_PENDING),
            "Reader failed card insertion monitor.\nReturned %2lxH",
            l_lResult
            );

          l_bResult = DeviceIoControl (
            l_hReader,
          IOCTL_SMARTCARD_IS_ABSENT,
          NULL,
          0,
          NULL,
          0,
          &l_uReplyLength,
          &l_Ovr
            );

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            l_hReader,
            &l_Ovr,
            &l_uReplyLength,
            FALSE
            );

        l_lResult = GetLastError();

        TestCheck(
            l_bResult == TRUE && l_lResult == ERROR_SUCCESS ||
            l_bResult == FALSE &&
            (l_lResult == ERROR_IO_INCOMPLETE ||
             l_lResult == ERROR_BUSY ||
             l_lResult == ERROR_IO_PENDING),
            "Reader failed card removal monitor:\nReturned %2lxH",
            l_lResult
            );
#endif
    }
#ifdef insert_remove_alternate
    l_bResult = GetOverlappedResult(
        l_hReader,
        &l_Ovr,
        &l_uReplyLength,
        TRUE
        );
#endif
    TestEnd();

    LogMessage("Press any key to continue");
    _getch();

    if (ReaderFailed()) {

        exit(-1);
    }
}

void
CheckReader(
    CReader &in_CReader
    )
/*++

Routine Description:

    Checks the attributes of a reader.
    Once with card inserted and then without

Arguments:

Return Value:

--*/
{
    BOOL l_bResult;
    ULONG l_iIndex, l_uReplyLength, l_lTestNo = 1, l_uStart, l_uEnd;
    OVERLAPPED l_Ovr;
    UCHAR l_rgbReplyBuffer[512];
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

#define ATTR(x) #x, x

    struct {

        PCHAR m_pchName;
        ULONG m_uType;

    } l_aAttr[] = {

        ATTR(SCARD_ATTR_VENDOR_NAME),
        ATTR(SCARD_ATTR_VENDOR_IFD_TYPE),
        ATTR(SCARD_ATTR_DEVICE_UNIT),
        ATTR(SCARD_ATTR_ATR_STRING),
        ATTR(SCARD_ATTR_DEFAULT_CLK),
        ATTR(SCARD_ATTR_MAX_CLK),
        ATTR(SCARD_ATTR_DEFAULT_DATA_RATE),
        ATTR(SCARD_ATTR_MAX_DATA_RATE),
        ATTR(SCARD_ATTR_MAX_IFSD),
        ATTR(SCARD_ATTR_CURRENT_PROTOCOL_TYPE),
        ATTR(SCARD_ATTR_PROTOCOL_TYPES),
        0, 0,
        ATTR(SCARD_ATTR_ATR_STRING),
        ATTR(SCARD_ATTR_CURRENT_PROTOCOL_TYPE)
    };

    LogMessage("=======================");
    LogMessage("Part B: Checking reader");
    LogMessage("=======================");

    BOOL l_bCardInserted = FALSE;
    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

    TestStart("%2d. Device name", l_lTestNo++);

    CString l_COperatingSystem = GetOperatingSystem();

    if (l_COperatingSystem == OS_WINNT4) {

        TestCheck(
            in_CReader.GetDeviceName().Left(12) == "\\\\.\\SCReader",
            "Device name is not NT 4.0 compliant"
            );

    } else if (l_COperatingSystem == OS_WIN95 ||
               l_COperatingSystem == OS_WIN98) {

        // there is no special naming convention for Win9x

    } else {

        TestCheck(
            in_CReader.GetDeviceName().Find("{50dd5230-ba8a-11d1-bf5d-0000f805f530}") != -1,
            "Device name is not WDM PnP compliant"
            );
    }
    TestEnd();

    TestStart(
        "%2d. Null pointer check",
        l_lTestNo++
        );

    for (l_iIndex = 0; l_aAttr[l_iIndex].m_pchName; l_iIndex++) {

      // try to crash reader by using null pointers as arguments
       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_ATTRIBUTE,
          &l_aAttr[l_iIndex].m_uType,
            sizeof(ULONG),
            NULL,
            1000,
           &l_uReplyLength,
          &l_Ovr
            );

        ULONG l_lResult = GetLastError();

        TestCheck(
            l_lResult == ERROR_INSUFFICIENT_BUFFER ||
            l_lResult == ERROR_BAD_COMMAND,
            "IOCTL_SMARTCARD_GET_ATTRIBUTE (%lxh) should fail\nReturned %2lxH (NTSTATUS %lxH)\nExpected %2lxH (NTSTATUS %lxH)\nor       %2lxH (NTSTATUS %lxH)",
            l_aAttr[l_iIndex].m_uType & 0xFFFF,
            l_lResult,
            MapWinErrorToNtStatus(l_lResult),
            ERROR_INSUFFICIENT_BUFFER,
            MapWinErrorToNtStatus(ERROR_BAD_COMMAND),
            ERROR_BAD_COMMAND,
            MapWinErrorToNtStatus(ERROR_BAD_COMMAND)
            );
   }
    TestEnd();

    for (l_iIndex = 0; l_iIndex < sizeof(l_aAttr) / sizeof(l_aAttr[0]); l_iIndex++) {

        if (l_aAttr[l_iIndex].m_pchName == 0) {

            TestStart("%2d. Close driver with I/O-request still pending", l_lTestNo++);

            // Check if the reader correctly terminates pending io-requests
              l_bResult = DeviceIoControl (
                l_hReader,
              IOCTL_SMARTCARD_IS_PRESENT,
              NULL,
              0,
              NULL,
              0,
              &l_uReplyLength,
              &l_Ovr
                );

            TestCheck(
                l_bResult == FALSE,
                "Wait for present succeeded with no card inserted"
                );

            // With the pending i/o request close and re-open the driver
            in_CReader.Close();
            l_bResult = in_CReader.Open();

            TestCheck(
                l_bResult,
                "Reader failed to terminate pending i/o request"
                );

            TestEnd();

            if (TestFailed()) {

                // If the open failed we can't contiue
                exit(GetLastError());
            }

            l_hReader = in_CReader.GetHandle();

            LogMessage("   >>  Please insert 'IBM PC/SC Compliance Test Card'");
            in_CReader.WaitForCardInsertion();
            l_bCardInserted = TRUE;

            // Cold reset
            TestStart("%2d. Cold reset", l_lTestNo++);
         l_uStart = clock();
            LONG l_lResult = in_CReader.ColdResetCard();
         l_uEnd = clock();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
         TestCheck(
            (l_uEnd - l_uStart) / CLOCKS_PER_SEC <= 2,
            "Cold reset took too long.\nElapsed time %ld sec\nExpected time %ld sec",
            (l_uEnd - l_uStart) / CLOCKS_PER_SEC,
            2
            );
            TestEnd();

            if (TestFailed()) {

                exit(l_lResult);
            }

            // Set protocol
            TestStart("%2d. Set protocol to T0 | T1", l_lTestNo++);
            l_lResult = in_CReader.SetProtocol(
                SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
                );
            TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
            TestEnd();
            continue;
        }

        TestStart("%2d. %s", l_lTestNo++, l_aAttr[l_iIndex].m_pchName);

        SetLastError(0);
        *(PULONG) l_rgbReplyBuffer = 0;

       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_ATTRIBUTE,
          &l_aAttr[l_iIndex].m_uType,
            sizeof(ULONG),
            l_rgbReplyBuffer,
            sizeof(l_rgbReplyBuffer),
          &l_uReplyLength,
          &l_Ovr
            );

        if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

            //
            // The I/O request returned pending, so
            // wait until the request is finished
            //
            SetLastError(0);

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_Ovr,
                &l_uReplyLength,
                TRUE
                );
        }

        if (GetLastError() != ERROR_SUCCESS) {

            l_bResult = FALSE;

        } else {

            l_rgbReplyBuffer[l_uReplyLength] = 0;
        }

        LONG l_lResult = GetLastError();

        switch (l_aAttr[l_iIndex].m_uType) {

            case SCARD_ATTR_VENDOR_NAME:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_VENDOR_NAME failed",
                    l_lResult
                    );
            TestCheck(
               strlen((PCHAR) l_rgbReplyBuffer) != 0,
               "No vendor name defined"
               );
                TestEnd();
               break;

            case SCARD_ATTR_VENDOR_IFD_TYPE:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_VENDOR_IFD_TYPE failed",
                    l_lResult
                    );
            TestCheck(
               strlen((PCHAR) l_rgbReplyBuffer) != 0,
               "No ifd type defined"
               );
                TestEnd();
               break;

            case SCARD_ATTR_DEVICE_UNIT:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEVICE_UNIT failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer < 4,
                    "Invalid value: %ld (0 - 3)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_ATR_STRING:
                if (l_bCardInserted) {

                    TEST_CHECK_SUCCESS(
                        "Ioctl SCARD_ATTR_ATR_STRING failed",
                        l_lResult
                        );

                } else {

                    TestCheck(
                        l_bResult == FALSE,
                        "Reader returned ATR with no card inserted"
                        );
                }
                TestEnd();
               break;

            case SCARD_ATTR_DEFAULT_CLK:
            case SCARD_ATTR_MAX_CLK:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEFAULT_CLK/SCARD_ATTR_MAX_CLK failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer >= 1000 && *(PULONG) l_rgbReplyBuffer <= 20000,
                    "Invalid value %ld (1000 - 20000)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_DEFAULT_DATA_RATE:
            case SCARD_ATTR_MAX_DATA_RATE:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_DEFAULT_DATA_RATE/SCARD_ATTR_MAX_DATA_RATE failed",
                    l_lResult
                    );
                TestEnd();
               break;

            case SCARD_ATTR_MAX_IFSD:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_MAX_IFSD failed",
                    l_lResult
                    );
                TestCheck(
                    *(PULONG) l_rgbReplyBuffer >= 1 && *(PULONG) l_rgbReplyBuffer <= 254,
                    "Invalid value: %ld (1 - 254)",
                    *(PULONG) l_rgbReplyBuffer
                    );
                TestEnd();
               break;

            case SCARD_ATTR_PROTOCOL_TYPES:
                TEST_CHECK_SUCCESS(
                    "Ioctl SCARD_ATTR_PROTOCOL_TYPES failed",
                    l_lResult
                    );

                // check if the reader at least supports T=0 and T=1
                TestCheck(
                    (*(PULONG) l_rgbReplyBuffer & SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1) ==
                    (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1),
                    "Reader must support T=0 and T=1"
                    );
                TestEnd();
                break;

            case SCARD_ATTR_CURRENT_PROTOCOL_TYPE:

                if (l_bCardInserted) {

                    TEST_CHECK_SUCCESS(
                        "Ioctl SCARD_ATTR_CURRENT_PROTOCOL_TYPE failed",
                        l_lResult
                        );

                    TestCheck(
                        *(PULONG) l_rgbReplyBuffer != 0,
                        "Reader returned no protocol"
                        );

                } else {

                    // Check that without a card the current protocol is set to 0
                    TestCheck(
                        l_bResult == FALSE,
                        "Ioctl SCARD_ATTR_CURRENT_PROTOCOL_TYPE failed should fail with no card inserted"
                        );
                }
                TestEnd();
                break;

            default:
                TestCheck(
                    l_bResult,
                    "Ioctl returned %lxh",
                    GetLastError()
                    );
                TestEnd();
                break;
        }
    }

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();
    LogMessage("   <<  Please insert smart card BACKWARDS");
    in_CReader.WaitForCardInsertion();

    TestStart("%2d. IOCTL_SMARTCARD_GET_STATE", l_lTestNo++);
    ULONG l_uState;

   l_bResult = DeviceIoControl (
      l_hReader,
      IOCTL_SMARTCARD_GET_STATE,
      NULL,
        0,
        &l_uState,
        sizeof(l_uState),
      &l_uReplyLength,
      &l_Ovr
        );

    LONG l_lResult = GetLastError();

    TestCheck(
        l_bResult,
        "IOCTL_SMARTCARD_GET_STATE failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
        l_lResult,
        MapWinErrorToNtStatus(l_lResult),
        ERROR_SUCCESS,
        MapWinErrorToNtStatus(ERROR_SUCCESS)
        );

    TestCheck(
        l_uState <= SCARD_SWALLOWED,
        "Invalid reader state.\nReturned %d\nExpected <= %d",
        l_uState,
        SCARD_SWALLOWED
        );

    TestEnd();

    TestStart("%2d. Cold reset", l_lTestNo++);
   l_uStart = clock();
    l_lResult = in_CReader.ColdResetCard();
   l_uEnd = clock();

    TestCheck(
        l_lResult == ERROR_UNRECOGNIZED_MEDIA,
        "Cold reset failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
        l_lResult,
        MapWinErrorToNtStatus(l_lResult),
        ERROR_UNRECOGNIZED_MEDIA,
        MapWinErrorToNtStatus(ERROR_UNRECOGNIZED_MEDIA)
        );

   TestCheck(
      (l_uEnd - l_uStart) / CLOCKS_PER_SEC <= 2,
      "Cold reset took too long.\nElapsed time %ld sec\nExpected time %ld sec",
      (l_uEnd - l_uStart) / CLOCKS_PER_SEC,
      2
      );

    TestEnd();
}

void
SimulateResMngr(
    CReader &in_CReader
    )
{
    BOOL l_bWaitForPresent = FALSE, l_bWaitForAbsent = FALSE, l_bResult;
    BOOL l_bMustWait = FALSE, l_bPoweredDown = FALSE;
    ULONG l_uState, l_uStatus, l_uReplyLength, l_uStateExpected = SCARD_ABSENT, l_lTestNo = 1;
    ULONG l_uMinorIoctl;
    OVERLAPPED l_Ovr, l_OvrWait;
    HANDLE l_hReader = in_CReader.GetHandle();

    l_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_Ovr.hEvent);

    l_OvrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(l_OvrWait.hEvent);

    LogMessage("===================================");
    LogMessage("Part C: Resource Manager Simulation");
    LogMessage("===================================");

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

    while (TRUE) {

        TestStart("%2d. IOCTL_SMARTCARD_GET_STATE", l_lTestNo++);

       l_bResult = DeviceIoControl (
          l_hReader,
          IOCTL_SMARTCARD_GET_STATE,
          NULL,
            0,
            &l_uState,
            sizeof(l_uState),
          &l_uReplyLength,
          &l_Ovr
            );

        LONG l_lResult = GetLastError();

        TestCheck(
            l_bResult,
            "IOCTL_SMARTCARD_GET_STATE failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
            l_lResult,
            MapWinErrorToNtStatus(l_lResult),
            ERROR_SUCCESS,
            MapWinErrorToNtStatus(ERROR_SUCCESS)
            );

        TestEnd();

        if (l_bWaitForPresent) {

            TestStart("%2d. %s", l_lTestNo++, INSERT_CARD);

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_OvrWait,
                &l_uReplyLength,
                TRUE
                );

            l_lResult = GetLastError();

            TestCheck(
                l_bResult,
                "Card insertion monitor failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                l_lResult,
                MapWinErrorToNtStatus(l_lResult),
                ERROR_SUCCESS,
                MapWinErrorToNtStatus(ERROR_SUCCESS)
                );
                l_lResult = GetLastError();

            TestEnd();

            l_bWaitForPresent = FALSE;
            continue;
        }

        if (l_bWaitForAbsent) {

            if (l_bMustWait) {

                TestStart("%2d. %s", l_lTestNo++, REMOVE_CARD);

            } else {

                TestStart("%2d. GetOverlappedResult", l_lTestNo++);
            }

            l_bResult = GetOverlappedResult(
                l_hReader,
                &l_OvrWait,
                &l_uReplyLength,
                l_bMustWait
                );

            if (l_bMustWait == FALSE) {

                TestCheck(
                    l_bResult == FALSE,
                    "Smart card not removed"
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

            } else {

                l_lResult = GetLastError();

                TestCheck(
                    l_bResult,
                    "Card removal monitor failed.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                    l_lResult,
                    MapWinErrorToNtStatus(l_lResult),
                    ERROR_SUCCESS,
                    MapWinErrorToNtStatus(ERROR_SUCCESS)
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }
                l_bWaitForAbsent = FALSE;
                continue;
            }
        }

        TestStart("%2d. Checking reader status", l_lTestNo++);

        switch (l_uState) {

            case SCARD_UNKNOWN:
                TestCheck(FALSE, "Reader returned illegal state SCARD_UNKNOWN");
                TestEnd();
                return;

            case SCARD_ABSENT:
                TestCheck(
                    l_uStateExpected == SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                if (l_bMustWait) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_IS_PRESENT", l_lTestNo++);

               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_IS_PRESENT,
                  NULL,
                    0,
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_OvrWait
                    );

                TestCheck(
                    GetLastError() == ERROR_IO_PENDING,
                    "Monitor is supposed to return ERROR_IO_PENDING (%lxh)",
                    GetLastError()
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                l_bWaitForPresent = TRUE;
                l_uStateExpected = SCARD_PRESENT;
             break;

            case SCARD_PRESENT:
            case SCARD_SWALLOWED:
            case SCARD_POWERED:
                if (l_bPoweredDown) {

                    TestCheck(
                        l_uStateExpected <= SCARD_POWERED,
                        "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                        l_uState,
                        l_uStateExpected
                        );

                    TestEnd();

                    if (TestFailed()) {

                        return;
                    }

                    l_bMustWait = TRUE;
                    l_uStateExpected = SCARD_ABSENT;
                    break;
                }

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_IS_ABSENT", l_lTestNo++);
               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_IS_ABSENT,
                  NULL,
                    0,
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_OvrWait
                    );

                l_lResult = GetLastError();

                TestCheck(
                    l_bResult == FALSE,
                    "IOCTL_SMARTCARD_IS_ABSENT should fail.\nReturned %8lxH (NTSTATUS %8lxH).\nExpected %8lxH (NTSTATUS %8lxH)",
                    l_lResult,
                    MapWinErrorToNtStatus(l_lResult),
                    ERROR_IO_PENDING,
                    MapWinErrorToNtStatus(ERROR_IO_PENDING)
                    );

                TestEnd();

                l_bWaitForAbsent = TRUE;
                TestStart("%2d. Cold reset card", l_lTestNo++);
                l_uStatus = in_CReader.ColdResetCard();
                TEST_CHECK_SUCCESS("ColdReset", l_uStatus)
                l_uStateExpected = SCARD_NEGOTIABLE;

                TestEnd();

                if (TestFailed()) {

                    return;
                }
             break;

            case SCARD_NEGOTIABLE:
                TestCheck(
                    l_bPoweredDown == FALSE,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    SCARD_PRESENT
                    );

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nCurrent state = %d\nExpected state <= %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. Set protocol to T0 | T1", l_lTestNo++);

                l_uStatus = in_CReader.SetProtocol(
                    SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
                    );

                TestCheck(
                    l_uStatus == ERROR_SUCCESS,
                    "Protocol selection failed with error %lxh",
                    GetLastError()
                    );
                TestEnd();

                if (TestFailed()) {

                    return;
                }
                l_uStateExpected = SCARD_SPECIFIC;
             break;

            case SCARD_SPECIFIC:
                TestCheck(
                    l_bPoweredDown == FALSE,
                    "Invalid reader state.\nCurrent state = %d\nExpected state = %d",
                    l_uState,
                    SCARD_PRESENT
                    );

                TestCheck(
                    l_uStateExpected > SCARD_ABSENT,
                    "Invalid reader state.\nReturned %d\nExpected < %d",
                    l_uState,
                    l_uStateExpected
                    );

                TestEnd();

                if (TestFailed()) {

                    return;
                }

                TestStart("%2d. IOCTL_SMARTCARD_POWER (SCARD_POWER_DOWN)", l_lTestNo++);
                l_uMinorIoctl = SCARD_POWER_DOWN;
                SetLastError(0);
               l_bResult = DeviceIoControl (
                  l_hReader,
                  IOCTL_SMARTCARD_POWER,
                  &l_uMinorIoctl,
                    sizeof(l_uMinorIoctl),
                    NULL,
                    0,
                  &l_uReplyLength,
                  &l_Ovr
                    );

                if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

                    SetLastError(0);

                    l_bResult = GetOverlappedResult(
                        l_hReader,
                        &l_Ovr,
                        &l_uReplyLength,
                        TRUE
                        );
                }

                l_lResult = GetLastError();

                TEST_CHECK_SUCCESS("IOCTL_SMARTCARD_POWER failed", l_lResult);
                TestEnd();

                l_uStateExpected = SCARD_PRESENT;
                l_bPoweredDown = TRUE;
             break;

            default:
               TestCheck(
                    FALSE,
                    "Reader returned invalid state %d",
                    l_uState
                    );
                TestEnd();
                return;
        }
    }
}

void
PowerManagementTest(
    CReader &in_CReader,
   ULONG in_uWaitTime
    )
{
   LONG l_lResult;
   ULONG l_uState, l_uPrevState, l_uRepeat;
   ULONG l_uDuration = 30;

   if (in_uWaitTime > 30 && in_uWaitTime < 120) {

      l_uDuration = in_uWaitTime;
   }

    LogMessage("=============================");
    LogMessage("Part E: Power Management Test");
    LogMessage("=============================");

   LogMessage("Note: Each test cycle takes %ld seconds!", l_uDuration);
    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

   LogMessage("Test 1: DO NOT INSERT smart card during hibernate mode");
    TestStart("Card out / card out - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardInsertion();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TestCheck(
        l_lResult == ERROR_IO_INCOMPLETE,
        "GetOverlappedResult failed\nReturned %8lx\nExpected %8lx",
      l_lResult,
      ERROR_IO_INCOMPLETE
        );

    TestEnd();

   TestStart("%s", INSERT_CARD);
   l_lResult = in_CReader.FinishWaitForCard(TRUE);
   TEST_CHECK_SUCCESS("Reader failed card insertion", l_lResult);
   TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState > SCARD_ABSENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

   //
   // Test 2
   //

   LogMessage("Test 2: REMOVE smart card DURING hibernate mode");
    TestStart("Card in / card out - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardRemoval();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState == SCARD_ABSENT,
        "Invalid reader state.\nReturned %d\nExpected %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

    LogMessage("   >>  %s", INSERT_CARD);
    in_CReader.WaitForCardInsertion();

   //
   // Test 3
   //
   LogMessage("Test 3: DO NOT REMOVE smart card during hibernate mode");
    TestStart("Card in / card in - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardRemoval();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");

   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState >= SCARD_PRESENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();

    LogMessage("   <<  %s", REMOVE_CARD);
    in_CReader.WaitForCardRemoval();

   //
   // Test 4
   //

   LogMessage("Test 4: INSERT smart card DURING hibernate mode");
    TestStart("Card out / card in - Hibernate now");

   l_lResult = in_CReader.StartWaitForCardInsertion();
    l_lResult = in_CReader.GetState(&l_uPrevState);

    for (l_uRepeat = 0; l_uRepeat < l_uDuration; l_uRepeat++) {

        l_lResult = in_CReader.GetState(&l_uState);

        LONG l_uGoal = clock() + CLOCKS_PER_SEC;
        while(l_uGoal > clock())
            ;
      printf("\x08\x08%2ld", l_uDuration - l_uRepeat);
   }
   printf("\x08\x08  ");
   l_lResult = in_CReader.FinishWaitForCard(FALSE);

    TEST_CHECK_SUCCESS(
        "GetOverlappedResult failed",
      l_lResult
        );

    TestEnd();

    TestStart("Checking reader status");
    l_lResult = in_CReader.GetState(&l_uState);
   TEST_CHECK_SUCCESS("Reader failed IOCTL_SMARTCARD_GET_STATE", l_lResult);

    TestCheck(
        l_uState >= SCARD_PRESENT,
        "Invalid reader state.\nReturned %d\nExpected > %d",
        l_uState,
        SCARD_ABSENT
        );
   TestEnd();
}

class CArgv {

    int m_iArgc;
    char **m_pArgv;
    BOOL *m_pfRef;

public:

    CArgv(int in_iArgc, char **in_pArgv);

    int OptionExist(PCHAR);

    PCHAR ParameterExist(PCHAR);

    PCHAR CheckParameters(CString);

    PCHAR CArgv::ParameterUnused(void);
};


CArgv::CArgv(
    int in_iArgc,
    char **in_pArgv
    )
{
    m_iArgc = in_iArgc;
    m_pArgv = in_pArgv;
    m_pfRef = new BOOL[in_iArgc];
    memset(m_pfRef, 0, sizeof(BOOL) * in_iArgc);
}

CArgv::OptionExist(
    PCHAR in_pchParameter
    )
{
    for (int i = 0; i < m_iArgc; i++) {

        if (m_pArgv[i][0] == '-' || m_pArgv[i][0] == '/') {

            int j = 1;

            while (m_pArgv[i][j] && m_pArgv[i][j] != ' ') {

                if (strncmp(m_pArgv[i] + j, in_pchParameter, strlen(m_pArgv[i] + j)) == 0) {

                    m_pfRef[i] = TRUE;
                    return i;
                }

                j++;
            }
        }
    }

    return 0;
}

PCHAR
CArgv::ParameterExist(
    PCHAR in_pchParameter
    )
{
    if (int i = OptionExist(in_pchParameter)) {

        m_pfRef[i + 1] = TRUE;
        return m_pArgv[i + 1];
    }

    return NULL;
}

PCHAR
CArgv::CheckParameters(
    CString in_CParameters
    )
/*++

Routine Description:
    Checks if the command line includes in invalid/unknown parameter

--*/
{
    int i, l_iPos;

    for (i = 1; i < m_iArgc; i++) {

        if ((l_iPos = in_CParameters.Find(m_pArgv[i])) == -1) {

            return m_pArgv[i];
        }

        if (l_iPos + 3 < in_CParameters.GetLength() &&
            in_CParameters[l_iPos + 3] == '*') {

            // skip the next parameter
            i += 1;
        }
    }
    return NULL;
}

PCHAR
CArgv::ParameterUnused(
    void
    )
{
    int i;

    for (i = 1; i < m_iArgc; i++) {

        if (m_pfRef[i] == FALSE) {

            return m_pArgv[i];
        }
    }
    return NULL;
}

CString &
GetOperatingSystem(
    void
    )
{
    static CString l_COperatingSystem;
    OSVERSIONINFO VersionInformation;

    if (l_COperatingSystem.GetLength() == 0) {

        VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (GetVersionEx(&VersionInformation) == FALSE) {

            l_COperatingSystem += "Unknown";

        } else {

            if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {

                if (VersionInformation.dwMinorVersion == 0) {

                    l_COperatingSystem += OS_WIN95;

                } else {

                    l_COperatingSystem += OS_WIN98;
                }

            } else if (VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT) {

                if (VersionInformation.dwMajorVersion <= 4) {

                    l_COperatingSystem += OS_WINNT4;

                } else {

                    l_COperatingSystem += OS_WINNT5;
                }

            } else {

                l_COperatingSystem += "Unknown";
            }
        }
    }

    return l_COperatingSystem;
}

CString &
SelectReader(
    void
    )
{
    CReaderList l_CReaderList;
    ULONG l_uIndex, l_uReader;
    ULONG l_uNumReaders = l_CReaderList.GetNumReaders();
   static CString l_CEmpty("");

    if (l_uNumReaders == 0) {

      return l_CEmpty;
    }

    if (l_uNumReaders == 1) {

        return l_CReaderList.GetDeviceName(0);
    }

    CString l_CLetter;

    printf("\n");
    printf(" Vendor                  IfdType                  Type\n");
    printf(" -----------------------------------------------------\n");

    for (l_uIndex = 0; l_uIndex < l_uNumReaders; l_uIndex++) {

        INT l_iLetterPos;
        INT l_iLength = l_CReaderList.GetVendorName(l_uIndex).GetLength();
        CString l_CVendorName = l_CReaderList.GetVendorName(l_uIndex);

        for (l_iLetterPos = 0;
             l_iLetterPos < l_CVendorName.GetLength();
             l_iLetterPos++) {

            CHAR l_chLetter = l_CVendorName[l_iLetterPos];

            if (l_chLetter == ' ' || l_chLetter == 'x') {

                continue;
            }

            if (l_CLetter.Find(l_chLetter) == -1) {

                l_CLetter += l_chLetter;
                break;
            }
        }
        if (l_iLetterPos >= l_iLength) {

            l_CVendorName += (CHAR) (l_uIndex + '0') ;
            l_iLetterPos = l_iLength;
        }

        printf(
            " %s[%c]%-*s %-20s %8s\n",
            (LPCSTR) l_CVendorName.Left(l_iLetterPos),
            l_CVendorName[l_iLetterPos],
            20 - l_iLetterPos,
            l_CVendorName.Right(l_iLength - l_iLetterPos - 1),
            (LPCSTR) l_CReaderList.GetIfdType(l_uIndex),
            (LPCSTR) l_CReaderList.GetPnPType(l_uIndex)
            );
    }

    putchar('\n');
    do {

        printf("\rSelect reader:  \010");

        CHAR l_chInput = (CHAR) _getche();
      if (l_chInput == 3) {

         exit(-1);
      }

      l_uReader = l_CLetter.Find(l_chInput);

    } while(l_uReader == -1);

    printf("\n");

    return l_CReaderList.GetDeviceName(l_uReader);
}

CString
SelectReader(
    CString &in_CVendorName
    )
{
    CReaderList l_CReaderList;
    ULONG l_uIndex;
    ULONG l_uNumReaders = l_CReaderList.GetNumReaders();
    CString l_CVendorName = in_CVendorName;

    l_CVendorName.MakeLower();

    for (l_uIndex = 0; l_uIndex < l_uNumReaders; l_uIndex++) {

        CString l_CVendorListName = l_CReaderList.GetVendorName(l_uIndex);
        l_CVendorListName.MakeLower();

        if (l_CVendorListName.Find(l_CVendorName) != -1) {

            return l_CReaderList.GetDeviceName(l_uIndex);
        }
    }

    return CString("");
}



//**********************************************************************
// 
//  StopService()
// 
//  PURPOSE :     This function attempts to stop a service. It will fail
//				  the service has any dependent services.
//                It also allows a timeout
//                value to be passed, to prevent a scenario in which a
//                service shutdown hangs, and in turn the application
//                stopping the service hangs.
// 
//  PARAMETERS:   hSCM - open handle to the service control manager
//                hService - open handle to the service to be stopped
//                dwTimeout - maximum time (in milliseconds) to wait
//                   for the service and its dependencies to stop
// 
//  RETURN VALUE: TRUE if the service is successfully stopped
// 
//**********************************************************************

BOOL StopService( SC_HANDLE hSCM, SC_HANDLE hService, 
      DWORD dwTimeout ) {

   SERVICE_STATUS ss;
   DWORD dwStartTime = GetTickCount();

   // Make sure the service is not already stopped
   if ( !QueryServiceStatus( hService, &ss ) )
      return FALSE;

   if ( ss.dwCurrentState == SERVICE_STOPPED ) 
      return FALSE;

   // If a stop is pending, just wait for it
   while ( ss.dwCurrentState == SERVICE_STOP_PENDING ) {

      Sleep( 5000 );
      if ( !QueryServiceStatus( hService, &ss ) )
         return FALSE;

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         return FALSE;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return FALSE;
   }

   // Send a stop code to service
   if ( !ControlService( hService, SERVICE_CONTROL_STOP, &ss ) )
      return FALSE;

   // Wait for the service to stop
   while ( ss.dwCurrentState != SERVICE_STOPPED ) {

      Sleep( 5000 );
      if ( !QueryServiceStatus( hService, &ss ) )
         return FALSE;

      if ( ss.dwCurrentState == SERVICE_STOPPED )
         break;

      if ( GetTickCount() - dwStartTime > dwTimeout )
         return FALSE;
   }

   // Return success
   return TRUE;
}


__cdecl
main(
    int argc,
    char* argv[]
    )
{
    CArgv l_CArgv(argc, argv);
    BOOL l_bSuccess, l_fInvalidParameter = FALSE;
	BOOL l_bStoppedScardsvr = FALSE;		// true==> we succesfully stoped scardsvr service
	SC_HANDLE l_hSCM = NULL;
	SC_HANDLE l_hService = NULL;
   
    LogMessage("Smart Card Reader Test Suite");
    LogMessage("Version 2.0.5");
    LogMessage("Copyright(c) Microsoft Corporation 1997 - 1999");

    if(PCHAR l_pchArgv = l_CArgv.CheckParameters("-d -e -h -m -r * -sa -sb -sc -sd -se -t * -v * -w *")) {

        LogMessage("Invalid Parameter '%s'", l_pchArgv);
        l_fInvalidParameter = TRUE;
    }

    if (l_fInvalidParameter ||

        l_CArgv.OptionExist("h")) {

        LogMessage("IfdTest [-d] [-m] [-r name] [-sa] [-sb] [-sc] [-sd] [-se] [-ss] [-w sec] [-t test] [-v name]\n");
        LogMessage("   -d        dumps all i/o");
        LogMessage("   -e        ends (stops) scardsvr service");
        LogMessage("   -m        manual test");
        LogMessage("   -r name   opens reader using device name");
        LogMessage("   -sa       skips card monitor test");
        LogMessage("   -sb       skips general reader test");
        LogMessage("   -sc       skips resource manager simulation");
        LogMessage("   -sd       skips card tests");
        LogMessage("   -se       skips power management tests");
        LogMessage("   -v name   opens reader using vendor name");
        LogMessage("   -t test   runs only specific card test in part d");
        LogMessage("   -w sec    runs power management test using specified waiting time");
        exit(-1);
    }

    static CReader l_CReader;
    CString l_CDeviceName;

	//
	// sandysp 5/9/01: stop scardsvr service because open will fail if it's running
	//

	if (l_CArgv.OptionExist("e")) {
		l_hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );
		if (l_hSCM) {

			// Open the specified service
			l_hService = OpenService( l_hSCM, 
									  "scardsvr", 
									  SERVICE_STOP | SERVICE_START | SERVICE_QUERY_STATUS );
			if (l_hService) {
				// Try to stop the service, specifying a 30 second timeout
				l_bStoppedScardsvr = StopService( l_hSCM, l_hService, 30000 ) ;
			}
		}
	}

    if (PCHAR l_pchReader = l_CArgv.ParameterExist("r")) {

      l_CDeviceName = CString("\\\\.\\") + CString(l_pchReader);

    } else if (PCHAR l_pchVendorName = l_CArgv.ParameterExist("v")) {

        CReaderList l_CReaderList;
        l_CDeviceName = SelectReader(CString(l_pchVendorName));

    } else {

        CReaderList l_CReaderList;
        l_CDeviceName = SelectReader();
    }

    if (l_CDeviceName == "") {

        LogMessage("No reader found");
        exit (-1);
    }
	
	l_bSuccess = l_CReader.Open(l_CDeviceName);

    LogMessage(".");
    if (l_bSuccess == FALSE) {

        LogMessage("Can't open smart card reader");
        exit (-1);
    }

    if (l_CArgv.OptionExist("d")) {

        l_CReader.SetDump(TRUE);
    }

    void ManualTest(CReader &in_CReader);
    if (l_CArgv.OptionExist("m")) {

        ManualTest(l_CReader);
    }

    CCardProvider l_CCardProvider;

    LogOpen("ifdtest");

    time_t l_osBinaryTime;
    time( &l_osBinaryTime );
    CTime l_CTime( l_osBinaryTime );

    LogMessage("Vendor: %s", l_CReader.GetVendorName());
    LogMessage("Reader: %s", l_CReader.GetIfdType());
    LogMessage(
        "Date:   %d/%02d/%02d",
        l_CTime.GetMonth(),
        l_CTime.GetDay(),
        l_CTime.GetYear()
        );
    LogMessage(
        "Time:   %d:%02d",
        l_CTime.GetHour(),
        l_CTime.GetMinute()
        );
    LogMessage("OS:     %s", (LPCSTR) GetOperatingSystem());

    //
    // Check if the reader properly supports
    // card insertion and removal
    //
    if (l_CArgv.OptionExist("sa")) {

        LogMessage("=================================");
        LogMessage("Part A: Card monitor test skipped");
        LogMessage("=================================");

    } else {

        CheckCardMonitor(l_CReader);
    }

    if (l_CArgv.OptionExist("sb")) {

        LogMessage("===========================");
        LogMessage("Part B: Reader test skipped");
        LogMessage("===========================");

    } else {

        CheckReader(l_CReader);
    }

    if (l_CArgv.OptionExist("sc")) {

        LogMessage("===========================================");
        LogMessage("Part C: Resource Manager Simulation skipped");
        LogMessage("===========================================");

    } else {

        // Check res manager behavior
        SimulateResMngr(l_CReader);
    }

    if (l_CArgv.OptionExist("sd")) {

        LogMessage("========================================");
        LogMessage("Part D: Smart Card Provider Test skipped");
        LogMessage("========================================");

    } else {

        ULONG l_uTestNo = 0;
        PCHAR l_pchTestNo;

        if (l_pchTestNo = l_CArgv.ParameterExist("t")) {

            // The user wants us to run only one test
            l_uTestNo = atoi(l_pchTestNo);
        }

        while (l_CCardProvider.CardsUntested()) {

            LogMessage("================================");
            LogMessage("Part D: Smart Card Provider Test");
            LogMessage("================================");

            LogMessage("Insert any of the following PC/SC Compliance Test Cards:");
            l_CCardProvider.ListUntestedCards();

            LogMessage("   >>  %s", INSERT_CARD);
            if (l_CReader.WaitForCardInsertion() != ERROR_SUCCESS) {

                LogMessage("Reader failed card insertion monitor");
                return -1;
            }

            // Reset the card
            if (l_CReader.ColdResetCard() != ERROR_SUCCESS) {

                LogMessage("Unable to reset smart card");

            } else {

                // Try to run tests with this card
                l_CCardProvider.CardTest(l_CReader, l_uTestNo);

                if (l_uTestNo != 0) {

                    // Quit the program if we only run one test.
                    return 0;
                }
            }

            LogMessage("   <<  %s", REMOVE_CARD);
            if (l_CReader.WaitForCardRemoval() != ERROR_SUCCESS) {

                LogMessage("Reader failed card removal monitor");
                return -1;
            }
        }
   }

   if (GetOperatingSystem() == OS_WINNT5) {

      if (l_CArgv.OptionExist("se")) {

         LogMessage("=====================================");
         LogMessage("Part E: Power Management Test skipped");
         LogMessage("=====================================");

      } else {

         ULONG l_uWaitTime = 0;

         if (PCHAR l_pchWaitTime = l_CArgv.ParameterExist("w")) {

            // The user wants us to run only one test
            l_uWaitTime = atoi(l_pchWaitTime);
         }

         PowerManagementTest(l_CReader, l_uWaitTime);
      }
   }

   //
   // Sandysp 5/9/01: restart smart card reader service if we stopped it
   //
   if (l_bStoppedScardsvr) {
	   StartService( l_hService, 0, NULL );
   }
   if ( l_hService )
	   CloseServiceHandle( l_hService );

   if ( l_hSCM )
	   CloseServiceHandle( l_hSCM );

   
   LogMessage("Reader %s the test", (ReaderFailed() ? "failed" : "passed"));
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ifdrdr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdrdr.cpp
//
//--------------------------------------------------------------------------

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <conio.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

ULONG CReaderList::m_uRefCount;
ULONG CReaderList::m_uNumReaders;
CReaderList **CReaderList::m_pList;
static CString l_CEmpty("");

void
DumpData(
    PCHAR in_pchCaption,
    ULONG in_uIndent,
    PBYTE in_pbData,
    ULONG in_uLength) 
{
    ULONG l_uIndex, l_uLine, l_uCol;

    printf("%s\n%*s%04x: ", in_pchCaption, in_uIndent, "", 0);

    for (l_uLine = 0, l_uIndex = 0; 
         l_uLine < ((in_uLength - 1) / 8) + 1; 
         l_uLine++) {

        for (l_uCol = 0, l_uIndex = l_uLine * 8; 
             l_uCol < 8; l_uCol++, 
             l_uIndex++) {
        
            printf(
                l_uIndex < in_uLength ? "%02x " : "   ",
                in_pbData[l_uIndex]
                );
        }

        putchar(' ');

        for (l_uCol = 0, l_uIndex = l_uLine * 8; 
             l_uCol < 8; l_uCol++, 
             l_uIndex++) {

            printf(
                l_uIndex < in_uLength ? "%c" : " ",
                isprint(in_pbData[l_uIndex]) ? in_pbData[l_uIndex] : '.'
                );
        }

        putchar('\n');
	    if (l_uIndex  < in_uLength) {

            printf("%*s%04x: ", in_uIndent, "", l_uIndex + 1);
	    }
    }
}

CReaderList::CReaderList(
    CString &in_CDeviceName,
    CString &in_CPnPType,
	CString &in_CVendorName,
	CString &in_CIfdType
    )
{
    m_CDeviceName += in_CDeviceName;
    m_CPnPType += in_CPnPType;
    m_CVendorName += in_CVendorName;
    m_CIfdType += in_CIfdType;
}

CString &
CReaderList::GetDeviceName(
    ULONG in_uIndex
    )
/*++

Routine Description:	
	Retrieves the device name of a reader

Arguments:
	in_uIndex - index to reader list

Return Value:
	The device name that can be used to open the reader

--*/
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CDeviceName;
}

CString &
CReaderList::GetIfdType(
    ULONG in_uIndex
    )
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CIfdType;
}

CString &
CReaderList::GetPnPType(
    ULONG in_uIndex
    )
{ 	
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CPnPType;
}

CString &
CReaderList::GetVendorName(
    ULONG in_uIndex
    )
{
	if (in_uIndex >= m_uNumReaders) {

		return l_CEmpty;
	}

    return m_pList[in_uIndex]->m_CVendorName;
}

void
CReaderList::AddDevice(
    CString in_CDeviceName,
    CString in_CPnPType
    )
/*++

Routine Description:
	This functions tries to open the reader device supplied by
	in_pchDeviceName. If the device exists it adds it to the list
	of installed readers
	
Arguments:
	in_pchDeviceName - reader device name
	in_pchPnPType - type of reader (wdm-pnp, nt, win9x)

--*/
{ 	
    CReader l_CReader;

    if (l_CReader.Open(in_CDeviceName)) {

		if (l_CReader.GetVendorName().IsEmpty()) {

			LogMessage(
				"VendorName of reader device %s is NULL",
				(LPCSTR) in_CDeviceName
				);		 	

		} else if (l_CReader.GetIfdType().IsEmpty()) {
		 	
			LogMessage(
				"IfdType of reader device %s is NULL",
				(LPCSTR) in_CDeviceName
				);		 	

		} else {
		 	
			CReaderList *l_CReaderList = new CReaderList(
				in_CDeviceName,
				in_CPnPType,
				l_CReader.GetVendorName(),
				l_CReader.GetIfdType()
				);

			// extend the device list array by one
			CReaderList **l_pList = 
				new CReaderList *[m_uNumReaders + 1];

			if (m_pList) {

				// copy old list of readers to new list of readers
				memcpy(
					l_pList, 
					m_pList, 
					m_uNumReaders * sizeof(CReaderList *)
					);

				delete m_pList;
			}

			m_pList = l_pList;
			m_pList[m_uNumReaders++] = l_CReaderList;
		}

        l_CReader.Close();
    } 	
}

CReaderList::CReaderList() 
/*++

Routine Description:
	Constructor for CReaderList.	
	Builds a list of currently installed and running smart card readers.
	It first tries to find all WDM PnP drivers. These should be registered
	in the registry under the class guid for smart card readers.

	Then it looks for all 'old style' reader names like \\.\SCReaderN

	And then it looks for all Windows 9x VxD style readers, which are
	registered in the registry through smclib.vxd

--*/
{ 	
    HKEY l_hKey;
    ULONG l_uIndex;

    m_uCurrentReader = (ULONG) -1;

	if (m_uRefCount++ != 0) {

		return;	 	
	}

    // look up all WDM PnP smart card readers
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\DeviceClasses\\{50DD5230-BA8A-11D1-BF5D-0000F805F530}",
        &l_hKey) == ERROR_SUCCESS) {

        ULONG l_uStatus, l_uIndex;

        for (l_uIndex = 0; ;l_uIndex++) {

            HKEY l_hDeviceTypeKey;
            UCHAR l_rgchDeviceTypeKey[128];
            ULONG l_uDeviceTypeInstance = 0;

            // look up 'device type subkey'
            l_uStatus = RegEnumKey(  
                l_hKey,   
                l_uIndex, 
                (PCHAR) l_rgchDeviceTypeKey, 
                sizeof(l_rgchDeviceTypeKey)
                );

            if (l_uStatus != ERROR_SUCCESS) {

                // no smart card device types found 
                break;
            }

            // open the found 'device type subkey'
            l_uStatus = RegOpenKey(  
                l_hKey,    
                (PCHAR) l_rgchDeviceTypeKey,
                &l_hDeviceTypeKey
                );
        
            if (l_uStatus != ERROR_SUCCESS) {

                continue;
            }

            for (l_uDeviceTypeInstance = 0; ; l_uDeviceTypeInstance++) {

                DWORD l_dwKeyType;
                HKEY l_hDeviceTypeInstanceKey;
                UCHAR l_rgchDeviceName[128];
                UCHAR l_rgchDeviceTypeInstanceKey[128];
                ULONG l_uDeviceNameLen = sizeof(l_rgchDeviceName);
         	    
                // look up device instance subkey
                l_uStatus = RegEnumKey(  
                    l_hDeviceTypeKey,   
                    l_uDeviceTypeInstance, 
                    (PCHAR) l_rgchDeviceTypeInstanceKey, 
                    sizeof(l_rgchDeviceTypeInstanceKey)
                    );

                if (l_uStatus != ERROR_SUCCESS) {

                    // no instance of the smart card reader type found
                    break;
                }

                // open the found 'device type instance subkey'
                l_uStatus = RegOpenKey(  
                    l_hDeviceTypeKey,
                    (PCHAR) l_rgchDeviceTypeInstanceKey,
                    &l_hDeviceTypeInstanceKey
                    );

                if (l_uStatus != ERROR_SUCCESS) {

                    continue;
                }

                // get the name of the device
                if (RegQueryValueEx(
                    l_hDeviceTypeInstanceKey,
                    "SymbolicLink",
                    NULL,
                    &l_dwKeyType,
                    l_rgchDeviceName,
                    &l_uDeviceNameLen) == ERROR_SUCCESS) {

                    AddDevice(l_rgchDeviceName, READER_TYPE_WDM);
                }
            }
        }
    }

    // Now look up all non PnP readers
    for (l_uIndex = 0; l_uIndex < MAXIMUM_SMARTCARD_READERS; l_uIndex++) {

        UCHAR l_rgchDeviceName[128];

        sprintf(
            (PCHAR) l_rgchDeviceName, 
            "\\\\.\\SCReader%d", 
            l_uIndex
            );

        AddDevice(l_rgchDeviceName, READER_TYPE_NT);
    }

    // Add all Windows95 type readers to the list
    if (RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Services\\VxD\\Smclib\\Devices",
        &l_hKey) == ERROR_SUCCESS) {

        ULONG l_uIndex;

        for (l_uIndex = 0; l_uIndex < MAXIMUM_SMARTCARD_READERS; l_uIndex++) {

            UCHAR l_rgchDeviceName[128], l_rgchValueName[128];
            DWORD l_dwValueType;
            ULONG l_uDeviceNameLen = sizeof(l_rgchDeviceName);
            ULONG l_uValueNameLen = sizeof(l_rgchValueName);

            if (RegEnumValue(  
                l_hKey,
                l_uIndex,
                (PCHAR) l_rgchValueName,
                &l_uValueNameLen,
                NULL,
                &l_dwValueType,
                (PUCHAR) l_rgchDeviceName,
                &l_uDeviceNameLen) == ERROR_SUCCESS) {

                AddDevice(CString("\\\\.\\") + l_rgchDeviceName, READER_TYPE_VXD);
            }
        }
    }
}

CReaderList::~CReaderList()
{
	ULONG l_uIndex;

	if (--m_uRefCount != 0) {

		return;	 	
	}

	for (l_uIndex = 0; l_uIndex < m_uNumReaders; l_uIndex++) {

		delete m_pList[l_uIndex];	 	
	}

	if (m_pList) {
	 	
		delete m_pList;
	}
}

// ****************************************************************************
// CReader methods 
// ****************************************************************************

CReader::CReader(
    void
    )
{
    m_uReplyBufferSize = sizeof(m_rgbReplyBuffer);

    m_Ovr.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(m_Ovr.hEvent);

    m_OvrWait.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ResetEvent(m_OvrWait.hEvent);

    m_ScardIoRequest.dwProtocol = 0;
    m_ScardIoRequest.cbPciLength = sizeof(m_ScardIoRequest);

    m_fDump = FALSE;
}
void
CReader::Close(
    void
    )
{
#ifndef SIMULATE
    CloseHandle(m_hReader);
#endif
}

CString &
CReader::GetIfdType(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_VENDOR_IFD_TYPE;

#ifdef SIMULATE
	m_CIfdType = "DEBUG IfdType";
#endif

    if (m_CIfdType.IsEmpty()) {
     	
	    BOOL l_bResult = DeviceIoControl(
		    m_hReader,
		    IOCTL_SMARTCARD_GET_ATTRIBUTE,
		    (void *) &l_uAttr,
            sizeof(ULONG),
            m_rgbReplyBuffer,
            sizeof(m_rgbReplyBuffer),
		    &m_uReplyLength,
		    &m_Ovr
            );

        if (l_bResult) {

            m_rgbReplyBuffer[m_uReplyLength] = '\0';
            m_CIfdType = m_rgbReplyBuffer;
        }
    }

    return m_CIfdType;
}

LONG 
CReader::GetState(
    PULONG out_puState
    )
{
    SetLastError(0);

	BOOL l_bResult = DeviceIoControl(
		m_hReader,
		IOCTL_SMARTCARD_GET_STATE,
		NULL, 
        0,
        (void *) out_puState,
        sizeof(ULONG),
		&m_uReplyLength,
		&m_Ovr
        );

    return GetLastError();
}

CString &
CReader::GetVendorName(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_VENDOR_NAME;

#ifdef SIMULATE
	m_CVendorName = "DEBUG Vendor";
#endif

    if (m_CVendorName.IsEmpty()) {
     	
	    BOOL l_bResult = DeviceIoControl(
		    m_hReader,
		    IOCTL_SMARTCARD_GET_ATTRIBUTE,
		    (void *) &l_uAttr,
            sizeof(ULONG),
            m_rgbReplyBuffer,
            sizeof(m_rgbReplyBuffer),
		    &m_uReplyLength,
		    &m_Ovr
            );

        if (l_bResult) {

            m_rgbReplyBuffer[m_uReplyLength] = '\0';
            m_CVendorName = m_rgbReplyBuffer;
        }
    }

    return m_CVendorName;
}

ULONG
CReader::GetDeviceUnit(
    void
    )
{
    ULONG l_uAttr = SCARD_ATTR_DEVICE_UNIT;

	BOOL l_bResult = DeviceIoControl(
		m_hReader,
		IOCTL_SMARTCARD_GET_ATTRIBUTE,
		(void *) &l_uAttr,
        sizeof(ULONG),
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        );

    return (ULONG) *m_rgbReplyBuffer;
}

BOOL
CReader::Open(
    void    
    )
{
    if (m_CDeviceName.IsEmpty()) {

        return FALSE;
    }

    // Try to open the reader.
    m_hReader = CreateFile(
    	(LPCSTR) m_CDeviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (m_hReader == INVALID_HANDLE_VALUE ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
CReader::Open(
    CString & in_CDeviceName
    )
{
    // save the reader name
    m_CDeviceName += in_CDeviceName;

#ifdef SIMULATE
	return TRUE;
#endif

    return Open();
}

LONG
CReader::PowerCard(
    ULONG in_uMinorIoControl
    )
/*++

Routine Description:
	
    Cold resets the current card and sets the ATR
    of the card in the reader class.

Return Value:

    Returns the result of the DeviceIoControl call

--*/
{
    BOOL l_bResult;
    ULONG l_uReplyLength;
    CHAR l_rgbAtr[SCARD_ATR_LENGTH];

    SetLastError(0);

   	l_bResult = DeviceIoControl (
        m_hReader,
		IOCTL_SMARTCARD_POWER,
		&in_uMinorIoControl,
		sizeof(in_uMinorIoControl),
        l_rgbAtr,
		sizeof(l_rgbAtr),
		&l_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        SetLastError(0);                             
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &l_uReplyLength,
            TRUE
            );
    }

    if (GetLastError() == ERROR_SUCCESS) {
     	
        SetAtr((PBYTE) l_rgbAtr, l_uReplyLength);
    }

    return GetLastError();
}

LONG
CReader::SetProtocol(
    const ULONG in_uProtocol
    )
{
    BOOL l_bResult;

 	m_ScardIoRequest.dwProtocol = in_uProtocol;
    m_ScardIoRequest.cbPciLength = sizeof(SCARD_IO_REQUEST);

    SetLastError(0);

	l_bResult = DeviceIoControl (
		m_hReader,
		IOCTL_SMARTCARD_SET_PROTOCOL,
		(void *) &in_uProtocol,
        sizeof(ULONG),
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        SetLastError(0);
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &m_uReplyLength,
            TRUE
            );
    }

    return GetLastError();
}

LONG
CReader::Transmit(
    PUCHAR in_pchApdu,
    ULONG in_uApduLength,
    PUCHAR *out_pchReply,
    PULONG out_puReplyLength
    )
/*++

Routine Description:
    Transmits an apdu using the currently connected reader

Arguments:
    in_pchApdu - the apdu to send
    in_uApduLength - the length of the apdu
    out_pchReply - result returned from the reader/card
    out_puReplyLength - pointer to store number of bytes returned

Return Value:
    The nt-status code returned by the reader

--*/
{
    BOOL l_bResult;
    ULONG l_uBufferLength = m_ScardIoRequest.cbPciLength + in_uApduLength;
    PUCHAR l_pchBuffer = new UCHAR [l_uBufferLength];

    // Copy io-request header to request buffer
    memcpy(
        l_pchBuffer, 
        &m_ScardIoRequest, 
        m_ScardIoRequest.cbPciLength
        );

    // copy io-request header to reply buffer
    memcpy(
        m_rgbReplyBuffer, 
        &m_ScardIoRequest, 
        m_ScardIoRequest.cbPciLength
        );

    // append apdu to buffer
    memcpy(
        l_pchBuffer + m_ScardIoRequest.cbPciLength, 
        in_pchApdu,
        in_uApduLength
        );

    if (m_fDump) {

        DumpData(
            "\n   RequestData:",
            3,
            l_pchBuffer,
            l_uBufferLength
            );
    }

    SetLastError(0);
    // send the request to the card
	l_bResult = DeviceIoControl (
		m_hReader,
		IOCTL_SMARTCARD_TRANSMIT,
		l_pchBuffer,
        l_uBufferLength,
        m_rgbReplyBuffer,
        m_uReplyBufferSize,
		&m_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {
    
        // wait for result
        SetLastError(0);
        
        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &m_uReplyLength,
            TRUE
            );
    }
    
    if (m_fDump) {

        printf("   IOCTL returned %lxh\n", GetLastError());

        if (l_bResult) {
         	
            DumpData(
                "   ReplyData:",
                3,
                m_rgbReplyBuffer,
                m_uReplyLength
                );
        }
        printf("%*s", 53, "");
    }

    *out_pchReply = (PUCHAR) m_rgbReplyBuffer + m_ScardIoRequest.cbPciLength;
    *out_puReplyLength = m_uReplyLength - m_ScardIoRequest.cbPciLength;

    delete l_pchBuffer;
    return GetLastError();
}

LONG
CReader::VendorIoctl(
    CString &o_Answer
    )
{
	BOOL l_bResult = DeviceIoControl(
		m_hReader,
        CTL_CODE(FILE_DEVICE_SMARTCARD, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS),
		NULL,
        NULL, 
        m_rgbReplyBuffer,
        sizeof(m_rgbReplyBuffer),
		&m_uReplyLength,
		&m_Ovr
        );


    if (l_bResult) {

        m_rgbReplyBuffer[m_uReplyLength] = '\0';
        o_Answer = CString(m_rgbReplyBuffer);
    }

    return GetLastError();
}

LONG
CReader::WaitForCard(
    const ULONG in_uWaitFor
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    SetLastError(0);
        
   	l_bResult = DeviceIoControl (
        m_hReader,
		in_uWaitFor,
		NULL,
		0,
		NULL,
		0,
		&l_uReplyLength,
		&m_Ovr
        ); 	

    if (l_bResult == FALSE && GetLastError() == ERROR_IO_PENDING) {

        SetLastError(0);

        l_bResult = GetOverlappedResult(
            m_hReader,
            &m_Ovr,
            &l_uReplyLength,
            TRUE
            );
    }
    return GetLastError();
}

LONG
CReader::StartWaitForCard(
    const ULONG in_uWaitFor
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    ResetEvent(m_OvrWait.hEvent);
        
   	l_bResult = DeviceIoControl (
        m_hReader,
		in_uWaitFor,
		NULL,
		0,
		NULL,
		0,
		&l_uReplyLength,
		&m_OvrWait
        ); 	

    return GetLastError();
}

LONG
CReader::FinishWaitForCard(
	const BOOL in_bWait						   
    )
{
    BOOL l_bResult;
    ULONG l_uReplyLength;

    SetLastError(0);

    l_bResult = GetOverlappedResult(
        m_hReader,
        &m_OvrWait,
        &l_uReplyLength,
        in_bWait
        );

	return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\inc\smcdbg.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    smcdbg.h

Abstract:

    This header contains all definitions for the smart card debugger

Environment:

    Kernel mode only.

Revision History:

    - Created Jan. 1999 by Klaus Schutz 

--*/
#define IOCTL_SMCLIB_SEND_DEBUG_REQUEST     SCARD_CTL_CODE(100)
#define IOCTL_SMCLIB_PROCESS_T1_REQUEST     SCARD_CTL_CODE(101)
#define IOCTL_SMCLIB_GET_T1_REQUEST         SCARD_CTL_CODE(102)
#define IOCTL_SMCLIB_GET_T1_REPLY           SCARD_CTL_CODE(103)
#define IOCTL_SMCLIB_PROCESS_T1_REPLY       SCARD_CTL_CODE(104)
#define IOCTL_SMCLIB_IGNORE_T1_REPLY        SCARD_CTL_CODE(105)
#define IOCTL_SMCLIB_NOTIFY_DEVICE_REMOVAL  SCARD_CTL_CODE(106)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\sni.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

void MyCardEntry(class CCardProvider& in_CCardProvider);

//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MyCard(MyCardEntry);

//
// This structure represents the result file 
// that is stored in the smart card
//
typedef struct _RESULT_FILE {
 	
    // Offset to first test result
    UCHAR Offset;

    // Number of times the card has been reset
    UCHAR CardResetCount;

    // Version number of this card
    UCHAR CardMajorVersion;
    UCHAR CardMinorVersion;

    // RFU
    UCHAR Reserved[6];

    //
    // The following structures store the results
    // of the tests. Each result comes with the 
    // reset count when the test was performed.
    // This is used to make sure that we read not
    // the result from an old test, maybe even 
    // performed with another reader/driver.
    //
    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Wtx;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } ResyncRead;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } ResyncWrite;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Seqnum;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } IfscRequest;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } IfsdRequest;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Timeout;

} RESULT_FILE, *PRESULT_FILE;
                                                                                           
static void 
sleep( 
    clock_t wait 
    )
{
	clock_t goal;
	goal = wait + clock();
	while( goal > clock() )
        ;
}

static ULONG
MyCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Try to set incorrect protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static ULONG
MyCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PUCHAR l_pchResult;
    UCHAR l_rgchBuffer[512];
    CHAR l_chFileId;

    if (in_CCardProvider.GetTestNo() > 1 && in_CCardProvider.GetTestNo() < 7) {

        //
        // Select the appropriate file for the test
        // Each test is tied to a particular file
        //
        l_chFileId = (CHAR) in_CCardProvider.GetTestNo() - 1;

        //
        // APDU for select file
        //
        PCHAR l_pchFileDesc[] = {
            "wtx",
            "resync",
            "seqnum",
            "ifs",
            "timeout"
        };

        memcpy(l_rgchBuffer, "\x00\xa4\x08\x04\x04\x3e\x00\x00\x00", 9);

        //
        // add file number to select
        //
        l_rgchBuffer[8] = l_chFileId;

        //
        // select a file
        //
        TestStart("SELECT FILE EF%s", l_pchFileDesc[l_chFileId - 1]);

        l_lResult = in_CReader.Transmit(
            (PUCHAR) l_rgchBuffer,
            9,
            &l_pchResult,
            &l_uResultLength
            );

        TestCheck(
            l_lResult, "==", ERROR_SUCCESS,
            l_uResultLength, 2,
            l_pchResult[0], l_pchResult[1], 0x90, 0x00,
            NULL, NULL, NULL
            );

        TEST_END();     	

        //
        // Generate a 'test' pattern which will be written to the card
        //
        for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

            l_rgchBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
        }
    }


    switch (in_CCardProvider.GetTestNo()) {

        case 1:
            //
            // First test
            //
            TestStart("Buffer boundary test");

            //
            // Check if the reader correctly determines that
            // our receive buffer is too small
            //
            in_CReader.SetReplyBufferSize(9);
            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x08\x84\x00\x00\x08",
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult == ERROR_INSUFFICIENT_BUFFER,
                "Transmit should fail due to too small buffer\nReturned %2lxH\nExpected %2lxH",
                l_lResult, 
                ERROR_INSUFFICIENT_BUFFER
                );

            TestEnd();

            in_CReader.SetReplyBufferSize(2048);
        	break;

        case 2: {

            //
            // Wtx test file id 00 01
            // This test checks if the reader/driver correctly handles WTX requests
            //
            ULONG l_auNumBytes[] = { 1 , 2, 5, 30 };

            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];

                //
                // Now read from this file
                // The number of bytes we read corresponds to 
                // the waiting time extension this command produces
                //
                TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

                //
                // apdu for read binary
                //
                memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

                //
                // Append number of bytes
                //
                l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

                l_lResult = in_CReader.Transmit(
                    l_rgchBuffer,
                    5,
                    &l_pchResult,
                    &l_uResultLength
                    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uNumBytes + 2,
                    l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                    0x90, 0x00,
                    l_pchResult, l_rgchBuffer + 5, l_uNumBytes
                    );

                TEST_END();
            }
            break;
        }

        case 3: {
         	
            ULONG l_uNumBytes = 255;

            // resync. on write file id 00 02
            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for write binary
            memcpy(l_rgchBuffer, "\x00\xd6\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5 + l_uNumBytes,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();

            // resync. on read file id 00 02
            TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();
            break;
        }

        case 4: {
         	
            // wrong block seq. no file id 00 03
            ULONG l_uNumBytes = 255;
            
            TestStart("READ BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );
            TEST_END();
            break;
        }

        case 5: { 

            // ifsc request file id 00 04
            ULONG l_uNumBytes = 255;

            TestStart("WRITE BINARY %3d bytes", l_uNumBytes);
                    
            // Tpdu for write binary
            memcpy(l_rgchBuffer, "\x00\xd6\x00\x00", 4);

            // Append number of bytes (note: the buffer contains the pattern already)
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5 + l_uNumBytes,
                &l_pchResult,
                &l_uResultLength
                );
            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );
            TEST_END();
#ifdef junk
            l_uNumBytes = 255;
            TestStart("READ  BINARY %3d byte(s)", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                0x90, 0x00,
                l_pchResult, l_rgchBuffer + 5, l_uNumBytes
                );

            TEST_END();
#endif
            break;
        }

        case 6: {

            // forced timeout file id 00 05
            ULONG l_uNumBytes = 254;
            TestStart("READ  BINARY %3d bytes", l_uNumBytes);

            // tpdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_IO_DEVICE,
                0, 0,
                0, 0, 0, 0,
                NULL, NULL, 0
                );

            TEST_END();
            break;         	
        }

        case 7:{

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
            ULONG l_uNumBytes = sizeof(RESULT_FILE);
            PRESULT_FILE pCResultFile;
            
            TestStart("SELECT FILE EFresult");

            l_lResult = in_CReader.Transmit(
                (PUCHAR) "\x00\xa4\x08\x04\x04\x3e\x00\xA0\x00",
                9,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pchResult[0], l_pchResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY %3d bytes", l_uNumBytes);

            // apdu for read binary
            memcpy(l_rgchBuffer, "\x00\xB0\x00\x00", 4);

            // Append number of bytes
            l_rgchBuffer[4] = (UCHAR) l_uNumBytes;

            l_lResult = in_CReader.Transmit(
                l_rgchBuffer,
                5,
                &l_pchResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pchResult[l_uNumBytes], l_pchResult[l_uNumBytes + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            pCResultFile = (PRESULT_FILE) l_pchResult;

            //
            // Now check the result file. 
            //

            //
            // Check wtx result
            //
            TestStart("WTX result");
            TestCheck(
                pCResultFile->Wtx.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->Wtx.Result & 0x01) == 0, 
                "Smart card received no WTX reply"
                );
            TestCheck(
                (pCResultFile->Wtx.Result & 0x02) == 0, 
                "Smart card received wrong WTX reply"
                );
            TestCheck(
                pCResultFile->Wtx.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Wtx.Result
                );
            TestEnd();

            //
            // Check resync. read result
            //
            TestStart("RESYNCH read result");
            TestCheck(
                pCResultFile->ResyncRead.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->ResyncRead.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                pCResultFile->ResyncRead.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->ResyncRead.Result
                );
            TestEnd();

            //
            // Check resync. write result
            //
            TestStart("RESYNCH write result");
            TestCheck(
                pCResultFile->ResyncWrite.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->ResyncWrite.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                (pCResultFile->ResyncWrite.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                pCResultFile->ResyncWrite.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->ResyncWrite.Result
                );
            TestEnd();

            //
            // Sequence number result
            //
            TestStart("Sequence number result");
            TestCheck(
                pCResultFile->ResyncRead.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->Seqnum.Result & 0x01) == 0, 
                "Smart card received no RESYNCH request"
                );
            TestCheck(
                (pCResultFile->Seqnum.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                pCResultFile->Seqnum.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Seqnum.Result
                );
            TestEnd();

            //
            // IFSC Request
            //
            TestStart("IFSC request");
            TestCheck(
                pCResultFile->IfscRequest.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x01) == 0, 
                "Smart card received no IFSC reply"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x02) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x04) == 0, 
                "Block size BEFORE IFSC request incorrect",
                pCResultFile->IfscRequest.Result
                );
            TestCheck(
                (pCResultFile->IfscRequest.Result & 0x08) == 0, 
                "Block size AFTER IFSC request incorrect",
                pCResultFile->IfscRequest.Result
                );
            TestCheck(
                pCResultFile->IfscRequest.Result == 0x00, 
                "Test failed. Error code %02xH",
                pCResultFile->IfscRequest.Result
                );
            TestEnd();

            //
            // IFSD Request
            //
            TestStart("IFSD request");
            TestCheck(
                pCResultFile->IfsdRequest.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                (pCResultFile->IfsdRequest.Result & 0x01) == 0, 
                "Smart card received no IFSD request"
                );
            TestCheck(
                pCResultFile->IfsdRequest.Result == 0x00, 
                "Test failed. Error code %02xH",
                pCResultFile->IfsdRequest.Result
                );
            TestEnd();

            //
            // Timeout
            //
            TestStart("Forced timeout result");
            TestCheck(
                pCResultFile->Timeout.ResetCount == pCResultFile->CardResetCount,
                "Test not performed"
                );
            TestCheck(
                pCResultFile->Timeout.Result == 0, 
                "Test failed. Error code %02xH",
                pCResultFile->Timeout.Result
                );
            TestEnd();
            return IFDSTATUS_END;
        }

        default:
            return IFDSTATUS_FAILED;        
    }
    
    return IFDSTATUS_SUCCESS;

}    

static void
MyCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:                                           

    -

--*/
{                                                           
    // Set protocol callback
    in_CCardProvider.SetProtocol(MyCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MyCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("SIEMENS NIXDORF");

    // Set ATR of our card
    in_CCardProvider.SetAtr(
        (PBYTE) "\x3b\xef\x00\x00\x81\x31\x20\x49\x00\x5c\x50\x43\x54\x10\x27\xf8\xd2\x76\x00\x00\x38\x33\x00\x4d", 
        24
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\schlumbgr.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"


void 
SLBTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider SLBTestCard(SLBTestCardEntry);

//Pauses for a specified number of milliseconds. 
static void 
sleep( 
    clock_t wait 
    )
{
	clock_t goal;
	goal = wait + clock();
	while( goal > clock() )
        ;
}

static ULONG
SLBTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    // Try to set INCORRECT protocol T=1
    TestStart("Try to set incorrect protocol T=1");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);

    // The test MUST fail with the incorrect protocol
    TEST_CHECK_NOT_SUPPORTED("Set protocol failed", l_lResult);
    TestEnd();

    // Now set the correct protocol
    TestStart("Set protocol T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
SLBTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult, l_uResultLength, l_uIndex;
    PBYTE l_pbResult;
    BYTE l_rgbBuffer[512];
    CHAR l_chFileId;
	
    // First select the file
    if (in_CCardProvider.GetTestNo() < 6) {

        //
        // Select the appropriate file for the test
        // Each test is tied to a particular file
        //
        l_chFileId = (CHAR) in_CCardProvider.GetTestNo();

        PCHAR l_pchFileDesc[] = {
            "transferAllBytes",
            "transferNextByte",
            "read256Bytes",
            "case1Apdu",
            "restartWorkWaitingTime"
        };

        // APDU for select file
		memcpy(l_rgbBuffer, "\x00\xa4\x00\x00\x02\x00\x00", 7);

        // add file number to select
        l_rgbBuffer[6] = l_chFileId;

        // select a file
        TestStart("SELECT FILE EF%s", l_pchFileDesc[l_chFileId - 1]);

        sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

        l_lResult = in_CReader.Transmit(
            (PBYTE) l_rgbBuffer,
            7,
            &l_pbResult,
            &l_uResultLength
            );

        TestCheck(
            l_lResult, "==", ERROR_SUCCESS,
            l_uResultLength, 2,
            l_pbResult[0], l_pbResult[1], 0x90, 0x00,
            NULL, NULL, NULL
            );

        TEST_END();     	

        //
        // Generate a 'test' pattern which will be written to the card
        //
        for (l_uIndex = 0; l_uIndex < 256; l_uIndex++) {

            l_rgbBuffer[5 + l_uIndex] = (UCHAR) l_uIndex;             	
        }
    }

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1:
	    case 2: {
		    //
		    // Write 
		    //
            ULONG l_auNumBytes[] = { 1 , 25 }; //, 50, 75, 100, 125 };
    
            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];

			    TestStart("WRITE BINARY %3d Byte(s)", l_uNumBytes);
				    
		        // Tpdu for write binary
			    memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);
				    
		        // Append number of bytes (note: the buffer contains the pattern already)
			    l_rgbBuffer[4] = (UCHAR) l_uNumBytes;

			    sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 4) );
								    
			    l_lResult = in_CReader.Transmit(
				    l_rgbBuffer,
				    5 + l_uNumBytes,
				    &l_pbResult,
				    &l_uResultLength
				    );
				    
                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, 2,
                    l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                    NULL, NULL, NULL
                    );

                TEST_END();
		    }		    
		    break;         	
        }

	    case 3: {
         	
            // Test read of 256 bytes
            ULONG l_uNumBytes = 256;
            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

            // tpdu for read binary 256 bytes
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00\x00", 5);
		    
		    sleep((clock_t) 1 * (CLOCKS_PER_SEC / 2) );
	    
		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, l_uNumBytes + 2,
                l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                );

            TEST_END();
            break;
        }

	    case 4: {

            // Test write of 0 bytes
            TestStart("WRITE BINARY %3d Byte", 0);

            // tpdu for write binary
            memcpy(l_rgbBuffer, "\x00\xd6\x00\x00", 4);
		    
		    sleep((clock_t) 1 * (CLOCKS_PER_SEC / 2) );
	    
		    l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                4,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, 0
                );

            TEST_END();
		    break;         	
        }

	    case 5: {
		    // Test restart or work waiting time
            ULONG l_auNumBytes[] = { 1, 2, 5, 30 };

            for (ULONG l_uTest = 0; 
                 l_uTest < sizeof(l_auNumBytes) / sizeof(l_auNumBytes[0]); 
                 l_uTest++) {

                ULONG l_uNumBytes = l_auNumBytes[l_uTest];
	            TestStart("READ BINARY %3d Byte(s)", l_uNumBytes);

			    // tpdu for read binary
			    memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

			    // Append number of bytes
			    l_rgbBuffer[4] = (UCHAR)l_uNumBytes;
		    
			    sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

			    l_lResult = in_CReader.Transmit(
				    l_rgbBuffer,
				    5,
				    &l_pbResult,
				    &l_uResultLength
			    );

                TestCheck(
                    l_lResult, "==", ERROR_SUCCESS,
                    l_uResultLength, l_uNumBytes + 2,
                    l_pbResult[l_uNumBytes], l_pbResult[l_uNumBytes + 1], 0x90, 0x00,
                    l_pbResult, l_rgbBuffer + 5, l_uNumBytes
                    );

                TEST_END();
		    }
		    break;         	
        }

        case 6: {

            //
            // Read the result file from the smart card.
            // The card stores results of each test in 
            // a special file
            //
         	
            TestStart("SELECT FILE EFresult");

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            l_lResult = in_CReader.Transmit(
                (PBYTE) "\x00\xa4\x00\x00\x02\xa0\x00",
                7,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, 2,
                l_pbResult[0], l_pbResult[1], 0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();     	

            // Read
            TestStart("READ  BINARY FILE EFresult");

            // apdu for read binary
            memcpy(l_rgbBuffer, "\x00\xb0\x00\x00", 4);

            // Append number of bytes we want to read
            l_rgbBuffer[4] = (UCHAR) sizeof(T0_RESULT_FILE_HEADER);

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE_HEADER) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER)], 
                l_pbResult[sizeof(T0_RESULT_FILE_HEADER) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            // get the card reset count
            PT0_RESULT_FILE_HEADER l_pCResultFileHeader;
            l_pCResultFileHeader = (PT0_RESULT_FILE_HEADER) l_pbResult;
            BYTE l_bCardResetCount = l_pCResultFileHeader->CardResetCount;

            // set the offset from where we want to read
            l_rgbBuffer[3] = (BYTE) l_pCResultFileHeader->Offset;
            // Append number of bytes
            l_rgbBuffer[4] = (BYTE) sizeof(T0_RESULT_FILE);

            sleep( (clock_t) 1 * (CLOCKS_PER_SEC / 2) );

            // read in the result data of the result file
            l_lResult = in_CReader.Transmit(
                l_rgbBuffer,
                5,
                &l_pbResult,
                &l_uResultLength
                );

            TestCheck(
                l_lResult, "==", ERROR_SUCCESS,
                l_uResultLength, sizeof(T0_RESULT_FILE) + 2,
                l_pbResult[sizeof(T0_RESULT_FILE)], 
                l_pbResult[sizeof(T0_RESULT_FILE) + 1], 
                0x90, 0x00,
                NULL, NULL, NULL
                );

            TEST_END();

            PT0_RESULT_FILE l_pCResultFile = (PT0_RESULT_FILE) l_pbResult;

            //
            // Now check the result file. 
            //

            // procedure byte interpretation - write all bytes 
            TestStart("'Transfer all remaining bytes result'");
            TestCheck(
                l_pCResultFile->TransferAllBytes.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->TransferAllBytes.Result & 0x01) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                l_pCResultFile->TransferAllBytes.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->TransferAllBytes.Result
                );
            TestEnd();

            // procedure byte interpretation - write single bytes
            TestStart("'Transfer next byte result'");
            TestCheck(
                l_pCResultFile->TransferNextByte.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->TransferNextByte.Result & 0x01) == 0, 
                "Smart card received incorrect data"
                );
            TestCheck(
                l_pCResultFile->TransferNextByte.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->TransferNextByte.Result
                );
            TestEnd();

            // Check read of 256 bytes
            TestStart("'Read 256 bytes bytes' result");
            TestCheck(
                l_pCResultFile->Read256Bytes.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->Read256Bytes.Result & 0x01) == 0, 
                "Smart card received P3 != 0"
                );
            TestCheck(
                l_pCResultFile->Read256Bytes.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->Read256Bytes.Result
                );
            TestEnd();

            // Test of case 1 APDU
            TestStart("'Case 1 APDU' result");
            TestCheck(
                l_pCResultFile->Case1Apdu.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->Case1Apdu.Result & 0x01) == 0, 
                "Smart card received only 4-byte-TPDU"
                );
            TestCheck(
                (l_pCResultFile->Case1Apdu.Result & 0x02) == 0, 
                "Smart card received P3 !=0"
                );
            TestCheck(
                l_pCResultFile->Case1Apdu.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->Case1Apdu.Result
                );
            TestEnd();

            // Test of restart of work waiting time
            TestStart("'Restart of work waiting time' result");
            TestCheck(
                l_pCResultFile->RestartWorkWaitingTime.ResetCount == l_bCardResetCount,
                "Test not performed"
                );
            TestCheck(
                (l_pCResultFile->RestartWorkWaitingTime.Result & 0x01) == 0, 
                "Smart card received only 4-byte-TPDU"
                );
            TestCheck(
                (l_pCResultFile->RestartWorkWaitingTime.Result & 0x02) == 0, 
                "Smart card received P3 !=0"
                );
            TestCheck(
                l_pCResultFile->RestartWorkWaitingTime.Result == 0, 
                "Test failed. Error code %02xH",
                l_pCResultFile->RestartWorkWaitingTime.Result
                );
            TestEnd();
            return IFDSTATUS_END;
        }
	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
SLBTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(SLBTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(SLBTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("SCHLUMBERGER");

    // Name of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xe2\x00\x00\x40\x20\x99\x01", 8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ifdtest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ifdtest.h
//
//--------------------------------------------------------------------------

#define min(a, b)  (((a) < (b)) ? (a) : (b)) 

// Status codes
#define IFDSTATUS_SUCCESS       0
#define IFDSTATUS_FAILED        1
#define IFDSTATUS_CARD_UNKNOWN  2
#define IFDSTATUS_TEST_UNKNOWN  3
#define IFDSTATUS_NO_PROVIDER   4
#define IFDSTATUS_NO_FUNCTION   5
#define IFDSTATUS_END           7

// query codes
#define IFDQUERY_CARD_TESTED    0
#define IFDQUERY_CARD_NAME      1
#define IFDQUERY_TEST_RESULT    2

#define READER_TYPE_WDM         "WDM PnP"
#define READER_TYPE_NT          "NT 4.00"
#define READER_TYPE_VXD         "Win9x VxD"

#define OS_WINNT4               "Windows NT 4.0"
#define OS_WINNT5               "Windows NT 5.0"
#define OS_WIN95                "Windows 95"
#define OS_WIN98                "Windows 98"

#define MAX_NUM_ATR				3

// Prototypes 
void LogMessage(PCHAR in_pchFormat, ...);
void LogOpen(PCHAR in_pchLogFile);
void TestStart(PCHAR in_pchFormat,  ...);
void TestCheck(BOOL in_bResult, PCHAR in_pchFormat, ...);
void TestEnd(void);
BOOL TestFailed(void);
BOOL ReaderFailed(void);
CString & GetOperatingSystem(void);

void
TestCheck(
    ULONG in_lResult,
    const PCHAR in_pchOperator,
    const ULONG in_uExpectedResult,
    ULONG in_uResultLength,
    ULONG in_uExpectedLength,
    UCHAR in_chSw1,
    UCHAR in_chSw2,
    UCHAR in_chExpectedSw1,
    UCHAR in_chExpectedSw2,
    PBYTE in_pchData,
    PBYTE in_pchExpectedData,
    ULONG  in_uDataLength
    );

extern "C" {

    LONG MapWinErrorToNtStatus(ULONG in_uErrorCode);
}

//
// some useful macros
//
#define TEST_END() {TestEnd(); if(TestFailed()) return IFDSTATUS_FAILED;}

#define TEST_CHECK_SUCCESS(Text, Result) \
TestCheck( \
    Result == ERROR_SUCCESS, \
    "%s.\nReturned %8lxH (NTSTATUS %8lxH)\nExpected        0H (NTSTATUS        0H)", \
    Text, \
    Result, \
    MapWinErrorToNtStatus(Result) \
    ); 

#define TEST_CHECK_NOT_SUPPORTED(Text, Result) \
TestCheck( \
    Result == ERROR_NOT_SUPPORTED, \
    "%s.\nReturned %8lxH (NTSTATUS %8xH)\nExpected %38xH (NTSTATUS %8lxH)", \
    Text, \
    Result, \
    MapWinErrorToNtStatus(Result), \
    ERROR_NOT_SUPPORTED, \
    MapWinErrorToNtStatus(ERROR_NOT_SUPPORTED) \
    ); 
//
// Class definitions
//
class CAtr {

    UCHAR m_rgbAtr[SCARD_ATR_LENGTH];
    ULONG m_uAtrLength;
 	
public:
    CAtr() {
     	                                  
        m_uAtrLength = 0;
        memset(m_rgbAtr, 0, SCARD_ATR_LENGTH);
    }

    CAtr(
        BYTE in_rgbAtr[], 
        ULONG in_uAtrLength
        )
    {
        *this = CAtr();
        m_uAtrLength = min(SCARD_ATR_LENGTH, in_uAtrLength);
        memcpy(m_rgbAtr, in_rgbAtr, m_uAtrLength);
    }

    PCHAR GetAtrString(PCHAR io_pchBuffer);
    PBYTE GetAtr(PBYTE *io_pchBuffer, PULONG io_puAtrLength) {
     	
        *io_pchBuffer = (PBYTE) m_rgbAtr;
        *io_puAtrLength = m_uAtrLength;
        return (PBYTE) m_rgbAtr;
    }

	ULONG GetLength() {

		return m_uAtrLength;
	}

    operator==(const CAtr& a) {

        return (m_uAtrLength && 
            a.m_uAtrLength == m_uAtrLength && 
            memcmp(m_rgbAtr, a.m_rgbAtr, m_uAtrLength) == 0);
    }

    operator!=(const CAtr& a) {

        return !(*this == a);
    }
};

class CReader {

    // device name. E.g. SCReader0
    CString m_CDeviceName;

    // Name of the reader to be tested. E.g. Bull
    CString m_CVendorName;

    // Name of the reader to be tested. E.g. Bull
    CString m_CIfdType;

    // Atr of the current card
    class CAtr m_CAtr;

    // handle to the reader device
    HANDLE m_hReader;

    // Overlapped structure used by DeviceIoControl
    OVERLAPPED m_Ovr;

    // Overlapped structure used by WaitFor...
    OVERLAPPED m_OvrWait;

    // io-request struct used for transmissions
    SCARD_IO_REQUEST m_ScardIoRequest;

    // Storage area for smart card i/o
    UCHAR m_rgbReplyBuffer[1024];

    // size of the reply buffer
    ULONG m_uReplyBufferSize;

    // Number of bytes returned by the card
    ULONG m_uReplyLength;

    // function used by WaitForCardInsertion|Removal
    LONG WaitForCard(const ULONG);

    LONG StartWaitForCard(const ULONG);

    LONG PowerCard(ULONG in_uMinorIoControlCode);

    BOOL m_fDump;

public:
    CReader();

    // Close reader
    void Close(void);

    // power functions
    LONG CReader::ColdResetCard(void) {

        return PowerCard(SCARD_COLD_RESET); 	
    }  

    LONG CReader::WarmResetCard(void) {

        return PowerCard(SCARD_WARM_RESET); 	
    }  

    LONG CReader::PowerDownCard(void) {

        return PowerCard(SCARD_POWER_DOWN); 	
    }  

    PBYTE GetAtr(PBYTE *io_pchBuffer, PULONG io_puAtrLength) {
     	
        return m_CAtr.GetAtr(io_pchBuffer, io_puAtrLength);
    }

    PCHAR GetAtrString(PCHAR io_pchBuffer) {
     	
        return m_CAtr.GetAtrString(io_pchBuffer);
    }

    HANDLE GetHandle(void) {
     	
        return m_hReader;
    }

    CString &GetDeviceName(void) {
     	
        return m_CDeviceName;
    }

    LONG VendorIoctl(CString &o_CAnswer);
    CString &GetVendorName(void);
    CString &GetIfdType(void);
    ULONG GetDeviceUnit(void);
    LONG GetState(PULONG io_puState);

    // Open the reader
    BOOL Open(
        CString &in_CReaderName
        );

    // (Re)Open reader using the existing name
    BOOL Open(void);

	//
    // Set size of the reply buffer
    // (Only for testing purposes)
	//
    void SetReplyBufferSize(ULONG in_uSize) {
     	
        if (in_uSize > sizeof(m_rgbReplyBuffer)) {

            m_uReplyBufferSize = sizeof(m_rgbReplyBuffer);

        } else {
         	
            m_uReplyBufferSize = in_uSize;
        }
    }

    // assigns an ATR
    void SetAtr(PBYTE in_pchAtr, ULONG in_uAtrLength) {

        m_CAtr = CAtr(in_pchAtr, in_uAtrLength); 	    
    }

    // returns the ATR of the current card
    class CAtr &GetAtr() {

        return m_CAtr; 	
    }

    // set protocol to be used
    LONG SetProtocol(const ULONG in_uProtocol);

    // transmits an APDU to the reader/card
    LONG Transmit(
        PBYTE in_pchRequest,
        ULONG in_uRequestLength,
        PBYTE *out_pchReply,
        PULONG out_puReplyLength
		);

    // wait to insert card
    LONG WaitForCardInsertion() {
     	
        return WaitForCard(IOCTL_SMARTCARD_IS_PRESENT);
    };

    // wait to remove card
    LONG WaitForCardRemoval() {
     	
        return WaitForCard(IOCTL_SMARTCARD_IS_ABSENT);
    };

    LONG StartWaitForCardRemoval() {
     	
        return StartWaitForCard(IOCTL_SMARTCARD_IS_ABSENT);
    };

    LONG StartWaitForCardInsertion() {
     	
        return StartWaitForCard(IOCTL_SMARTCARD_IS_PRESENT);
    };

    LONG FinishWaitForCard(const BOOL in_bWait);

    void SetDump(BOOL in_fOn) {
     	
        m_fDump = in_fOn;
    }
};

class CCardProvider {
 	
    // Start of list pointer
    static class CCardProvider *s_pFirst;

    // Pointer to next provider
    class CCardProvider *m_pNext;

    // name of the card to be tested
    CString m_CCardName;

    // atr of this card
    CAtr m_CAtr[3];

    // test no to run
    ULONG m_uTestNo;

    // max number of tests
    ULONG m_uTestMax;

    // This flag indicates that the card test was unsuccessful
    BOOL m_bTestFailed;

    // This flag indicates that the card has been tested
    BOOL m_bCardTested;

    // set protocol function
    ULONG ((*m_pSetProtocol)(class CCardProvider&, class CReader&));

    // set protocol function
    ULONG ((*m_pCardTest)(class CCardProvider&, class CReader&));

public:

    // Constructor
    CCardProvider(void);

    // Constructor to be used by plug-in 
    CCardProvider(void (*pEntryFunction)(class CCardProvider&));

    // Method that mangages all card tests
    void CardTest(class CReader&, ULONG in_uTestNo);

    // return if there are still untested cards
    BOOL CardsUntested(void);

    // List all cards that have not been tested
    void ListUntestedCards(void);

    // Assigns a friendly name to a card
    void SetCardName(CHAR in_rgchCardName[]);

    // Set ATR of the card
    void SetAtr(PBYTE in_rgbAtr, ULONG in_uAtrLength);

    // Assign callback functions
    void SetProtocol(ULONG ((in_pFunction)(class CCardProvider&, class CReader&))) {
     	
        m_pSetProtocol = in_pFunction;
    }

    void SetCardTest(ULONG ((in_pFunction)(class CCardProvider&, class CReader&))) {
     	
        m_pCardTest = in_pFunction;
    }

    // returns the test number to perform
    ULONG GetTestNo(void) {
     	
        return m_uTestNo;
    }

	BOOL IsValidAtr(CAtr in_CAtr) {

		for (int i = 0; i < MAX_NUM_ATR; i++) {

			if (m_CAtr[i] == in_CAtr) {

				return TRUE;
			}
		}
		return FALSE;
	}
};

// represents a list of all installed readers
class CReaderList {

    // number of constructor calls to avoid multiple build of reader list
	static ULONG m_uRefCount;

    // number of currently installed readers
    static ULONG m_uNumReaders;

    // pointer to array of reader list
    static class CReaderList **m_pList;

    ULONG m_uCurrentReader;

    CString m_CDeviceName;
    CString m_CPnPType;
    CString m_CVendorName;
    CString m_CIfdType;

public:

    CReaderList();
    CReaderList(
        CString &in_CDeviceName,
        CString &in_CPnPType,
        CString &in_CVendorName,
        CString &in_CIfdType
        );
	~CReaderList();
	
    void AddDevice(
        CString in_pchDeviceName,
        CString in_pchPnPType
        );

    CString &GetVendorName(ULONG in_uIndex);
    CString &GetDeviceName(ULONG in_uIndex);
    CString &GetIfdType(ULONG in_uIndex);
    CString &GetPnPType(ULONG in_uIndex);

    ULONG GetNumReaders(void) {
     	
        return m_uNumReaders;
    }
};

// This structure represents the T=0 result file of a smart card
typedef struct _T0_RESULT_FILE_HEADER {
 	
    // Offset to first test result
    UCHAR Offset;

    // Number of times the card has been reset
    UCHAR CardResetCount;

    // Version number of this card
    UCHAR CardMajorVersion;
    UCHAR CardMinorVersion;

} T0_RESULT_FILE_HEADER, *PT0_RESULT_FILE_HEADER;

typedef struct _T0_RESULT_FILE {

    //
    // The following structures store the results
    // of the tests. Each result comes with the 
    // reset count when the test was performed.
    // This is used to make sure that we read not
    // the result from an old test, maybe even 
    // performed with another reader/driver.
    //
    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } TransferAllBytes;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } TransferNextByte;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Read256Bytes;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } Case1Apdu;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } RestartWorkWaitingTime;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } PTS;

    struct {

        UCHAR Result;
        UCHAR ResetCount; 	

    } PTSDataCheck;

} T0_RESULT_FILE, *PT0_RESULT_FILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\mondex.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    example.cpp

Abstract:

    This is a plug-in for the smart card driver test suite.
    This plug-in is smart card dependent

Author:

    Klaus U. Schutz

Environment:

    Win32 application

Revision History :

    Nov. 1997 - initial version

--*/

#include <stdarg.h> 
#include <stdio.h>
#include <string.h>
#include <time.h>

#include <afx.h>
#include <afxtempl.h>

#include <winioctl.h>
#include <winsmcrd.h>

#include "ifdtest.h"

#define BYTES_PER_BLOCK 64

void 
MondexTestCardEntry(
    class CCardProvider& in_CCardProvider
    );
//
// Create a card provider object
// Note: all global varibales and all functions have to be static
//
static class CCardProvider MondexTestCard(MondexTestCardEntry);

static ULONG
MondexTestCardSetProtocol(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
    
    This function will be called after the card has been correctly 
    identified. We should here set the protocol that we need
    for further transmissions

Arguments:

    in_CCardProvider - ref. to our card provider object
    in_CReader - ref. to the reader object

Return Value:

    IFDSTATUS_FAILED - we were unable to set the protocol correctly
    IFDSTATUS_SUCCESS - protocol set correctly

--*/
{
    ULONG l_lResult;

    TestStart("Set protocol to T=0");
    l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
    TEST_CHECK_SUCCESS("Set protocol failed", l_lResult);
    TestEnd();

    if (l_lResult != ERROR_SUCCESS) {

        return IFDSTATUS_FAILED;
    }

    return IFDSTATUS_SUCCESS;
}

static 
ULONG
MondexTestCardTest(
    class CCardProvider& in_CCardProvider,
    class CReader& in_CReader
    )
/*++

Routine Description:
	    
    This serves as the test function for a particular smart card

Arguments:

    in_CReader - ref. to class that provides all information for the test

Return Value:

    IFDSTATUS value

--*/
{
    ULONG l_lResult;

	switch (in_CCardProvider.GetTestNo()) {
	
	    case 1: {
            TestStart("Cold reset");
            l_lResult = in_CReader.ColdResetCard();
            TEST_CHECK_SUCCESS("Cold reset failed", l_lResult);
            TestEnd();

            ULONG l_uState;
            TestStart("Check reader state");
            l_lResult = in_CReader.GetState(&l_uState);
            TEST_CHECK_SUCCESS(
                "Ioctl IOCTL_SMARTCARD_GET_STATE failed", 
                l_lResult
                );

            TestCheck(
                l_uState == SCARD_SPECIFIC,
                "Invalid reader state.\nReturned %d\nExpected %d",
                l_uState,
                SCARD_SPECIFIC
                );
            TestEnd();

            return IFDSTATUS_END;
        }

	    default:
		    return IFDSTATUS_FAILED;

	}    
    return IFDSTATUS_SUCCESS;
}    

static void
MondexTestCardEntry(
    class CCardProvider& in_CCardProvider
    )
/*++

Routine Description:
    
    This function registers all callbacks from the test suite
	
Arguments:

    CCardProvider - ref. to card provider class

Return Value:

    -

--*/
{
    // Set protocol callback
    in_CCardProvider.SetProtocol(MondexTestCardSetProtocol);

    // Card test callback
    in_CCardProvider.SetCardTest(MondexTestCardTest);

    // Name of our card
    in_CCardProvider.SetCardName("Mondex");

    // ATR of our card
    in_CCardProvider.SetAtr((PBYTE) "\x3b\xff\x32\x00\x00\x10\x80\x80\x31\xe0\x5b\x55\x53\x44\x00\x00\x00\x00\x13\x88\x02\x55", 22);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\ifdtest\ifdscrpt.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    scdrvtst

Abstract:

     IOCTL test program for smart card driver.

Author:

    Klaus Schutz (kschutz) Dec-1996

Revision History:     

--*/

#include <afx.h>
#include <afxtempl.h>
#include <winioctl.h>

#include <conio.h>

#include <winsmcrd.h>
#include "ifdtest.h"

class CCardList;

// This represents a single function of a card
class CCardFunction  {
	
	CString m_CName;
	CHAR m_chShortCut;
	CByteArray m_CData;
	CCardFunction *m_pCNextFunction;

public:
	CCardFunction(
		CString &in_CName,
		CHAR in_chShortCut,
		CByteArray &in_CData
		);
	friend CCardList;
};

// This is a single card
class CCard {
	
	CString	m_CName;
    CHAR m_chShortCut;
	CCardFunction *m_pCFirstFunction;
	CCard *m_pCNextCard;

public:
	CCard(
		CString & in_CCardName,
		CHAR in_chShortCut
		);

	friend CCardList;
};

// This implements a list of cards
class CCardList  {

	CString	m_CScriptFileName;
	CCard *m_pCFirstCard;
	CCard *m_pCCurrentCard;
    ULONG m_uNumCards;

public:
	CCardList(CString &in_CScriptFileName);

    void 
	AddCard(
		CString	&in_CardName,
        CHAR in_chShortCut
		);

	void
	AddCardFunction(
		CString &in_CFunctionName, 
		CHAR in_chShortCut,
		CByteArray &l_pCData
		);

    void ShowCards(
        void (__cdecl *in_pCallBack)(void *in_pContext, PCHAR in_pchCardName),
        void *in_pContext
        );

	BOOL SelectCard(CHAR in_chShortCut);
	void ReleaseCard(void);
	CString GetCardName(void);
    ULONG GetNumCards(void) {
     	
        return m_uNumCards;
    }
	BOOL	IsCardSelected(void);
    BOOL	ListFunctions(void);
	CByteArray *GetApdu(CHAR in_chShortCut);
};

CCardFunction::CCardFunction(
	CString	&in_CName,
    CHAR in_chShortCut,
	CByteArray &in_CData
	)
/*++
	Adds a function to the current card
--*/
{
	m_CName = in_CName;
	m_chShortCut = in_chShortCut;
	m_CData.Copy(in_CData);
	m_pCNextFunction = NULL;
}

CCard::CCard(
	CString	&in_CCardName,
    CHAR in_chShortCut
	)
/*++

Routine Description:

	Constructor for a new card

Arguments:

	CardName - Reference to card to add
	in_uPos - index of shortcut key

Return Value:

--*/
{
	m_CName = in_CCardName;
	m_chShortCut = in_chShortCut;
	m_pCNextCard = NULL;
	m_pCFirstFunction = NULL;
}
    
void
CCardList::AddCard(
	CString	&in_CCardName,
    CHAR in_chShortCut
	)
/*++

Routine Description:
	Adds a new card to CardList

Arguments:
	in_CCardName - Reference to card to add

--*/
{
	CCard *l_pCNewCard = new CCard(in_CCardName, in_chShortCut);

	if (m_pCFirstCard == NULL) {

		m_pCFirstCard = l_pCNewCard;

	} else {

		CCard *l_pCCurrent = m_pCFirstCard;
		while (l_pCCurrent->m_pCNextCard) {

			l_pCCurrent = l_pCCurrent->m_pCNextCard;
		}

		l_pCCurrent->m_pCNextCard = l_pCNewCard;
	}

	m_pCCurrentCard = l_pCNewCard;
    m_uNumCards += 1;
}

void
CCardList::AddCardFunction(
	CString	&in_CFunctionName,
    CHAR in_chShortCut,
	CByteArray &in_pCData
	)
/*++

Routine Description:
	Adds a new function to the current card

Arguments:
	in_CCardName - Reference to card to add
	in_chShortCut - Shortcut key

Return Value:

--*/
{
	CCardFunction *l_pCNewFunction = new CCardFunction(
		in_CFunctionName, 
		in_chShortCut, 
		in_pCData
		);

	if (m_pCCurrentCard->m_pCFirstFunction == NULL) {

		m_pCCurrentCard->m_pCFirstFunction = l_pCNewFunction;

	} else {

		CCardFunction *l_pCCurrent = m_pCCurrentCard->m_pCFirstFunction;
		while (l_pCCurrent->m_pCNextFunction) {

			l_pCCurrent = l_pCCurrent->m_pCNextFunction;
		}

		l_pCCurrent->m_pCNextFunction = l_pCNewFunction;
	}
}

CCardList::CCardList(
	CString &in_CScriptFileName
	)
/*++

Routine Description:

	Adds a new function to the current card

Arguments:

	CardName - Reference to card to add
	in_uPos - index of shortcut key

Return Value:

--*/
{
	CStdioFile l_CScriptFile;
    CHAR l_rgchBuffer[255], l_chKey;
    ULONG l_uLineNumber = 0;
    BOOL l_bContinue = FALSE;
    CByteArray l_Data;
    CString l_CCommand;
        
	m_pCFirstCard = NULL;
	m_pCCurrentCard = NULL;
    
    if (l_CScriptFile.Open(in_CScriptFileName, CFile::modeRead) == NULL) {

		printf("Script file cannot be opened: %s\n", in_CScriptFileName);
    	return;
    }

	m_CScriptFileName = in_CScriptFileName;
    
    while (l_CScriptFile.ReadString(l_rgchBuffer, sizeof(l_rgchBuffer) - 1)) {

        try {

	        CString l_CLine(l_rgchBuffer);
            CString l_CCommandApdu;

            l_uLineNumber += 1;

            if (l_CLine.GetLength() != 0 && l_CLine[0] == '#') {
        
                // comment line found, skip this line
                continue;
            }

	        // Get rid of leading and trailing spaces
	        l_CLine.TrimLeft();
	        l_CLine.TrimRight();

	        int l_ichStart = l_CLine.Find('[');	   
	        int l_ichKey = l_CLine.Find('&');
	        int l_ichEnd = l_CLine.Find(']');

	        if(l_ichStart == 0 && l_ichKey > 0 && l_ichEnd > l_ichKey + 1) {

		        //
		        // Add new card to list
		        //

		        CString l_CardName;

		        // Change card name from [&Card] to [C]ard
		        l_CardName = 
			        l_CLine.Mid(l_ichStart + 1, l_ichKey - l_ichStart - 1) + 
                    '[' +
                    l_CLine[l_ichKey + 1] +
                    ']' +
			        l_CLine.Mid(l_ichKey + 2, l_ichEnd - l_ichKey - 2);
		       
                AddCard(
                    l_CardName, 
                    l_CardName[l_ichKey]
                    );

	        } else if (l_ichStart == -1 && l_ichKey >= 0 && l_ichEnd == -1) {

		        //
		        // Add new function to current card
		        //

		        // Get function name
		        CString l_CToken = l_CLine.SpanExcluding(",");

		        // Search for shurtcut key
		        l_ichKey = l_CToken.Find('&');

		        if (l_ichKey == -1) {

			        throw "Missing '&' in function name";
		        }

                l_chKey = l_CToken[l_ichKey + 1];

		        // Change card function from &Function to [F]unction

                l_CCommand = 
			        l_CToken.Mid(l_ichStart + 1, l_ichKey - l_ichStart - 1) + 
                    '[' +
                    l_CToken[l_ichKey + 1] +
                    ']' +
			        l_CToken.Right(l_CToken.GetLength() - l_ichKey - 2);
                
                LONG l_lComma = l_CLine.Find(',');
            
                if (l_lComma == -1) {

			        throw "Missing command APDU";

                } else {
            	    
		            l_CCommandApdu = l_CLine.Right(l_CLine.GetLength() - l_lComma - 1);
                }

            } else if (l_bContinue) {

                l_CCommandApdu = l_CLine;        	

            } else if (l_CLine.GetLength() != 0 && l_CLine[0] != '#') {

                throw "Line invalid";
            }
       
            if (l_CCommandApdu != "") {
        
		        do {

			        CHAR l_chData;
                    l_CCommandApdu.TrimLeft();

                    ULONG l_uLength = l_CCommandApdu.GetLength();

                    if (l_uLength >= 3 &&
                        l_CCommandApdu[0] == '\'' &&
                        l_CCommandApdu[2] == '\'') {

                        // add ascsii character like 'c'
                        l_chData = l_CCommandApdu[1];
    			        l_Data.Add(l_chData);                
                 	    
                    } else if(l_uLength >= 3 &&
                              l_CCommandApdu[0] == '\"' &&
                              l_CCommandApdu.Right(l_uLength - 2).Find('\"') != -1) {

                        // add string like "string"
                        for (INT l_iIndex = 1; l_CCommandApdu[l_iIndex] != '\"'; l_iIndex++) {

            			    l_Data.Add(l_CCommandApdu[l_iIndex]);                                     	
                        }

                    } else if (l_CCommandApdu.SpanIncluding("0123456789abcdefABCDEF").GetLength() == 2) {

                        sscanf(l_CCommandApdu, "%2x", &l_chData);
    			        l_Data.Add(l_chData);                

                    } else {
                 	    
                        l_CCommandApdu = l_CCommandApdu.SpanExcluding(",");
                        static CString l_CError;
                        l_CError = "Illegal value found: " + l_CCommandApdu;
                        throw (PCHAR) (LPCSTR) l_CError;
                    } 
                	    
                    l_ichStart = l_CCommandApdu.Find(',');
                    if (l_ichStart != -1) {
                 	    
                        l_CCommandApdu = l_CLine.Right(l_CCommandApdu.GetLength() - l_ichStart - 1);
                    }

		        } while (l_ichStart != -1);

                if (l_CLine.Find('\\') != -1) {
        	        
                    // we have to read more data from the file
                    l_bContinue = TRUE;

                } else {

                    if (m_pCCurrentCard == NULL) {

                        throw "Card command found, but no card defined";
                    }
            	        
		            AddCardFunction(
			            l_CCommand,
			            l_chKey,
			            l_Data
			            );

                    l_CCommand = "";
                    l_Data.RemoveAll();
                    l_bContinue = FALSE;            	
                }
	        } 
        }
        catch (PCHAR in_pchError){
    
		    printf(
                "%s (%d): %s\n",
                in_CScriptFileName, 
                l_uLineNumber,
                in_pchError
                );	

            l_CCommand = "";
            l_Data.RemoveAll();
            l_bContinue = FALSE;            	
        }
	}

	m_pCCurrentCard = NULL;
}	    

void
CCardList::ShowCards(
    void (__cdecl *in_pCallBack)(void *in_pContext, PCHAR in_pchCardName),
    void *in_pContext
	)
{
	CCard *l_pCCurrentCard = m_pCFirstCard;

    if (l_pCCurrentCard == NULL) {

        return;
    }

	while(l_pCCurrentCard) {

        (*in_pCallBack) (in_pContext, (PCHAR) (LPCSTR) l_pCCurrentCard->m_CName);

		l_pCCurrentCard = l_pCCurrentCard->m_pCNextCard;
	}
}

BOOL
CCardList::ListFunctions(
	void
	)
/*++
	List all card functions
--*/
{
	if (m_pCCurrentCard == NULL)
		return FALSE;

	CCardFunction *l_pCCurrentFunction = m_pCCurrentCard->m_pCFirstFunction;

	while(l_pCCurrentFunction) {

		printf("   %s\n", (LPCSTR) l_pCCurrentFunction->m_CName);
		l_pCCurrentFunction = l_pCCurrentFunction->m_pCNextFunction;
	}

	return TRUE;
}

BOOL
CCardList::SelectCard(
	CHAR in_chShortCut
	)
/*++

Routine Description:
	Selectd a card by shorcut

Arguments:
	chShortCut - Shortcut key
	
Return Value:
    TRUE - card found and selected
    FALSE - no card with that shortcut found

--*/
{
	m_pCCurrentCard = m_pCFirstCard;

	while(m_pCCurrentCard) {

        if (m_pCCurrentCard->m_chShortCut == in_chShortCut) {

			return TRUE;
		}

		m_pCCurrentCard = m_pCCurrentCard->m_pCNextCard;
	}

	m_pCCurrentCard = NULL;

	return FALSE;
}

void CCardList::ReleaseCard(
	void
	)
{
	m_pCCurrentCard = NULL;
}

BOOL
CCardList::IsCardSelected(
	void
	)
{
	return (m_pCCurrentCard != NULL);
}

CString 
CCardList::GetCardName(
	void
	)
{
    CString l_CCardName;
    INT l_iLeft = m_pCCurrentCard->m_CName.Find('[');    
    INT l_iLength = m_pCCurrentCard->m_CName.GetLength();

    l_CCardName = 
        m_pCCurrentCard->m_CName.Left(l_iLeft) + 
        m_pCCurrentCard->m_CName[l_iLeft + 1] +
        m_pCCurrentCard->m_CName.Right(l_iLength - l_iLeft - 3);

    return l_CCardName;
}


CByteArray *
CCardList::GetApdu(
	CHAR in_chShortCut
	)
{
	CCardFunction *l_pCCurrentFunction = m_pCCurrentCard->m_pCFirstFunction;

	while(l_pCCurrentFunction) {

		if (l_pCCurrentFunction->m_chShortCut == in_chShortCut) {

			return &l_pCCurrentFunction->m_CData;
		}

		l_pCCurrentFunction = l_pCCurrentFunction->m_pCNextFunction;
	}

	return NULL; 
}

void 
ManualTest(
    CReader &in_CReader
    )
{
    CCardList l_CCardList(CString("ifdtest.dat"));
    ULONG l_uRepeat = 0;
    LONG l_lResult;
    CHAR l_chSelection;
    PUCHAR l_pbResult;
    ULONG l_uState, l_uPrevState;
    CString l_CAnswer;
	CString l_CCardStates[] =  { "Unknown", "Absent", "Present" , "Swallowed", "Powered", "Negotiable", "Specific" };
	BOOL l_bWaitForInsertion, l_bWaitForRemoval;

    while (TRUE)  {

        ULONG l_uResultLength = 0;

        printf("Manual reader test\n");
        printf("------------------\n");

		if (l_CCardList.IsCardSelected()) {

			printf("%s Commands:\n", l_CCardList.GetCardName());
			l_CCardList.ListFunctions();
	        printf("Other Commands:\n");
	        printf("   [r]epeat command\n");
	        printf("   E[x]it\n");

        } else {
         	
	        printf("Reader Commands:\n");
	        printf("   Protocol: T=[0], T=[1]\n");
	        printf("   Power   : [c]oldReset, Power[d]own, Warm[r]eset\n");
	        printf("   Card    : [p]resent, [a]bsent, [s]tatus\n");
	        printf("   PwrMngnt: [h]ibernation\n");
	        printf("   Test    : [v]endor IOCTL\n");
            if (l_CCardList.GetNumCards() != 0) {
             	
	            printf("Card Commands:\n");
			    l_CCardList.ShowCards((void (__cdecl *)(void *,char *)) printf, "   %s\n");
            }
	        printf("Other Commands:\n");
            printf("   E[x]it\n");
        }

	    printf(
            "\n[%s|%s|%ld] - Command: ", 
            in_CReader.GetVendorName(), 
            in_CReader.GetIfdType(), 
            in_CReader.GetDeviceUnit()
            );

        l_chSelection = (CHAR) _getche();
        putchar('\n');

        if (l_CCardList.IsCardSelected()) {

            switch (l_chSelection) {

            case 'x':
    			l_CCardList.ReleaseCard();
                continue;

            case 'r':
	            printf("Enter repeat count: ");
                scanf("%2d", &l_uRepeat);

                if (l_uRepeat > 99) {

                    l_uRepeat = 0;
                }
    	        printf("Enter command: ");
	            l_chSelection = (CHAR) _getche();             	

                // no bbreak;

            default:             	
                CByteArray *l_pCData;

                if((l_pCData = l_CCardList.GetApdu(l_chSelection)) != NULL) {
                    
                    l_lResult = in_CReader.Transmit(
                        l_pCData->GetData(),
                        (ULONG) l_pCData->GetSize(),
                        &l_pbResult,
                        &l_uResultLength
                        );

			    } else {

				    printf("Invalid Selection");
				    continue;
			    }
                break;
            }

		} else {

			switch(l_chSelection){
        
			case '0':
    			printf("Changing to T=0");
                l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T0);
                break;

			case '1':
				printf("Changing to T=1");
                l_lResult = in_CReader.SetProtocol(SCARD_PROTOCOL_T1);
                break;
            
			case 'c':
    			printf("Cold reset");
                l_lResult = in_CReader.ColdResetCard();
                in_CReader.GetAtr(&l_pbResult, &l_uResultLength);
                break;

			case 'r':
    			printf("Warm reset");
                l_lResult = in_CReader.WarmResetCard();
                in_CReader.GetAtr(&l_pbResult, &l_uResultLength);
                break;
            
			case 'd':
				printf("Power down");
                l_lResult = in_CReader.PowerDownCard();
				break;

            case 'h':
                printf("Hibernation test...(1 min)\nHibernate machine now!");
				l_uPrevState = SCARD_UNKNOWN;
				l_bWaitForInsertion = FALSE;
				l_bWaitForRemoval = FALSE;
                for (l_uRepeat = 0; l_uRepeat < 60; l_uRepeat++) {
                 	
                    l_lResult = in_CReader.GetState(&l_uState);

					l_lResult = in_CReader.FinishWaitForCard(FALSE);

					if (l_uPrevState != SCARD_UNKNOWN && 
						l_lResult == ERROR_SUCCESS) {

						printf("\n   Card %s", l_bWaitForInsertion ? "inserted" : "removed"); 
						l_uPrevState = SCARD_UNKNOWN;	
						l_bWaitForInsertion = FALSE;
						l_bWaitForRemoval = FALSE;
					}

					if (l_uState == SCARD_ABSENT) { 

						if (l_bWaitForInsertion == FALSE) {

							l_lResult = in_CReader.StartWaitForCardInsertion();
							l_bWaitForInsertion = TRUE;
							l_bWaitForRemoval = FALSE;
						}

					} else {
						
						if (l_bWaitForRemoval == FALSE) {

							l_lResult = in_CReader.StartWaitForCardRemoval();
							l_bWaitForRemoval = TRUE;
							l_bWaitForInsertion = FALSE;
						}
					}

					if (l_uState != l_uPrevState) {

						printf("\n   %s", l_CCardStates[l_uState]);
					}
					if (l_uState >= SCARD_PRESENT && l_uState < SCARD_NEGOTIABLE) {

		                l_lResult = in_CReader.ColdResetCard();
					}
					if (l_uState == SCARD_NEGOTIABLE) {

		                l_lResult = in_CReader.SetProtocol(
							SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1
							);
					}
					printf(".");
					l_uPrevState = l_uState;

                    LONG l_uGoal = clock() + CLOCKS_PER_SEC;
                    while(l_uGoal > clock())
                        ;
                }
				printf("\nPlease %s card", l_uState >= SCARD_PRESENT ? "remove" : "insert");
				in_CReader.FinishWaitForCard(TRUE);
				printf("\n");
                continue;
            	break;
                
			case 's': 
				printf("Get state");
                l_lResult = in_CReader.GetState(&l_uState);
				printf("Get state 1");
                l_pbResult = (PBYTE) &l_uState;
                l_uResultLength = sizeof(ULONG);
				break;

			case 'a':
				printf("Waiting for removal...");
                l_lResult = in_CReader.WaitForCardRemoval();
                break;

			case 'p':
				printf("Waiting for insertion...");
                l_lResult = in_CReader.WaitForCardInsertion();
                break;

            case 'v':
				printf("Test Vendor IOCTL...");
                l_lResult = in_CReader.VendorIoctl(l_CAnswer);
                l_pbResult = (PUCHAR) ((LPCSTR) l_CAnswer);
                l_uResultLength = l_CAnswer.GetLength();
               	break;
            
			case 'x':
				exit(0);
            
			default:
				// Try to select a card
				if (l_CCardList.SelectCard(l_chSelection) == FALSE) {

					printf("Invalid selection\n");
				}
                l_uRepeat = 0;
				continue;
			}
		}

        printf(
            "\nReturn value: %lxh (NTSTATUS %lxh)\n",                
            l_lResult, 
            MapWinErrorToNtStatus(l_lResult)
            );

        if (l_lResult == ERROR_SUCCESS && l_uResultLength) {

            ULONG l_uIndex, l_uLine, l_uCol;
        
            // The I/O request has data returned
            printf("Data returned (%ld bytes):\n   %04x: ", l_uResultLength, 0);

            for (l_uLine = 0, l_uIndex = 0; 
                 l_uLine < ((l_uResultLength - 1) / 8) + 1; 
                 l_uLine++) {

                for (l_uCol = 0, l_uIndex = l_uLine * 8; 
                     l_uCol < 8; l_uCol++, 
                     l_uIndex++) {
            	    
                    printf(
                        l_uIndex < l_uResultLength ? "%02x " : "   ",
                        l_pbResult[l_uIndex]
                        );
                }

              	putchar(' ');

                for (l_uCol = 0, l_uIndex = l_uLine * 8; 
                     l_uCol < 8; l_uCol++, 
                     l_uIndex++) {

                    printf(
                        l_uIndex < l_uResultLength ? "%c" : " ",
                        isprint(l_pbResult[l_uIndex]) ? l_pbResult[l_uIndex] : '.'
                        );
                }

                putchar('\n');
				if (l_uIndex  < l_uResultLength) {

                	printf("   %04x: ", l_uIndex + 1);
				}
            }
        }
        putchar('\n');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\inc\smcnt.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    smcnt.h

Abstract:

    This files inlcudes the Windows NT specific data structure
    for the smart card library

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

--*/

#define SMCLIB_NT 1

typedef struct _OS_DEP_DATA {

	// Pointer to the device object (Must be set by driver)
	PDEVICE_OBJECT DeviceObject;

    //
	// This is the current Irp to be processed
    // Use OsData->SpinLock to access this member
    //
	PIRP CurrentIrp;

    //
    // Irp to be notified of card insertion/removal 
    // Use OsData->SpinLock to access this member
    //
    PIRP NotificationIrp;

    // Used to synchronize access to the driver 
    KMUTANT Mutex;

    // Use this spin lock to access protected members (see smclib.h)
    KSPIN_LOCK SpinLock;

    struct {
     	
        BOOLEAN Removed;
        LONG RefCount;
        KEVENT RemoveEvent;
		LIST_ENTRY TagList;
    } RemoveLock;

#ifdef DEBUG_INTERFACE
    PDEVICE_OBJECT DebugDeviceObject;
#endif

} OS_DEP_DATA, *POS_DEP_DATA;

#ifdef  POOL_TAGGING
#ifndef ExAllocatePool
#error  ExAllocatePool not defined
#endif
#undef  ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b, SMARTCARD_POOL_TAG) 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\inc\smclib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    smclib.h

Abstract:

    This module contains all definitions for the smart card library.
	All defintions are made according to ISO 7816.

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 
    - Jun. 97:  Definitions for Windows 9x added
    - Feb. 98:  PTS struct added 
                Async./Sync. protocols now combined

--*/

#ifndef _SMCLIB_
#define _SMCLIB_

#if DBG || DEBUG
#undef DEBUG
#define DEBUG 1
#undef DBG
#define DBG 1
#pragma message("Debug is turned on")
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SMCLIB_VXD
//
// Include windows 9x specific data definitions
//
#include "smcvxd.h"
#elif defined(SMCLIB_CE)
//
// Include Windows CE specific data definitons
//
#include "smcce.h"
#else
//
// Include Windows NT specific data definitions
//
#include "smcnt.h"
#endif

#include "winsmcrd.h"
//
// This name is displayed in debugging messages
//
#ifndef DRIVER_NAME
#define DRIVER_NAME "SMCLIB"
#endif

//
// This version number changes for every change of the device extension.
// (I.e. new fields were added)
// The required version is the version number that the lib is compatible to.
//
#define SMCLIB_VERSION          0x150
#define SMCLIB_VERSION_REQUIRED 0x100

#if DEBUG
#define DEBUG_IOCTL     ((ULONG) 0x00000001)
#define DEBUG_ATR       ((ULONG) 0x00000002)
#define DEBUG_PROTOCOL  ((ULONG) 0x00000004)
#define DEBUG_DRIVER    ((ULONG) 0x00000008)
#define DEBUG_TRACE     ((ULONG) 0x00000010)
#define DEBUG_ERROR     ((ULONG) 0x00000020)
#define DEBUG_INFO      DEBUG_ERROR
#define DEBUG_PERF      ((ULONG) 0x10000000)
#define DEBUG_T1_TEST   ((ULONG) 0x40000000)
#define DEBUG_BREAK     ((ULONG) 0x80000000)
#define DEBUG_ALL       ((ULONG) 0x0000FFFF)
#endif

#ifdef SMCLIB_VXD

// ****************************************************************************
// Windows 9x definitions
// ****************************************************************************

typedef LONG NTSTATUS;
typedef UCHAR BOOLEAN;           

//
// include this file to get nt status codes
//
#include <ntstatus.h>

//
// The following three definition are taken out of the ntddk.h file
// Please refer to this file for a description
//
#define METHOD_BUFFERED                 0
#define FILE_ANY_ACCESS                 0
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the ASSERT macro for Windows 9x
//
#if DEBUG
NTSTATUS
VXDINLINE 
SmartcardAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
	);

#define ASSERT( exp ) \
    if (!(exp)) { \
     	SmartcardAssert( #exp, __FILE__, __LINE__, NULL ); \
        _asm int 3 \
    } else


#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
     	SmartcardAssert( #exp, __FILE__, __LINE__, msg ); \
        _asm int 3 \
    } else 
        
#define SmartcardDebug(LEVEL, STRING) \
        { \
            if ((LEVEL) & (DEBUG_ERROR | SmartcardGetDebugLevel())) \
                _Debug_Printf_Service STRING; \
            if (SmartcardGetDebugLevel() & DEBUG_BREAK) \
                _asm int 3 \
        }

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#define SmartcardDebug(LEVEL, STRING)
#endif // DEBUG

#define AccessUnsafeData(Irql) 
#define EndAccessUnsafeData(Irql)

#define RtlCopyMemory memcpy
#define RtlZeroMemory(d, c) memset((d), 0, (c))

// ****************************************************************************
// End Windows 9x definitions
// ****************************************************************************

#elif defined(SMCLIB_CE)
// ****************************************************************************
// Windows CE definitions
// ****************************************************************************

// Use the debug message structs and macros from dbgapi.h
// Driver has to define and initialize a DEBUGPARAM struct


#define SmartcardDebug(LEVEL, STRING) DEBUGMSG(dpCurSettings.ulZoneMask & (LEVEL), STRING)

#define SmartcardLockDevice(SmartcardExtension) EnterCriticalSection(&(SmartcardExtension)->OsData->CritSect)
#define SmartcardUnlockDevice(SmartcardExtension) LeaveCriticalSection(&(SmartcardExtension)->OsData->CritSect)

#define AccessUnsafeData(Irql) SmartcardLockDevice(SmartcardExtension)
#define EndAccessUnsafeData(Irql) SmartcardUnlockDevice(SmartcardExtension)

// ****************************************************************************
// End Windows CE definitions
// ****************************************************************************

#else

// ****************************************************************************
// Windows NT definitions
// ****************************************************************************

#if DEBUG
#define SmartcardDebug(LEVEL, STRING) \
        { \
            if ((LEVEL) & (DEBUG_ERROR | SmartcardGetDebugLevel())) \
                DbgPrint STRING; \
            if (SmartcardGetDebugLevel() & DEBUG_BREAK) \
                DbgBreakPoint(); \
        }

#else
#define SmartcardDebug(LEVEL, STRING) 
#endif

#define AccessUnsafeData(Irql) \
    KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, (Irql));
#define EndAccessUnsafeData(Irql) \
    KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, (Irql));

#ifndef SMART_CARD_READER_GUID_DEFINED
#define SMART_CARD_READER_GUID_DEFINED
#include <initguid.h>
DEFINE_GUID(SmartCardReaderGuid, 0x50DD5230, 0xBA8A, 0x11D1, 0xBF,0x5D,0x00,0x00,0xF8,0x05,0xF5,0x30);

// ****************************************************************************
// End Windows NT definitions
// ****************************************************************************

#endif
#endif

//
// Indexes to the callback functions of the ReaderFunction array 
// in the SmartcardExtension
//
#define RDF_CARD_POWER 		0
#define RDF_TRANSMIT		1
#define RDF_CARD_EJECT		2
#define RDF_READER_SWALLOW 	3
#define RDF_CARD_TRACKING	4
#define RDF_SET_PROTOCOL	5
#define RDF_DEBUG_LEVEL		6
#define RDF_CARD_CONFISCATE 7
#define RDF_IOCTL_VENDOR    8
#define RDF_ATR_PARSE       9

//
// Minimum buffer size for request and reply buffer
//
#define MIN_BUFFER_SIZE	288

//
// This union is used for data type conversion
//
typedef union _LENGTH {
	
	struct {

		ULONG	l0;

	} l;

	struct {

		UCHAR 	b0;
		UCHAR	b1;
		UCHAR	b2;
		UCHAR	b3;
	} b;

} LENGTH, *PLENGTH;

#define MAXIMUM_ATR_CODES					4
#define MAXIMUM_ATR_LENGTH					33

typedef struct _T0_DATA {

	// Number of data bytes in this request
	ULONG	Lc;

	// Number of expected bytes from the card
	ULONG	Le;

} T0_DATA, *PT0_DATA;

//
// constants for the T=1 i/o function
//
#define T1_INIT             0
#define T1_START			1
#define T1_I_BLOCK			2
#define T1_R_BLOCK			3
#define T1_RESTART          4
#define T1_RESYNCH_REQUEST	0xC0
#define T1_RESYNCH_RESPONSE	0xE0
#define T1_IFS_REQUEST		0xC1
#define T1_IFS_RESPONSE		0xE1
#define T1_ABORT_REQUEST   	0xC2
#define T1_ABORT_RESPONSE  	0xE2
#define T1_WTX_REQUEST		0xC3
#define T1_WTX_RESPONSE		0xE3
#define T1_VPP_ERROR		0xE4

//
// Information field size the lib uses
//
#define T1_IFSD             254
#define T1_IFSD_DEFAULT		 32

//
// Maximum attempts to resend a block in T1
//
#define T1_MAX_RETRIES		2

//
// Bit that indenticates if there are more data to send
//
#define T1_MORE_DATA		0x20

//
// T1 Error values
//
#define T1_ERROR_CHKSUM		1
#define T1_ERROR_OTHER		2

//
// Error detection bit as defined by ISO 
//
#define T1_CRC_CHECK		1

//
// Character waiting integer default value as definded by ISO
//
#define T1_CWI_DEFAULT		13

//
// Block waiting integer default value as definded by ISO
//
#define T1_BWI_DEFAULT		4

//
// This struct is used by the lib for processing T1 I/O
// It should not be modified by a driver directly.
//
typedef struct _T1_DATA {

	// Current information field size that can be transmitted
	UCHAR	IFSC;

    // Current information field size we can receive
    UCHAR   IFSD;

	// Number of bytes already received from smart card
	ULONG	BytesReceived;

	// Number of bytes already sent to the card;
	ULONG	BytesSent;

	// Total number of bytes still to send
	ULONG	BytesToSend;

	// Type of error 
	UCHAR 	LastError;

	// This flag is set whenever the IFD has to send more data
	BOOLEAN	MoreData;

	// This is the node address byte to be sent to the card
	UCHAR 	NAD;

	// The state before an error occured
	ULONG	OriginalState;

	// Resend counter
	UCHAR	Resend;

	// Resync counter
	UCHAR	Resynch;

	// The 'number' of received I-Blocks
	UCHAR	RSN;

	// The 'number' of sent I-Blocks as defined in ISO 7816-3
	UCHAR	SSN;

	// Current state of protocol
	ULONG	State;

	//
	// Waiting time extension requested by the smart card
	// This value should be used by the driver to extend block waiting time.
	//
	UCHAR	Wtx;

    // Pointer to result buffer
    PUCHAR  ReplyData;

    // This flag indicates that we're waiting for a reply from the card
    BOOLEAN WaitForReply;

    UCHAR   InfBytesSent;

#ifndef _WIN64
    // Reserved, do not use
    UCHAR Reserved[
        10 - 
        sizeof(PUCHAR) -
        sizeof(BOOLEAN) - 
        sizeof(UCHAR)];
#endif

} T1_DATA, *PT1_DATA;

//
// This struct is used by the lib for T1 I/O
//
typedef struct _T1_BLOCK_FRAME {
    
    UCHAR   Nad;
    UCHAR   Pcb;
    UCHAR   Len;
    PUCHAR  Inf;

} T1_BLOCK_FRAME, *PT1_BLOCK_FRAME;

//
// All lib functions put their data to send in this struct.
// The driver must send this data to the reader.
//
typedef struct _SMARTCARD_REQUEST {

	// Data to send
	PUCHAR	Buffer;

	// Allocted size of this buffer
	ULONG 	BufferSize;

	// Length of data for this command
	ULONG	BufferLength;

} SMARTCARD_REQUEST, *PSMARTCARD_REQUEST;

//
// The driver must put the received bytes into this buffer and 
// adjust the buffer length to the number of received bytes.
//
typedef struct _SMARTCARD_REPLY {
	
	// Buffer for received smart card data
	PUCHAR	Buffer;

	// Allocted size of this buffer
	ULONG 	BufferSize;

	// Number of bytes received from the card
	ULONG	BufferLength;

} SMARTCARD_REPLY, *PSMARTCARD_REPLY;

//
// Clock rate conversion table according to ISO 
//
typedef struct _CLOCK_RATE_CONVERSION {

	const ULONG F;
	const ULONG fs; 

} CLOCK_RATE_CONVERSION, *PCLOCK_RATE_CONVERSION;

//
// Bit rate adjustment factor 
// The layout of this table has been slightly modified due to 
// the unavailibility of floating point math support in the kernel.
// The value D has beed devided into a numerator and a divisor.
//
typedef struct _BIT_RATE_ADJUSTMENT {

	const ULONG DNumerator;
	const ULONG DDivisor;

} BIT_RATE_ADJUSTMENT, *PBIT_RATE_ADJUSTMENT;

#ifdef _ISO_TABLES_
#define MHZ * 1000000l

//
// The clock rate conversion table itself.
// All R(eserved)F(or Future)U(se) fields MUST be 0
//
static CLOCK_RATE_CONVERSION ClockRateConversion[] = {

		{ 372, 	4 MHZ	}, 
		{ 372, 	5 MHZ	}, 
		{ 558, 	6 MHZ	}, 
		{ 744, 	8 MHZ	}, 
		{ 1116, 12 MHZ	}, 
		{ 1488, 16 MHZ	},
		{ 1860, 20 MHZ	},
		{ 0, 	0		},
		{ 0, 	0		},
		{ 512, 	5 MHZ	},
		{ 768, 	7500000	},
		{ 1024, 10 MHZ	},
		{ 1536, 15 MHZ	},
		{ 2048, 20 MHZ	},
		{ 0, 	0		},
		{ 0, 	0		}
};		

#undef MHZ

//
// The bit rate adjustment table itself.
// All R(eserved)F(or)U(se) fields MUST be 0
//
static BIT_RATE_ADJUSTMENT BitRateAdjustment[] = {

	{ 0,	0	},
	{ 1,	1	},
	{ 2,	1	},
	{ 4,	1	},
	{ 8,	1	},
	{ 16,	1	},
	{ 32,	1	},
	{ 0,	0	},
	{ 12,	1	},
	{ 20,	1	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	},
	{ 0,	0	}
};
#endif

#if defined (DEBUG) && defined (SMCLIB_NT)
typedef struct _PERF_INFO { 

    ULONG NumTransmissions;
    ULONG BytesSent;
    ULONG BytesReceived;
    LARGE_INTEGER IoTickCount;
    LARGE_INTEGER TickStart;
    LARGE_INTEGER TickEnd;
} PERF_INFO, *PPERF_INFO;
#endif

//
// structure used for protocol type selection (PTS)
//
typedef struct _PTS_DATA {

#define PTS_TYPE_DEFAULT 0x00
#define PTS_TYPE_OPTIMAL 0x01
#define PTS_TYPE_USER    0x02

    UCHAR Type;

    // Fl value for PTS
    UCHAR Fl;

    // Dl value for PTS
    UCHAR Dl;     	

    // New clock frequency
    ULONG CLKFrequency;

    // New baud rate to be used after pts
    ULONG DataRate;

    // new stop bits to be used after pts
    UCHAR StopBits;

} PTS_DATA, *PPTS_DATA;

//
// This struct holds information for the card currently in use
// The driver must store a received ATR into the ATR struct which is
// part of this struct. The lib will get all other information 
// out of the ATR.
//
typedef struct _SCARD_CARD_CAPABILITIES{

	// Flag that indicates that the current card uses invers convention
	BOOLEAN InversConvention;

	// Calculated etu 
	ULONG	etu;
      
    //
    // Answer To Reset string returned by card.
    // Use OsData->SpinLock to access this member
    //
	struct {

		UCHAR Buffer[64];
		UCHAR Length;

	} ATR;

	struct {

		UCHAR Buffer[16];
		UCHAR Length;

	} HistoricalChars;

    // !!! DO NOT MODIFY ANY OF THE BELOW VALUES
    // OTHERWISE THE LIBRARY WON'T WORK PROPERLY

	//
	// The following 2 tables are provided to give 
	// the driver access to the ISO definitions
	//
	PCLOCK_RATE_CONVERSION 	ClockRateConversion;
	PBIT_RATE_ADJUSTMENT 	BitRateAdjustment;

	// Clock rate conversion 
	UCHAR Fl;

	// Bit rate adjustment
	UCHAR Dl;

	// Maximum programming current
	UCHAR II;

	// Programming voltage in .1 Volts
	UCHAR P;

	// Extra guard time in etu 
	UCHAR N;

	// Calculated guard time in micro seconds
	ULONG GT;

	struct {

		// This is a bit mask of the supported protocols
		ULONG Supported;
		// The currently selected protocol
		ULONG Selected;

	} Protocol;

	// T=0 specific data
	struct {

		// Waiting integer
		UCHAR WI;

		// Waiting time in micro seconds
		ULONG WT;

	} T0;

	// T=1 specific data
	struct {

		// Information field size of card
		UCHAR IFSC;

		// Character waiting integer and block waiting integer
		UCHAR CWI;
		UCHAR BWI;

		// Error detection code
		UCHAR EDC;

		// Character and block waiting time in micro seconds
		ULONG CWT;
		ULONG BWT;

		// Block guarding time in micro seconds
		ULONG BGT;

	} T1;

    PTS_DATA PtsData;

    UCHAR Reserved[100 - sizeof(PTS_DATA)];

} SCARD_CARD_CAPABILITIES, *PSCARD_CARD_CAPABILITIES;

//
// structure used for passing configuration info between miniport/class
//
typedef struct _SCARD_READER_CAPABILITIES {

	// Supported protocol by the reader/driver (mandatory)
    ULONG SupportedProtocols;

    ULONG Reserved;

	// Type of reader (Serial/USB/PCMCIA/Keyboard etc)
	ULONG	ReaderType;

	// Mechanical characteristics like SCARD_READER_SWALLOWS etc.
	ULONG	MechProperties;

    //
    // Current state of reader (card present/removed/activated)
    // Use OsData->SpinLock to access this member
    // (mandatory)
    //
    ULONG 	CurrentState;

	//
	// The channel id the reader uses depending on the type of reader:
	// 	- Port number for serial reader
	//	- Port number for par reader
	//	- Scsi id for scsi reader
	//	- 0 for keyboard reader
	//	- device number for USB
	//
	ULONG	Channel;

    //
    // Clock rates in KHz encoded as little endian
    // (I.e. 3.58MHz is encoded as 3580)
    // (mandatory)
    //
    struct {
     	
        ULONG Default;
        ULONG Max;

    } CLKFrequency;

    // Data rates in bps encoded as little endian (mandatory)
    struct {
     	
        ULONG Default;
        ULONG Max;

    } DataRate;

    // Maximum IFSD supported by IFD
    ULONG   MaxIFSD;              

    //
    // Type of power management the card supports
    // (0 = ifd doesn't support pwr mgnt)
    //
    ULONG   PowerMgmtSupport;

    // Boolean that indicates that the card has been confiscated
    ULONG   CardConfiscated;

    //
    // A list of data rates supported by the ifd.
    // If this list is empty, the DataRate struct will be taken
    // (optional)
    //
    struct _DataRatesSupported {

        PULONG List;
        UCHAR  Entries;
     	
    } DataRatesSupported;

    //
    // A list of supported clock frequencies.
    // If this list is empty, the CLKFrequency struct will be taken
    // (optional)
    //
    struct _CLKFrequenciesSupported {
     	
        PULONG List;
        UCHAR  Entries;

    } CLKFrequenciesSupported;

    // Reserved, do not use
    UCHAR Reserved1[
        100 - 
        sizeof(ULONG) - 
        sizeof(struct _DataRatesSupported) - 
        sizeof(struct _CLKFrequenciesSupported)
        ];

} SCARD_READER_CAPABILITIES, *PSCARD_READER_CAPABILITIES;

//
// This struct holds the mandatory reader info
//
typedef struct _VENDOR_ATTR {

	// Manufacturer name (mandatory)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} VendorName;

	// Name (designation) of reader (mandatory)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} IfdType;

	//
	// If more than one reader of the same type are installed
	// this unit number is used to destinguish these readers
	// (mandatory)
    //
	ULONG	UnitNo;

    // IFD Version number (optional)
    struct {
        
        USHORT  BuildNumber;
        UCHAR   VersionMinor;
        UCHAR   VersionMajor;
    } IfdVersion;

    // IFD Serial number (optional)
	struct {
		
		USHORT Length;
		UCHAR  Buffer[MAXIMUM_ATTR_STRING_LENGTH];
	} IfdSerialNo;

    // Reserved, do not use
    ULONG   Reserved[25];

} VENDOR_ATTR, *PVENDOR_ATTR;

//                                           
// Forward definitions
//
typedef struct _READER_EXTENSION *PREADER_EXTENSION;
typedef struct _OS_DEP_DATA *POS_DEP_DATA;
typedef struct _SMARTCARD_EXTENSION *PSMARTCARD_EXTENSION;

//
// Define the smartcard portion of the port device extension.
//
typedef struct _SMARTCARD_EXTENSION {

    // Version of this structure
    ULONG           Version;

	// Mandatory reader info
	VENDOR_ATTR		VendorAttr;

	// Array of callback reader functions
	NTSTATUS (*ReaderFunction[16])(PSMARTCARD_EXTENSION);

	// Capabilities of the current inserted card
	SCARD_CARD_CAPABILITIES	CardCapabilities;

	//
	// This is used to store the last error of an overlapped operation
	// (Used only for Win9x VxD's)
    //
	ULONG LastError;

	// This struct holds the data of the users io request
	struct {

		// Number of bytes returned
		PULONG	Information;
		
		// Pointer to data to send to the card
		PUCHAR	RequestBuffer;

		// Number of bytes to send
		ULONG	RequestBufferLength;

		// Pointer to buffer that receives the answer
		PUCHAR	ReplyBuffer;

		// Size of reply buffer
		ULONG	ReplyBufferLength;

	} IoRequest;

	// Major and minor io control code for current request
	ULONG	MajorIoControlCode;
	ULONG	MinorIoControlCode;

	// OS dependent data
	POS_DEP_DATA    OsData;

	// Capabilities of the keyboard-reader
	SCARD_READER_CAPABILITIES	ReaderCapabilities;

	// Reader specific data
	PREADER_EXTENSION	ReaderExtension;

    //
	// The reader stores all replies from the card here
    // This can be used by the driver for data coming from the reader
    //
	SMARTCARD_REPLY		SmartcardReply;

    //
	// Current command that will be sent to the smart card
    // This can be used by the driver for data to send to the readaer
    //
	SMARTCARD_REQUEST	SmartcardRequest;

	// Data for T=0
	T0_DATA	T0;

	// Data for T=1
	T1_DATA	T1;

#if defined (DEBUG) && defined (SMCLIB_NT)
    PPERF_INFO PerfInfo;
#endif
    // Reserved, do not use
    ULONG   Reserved[
        25 
#if defined (DEBUG) && defined (SMCLIB_NT)
        - sizeof(PPERF_INFO)
#endif
        ];

} SMARTCARD_EXTENSION, *PSMARTCARD_EXTENSION;

#ifdef SMCLIB_VXD

// ****************************************************************************
// Windows 95 definitions and prototyping
// ****************************************************************************

#ifndef SMCLIB_DEVICE_ID
#define SMCLIB_DEVICE_ID    0x0004E /* Smart Card port driver */
#else
#if SMCLIB_DEVICE_ID != 0x0004E
#error "Incorrect SMCLIB_DEVICE_ID Definition"
#endif
#endif

#define SMCLIB_Service Declare_Service
#pragma warning(disable:4003)

Begin_Service_Table(SMCLIB)
SMCLIB_Service(SMCLIB_Get_Version)
SMCLIB_Service(SMCLIB_SmartcardCreateLink)
SMCLIB_Service(SMCLIB_SmartcardDeleteLink)
SMCLIB_Service(SMCLIB_SmartcardDeviceControl)
SMCLIB_Service(SMCLIB_SmartcardExit)
SMCLIB_Service(SMCLIB_SmartcardInitialize)
SMCLIB_Service(SMCLIB_SmartcardLogError)
SMCLIB_Service(SMCLIB_SmartcardRawReply)
SMCLIB_Service(SMCLIB_SmartcardRawRequest)
SMCLIB_Service(SMCLIB_SmartcardT0Reply)
SMCLIB_Service(SMCLIB_SmartcardT0Request)
SMCLIB_Service(SMCLIB_SmartcardT1Reply)
SMCLIB_Service(SMCLIB_SmartcardT1Request)
SMCLIB_Service(SMCLIB_SmartcardUpdateCardCapabilities)
SMCLIB_Service(SMCLIB_SmartcardGetDebugLevel)
SMCLIB_Service(SMCLIB_SmartcardSetDebugLevel)
SMCLIB_Service(SMCLIB_MapNtStatusToWinError)
SMCLIB_Service(SMCLIB_Assert)
SMCLIB_Service(SMCLIB_VxD_CreateDevice)
SMCLIB_Service(SMCLIB_VxD_DeleteDevice)
SMCLIB_Service(SMCLIB_SmartcardCompleteCardTracking)
SMCLIB_Service(SMCLIB_SmartcardCompleteRequest)
End_Service_Table(SMCLIB)

PVMMDDB
VXDINLINE 
VxD_CreateDevice(
    char *Device, 
    void (*ControlProc)(void)
	)
{
    _asm push ControlProc
    _asm push Device
    VxDCall(SMCLIB_VxD_CreateDevice); 	
    _asm add sp, 8
}

BOOL
VXDINLINE 
VxD_DeleteDevice(
    PVMMDDB pDDB
	)
{
    _asm push pDDB
    VxDCall(SMCLIB_VxD_DeleteDevice); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
	)
{
    _asm push Message
    _asm push LineNumber
    _asm push FileName
    _asm push FailedAssertion
    VxDCall(SMCLIB_Assert); 	
    _asm add sp, 16
}

NTSTATUS
VXDINLINE 
SmartcardCreateLink(
	PUCHAR LinkName,
	PUCHAR DeviceName
	)
{
    _asm push DeviceName
    _asm push LinkName
    VxDCall(SMCLIB_SmartcardCreateLink); 	
    _asm add sp, 8
}

NTSTATUS
VXDINLINE 
SmartcardDeleteLink(
	PUCHAR LinkName
	)
{
    _asm push LinkName
    VxDCall(SMCLIB_SmartcardDeleteLink); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DIOCPARAMETERS *lpDIOCParmas
    )
{
    _asm push lpDIOCParmas
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardDeviceControl); 	
    _asm add sp, 8
}

VOID
VXDINLINE 
SmartcardExit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardExit); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardInitialize(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardInitialize); 	
    _asm add sp, 4
}

VOID
VXDINLINE 
SmartcardLogError(
    )
{
    VxDCall(SMCLIB_SmartcardLogError); 		
}

NTSTATUS
VXDINLINE 
SmartcardRawReply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardRawReply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardRawRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardRawRequest); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT0Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT0Reply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT0Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT0Request); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT1Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT1Reply); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardT1Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardT1Request); 	
    _asm add sp, 4
}

NTSTATUS
VXDINLINE 
SmartcardUpdateCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardUpdateCardCapabilities); 	
    _asm add sp, 4
}

ULONG
VXDINLINE 
SmartcardGetDebugLevel(
	void
	)
{
    VxDCall(SMCLIB_SmartcardGetDebugLevel); 	
}

void
VXDINLINE 
SmartcardSetDebugLevel(
	ULONG Level
	)
{
    _asm push Level
    VxDCall(SMCLIB_SmartcardSetDebugLevel); 	
    _asm add sp, 4
}

void
VXDINLINE 
SmartcardCompleteCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardCompleteCardTracking); 	
    _asm add sp, 4
}

void
VXDINLINE 
SmartcardCompleteRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
{
    _asm push SmartcardExtension
    VxDCall(SMCLIB_SmartcardCompleteRequest); 	
    _asm add sp, 4
}

ULONG
VXDINLINE 
MapNtStatusToWinError(
	NTSTATUS status
	)
{
    _asm push status
    VxDCall(SMCLIB_MapNtStatusToWinError); 	
    _asm add sp, 4
}

VOID
SmartcardInvertData(
	PUCHAR Buffer,
	ULONG Length
    );

#else 

// ****************************************************************************
// Windows NT and Windows CE prototyping
// ****************************************************************************

#ifndef _SMCLIBSYSTEM_
#define SMCLIBAPI _declspec(dllimport)
#else
#define SMCLIBAPI
#endif

#ifdef SMCLIB_CE
#define SmartcardLogError(Object,ErrorCode,Insertion,DumpWord)
#else
VOID
SMCLIBAPI
SmartcardLogError(
    PVOID Object,
	LONG ErrorCode,
	PUNICODE_STRING Insertion,
    ULONG DumpWord
	);
#endif


#ifdef SMCLIB_CE
NTSTATUS
SMCLIBAPI
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    DWORD dwIoControlCode,
    PBYTE pInBuf,
    DWORD nInBufSize,
    PBYTE pOutBuf,
    DWORD nOutBufSize,
    PDWORD pBytesReturned
    );
#else
NTSTATUS
SMCLIBAPI
SmartcardDeviceControl(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PIRP Irp
    );
#endif

VOID
SMCLIBAPI
SmartcardInitializeCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardInitialize(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
SMCLIBAPI
SmartcardCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
SMCLIBAPI
SmartcardExit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardUpdateCardCapabilities(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
SMCLIBAPI
SmartcardRawRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT0Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT1Request(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardRawReply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT0Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SMCLIBAPI
SmartcardT1Reply(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID 
SMCLIBAPI
SmartcardInvertData(
	PUCHAR Buffer,
	ULONG Length
	);

#ifndef SMCLIB_CE
// Following APIs not defined in Windows CE
NTSTATUS
SMCLIBAPI
SmartcardCreateLink(
	IN OUT PUNICODE_STRING LinkName,
	IN PUNICODE_STRING DeviceName
	);

ULONG
SMCLIBAPI
SmartcardGetDebugLevel(
	void
	);

void
SMCLIBAPI
SmartcardSetDebugLevel(
	ULONG Level
	);

NTSTATUS
SmartcardAcquireRemoveLock(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
SmartcardAcquireRemoveLockWithTag(
	IN PSMARTCARD_EXTENSION SmartcardExtension,
	IN ULONG Tag
	);

VOID
SmartcardReleaseRemoveLock(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
SmartcardReleaseRemoveLockWithTag(
	IN PSMARTCARD_EXTENSION SmartcardExtension,
	IN ULONG Tag
	);

VOID
SmartcardReleaseRemoveLockAndWait(
	IN PSMARTCARD_EXTENSION SmartcardExtension
    );
#else
// WinCE only
ULONG
MapNtStatusToWinError(
	NTSTATUS status
	);
#endif

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220ser.c ===
/*++

	Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220Ser.c

Abstract:

	This module contains the functions for the 220 serial smart card reader.
	Most functions herein will be called by the smart card lib.


Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz 

    - Modified December 1997 by Brian Manahan for use with
        the 220 reader.
--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "L220SCR.h"


// Make functions pageable
#pragma alloc_text(PAGEABLE, Lit220Command)
#pragma alloc_text(PAGEABLE, Lit220SetProtocol)
#pragma alloc_text(PAGEABLE, Lit220IoRequest)
#pragma alloc_text(PAGEABLE, Lit220IoReply)


NTSTATUS
Lit220CardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

	The smart card lib requires to have this function. It is called 
	to set up event tracking for card insertion and removal events.
    We set the cancel routine so the IRP can be canceled.
    We always return STATUS_PENDING and the Lit220NotifyCardChange
    will signal the completion when called from the Lit220InputFilter.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    KIRQL oldIrql;
    KIRQL oldOsDataIrql;

    //
    // Set the wait mask for the isr. The isr will complete the 
    // user request.
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_INSERTION; // WAIT_INSERTION - wait for insertion or removal

    //
    // Set cancel routine for the notification irp
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &oldOsDataIrql
        );

    ASSERT (SmartcardExtension->OsData->NotificationIrp);

    if (SmartcardExtension->OsData->NotificationIrp) {
        IoAcquireCancelSpinLock(
            &oldIrql
            );
    
        IoSetCancelRoutine(
            SmartcardExtension->OsData->NotificationIrp, 
            Lit220Cancel
            );
        
        IoReleaseCancelSpinLock(
            oldIrql
            );

    } else {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220CardTracking: SmartcardExtension->OsData->NotificationIrp is NULL!!! This should not be.\n", 
            DRIVER_NAME
            ));
    }

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        oldOsDataIrql
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220CardTracking: Exit, WaitMask %X, NotificationIRP %X\n", 
        DRIVER_NAME, 
        SmartcardExtension->ReaderExtension->WaitMask,
        SmartcardExtension->OsData->NotificationIrp
        ));

    return STATUS_PENDING;
}	



NTSTATUS
Lit220Command(
	IN PSMARTCARD_EXTENSION SmartcardExtension
	) 
/*++

Routine Description:

	This routine sends a command to the reader. 
    SerialIo is used to write the command to the reader synchronously.
    We then wait for an ACK from the reader (by waiting for a signal from
    the Lit220InputFilter) so we know it received the command OK.
    If data is expected we wait for the data event signal from the
    Lit220InputFilter to indicate that the data is ready.

Arguments:

    DeviceObject - 	Pointer to the device object.

Return Value:

    -

--*/
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    ULONG i;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    LARGE_INTEGER timeout;
    ULONG localWaitMask;
    ULONG retry = 1;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Command: Enter\n",
        DRIVER_NAME)
        );

    do{

        // Make sure the data & ack events are not signaled before we start

        // Clear the DataEvnt
        KeClearEvent(
            &readerExtension->DataEvnt
            );


        // Clear the AckEvnt
        KeClearEvent(
            &readerExtension->AckEvnt
            );


        readerExtension->ReceivedByteNo = 0;

		readerExtension->GotNack = FALSE;

        // We always exect an ACK back
        readerExtension->WaitMask |= WAIT_ACK;


        // We need to copy the wait mask because the wait mask might change 
        // before we have a chance to check if we need to wait on it 
        localWaitMask = readerExtension->WaitMask;

        //
        // Send the data to the reader
        //
        readerExtension->SerialIoControlCode = IOCTL_SMARTCARD_220_WRITE;

        // Use SerialIo to actually send the bytes to the reader
        status = Lit220SerialIo(
            SmartcardExtension
            );

        //
        // Set Timeout according the protocol
        //
        timeout.HighPart = -1;
	    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

            case SCARD_PROTOCOL_UNDEFINED:
                // 3 sec timeout for undefined protocol
                timeout.LowPart = (ULONG)
                    (-30 * 1000 * 1000);    
                break;

            case SCARD_PROTOCOL_T0:
                // For t=0 protocol we must set the timeout to a very large time.  This
                // is becuase the card could ask for more time, but the reader must pay
                // keep paying attention to the card so it can not tell us that more time
                // is needed.  Therefore we must trust the readers timeout, and trust that
                // it will NACK us if there is a problem.
                timeout.LowPart = (-10 * 1000 * 1000 * 100) +  // Timeout 100 seconds
                    (-10) * SmartcardExtension->CardCapabilities.T0.WT;
                break;

            case SCARD_PROTOCOL_T1:
				          
                timeout.LowPart = 
                    SmartcardExtension->CardCapabilities.T1.BWT * 
                    (SmartcardExtension->T1.Wtx ? SmartcardExtension->T1.Wtx : 1);

                timeout.LowPart += SmartcardExtension->CardCapabilities.T1.CWT * 
                    SmartcardExtension->SmartcardReply.BufferLength;

                // Add a little extra time for reader to respond to the PC
                timeout.LowPart += 100 * 1000;

                // Convert timeout to NS
                timeout.LowPart *= -10;


                break;
        }

        ASSERT(timeout.LowPart != 0);




        //
        // Always for the ACK
        //
        status = KeWaitForSingleObject(
            &readerExtension->AckEvnt,
            Executive,
            KernelMode,
            FALSE,
            &timeout
            );

        // Did we actually get a nack instead of an ACK
        if (readerExtension->GotNack) {
            status = Lit220GetReaderError(SmartcardExtension); 
            // GetReaderError will clear this flag, but I need to
            // preserve the fact that I got nacked so I must reset it.
            readerExtension->GotNack = TRUE; 
        }

        //
        // Wait for the Data if requested
        //
        if ((localWaitMask & WAIT_DATA) && (status == STATUS_SUCCESS)) {

            // Wait for signal the data is ready (at least until we timeout)
            status = KeWaitForSingleObject(
                &readerExtension->DataEvnt,
                Executive,
                KernelMode,
                FALSE,
                &timeout
                );

            // Did we get NACKed?
            if (readerExtension->GotNack) {
                status = Lit220GetReaderError(SmartcardExtension); 
                // GetReaderError will clear this flag, but I need to
                // preserve the fact that I got nacked so I must reset it.
                readerExtension->GotNack = TRUE; 
            }

        }


        if (status == STATUS_TIMEOUT) {

            //
            // STATUS_TIMEOUT isn't correctly mapped 
            // to a WIN32 error, that's why we change it here
            // to STATUS_IO_TIMEOUT
            //
            status = STATUS_IO_TIMEOUT;

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220Command): Operation timed-out\n",
                DRIVER_NAME)
                );
        }

        {   // Sometimes after a command the reader is not reader to accept another command
            // so we need to wait for a short period of time for the reader to be ready.  We need to
            // take this out as soon as the reader is fixed!
            LARGE_INTEGER WaitTime;

            WaitTime.HighPart = -1;
            WaitTime.LowPart = -10;  // Wait 1uS

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &WaitTime
                );
        }

        // If we failed because the reader did not give us any response resend the command.
        // The reader should respond.
        if ((status != STATUS_SUCCESS) && (!readerExtension->GotNack)) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220Command): Reader failed to respond!  Retrying once more.\n",
                DRIVER_NAME)
                );
        } else {
            break;
        }            


    } while (retry++ <= 2);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Command: Exit - status %X\n",
        DRIVER_NAME, 
        status)
        );

    return status;
}


NTSTATUS
Lit220SetProtocol(
	PSMARTCARD_EXTENSION SmartcardExtension
    )
    
/*++

Routine Description:

	This function sends a set mode command to the reader set the 
    protocol and the parameters for the wait protocol.


Arguments:

	SmartcardExtension - Pointer to the smart card data struct


// Parameters are up to seven bytes as follows:
//
//  Flags -  Flags to indicate the presence or absence of the other parameters.
//    SETMODE_PROTOCOL, b0 - 1 if Protocol is present.
//    SETMODE_GT,		b1 - 1 if GuardTime is present.
//    SETMODE_WI,		b2 - 1 if WorkWaitTime is present.
//    SETMODE_BWI,		b3 - 1 if BWI/CWI is present.
//    SETMODE_WTX,		b4 - 1 if BlockWaitTimeExtension is present.
//    SETMODE_FI_DI,	b5 - 1 if BaudRate is present.
//
//  Protocol - possible values 00, 02, 10, 11, 12, 13
//    encodes T, C, CKS from the ATR
//    Use of this parameter may invoke a PTS request to the smartcard.
//    b4 - Protocol Type  (0 for T=0, 1 for T=1)
//    b3 - 0
//    b2 - 1 for convert 6A to 6A 00 and FA to 6A 01 on output to PS/2.
//    b1 - 0 ( use to be Convention used (0 for direct, 1 for inverse))
//    b0 - Checksum type  (0 for LRC, 1 for CRC)
//
//  GuardTime - possible values 00 to FE (0 to 254 etu between two characters)
//    encodes N (Extra Guardtime) from ATR
//
//  WorkWaitTime - possible values 00 to FF
//    encodes WI which is Work Waiting Time (character time-out for T=0)

//
//  BWI/CWI - possible values 00 to FF
//    encodes BWI and CWI which are the Block and Char Wait Time
//    (block and character time-out for T=1)
//
//  BlockWaitTimeExtension - possible values 00 to FF
//    encodes WTX which is the Block Waiting Time Extension.
//    00 = no WTX is requested by the ICC.
//    vv is the multiplier of the BWT value
//
//  BaudRate - possible values 00 to FF
//    encodes FI and DI in the same fashion as TA1 does.
//    FI is in the high nibble. DI is in the low nibble.
//    D and F can be looked up in a table in PC/SC part 2 sec. 4.4.3.
//    Use of this parameter may invoke a PTS request to the smartcard.

Return Value:

	NTSTATUS

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;
	DWORD bufLen = 0;
	PCHAR flags;
	PCHAR protoByte;

    PAGED_CODE();


    RtlZeroMemory(
        smartcardRequest->Buffer,
        8
        );
    
    // Send a set mode command to the reader
    smartcardRequest->Buffer[bufLen++] = LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[bufLen++] = LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[bufLen++] = LIT220_SET_MODE;
    flags = &smartcardRequest->Buffer[bufLen++];
    *flags = 0;

    // Set the protocol
    protoByte = &smartcardRequest->Buffer[bufLen++];
    *protoByte = 0;	
    *flags |= SETMODE_PROTOCOL;
        
    // Set the inverse convention bit
    if (SmartcardExtension->CardCapabilities.InversConvention) {
		// Set the bit in the protocol paramter
        *protoByte |= LIT220_READER_CONVENTION_INVERSE;
    }
    
    //
    // test if caller wants to have T=0 or T=1
    //
    if ((SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_T1) &&
        (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T1)){
        
        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_T1;
        
        // Setup set mode command with T=1 parameters for protocol
        *protoByte |= LIT220_READER_PROTOCOL_T1;

        if (SmartcardExtension->CardCapabilities.T1.EDC & T1_CRC_CHECK) {

            *protoByte |= LIT220_READER_CHECK_CRC;
        }			 
    
        // Set the guard time
        *flags |= SETMODE_GT;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.N; 
				
        // Set BWI and CWI
        *flags |= SETMODE_BWI;
        smartcardRequest->Buffer[bufLen++] = 
            (SmartcardExtension->CardCapabilities.T1.BWI << 4) |
            (SmartcardExtension->CardCapabilities.T1.CWI);

    }
    else if ((SmartcardExtension->MinorIoControlCode & SCARD_PROTOCOL_T0) &&
        (SmartcardExtension->CardCapabilities.Protocol.Supported & SCARD_PROTOCOL_T0))
    {
        
        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_T0;


        // Set the guard time
        *flags |= SETMODE_GT;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.N;
			
		// Set WI
		*flags |= SETMODE_WI;
        smartcardRequest->Buffer[bufLen++] = 
            SmartcardExtension->CardCapabilities.T0.WI;

    } else {
    
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220SetProtocol: Error invalid protocol selected\n",
            DRIVER_NAME)
            );

        SmartcardExtension->CardCapabilities.Protocol.Selected = 
            SCARD_PROTOCOL_UNDEFINED;
        
        return STATUS_INVALID_PARAMETER;
    }

		   
    // Set FI & DI for baud rate
    *flags |= SETMODE_FI_DI;
    smartcardRequest->Buffer[bufLen++] = 
        (SmartcardExtension->CardCapabilities.PtsData.Fl << 4) | 
        SmartcardExtension->CardCapabilities.PtsData.Dl;


    smartcardRequest->BufferLength = bufLen;

    
    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220SetProtocol - Sending SetMode command %x bytes, %X,%X,%X,%X,%X,%X,%X,%X,%X,%X\n",
        DRIVER_NAME,
        bufLen,
        smartcardRequest->Buffer[0],
        smartcardRequest->Buffer[1],
        smartcardRequest->Buffer[2],
        smartcardRequest->Buffer[3],
        smartcardRequest->Buffer[4],
        smartcardRequest->Buffer[5],
        smartcardRequest->Buffer[6],
        smartcardRequest->Buffer[7],
        smartcardRequest->Buffer[8],
        smartcardRequest->Buffer[9]
    ));

    status =Lit220Command(
        SmartcardExtension
        );


    if (status == STATUS_SUCCESS) {
	    // now indicate that we're in specific mode 
	    SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
        return status;
    }

    //TODO: handle rertying code without optimal setting if optimal fails
    if (SmartcardExtension->CardCapabilities.PtsData.Type !=
        PTS_TYPE_DEFAULT) {
        DWORD saveMinorCode = SmartcardExtension->MinorIoControlCode;

	    SmartcardDebug(
		    DEBUG_TRACE,
		    ("%s!Lit220SetProtocol: PTS failed. Trying default parameters...\n",
            DRIVER_NAME,
            status)
		    );
        //
        // The card did either NOT reply or it replied incorrectly
        // so try default values
        //
        SmartcardExtension->CardCapabilities.PtsData.Type = 
            PTS_TYPE_DEFAULT;

        SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

        status = Lit220Power(SmartcardExtension);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        SmartcardExtension->MinorIoControlCode = saveMinorCode;

        return Lit220SetProtocol(SmartcardExtension);
    } 
    
    // the card failed the pts-request
    status = STATUS_DEVICE_PROTOCOL_ERROR;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SetProtocol: Exit with error.\n",
        DRIVER_NAME)
        );

    return status;
}

NTSTATUS
Lit220Power(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

	This function sends an SCARD_COLD_RESET, SCARD_WARM_RESET or SCARD_POWER_DOWN
    to the reader.  For cold or warm reset we set a flag indicating that an ATR
    is expected.  Once the Lit220InputFilter receives the ATR it will update the
    card capabilites.

Arguments:

	SmartcardExtension - Pointer to the smart card data struct

Return Value:

   NTSTATUS

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Power: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;


    // Make sure card is still present
    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_ABSENT) {
        return STATUS_DEVICE_REMOVED;
    }


	//
	// Since power down triggers the UpdateSerialStatus function, we have
	// to inform it that we forced the change of the status and not the user
	// (who might have removed and inserted a card)
	//
	SmartcardExtension->ReaderExtension->PowerRequest = TRUE;

    switch(SmartcardExtension->MinorIoControlCode) {

        case SCARD_COLD_RESET:
            //
            // Send a power-on, if the reader is already off
            // it will perform a cold reset turning the power off
            // the back on again.  
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_CARD_POWER_ON;
            
            // 
            // Power-on leads to an ATR
            //    
            SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;
            SmartcardExtension->ReaderExtension->WaitForATR = TRUE;
            break;
        
        case SCARD_WARM_RESET:

            //
            // Send a reset to the reader (warm reset)  
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_RESET;
                
            // 
            // Warm reset leads to an ATR
            //    
            SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;
            SmartcardExtension->ReaderExtension->WaitForATR = TRUE;
            break;
            
        case SCARD_POWER_DOWN:
            //
            // Send a power down to the reader 
            //
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_READER_ATTENTION;
            smartcardRequest->Buffer[smartcardRequest->BufferLength++] = 
                LIT220_CARD_POWER_OFF;
            break;
    }

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    SmartcardExtension->ReaderExtension->PowerRequest = FALSE;     	

	if (status == STATUS_IO_TIMEOUT) {
		status = STATUS_UNRECOGNIZED_MEDIA;
	}

    if (status == STATUS_SUCCESS) {
        if (SmartcardExtension->MinorIoControlCode == SCARD_POWER_DOWN) {

		    SmartcardExtension->ReaderCapabilities.CurrentState = 
	            SCARD_PRESENT;
		            
		    SmartcardExtension->CardCapabilities.Protocol.Selected = 
			    SCARD_PROTOCOL_UNDEFINED;
        }
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Power: Exit\n",
        DRIVER_NAME)
        );

    return status;
}	




NTSTATUS
Lit220IoRequest(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:
    The routine handles IO request from the smartcard library.
    It sends the command to card and processes the reply.
    It may also be called from Lit220IoReply is more processing is 
    required.

Arguments:

	SmartcardExtension - Pointer to the smart card data struct

Return Value:

   NTSTATUS

--*/
{
    NTSTATUS status;
    LENGTH length;
//    ULONG offset = 0;
    ULONG indx;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoRequest: Enter\n",
        DRIVER_NAME)
        );

    //
    // Tell the lib function how many bytes I need for the prologue
    //
    SmartcardExtension->SmartcardRequest.BufferLength = 5;

    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

        case SCARD_PROTOCOL_RAW:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_RAW\n",
                DRIVER_NAME)
                );

            status = SmartcardRawRequest(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T0:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_T0\n",
                DRIVER_NAME)
                );

            status = SmartcardT0Request(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T1:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoRequest - SCARD_PROTOCOL_T1\n",
                DRIVER_NAME)
                );


            status = SmartcardT1Request(
                SmartcardExtension
                );
            break;

        default:
        {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220IoRequest: Invalid Device Request - protocol selected = %X\n",
                DRIVER_NAME,
                SmartcardExtension->CardCapabilities.Protocol.Selected)
                );

            status = STATUS_INVALID_DEVICE_REQUEST;
        }
			
    }

    if (status == STATUS_SUCCESS) {

        // Add the send block command to the front of the buffer
        SmartcardExtension->SmartcardRequest.Buffer[0] = 
            LIT220_READER_ATTENTION;
        SmartcardExtension->SmartcardRequest.Buffer[1] = 
            LIT220_READER_ATTENTION;

        SmartcardExtension->SmartcardRequest.Buffer[2] = 
            LIT220_SEND_BLOCK;

        length.l.l0 = 
            SmartcardExtension->SmartcardRequest.BufferLength - 5;

        SmartcardExtension->SmartcardRequest.Buffer[3] = 
            length.b.b1;

        SmartcardExtension->SmartcardRequest.Buffer[4] = 
            length.b.b0;
        
		// We expect data back from this command
        SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

        //
        // Send the command
        //
        status = Lit220Command(
            SmartcardExtension
            );
    }
    

    if (status == STATUS_SUCCESS) {
        // Process the reply
        status = Lit220IoReply(
	        SmartcardExtension
	        );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoRequest: Exit - status %X\n",
        DRIVER_NAME, 
        status)
        );

    return status;
}	



NTSTATUS
Lit220IoReply(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:
    Handles the reply from a smartcard command.
    If more processing is required it will call Lit220IoRequest 
    to send another command.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    LENGTH length;
    ULONG indx;

    PAGED_CODE();

    // Check which protocol is being used so we know how to respond
    switch (SmartcardExtension->CardCapabilities.Protocol.Selected) {

        case SCARD_PROTOCOL_RAW:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply:  - SCARD_PROTOCOL_RAW\n",
                DRIVER_NAME)
                );

            // Let the smartcard lib process the reply
            status = SmartcardRawReply(
                SmartcardExtension
                );
            break;

        case SCARD_PROTOCOL_T0:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - SCARD_PROTOCOL_T0\n",
                DRIVER_NAME)
                );

            // The instruction seems to be tagged onto the front of the buffer
            //   the smartcard library does not seem to like this so we must shift the buffer.
            for(indx=0;indx<SmartcardExtension->SmartcardReply.BufferLength;indx++){
                SmartcardExtension->SmartcardReply.Buffer[indx] =
                    SmartcardExtension->SmartcardReply.Buffer[indx+1];
            }

            SmartcardExtension->SmartcardReply.BufferLength--;

#if DBG   // DbgPrint the buffer
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - Buffer - ",
                DRIVER_NAME)
                );
            for (indx=0; indx<SmartcardExtension->SmartcardReply.BufferLength; indx++){
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%X, ",
                    SmartcardExtension->SmartcardReply.Buffer[indx])
                    );
            }
            SmartcardDebug(
                DEBUG_DRIVER,
                ("\n")
                );
#endif

            // Let the smartcard lib process the reply
            status = SmartcardT0Reply(
                SmartcardExtension
                );

            break;

        case SCARD_PROTOCOL_T1:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220IoReply - SCARD_PROTOCOL_T1\n",
                DRIVER_NAME)
                );

            // Let the smartcard lib process the reply
            status = SmartcardT1Reply(
                SmartcardExtension
                );
            break;

        default:
        {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220IoRequest: Invalid Device Request2 - protocol selected = %X\n",
                DRIVER_NAME,
                SmartcardExtension->CardCapabilities.Protocol.Selected)
                );

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    // If there is more work to be done send out another IoRequest.
    // The smartcard lib should have set up the buffers for the new
    // IO operation.
    if (status == STATUS_MORE_PROCESSING_REQUIRED) {

        status = Lit220IoRequest(
            SmartcardExtension
            );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IoReply: - Exit - status %X\n", 
        DRIVER_NAME, 
        status)
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220scr.h ===
/*++

Module Name:

    L220SCR.h

Abstract:

    smartcard 220 serial miniport defines and structures

Revision History:

--*/


#ifndef _L220SCR_
#define _L220SCR_



#define DRIVER_NAME "LIT220P"

#ifndef _WDMDDK_
#include <ntddk.h>
#endif
#include <ntddser.h>

// Pool tag for Litronic xlCS where x is a number we choose
#define SMARTCARD_POOL_TAG '0lCS'

#include "smclib.h"
#include "L220log.h"


#define IOCTL_SMARTCARD_220_READ            SCARD_CTL_CODE( 8) 
#define IOCTL_SMARTCARD_220_WRITE           SCARD_CTL_CODE( 9)       

#define MAX_IFSD 254


//
// 220 smart card reader command constants
//
#define LIT220_READER_ATTENTION     0xF4
#define KBD_ACK                     0xFA

#define LIT220_GET_READER_TYPE      0xB0
#define LIT220_SET_MODE             0xB1
#define LIT220_CARD_POWER_ON        0xB2
#define LIT220_CARD_POWER_OFF       0xB3
#define LIT220_RESET                0xB4
#define LIT220_GET_READER_STATUS    0xB5
#define LIT220_SEND_BYTE            0xB6
#define LIT220_SEND_BLOCK           0xB7
#define LIT220_RESEND_BLOCK         0xB8
#define LIT220_GET_READER_CAPS      0xB9
#define LIT220_DEACTIVATE_READER    0xBA


//
// 220 smart card respons bytes 
// every received packet starts with one of these bytes
//
#define LIT220_READER_TYPE          0x60            
#define LIT220_READER_STATUS        0x61
#define LIT220_ACK                  0x62
#define LIT220_RECEIVE_BYTE         0x63
#define LIT220_RECEIVE_BLOCK        0x64
#define LIT220_CARD_IN              0x65
#define LIT220_CARD_OUT             0x66
#define LIT220_NACK                 0x67

//
// Length of constant size reply packets
//
#define LIT220_READER_TYPE_LEN      16
#define LIT220_READER_STATUS_LEN    4

//
// Length of constant command packets
//
#define LIT220_READER_SET_MODE_LEN  8

//
// Reader status flags
//
#define LIT220_STATUS_CARD_INSERTED    0x08



#define LIT220_VENDOR_NAME          "Litronic"
#define LIT220_PRODUCT_NAME         "220 Smartcard Reader"


//
// WaitMask values
//
#define WAIT_DATA           0x0001
#define WAIT_ACK            0x0002
#define WAIT_INSERTION      0x0004
#define WAIT_REMOVAL        0x0008

//
// 220 smart card reader dependent flags
//
#define LIT220_READER_PROTOCOL_T1           0x10
#define LIT220_READER_CONVENTION_INVERSE    0x02
#define LIT220_READER_CHECK_CRC             0x01
#define LIT220_READER_BWT_EXTENSION         0x04


// Set mode flags
#define SETMODE_PROTOCOL    0x01
#define SETMODE_GT          0x02
#define SETMODE_WI          0x04
#define SETMODE_BWI         0x08
#define SETMODE_WTX         0x10
#define SETMODE_FI_DI       0x20


#define UNICODE_SIZE(x) ((x) * sizeof(WCHAR))

typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _SERIAL_READER_CONFIG {

    //
    // flow control
    //
    SERIAL_HANDFLOW HandFlow;           

    //
    // special characters
    //
    SERIAL_CHARS SerialChars;           

    //
    // read/write timeouts
    //
    SERIAL_TIMEOUTS Timeouts;           

    //
    // Baudrate for reader
    //
    SERIAL_BAUD_RATE BaudRate;          

    //
    // Stop bits, parity configuration
    //
    SERIAL_LINE_CONTROL LineControl;    

    //
    // Event serial reader uses to signal insert/removal
    //
    ULONG WaitMask; 
    

} SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION {

    //
    // DeviceObject pointer to serial port
    //
    PDEVICE_OBJECT ConnectedSerialPort;


    //
    // This struct is used for CardTracking
    //
    struct {

        PIRP    Irp;

        KEVENT  Event;

        IO_STATUS_BLOCK IoStatus;

        KDPC    Dpc;

    } CardStatus;

    // 
    // This struct is used to get the number of characters in the input queue
    //
    SERIAL_STATUS SerialStatus;

    //
    // IOCTL to send to the serial driver
    //
    ULONG   SerialIoControlCode;


    //
    // This holds state bits for the COM port such as DSR
    //
    ULONG   ModemStatus;

    //
    // This holds the serial parameters used to configure the serial port
    //
    SERIAL_READER_CONFIG SerialConfigData;

    //
    // This is the data byte no in reply packet
    //
    ULONG   DataByteNo;

    //
    // Number of bytes expected in the reply packer as indicated by byte 2 
    // and 3 of the receive packet
    //
    LENGTH  DataLength;

    //
    // Flags that indicate if we have received the length-bytes in the receive packet
    //
    BOOLEAN GotLengthB0;
    BOOLEAN GotLengthB1;

    //
    // Nack received from reader
    //
    BOOLEAN GotNack;

    //
    // The total number of bytes currently in the receive packet 
    //
    ULONG   ReceivedByteNo;

    //  
    // This flag inidictes that the input filter treats the next packet as and ATR
    //
    BOOLEAN WaitForATR;

    //
    // Mask that indicates the input filter what events we are expecting
    //
    ULONG   WaitMask;

    // 
    // Smartcard notification DPC queue
    //
    KDPC    NotificationIsrDpc;

    //
    // Event used to indicate that an ack was received by the input filter.
    // This will signal the Lit220Command that it can continue.
    //
    KEVENT  AckEvnt;

    //
    // Event used to indicate that a data packet was received by the input filter.
    // This will signal the Lit220Command that it can continue.
    //
    KEVENT  DataEvnt;

    //
    // Holds the Device Object of the top of our stack
    //
    PDEVICE_OBJECT BusDeviceObject;

    //
    // Holds the Device Object of our parent (1394 bus driver)
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // State the Lit220SerialEventCallback is in.
    //
    DWORD SerialEventState; 

    //
    // Temporary transfer buffer used to get data from the serial port
    // before we send it to the input filter
    //
    BYTE TempXferBuf[270];


    // Flag that indicates that the caller requests a power-down or a reset
    BOOLEAN PowerRequest;

    // Saved card state for hibernation/sleeping modes.
    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

    // Used to indicate that the device has been removed even before we can release
    // the remove lock throw SmartcardReleaseRemoveLockAndWait.  This way when we 
    // close the connection to the serial port we won't send any more IRPs to the
    // device 
    BOOLEAN DeviceRemoved;

    // Flag indicating whether the card is inserted or not
    DWORD CardIn;


} READER_EXTENSION, *PREADER_EXTENSION;



typedef struct _DEVICE_EXTENSION {

    SMARTCARD_EXTENSION SmartcardExtension;

    // The current number of io-requests
    LONG IoCount;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // The pnp device name of our smart card reader
    UNICODE_STRING PnPDeviceName;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to signal that the connection to the serial driver has been closed
    KEVENT SerialCloseDone;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

    KSPIN_LOCK SpinLock;

    // A worker thread that closes the serial driver &
    // handling IO timeouts
    PIO_WORKITEM WorkItem;

    // Keeps track of how many times the timeout
    // function has been called
    BYTE EntryCount;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;




//
// Prototypes
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
Lit220Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Lit220CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220SystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   );

NTSTATUS
Lit220DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
Lit220Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220SerialIo(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220StopDevice(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220RemoveDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Lit220StartDevice(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
Lit220InitializeInputFilter(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


BOOLEAN
Lit220InputFilter(
    IN BYTE SmartcardByte,
    IN PSMARTCARD_EXTENSION smartcardExtension
    );

NTSTATUS
Lit220CardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220SetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Power(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220IoRequest(
    PSMARTCARD_EXTENSION SmartcardExtension
    );


NTSTATUS
Lit220GetReaderError(
    PSMARTCARD_EXTENSION SmartcardExtension
    );


NTSTATUS
Lit220IoReply(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

BOOLEAN
Lit220IsCardPresent(
      IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220Command(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220AddDevice(
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PDEVICE_OBJECT  PhysicalDeviceObject
    );

NTSTATUS
Lit220PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Lit220SynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );
                       
VOID 
Lit220CloseSerialPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context  
    );

NTSTATUS
Lit220CallSerialDriver(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp);

NTSTATUS 
Lit220SerialEventCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
Lit220NotifyCardChange(
    IN PSMARTCARD_EXTENSION smartcardExtension,
    IN DWORD CardInserted
    );

NTSTATUS
Lit220DevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220CompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
Lit220ReceiveBlockTimeout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

VOID 
Lit220ProcessNack(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID 
Lit220StartTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    );

VOID 
Lit220StopTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    );

VOID 
Lit220ScheduleTimer(
    IN PSMARTCARD_EXTENSION SmartcardExtension,
    IN PIO_WORKITEM_ROUTINE Routine
    );




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220pnp.c ===
/*++

   Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220pnp.c

Abstract:

   This module contains the functions for the PnP and Power management.


Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created Febuary 1998 by Brian Manahan for use with
        the 220 reader.
--*/
#include <ntddk.h>
#include "L220SCR.h"
#include <stdio.h>


// Next statement so memory for DriverEntry is released when finished
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, Lit220RemoveDevice)
#pragma alloc_text(PAGEABLE, Lit220StopDevice)
#pragma alloc_text(PAGEABLE, Lit220StartDevice)



#include <initguid.h>






NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/
{
    SmartcardDebug(
        DEBUG_DRIVER,
       ("%s!DriverEntry: Enter - %s %s\n",
        DRIVER_NAME,
        __DATE__,
        __TIME__)
        );


    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload = Lit220Unload;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = Lit220CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = Lit220CreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = Lit220Cleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Lit220DeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = Lit220SystemControl;

    //
    // Init PNP entries
    //
    DriverObject->DriverExtension->AddDevice = Lit220AddDevice;

    // Power functionality temporarily removed
    DriverObject->MajorFunction[IRP_MJ_PNP]  = Lit220PnP;

    // Power
    // Power functionality temporarily removed
    DriverObject->MajorFunction[IRP_MJ_POWER] = Lit220DispatchPower;

    // Always return STATUS_SUCCESS
    return STATUS_SUCCESS;
}





NTSTATUS
Lit220AddDevice(
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PDEVICE_OBJECT  PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine is called by the Operating System to create a new
    instance of a Litronic 220 Smartcard Reader.  Still can't touch hardware
    at this point, or submit requests to the serial driver.  But at
    least at this point we get a handle to the serial bus driver, which
    we'll use in submitting requests in the future.

Arguments:

    DriverObject - Pointer to our driver object

    PhysicalDeviceObject - Pointer to Device Object created by parent

Return Value:

    Status is returned.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;
    PDEVICE_EXTENSION deviceExtension = NULL;
    PREADER_EXTENSION ReaderExtension = NULL;
    static BYTE devUnitNo = 0;
    BOOLEAN smclibInitialized = FALSE;
    BOOLEAN symbolicLinkCreated = FALSE;
    BOOLEAN deviceInterfaceStateSet = FALSE;
    KIRQL oldIrql;


    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220AddDevice: enter\n",
        DRIVER_NAME)
        );

    try {

        //
        // Create our device object with a our own specific device
        // extension.
        //

        status = IoCreateDevice(
          DriverObject,
            sizeof(DEVICE_EXTENSION),
            NULL,
            FILE_DEVICE_SMARTCARD,
            0,
            TRUE,
            &DeviceObject
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_INSUFFICIENT_RESOURCES) {
                SmartcardLogError(
                   DriverObject,
                   LIT220_INSUFFICIENT_RESOURCES,
                   NULL,
                   0
                   );
            } else {
                SmartcardLogError(
                   DriverObject,
                   LIT220_NAME_CONFLICT,
                   NULL,
                   0
                   );
            }

            leave;
        }

        //
        // Allocate data struct space for smart card reader
        //
        SmartcardExtension = DeviceObject->DeviceExtension;
      deviceExtension = DeviceObject->DeviceExtension;

        SmartcardExtension->ReaderExtension = ExAllocatePool(
              NonPagedPool,
              sizeof(READER_EXTENSION)
              );

        if (SmartcardExtension->ReaderExtension == NULL) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        ReaderExtension = SmartcardExtension->ReaderExtension;

        // Zero the contents of the ReaderExtension
        RtlZeroMemory(
            SmartcardExtension->ReaderExtension,
            sizeof(READER_EXTENSION)
            );

        //
        // Attach ourself into the driver stack on top of our parent (serial).
        //
        ReaderExtension->BusDeviceObject = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject
            );


        if (!ReaderExtension->BusDeviceObject) {
            status = STATUS_NO_SUCH_DEVICE;

            SmartcardLogError(
               DriverObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );

            leave;
        }

        // Set flag so if something fails we know to disable the interface
        deviceInterfaceStateSet = TRUE;


        //
        // Initialize Smartcard Library
        //
        //
        // Write the version of the lib we use to the smartcard extension
        //
        SmartcardExtension->Version = SMCLIB_VERSION;

        SmartcardExtension->SmartcardReply.BufferSize =
            MIN_BUFFER_SIZE;

        SmartcardExtension->SmartcardRequest.BufferSize =
            MIN_BUFFER_SIZE;

        //
        // Now let the lib allocate the buffer for data transmission
        // We can either tell the lib how big the buffer should be
        // by assigning a value to BufferSize or let the lib
        // allocate the default size
        //
        status = SmartcardInitialize(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {
            SmartcardLogError(
               DriverObject,
               LIT220_SMARTCARD_LIB_ERROR,
               NULL,
               0
               );
            leave;
        }

        // Set flag so if something fails we know to exit out of the
        // smartcard library
        smclibInitialized = TRUE;

        status = IoInitializeTimer(
           DeviceObject,
           Lit220ReceiveBlockTimeout,
           NULL
           );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        deviceExtension->WorkItem = NULL;
        deviceExtension->WorkItem = IoAllocateWorkItem(
          DeviceObject
          );
        if (deviceExtension->WorkItem == NULL) {

            SmartcardLogError(
               DriverObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }


        // register our new device
        status = IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            &SmartCardReaderGuid,
            NULL,
            &deviceExtension->PnPDeviceName
            );
        ASSERT(status == STATUS_SUCCESS);

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220AddDevice: DevName - %ws\n",
            DRIVER_NAME, deviceExtension->PnPDeviceName.Buffer)
            );


      //
      // Initialize some events
      //
      KeInitializeEvent(&ReaderExtension->AckEvnt,
         NotificationEvent,
         FALSE);
      KeInitializeEvent(&ReaderExtension->DataEvnt,
         NotificationEvent,
         FALSE);

      KeInitializeEvent(
         &deviceExtension->SerialCloseDone,
         NotificationEvent,
         TRUE
         );

      // Used for stop / start notification
      KeInitializeEvent(
         &deviceExtension->ReaderStarted,
         NotificationEvent,
         FALSE
         );

      // Used to keep track of open close calls
      deviceExtension->ReaderOpen = FALSE;

    } finally {
        if (status != STATUS_SUCCESS) {
         Lit220RemoveDevice(DeviceObject);
        }
    }

    if (status != STATUS_SUCCESS) {
        return (status);
    }


    //
    // Set up call back functions for smartcard library
    //
    SmartcardExtension->ReaderFunction[RDF_TRANSMIT] =
        Lit220IoRequest;
    SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =
        Lit220SetProtocol;
    SmartcardExtension->ReaderFunction[RDF_CARD_POWER] =
        Lit220Power;
    SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] =
        Lit220CardTracking;

    //
    // Save deviceObject
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &oldIrql
        );

    SmartcardExtension->OsData->DeviceObject =
        DeviceObject;

    //
    // Set the Current and Notification IRPs to NULL
    //
    SmartcardExtension->OsData->CurrentIrp = NULL;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        oldIrql
        );

    //
    // Save the deviceObject for the connected serial port
    //
    SmartcardExtension->ReaderExtension->ConnectedSerialPort =
        PhysicalDeviceObject;


    //
    // Set the vendor info
    //
    strcpy(
        SmartcardExtension->VendorAttr.VendorName.Buffer,
        LIT220_VENDOR_NAME);

    SmartcardExtension->VendorAttr.VendorName.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.VendorName.Buffer);

    SmartcardExtension->VendorAttr.UnitNo = devUnitNo++;

    strcpy(
        SmartcardExtension->VendorAttr.IfdType.Buffer,
        LIT220_PRODUCT_NAME);

    SmartcardExtension->VendorAttr.IfdType.Length =
        (USHORT) strlen(SmartcardExtension->VendorAttr.IfdType.Buffer);


    //
    // Clk frequency in KHz encoded as little endian integer
    //
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;

    SmartcardExtension->ReaderCapabilities.DataRate.Default = 9600;
    SmartcardExtension->ReaderCapabilities.DataRate.Max = 115200;

    SmartcardExtension->ReaderCapabilities.MaxIFSD = MAX_IFSD;

    SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    // Save a copy to the PhysicalDeviceObject
    ReaderExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Set initial state for SerialEventState
    SmartcardExtension->ReaderExtension->SerialEventState = 0;

    // Device is connected
    SmartcardExtension->ReaderExtension->DeviceRemoved = FALSE;

    // Assume reader is attached until we ask the serial driver
    SmartcardExtension->ReaderExtension->ModemStatus = SERIAL_DSR_STATE;

   // Set initial power state
    deviceExtension->PowerState = PowerDeviceD0;

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    // Clear the DO_DEVICE_INITIALIZING bit
    DeviceObject->Flags |= DO_BUFFERED_IO;
   DeviceObject->Flags |= DO_POWER_PAGABLE;
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}



VOID
Lit220CloseSerialPort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine closes the connection to the serial driver when the
    reader has been removed (unplugged).  This routine runs as a system
    thread at IRQL == PASSIVE_LEVEL.
    It waits for a DeviceClose event sent by another part of the driver to
    indicate that the serial connection should be close.
    If the notification IRP is still pending we complete it.
    Once the connection is closed it will signal the SerialCloseDone event so the
    PnP Remove IRP knows when it is safe to unload the device.
*/
{
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL oldIrql;

    //
    // first mark this device as 'gone'.
    // This will prevent that someone can re-open the device
    //
    // We intentionally ignore error here for the case we are disabling an interface
    // that is already disabled.
    //
    IoSetDeviceInterfaceState(
        &deviceExtension->PnPDeviceName,
        FALSE
        );

    // Mark the device as removed so no more IRPs will be sent to the
    // serial port
    ReaderExtension->DeviceRemoved = TRUE;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220CloseSerialPort: Got Close signal.  Checking if we can remove device now.\n",
        DRIVER_NAME)
        );

    //
    // Cancel the Notification IRP if it is around
    //
    Lit220CompleteCardTracking(SmartcardExtension);


    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220CloseSerialPort: Sending IRP_MJ_CLOSE\n",
        DRIVER_NAME)
        );

    //
    // Create an IRP for closing the serial driver
    //
    irp = IoAllocateIrp(
        (CCHAR)(DeviceObject->StackSize + 1),
        FALSE
        );

    ASSERT(irp != NULL);

    if (irp) {

        //
        // Send a close to the serial driver.  The serial enumerator
        // will receive this and start tracking again.  This will
        // eventually trigger a device removal.
        //
        IoSetNextIrpStackLocation(irp);
        irp->UserIosb = &ioStatusBlock;
        irpStack = IoGetCurrentIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_CLOSE;

        status = Lit220CallSerialDriver(
            ReaderExtension->BusDeviceObject,
            irp
            );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);
    } else {

        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220CloseSerialPort: Could not allocate IRP for close!\n",
            DRIVER_NAME)
            );
    }

    // Inform the remove function that the call is complete
    KeSetEvent(
        &deviceExtension->SerialCloseDone,
        0,
        FALSE
        );

}




NTSTATUS
Lit220SerialCallComplete(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp,
                         IN PKEVENT Event)
/*++

Routine Description:

    Completion routine for an Irp sent to the serial driver.
    It sets only an event that we can use to wait for.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SerialCallComplete: enter\n",
        DRIVER_NAME)
        );

    if (Irp->Cancel) {
        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent(Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
Lit220CallSerialDriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp)
/*++

Routine Description:

    Sends an Irp to the serial driver.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    // Copy out stack location to the next
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Initializate event for process synchronication.
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    // Set the completion routine
    IoSetCompletionRoutine(
        Irp,
        Lit220SerialCallComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    // Call the serial driver
    status = IoCallDriver(
        DeviceObject,
        Irp
        );

    // Wait for it to complete
    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        ASSERT(STATUS_SUCCESS == status);

        status = Irp->IoStatus.Status;
    }

    return status;
}




NTSTATUS
Lit220PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will receive the various Plug N Play messages.  It is
    here that we start our device, stop it, etc.  Safe to submit requests
    to the serial bus driver.

Arguments:

    DeviceObject - Pointer to class device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    KEVENT Event;
    NTSTATUS status;
    PIO_STACK_LOCATION IrpStack;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
   PDEVICE_OBJECT busDeviceObject = ReaderExtension->BusDeviceObject;
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK     ioStatusBlock;
    LARGE_INTEGER Interval;
    PIRP createIrp = NULL;
    HANDLE handle;
    PIO_STACK_LOCATION NextIrpStack;
    PIRP irp;
    BOOLEAN deviceRemoved = FALSE;
    KIRQL irql;


    status = SmartcardAcquireRemoveLockWithTag(
      SmartcardExtension,
      'PnP'
      );
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // pull the minor code out of our Irp Stack so we know what
    // PnP function we're supposed to do
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    ASSERT(IrpStack);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220PnP: Enter - MinorFunction %X\n",
        DRIVER_NAME,
        IrpStack->MinorFunction)
        );

    switch (IrpStack->MinorFunction) {

        PDEVICE_OBJECT BusDeviceObject = ReaderExtension->BusDeviceObject;


        case IRP_MN_START_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_START_DEVICE\n",
                DRIVER_NAME)
                );

            //
            // Before we start initializing our device, we must
            // call to the layer below us first.
            //
            IoCopyCurrentIrpStackLocationToNext (Irp);

            KeInitializeEvent(
                &Event,
                SynchronizationEvent,
                FALSE
                );

            IoSetCompletionRoutine(
                Irp,
                Lit220SynchCompletionRoutine,
               &Event,
                TRUE,
                TRUE,
                TRUE
                );

            //
            // Call down to the serial bus driver.
            //
            status = IoCallDriver(
                        ReaderExtension->BusDeviceObject,
                        Irp
                        );

            if (status == STATUS_PENDING) {

                //
                // Still pending, wait for the IRP to complete
                //

                status = KeWaitForSingleObject(
                   &Event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );

            }

         if (NT_SUCCESS(status)) {

            status = Lit220StartDevice(SmartcardExtension);

         } else {

                SmartcardLogError(
                   SmartcardExtension->OsData->DeviceObject,
                   LIT220_SERIAL_CONNECTION_FAILURE,
                   NULL,
                   0
                   );
         }

         //
         // Complete the IRP first otherwise if we failed we may remove
         // the driver before we have a chance to complete this IRP.
         // Causing a system crash.
         //

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);


            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: IRP_MN_QUERY_STOP_DEVICE\n",
                DRIVER_NAME)
                );

            KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
            if ((deviceExtension->IoCount > 0) /* ***&& (!ReaderExtension->DeviceRemoved)*/) {

                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                status = STATUS_DEVICE_BUSY;

            } else {

                // stop processing requests
                KeClearEvent(&deviceExtension->ReaderStarted);
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                IoCopyCurrentIrpStackLocationToNext (Irp);
                status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);
            }


            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: IRP_MN_CANCEL_STOP_DEVICE\n",
                DRIVER_NAME)
                );

            IoCopyCurrentIrpStackLocationToNext (Irp);
            status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);

            if (status == STATUS_SUCCESS) {

                // we can continue to process requests
                KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
            }

            break;

        case IRP_MN_STOP_DEVICE:

            //
            // Do whatever you need to do to shutdown the device.
            //

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_STOP_DEVICE\n",
                DRIVER_NAME)
                );

         Lit220StopDevice(SmartcardExtension);

            //
            // Send the stop IRP down
            //
            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = (IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp)
                );
            break;


        case IRP_MN_QUERY_REMOVE_DEVICE:

            // now look if someone is currently connected to us
            if (deviceExtension->ReaderOpen) {

                //
                // someone is connected, fail the call
                // we will enable the device interface in
                // IRP_MN_CANCEL_REMOVE_DEVICE again
                //
                status = STATUS_UNSUCCESSFUL;
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest (
                    Irp,
                    IO_NO_INCREMENT
                    );
                
                break;
            }

            // disable the reader
            status = IoSetDeviceInterfaceState(
                &deviceExtension->PnPDeviceName,
                FALSE
                );


            // Send the call down the DevNode
            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp
                );

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            // Send call down to serial driver - we need
            // to process this call on the way up the devNode
            //

            IoCopyCurrentIrpStackLocationToNext (Irp);

            //
            // Initialize the event
            //
            KeInitializeEvent(
                &Event,
                SynchronizationEvent,
                FALSE
                );

            IoSetCompletionRoutine (
                Irp,
                Lit220SynchCompletionRoutine,
                &Event,
                TRUE,
                TRUE,
                TRUE
                );

            status = IoCallDriver (
                ReaderExtension->BusDeviceObject,
                Irp
                );

            if (STATUS_PENDING == status) {
                KeWaitForSingleObject(
                    &Event,
                    Executive, // Waiting for reason of a driver
                    KernelMode, // Waiting in kernel mode
                    FALSE, // No allert
                    NULL    // No timeout
                    );

                status = Irp->IoStatus.Status;
            }


         // Re-enable the device interface
         if ((status == STATUS_SUCCESS) &&
            (ReaderExtension->SerialConfigData.WaitMask != 0))
         {

            status = IoSetDeviceInterfaceState(
               &deviceExtension->PnPDeviceName,
               TRUE
               );

                ASSERT(NT_SUCCESS(status));
         }


            //
            // We must now complete the IRP, since we stopped it in the
            // completetion routine with MORE_PROCESSING_REQUIRED.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (
                Irp,
                IO_NO_INCREMENT
                );

            break;

        case IRP_MN_REMOVE_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220PnP: MN_REMOVE_DEVICE\n",
                DRIVER_NAME)
                );
         // Wait until we can safely unload the device
         SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

         Lit220RemoveDevice(DeviceObject);

         // Mark the device as removed
         deviceRemoved = TRUE;

            //
            // Send on the remove IRP.
            // We need to send the remove down the stack before we detach,
            // but we don't need to wait for the completion of this operation
            // (and to register a completion routine).
            //

            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                busDeviceObject,
                Irp
                );

            break;


        default:

            IoCopyCurrentIrpStackLocationToNext (Irp);

            status = IoCallDriver(
                ReaderExtension->BusDeviceObject,
                Irp
                );
            break;

    }

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLockWithTag(
         SmartcardExtension,
         'PnP'
         );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220PnP: Exit %X\n",
        DRIVER_NAME,
        status)
        );

    return status;

}



NTSTATUS
Lit220StartDevice(
   IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    KEVENT Event;
    PIRP irp;
    IO_STATUS_BLOCK     ioStatusBlock;
    PIO_STACK_LOCATION IrpStack;

    PAGED_CODE();


    try {

        //
        // Send a create IRP to the serial driver
        //
        KeInitializeEvent(
            &Event,
            NotificationEvent,
            FALSE
            );

        //
        // Create an IRP for opening the serial driver
        //
        irp = IoAllocateIrp(
            (CCHAR)(deviceObject->StackSize + 1),
            FALSE
            );

        ASSERT(irp != NULL);

        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_INSUFFICIENT_RESOURCES,
               NULL,
               0
               );

            leave;
        }

      //
      // Open the underlying serial driver.
      // This is necessary for two reasons:
      // a) The serial driver can't be used without opening it
      // b) The call will go through serenum first which informs
      //    it to stop looking/polling for new devices.
      //
        IoSetNextIrpStackLocation(irp);
        irp->UserIosb = &ioStatusBlock;
        IrpStack = IoGetCurrentIrpStackLocation(irp);
        IrpStack->MajorFunction = IRP_MJ_CREATE;
        IrpStack->MinorFunction = 0UL;
        IrpStack->Parameters.Create.Options = 0;
        IrpStack->Parameters.Create.ShareAccess = 0;
        IrpStack->Parameters.Create.FileAttributes = 0;
        IrpStack->Parameters.Create.EaLength = 0;

        status = Lit220CallSerialDriver(
            readerExtension->BusDeviceObject,
            irp
            );

        ASSERT(status == STATUS_SUCCESS);

        IoFreeIrp(irp);


        if (status != STATUS_SUCCESS) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220PNP: CreateIRP failed %X\n",
                DRIVER_NAME,
                status)
                );

         if (status == STATUS_SHARED_IRQ_BUSY) {
            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_SHARE_IRQ_CONFLICT,
               NULL,
               0
               );
         } else {
            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );
         }
            leave;
        }

        KeClearEvent(&deviceExtension->SerialCloseDone);

        //
        // Configure the reader
        //
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220PnP: Now doing Lit220Initialize - SmartcardExt %X\n",
            DRIVER_NAME,
            SmartcardExtension)
            );

        ASSERT(SmartcardExtension != NULL);

        status = Lit220Initialize(SmartcardExtension);

        if (status != STATUS_SUCCESS) {

            // The function fails in Lit220Initialize will log
            // the appropriate error.  So we don't need to do that
            // here

            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220PNP: Lit220Initialize failed %X\n",
                DRIVER_NAME,
                status)
                );

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_INITIALIZATION_FAILURE,
               NULL,
               0
               );

            leave;
        }

      // Enable the interface for the device
      status = IoSetDeviceInterfaceState(
         &deviceExtension->PnPDeviceName,
         TRUE
         );

      if (!NT_SUCCESS(status)) {

            SmartcardLogError(
               SmartcardExtension->OsData->DeviceObject,
               LIT220_SERIAL_CONNECTION_FAILURE,
               NULL,
               0
               );

         leave;
      }

        KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    }

    finally {

        if (status != STATUS_SUCCESS) {

         Lit220StopDevice(SmartcardExtension);

        }

    }

   return status;

}


VOID
Lit220StopDevice(
   IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine handles stopping the device.  It closes
   connection to serial port and stops the input filter
   if it has been activated.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    PDEVICE_OBJECT deviceObject = SmartcardExtension->OsData->DeviceObject;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l) {

        // test if we ever started event tracking
        if (SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {

            // no, we did not
            // We 'only' need to close the serial port
            Lit220CloseSerialPort(deviceObject, NULL);

        } else {
            PUCHAR requestBuffer;

            //
            // Stop the wait for character input and DSR changes.
            // When this happens it will signal the our waitforclose
            // thread to close the connection to the serial driver (if
            // it is not already closed).
            //
            readerExtension->SerialConfigData.WaitMask = 0;

            // save the pointer
            requestBuffer = SmartcardExtension->SmartcardRequest.Buffer;


            // Stop the event requests
            *(PULONG) SmartcardExtension->SmartcardRequest.Buffer =
                readerExtension->SerialConfigData.WaitMask;

            SmartcardExtension->SmartcardRequest.BufferLength =
                sizeof(ULONG);

            readerExtension->SerialIoControlCode =
                IOCTL_SERIAL_SET_WAIT_MASK;

            // No bytes expected back
            SmartcardExtension->SmartcardReply.BufferLength = 0;

            status = Lit220SerialIo(SmartcardExtension);
            ASSERT(status == STATUS_SUCCESS);

            // Restore the pointer
            SmartcardExtension->SmartcardRequest.Buffer = requestBuffer;

            // Wait for the close thread to complete
            KeWaitForSingleObject(
               &deviceExtension->SerialCloseDone,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

        }
    }

}


VOID
Lit220RemoveDevice(
   IN PDEVICE_OBJECT DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension;
    NTSTATUS status;

    PAGED_CODE();

    if (DeviceObject == NULL) {

        return;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    smartcardExtension = &deviceExtension->SmartcardExtension;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "%s!Lit220RemoveDevice: Enter\n",
        DRIVER_NAME)
      );

   // We need to stop the device before we can remove it.
   Lit220StopDevice(smartcardExtension);

/*  Superfluous -- Remove later
   // now wait until our device has been closed
   status = KeWaitForSingleObject(
      &deviceExtension->ReaderClosed,
      Executive,
      KernelMode,
      FALSE,
      NULL
      );

   ASSERT(status == STATUS_SUCCESS);
*/

   //
   // Clean ourself out of the driver stack layer
   //
    if (deviceExtension->SmartcardExtension.ReaderExtension &&
        deviceExtension->SmartcardExtension.ReaderExtension->BusDeviceObject) {

        IoDetachDevice(
            deviceExtension->SmartcardExtension.ReaderExtension->BusDeviceObject
            );
    }

   // Free PnPDeviceName
   if(deviceExtension->PnPDeviceName.Buffer != NULL) {

      RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
   }

   //
   // Let the lib free the send/receive buffers
   //
   if(smartcardExtension->OsData != NULL) {

      SmartcardExit(smartcardExtension);
   }


   // Free reader extension
    if (smartcardExtension->ReaderExtension != NULL) {

        ExFreePool(smartcardExtension->ReaderExtension);
    }



   // Free the work item
   if (deviceExtension->WorkItem != NULL) {
      IoFreeWorkItem(deviceExtension->WorkItem);
      deviceExtension->WorkItem = NULL;
   }


   // Delete the device object
   IoDeleteDevice(DeviceObject);
}



NTSTATUS
Lit220SynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp - Irp that just completed

    Event - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220SynchCompletionRoutine: Enter\n",
        DRIVER_NAME)
        );

    KeSetEvent(
        (PKEVENT) Event,
        0,
        FALSE
        );
    return (STATUS_MORE_PROCESSING_REQUIRED);
}



VOID
Lit220SystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    UNREFERENCED_PARAMETER (MinorFunction);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = IoStatus->Status;

    SmartcardReleaseRemoveLockWithTag(
      smartcardExtension,
      'rwoP'
      );

    if (PowerState.SystemState == PowerSystemWorking) {

        PoSetPowerState (
            DeviceObject,
            SystemPowerState,
            PowerState
            );
    }
                          
    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(smartcardExtension->ReaderExtension->BusDeviceObject, Irp);

   // IoCompleteRequest(Irp, IO_NO_INCREMENT);
}



NTSTATUS
Lit220DevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    ASSERT(irpStack != NULL);
    
    if(Irp->PendingReturned) {
       IoMarkIrpPending(Irp);
    }

    //
    // Check if the card is inserted
    //
    SmartcardExtension->ReaderCapabilities.CurrentState =
        (Lit220IsCardPresent(SmartcardExtension) ? SCARD_PRESENT : SCARD_ABSENT);

    //
    // Issue a power request in order to reset the card's status
    //
   if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_PRESENT) {
      SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
      status = Lit220Power(SmartcardExtension);
      ASSERT(status == STATUS_SUCCESS);
   }

    //
    // If a card was present before power down or now there is
    // a card in the reader, we complete any pending card monitor
    // request, since we do not really know what card is now in the
    // reader.
    //
    if(SmartcardExtension->ReaderExtension->CardPresent ||
       SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT) {

        Lit220NotifyCardChange(
         SmartcardExtension,
         SmartcardExtension->ReaderCapabilities.CurrentState & SCARD_PRESENT
         );
    }

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag(
      SmartcardExtension,
      'rwoP'
      );

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State
        );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    The power dispatch routine.
    All we care about is the transition from a low D state to D0.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedDeviceObject;
    POWER_STATE powerState;
    ACTION action = SkipRequest;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220DispatchPower: Enter\n",
        DRIVER_NAME)
        );

    status = SmartcardAcquireRemoveLockWithTag(
      smartcardExtension,
      'rwoP'
      );

    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedDeviceObject = smartcardExtension->ReaderExtension->BusDeviceObject;

   switch (irpStack->Parameters.Power.Type) {
   case DevicePowerState:
      if (irpStack->MinorFunction == IRP_MN_SET_POWER) {

         switch (irpStack->Parameters.Power.State.DeviceState) {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerDevice D0\n",
                           DRIVER_NAME)
                          );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   Lit220DevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;

         case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerDevice D3\n",
                           DRIVER_NAME)
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            smartcardExtension->ReaderExtension->CardPresent =
            smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent) {

               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = Lit220Power(smartcardExtension);
               ASSERT(status == STATUS_SUCCESS);
            }

            //
            // If there is a pending card tracking request, setting
            // this flag will prevent completion of the request
            // when the system will be waked up again.
            //
            smartcardExtension->ReaderExtension->PowerRequest = TRUE;

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            ASSERT(FALSE);
            action = SkipRequest;
            break;
         }
      } else {
         ASSERT(FALSE);
         action = SkipRequest;
         break;
      }
      break;

   case SystemPowerState: {

         //
         // The system wants to change the power state.
         // We need to translate the system power state to
         // a corresponding device power state.
         //

         POWER_STATE_TYPE powerType = DevicePowerState;

         ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
                PowerReaderUnspecified);

         switch (irpStack->MinorFunction) {

         KIRQL irql;

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: Query Power\n",
                           DRIVER_NAME)
                          );

            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
               KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
               if (deviceExtension->IoCount == 0) {

                  // Block any further ioctls
                  KeClearEvent(&deviceExtension->ReaderStarted);

               } else {

                  // can't go to sleep mode since the reader is busy.
                  status = STATUS_DEVICE_BUSY;
                  action = CompleteRequest;
               }
               KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
               break;
            }
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Lit220DispatchPower: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderWorking) {

                  // We're already in the right state
                  KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
                  action = SkipRequest;
                  break;
               }

               // wake up the underlying stack...
               powerState.DeviceState = PowerDeviceD0;
               action = MarkPending;
               break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

               if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                   PowerReaderOff) {

                  // We're already in the right state
                  action = SkipRequest;
                  break;
               }

               powerState.DeviceState = PowerDeviceD3;

               // first, inform the power manager of our new state.
               PoSetPowerState (
                               DeviceObject,
                               SystemPowerState,
                               powerState
                               );

               action = MarkPending;
               break;

            default:
               ASSERT(FALSE);
               action = CompleteRequest;
               break;
            }
         }
      }
      break;

   default:
      ASSERT(FALSE);
      action = CompleteRequest;
      break;
   }

    switch (action) {

        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'rwoP'
            );
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                Lit220SystemPowerCompletion,
                Irp,
                NULL
                );
            ASSERT(status == STATUS_PENDING);
         break;

        case SkipRequest:
            SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'rwoP'
            );
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220DispatchPower: Exit %lx\n",
        DRIVER_NAME,
        status)
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220scr.c ===
/*++

    Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999

Module Name:

    L220SCR.c - Main module for Driver

Abstract:

    Author:
        Brian Manahan

Environment:

    Kernel mode

Revision History :

--*/

#include <stdio.h>
#include "L220SCR.h"

// Make functions pageable
#pragma alloc_text(PAGEABLE, Lit220IsCardPresent)
#pragma alloc_text(PAGEABLE, Lit220Initialize)
#pragma alloc_text(PAGEABLE, Lit220ConfigureSerialPort)
#pragma alloc_text(PAGEABLE, Lit220CreateClose)
#pragma alloc_text(PAGEABLE, Lit220Unload)
#pragma alloc_text(PAGEABLE, Lit220InitializeInputFilter)


#if DBG
#pragma optimize ("", off)
#endif


BOOLEAN
Lit220IsCardPresent(
      IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine checks if a card is in the socket.  It is only done
    when the driver starts to set the intial state.  After that the
    reader will tell us when the status changes.
    It makes synchronous calls to the serial port.

--*/
{
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220IsCardPresent: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;

    //
    // Send a get reader status to see if a card is inserted
    //
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_GET_READER_STATUS;

    //
    // We Expect to get a response
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    if (status != STATUS_SUCCESS) {
        return FALSE;
    }

    // Check if length is correct
    if (SmartcardExtension->SmartcardReply.BufferLength != LIT220_READER_STATUS_LEN) {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220IsCardPresent: Reader response - bufLen %X, should be %X\n",
            DRIVER_NAME,
            SmartcardExtension->SmartcardReply.BufferLength,
            LIT220_READER_STATUS_LEN)
            );

        return FALSE;
    }

    // Check status byte to see if card is inserted
    if (SmartcardExtension->SmartcardReply.Buffer[0] & LIT220_STATUS_CARD_INSERTED) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220IsCardPresent: Card is inserted\n",
            DRIVER_NAME)
            );

        return TRUE;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220IsCardPresent: Card is not inserted\n",
        DRIVER_NAME)
        );

    return FALSE;
}





NTSTATUS
Lit220Initialize(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine initializes the reader for use.
    It sets up the serial communications, checks to make sure our
    reader is attached, checks if a card is inserted or not and
    sets up the input filter for receiving bytes from the reader
    asynchronously.

--*/

{
    PREADER_EXTENSION readerExtension;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Initialize: Enter - SmartcardExtension %X\n",
        DRIVER_NAME,
        SmartcardExtension)
        );

    readerExtension = SmartcardExtension->ReaderExtension;



    //
    // Set the serial config data
    //

    // We always talk to the  at 57600 no matter what speed the reader talks to the card
    readerExtension->SerialConfigData.BaudRate.BaudRate = 57600;
    readerExtension->SerialConfigData.LineControl.StopBits = STOP_BITS_2;
    readerExtension->SerialConfigData.LineControl.Parity = EVEN_PARITY;
    readerExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

    //
    // set timeouts
    //
    readerExtension->SerialConfigData.Timeouts.ReadIntervalTimeout = 10;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 1;
    readerExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 1;

    //
    // set special characters
    //
    readerExtension->SerialConfigData.SerialChars.ErrorChar = 0;
    readerExtension->SerialConfigData.SerialChars.EofChar = 0;
    readerExtension->SerialConfigData.SerialChars.EventChar = 0;
    readerExtension->SerialConfigData.SerialChars.XonChar = 0;
    readerExtension->SerialConfigData.SerialChars.XoffChar = 0;
    readerExtension->SerialConfigData.SerialChars.BreakChar = 0xFF;

    //
    // Set handflow
    //
    readerExtension->SerialConfigData.HandFlow.XonLimit = 0;
    readerExtension->SerialConfigData.HandFlow.XoffLimit = 0;
    readerExtension->SerialConfigData.HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
    readerExtension->SerialConfigData.HandFlow.ControlHandShake = 0;

    //
    // Now setup default the card state
    //
    SmartcardExtension->ReaderCapabilities.CurrentState = (ULONG) SCARD_UNKNOWN;

    //
    // Set the MechProperties
    //
    SmartcardExtension->ReaderCapabilities.MechProperties = 0;

    try {

        //
        // Configure the serial port
        //
        status = Lit220ConfigureSerialPort(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                SmartcardExtension->OsData->DeviceObject,
                LIT220_SERIAL_COMUNICATION_FAILURE,
                NULL,
                0
                );

            SmartcardDebug(DEBUG_ERROR,
                ("%s!Lit220Initialize: ConfiguringSerialPort failed %X\n",
                DRIVER_NAME,
                status)
                );
            leave;
        }


        //
        // Initailize the input filter now
        //
        status = Lit220InitializeInputFilter(
            SmartcardExtension
            );

        if (status != STATUS_SUCCESS) {

            SmartcardLogError(
                SmartcardExtension->OsData->DeviceObject,
                LIT220_SERIAL_COMUNICATION_FAILURE,
                NULL,
                0
                );

            SmartcardDebug(DEBUG_ERROR,
                ("%s!Lit220Initialize: Lit220InitializeInputFilter failed %X\n",
                DRIVER_NAME, status)
                );
            leave;
        }


        //
        // Now check if the card is inserted
        //
        if (Lit220IsCardPresent(SmartcardExtension)) {

            // Card is inserted
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_SWALLOWED;

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

            SmartcardExtension->ReaderExtension->CardIn = TRUE;
        } else {

            // Card is not inserted
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_ABSENT;

            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_UNDEFINED;

            SmartcardExtension->ReaderExtension->CardIn = FALSE;
        }
    }
    finally
    {

        SmartcardDebug(DEBUG_TRACE,
            ("%s!Lit220Initialize: Exit - status %X\n",
            DRIVER_NAME, status)
            );
    }
    return status;
}


NTSTATUS
Lit220ConfigureSerialPort(
    PSMARTCARD_EXTENSION SmartcardExtension
    )

/*++

Routine Description:

    This routine will appropriately configure the serial port.
    It makes synchronous calls to the serial port.

Arguments:

    SmartcardExtension - Pointer to smart card struct

Return Value:

    NTSTATUS

--*/

{
    PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER WaitTime;
    PSERIALPERF_STATS perfData;
    USHORT indx;
    PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;

    PAGED_CODE();

    SmartcardExtension->SmartcardRequest.BufferLength = 0;
    SmartcardExtension->SmartcardReply.BufferLength =
        SmartcardExtension->SmartcardReply.BufferSize;

    for (indx = 0; NT_SUCCESS(status); indx++) {

        switch (indx) {

            case 0:
                //
                // Set up baudrate for the Lit220 reader
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_BAUD_RATE;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->BaudRate;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_BAUD_RATE);
                break;

            case 1:
                //
                // Set up line control parameters
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_LINE_CONTROL;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->LineControl;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_LINE_CONTROL);
                break;

            case 2:
                //
                // Set serial special characters
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_CHARS;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->SerialChars;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_CHARS);
                break;

            case 3:
                //
                // Set up timeouts
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_TIMEOUTS;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->Timeouts;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_TIMEOUTS);
                break;

            case 4:
                //
                // Set flowcontrol and handshaking
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_HANDFLOW;

                SmartcardExtension->SmartcardRequest.Buffer =
                    (PUCHAR) &configData->HandFlow;

                SmartcardExtension->SmartcardRequest.BufferLength =
                    sizeof(SERIAL_HANDFLOW);
                break;

            case 5:
                //
                // Set break off
                //
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_BREAK_OFF;
                break;

            case 6:
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_SET_DTR;
                break;

            case 7:
                // 500ms delay before we send the next command
                // To give the reader a chance to calm down after we started it.
                WaitTime.HighPart = -1;
                WaitTime.LowPart = -500 * 10000;

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &WaitTime
                    );

                // Clear possible error condition with the serial port
                perfData =
                    (PSERIALPERF_STATS) SmartcardExtension->SmartcardReply.Buffer;

                // we have to call GetCommStatus to reset the error condition
                SmartcardExtension->ReaderExtension->SerialIoControlCode =
                    IOCTL_SERIAL_GET_COMMSTATUS;
                SmartcardExtension->SmartcardRequest.BufferLength = 0;
                SmartcardExtension->SmartcardReply.BufferLength =
                    sizeof(SERIAL_STATUS);
                break;

            case 8:
                return STATUS_SUCCESS;
        }

        // Send the command to the serial driver
        status = Lit220SerialIo(SmartcardExtension);

        //
        // restore pointer to original request buffer
        //
        SmartcardExtension->SmartcardRequest.Buffer = request;
    }

    return status;
}


NTSTATUS
Lit220CreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    if (irpStack->MajorFunction == IRP_MJ_CREATE) {

        status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

        if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;             

        } else {

            // test if the device has been opened already
            if (InterlockedCompareExchange(
                &deviceExtension->ReaderOpen,
                TRUE,
                FALSE) == FALSE) {

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220CreateClose: Open\n",
                    DRIVER_NAME)
                    );

            } else {
                
                // the device is already in use
                status = STATUS_UNSUCCESSFUL;

                // release the lock
                SmartcardReleaseRemoveLockWithTag(
                    &deviceExtension->SmartcardExtension,
                    'lCrC'
                    );
            }

        }

    } else {

        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220CreateClose: Close\n",
            DRIVER_NAME)
            );

        SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

        deviceExtension->ReaderOpen = FALSE;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;  
}




NTSTATUS
Lit220Cancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cancel: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    Lit220CompleteCardTracking(
        smartcardExtension
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cancel: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_CANCELLED;
}




NTSTATUS
Lit220Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates
    or when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = smartcardExtension->ReaderExtension;
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL oldOsDataIrql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cleanup: Enter\n",
        DRIVER_NAME)
        );

    Lit220CompleteCardTracking(smartcardExtension);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220Cleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
        );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Cleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}




VOID
Lit220Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    STATUS_SUCCESS.

--*/
{
    PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Unload: Enter\n",
        DRIVER_NAME)
        );

    //
    // All the device objects should be gone.
    //
    ASSERT (NULL == DriverObject->DeviceObject);

    //
    // Here we free any resources allocated in DriverEntry
    //

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220Unload: Exit\n",
        DRIVER_NAME)
        );
}




NTSTATUS
Lit220SerialIo(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine sends IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

    Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    ULONG currentByte = 0;
    DWORD indx;
    PDEVICE_EXTENSION devExt = SmartcardExtension->OsData->DeviceObject->DeviceExtension;

    if (KeReadStateEvent(&devExt->SerialCloseDone)) {

        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check if the buffers are large enough
    //
    ASSERT(SmartcardExtension->SmartcardReply.BufferLength <=
        SmartcardExtension->SmartcardReply.BufferSize);

    ASSERT(SmartcardExtension->SmartcardRequest.BufferLength <=
        SmartcardExtension->SmartcardRequest.BufferSize);

    if (SmartcardExtension->SmartcardReply.BufferLength >
        SmartcardExtension->SmartcardReply.BufferSize ||
        SmartcardExtension->SmartcardRequest.BufferLength >
        SmartcardExtension->SmartcardRequest.BufferSize) {

        SmartcardLogError(
            SmartcardExtension->OsData->DeviceObject,
            LIT220_BUFFER_TOO_SMALL,
            NULL,
            0
            );

        return STATUS_BUFFER_TOO_SMALL;
    }

    do {

        IO_STATUS_BLOCK ioStatus;
        KEVENT event;
        PIRP irp;
        PIO_STACK_LOCATION irpNextStack;
        PUCHAR requestBuffer = NULL;
        PUCHAR replyBuffer = SmartcardExtension->SmartcardReply.Buffer;
        ULONG requestBufferLength = 0;
        ULONG replyBufferLength = SmartcardExtension->SmartcardReply.BufferLength;

        KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE
            );

        if (SmartcardExtension->ReaderExtension->SerialIoControlCode ==
            IOCTL_SMARTCARD_220_WRITE) {

            //
            // If we write data to the smart card we only write byte by byte,
            // because we have to insert a delay between every sent byte
            //
            requestBufferLength =
                SmartcardExtension->SmartcardRequest.BufferLength;

            requestBuffer =
                SmartcardExtension->SmartcardRequest.Buffer;

#if DBG   // DbgPrint the buffer
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220SerialIo - Sending Buffer - ",
                DRIVER_NAME)
                );
            for (indx=0; indx<requestBufferLength; indx++){
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%X, ",
                    requestBuffer[indx])
                    );
            }
            SmartcardDebug(
                DEBUG_DRIVER,
                ("\n")
                );
#endif
        } else {
            
            requestBufferLength =
                SmartcardExtension->SmartcardRequest.BufferLength;

            requestBuffer =
                (requestBufferLength ?
                SmartcardExtension->SmartcardRequest.Buffer : NULL);
        }

        //
        // Build irp to be sent to serial driver
        //
        irp = IoBuildDeviceIoControlRequest(
            SmartcardExtension->ReaderExtension->SerialIoControlCode,
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            requestBuffer,
            requestBufferLength,
            replyBuffer,
            replyBufferLength,
            FALSE,
            &event,
            &ioStatus
            );

        ASSERT(irp != NULL);

        if (irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        irpNextStack = IoGetNextIrpStackLocation(irp);


        switch (SmartcardExtension->ReaderExtension->SerialIoControlCode) {

            //
            // The serial driver trasfers data from/to irp->AssociatedIrp.SystemBuffer
            //
            case IOCTL_SMARTCARD_220_WRITE:
                irpNextStack->MajorFunction = IRP_MJ_WRITE;
                irpNextStack->Parameters.Write.Length =
                    SmartcardExtension->SmartcardRequest.BufferLength;
                break;

            case IOCTL_SMARTCARD_220_READ:
                irpNextStack->MajorFunction = IRP_MJ_READ;
                irpNextStack->Parameters.Read.Length =
                    SmartcardExtension->SmartcardReply.BufferLength;

                break;
        }


        // Send the command to the serial driver
        status = IoCallDriver(
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            irp
            );

        if (status == STATUS_PENDING) {

            // Wait for the command to complete
            KeWaitForSingleObject(
                &event,
                Suspended,
                KernelMode,
                FALSE,
                NULL
                );

            status = ioStatus.Status;
        }

    } while (status == STATUS_MORE_PROCESSING_REQUIRED);

    return status;
}




NTSTATUS
Lit220InitializeInputFilter(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine initialized input filter. It calls the serial driver to
    set a wait mask for character input or DSR change. After that it installs a completion
    routine to be called when a character is received or when DSR changes.
    The completion routine for the wait is Lit220SerialEventCallback and that IRP will
    run until the device is ready to be removed.

Arguments:

    SmartcardExtension - Pointer to our smartcard structure

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;

    PAGED_CODE();

    // Set the WaitMask
    SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask =
        SERIAL_EV_RXCHAR | SERIAL_EV_DSR;

    KeInitializeEvent(
        &SmartcardExtension->ReaderExtension->CardStatus.Event,
        NotificationEvent,
        FALSE
        );

    try {
        //
        // Send a wait mask to the serial driver.
        // This call only sets the wait mask.
        // We want to be informed if a character is received
        //
        SmartcardExtension->ReaderExtension->CardStatus.Irp = IoBuildDeviceIoControlRequest(
            IOCTL_SERIAL_SET_WAIT_MASK,
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
           &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask,
            sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask),
            NULL,
            0,
            FALSE,
           &(SmartcardExtension->ReaderExtension->CardStatus.Event),
           &(SmartcardExtension->ReaderExtension->CardStatus.IoStatus)
            );

        if (SmartcardExtension->ReaderExtension->CardStatus.Irp == NULL) {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("%s!Lit220InitializeCardTracking: Error STATUS_INSUFFICIENT_RESOURCES\n",
                DRIVER_NAME);
                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        // Call the serial driver
        status = IoCallDriver(
            SmartcardExtension->ReaderExtension->ConnectedSerialPort,
            SmartcardExtension->ReaderExtension->CardStatus.Irp,
            );

        if (status == STATUS_SUCCESS) {

            KIRQL oldIrql;
            LARGE_INTEGER delayPeriod;
            PIO_STACK_LOCATION irpSp;

            //
            // Now tell the serial driver that we want to be informed
            // if a character is received or DSR changes
            //
            readerExtension->CardStatus.Irp = IoAllocateIrp(
                (CCHAR) (SmartcardExtension->OsData->DeviceObject->StackSize + 1),
                FALSE
                );

            if (readerExtension->CardStatus.Irp == NULL) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            irpSp = IoGetNextIrpStackLocation( readerExtension->CardStatus.Irp );
            irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

            irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            irpSp->Parameters.DeviceIoControl.OutputBufferLength =
                sizeof(readerExtension->SerialConfigData.WaitMask);
            irpSp->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_SERIAL_WAIT_ON_MASK;
            
            readerExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer =
                &readerExtension->SerialConfigData.WaitMask;

            //
            // this artificial delay is necessary to make this driver work
            // with digi board cards
            //
            delayPeriod.HighPart = -1;
            delayPeriod.LowPart = 100l * 1000 * (-10);

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &delayPeriod
                );

            // We simulate a callback now that triggers the card supervision
            Lit220SerialEventCallback(
                SmartcardExtension->OsData->DeviceObject,
                SmartcardExtension->ReaderExtension->CardStatus.Irp,
                SmartcardExtension
                );

            status = STATUS_SUCCESS;

        }
    }
    finally {

        if (status != STATUS_SUCCESS) {
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s(Lit220InitializeInputFilter): Initialization failed - stauts %X\n",
                DRIVER_NAME,
                status)
                );

            // Clear the WaitMask since we did not get the call out that does the wait
            SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask =
                0;
        }
    }

    return status;
}   


NTSTATUS
Lit220SystemControl(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )

/*++

Routine Description:

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/
{
   
   PDEVICE_EXTENSION DeviceExtension; 
   PSMARTCARD_EXTENSION SmartcardExtension; 
   PREADER_EXTENSION ReaderExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;
   SmartcardExtension   = &DeviceExtension->SmartcardExtension;
   ReaderExtension      = SmartcardExtension->ReaderExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(ReaderExtension->BusDeviceObject, Irp);
      
   return status;

} 


NTSTATUS
Lit220DeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    This is the main entry point for the PCSC resource manager.
    We pass all commands to the smartcard libary and let the smartcard
    library call us directly when needed (If device is ready to receive
    calls).
    If the device is not ready we will hold the IRP until we get a signal
    that it is safe to send IRPs again.
    If the device is removed we return an error instead of calling the
    smartcard library.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = smartcardExtension->ReaderExtension;
    NTSTATUS status;
    KIRQL irql;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s(Lit220DeviceControl): Enter DeviceObject %X, Irp %X\n",
        DRIVER_NAME,
        DeviceObject,
        Irp)
        );

    if (smartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {

        //
        // the wait mask is set to 0 whenever the device was either
        // surprise-removed or politely removed
        //
        status = STATUS_DEVICE_REMOVED;
    }

    // Increment the IRP count
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount == 0) {

        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    status = SmartcardAcquireRemoveLockWithTag(
        smartcardExtension,
        'tcoI');

    if ((status != STATUS_SUCCESS) || (ReaderExtension->DeviceRemoved)) {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SmartcardReleaseRemoveLockWithTag(
            smartcardExtension,
            'tcoI');

        return STATUS_DEVICE_REMOVED;
    }

    ASSERT(deviceExtension->SmartcardExtension.ReaderExtension->ReaderPowerState ==
        PowerReaderWorking);

    //
    // We are in the common situation where we send the IRP
    // to the smartcard lib to handle it.
    //
    status = SmartcardDeviceControl(
        &(deviceExtension->SmartcardExtension),
        Irp
        );

    SmartcardReleaseRemoveLockWithTag(
        smartcardExtension,
        'tcoI');

    // Decrement the IRP count
    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220DeviceControl: Exit %X\n",
        DRIVER_NAME, status)
        );
    return status;
}



NTSTATUS
Lit220GetReaderError(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine checks the status of the previous error to determine the
    correct error code to return.
    The default error is timeout if we cannot determine the error from the
    reader.

--*/
{
    static ULONG PreventReentry = FALSE;
    PSMARTCARD_REQUEST smartcardRequest = &SmartcardExtension->SmartcardRequest;
    NTSTATUS status = STATUS_TIMEOUT;
    LARGE_INTEGER WaitTime;
    KIRQL irql;


    // Sometimes after a command the reader is not reader to accept another command
    // so we need to wait for a short period of time for the reader to be ready.  We need to
    // take this out as soon as the reader is fixed!

    WaitTime.HighPart = -1;
    WaitTime.LowPart = -10 * 1000 * 1000;  // Wait 1S for reader to recover from error.

    KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &WaitTime
        );

    // Prevent a nack from this call from recursively calling itself
    if (InterlockedExchange(
            &PreventReentry,
            TRUE))
    {
        // Default error to timeout if reader keeps failing our calls
        return STATUS_TIMEOUT;
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220GetReaderError: Enter\n",
        DRIVER_NAME)
        );

    smartcardRequest->BufferLength = 0;

    //
    // Send a get reader status to see if a card is inserted
    //
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
       LIT220_READER_ATTENTION;
    smartcardRequest->Buffer[smartcardRequest->BufferLength++] =
        LIT220_GET_READER_STATUS;

    //
    // We Expect to get a response
    //
    SmartcardExtension->ReaderExtension->WaitMask |= WAIT_DATA;

    // Send the command
    status = Lit220Command(
        SmartcardExtension
        );

    if (status == STATUS_SUCCESS) {
        // Check if length is correct
        if (SmartcardExtension->SmartcardReply.BufferLength != LIT220_READER_STATUS_LEN) {
            // Return a status timeout because the reader failed to respond
            status = STATUS_TIMEOUT;
        }

        if (status == STATUS_SUCCESS) {
            // Check the error byte to see if there was a protocol error
            // otherwise assume timeout
            if (SmartcardExtension->SmartcardReply.Buffer[1] & 0x04) {
                status = STATUS_TIMEOUT;
            } else {
                status = STATUS_DEVICE_PROTOCOL_ERROR;
            }

            // Check status byte to see if card is inserted
            // and send a notification accordingly
            if (SmartcardExtension->SmartcardReply.Buffer[0] & LIT220_STATUS_CARD_INSERTED) {
                Lit220NotifyCardChange(
                    SmartcardExtension,
                    TRUE
                    );

            } else {
                Lit220NotifyCardChange(
                    SmartcardExtension,
                    FALSE
                    );
            }

        }

    }

    InterlockedExchange(
        &PreventReentry,
        FALSE);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220fltr.c ===
/*++

Module Name:

    L220FLTR.c

Abstract:

    This module contains the input filter routine and the notification 
    procedure for insertion/removal events.  

Environment:

    Kernel mode only.

Notes:

Revision History:

    - Created December 1996 by Klaus Schutz (kschutz)

    - Modified December 1997 by Brian Manahan for use with
        our 220 reader.

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "L220SCR.h"


#pragma alloc_text(PAGEABLE, Lit220StartTimer)
#pragma alloc_text(PAGEABLE, Lit220StopTimer)


static DWORD bTrue = TRUE;
static DWORD bFalse = FALSE;


BOOLEAN
Lit220InputFilter(
    IN BYTE SmartcardByte,
    IN PSMARTCARD_EXTENSION smartcardExtension
    )
/*++

Routine Description:

    This routine is processes each byte from the serial port.
    Lit220SerialEventCallback call this function when it receives a byte
    of data from the serial port.  For card insertion/removal it will call the
    Lit220NotifyCardChange to process the notificiation.  
    If an ACK is received it will signal the Lit220SendCommand so it can continue.
    After a data block is received it will signal the Lit220SendCommand
    to notifiy that the data is ready.
--*/
{
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
	PDEVICE_EXTENSION deviceExtension = smartcardExtension->OsData->DeviceObject->DeviceExtension;

    LONG semState;
    BOOLEAN retVal = TRUE;


    //
    // The first byte of each packet identifies the packet-type
    // A packet containing data starts with the packet-type and then
    // 2 bytes of packet length.
    //
    if (++readerExtension->ReceivedByteNo == 1) {
    
        readerExtension->GotLengthB0 = FALSE;
        readerExtension->GotLengthB1 = FALSE;
        readerExtension->DataByteNo = 0;
         
        switch (SmartcardByte) {
        
            case LIT220_READER_TYPE:
    
                // Prepare for reader type input
                readerExtension->GotLengthB0 = TRUE;
                readerExtension->GotLengthB1 = TRUE;
                readerExtension->DataLength.l.l0 = 
                    LIT220_READER_TYPE_LEN;
                break;
                
            case LIT220_READER_STATUS:

                // Prepare for reader status input
                readerExtension->GotLengthB0 = TRUE;
                readerExtension->GotLengthB1 = TRUE;
                readerExtension->DataLength.l.l0 = 
                    LIT220_READER_STATUS_LEN;
                break;    
                
            case LIT220_RECEIVE_BLOCK:
                // If a smart card was already inserted in the boot phase
                // the reader sends only the ATR but no CARD_IN - msg.
                // We fix that missing msg here.
                //
                if (smartcardExtension->ReaderCapabilities.CurrentState == SCARD_UNKNOWN) {
                
                    smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
                }
                
                break;    
                
            case LIT220_CARD_IN:

                Lit220NotifyCardChange(
                    smartcardExtension,
                    TRUE
                    );

                readerExtension->ReceivedByteNo = 0;
                break;    
                
            case LIT220_CARD_OUT:

                Lit220NotifyCardChange(
                    smartcardExtension,
                    FALSE
                    );

                    
                readerExtension->ReceivedByteNo = 0;
                    
                break;    
                
            case LIT220_ACK:
            case KBD_ACK: // Also allow kdb_ack for the case for getting keyboard attention
                readerExtension->GotNack = FALSE;
                readerExtension->ReceivedByteNo = 0;


                // Check if anyone needs to be singaled for this event.
                // The Lit220SendCommand waits for the ACK signal so it knows
                // when it can continue.
                if (readerExtension->WaitMask & WAIT_ACK) {
                    LONG semState;
                
                    // Only signal once
                    readerExtension->WaitMask &= ~WAIT_ACK;

                    // Signal the AckEvnt
                    KeSetEvent(
                        &readerExtension->AckEvnt,
                        0, 
                        FALSE
                        );
                }   
                             
                break;    
                
                
            case LIT220_NACK:
                SmartcardDebug(
                    DEBUG_ERROR, 
                    ("%s!Lit220InteruptService: LIT220_NACK\n",
                    DRIVER_NAME)
                    );

                Lit220ProcessNack(smartcardExtension);

                break;    

            default:
                readerExtension->ReceivedByteNo = 0;
                
                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!Lit220InteruptService: Invalid PacketType %xh\n",
                    DRIVER_NAME,
                    SmartcardByte)
                    );

                // Return false so the rest of this bad buffer 
                // will not be sent to us.
                retVal = FALSE; 

                // We want to force a NACK so the
                // the state of the card being inserted or not
                // is re-checked
                Lit220ProcessNack(smartcardExtension);
        }
        
        return retVal;
    }    
       
    //
    // Get length-byte-0 from reader
    //        
    if (readerExtension->ReceivedByteNo == 2 &&
        readerExtension->GotLengthB0 == FALSE)  {
            
        readerExtension->DataLength.b.b1 = SmartcardByte;
        readerExtension->GotLengthB0 = TRUE;
        return TRUE;
    }
        
    //
    // Get length-byte-1 from reader
    //        
    if (readerExtension->ReceivedByteNo == 3 &&
        readerExtension->GotLengthB1 == FALSE)  {
            
        readerExtension->DataLength.b.b0 = SmartcardByte;
        readerExtension->GotLengthB1 = TRUE;
        
        // 
        // test if the reader has sent a zero-length block of data
        //
        if (readerExtension->DataLength.l.l0 == 0) {
        
            readerExtension->ReceivedByteNo = 0;
            readerExtension->WaitForATR = FALSE;        
            
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardInterruptService: Zero length block received\n",
                DRIVER_NAME)
                );
        }

        if (readerExtension->DataLength.l.l0 > 
	        smartcardExtension->SmartcardReply.BufferSize) {

            readerExtension->ReceivedByteNo = 0;
            readerExtension->WaitForATR = FALSE;        
            
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!SmartcardInterruptService: Reply buffer not large enough\n",
                DRIVER_NAME)
                );

        }
        return TRUE;
    }

    //
    // store data from reader
    //
    if ((readerExtension->DataByteNo < readerExtension->DataLength.l.l0) &&
        (readerExtension->DataByteNo < smartcardExtension->SmartcardReply.BufferSize))
    {

        smartcardExtension->SmartcardReply.Buffer[readerExtension->DataByteNo++] = 
        	SmartcardByte;

    } else {
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!SmartcardInterruptService: DataByteNo %X too large buffer %X, %X bytest expected\n",
            DRIVER_NAME,
            readerExtension->DataByteNo,
            smartcardExtension->SmartcardReply.BufferSize,
            readerExtension->DataLength.l.l0)
            );

    }

    ASSERT(readerExtension->DataByteNo <= readerExtension->DataLength.l.l0);
    //
    // Have we received all the bytes in the packet yet?
    //
    if (readerExtension->DataByteNo == readerExtension->DataLength.l.l0) {
                                     
        // Stop the input timeout timer
        // schedule our remove thread
		Lit220ScheduleTimer(
			smartcardExtension,
			Lit220StopTimer
			);


        smartcardExtension->SmartcardReply.BufferLength = 
	        readerExtension->DataByteNo;

        readerExtension->ReceivedByteNo = 0;
        
        if (readerExtension->WaitForATR)  {
            
            //
            // Transfer ATR to smartcard-struct
            //
            smartcardExtension->CardCapabilities.ATR.Length = 
                (UCHAR) (readerExtension->DataByteNo % (SCARD_ATR_LENGTH + 1));
              
            readerExtension->WaitForATR = FALSE;        

            if (smartcardExtension->CardCapabilities.ATR.Length >
                smartcardExtension->SmartcardReply.BufferLength)
            {
                SmartcardDebug(
                    DEBUG_ERROR,
                    ("%s!SmartcardInterruptService: SmarcardReply buffer too  small for ATR\n",
                    DRIVER_NAME)
                    );
            } else {

                RtlCopyMemory(
                    smartcardExtension->CardCapabilities.ATR.Buffer,
                    smartcardExtension->SmartcardReply.Buffer,
                    smartcardExtension->CardCapabilities.ATR.Length
                    );
          
                SmartcardUpdateCardCapabilities(
                    smartcardExtension
                    );
            }
        }
        
        
        // Check if anyone needs to be singaled for this event.
        // The Lit220SendCommand waits for the DataEvnt signal so it knows
        // when the data has been received.
        if (readerExtension->WaitMask & WAIT_DATA) {
        
            //
            // Do any necessary post proccessing after we have receive the packet
            //
            if (smartcardExtension->OsData->CurrentIrp != NULL)  {
  
                NTSTATUS status = STATUS_SUCCESS;

                switch (smartcardExtension->MajorIoControlCode) {
      
                    case IOCTL_SMARTCARD_POWER:
                        if (smartcardExtension->ReaderExtension->GotNack) {                
              
                            status = STATUS_NO_MEDIA;
                            break;
                        }
          
                        switch(smartcardExtension->MinorIoControlCode) {
                      
                            case SCARD_COLD_RESET:
                            case SCARD_WARM_RESET:
                                if (smartcardExtension->IoRequest.ReplyBufferLength <
                                    smartcardExtension->CardCapabilities.ATR.Length) {
                              
                                        status = STATUS_BUFFER_TOO_SMALL;
                              
                                } else {
                  
                                    //
                                    // copy ATR to user buffer
                                    //
                                    if (smartcardExtension->CardCapabilities.ATR.Length <=
                                        sizeof(smartcardExtension->CardCapabilities.ATR.Buffer)) 
                                    {
                                        RtlCopyMemory(
                                            smartcardExtension->IoRequest.ReplyBuffer,
                                            &smartcardExtension->CardCapabilities.ATR.Buffer, 
                                            smartcardExtension->CardCapabilities.ATR.Length
                                            );
                            
                                        // 
                                        // length of buffer
                                        //        
                                        *(smartcardExtension->IoRequest.Information) = 
                                            smartcardExtension->CardCapabilities.ATR.Length;                            
                                    }
                                }
                      
                                break;
                      
                            case SCARD_POWER_DOWN:
                                if (smartcardExtension->ReaderCapabilities.CurrentState != SCARD_ABSENT) {
                                    smartcardExtension->ReaderCapabilities.CurrentState = 
                                        SCARD_SWALLOWED;
                              
                                    smartcardExtension->CardCapabilities.Protocol.Selected = 
                                        SCARD_PROTOCOL_UNDEFINED;
                                }
                                break;
                      
                        }
                        break;
              
                    case IOCTL_SMARTCARD_SET_PROTOCOL:
                        if (smartcardExtension->ReaderExtension->GotNack) {                
              
                            smartcardExtension->CardCapabilities.Protocol.Selected = 
                                SCARD_PROTOCOL_UNDEFINED;

                            status = STATUS_NO_MEDIA;
                            break;
                        }

                        //
                        // protocol has been changed successfully
                        //    
                        if (smartcardExtension->ReaderCapabilities.CurrentState != SCARD_ABSENT) {
                            smartcardExtension->ReaderCapabilities.CurrentState = 
                                SCARD_SPECIFIC;
                        }

                        //
                        // Tell the caller what the current protocol is.
                        //
                        *(PULONG) smartcardExtension->IoRequest.ReplyBuffer =
                            smartcardExtension->CardCapabilities.Protocol.Selected;
    
                        *(smartcardExtension->IoRequest.Information) = 
                          sizeof(ULONG);

                        break;

                } 
      
            }

            // Only signal once
            readerExtension->WaitMask &= ~WAIT_DATA;
             
            // Signal the DataEvnt
            KeSetEvent(
                &readerExtension->DataEvnt,
                0, 
                FALSE
                );
        }
    }

    return TRUE;
}




VOID 
Lit220ProcessNack(
	PSMARTCARD_EXTENSION SmartcardExtension
	)
/*++

Routine Description:

    This routine handles everything that needs to be done when we have an error
    with the reader.  The state of the input filter is reset.  All signals that
    the Lit220Command function may be waiting on are fired.  The flag GotNack is
    set which will trigger Lit220Command to resync with the reader (get the last
    error and refresh the card inserted state).

--*/
{
    PREADER_EXTENSION readerExtension = SmartcardExtension->ReaderExtension;

    // Set GotNack so we know something went wrong
    readerExtension->GotNack = TRUE;

    // Reset the input state of the filter
    readerExtension->ReceivedByteNo = 0;
    

    //
    // Signal the ACK and data semaphores and set error code
    // This will keep the Lit220SendCommand from having to 
    // wait for a timeout to continue when something goes wrong.
    //
    if (readerExtension->WaitMask & WAIT_ACK) {
    
        // Signal the AckEvnt
        KeSetEvent(
            &readerExtension->AckEvnt,
            0, 
            FALSE
            );
    }

    if (readerExtension->WaitMask & WAIT_DATA) {

        // Signal the DataEvnt
        KeSetEvent(
            &readerExtension->DataEvnt,
            0, 
            FALSE
            );
    }


    //
    // Reset WaitMask since the card has nacked the command
    // 
    readerExtension->WaitMask &= (WAIT_INSERTION | WAIT_REMOVAL);
}




VOID
Lit220NotifyCardChange(
    IN PSMARTCARD_EXTENSION smartcardExtension,
    IN DWORD CardInserted
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL to finish processing
    a card insertion/removal event.  It is queued in the smartcard filter
    and notifies a caller of an insertion/removal event.

--*/

{
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
    KIRQL oldOsDataIrql;
    
	if (readerExtension->CardIn == CardInserted) {
		return;
	}
    readerExtension->CardIn = CardInserted;


    KeAcquireSpinLock(
        &smartcardExtension->OsData->SpinLock,
        &oldOsDataIrql
        );


    if (CardInserted) {
        // Set the default state for the new card
        smartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_SWALLOWED;

        smartcardExtension->CardCapabilities.Protocol.Selected = 
	        SCARD_PROTOCOL_UNDEFINED;
    } else {
        // Reset card state to reflect the card removal
        smartcardExtension->ReaderCapabilities.CurrentState = 
            SCARD_ABSENT;

        smartcardExtension->CardCapabilities.Protocol.Selected = 
	        SCARD_PROTOCOL_UNDEFINED;

        smartcardExtension->CardCapabilities.ATR.Length = 0; 
    }

    if (readerExtension->WaitMask & WAIT_INSERTION) {

        // We only make this notification once
        readerExtension->WaitMask &= ~WAIT_INSERTION;
    }      
	
	Lit220CompleteCardTracking(smartcardExtension);

    KeReleaseSpinLock(
        &smartcardExtension->OsData->SpinLock,
        oldOsDataIrql
        );

}


VOID
Lit220CompleteCardTracking(
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    KIRQL oldIrql;
    PIRP notificationIrp;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220CompleteCardTracking: Enter\n",
        DRIVER_NAME)
        );

    IoAcquireCancelSpinLock(&oldIrql);

    notificationIrp = InterlockedExchangePointer(
        &(SmartcardExtension->OsData->NotificationIrp),
        NULL
        );
    
    if (notificationIrp) {

        IoSetCancelRoutine(
            notificationIrp, 
            NULL
            );
    }

    IoReleaseCancelSpinLock(oldIrql);

    if (notificationIrp) {
     	
	    //	finish the request
        if (notificationIrp->Cancel) {
         	
	        notificationIrp->IoStatus.Status = STATUS_CANCELLED;

        } else {
         	
	        notificationIrp->IoStatus.Status = STATUS_SUCCESS;
        }
	    notificationIrp->IoStatus.Information = 0;

	    IoCompleteRequest(
            notificationIrp, 
            IO_NO_INCREMENT 
            );
    }
}


     
NTSTATUS 
Lit220SerialEventCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This routine is first called as the deferred procedure when a character is received
    or when DSR changes its status.
	It first calls the serial driver to get the modem status to see if the events was
    due to DSR changing (meaning the reader has been removed).  
    If DSR did not change it then checks the input queue size and reads the characters in
    the input queue.  It then sends the input characters to the input filter for processing.
    Finally it calls the serial driver again to start new cts tracking (starting all over again).
    This routine gets continually called back from itself until the driver is ready
    to unload (indicated by the WaitMask set to 0).
    When the WaitMask is set to 0 it frees this IRP and signals the Lit220WaitForRemoval thread
    to close the serial port.
--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    DWORD indx;			
	PDEVICE_EXTENSION deviceExtension = SmartcardExtension->OsData->DeviceObject->DeviceExtension;

    SmartcardExtension->ReaderExtension->SerialEventState++;

    //
    // First check to see we are being unloaded
    //
    if (SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask == 0) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220SerialEventCallback: WAIT MASK 0 UNLOADING !!!!\n",
            DRIVER_NAME)
            );

		SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;

        //
        // If the WaitMask is 0 then the driver is about to unload and we've
        // been called because the unload function has directed the serial
        // driver to complete the outstanding io completion.
        //

        // schedule our remove thread
		IoQueueWorkItem(
			deviceExtension->WorkItem,
            (PIO_WORKITEM_ROUTINE) Lit220CloseSerialPort,
			DelayedWorkQueue,
            NULL
			);

		//
		// We don't need the IRP anymore, so free it and tell the 
		// io subsystem not to touch it anymore by returning the value below
		//
		IoFreeIrp(Irp);
		return STATUS_MORE_PROCESSING_REQUIRED;
	}

    // Get next stack location for next IRP
    irpStack = IoGetNextIrpStackLocation(
		SmartcardExtension->ReaderExtension->CardStatus.Irp
		);

    if (irpStack == NULL) {
        // Fatal Error
        SmartcardDebug(
            DEBUG_ERROR,
            ("%s!Lit220SerialEventCallback: Error IoGetNextIrpStackLocation returned NULL - exiting.\n",
            DRIVER_NAME)
            );
        return STATUS_SUCCESS;
    }

    switch (SmartcardExtension->ReaderExtension->SerialEventState) {
        case 1:
            //
            // First we send a get modem status
            //
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
                sizeof(SmartcardExtension->ReaderExtension->ModemStatus);
            irpStack->Parameters.DeviceIoControl.IoControlCode = 
                IOCTL_SERIAL_GET_MODEMSTATUS;

            SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
	            &SmartcardExtension->ReaderExtension->ModemStatus;

            break;

        case 2:
            //
            // Check modem status if DSR = 0 then unload driver if not 
            // then get queuestatus
            //
            if ((SmartcardExtension->ReaderExtension->ModemStatus & SERIAL_DSR_STATE) == 0) {
                // DSR is 0 this means the reader has been removed

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220SerialEventCallback: DSR = 0 signaling to close device\n",
                    DRIVER_NAME)
                    );

                SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask = 0;
				SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_UNKNOWN;

				// schedule our remove thread
		        IoQueueWorkItem(
			        deviceExtension->WorkItem,
                    (PIO_WORKITEM_ROUTINE) Lit220CloseSerialPort,
			        DelayedWorkQueue,
                    NULL
			        );
                
				//
				// We don't need the IRP anymore, so free it and tell the 
				// io subsystem not to touch it anymore by returning the value below
				//
				IoFreeIrp(Irp);
				return STATUS_MORE_PROCESSING_REQUIRED;

            } else {

                // Device is not removed - there must be a character ready
                // Read the data into our temporary buffer.  The temporary buffer
				// is large enough to read whatever the reader can send us a one time.
				// The character interval timeout will stop the read at the end of whatever
				// the reader sends us.
                SmartcardExtension->ReaderExtension->SerialStatus.AmountInInQueue =
                    sizeof(SmartcardExtension->ReaderExtension->TempXferBuf);

                // Read the characters
                irpStack->MajorFunction = IRP_MJ_READ;
                irpStack->Parameters.Read.Length = 
					sizeof(SmartcardExtension->ReaderExtension->TempXferBuf);
                irpStack->MinorFunction = 0UL;

                SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                    SmartcardExtension->ReaderExtension->TempXferBuf;


            } 


            break;

        case 3:
            //
            // Send the characers we read to the input filter then setup for read input
            // queue again (in case some characters came in while we were processing the
            // ones we just read).
            // 
            for (indx = 0; indx < Irp->IoStatus.Information; indx++) {

                if (!Lit220InputFilter(
                        SmartcardExtension->ReaderExtension->TempXferBuf[indx],
                        SmartcardExtension
                        ))
                {
                    // An invalid character was received so stop sending the rest of
                    // the data to the filter because it is probably corrupted.
                    break;
                }
            }

            // Check if we are in the middle of a block of data
            if (SmartcardExtension->ReaderExtension->ReceivedByteNo != 0) {

                // Start the timeout timer.  If we don't get the rest of this 
                // data block in a few seconds we will timeout.  This prevents 
                // communication problems between the reader and the PC causing
                // locking up a T=0 card for too long.
				Lit220ScheduleTimer(
					SmartcardExtension,
					Lit220StartTimer
					);

            }

				
			//
			// Read done - start all over again with the wait_on_mask
			//
			irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
			irpStack->MinorFunction = 0UL;
			irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
				sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask);
			irpStack->Parameters.DeviceIoControl.IoControlCode = 
				IOCTL_SERIAL_WAIT_ON_MASK;

			SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
				&SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

			// Reset SerialEventState value
			SmartcardExtension->ReaderExtension->SerialEventState = 0;
            break;

        default:
            SmartcardDebug(
                DEBUG_ERROR,
                ("%s!Lit220SerialEventCallback: Error SerialEventState is out of bounds - resetting to 0\n",
                DRIVER_NAME)
                );
            //
            // We should never get here, but if we do we should try to recover the
            // best we can by setting up for the wait_on_mask.
            //

            // Reset value
            SmartcardExtension->ReaderExtension->SerialEventState = 0;

            // Setup for next callback
            irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            irpStack->MinorFunction = 0UL;
            irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
                sizeof(SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask);
            irpStack->Parameters.DeviceIoControl.IoControlCode = 
                IOCTL_SERIAL_WAIT_ON_MASK;

            SmartcardExtension->ReaderExtension->CardStatus.Irp->AssociatedIrp.SystemBuffer = 
                &SmartcardExtension->ReaderExtension->SerialConfigData.WaitMask;

    }

    // We always call this same function when we complete a call
    IoSetCompletionRoutine(
	    SmartcardExtension->ReaderExtension->CardStatus.Irp,
	    Lit220SerialEventCallback,
	    SmartcardExtension,
	    TRUE,
	    TRUE,
	    TRUE
	    );

    // Call the serial driver
    status = IoCallDriver(
        SmartcardExtension->ReaderExtension->ConnectedSerialPort, 
        SmartcardExtension->ReaderExtension->CardStatus.Irp
        );

    // Return STATUS_MORE_PROCESSING_REQUIRED so our IRP stays around
    return STATUS_MORE_PROCESSING_REQUIRED;
}	



VOID 
Lit220ScheduleTimer(
	IN PSMARTCARD_EXTENSION SmartcardExtension,
	IN PIO_WORKITEM_ROUTINE Routine
    )
{
		PIO_WORKITEM workItem = IoAllocateWorkItem(
		    SmartcardExtension->OsData->DeviceObject
		    );

		if (workItem != NULL) {

			IoQueueWorkItem(
				workItem,
				Routine,
				CriticalWorkQueue,
				workItem
				);
		} 
}


VOID 
Lit220StartTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine starts the timeout timer.  The function is executed as a worker
    thread so IoStartTimer does not get called at the wrong IRQL.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    deviceExtension->EntryCount = 0;

    IoStartTimer(DeviceObject);

	IoFreeWorkItem(WorkItem);

}

VOID 
Lit220StopTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine stops the timeout timer.  The function is executed as a worker
    thread so IoStopTimer does not get called at the wrong IRQL.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();


	IoStopTimer(DeviceObject);

	IoFreeWorkItem(WorkItem);
}



VOID
Lit220ReceiveBlockTimeout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is timeout callback.  A timeout is setup every time we get an
    incomplete block of data.  Once we receive the complete block the timeout 
    will be canceled.  The type of timer we use for the timeout gets called 
    once every second.  We want to time out after a few seconds, so we keep track
    of how many time we get called and then timeout after we have been called 
    5 times.
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;

    if (readerExtension->DataByteNo == readerExtension->DataLength.l.l0) {
        // Stop the timer we got all the bytes we need
		Lit220ScheduleTimer(
			smartcardExtension,
			Lit220StopTimer
			);

        return;
    }

    if (++deviceExtension->EntryCount >= 5) {
        SmartcardDebug(
            DEBUG_ERROR, 
            ("%s!Lit220ReceiveBlockTimeout: Communication with reader timed-out\n",
            DRIVER_NAME)
            );

        // Process the timeout
        Lit220ProcessNack(smartcardExtension);
        
        // A timeout has occured schedule worker thread to 
        // stop the timer
		Lit220ScheduleTimer(
			smartcardExtension,
			Lit220StopTimer
			);

        deviceExtension->EntryCount = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Lit220.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrcb.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCB.c

Abstract:

        callback handler for PSCR.xxx driver

Author:

        Andreas Straub

Environment:

        Win 95          Sys... calls are resolved by Pscr95Wrap.asm functions and
                                Pscr95Wrap.h macros, resp.

        NT      4.0             Sys... functions resolved by PscrNTWrap.c functions and
                                PscrNTWrap.h macros, resp.

Revision History:

        Andreas Straub                  8/18/1997       1.00    Initial Version
        Andreas Straub                  9/24/1997       1.02    Flush Interface if card tracking
                                                                                                requested

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else   //      SMCLIB_VXD

#include <PscrNT.h>

#endif  //      SMCLIB_VXD


#include <PscrRdWr.h>
#include <PscrCmd.h>
#include <PscrCB.h>


NTSTATUS
CBCardPower( 
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBCardPower:
        callback handler for SMCLIB RDF_CARD_POWER

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_BUFFER_TOO_SMALL

--*/
{
        NTSTATUS                        NTStatus = STATUS_SUCCESS;
        UCHAR                           ATRBuffer[ ATR_SIZE ], TLVList[16];
        ULONG                           Command,
                                                ATRLength;
        PREADER_EXTENSION       ReaderExtension;
    BYTE                CardState;
#if DBG || DEBUG
    static PCHAR request[] = { "PowerDown",  "ColdReset", "WarmReset" };
#endif

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBCardPower: Enter, Request = %s\n",
        request[SmartcardExtension->MinorIoControlCode])
                );

        ReaderExtension = SmartcardExtension->ReaderExtension;

        //
        //      update actual power state
        //
        Command = SmartcardExtension->MinorIoControlCode;

        switch ( Command )
        {
                case SCARD_WARM_RESET:

                        //      if the card was not powerd, fall thru to cold reset
                        if( SmartcardExtension->ReaderCapabilities.CurrentState >
                                SCARD_SWALLOWED )
                        {
                                //      reset the card
                                ATRLength = ATR_SIZE;
                                NTStatus = CmdReset(
                                        ReaderExtension,
                                        ReaderExtension->Device,
                                        TRUE,                           // warm reset
                                        ATRBuffer,
                                        &ATRLength
                                        );

                                break;
                        }

                        //      warm reset not possible because card was not powerd
                case SCARD_COLD_RESET:

                        //      reset the card
                        ATRLength = ATR_SIZE;
                        NTStatus = CmdReset(
                                ReaderExtension,
                                ReaderExtension->Device,
                                FALSE,                          // cold reset
                                ATRBuffer,
                                &ATRLength
                                );
                        break;

                case SCARD_POWER_DOWN:
                        ATRLength = 0;
                        NTStatus = CmdDeactivate(       
                                ReaderExtension,
                                ReaderExtension->Device
                                );

                        //      discard old card status
            CardState = CBGetCardState(SmartcardExtension);
            CBUpdateCardState(SmartcardExtension, CardState, FALSE);
                        break;
        }

    if (NT_SUCCESS(NTStatus)) {
        
        //
        // Set the 'restart of work waiting time' counter for T=0
        // This will send a WTX request for n NULL bytes received
        //
        TLVList[0] = TAG_SET_NULL_BYTES;
        TLVList[1] = 1;
        TLVList[2] = 0x05; 

        NTStatus = CmdSetInterfaceParameter(
                ReaderExtension,
                DEVICE_READER,
                TLVList,
                3
                );
    }

    ASSERT(NT_SUCCESS(NTStatus));

        //      finish the request
        if( NT_SUCCESS( NTStatus ))
        {
                //      update all neccessary data if an ATR was received
                if( ATRLength > 2 )
                {
                        //
                        //      the lib expects only the ATR, so we skip the 
                        //      900x from the reader
                        //
                        ATRLength -= 2;

                        //      copy ATR to user buffer buffer
                        if( ATRLength <= SmartcardExtension->IoRequest.ReplyBufferLength )
                        {
                                SysCopyMemory(
                                        SmartcardExtension->IoRequest.ReplyBuffer,
                                        ATRBuffer,
                                        ATRLength
                                        );
                                *SmartcardExtension->IoRequest.Information = ATRLength;
                        }
                        else
                        {
                                NTStatus = STATUS_BUFFER_TOO_SMALL;
                        }

                        //      copy ATR to card capability buffer
                        if( ATRLength <= MAXIMUM_ATR_LENGTH )
                        {
                                SysCopyMemory(
                                        SmartcardExtension->CardCapabilities.ATR.Buffer,
                                        ATRBuffer,
                                        ATRLength
                                        );

                                SmartcardExtension->CardCapabilities.ATR.Length = 
                                        ( UCHAR )ATRLength;

                                //      let the lib update the card capabilities
                                NTStatus = SmartcardUpdateCardCapabilities(
                                        SmartcardExtension 
                                        );
                        }
                        else
                        {
                                NTStatus = STATUS_BUFFER_TOO_SMALL;
                        }
                }
        }

        if( !NT_SUCCESS( NTStatus ))
        {
                switch( NTStatus )
                {
                        case STATUS_NO_MEDIA:
                        case STATUS_BUFFER_TOO_SMALL:
                                break;

                        case STATUS_TIMEOUT:
                NTStatus = STATUS_IO_TIMEOUT;
                break;

                        default:
                                NTStatus = STATUS_UNRECOGNIZED_MEDIA;
                break;
                }
        }

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBCardPower: Exit (%lx)\n", NTStatus )
                );
        
        return( NTStatus );
}

NTSTATUS
CBSetProtocol( 
        PSMARTCARD_EXTENSION SmartcardExtension 
        )

/*++

CBSetProtocol:
        callback handler for SMCLIB RDF_SET_PROTOCOL

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_BUFFER_TOO_SMALL
        STATUS_INVALID_DEVICE_STATE
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
        NTSTATUS NTStatus = STATUS_PENDING;
        USHORT SCLibProtocol;
        UCHAR TLVList[ TLV_BUFFER_SIZE ];
        PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;

    if (SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_SPECIFIC) {

        return STATUS_SUCCESS;
    }

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBSetProtocol: Enter\n" )
                );

        SCLibProtocol = ( USHORT )( SmartcardExtension->MinorIoControlCode );

    if (SCLibProtocol & (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1))
    {
                //
                //      setup the TLV list for the Set Interface Parameter List
                //
                TLVList[ 0 ] = TAG_ICC_PROTOCOLS;
                TLVList[ 1 ] = 0x01;
                TLVList[ 2 ] = 
            (SCLibProtocol & SCARD_PROTOCOL_T1 ? PSCR_PROTOCOL_T1 : PSCR_PROTOCOL_T0);

                //      do the PTS
                NTStatus = CmdSetInterfaceParameter(
                        ReaderExtension,
                        ReaderExtension->Device,
                        TLVList,
                        3                       // size of list
                        );              

    } else {

                //      we don't support other modi
                NTStatus = STATUS_INVALID_DEVICE_REQUEST;
        }

        //      if protocol selection failed, prevent from calling invalid protocols
        if( NT_SUCCESS( NTStatus ))
        {
                SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
                SCLibProtocol = (SCLibProtocol & SCARD_PROTOCOL_T1 &
                         SmartcardExtension->CardCapabilities.Protocol.Supported) ?
                                                 SCARD_PROTOCOL_T1 :
                                                 SCARD_PROTOCOL_T0;
        }
        else
        {
                SCLibProtocol = SCARD_PROTOCOL_UNDEFINED;
        }

        //      Return the selected protocol to the caller.
        SmartcardExtension->CardCapabilities.Protocol.Selected = SCLibProtocol;
        *( PULONG )( SmartcardExtension->IoRequest.ReplyBuffer ) = SCLibProtocol;
        *( SmartcardExtension->IoRequest.Information ) = sizeof( ULONG );
        
        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBSetProtocol: Exit (%lx)\n", NTStatus )
                );

        return ( NTStatus );
}

NTSTATUS
CBTransmit( 
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBTransmit:
        callback handler for SMCLIB RDF_TRANSMIT

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
        NTSTATUS  NTStatus = STATUS_SUCCESS;

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBTransmit: Enter\n" )
                );

        //      dispatch on the selected protocol
        switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
        {
                case SCARD_PROTOCOL_T0:
                        NTStatus = CBT0Transmit( SmartcardExtension );
                        break;

                case SCARD_PROTOCOL_T1:
                        NTStatus = CBT1Transmit( SmartcardExtension );
                        break;

                case SCARD_PROTOCOL_RAW:
                        NTStatus = CBRawTransmit( SmartcardExtension );
                        break;

                default:
                        NTStatus = STATUS_INVALID_DEVICE_REQUEST;
                        break;
        }

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBTransmit: Exit (%lx)\n", NTStatus )
                );

        return( NTStatus );
}

NTSTATUS
CBRawTransmit(
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBRawTransmit:
        finishes the callback RDF_TRANSMIT for the RAW protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS                    NTStatus = STATUS_SUCCESS;
        UCHAR                           TLVList[ TLV_BUFFER_SIZE ],
                                                Val,
                                                Len;
        ULONG                           TLVListLen;
        PREADER_EXTENSION       ReaderExtension;

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBRawTransmit: Enter\n" )
                );

        ReaderExtension = SmartcardExtension->ReaderExtension;
        //
        //      read the status file of ICC1 from the reader
        //
        TLVListLen = TLV_BUFFER_SIZE;
        NTStatus = CmdReadStatusFile(
                ReaderExtension,
                ReaderExtension->Device,
                TLVList,
                &TLVListLen
                );

        //
        //      check the active protocol of the reader
        //
        if( NT_SUCCESS( NTStatus ))
        {
                NTStatus = CmdGetTagValue(
                        TAG_ICC_PROTOCOLS,
                        TLVList,
                        TLVListLen,
                        &Len,
                        ( PVOID ) &Val
                        );

                //      execute the active protocol
                if( NT_SUCCESS( NTStatus ))
                {

                        //      translate the actual protocol to a value the lib can understand
                        switch( Val )
                        {
                                case PSCR_PROTOCOL_T0:
                                        NTStatus = CBT0Transmit( SmartcardExtension );
                                        break;
                                case PSCR_PROTOCOL_T1:
                                        NTStatus = CBT1Transmit( SmartcardExtension );
                                        break;
                                default:
                                        NTStatus = STATUS_UNSUCCESSFUL;
                                        break;
                        }
                }
        }
        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBRawTransmit: Exit (%lx)\n", NTStatus )
                );
        return ( NTStatus );
}

NTSTATUS
CBT1Transmit(
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBT1Transmit:
        finishes the callback RDF_TRANSMIT for the T1 protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS    NTStatus = STATUS_SUCCESS;
        ULONG           IOBytes;

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBT1Transmit: Enter\n" )
                );
        //
        //      use the lib support to construct the T=1 packets
        //
        do {
                //
                //      no header for the T=1 protocol
                //
                SmartcardExtension->SmartcardRequest.BufferLength = 0;
                //
                //      SCM-TM: Siemens 4440 accepts only NAD=0!!!
                //
                SmartcardExtension->T1.NAD = 0;
                //
                //      let the lib setup the T=1 APDU & check for errors
                //
                NTStatus = SmartcardT1Request( SmartcardExtension );
                if( NT_SUCCESS( NTStatus ))
                {

                        //      send command (don't calculate LRC because CRC may be used!)
                        IOBytes = 0;
                        NTStatus = PscrWriteDirect(
                                SmartcardExtension->ReaderExtension,
                                SmartcardExtension->SmartcardRequest.Buffer,
                                SmartcardExtension->SmartcardRequest.BufferLength,
                                &IOBytes
                                );
                        //
                        //      extend the timeout if a Wtx request was sent by the card. if the 
                        //      card responds before the waiting time extension expires, the data are
                        //      buffered in the reader. A delay without polling the reader status
                        //      slows down the performance of the driver, but wtx is an exeption,
                        //      not the rule.
                        //
                        if (SmartcardExtension->T1.Wtx)
                        {
                                        SysDelay(
                                        (( SmartcardExtension->T1.Wtx * 
                                        SmartcardExtension->CardCapabilities.T1.BWT + 999L )/
                                        1000L) 
                                        );

                        }

                        //      get response
                        SmartcardExtension->SmartcardReply.BufferLength = 0;
                        NTStatus = PscrRead(
                                SmartcardExtension->ReaderExtension,
                                SmartcardExtension->SmartcardReply.Buffer,
                                MAX_T1_BLOCK_SIZE,
                                &SmartcardExtension->SmartcardReply.BufferLength
                                );

                        //      if PscrRead detects an LRC error, ignore it (maybe CRC used)
                        if( NTStatus == STATUS_CRC_ERROR )
                        {
                                NTStatus = STATUS_SUCCESS;
                        }

            //
            // We even continue if the prev. read failed.
            // We let the smart card library continue, because it might
            // send a resynch. request in case of a timeout
            //
                        NTStatus = SmartcardT1Reply( SmartcardExtension );
                }

        //      continue if the lib wants to send the next packet
        } while( NTStatus == STATUS_MORE_PROCESSING_REQUIRED );

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBT1Transmit: Exit (%lx)\n", NTStatus )
                );

        return ( NTStatus );
}

NTSTATUS
CBT0Transmit( 
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBT0Transmit:
        finishes the callback RDF_TRANSMIT for the T0 protocol

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS
        STATUS_NO_MEDIA
        STATUS_TIMEOUT
        STATUS_INVALID_DEVICE_REQUEST

--*/
{
    NTSTATUS NTStatus = STATUS_SUCCESS;
        PUCHAR pRequest,pReply;
        ULONG IOBytes, APDULength, RequestLength;
        UCHAR IOData[ MAX_T1_BLOCK_SIZE ];
    UCHAR WtxReply[16];

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBT0Transmit: Enter\n" )
                );

        pRequest        = SmartcardExtension->SmartcardRequest.Buffer;
        pReply          = SmartcardExtension->SmartcardReply.Buffer;

        //      setup the command header
        pRequest[ PSCR_NAD ] = 
                ( SmartcardExtension->ReaderExtension->Device == DEVICE_ICC1 ) ? 
                NAD_TO_ICC1 : NAD_TO_ICC1;

        pRequest[ PSCR_PCB ] = PCB_DEFAULT;
        //
        //      get the length of the user data packet & set the appropriate LEN
        //      information the complete user packet consists of a SCARD_IO_REQUEST
        //      structure followed by the APDU. the length of SCARD_IO_REQUEST is
        //      transferred in the member cbPciLength of the structure
        //
        APDULength = SmartcardExtension->IoRequest.RequestBufferLength;
        APDULength -= ((PSCARD_IO_REQUEST) SmartcardExtension->
                IoRequest.RequestBuffer)->cbPciLength;
        //
        //      a 4 byte APDU will be patched to a 5 byte TPDU by the lib; see
        //      annex of the ISO
        //
        if( APDULength == 4 ) APDULength++;
        //
        //      if the total length of the T1 (reader) packet is larger than 0xFF
        //      the extended length notation will be used
        //
        if( APDULength >= 0xFF )
        {
                pRequest[ PSCR_LEN ]    = 0xFF;
                pRequest[ PSCR_LEN+1 ]  = HIBYTE( APDULength );
                pRequest[ PSCR_LEN+2 ]  = LOBYTE( APDULength );
                SmartcardExtension->SmartcardRequest.BufferLength =
                        PSCR_EXT_PROLOGUE_LENGTH;
        }
        else
        {
                pRequest[ PSCR_LEN ] = ( UCHAR ) APDULength;
                SmartcardExtension->SmartcardRequest.BufferLength = 
                        PSCR_PROLOGUE_LENGTH;
        }

        //      let the lib setup the T=1 APDU & check for errors
        NTStatus = SmartcardT0Request( SmartcardExtension );
    RequestLength = SmartcardExtension->SmartcardRequest.BufferLength;

        while( NT_SUCCESS( NTStatus ))
        {
                //      send command
                IOBytes = 0;
                NTStatus = PscrWrite(
                        SmartcardExtension->ReaderExtension,
                        pRequest,
                        RequestLength,
                        &IOBytes
                        );

                //      get response
                if( NT_SUCCESS( NTStatus ))
                {
                        IOBytes = 0;
                        NTStatus = PscrRead(
                                SmartcardExtension->ReaderExtension,
                                IOData,
                                MAX_T1_BLOCK_SIZE,
                                &IOBytes
                                );

                        //      extract APDU from T=1 transport packet
                        if( NT_SUCCESS( NTStatus ))
                        {
                if (IOData[ PSCR_PCB ] == WTX_REQUEST) {

                    WtxReply[PSCR_NAD] = NAD_TO_PSCR;
                    WtxReply[PSCR_PCB] = WTX_REPLY;
                    WtxReply[PSCR_LEN] = 1;
                    WtxReply[PSCR_INF] = IOData[PSCR_INF];

                    RequestLength = 4;
                    pRequest = WtxReply;
                    continue;
                }

                                if( IOData[ PSCR_LEN ] == 0xFF )
                                {
                                        //
                                        //      extended length byte used
                                        //
                                        APDULength  = IOData[ PSCR_LEN + 1 ] << 8;
                                        APDULength += IOData[ PSCR_LEN + 2 ];

                                        SmartcardExtension->SmartcardReply.BufferLength = APDULength ;
                                        SysCopyMemory( pReply, &IOData[ PSCR_APDU + 2 ], APDULength );
                                }
                                else
                                {
                                        SmartcardExtension->SmartcardReply.BufferLength = 
                                                IOData[ PSCR_LEN ];

                                        SysCopyMemory( 
                                                pReply, 
                                                &IOData[ PSCR_APDU ], 
                                                IOData[ PSCR_LEN ] 
                                                );
                                }

                                // let the lib evaluate the result & tansfer the data
                                NTStatus = SmartcardT0Reply( SmartcardExtension );
                break;
                        }
                }
        }

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBT0Transmit: Exit (%lx)\n", NTStatus )
                );

    return( NTStatus );
}

NTSTATUS
CBCardTracking( 
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBCardTracking:
        callback handler for SMCLIB RDF_CARD_TRACKING. the requested event was 
        validated by the smclib (i.e. a card removal request will only be passed 
        if a card is present).
        for a win95 build STATUS_PENDING will be returned without any other action. 
        for NT the cancel routine for the irp will be set to the drivers cancel
        routine.

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_PENDING

--*/
{
        KIRQL CancelIrql;

        SmartcardDebug( 
                DEBUG_TRACE, 
                ( "PSCR!CBCardTracking: Enter\n" )
                );

        //      set cancel routine
        IoAcquireCancelSpinLock( &CancelIrql );

        IoSetCancelRoutine(
                SmartcardExtension->OsData->NotificationIrp, 
                PscrCancel
                );

        IoReleaseCancelSpinLock( CancelIrql );

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBCardTracking: Exit \n" )
                );

        return( STATUS_PENDING );
}

VOID
CBUpdateCardState(
        PSMARTCARD_EXTENSION SmartcardExtension,
    UCHAR IccState,
    BOOLEAN SystemWakeUp
        )
{
    ULONG oldState;
    KIRQL currentIrql, irql;

    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &irql
        );

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBUpdateCardState: Enter \n" )
                );

    oldState = 
        (SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT ?
        SCARD_PRESENT : SCARD_ABSENT);

        SmartcardExtension->ReaderCapabilities.CurrentState = 
        (IccState == PSCR_ICC_PRESENT ? SCARD_PRESENT : SCARD_ABSENT);

        SmartcardDebug( 
                DEBUG_DRIVER, 
                ( "PSCR!CBUpdateCardState: Smart card %s\n",
        IccState == PSCR_ICC_PRESENT ? "inserted" : "removed")
                );

    IoAcquireCancelSpinLock( &currentIrql );

        if( SmartcardExtension->OsData->NotificationIrp != NULL && (
            SystemWakeUp && (
                oldState == SCARD_PRESENT || 
                SmartcardExtension->ReaderCapabilities.CurrentState == SCARD_PRESENT) || 
            SmartcardExtension->ReaderCapabilities.CurrentState != oldState)) {

        PIRP notificationIrp = InterlockedExchangePointer(
            &(SmartcardExtension->OsData->NotificationIrp),
            NULL
            );

                IoSetCancelRoutine( 
            notificationIrp, 
            NULL 
            );

                IoReleaseCancelSpinLock( currentIrql );

        if (notificationIrp->Cancel == FALSE) {
                
                    //  finish the request
                    notificationIrp->IoStatus.Status    = STATUS_SUCCESS;
                    notificationIrp->IoStatus.Information = 0;

                SmartcardDebug( 
                        DEBUG_DRIVER, 
                        ( "PSCR!CBUpdateCardState: Completing Irp %lx\n",
                notificationIrp)
                        );

                    IoCompleteRequest(notificationIrp, IO_NO_INCREMENT );
        }

    } else {
        
                IoReleaseCancelSpinLock( currentIrql );
    }

        SmartcardDebug( 
                DEBUG_TRACE,
                ( "PSCR!CBUpdateCardState: Exit \n" )
                );

        KeReleaseSpinLock(
                &SmartcardExtension->OsData->SpinLock,
                irql
                );
}

UCHAR 
CBGetCardState(
        PSMARTCARD_EXTENSION SmartcardExtension 
        )
/*++

CBUpdateCardState:
        updates the variable CurrentState in SmartcardExtension

Arguments:
        SmartcardExtension      context of call

Return Value:
        STATUS_SUCCESS

--*/
{
        NTSTATUS NTStatus = STATUS_SUCCESS;
        UCHAR TLVList[ TLV_BUFFER_SIZE ],       Val, Len;
        ULONG TLVListLen;
        PREADER_EXTENSION       ReaderExtension = SmartcardExtension->ReaderExtension;

        //      read the status file of ICC1 from the reader
        TLVListLen = TLV_BUFFER_SIZE;

        if( NT_SUCCESS( CmdReadStatusFile(
                ReaderExtension,
                ReaderExtension->Device,
                TLVList,
                &TLVListLen
                )))     {

                //      get reader status value
                CmdGetTagValue(
                        TAG_READER_STATUS,
                        TLVList,
                        TLVListLen,
                        &Len,
                        ( PVOID ) &Val
                        );
        }
        else
        {
                //      IO-error is interpreted as card absent
                Val = PSCR_ICC_ABSENT;
        }

    return Val;
}

//      -------------------------------- END OF FILE ------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrcb.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCB.h

Abstract:

	prototypes of callback handlers for pscr.xxx

Author:

	Andreas Straub

Environment:

	Win 95
	NT	4.0

Revision History:

	Andreas Straub			7/16/1997	Initial Version

--*/

#if !defined( __PSCR_CALLBACK_H__ )
#define __PSCR_CALLBACK_H__

NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension,
    UCHAR CardState,
    BOOLEAN SystemWakeUp
	);

UCHAR 
CBGetCardState(
	PSMARTCARD_EXTENSION SmartcardExtension
	);
#endif // __PSCR_CALLBACK_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\lit220\l220powr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation and Litronic, 1998 - 1999
//
//  File:       l220powr.c
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////
//
// Power Management
//
//////////////////////////////////////////////////////////


NTSTATUS
Lit220DispatchPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The power dispatch routine.

    As this is a POWER irp, and therefore a special irp, special power irp
    handling is required.


Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

      NT status code

--*/
{
    PIO_STACK_LOCATION  stack;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS            status;

    LONG          requestCount;

    stack = IoGetCurrentIrpStackLocation(Irp);

    //
    // This IRP was sent to the function driver.
    // The behavior is similar with the one of SD_Pass
    //

    //
    // This IRP was sent to the function driver.
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll send it to the next lower
    // driver.
    //

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!Lit220DispatchPower: Enter - MinorFunction %X\n",
        DRIVER_NAME,
        stack->MinorFunction)
        );


    // Increment the IRP Count
    status = Lit220IncIoCount(ReaderExtension);

    if (ReaderExtension->IsRemoved) {
        status = STATUS_DELETE_PENDING;
        PoStartNextPowerIrp (Irp);
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

    } else {

        //
        // We always need to start the next power irp with PoStartNextPowerIrp
        //
        switch  (stack->MinorFunction)  {
            case IRP_MN_WAIT_WAKE   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_WAIT_WAKE\n",
                    DRIVER_NAME)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_POWER_SEQUENCE   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_POWER_SEQUENCE\n",
                    DRIVER_NAME)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_QUERY_POWER   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_QUERY_POWER\n",
                    DRIVER_NAME)
                    );


                status = Lit220QueryPowerState(
                    DeviceObject,
                    Irp
                    );

                break;

            case IRP_MN_SET_POWER   :
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_SET_POWER\n",
                    DRIVER_NAME)
                    );

                status = Lit220SetPowerState(
                    DeviceObject,
                    Irp
                    );

                break;


            default:
                //
                // Pass it down
                //
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Lit220DispatchPower: IRP_MN_0x%x\n",
                    DRIVER_NAME,
                    stack->MinorFunction)
                    );

                status = Lit220PassDownToNextPowerDriver(
                    DeviceObject,
                    Irp
                    );

                break;
        }

    }

    return status;
}






NTSTATUS
Lit220PassDownToNextPowerDriver  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

    Passes the Irp to the next device in the attchement chain

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    PoStartNextPowerIrp(Irp);

    status = PoCallDriver(
        ReaderExtension->BusDeviceObject,
        Irp
        );

    if (!NT_SUCCESS(status)) {
        SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!Lit220PassDownToNextPowerDriver : Lower driver fails a power irp\n",
            DRIVER_NAME)
            );
    }

    return status;
}


NTSTATUS
Lit220QueryPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

   Completes the power Irp with STATUS_SUCCESS

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    Irp->IoStatus.Status = STATUS_SUCCESS;

    PoStartNextPowerIrp(Irp);

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );


    //
    // Do not send this Irp down.
    //
    return STATUS_SUCCESS;
}



NTSTATUS
Lit220SetPowerState  (
    IN  PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP        Irp
    )

/*++

Routine Description:

   Processes IRP_MN_SET_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

Return Value:

   NT status code

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
   PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    PIO_STACK_LOCATION  stack;

    PFDO_POWER_CONTEXT  context;

    BOOLEAN             passItDown;



    stack = IoGetCurrentIrpStackLocation (Irp);

    SmartcardDebug(
        DEBUG_DRIVER,
        ("%s!Lit220SetPowerState: Type %X, State %X\n",
        DRIVER_NAME,
      stack->Parameters.Power.Type,
      stack->Parameters.Power.State.SystemState)
        );

    context = ExAllocatePool(
        NonPagedPool,
        sizeof(FDO_POWER_CONTEXT)
        );

    if (context == NULL) {

        status = STATUS_NO_MEMORY;

    } else {

        RtlZeroMemory(
            context,
            sizeof(FDO_POWER_CONTEXT)
            );

        stack = IoGetCurrentIrpStackLocation (Irp);

        context->newPowerType  = stack->Parameters.Power.Type;
        context->newPowerState = stack->Parameters.Power.State;

        passItDown = TRUE;

        if (stack->Parameters.Power.Type == SystemPowerState) {

            if (ReaderExtension->SystemPowerState ==
                stack->Parameters.Power.State.SystemState)
            {

                //
                // We are already in the given system state
                //
                passItDown = FALSE;
            }

        } else if (stack->Parameters.Power.Type == DevicePowerState) {

            if (ReaderExtension->DevicePowerState !=
                stack->Parameters.Power.State.DeviceState)
            {

                if (ReaderExtension->DevicePowerState == PowerDeviceD0) {

                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        stack->Parameters.Power.State
                        );
                }

            } else {

                //
                // We are already in the given device state
                //
                passItDown = FALSE;
            }
        } else {

            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }

    if (NT_SUCCESS(status) && passItDown) {

        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(Irp,
                               Lit220PowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        return PoCallDriver(
            ReaderExtension->BusDeviceObject,
            Irp
            );

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        //
        // Free the memory now
        //
        if (context) {
            ExFreePool (context);
        }

        return status;
    }
}



NTSTATUS
Lit220PowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

   The completion routine for IRP_MN_SET_POWER.

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Context - a pointer to a structure that contains the new power type and
   new power state.

Return Value:

   NT status code

--*/
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState;
    PSMARTCARD_EXTENSION SmartcardExtension = DeviceObject->DeviceExtension;
   PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) {

            ReaderExtension->SystemPowerState = context->newPowerState.SystemState;


        } else if (context->newPowerType == DevicePowerState) {

            if (ReaderExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            //TODO: Send Power command to device
            //Also, Not sure if we should do this yet it is
            // still TBD

            ReaderExtension->DevicePowerState = context->newPowerState.DeviceState;

        }

        if (callPoSetPowerState) {

            PoSetPowerState (
                DeviceObject,
                context->newPowerType,
                context->newPowerState
                );
        }
    }

    PoStartNextPowerIrp (Irp);
    //
    // We can happily free the heap here
    //
    ExFreePool(context);

    return Irp->IoStatus.Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrnt.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrNT.h

Abstract:

    Driver header - NT Version

Author:

    Andreas Straub  (SCM Microsystems, Inc.)
    Klaus Schuetz   (Microsoft Corp.)

Revision History:

    Andreas Straub  1.00        8/18/1997       Initial Version
    Klaus Schuetz   1.01        9/20/1997       Timing changed
    Andreas Straub  1.02        9/24/1997       Low Level error handling,
                                                minor bugfixes, clanup
    Andreas Straub  1.03        10/8/1997       Timing changed, generic SCM
                                                interface changed
    Andreas Straub  1.04        10/18/1997      Interrupt handling changed
    Andreas Straub  1.05        10/19/1997      Generic IOCTL's added
    Andreas Straub  1.06        10/25/1997      Timeout limit for FW update variable
    Andreas Straub  1.07        11/7/1997       Version information added
    Andreas Straub  1.08        11/10/1997      Generic IOCTL GET_CONFIGURATION
    Klaus Schuetz               1998            PnP and Power Management added

--*/

#if !defined ( __PSCR_NT_DRV_H__ )
#define __PSCR_NT_DRV_H__
#define SMARTCARD_POOL_TAG '4SCS'

#include <wdm.h>
#include <DEVIOCTL.H>
#include "SMCLIB.h"
#include "WINSMCRD.h"

#include "PscrRdWr.h"

#if !defined( STATUS_DEVICE_REMOVED )
#define STATUS_DEVICE_REMOVED STATUS_UNSUCCESSFUL
#endif

#define SysCompareMemory( p1, p2, Len )         ( RtlCompareMemory( p1,p2, Len ) != Len )
#define SysCopyMemory( pDest, pSrc, Len )       RtlCopyMemory( pDest, pSrc, Len )
#define SysFillMemory( pDest, Value, Len )      RtlFillMemory( pDest, Len, Value )

#define DELAY_WRITE_PSCR_REG    1
#define DELAY_PSCR_WAIT         5

#define LOBYTE( any )   ((UCHAR)( any & 0xFF ) )
#define HIBYTE( any )   ((UCHAR)( ( any >> 8) & 0xFF ))

typedef struct _DEVICE_EXTENSION
{
    SMARTCARD_EXTENSION SmartcardExtension;

    // The PDO that we are attached to
    PDEVICE_OBJECT AttachedPDO;

    // The DPC object for post interrupt processing
    KDPC DpcObject;

    // Out interrupt resource
    PKINTERRUPT InterruptObject;

    // Flag that indicates if we need to unmap the port upon stop
    BOOLEAN UnMapPort;

    // Our PnP device name
    UNICODE_STRING DeviceName;

    // Current number of io-requests
    LONG IoCount;

    // Used to access IoCount;
    KSPIN_LOCK SpinLock;

     // Used to signal that the device has been removed
    KEVENT ReaderRemoved;

    // Used to signal that the reader is able to process reqeusts
    KEVENT ReaderStarted;

    // Used to signal the the reader has been closed
    LONG ReaderOpen;

    // Used to keep track of the current power state the reader is in
    LONG PowerState;

    // Number of pending card tracking interrupts
    ULONG PendingInterrupts;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define PSCR_MAX_DEVICE     2

#define IOCTL_PSCR_COMMAND      SCARD_CTL_CODE( 0x8000 )
#define IOCTL_GET_VERSIONS      SCARD_CTL_CODE( 0x8001 )
#define IOCTL_SET_TIMEOUT       SCARD_CTL_CODE( 0x8002 )
#define IOCTL_GET_CONFIGURATION SCARD_CTL_CODE( 0x8003 )

typedef struct _VERSION_CONTROL
{
    ULONG   SmclibVersion;
    UCHAR   DriverMajor,
            DriverMinor,
            FirmwareMajor, 
            FirmwareMinor,
            UpdateKey;
} VERSION_CONTROL, *PVERSION_CONTROL;

#define SIZEOF_VERSION_CONTROL  sizeof( VERSION_CONTROL )

typedef struct _PSCR_CONFIGURATION
{
    PPSCR_REGISTERS IOBase;
    ULONG           IRQ;

} PSCR_CONFIGURATION, *PPSCR_CONFIGURATION;

#define SIZEOF_PSCR_CONFIGURATION   sizeof( PSCR_CONFIGURATION )

void SysDelay( ULONG Timeout );

BOOLEAN
PscrMapIOPort( 
    INTERFACE_TYPE  InterfaceType,
    ULONG BusNumber,
    PHYSICAL_ADDRESS BusAddress,
    ULONG Length,
    PULONG pIOPort
    );
        
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

NTSTATUS
PscrPnP(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS
PscrPower(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp
    );

NTSTATUS 
PscrCreateAndStartDevice(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PscrCreateDevice(
    IN  PDRIVER_OBJECT DriverObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS 
PscrStartDevice(
    PDEVICE_OBJECT DeviceObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
    );

NTSTATUS
PscrPcmciaCallComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

VOID
PscrStopDevice( 
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PscrReportResources(
    PDRIVER_OBJECT DriverObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDesciptor
    );

NTSTATUS
PscrAddDevice(
    IN PDRIVER_OBJECT DriverObject, 
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
PscrUnloadDevice( 
    PDEVICE_OBJECT DeviceObject
    );

VOID
PscrUnloadDriver( 
    PDRIVER_OBJECT DriverObject
    );

BOOLEAN
IsPnPDriver( 
    void 
    );

VOID
PscrFinishPendingRequest(
    PDEVICE_OBJECT DeviceObject,
    NTSTATUS NTStatus
    );

NTSTATUS
PscrCancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PscrCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
PscrIrqServiceRoutine(
    PKINTERRUPT Interrupt,
    PDEVICE_EXTENSION DeviceExtension
    );

VOID
PscrDpcRoutine(
    PKDPC                   Dpc,
    PDEVICE_OBJECT          DeviceObject,
    PDEVICE_EXTENSION       DeviceExtension,
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS
PscrGenericIOCTL(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
PscrCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
PscrSystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS 
PscrDeviceIoControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID
PscrInterruptEvent(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PscrFreeze(
    PSMARTCARD_EXTENSION    SmartcardExtension
    );

NTSTATUS 
PscrCallPcmciaDriver(
    IN PDEVICE_OBJECT AttachedPDO, 
    IN PIRP Irp
    );
#endif  // __PSCR_NT_DRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrnt.c ===
/*++

Copyright (c) 1997  - 1999 SCM Microsystems, Inc.

Module Name:

   PscrNT.c

Abstract:

   Main Driver Module - NT Version

Author:

   Andreas Straub

Revision History:


   Andreas Straub 1.00     8/18/1997      Initial Version
   Klaus Schuetz  1.01     9/20/1997      Timing changed
   Andreas Straub 1.02     9/24/1997      Low Level error handling,
                                    minor bugfixes, clanup
   Andreas Straub 1.03     10/8/1997      Timing changed, generic SCM
                                    interface changed
   Andreas Straub 1.04     10/18/1997     Interrupt handling changed
   Andreas Straub 1.05     10/19/1997     Generic IOCTL's added
   Andreas Straub 1.06     10/25/1997     Timeout limit for FW update variable
   Andreas Straub 1.07     11/7/1997      Version information added
   Klaus Schuetz  1.08     11/10/1997     PnP capabilities added
    Klaus Schuetz                               Cleanup added

--*/

#include <PscrNT.h>
#include <PscrCmd.h>
#include <PscrCB.h>
#include <PscrLog.h>
#include <PscrVers.h>

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, PscrAddDevice)
#pragma alloc_text(PAGEABLE, PscrCreateAndStartDevice)
#pragma alloc_text(PAGEABLE, PscrCreateDevice)
#pragma alloc_text(PAGEABLE, PscrStartDevice)
#pragma alloc_text(PAGEABLE, PscrUnloadDriver)
#pragma alloc_text(PAGEABLE, PscrCreateClose)

BOOLEAN DeviceSlot[PSCR_MAX_DEVICE];

NTSTATUS
DriverEntry(
   PDRIVER_OBJECT DriverObject,
   PUNICODE_STRING   RegistryPath
   )
/*++

DriverEntry:
   entry function of the driver. setup the callbacks for the OS and try to
   initialize a device object for every device in the system

Arguments:
   DriverObject   context of the driver
   RegistryPath   path to the registry entry for the driver

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   ULONG Device;
   
   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!DriverEntry: Enter\n" )
      );

   // tell the system our entry points
   DriverObject->MajorFunction[IRP_MJ_CREATE] =
   DriverObject->MajorFunction[IRP_MJ_CLOSE] = PscrCreateClose;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PscrDeviceIoControl;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PscrSystemControl;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]  = PscrCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]   = PscrPnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PscrPower;
    DriverObject->DriverExtension->AddDevice = PscrAddDevice;
   DriverObject->DriverUnload = PscrUnloadDriver;

   SmartcardDebug(
      DEBUG_TRACE,
      ("PSCR!DriverEntry: Exit %x\n",
        NTStatus)
      );

   return NTStatus;
}

NTSTATUS
PscrAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:
    This function is called by the pnp manager. This is used to create
    a new device instance.

--*/
{
   NTSTATUS status;
   UNICODE_STRING vendorNameU, ifdTypeU;
   ANSI_STRING vendorNameA, ifdTypeA;
   HANDLE regKey = NULL;
   PDEVICE_OBJECT DeviceObject = NULL;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrAddDevice: Enter\n" )
      );

    try {

        ULONG DeviceInstance;
       UNICODE_STRING DriverID;
       PDEVICE_EXTENSION DeviceExtension;
       PREADER_EXTENSION ReaderExtension;
        PSMARTCARD_EXTENSION SmartcardExtension;
      RTL_QUERY_REGISTRY_TABLE parameters[3];

      RtlZeroMemory(parameters, sizeof(parameters));
      RtlZeroMemory(&vendorNameU, sizeof(vendorNameU));
      RtlZeroMemory(&ifdTypeU, sizeof(ifdTypeU));
      RtlZeroMemory(&vendorNameA, sizeof(vendorNameA));
      RtlZeroMemory(&ifdTypeA, sizeof(ifdTypeA));

       for( DeviceInstance = 0; DeviceInstance < PSCR_MAX_DEVICE; DeviceInstance++ )
       {
            if (DeviceSlot[DeviceInstance] == FALSE) {

                DeviceSlot[DeviceInstance] = TRUE;
                break;
            }
       }

        if (DeviceInstance == PSCR_MAX_DEVICE) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

       // Create the device object
       status = IoCreateDevice(
          DriverObject,
          sizeof(DEVICE_EXTENSION),
            NULL,
          FILE_DEVICE_SMARTCARD,
          0,
          TRUE,
          &DeviceObject
          );

        if (status != STATUS_SUCCESS) {

         SmartcardLogError(
            DriverObject,
            PSCR_INSUFFICIENT_RESOURCES,
            NULL,
            0
            );

            leave;
        }

       //   set up the device extension.
       DeviceExtension = DeviceObject->DeviceExtension;
        SmartcardExtension = &DeviceExtension->SmartcardExtension;

       //   initialize the DPC routine
       KeInitializeDpc(
          &DeviceExtension->DpcObject,
          PscrDpcRoutine,
          DeviceObject
          );

        KeInitializeSpinLock(&DeviceExtension->SpinLock);

        // Used for device removal notification
        KeInitializeEvent(
            &DeviceExtension->ReaderRemoved,
            NotificationEvent,
            FALSE
            );

        // Used for stop / start notification
        KeInitializeEvent(
            &DeviceExtension->ReaderStarted,
            NotificationEvent,
            FALSE
            );

       //   allocate the reader extension
       ReaderExtension = ExAllocatePool(
          NonPagedPool,
          sizeof( READER_EXTENSION )
          );

       if( ReaderExtension == NULL ) {
         SmartcardLogError(
            DriverObject,
            PSCR_INSUFFICIENT_RESOURCES,
            NULL,
            0
            );
            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

       RtlZeroMemory( ReaderExtension, sizeof( READER_EXTENSION ));

       SmartcardExtension->ReaderExtension = ReaderExtension;

       //   setup smartcard extension - callback's
       SmartcardExtension->ReaderFunction[RDF_CARD_POWER] = CBCardPower;
       SmartcardExtension->ReaderFunction[RDF_TRANSMIT] = CBTransmit;
       SmartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = CBCardTracking;
       SmartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] = CBSetProtocol;
      SmartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] = PscrGenericIOCTL;

      // setup smartcard extension - vendor attribute
      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         PSCR_VENDOR_NAME,
         sizeof( PSCR_VENDOR_NAME )
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         sizeof( PSCR_VENDOR_NAME );

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         PSCR_IFD_TYPE,
         sizeof( PSCR_IFD_TYPE )
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         sizeof( PSCR_IFD_TYPE );

       SmartcardExtension->VendorAttr.UnitNo =
          DeviceInstance;
       SmartcardExtension->VendorAttr.IfdVersion.BuildNumber = 0;

       //   store firmware revision in ifd version
       SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
          ReaderExtension->FirmwareMajor;
       SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
          ReaderExtension->FirmwareMinor;
       SmartcardExtension->VendorAttr.IfdSerialNo.Length = 0;

       //   setup smartcard extension - reader capabilities
       SmartcardExtension->ReaderCapabilities.SupportedProtocols =
          SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

       SmartcardExtension->ReaderCapabilities.ReaderType =
          SCARD_READER_TYPE_PCMCIA;
       SmartcardExtension->ReaderCapabilities.MechProperties = 0;
       SmartcardExtension->ReaderCapabilities.Channel = 0;

       SmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 4000;
       SmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 4000;

        SmartcardExtension->ReaderCapabilities.DataRate.Default = 10750;
        SmartcardExtension->ReaderCapabilities.DataRate.Max = 10750;

       //   enter correct version of the lib
       SmartcardExtension->Version = SMCLIB_VERSION;
       SmartcardExtension->SmartcardRequest.BufferSize   = MIN_BUFFER_SIZE;
       SmartcardExtension->SmartcardReply.BufferSize  = MIN_BUFFER_SIZE;

        SmartcardExtension->ReaderExtension->ReaderPowerState =
            PowerReaderWorking;

       status = SmartcardInitialize(SmartcardExtension);

        if (status != STATUS_SUCCESS) {

         SmartcardLogError(
            DriverObject,
            PSCR_INSUFFICIENT_RESOURCES,
            NULL,
            0
            );

            leave;
        }

      // tell the lib our device object
      SmartcardExtension->OsData->DeviceObject = DeviceObject;

      DeviceExtension->AttachedPDO = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject
            );

        if (DeviceExtension->AttachedPDO == NULL) {

            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        // register our new device
        status = IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            &SmartCardReaderGuid,
            NULL,
            &DeviceExtension->DeviceName
            );

        ASSERT(status == STATUS_SUCCESS);

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(
         PhysicalDeviceObject,
         PLUGPLAY_REGKEY_DEVICE,
         KEY_READ,
         &regKey
         ) != STATUS_SUCCESS) {

         leave;
      }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(
          RTL_REGISTRY_HANDLE,
          (PWSTR) regKey,
          parameters,
          NULL,
          NULL
          ) != STATUS_SUCCESS) {

         leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &vendorNameA,
         &vendorNameU,
         TRUE
         ) != STATUS_SUCCESS) {

         leave;
      }

      if (RtlUnicodeStringToAnsiString(
         &ifdTypeA,
         &ifdTypeU,
         TRUE
         ) != STATUS_SUCCESS) {

         leave;
      }

      if (vendorNameA.Length == 0 ||
         vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
         ifdTypeA.Length == 0 ||
         ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH) {

         leave;
      }

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.VendorName.Buffer,
         vendorNameA.Buffer,
         vendorNameA.Length
         );
      SmartcardExtension->VendorAttr.VendorName.Length =
         vendorNameA.Length;

      RtlCopyMemory(
         SmartcardExtension->VendorAttr.IfdType.Buffer,
         ifdTypeA.Buffer,
         ifdTypeA.Length
         );
      SmartcardExtension->VendorAttr.IfdType.Length =
         ifdTypeA.Length;
    }
    finally {

      if (vendorNameU.Buffer) {

         RtlFreeUnicodeString(&vendorNameU);
      }

      if (ifdTypeU.Buffer) {

         RtlFreeUnicodeString(&ifdTypeU);
      }

      if (vendorNameA.Buffer) {

         RtlFreeAnsiString(&vendorNameA);
      }

      if (ifdTypeA.Buffer) {

         RtlFreeAnsiString(&ifdTypeA);
      }

      if (regKey != NULL) {

         ZwClose(regKey);
      }

        if (status != STATUS_SUCCESS) {

            PscrUnloadDevice(DeviceObject);
        }

      SmartcardDebug(
         DEBUG_TRACE,
         ( "PSCR!PscrAddDevice: Exit %x\n",
         status)
         );
    }
    return status;
}

NTSTATUS
PscrCallPcmciaDriver(
    IN PDEVICE_OBJECT AttachedPDO,
    IN PIRP Irp
    )
/*++

Routine Description:

   Send an Irp to the pcmcia driver and wait until the pcmcia driver has
   finished the request.

   To make sure that the pcmcia driver will not complete the Irp we first
   initialize an event and set our own completion routine for the Irp.

   When the pcmcia driver has processed the Irp the completion routine will
   set the event and tell the IO manager that more processing is required.

   By waiting for the event we make sure that we continue only if the pcmcia
   driver has processed the Irp completely.

Return Value:

   status returned by the pcmcia driver

--*/
{

   NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    // Copy our stack location to the next.
    IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. the event is passed
   // to our completion routine and will be set if the pcmcia driver is done
   //
    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    // Our IoCompletionRoutine sets only our event
    IoSetCompletionRoutine (
        Irp,
        PscrPcmciaCallComplete,
        &Event,
        TRUE,
        TRUE,
        TRUE
        );

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER) {

        status = PoCallDriver(AttachedPDO, Irp);

    } else {

        // Call the serial driver
        status = IoCallDriver(AttachedPDO, Irp);
    }

   // Wait until the pcmcia driver has processed the Irp
    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(
            &Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        if (status == STATUS_SUCCESS) {

            status = Irp->IoStatus.Status;
        }
    }

    return status;
}

NTSTATUS
PscrPcmciaCallComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:
   Completion routine for an Irp sent to the pcmcia driver. The event will
   be set to notify that the pcmcia driver is done. The routine will not
   'complete' the Irp, so the caller of PscrCallPcmciaDriver can continue.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);

    if (Irp->Cancel) {

        Irp->IoStatus.Status = STATUS_CANCELLED;
    }

    KeSetEvent (Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PscrPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
   driver callback for pnp manager
   All other requests will be passed to the pcmcia driver to ensure correct processing.

--*/
{

   NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION IrpStack;
    PDEVICE_OBJECT AttachedPDO;
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KIRQL irql;
    LARGE_INTEGER timeout;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrPnPDeviceControl: Enter\n" )
      );

    status = SmartcardAcquireRemoveLock(&DeviceExtension->SmartcardExtension);
    ASSERT(status == STATUS_SUCCESS);

    if (status != STATUS_SUCCESS) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    AttachedPDO = DeviceExtension->AttachedPDO;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

    // Now look what the PnP manager wants...
   switch(IrpStack->MinorFunction)
   {
      case IRP_MN_START_DEVICE:

            // Now we should connect to our resources (Irql, Io etc.)
         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_START_DEVICE\n")
                );

            // We have to call the underlying driver first
            status = PscrCallPcmciaDriver(AttachedPDO, Irp);

            if (NT_SUCCESS(status)) {

                status = PscrStartDevice(
                   DeviceObject,
                    &IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]
                    );

                ASSERT(NT_SUCCESS(status));
            }
         break;

        case IRP_MN_QUERY_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n")
                );
            KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);
            if (DeviceExtension->IoCount > 0) {

                // we refuse to stop if we have pending io
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = STATUS_DEVICE_BUSY;

            } else {

                // stop processing requests
                KeClearEvent(&DeviceExtension->ReaderStarted);
                KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);
                status = PscrCallPcmciaDriver(AttachedPDO, Irp);
            }
         break;

        case IRP_MN_CANCEL_STOP_DEVICE:

         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n")
                );

            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
            ASSERT(status == STATUS_SUCCESS);

            // we can continue to process requests
            DeviceExtension->IoCount = 0;
            KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);
         break;

      case IRP_MN_STOP_DEVICE:

            // Stop the device. Aka disconnect from our resources
         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_STOP_DEVICE\n")
                );

            PscrStopDevice(DeviceObject);
            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
         break;

      case IRP_MN_QUERY_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n")
                );

            // disable the reader
            status = IoSetDeviceInterfaceState(
                &DeviceExtension->DeviceName,
                FALSE
                );
            ASSERT(status == STATUS_SUCCESS);

            if (status != STATUS_SUCCESS) {

                break;
            }

            //
            // check if the reader has been opened
            //
            if (DeviceExtension->ReaderOpen) {

                // someone is connected, enable the reader and fail the call
                IoSetDeviceInterfaceState(
                    &DeviceExtension->DeviceName,
                    TRUE
                    );
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            // pass the call to the next driver in the stack
            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
         break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            // Removal of device has been cancelled
         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n")
                );

            status = PscrCallPcmciaDriver(AttachedPDO, Irp);

            if (status == STATUS_SUCCESS) {

                status = IoSetDeviceInterfaceState(
                    &DeviceExtension->DeviceName,
                    TRUE
                    );
            }
         break;

      case IRP_MN_REMOVE_DEVICE:

            // Remove our device
         SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPnPDeviceControl: IRP_MN_REMOVE_DEVICE\n")
                );

            KeSetEvent(&DeviceExtension->ReaderRemoved, 0, FALSE);

            PscrStopDevice(DeviceObject);
            PscrUnloadDevice(DeviceObject);

            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
            deviceRemoved = TRUE;
         break;

      default:
            // This is an Irp that is only useful for underlying drivers
            status = PscrCallPcmciaDriver(AttachedPDO, Irp);
         irpSkipped = TRUE;
         break;
   }

   if (irpSkipped == FALSE) {

      // Don't touch the status field of irps we don't process
      Irp->IoStatus.Status = status;
   }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    if (deviceRemoved == FALSE) {

        SmartcardReleaseRemoveLock(&DeviceExtension->SmartcardExtension);
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrPnPDeviceControl: Exit %x\n",
        status)
      );

    return status;
}

VOID
PscrSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PKEVENT Event,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (MinorFunction);
    UNREFERENCED_PARAMETER (PowerState);
    UNREFERENCED_PARAMETER (IoStatus);

    KeSetEvent(Event, 0, FALSE);
}

NTSTATUS
PscrDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    UCHAR state;

    if(Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    status = CmdResetInterface(SmartcardExtension->ReaderExtension);
    ASSERT(status == STATUS_SUCCESS);

    SmartcardExtension->ReaderExtension->StatusFileSelected = FALSE;
    state = CBGetCardState(SmartcardExtension);

    CBUpdateCardState(SmartcardExtension, state, TRUE);

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLock(SmartcardExtension);

    // inform the power manager of our state.
    PoSetPowerState (
        DeviceObject,
        DevicePowerState,
        irpStack->Parameters.Power.State
        );

    PoStartNextPowerIrp(Irp);

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
PscrPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
    POWER_STATE powerState;
    ACTION action = SkipRequest;
    KEVENT event;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("PSCR!PscrPower: Enter\n")
        );

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Prefix initialization
    //

    powerState.DeviceState = PowerDeviceUnspecified;

    status = SmartcardAcquireRemoveLock(smartcardExtension);
    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {

        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpStack->Parameters.Power.Type == DevicePowerState &&
        irpStack->MinorFunction == IRP_MN_SET_POWER) {

        switch (irpStack->Parameters.Power.State.DeviceState) {

        case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPower: PowerDevice D0\n")
                );

            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                Irp,
                PscrDevicePowerCompletion,
                smartcardExtension,
                TRUE,
                TRUE,
                TRUE
                );

            action = WaitForCompletion;
            break;

        case PowerDeviceD3:
            // Turn off the reader
            SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPower: PowerDevice D3\n")
                );

            PoSetPowerState (
                DeviceObject,
                DevicePowerState,
                irpStack->Parameters.Power.State
                );

            // save the current card state
            smartcardExtension->ReaderExtension->CardPresent =
                smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent) {

                smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                status = CBCardPower(smartcardExtension);
                ASSERT(NT_SUCCESS(status));
            }

            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState =
                PowerReaderOff;

            action = SkipRequest;
         break;

        default:

            action = SkipRequest;
            break;
        }
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // The system wants to change the power state.
        // We need to translate the system power state to
        // a corresponding device power state.
        //

        POWER_STATE_TYPE powerType = DevicePowerState;

        ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
            PowerReaderUnspecified);

        switch(irpStack->MinorFunction) {

      KIRQL irql;

        case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPower: Query Power\n")
                );


            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
                KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                if (deviceExtension->IoCount == 0) {

                    // Block any further ioctls
                    KeClearEvent(&deviceExtension->ReaderStarted);
                } else {

                    // can't go to sleep mode since the reader is busy.
                    status = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                break;
            }
         break;

        case IRP_MN_SET_POWER:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("PSCR!PscrPower: PowerSystem S%d\n",
                irpStack->Parameters.Power.State.SystemState - 1)
                );

            switch (irpStack->Parameters.Power.State.SystemState) {

            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderWorking) {

                    // We're already in the right state
               KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
               action = SkipRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD0;

                // wake up the underlying stack...
                action = MarkPending;
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

                if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderOff) {

                    // We're already in the right state
                    action = SkipRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD3;

                // first, inform the power manager of our new state.
                PoSetPowerState (
                    DeviceObject,
                    SystemPowerState,
                    powerState
                    );

                action = MarkPending;
                break;

            default:

                action = SkipRequest;
                break;
            }
        }
    }

    switch (action) {

        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

        case MarkPending:

         // initialize the event we need in the completion function
         KeInitializeEvent(
            &event,
            NotificationEvent,
            FALSE
            );

         // request the device power irp
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                PscrSystemPowerCompletion,
                &event,
                NULL
                );
            ASSERT(status == STATUS_PENDING);

         if (status == STATUS_PENDING) {

            // wait until the device power irp completed
            status = KeWaitForSingleObject(
               &event,
               Executive,
               KernelMode,
               FALSE,
               NULL
               );

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking) {

               PoSetPowerState (
                  DeviceObject,
                  SystemPowerState,
                  powerState
                  );
            }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);

         } else {

            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
             IoCompleteRequest(Irp, IO_NO_INCREMENT);
         }

         break;

        case SkipRequest:
            SmartcardReleaseRemoveLock(smartcardExtension);
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        case WaitForCompletion:
            status = PoCallDriver(deviceExtension->AttachedPDO, Irp);
         break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("PSCR!PscrPower: Exit %lx\n",
        status)
        );

    return status;
}

NTSTATUS
PscrStartDevice(
   PDEVICE_OBJECT DeviceObject,
    PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor
   )
/*++

Routine Description:
   get the actual configuration from the passed FullResourceDescriptor
   and initializes the reader hardware

Note:
   for an NT 4.00 build the resources must be translated by the HAL

Arguments:
   DeviceObject         context of call
   FullResourceDescriptor  actual configuration of the reader

Return Value:
   STATUS_SUCCESS
   status returned from the HAL (NT 4.00 only )
   status returned by LowLevel routines



--*/
{
   PCM_PARTIAL_RESOURCE_DESCRIPTOR  PartialDescriptor;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension = &DeviceExtension->SmartcardExtension;
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
   ULONG Count;

   SmartcardDebug(
      DEBUG_TRACE,
      ("PSCR!PscrStartDevice: Enter\n")
      );

    // Get the number of resources we need
   Count = FullResourceDescriptor->PartialResourceList.Count;

   PartialDescriptor = FullResourceDescriptor->PartialResourceList.PartialDescriptors;

   // parse all partial descriptors
   while(Count--)
   {
      switch(PartialDescriptor->Type)
      {
         case CmResourceTypePort: {

                //   0 - memory, 1 - IO
                ULONG AddressSpace = 1;
                BOOLEAN Translated;
                PHYSICAL_ADDRESS PhysicalAddress;

                ReaderExtension->IOBase =
                    (PPSCR_REGISTERS) UlongToPtr(PartialDescriptor->u.Port.Start.LowPart);

                ASSERT(PartialDescriptor->u.Port.Length >= 4);

            SmartcardDebug(
                    DEBUG_TRACE,
               ("PSCR!PscrStartDevice: IoBase = %lxh\n",
               ReaderExtension->IOBase)
               );
            break;
            }

         case CmResourceTypeInterrupt: {

            KINTERRUPT_MODE   Mode;
            BOOLEAN  Shared;
            KIRQL Irql;
            KAFFINITY Affinity;
            ULONG Vector;

            Mode = (
               PartialDescriptor->Flags &
               CM_RESOURCE_INTERRUPT_LATCHED ?
               Latched : LevelSensitive
               );

            Shared = (
               PartialDescriptor->ShareDisposition ==
               CmResourceShareShared
               );

            Vector = PartialDescriptor->u.Interrupt.Vector;
                Affinity = PartialDescriptor->u.Interrupt.Affinity;
                Irql = (KIRQL) PartialDescriptor->u.Interrupt.Level;

            // store IRQ to allow query configuration
            ReaderExtension->CurrentIRQ =
               PartialDescriptor->u.Interrupt.Vector;

            SmartcardDebug(
               DEBUG_TRACE,
               ("PSCR!PscrStartDevice: Irql: %d\n",
               PartialDescriptor->u.Interrupt.Level)
               );
            // connect the driver's isr
            status = IoConnectInterrupt(
               &DeviceExtension->InterruptObject,
               PscrIrqServiceRoutine,
               (PVOID) DeviceExtension,
               NULL,
               Vector,
               Irql,
               Irql,
               Mode,
               Shared,
               Affinity,
               FALSE
               );

            break;
         }

            case CmResourceTypeDevicePrivate:
               break;

         default:
                ASSERT(FALSE);
            status = STATUS_UNSUCCESSFUL;
            break;
      }
      PartialDescriptor++;
   }

    try {

        HANDLE handle;
        UCHAR CardState;

       //   IOBase initialized ?
       if( ReaderExtension->IOBase == NULL ) {

         //
         // under NT 4.0 the failure of this fct for the second reader
         // means there is only one device
         //
         SmartcardLogError(
            DeviceObject,
            PSCR_ERROR_IO_PORT,
            NULL,
            0
            );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
       }

       //   irq connected ?
       if( DeviceExtension->InterruptObject == NULL ) {

         SmartcardLogError(
             DeviceObject,
             PSCR_ERROR_INTERRUPT,
             NULL,
             0
             );

          status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
       }

      ReaderExtension->Device    = DEVICE_ICC1;
      ReaderExtension->MaxRetries = PSCR_MAX_RETRIES;
      status = CmdResetInterface( ReaderExtension );

       SmartcardExtension->ReaderCapabilities.MaxIFSD =
          ReaderExtension->MaxIFSD;

        if (status != STATUS_SUCCESS) {

          SmartcardLogError(
             DeviceObject,
             PSCR_CANT_INITIALIZE_READER,
             NULL,
             0
             );

            leave;
        }

         status = CmdReset(
         ReaderExtension,
         0x00,          // reader
         FALSE,            // cold reset
         NULL,          // no atr
         NULL
         );

        if (status != STATUS_SUCCESS) {

          SmartcardLogError(
             DeviceObject,
             PSCR_CANT_INITIALIZE_READER,
             NULL,
             0
             );

            leave;
        }

         PscrFlushInterface(DeviceExtension->SmartcardExtension.ReaderExtension);

      CmdGetFirmwareRevision(
         DeviceExtension->SmartcardExtension.ReaderExtension
         );

        // If you change the min. firmware version here, please update
        // the .mc file for the correct error message, too
        if (SmartcardExtension->ReaderExtension->FirmwareMajor < 2 ||
            SmartcardExtension->ReaderExtension->FirmwareMajor == 2 &&
            SmartcardExtension->ReaderExtension->FirmwareMinor < 0x30) {

          SmartcardLogError(
             DeviceObject,
             PSCR_WRONG_FIRMWARE,
             NULL,
             0
             );
        }

      //
      // make sure the ICC1 status file in the reader file system will
      // be selected
      //
      ReaderExtension->StatusFileSelected = FALSE;
        CardState = CBGetCardState(&DeviceExtension->SmartcardExtension);
        CBUpdateCardState(&DeviceExtension->SmartcardExtension, CardState, FALSE);

        // signal that the reader has been started (again)
        KeSetEvent(&DeviceExtension->ReaderStarted, 0, FALSE);

        status = IoSetDeviceInterfaceState(
            &DeviceExtension->DeviceName,
            TRUE
            );

        if (status == STATUS_OBJECT_NAME_EXISTS) {

            // We tried to re-enable the device which is ok
            // This can happen after a stop - start sequence
            status = STATUS_SUCCESS;
        }
        ASSERT(status == STATUS_SUCCESS);
    }
    finally {

        if (status != STATUS_SUCCESS) {

            PscrStopDevice(DeviceObject);
        }

        SmartcardDebug(
           DEBUG_TRACE,
           ( "PSCR!PscrStartDevice: Exit %x\n",
           status )
           );

    }
    return status;
}

VOID
PscrStopDevice(
   PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
   Diconnect the interrupt used by the device & unmap the IO port

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;
   LARGE_INTEGER delayPeriod;

    if (DeviceObject == NULL) {

        return;
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrStopDevice: Enter\n" )
      );

    DeviceExtension = DeviceObject->DeviceExtension;
    KeClearEvent(&DeviceExtension->ReaderStarted);

   // disconnect the interrupt
   if( DeviceExtension->InterruptObject != NULL )
   {
      IoDisconnectInterrupt(DeviceExtension->InterruptObject);
        DeviceExtension->InterruptObject = NULL;
   }

   // unmap ports
   if(DeviceExtension->UnMapPort)
   {
      MmUnmapIoSpace(
         DeviceExtension->SmartcardExtension.ReaderExtension->IOBase,
         DeviceExtension->SmartcardExtension.ReaderExtension->IOWindow
         );

        DeviceExtension->UnMapPort = FALSE;
   }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrStopDevice: Exit\n" )
      );
}

VOID
PscrUnloadDevice(
   PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
   close connections to smclib.sys and the pcmcia driver, delete symbolic
   link and mark the slot as unused.


Arguments:
   DeviceObject   device to unload

Return Value:
   void

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    NTSTATUS status;

    if (DeviceObject == NULL) {

        return;
    }

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrUnloadDevice: Enter\n" )
      );

    DeviceExtension = DeviceObject->DeviceExtension;

    ASSERT(
        DeviceExtension->SmartcardExtension.VendorAttr.UnitNo <
        PSCR_MAX_DEVICE
        );


    if (DeviceExtension->DeviceName.Buffer != NULL) {

        // disble our device so no one can open it
        IoSetDeviceInterfaceState(
            &DeviceExtension->DeviceName,
            FALSE
            );
    }

    // Mark this slot as available
    DeviceSlot[DeviceExtension->SmartcardExtension.VendorAttr.UnitNo] = FALSE;

   // report to the lib that the device will be unloaded
   if(DeviceExtension->SmartcardExtension.OsData != NULL)
   {
        KIRQL CancelIrql;
        PSMARTCARD_EXTENSION SmartcardExtension =
            &DeviceExtension->SmartcardExtension;

        ASSERT(SmartcardExtension->OsData->NotificationIrp == NULL);

       IoAcquireCancelSpinLock( &CancelIrql );

       if( SmartcardExtension->OsData->NotificationIrp != NULL )
       {
            PIRP notificationIrp;

            notificationIrp = InterlockedExchangePointer(
                &(SmartcardExtension->OsData->NotificationIrp),
                NULL
                );

          IoSetCancelRoutine(
                notificationIrp,
                NULL
                );

            IoReleaseCancelSpinLock( CancelIrql );

           SmartcardDebug(
              DEBUG_TRACE,
              ( "PSCR!PscrUnloadDevice: Completing NotificationIrp %lx\n",
                notificationIrp)
              );

          //   finish the request
          notificationIrp->IoStatus.Status = STATUS_SUCCESS;
          notificationIrp->IoStatus.Information = 0;

          IoCompleteRequest(
                notificationIrp,
                IO_NO_INCREMENT
                );

        } else {

            IoReleaseCancelSpinLock( CancelIrql );
        }

        // Wait until we can safely unload the device
        SmartcardReleaseRemoveLockAndWait(SmartcardExtension);

      SmartcardExit(&DeviceExtension->SmartcardExtension);
   }

   // delete the symbolic link
   if( DeviceExtension->DeviceName.Buffer != NULL )
   {
      RtlFreeUnicodeString(&DeviceExtension->DeviceName);
      DeviceExtension->DeviceName.Buffer = NULL;
   }

    if (DeviceExtension->SmartcardExtension.ReaderExtension != NULL) {

        ExFreePool(DeviceExtension->SmartcardExtension.ReaderExtension);
        DeviceExtension->SmartcardExtension.ReaderExtension = NULL;
    }

    // Detach from the pcmcia driver
    if (DeviceExtension->AttachedPDO) {

        IoDetachDevice(DeviceExtension->AttachedPDO);
        DeviceExtension->AttachedPDO = NULL;
    }

   // delete the device object
   IoDeleteDevice(DeviceObject);

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrUnloadDevice: Exit\n" )
      );
}

VOID
PscrUnloadDriver(
   PDRIVER_OBJECT DriverObject
   )
/*++

PscrUnloadDriver:
   unloads all devices for a given driver object

Arguments:
   DriverObject   context of driver

--*/
{
   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrUnloadDriver\n" )
      );
}

NTSTATUS
PscrCreateClose(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

PscrCreateClose:
   allowes only one open process a time

Arguments:
   DeviceObject   context of device
   Irp            context of call

Return Value:
   STATUS_SUCCESS
   STATUS_DEVICE_BUSY

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

   __try {

      if (irpStack->MajorFunction == IRP_MJ_CREATE) {

         status = SmartcardAcquireRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         if (status != STATUS_SUCCESS) {

            status = STATUS_DEVICE_REMOVED;
            __leave;
         }

         // test if the device has been opened already
         if (InterlockedCompareExchange(
            &deviceExtension->ReaderOpen,
            TRUE,
            FALSE) == FALSE) {

            SmartcardDebug(
               DEBUG_DRIVER,
               ("%s!PscrCreateClose: Open\n",
               DRIVER_NAME)
               );
         } else {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;

            // release the lock
            SmartcardReleaseRemoveLockWithTag(
               &deviceExtension->SmartcardExtension,
               'lCrC'
               );
         }

      } else {

         SmartcardDebug(
            DEBUG_DRIVER,
            ("%s!PscrCreateClose: Close\n",
            DRIVER_NAME)
            );
         SmartcardReleaseRemoveLockWithTag(
            &deviceExtension->SmartcardExtension,
            'lCrC'
            );

         deviceExtension->ReaderOpen = FALSE;
      }
   }
   __finally {

      Irp->IoStatus.Status = status;
      Irp->IoStatus.Information = 0;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
   }

    return status;
}

NTSTATUS
PscrSystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++
PscrSystemControl:
--*/
{
   PDEVICE_EXTENSION DeviceExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(DeviceExtension->AttachedPDO, Irp);
      
   return status;

}

NTSTATUS
PscrDeviceIoControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

PscrDeviceIoControl:

   all IRP's requiring IO are queued to the StartIo routine, other requests
   are served immediately

--*/
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    KIRQL irql;
    LARGE_INTEGER timeout;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    if (deviceExtension->IoCount == 0) {

        KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
        status = KeWaitForSingleObject(
            &deviceExtension->ReaderStarted,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        ASSERT(status == STATUS_SUCCESS);

        KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    }
    ASSERT(deviceExtension->IoCount >= 0);
    deviceExtension->IoCount++;
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    timeout.QuadPart = 0;

    status = KeWaitForSingleObject(
        &deviceExtension->ReaderRemoved,
        Executive,
        KernelMode,
        FALSE,
        &timeout
        );

    if (status == STATUS_SUCCESS) {

        status = STATUS_DEVICE_REMOVED;

    } else {

        status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);
    }

    if (status != STATUS_SUCCESS) {

        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

   status = SmartcardDeviceControl(
      &(deviceExtension->SmartcardExtension),
      Irp
      );

    SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

    KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
    deviceExtension->IoCount--;
    ASSERT(deviceExtension->IoCount >= 0);
    KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

    return status;
}

NTSTATUS
PscrGenericIOCTL(
   PSMARTCARD_EXTENSION SmartcardExtension
   )
/*++

PscrGenericIOCTL:
   Performs generic callbacks to the reader

Arguments:
   SmartcardExtension   context of the call

Return Value:
   STATUS_SUCCESS

--*/
{
   NTSTATUS          NTStatus;
   PIRP              Irp;
   PIO_STACK_LOCATION      IrpStack;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrGenericIOCTL: Enter\n" )
      );

   //
   // get pointer to current IRP stack location
   //
   Irp         = SmartcardExtension->OsData->CurrentIrp;
   IrpStack = IoGetCurrentIrpStackLocation( Irp );
   //
   // assume error
   //
   NTStatus = STATUS_INVALID_DEVICE_REQUEST;
   Irp->IoStatus.Information = 0;
   //
   // dispatch IOCTL
   //
   switch( IrpStack->Parameters.DeviceIoControl.IoControlCode )
   {
      case IOCTL_PSCR_COMMAND:

         NTStatus = CmdPscrCommand(
            SmartcardExtension->ReaderExtension,
            (PUCHAR)Irp->AssociatedIrp.SystemBuffer,
            IrpStack->Parameters.DeviceIoControl.InputBufferLength,
            (PUCHAR)Irp->AssociatedIrp.SystemBuffer,
            IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
            (PULONG) &Irp->IoStatus.Information
            );
         //
         // the command could change the active file in the reader file
         // system, so make sure that the status file will be selected
         // before the next read
         //
         SmartcardExtension->ReaderExtension->StatusFileSelected = FALSE;
         break;

      case IOCTL_GET_VERSIONS:

         if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            SIZEOF_VERSION_CONTROL )
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         else
         {
            PVERSION_CONTROL  VersionControl;

            VersionControl = (PVERSION_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            VersionControl->SmclibVersion = SmartcardExtension->Version;
            VersionControl->DriverMajor      = PSCR_MAJOR_VERSION;
            VersionControl->DriverMinor      = PSCR_MINOR_VERSION;

            // update firmware version (changed after update)
            CmdGetFirmwareRevision(
               SmartcardExtension->ReaderExtension
               );
            VersionControl->FirmwareMajor =
               SmartcardExtension->ReaderExtension->FirmwareMajor;

            VersionControl->FirmwareMinor =
               SmartcardExtension->ReaderExtension->FirmwareMinor;

            VersionControl->UpdateKey =
               SmartcardExtension->ReaderExtension->UpdateKey;

            Irp->IoStatus.Information = SIZEOF_VERSION_CONTROL;
            NTStatus = STATUS_SUCCESS;
         }
         break;

      case IOCTL_SET_TIMEOUT:
         {
            ULONG NewLimit;
            //
            // get new timeout limit
            //
            if ( IrpStack->Parameters.DeviceIoControl.InputBufferLength ==
               sizeof( ULONG ))
            {
               NewLimit = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
            }
            else
            {
               NewLimit = 0;
            }
            //
            // report actual timeout limit
            //
            if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength ==
               sizeof( ULONG ))
            {
               *(PULONG)Irp->AssociatedIrp.SystemBuffer =
                  SmartcardExtension->ReaderExtension->MaxRetries * DELAY_PSCR_WAIT;
               Irp->IoStatus.Information = sizeof( ULONG );
            }
            //
            // set new timeout limit
            //
            if( NewLimit != 0 )
            {
               SmartcardExtension->ReaderExtension->MaxRetries =
                  (NewLimit + DELAY_PSCR_WAIT - 1) / DELAY_PSCR_WAIT;
            }
         }
         NTStatus = STATUS_SUCCESS;
         break;

      case IOCTL_GET_CONFIGURATION:
         //
         // return IOBase and IRQ
         //
         if( IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
            SIZEOF_PSCR_CONFIGURATION )
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         else
         {
            PPSCR_CONFIGURATION  PSCRConfiguration;

            PSCRConfiguration =
               (PPSCR_CONFIGURATION)Irp->AssociatedIrp.SystemBuffer;
            PSCRConfiguration->IOBase =
               SmartcardExtension->ReaderExtension->IOBase;
            PSCRConfiguration->IRQ =
               SmartcardExtension->ReaderExtension->CurrentIRQ;

            Irp->IoStatus.Information = SIZEOF_PSCR_CONFIGURATION;
            NTStatus = STATUS_SUCCESS;
         }
         break;

      default:
         break;
   }
   //
   // set status of the packet
   //
   Irp->IoStatus.Status = NTStatus;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrGenericIOCTL: Exit\n" )
      );

   return( NTStatus );
}

BOOLEAN
PscrIrqServiceRoutine(
    PKINTERRUPT         Interrupt,
   PDEVICE_EXTENSION DeviceExtension
   )
/*++

PscrIrqServiceRoutine:
   because the device not supports shared interrupts, the call is passed
   to the DPC routine immediately and the IRQ is reported as served

Arguments:
    Interrupt        interrupt object related to the interrupt
   DeviceExtension      context of call

Return Value:
   STATUS_SUCCESS

--*/
{
   SmartcardDebug(
      DEBUG_TRACE,
      ("PSCR!PscrIrqServiceRoutine: Enter\n")
      );
   //
    // When someone yanks out the card the interrupt handler gets called,
    // but since there is no card anymore when don't need to schedule a DPC
    //

   //
   // the interrupt is caused by a freeze event. the interface will be
   // cleared either by PscrRead() or the DPC routine (depending on
   // which is called first)
   //
   DeviceExtension->SmartcardExtension.ReaderExtension->FreezePending = TRUE;

    InterlockedIncrement(&DeviceExtension->PendingInterrupts);

   KeInsertQueueDpc(
      &DeviceExtension->DpcObject,
      DeviceExtension,
      &DeviceExtension->SmartcardExtension
      );

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrIrqServiceRoutine: Exit\n" )
      );

   return TRUE;
}

VOID
PscrDpcRoutine(
   PKDPC             Dpc,
   PDEVICE_OBJECT       DeviceObject,
   PDEVICE_EXTENSION    DeviceExtension,
   PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

PscrDpcRoutine:
   finishes interrupt requests. the freeze event data of the reader will be read
   & the card state will be updated if data valid

Arguments:
   Dpc               dpc object related to the call
   DeviceObject      context of the device
   DeviceExtension      passed as system argument 1
   SmartcardExtension   passed as system argument 2

Return Value:
   void

--*/
{
   NTSTATUS status = STATUS_SUCCESS;
    UCHAR Event;

   SmartcardDebug(
      DEBUG_TRACE,
      ( "PSCR!PscrInterruptEvent: IoBase %xh\n",
      SmartcardExtension->ReaderExtension->IOBase)
      );

   //
   // In case of a card change the reader provides a TLV packet describing
   // the event ('freeze event'). If PscrRead was called before the DPC
   // routine is called, this event was cleared; in this case the card state
   // will be updated by reading the card status file
   //

   if( DeviceExtension->IoCount > 0 ) {

      SmartcardExtension->ReaderExtension->RequestCancelled = TRUE;
   }

    do {

        ASSERT(DeviceExtension->PendingInterrupts < 10);

       SmartcardDebug(
          DEBUG_TRACE,
          ( "PSCR!PscrInterruptEvent: PendingInterrupts = %ld\n",
          DeviceExtension->PendingInterrupts)
          );

        PscrFreeze( SmartcardExtension );

    } while (InterlockedDecrement(&DeviceExtension->PendingInterrupts) > 0);
}

void
PscrFreeze(
   PSMARTCARD_EXTENSION SmartcardExtension
   )

/*++
PscrFreeze:
   Read & evaluate freeze data

Arguments:
   ReaderExtension   context of call
   pDevice        device which causes the freeze event

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL

--*/
{
   NTSTATUS NTStatus = STATUS_UNSUCCESSFUL;
   PREADER_EXTENSION ReaderExtension;
   PPSCR_REGISTERS   IOBase;
   UCHAR TLVList[9], CardState;
   ULONG NBytes;
   ULONG Idx, Retries, Status;
   UCHAR ReadFreeze[] = { 0x12, 0x00, 0x05, 0x00, 0xB0, 0x00, 0x00, 0x01, 0xA6 };

   ReaderExtension   = SmartcardExtension->ReaderExtension;
   IOBase = ReaderExtension->IOBase;

   ReaderExtension->RequestCancelled = FALSE;

    for (Retries = 0; Retries < 5; Retries++) {

      Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );

      ReaderExtension->InvalidStatus = TRUE;
      if(!( Status & PSCR_DATA_AVAIL_BIT ))
      {
         PscrWriteDirect(
            ReaderExtension,
            ReadFreeze,
            sizeof( ReadFreeze ),
            &NBytes
            );

            SysDelay(15);
      }

      NTStatus = PscrRead(
         ReaderExtension,
         (PUCHAR) TLVList,
         sizeof( TLVList ),
         &NBytes
         );
      ReaderExtension->InvalidStatus = FALSE;

      if( NT_SUCCESS( NTStatus ) && ( NBytes == 9 ))
      {
         // get result
         if( ( TLVList[ PSCR_NAD ] == 0x21 ) &&
            ( TLVList[ PSCR_INF ] == TAG_FREEZE_EVENTS ))
         {
                CardState =
                    (TLVList[PSCR_INF + 2] == DEVICE_ICC1 ? PSCR_ICC_PRESENT : PSCR_ICC_ABSENT);

               SmartcardDebug(
                  DEBUG_TRACE,
                  ( "PSCR!PscrFreeze: CardState = %d\n",
                  CardState)
                  );

               CBUpdateCardState(SmartcardExtension, CardState, FALSE);
         }
      }
   }
}

NTSTATUS
PscrCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("PSCR!PscrCancel: Enter\n")
        );

    ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

    smartcardExtension->OsData->NotificationIrp = NULL;

   Irp->IoStatus.Information = 0;
   Irp->IoStatus.Status = STATUS_CANCELLED;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

   SmartcardDebug(
      DEBUG_DRIVER,
      ("PSCR!PscrCancel: Completing wait for Irp = %lx\n",
        Irp)
      );

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT
      );

    SmartcardDebug(
        DEBUG_TRACE,
        ("PSCR!PscrCancel: Exit\n")
        );

    return STATUS_CANCELLED;
}

NTSTATUS
PscrCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread terminates

Arguments:

    DeviceObject  - Pointer to device object for this miniport
    Irp        - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!PscrCleanup: Enter\n",
        DRIVER_NAME)
        );

    IoAcquireCancelSpinLock(&(Irp->CancelIrql));

    if (smartcardExtension->OsData->NotificationIrp) {

        // We need to complete the notification irp
      IoSetCancelRoutine(
            smartcardExtension->OsData->NotificationIrp,
            NULL
            );

        PscrCancel(
            DeviceObject,
            smartcardExtension->OsData->NotificationIrp
            );
    } else {

        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!PscrCleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
      );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT
      );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!PscrCleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}

void
SysDelay(
   ULONG Timeout
   )
/*++

SysDelay:
   performs a required delay. The usage of KeStallExecutionProcessor is
   very nasty, but it happends only if SysDelay is called in the context of
   our DPC routine (which is only called if a card change was detected).

   For 'normal' IO we have Irql < DISPATCH_LEVEL, so if the reader is polled
   while waiting for response we will not block the entire system

Arguments:
   Timeout     delay in milli seconds

Return Value:
   void

--*/
{
   LARGE_INTEGER  SysTimeout;

   if( KeGetCurrentIrql() >= DISPATCH_LEVEL )
   {
      ULONG Cnt = 20 * Timeout;

      while( Cnt-- )
      {
         // KeStallExecutionProcessor: counted in us
         KeStallExecutionProcessor( 50 );
      }
   }
   else
   {
      SysTimeout.QuadPart = (LONGLONG)-10 * 1000 * Timeout;

      // KeDelayExecutionThread: counted in 100 ns
      KeDelayExecutionThread( KernelMode, FALSE, &SysTimeout );
   }
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrcmd.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCmd.c

Abstract:

   Basic command functions for SCM PSCR smartcard reader

Author:

   Andreas Straub

Environment:


   Win 95      Sys... calls are resolved by Pscr95Wrap.asm functions and
            Pscr95Wrap.h macros, resp.

   NT 4.0      Sys... functions resolved by PscrNTWrap.c functions and
            PscrNTWrap.h macros, resp.

Revision History:

   Andreas Straub       8/18/1997   1.00  Initial Version
   Andreas Straub       9/24/1997   1.02  delay for read/write removed

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else // SMCLIB_VXD

#include <PscrNT.h>

#endif   // SMCLIB_VXD

#include <PscrRdWr.h>
#include <PscrCmd.h>

NTSTATUS
CmdResetInterface(
   PREADER_EXTENSION ReaderExtension
   )
/*++
CmdResetInterface:

   Performs a reset of the reader interface (NOT of the PCMCIA controller)
   - flush available data
   - set RESET bit
   - perform a buffer size exchange between reader & host
   - enables interrupts for freeze events
   - disables default PTS

Arguments:
   ReaderExtension   context of call

Return Value:
   STATUS_SUCCESS
   STATUS_IO_DEVICE_ERROR

--*/
{

   NTSTATUS    NTStatus = STATUS_SUCCESS;
   ULONG       IOBytes;
   UCHAR       Len,
               Tag,
               Cnt,
               InData[ TLV_BUFFER_SIZE ];
   PPSCR_REGISTERS   IOBase;
   UCHAR       EnableInterrupts[]   = { 0x28, 0x01, 0x01 };


   IOBase = ReaderExtension->IOBase;

   // discard any data
   PscrFlushInterface( ReaderExtension );

   // reset reader
   WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_RESET_BIT );
   SysDelay( DELAY_WRITE_PSCR_REG );
   WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );

   NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT );

   // read & check vendor string
   if( NT_SUCCESS( NTStatus ))
   {

      WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
      SysDelay( DELAY_WRITE_PSCR_REG );
      //
      // get actual len from TLV list
      //
      READ_PORT_UCHAR( &IOBase->SizeMSReg );
      READ_PORT_UCHAR( &IOBase->SizeLSReg );

      Tag = READ_PORT_UCHAR( &IOBase->DataReg );
      Len = READ_PORT_UCHAR( &IOBase->DataReg );
      //
      // avoid overwrite of buffer
      //
      if( Len > TLV_BUFFER_SIZE )
      {
         Len = TLV_BUFFER_SIZE;
      }
      for ( Cnt = 0; Cnt < Len; Cnt++ )
      {
         InData[ Cnt ] = READ_PORT_UCHAR( &IOBase->DataReg );
      }
      WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
      //
      // check vendor string
      //
      if( SysCompareMemory(
                  InData,
                  PSCR_ID_STRING,
                  sizeof( PSCR_ID_STRING )
                  ))
      {
         NTStatus = STATUS_IO_DEVICE_ERROR;
      }
      else
      {
         //
         // vendor string was correct, check buffer size
         //
         WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_SIZE_READ_BIT );
         NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT );
         //
         // reader ready to transfer interface buffer size
         //
         if( NT_SUCCESS( NTStatus ))
         {
            //
            // set size read & host control
            //
            WRITE_PORT_UCHAR(
               &IOBase->CmdStatusReg,
               PSCR_SIZE_READ_BIT | PSCR_HOST_CONTROL_BIT
               );

            SysDelay( DELAY_WRITE_PSCR_REG );
            //
            // read buffer length
            //
            Len = READ_PORT_UCHAR( &IOBase->SizeMSReg );
            Len = READ_PORT_UCHAR( &IOBase->SizeLSReg );
            for ( Cnt = 0; Cnt < Len; Cnt++ )
            {
               InData[ Cnt ] = READ_PORT_UCHAR( &IOBase->DataReg );
            }
            //
            // transfer of interface buffer size okay
            //
            WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
            SysDelay( DELAY_WRITE_PSCR_REG );
            //
            // notify the reader about the supported buffer size
            //
            WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
            SysDelay( DELAY_WRITE_PSCR_REG );

            WRITE_PORT_UCHAR( &IOBase->SizeMSReg, 0 );
            WRITE_PORT_UCHAR( &IOBase->SizeLSReg, 2 );
            //
            // Write the same data buffer size as the one we just got.
            //
            WRITE_PORT_UCHAR( &IOBase->DataReg, InData[ 0 ] );
            WRITE_PORT_UCHAR( &IOBase->DataReg, InData[ 1 ] );
            //
            // store the size to report to the lib
            //  The maximum buffer size of the reader is to betrieved with
                //  ((ULONG)InData[ 1 ] << 8) | InData[ 0 ]
                //
            ReaderExtension->MaxIFSD = 254;

            //
            // let the reader process the size write command
            //
            WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_SIZE_WRITE_BIT );
            NTStatus = PscrWait( ReaderExtension, PSCR_FREE_BIT );
         }
      }
   }
   //
   // clean up any host control settings
   //
   WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
   //
   // enable interrupts
   //
   CmdSetInterfaceParameter(
      ReaderExtension,
      ReaderExtension->Device,
      EnableInterrupts,
      sizeof( EnableInterrupts )
      );

   return ( NTStatus );
}

NTSTATUS
CmdReset(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device,
   BOOLEAN           WarmReset,
   PUCHAR            pATR,
   PULONG            pATRLength
   )
/*++
CmdReset:
   performs a reset of the reader / ICC

Arguments:
   ReaderExtension      context of call
   Device            device requested ( ICC_1, ICC_2, PSCR )
   WarmReset         kind of ICC reset
   pATR           ptr to ATR buffer, NULL if no ATR required
   pATRLength        size of ATR buffer / length of ATR

Return Value:
   STATUS_SUCCESS
   STATUS_NO_MEDIA
   STATUS_UNRECOGNIZED_MEDIA
   error values from PscrRead / PscrWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    IOData[ MAX_T1_BLOCK_SIZE ],
            P2;
   USHORT      ICCStatus;
   ULONG    IOBytes;

   // ATR from the smartcard requestet? P2 = 1
   P2 = 0;
   if(( pATR != NULL ) && ( pATRLength != NULL ))
   {
      if( *pATRLength > 0 )
         P2 = 0x01;
   }

   // build the RESET command.
   IOData[ PSCR_NAD ] = NAD_TO_PSCR;
   IOData[ PSCR_PCB ] = PCB_DEFAULT;
   IOData[ PSCR_LEN ] = 0x05;

   if( WarmReset == TRUE )
   {
      IOData[ PSCR_INF+0 ] = CLA_WARM_RESET;
      IOData[ PSCR_INF+1 ] = INS_WARM_RESET;
   }
   else
   {
      IOData[ PSCR_INF+0 ] = CLA_RESET;
      IOData[ PSCR_INF+1 ] = INS_RESET;
   }
   IOData[ PSCR_INF+2 ] = Device;
   IOData[ PSCR_INF+3 ] = P2;
   IOData[ PSCR_INF+4 ] = 0x00;

   // write command
   NTStatus = PscrWrite(
      ReaderExtension,
      IOData,
      8,
      &IOBytes
      );

   if( NT_SUCCESS( NTStatus ))
   {
      // read data
      IOBytes = 0;
      NTStatus = PscrRead(
         ReaderExtension,
         IOData,
         MAX_T1_BLOCK_SIZE,
         &IOBytes
         );

      // error detection
      if( NT_SUCCESS( NTStatus ))
      {
         //
         // the location of the error code in the buffer
         // is: ( data ) - STATUS_MSB - STATUS_LSB - EPILOGUE
         //
         ICCStatus = (( USHORT )IOData[ IOBytes-PSCR_EPILOGUE_LENGTH-2 ]) << 8;
         ICCStatus |= ( USHORT )IOData[ IOBytes-PSCR_EPILOGUE_LENGTH-1 ];

         switch( ICCStatus )
         {
            case PSCR_SW_SYNC_ATR_SUCCESS:
            case PSCR_SW_ASYNC_ATR_SUCCESS:
               break;

            case PSCR_SW_NO_ICC:
               NTStatus = STATUS_NO_MEDIA;
               break;

            case PSCR_SW_NO_PROTOCOL:
            case PSCR_SW_NO_ATR:
            case PSCR_SW_NO_ATR_OR_PROTOCOL:
            case PSCR_SW_NO_ATR_OR_PROTOCOL2:
            case PSCR_SW_ICC_NOT_ACTIVE:
            case PSCR_SW_NON_SUPPORTED_PROTOCOL:
            case PSCR_SW_PROTOCOL_ERROR:
            default:
               NTStatus = STATUS_UNRECOGNIZED_MEDIA;
         }
         //
         // copy ATR if required
         //
         if( NT_SUCCESS( NTStatus ))
         {
            if( P2 == 0x01 )
            {
               IOBytes -= PSCR_PROLOGUE_LENGTH + PSCR_EPILOGUE_LENGTH;
               if( IOBytes > *pATRLength )
               {
                  IOBytes = *pATRLength;
               }
               SysCopyMemory(
                  pATR,
                  &IOData[ PSCR_PROLOGUE_LENGTH ],
                  IOBytes
                  );
               *pATRLength = IOBytes;
            }
         }
      }
   }
   return( NTStatus );
}


NTSTATUS
CmdDeactivate(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device
   )
/*++
CmdDeactivate:
   Deactivates the requested device

Arguments:
   ReaderExtension      context of call
   Device            requested device

Return Value:
   STATUS_SUCCESS
   error values from PscrRead / PscrWrite

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   UCHAR    IOData[  MAX_T1_BLOCK_SIZE ];
   ULONG    IOBytes;

   //
   // build the DEACTIVATE command.
   //
   IOData[ PSCR_NAD ] = NAD_TO_PSCR;
   IOData[ PSCR_PCB ] = PCB_DEFAULT;
   IOData[ PSCR_LEN ] = 0x05;

   IOData[ PSCR_INF+0 ] = CLA_DEACTIVATE;
   IOData[ PSCR_INF+1 ] = INS_DEACTIVATE;
   IOData[ PSCR_INF+2 ] = Device;
   IOData[ PSCR_INF+3 ] = 0x00;
   IOData[ PSCR_INF+4 ] = 0x00;
   //
   // write command
   //
   NTStatus = PscrWrite(
      ReaderExtension,
      IOData,
      8,
      &IOBytes
      );

   if( NT_SUCCESS( NTStatus ))
   {
      //
      // read data to trap communication errors
      //
      IOBytes = 0;
      NTStatus = PscrRead(
         ReaderExtension,
         IOData,
         MAX_T1_BLOCK_SIZE,
         &IOBytes
         );
   }
   return( NTStatus );
}

NTSTATUS
CmdReadBinary(
   PREADER_EXTENSION ReaderExtension,
   USHORT            Offset,
   PUCHAR            pBuffer,
   PULONG            pBufferLength
   )
/*++
CmdReadBinary:
   read binary data from an PSCR data file

Arguments:
   ReaderExtension      context of call
   Offset            offset in file
   pBuffer           ptr to data buffer
   pBufferLength     length of buffer / number of bytes read

Return Value:

   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
   USHORT      ICCStatus;
   ULONG    IOBytes;
   //
   // check parameters
   //
   if(( pBuffer == NULL ) || ( pBufferLength == NULL))
   {
      NTStatus = STATUS_INVALID_PARAMETER;
   }
   else
   {
      //
      // build the READ BINARY command
      //
      IOData[ PSCR_NAD] = NAD_TO_PSCR;
      IOData[ PSCR_PCB] = PCB_DEFAULT;
      IOData[ PSCR_LEN] = 0x05;

      IOData[ PSCR_INF+0 ] = CLA_READ_BINARY;
      IOData[ PSCR_INF+1 ] = INS_READ_BINARY;
      IOData[ PSCR_INF+2 ] = HIBYTE( Offset );
      IOData[ PSCR_INF+3 ] = LOBYTE( Offset );
      IOData[ PSCR_INF+4 ] = 0x00;
      //
      // write command
      //
      NTStatus = PscrWrite(
         ReaderExtension,
         IOData,
         8,
         &IOBytes
         );

      if( NT_SUCCESS( NTStatus ))
      {
         //
         // read data
         //
         IOBytes = 0;
         NTStatus = PscrRead(
            ReaderExtension,
            IOData,
            MAX_T1_BLOCK_SIZE,
            &IOBytes
            );

         if( NT_SUCCESS( NTStatus ))
         {
            //
            // error check
            //
            ICCStatus =
               ((USHORT)IOData[ IOBytes-2-PSCR_EPILOGUE_LENGTH ]) << 8;
            ICCStatus |=
               (USHORT)IOData[ IOBytes-1-PSCR_EPILOGUE_LENGTH ];

            switch( ICCStatus )
            {
               case PSCR_SW_FILE_NO_ACCEPPTED_AUTH:
               case PSCR_SW_FILE_NO_ACCESS:
               case PSCR_SW_FILE_BAD_OFFSET:
               case PSCR_SW_END_OF_FILE_READ:
                  NTStatus = STATUS_UNSUCCESSFUL;
                  break;
               default:
                  break;
            }
            //
            // copy data
            //
            if( NT_SUCCESS( NTStatus ))
            {
               if( *pBufferLength <
                  IOBytes-PSCR_PROLOGUE_LENGTH-PSCR_STATUS_LENGTH )
               {
                  NTStatus = STATUS_BUFFER_TOO_SMALL;
               }
               else
               {
                  ( *pBufferLength ) =
                     IOBytes-PSCR_PROLOGUE_LENGTH-PSCR_STATUS_LENGTH;
                  SysCopyMemory(
                     pBuffer,
                     &IOData[ PSCR_PROLOGUE_LENGTH ],
                     *pBufferLength
                     );
               }
            }
         }
      }
   }
   return( NTStatus );
}

NTSTATUS
CmdSelectFile(
   PREADER_EXTENSION ReaderExtension,
   USHORT            FileId
   )
/*++
CmdSelectFile:
   selects a file/directoy of the reader

Arguments:
   ReaderExtension      context of call
   FileId            ID of file

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   error values from PscrRead / PscrWrite
--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
   USHORT      ICCStatus;
   ULONG    IOBytes;

   //
   // build the SELECT FILE command
   //
   IOData[ PSCR_NAD ] = NAD_TO_PSCR;
   IOData[ PSCR_PCB ] = PCB_DEFAULT;
   IOData[ PSCR_LEN ] = 0x07;

   IOData[ PSCR_INF+0 ] = CLA_SELECT_FILE;
   IOData[ PSCR_INF+1 ] = INS_SELECT_FILE;
   IOData[ PSCR_INF+2 ] = 0x00;
   IOData[ PSCR_INF+3 ] = 0x00;
   IOData[ PSCR_INF+4 ] = 0x02;
   IOData[ PSCR_INF+5 ] = HIBYTE( FileId );
   IOData[ PSCR_INF+6 ] = LOBYTE( FileId );
   //
   // write command
   //
   NTStatus = PscrWrite(
      ReaderExtension,
      IOData,
      10,
      &IOBytes
      );

   if( NT_SUCCESS( NTStatus ))
   {
      //
      // get the response of the reader
      //
      IOBytes = 0;
      NTStatus = PscrRead(
         ReaderExtension,
         IOData,
         MAX_T1_BLOCK_SIZE,
         &IOBytes
         );

      if( NT_SUCCESS( NTStatus ))
      {
         //
         // check errors
         //
         ICCStatus =
            ((USHORT)IOData[ IOBytes-2-PSCR_EPILOGUE_LENGTH ]) << 8;
         ICCStatus |=
            (USHORT)IOData[ IOBytes-1-PSCR_EPILOGUE_LENGTH ];

         if( ICCStatus == PSCR_SW_FILE_NOT_FOUND )
         {
            NTStatus = STATUS_UNSUCCESSFUL;
         }
      }
   }
   return( NTStatus );
}

NTSTATUS
CmdSetInterfaceParameter(
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device,
   PUCHAR            pTLVList,
   UCHAR          TLVListLen
   )
/*++
CmdSetInterfaceParameter:
   Sets the interface pareameter of the ICC interface to the values specified
   in the TLV list

Arguments:
   ReaderExtension      context of call
   Device            device
   pTLVList       ptr to list of tag-len-value's specified by caller
   TLVListLen        length of list

Return Value:
   STATUS_SUCCESS
   STATUS_INVALID_PARAMETER
   STATUS_INVALID_DEVICE_STATE
   error values from PscrRead / PscrWrite

--*/
{
    NTSTATUS   NTStatus = STATUS_SUCCESS;
    UCHAR      IOData[ MAX_T1_BLOCK_SIZE ];
   USHORT      ICCStatus;
   ULONG    IOBytes;

   //
   // check parameter
   //
   if( pTLVList == NULL )
   {
      NTStatus = STATUS_INVALID_PARAMETER;
   }
   else
   {
      //
      // build the SET INTERFACE PARAMETER command
      //
      IOData[ PSCR_NAD ] = NAD_TO_PSCR;
      IOData[ PSCR_PCB ] = PCB_DEFAULT;
      IOData[ PSCR_LEN ] = 0x05 + TLVListLen;

      IOData[ PSCR_INF+0 ] = CLA_SET_INTERFACE_PARAM;
      IOData[ PSCR_INF+1 ] = INS_SET_INTERFACE_PARAM;
      IOData[ PSCR_INF+2 ] = Device;
      IOData[ PSCR_INF+3 ] = 0x00;
      IOData[ PSCR_INF+4 ] = TLVListLen;

      SysCopyMemory( &IOData[ PSCR_INF+5 ], pTLVList, TLVListLen );
      //
      // write command
      //
      NTStatus = PscrWrite(
         ReaderExtension,
         IOData,
         8 + TLVListLen,
         &IOBytes
         );

      if( NT_SUCCESS( NTStatus ))
      {

         // do an dummy read to catch errors.
         IOBytes = 0;
         NTStatus = PscrRead(
            ReaderExtension,
            IOData,
            MAX_T1_BLOCK_SIZE,
            &IOBytes
            );

         if( NT_SUCCESS( NTStatus ))
         {

            // check error
            ICCStatus =
               ((USHORT)IOData[ IOBytes - 2 - PSCR_EPILOGUE_LENGTH ]) << 8;
            ICCStatus |=
               (USHORT)IOData[ IOBytes - 1 - PSCR_EPILOGUE_LENGTH ];

            if( ICCStatus != 0x9000 )
            {
               NTStatus = STATUS_INVALID_DEVICE_STATE;
            }
         }
      }
   }
   return( NTStatus );
}


NTSTATUS
CmdReadStatusFile (
   PREADER_EXTENSION ReaderExtension,
   UCHAR          Device,
   PUCHAR            pTLVList,
   PULONG            pTLVListLen
   )
/*++
CmdReadStatusFile:
   read the status file of the requested device from the reader filesystem

Arguments:
   ReaderExtension      context of call
   Device            requested device
   pTLVList       ptr to list (i.e. the status file)
   pTLVListLen       length of buffer / returned list

Return Value:
   STATUS_SUCCESS
   STATUS_BUFFER_TOO_SMALL
   error values from PscrRead / PscrWrite

--*/
{
   NTSTATUS       NTStatus = STATUS_UNSUCCESSFUL;
   UCHAR          IOData[ MAX_T1_BLOCK_SIZE ];
   ULONG          IOBytes;

   // select ICC status file if it's not the active file
   if( ReaderExtension->StatusFileSelected == FALSE )
   {

      // select master file on reader
      NTStatus = CmdSelectFile( ReaderExtension, FILE_MASTER );

      // select ICC directory
      if( NT_SUCCESS( NTStatus ))
      {
         if( Device != DEVICE_ICC1 )
         {
            NTStatus = STATUS_UNSUCCESSFUL;
         }
         else
         {
            NTStatus = CmdSelectFile(
               ReaderExtension,
               FILE_ICC1_DIR
               );

            // select status file
            if( NT_SUCCESS( NTStatus ))
            {
               NTStatus = CmdSelectFile(
                  ReaderExtension,
                  FILE_ICC1_DIR_STATUS
                  );
               if( NT_SUCCESS( NTStatus ))
               {
                  ReaderExtension->StatusFileSelected = TRUE;
               }
            }
         }
      }
   }

   // read status file if successful selected
   if( ReaderExtension->StatusFileSelected == TRUE )
   {
      IOBytes = MAX_T1_BLOCK_SIZE;
      NTStatus = CmdReadBinary(
         ReaderExtension,
         0,
         IOData,
         &IOBytes
         );

      // copy data to user buffer
      if( NT_SUCCESS( NTStatus ))
      {
         if(( pTLVList != NULL ) && ( IOBytes < *pTLVListLen ))
         {
            *pTLVListLen = IOBytes;
            SysCopyMemory( pTLVList, IOData, IOBytes );
         }
         else
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
      }
   }
   return( NTStatus );
}


NTSTATUS
CmdGetFirmwareRevision (
   PREADER_EXTENSION ReaderExtension
   )
/*++
CmdGetFirmwareRevision:
   get the firmware revision of the reader. Ther firmware revision is found
   in the PSCR configuration file (ID 0x0020) in the master directory.
   The tag of the revision is 0x0F, and the value is coded as an ASCII string,
   p.E. "2.20"

Arguments:
   ReaderExtension      context of call

Return Value:
   STATUS_SUCCESS
   error values from PscrRead / PscrWrite

--*/
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          TLVList[ MAX_T1_BLOCK_SIZE ],
                  Len;
   char           Revision[ 0x10 ],
                  UpdateKey[ 0x10 ];
   ULONG          IOBytes;
   //
   // select master file on reader
   //
   NTStatus = CmdSelectFile( ReaderExtension, FILE_MASTER );
   //
   // select pscr configuration file
   //
   if( NT_SUCCESS( NTStatus ))
   {
      NTStatus = CmdSelectFile( ReaderExtension, FILE_PSCR_CONFIG );
      //
      // read confiuration file
      //
      if( NT_SUCCESS( NTStatus ))
      {
         IOBytes = MAX_T1_BLOCK_SIZE;
         NTStatus = CmdReadBinary(
            ReaderExtension,
            0,
            TLVList,
            &IOBytes
            );
         //
         // get the value of revison
         //
         if( NT_SUCCESS( NTStatus ))
         {
            CmdGetTagValue(
               TAG_SOFTWARE_REV,
               TLVList,
               IOBytes,
               &Len,
               Revision
               );
            //
            // the coding is always X.YY (in ASCII), so we can get the numeric
            // values hardcoded by taking the low nibbles of the char's.
            //
            ReaderExtension->FirmwareMajor =   Revision[0] & 0x0F;
            ReaderExtension->FirmwareMinor = ( Revision[2] & 0x0F ) << 4;
            ReaderExtension->FirmwareMinor |=  Revision[3] & 0x0F;
            //
            // get value of update key
            //
            CmdGetTagValue(
               TAG_UPDATE_KEY,
               TLVList,
               IOBytes,
               &Len,
               UpdateKey
               );

            ReaderExtension->UpdateKey = UpdateKey[0];
         }
      }
   }
   ReaderExtension->StatusFileSelected = FALSE;
   return( NTStatus );
}

NTSTATUS
CmdPscrCommand (
   PREADER_EXTENSION ReaderExtension,
   PUCHAR            pInData,
   ULONG          InDataLen,
   PUCHAR            pOutData,
   ULONG          OutDataLen,
   PULONG            pNBytes
   )
/*++
CmdPscrCommand:
   send a command transparent to the reader

Arguments:
   ReaderExtension      context of call
   pInData,       ptr to input buffer
   InDataLen,        len of input buffer
   pOutData,         ptr to output buffer
   OutDataLen,       len of output buffer
   pNBytes           number of bytes transferred

Return Value:
   STATUS_SUCCESS
   STATUS_INVALID_PARAMETER
   error values from PscrRead / PscrWrite

--*/
{
   NTSTATUS       NTStatus = STATUS_SUCCESS;
   UCHAR          IOData[ MAX_T1_BLOCK_SIZE ] = { 0 };
   ULONG          IOBytes;
   //
   // the function is used for generic ioctl's, so carful ALL
   // parametes will be checked!
   //
   if( ( pInData == NULL ) ||
      ( pOutData == NULL ) ||
      ( pNBytes == NULL ) ||
      (InDataLen == 0 ) ||
      (OutDataLen == 0 )
      )
   {
      NTStatus = STATUS_INVALID_PARAMETER;
   }
   else
   {
      IOBytes = 0;
      NTStatus = PscrWriteDirect(
         ReaderExtension,
         pInData,
         InDataLen,
         &IOBytes
         );

      if( NT_SUCCESS( NTStatus ))
      {
         //
         // get result. ignore all reader errors
         //
         IOBytes = 0;
         NTStatus = PscrRead(
            ReaderExtension,
            IOData,
            MAX_T1_BLOCK_SIZE,
            &IOBytes
            );
         //
         // tranfer data
         //
         if( IOBytes > OutDataLen )
         {
            NTStatus = STATUS_BUFFER_TOO_SMALL;
         }
         else
         {
            *pNBytes = IOBytes;
            SysCopyMemory( pOutData, IOData, IOBytes );
         }
      }
   }
   return( NTStatus );
}

NTSTATUS
CmdGetTagValue (
   UCHAR Tag,
   PUCHAR   pTLVList,
   ULONG TLVListLen,
   PUCHAR   pTagLen,
   PVOID pTagVal
   )
/*++
CmdGetTagValue:
   scans a TLV list for the value of a user specified tag
   it is assumed, the caller knows the kind of the requested
   field, so only the ptr to the buffer will be checked

Arguments:
   Tag            requested Tag
   pTLVList    ptr to list
   TLVListLen     length of list
   pTagLen        ptr to length
   pTagVal        ptr to value

Return Value:
   STATUS_SUCCESS
   STATUS_UNSUCCESSFUL
   STATUS_INVALID_PARAMETER

--*/
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   ULONG    Idx;
   //
   // step through the given list
   //
   if(( pTLVList != NULL ) && ( pTagVal != NULL ) && ( pTagLen != NULL ))
   {
      //
      // look for requested tag
      //
      Idx = 0;
      while( Idx < TLVListLen )
      {
         if( pTLVList[ Idx ] == Tag )
         {
            //
            // ASSUMED THE CALLER KNOWS KIND OF FIELD!!!
            //
            *pTagLen = pTLVList[ Idx + 1 ];
            SysCopyMemory(
               pTagVal,
               &pTLVList[ Idx+2 ],
               pTLVList[ Idx+1 ]
               );

            break;
         }
         Idx += pTLVList[ Idx+1 ] + 2;
      }
      if( Idx >= TLVListLen )
      {
         NTStatus = STATUS_UNSUCCESSFUL;
      }
   }
   else
   {
      NTStatus = STATUS_INVALID_PARAMETER;
   }
   return( NTStatus );
}

// ------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrcmd.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrCmd.h

Abstract:

	Prototypes of basic command functions for SCM PSCR smartcard reader

Author:

	Andreas Straub

Revision History:

	Andreas Straub			7/16/1997	Initial Version

--*/

#if !defined( __PSCR_CMD_H__ )
#define __PSCR_CMD_H__

NTSTATUS
CmdResetInterface( 
	PREADER_EXTENSION	ReaderExtension			//	context of call
	);

NTSTATUS
CmdReset( 
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	BOOLEAN				WarmReset,				//	TRUE: Warm, FALSE: cold Reset
	PUCHAR				pATR,					//	ptr to ATR buffer
	PULONG				ATRLength				//	len of ATR
	);

NTSTATUS
CmdDeactivate( 
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device					//	device
	);

NTSTATUS
CmdReadBinary(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	USHORT				Offset,					//	offset in file
	PUCHAR				pData,					//	data buffer
	PULONG				pNBytes					//	length of bytes read
	);

NTSTATUS
CmdSelectFile(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	USHORT				FileId					//	File Id
	);

NTSTATUS
CmdSetInterfaceParameter(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	PUCHAR				pTLVList,				//	ptr to TLV list
	UCHAR				TLVListLen				//	len of TLV list
	);

NTSTATUS
CmdReadStatusFile (
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Device,					//	device
	PUCHAR				pTLVList,				//	ptr to TLV list
	PULONG				TLVListLen				//	len of TLV list
	);

NTSTATUS
CmdPscrCommand (
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	PUCHAR				pInData,				//	ptr to input buffer
	ULONG				InDataLen,				//	len of input buffer
	PUCHAR				pOutData,				//	ptr to ouput buffer
	ULONG				OutDataLen,				//	len of output buffer
	PULONG				pNBytes					//	number of bytes transferred
	);

NTSTATUS
CmdGetFirmwareRevision (
	PREADER_EXTENSION	ReaderExtension			//	context of call
	);

NTSTATUS
CmdGetTagValue (
	UCHAR				Tag,					//	tag to be searched
	PUCHAR				pTLVList,				//	ptr to TLV list
	ULONG				TLVListLen,				//	len of TLV list
	PUCHAR				pTagLen,				//	tag length
	PVOID				pTagVal					//	tag value
	);

#endif // __PSCR_CMD_H__

//------------------------------- END OF FILE -------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrvers.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrVers.h

Abstract:

	header file for version information

Author:

	Andreas Straub

Environment:

	Win 95, Win NT

Revision History:

--*/
#if !defined( __PSCRVERS_H__ )
#define __PSCRVERS_H__

#define PSCR_VERSION_STR	"1.26"
#define PSCR_MAJOR_VERSION	1
#define PSCR_MINOR_VERSION	26

#define PSCR_NAME			"PSCR"
#define PSCR_PRODUCT_NAME	"PSCR SmartCard Reader"
#define PSCR_VENDOR_NAME	"PSCR"
#define PSCR_IFD_TYPE		"PCMCIA Reader"
#define	PSCR_VXD_NAME		"PSCR.VXD"
#define PSCR_DEVICE_NAME	"PSCR_0"

#endif	//	__PSCRVERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrrdwr.h ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrRdWr.h

Abstract:

	Constants & access function prototypes for SCM PSCR smartcard reader

Author:

	Andreas Straub

Revision History:

	Andreas Straub			7/16/1997	Initial Version

--*/

#if !defined( __PSCR_RDWR_H__ )
#define __PSCR_RDWR_H__

#pragma pack( 1 )
//
//	The usage of the PSCR_REGISTERS struct is a little bit tricky:
//	We set the address of that stucture to the IO Base Port, then
//	the other reg's can accessed by their address.
//	p.E.	&PscrRegs = 0x320 --> &PscrRegs->CmdStatusReg = 0x321...
//
typedef struct _PSCR_REGISTERS {

	UCHAR  DataReg;
	UCHAR  CmdStatusReg;
	UCHAR  SizeLSReg;
	UCHAR  SizeMSReg;

 } PSCR_REGISTERS, *PPSCR_REGISTERS;

#define SIZEOF_PSCR_REGISTERS		( sizeof( PSCR_REGISTERS  )

#pragma pack()


typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _READER_EXTENSION {

	//	I/O address where the reader is configured.
	PPSCR_REGISTERS IOBase;
	ULONG IOWindow;
	ULONG MaxIFSD;

	//	IRQ assigned by the system
	ULONG CurrentIRQ;

	//
	//	limit for read timeout. the absolute timeout limit is 
	//	MaxRetries * DELAY_PSCR_WAIT
	//

	ULONG MaxRetries;

	//	Source/Destination byte always used by the PCMCIA (PC Card) reader.
	UCHAR Device;

	//	Software revision ID of the SwapSmart firmware.
	UCHAR FirmwareMajor, FirmwareMinor, UpdateKey;

	//
	//	Interrupt status; the flag is raised if an freeze event was detected
	//	and cleared if the interface was cleared (int service routine or
	//	PscrRead)
	//
	BOOLEAN	FreezePending;

	//
	//	Selected file in the reader file system; the flag is raised if the
	//	ICC1 status file was selected & is cleared if any generic ioctl was
	//	issued (in this case another file may be selected)
	//
	BOOLEAN	StatusFileSelected;

    BOOLEAN RequestCancelled;

    BOOLEAN InvalidStatus;

    BOOLEAN CardPresent;

    // Current reader power state.
    READER_POWER_STATE ReaderPowerState;

} READER_EXTENSION, *PREADER_EXTENSION;

#define SIZEOF_READER_EXTENSION		( sizeof( READER_EXTENSION ))

//
//	Constants -----------------------------------------------------------------
//
#define PSCR_ID_STRING				"SCM SwapSmart 2."

#define TLV_BUFFER_SIZE				0x20
#define ATR_SIZE					0x40	// TS + 32 + SW + PROLOGUE + EPILOGUE...

#define PSCR_MAX_RETRIES			1000

#define CLEAR_BIT					0x00

#define DEFAULT_WAIT_TIME			0x01

#define PSCR_PROLOGUE_LENGTH		0x03
#define PSCR_EXT_PROLOGUE_LENGTH	0x05
#define PSCR_STATUS_LENGTH			0x02

#define PSCR_LRC_LENGTH				0x01
#define PSCR_CRC_LENGTH				0x02

#define PSCR_EPILOGUE_LENGTH		PSCR_LRC_LENGTH

#define PCB_DEFAULT					0x00

#define MAX_T1_BLOCK_SIZE			270
//
//	data buffer idx
//
#define PSCR_NAD					0x00
#define PSCR_PCB					0x01
#define PSCR_LEN					0x02
#define PSCR_INF					0x03
#define PSCR_APDU					PSCR_INF
//
//	device identifier for reset, deactivate
//
#define DEVICE_READER				0x00
#define DEVICE_ICC1					0x01
#define DEVICE_ICC2					0x02
//
//	NAD's
//
#define NAD_TO_ICC1					0x02
#define NAD_TO_ICC2					0x42
#define NAD_TO_PSCR					0x12
#define REMOTE_NAD_TO_ICC1			0x03
#define REMOTE_NAD_TO_ICC2			0x43
#define REMOTE_NAD_TO_PSCR			0x13
//
//	PSCR Commands
//
#define CLA_SET_INTERFACE_PARAM		0x80
#define CLA_FREEZE					0x80
#define CLA_RESET					0x20
#define CLA_DEACTIVATE				0x20
#define CLA_SELECT_FILE				0x00
#define CLA_READ_BINARY				0x00
#define CLA_WRITE_BINARY			0x00
#define CLA_VERIFY					0x00
#define CLA_WARM_RESET				0x20
#define CLA_SOFTWARE_UPDATE			0x80
#define CLA_SET_MODE				0x80

#define INS_SET_INTERFACE_PARAM		0x60
#define INS_FREEZE					0x70
#define INS_RESET					0x10
#define INS_DEACTIVATE				0x14
#define INS_SELECT_FILE				0xA4
#define INS_READ_BINARY				0xB0
#define INS_WRITE_BINARY			0xD0
#define INS_VERIFY					0x20
#define INS_WARM_RESET				0x1F
#define INS_SOFTWARE_UPDATE			0xFF
#define INS_SET_MODE				0x61

//
//	Status Read Only Register
//
#define PSCR_DATA_AVAIL_BIT			0x80
#define PSCR_FREE_BIT				0x40
#define PSCR_WRITE_ERROR_BIT		0x02
#define PSCR_READ_ERROR_BIT			0x01
//
//	Command Write Only Register...
//
#define PSCR_RESET_BIT				0x08
#define PSCR_SIZE_READ_BIT			0x04
#define PSCR_SIZE_WRITE_BIT			0x02
#define PSCR_HOST_CONTROL_BIT		0x01
//
//	Tags...
//
#define TAG_MODULE					0x02
#define TAG_MEMORY_SIZE				0x03
#define TAG_UPDATE_KEY				0x08
#define TAG_SOFTWARE_REV			0x0F
#define TAG_BLOCK_COMP_OPTION		0x13
#define TAG_READER_MECH_OPTIONS		0x20
#define TAG_READER_STATUS			0x21
#define TAG_ICC_PROTOCOLS			0x22
#define TAG_BI						0x23
#define TAG_FI						0x24
#define TAG_PTS_PARAM				0x25
#define TAG_PROTOCOL_STATUS			0x26
#define TAG_SET_NULL_BYTES          0x2d
#define TAG_FREEZE_EVENTS			0x30
#define TAG_BIT_LENGTH				0x40
#define TAG_CGT						0x41
#define TAG_BWT						0x42
#define TAG_CWT						0x43
#define TAG_PROTOCOL_PARAM			0x44
//
//	card power definitions ( Tag 0x21 )
//
#define PSCR_ICC_ABSENT				0x00
#define PSCR_ICC_PRESENT			0x01
#define PSCR_ICC_POWERED			0x02
#define PSCR_ICC_IN_TRANSP_MODE		0xA0
#define PSCR_ICC_UNKNOWN            0xFF
//
//	protocol definitions ( Tag 0x22 )
//
#define PSCR_PROTOCOL_UNDEFINED		0x00
#define PSCR_PROTOCOL_T0			0x01
#define PSCR_PROTOCOL_T1			0x02
#define PSCR_PROTOCOL_T14			0x03
#define PSCR_PROTOCOL_I2C			0x80
#define PSCR_PROTOCOL_3WIRE			0x81
#define PSCR_PROTOCOL_2WIRE			0x81

#define WTX_REQUEST                 0xC3
#define WTX_REPLY                   0xE3
//
//	File ID's
//
#define FILE_MASTER						0x3F00
#define FILE_PSCR_CONFIG				0x0020
#define FILE_PSCR_DIR					0x7F60
#define FILE_PSCR_DIR_CONFIG			0x6020
#define FILE_PSCR_DIR_STATUS			0x6021
#define FILE_PSCR_DIR_FREEZE_CONFIG		0x6030
#define FILE_PSCR_DIR_FREEZE_STATUS		0x6031
#define FILE_ICC1_DIR					0x7F70
#define FILE_ICC1_DIR_CONFIG			0x7020
#define FILE_ICC1_DIR_STATUS			0x7021
#define FILE_ICC2_DIR_CONFIG			0x7120
#define FILE_ICC2_DIR_STATUS			0x7121
//
//	Status Word Definitions
//
#define PSCR_SW_COMMAND_FAIL			0x6985
#define PSCR_SW_INVALID_PARAM			0x6A80
#define PSCR_SW_INCONSISTENT_DATA		0x6A85
#define PSCR_SW_NO_PROTOCOL_SUPPORT		0x62A3
#define PSCR_SW_SYNC_ATR_SUCCESS		0x9000
#define PSCR_SW_ASYNC_ATR_SUCCESS		0x9001
#define PSCR_SW_NO_PROTOCOL				0x62A5
#define PSCR_SW_NO_ATR					0x62A6
#define PSCR_SW_NO_ATR_OR_PROTOCOL		0x62A7
#define PSCR_SW_NO_ICC					0x64A1
#define PSCR_SW_ICC_NOT_ACTIVE			0x64A2
#define PSCR_SW_NON_SUPPORTED_PROTOCOL	0x64A3
#define PSCR_SW_PROTOCOL_ERROR			0x64A8
#define PSCR_SW_NO_ATR_OR_PROTOCOL2		0x64A7
#define PSCR_SW_FILE_NOT_FOUND			0x6A82
#define PSCR_SW_FILE_NO_ACCEPPTED_AUTH	0x6982
#define PSCR_SW_FILE_NO_ACCESS			0x6985
#define PSCR_SW_FILE_BAD_OFFSET			0x6B00
#define PSCR_SW_END_OF_FILE_READ		0x6282
#define PSCR_SW_END_OF_FILE_WRITE		0x6301
#define PSCR_SW_WRITE_FILE_FAIL			0x6500
#define PSCR_SW_NO_PASSWORD				0x6200
#define PSCR_SW_WRONG_PASSWORD			0x6300
#define PSCR_SW_VERIFY_COUNTER_FAIL		0x6983
#define PSCR_SW_NO_REF_DATA				0x6A88
#define PSCR_SW_FLASH_MEM_ERROR			0x6481
#define PSCR_SW_FLASH_MEM_ERR2			0x6581
#define PSCR_SW_WRONG_LENGTH			0x6700
#define PSCR_SW_UNKNOWN_ICC_ERROR		0x64A0
#define PSCR_SW_UNKNOWN_PROTOCOL_ERROR	0x64A9
#define PSCR_SW_NO_PROTOCOL_SELECTED	0x64A5
#define PSCR_SW_PTS_PROTOCOL_ERROR		0x64AA
#define PSCR_SW_WTX_ERROR				0x64AB
#define PSCR_SW_WTX_ERR2				0x65AB
#define PSCR_SW_INVALID_SOURCE_ADDR		0x6F82

//
//	Prototypes for access functions -------------------------------------------
//


VOID
PscrFlushInterface(
	PREADER_EXTENSION	ReaderExtension		//	context of call
	);

NTSTATUS
PscrRead(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	PUCHAR				pData,					//	ptr to data buffer
	ULONG				DataLength,				//	length of data
	PULONG				pNBytes					//	number of bytes read
	);

NTSTATUS
PscrWrite(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	PUCHAR				pData,					//	ptr to data buffer
	ULONG				DataLength,				//	length of data
	PULONG				pNBytes					//	number of bytes written
	);

NTSTATUS
PscrWriteDirect(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	PUCHAR				pData,					//	ptr to data buffer
	ULONG				DataLength,				//	length of data
	PULONG				pNBytes					//	number of bytes written
	);

UCHAR
PscrCalculateLRC( 
	PUCHAR				pData,					//	ptr to data buffer
	USHORT				DataLength				//	length of data
	);

NTSTATUS
PscrWait(
	PREADER_EXTENSION	ReaderExtension,		//	context of call
	UCHAR				Mask					//	mask of requested bits
	);

#endif	//	__PSCR_RDWR_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\rnb3531\ifddefs.h ===
#define MAX_IFSD                254     // IFDTEST gives error on 255
#define CLK_FREQ_KHZ            3580
#define DATARATE_DEFAULT        9600

//
// Reader commands:
//
#define IFDCMD_GET_TYPE         0xF0
#define IFDCMD_GET_STATUS       0xF1
#define IFDCMD_PWR_OFF          0xF2
#define IFDCMD_PWR_ON           0xF3
#define IFDCMD_SLEEP            0xF4
#define IFDCMD_SEND_0xx         0xF8
#define IFDCMD_SEND_1xx         0xF9

#define IFDCMD_HEADER1          0xDB
#define IFDCMD_HEADER2          0x3A

//
// Responses from the reader
//
#define IFDRSP_HEADER_SIZE      2       // Marker + status/length
#define IFDRSP_MARKER           0xBE    // IFD responses start with this
#define IFDRSP_ICCRSP           0xD7    // ICC responses start with this

//
// Different status codes returned
//
#define IFDRSP_ACK              0xE0
#define IFDRSP_BADCMD           0xE1
#define IFDRSP_PARITY           0xE2
#define IFDRSP_NOCARD           0xE3

//
// Waiting times for various operations (in usec)
//
#define WAIT_TIME_READER_TYPE   10000
#define WAIT_TIME_STATUS        10000
#define WAIT_TIME_PWR_ON        1000000
#define WAIT_TIME_PWR_OFF       10000
#define WAIT_TIME_RDR_SLEEP     10000
#define WAIT_TIME_BYTE          1300
#define WAIT_TIME_PTS           1000000
#define WAIT_TIME_MINIMUM       20000

#define ATR_CHAR_TIMEOUT        1000000
#define ATR_BLOCK_TIMEOUT       1000000

#define SIZE_READER_TYPE        16
#define READER_TYPE_1           0x9B

#define DATARATE_14400          0x01
#define DATARATE_19200          0x02
#define DATARATE_28800          0x04
#define DATARATE_38400          0x08
#define DATARATE_57600          0x10
#define DATARATE_115200         0x20

//
// Status flags
//
#define SF_PRESENT              0x80
#define SF_REVERSE              0x40
#define SF_RESET_HI             0x04
#define SF_SYNC                 0x02
#define SF_ASYNC                0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\pscr\pscrrdwr.c ===
/*++

Copyright (c) 1997 - 1999 SCM Microsystems, Inc.

Module Name:

    PscrRdWr.c

Abstract:

	Hardware access functions for SCM PSCR smartcard reader

Author:

	Andreas Straub

Environment:

	Win 95		Sys... calls are resolved by Pscr95Wrap.asm functions and
				Pscr95Wrap.h macros, resp.

	NT	4.0		Sys... functions resolved by PscrNTWrap.c functions and
				PscrNTWrap.h macros, resp.

Revision History:

	Andreas Straub			7/16/1997	1.00	Initial Version
	Klaus Schuetz			9/20/1997	1.01	Timing changed
	Andreas Straub			9/24/1997	1.02	Low Level error handling,
												minor bugfixes, clanup

--*/

#if defined( SMCLIB_VXD )

#include <Pscr95.h>

#else	//	SMCLIB_VXD

#include <PscrNT.h>

#endif	//	SMCLIB_VXD

#include <PscrCmd.h>
#include <PscrRdWr.h>

#pragma optimize( "", off )
VOID
PscrFlushInterface( PREADER_EXTENSION ReaderExtension )
/*++

PscrFlushInterface:
	Read & discard data from the pcmcia interface

Arguments:
	ReaderExtension	context of call

Return Value:
	void

--*/
{
	UCHAR			Status;
	ULONG			Length;
	PPSCR_REGISTERS	IOBase;

	IOBase = ReaderExtension->IOBase;

	Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );
	if(( Status & PSCR_DATA_AVAIL_BIT ) && ( Status & PSCR_FREE_BIT ))
	{

		//	take control over
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

		//	get number of available bytes
		Length = ((ULONG)READ_PORT_UCHAR( &IOBase->SizeMSReg )) << 8;
		Length |= READ_PORT_UCHAR( &IOBase->SizeLSReg );

		//	perform a dummy read
		while( Length-- )
		{
			READ_PORT_UCHAR( &IOBase->DataReg );
		}
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
	}
	return;
}

NTSTATUS
PscrRead( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen,
	PULONG				pNBytes
	)
/*++
PscrRead:
	wait until data available & transfer data from reader to host

Arguments:
	ReaderExtension	context of call
	pData			ptr to data buffer
	DataLen			length of data buffer
	pNBytes			number of bytes returned

Return Value:
	STATUS_SUCCESS
	STATUS_BUFFER_TOO_SMALL
	STATUS_UNSUCCESSFUL

--*/
{
	NTSTATUS		NTStatus = STATUS_UNSUCCESSFUL;
	USHORT			ReaderStatus;
	PPSCR_REGISTERS	IOBase;
	USHORT			InDataLen;

	IOBase = ReaderExtension->IOBase;

	//	wait until interface is ready to transfer
	InDataLen = 0;

	if( NT_SUCCESS( NTStatus = PscrWait( ReaderExtension, PSCR_DATA_AVAIL_BIT | PSCR_FREE_BIT )))
	{
		//	take control over
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

		//	get number of available bytes
		InDataLen = ( READ_PORT_UCHAR( &IOBase->SizeMSReg ) << 8 );
		InDataLen |= READ_PORT_UCHAR( &IOBase->SizeLSReg );

        if (InDataLen <= PSCR_PROLOGUE_LENGTH) {

            // the buffer does not contain the minimum packet length
            NTStatus = STATUS_IO_TIMEOUT;

        } else if( ( ULONG )InDataLen <= DataLen ) {

		    //	check buffer size. if buffer to small, the data will be discarded

			//	read data
			ULONG Idx;
            for (Idx = 0; Idx < InDataLen; Idx++) {
             	
				pData[ Idx ] = READ_PORT_UCHAR( &IOBase->DataReg );
			} 

			//	error check
			if( pData[ InDataLen - 1 ] !=
				PscrCalculateLRC( pData, (USHORT)( InDataLen - 1 )))
			{
				NTStatus = STATUS_CRC_ERROR;
			}
			else
			{
				//
				//	Evaluation of reader errors. A reader error is indicated
				//	if the T1 length is 2 and the Nad indicates that this 
				//	packet came from the reader
				//
				if( ( ( pData[ PSCR_NAD ] & 0x0F ) == 0x01 ) &&
					( pData[ PSCR_LEN ] == 0x02 )
					)
				{
					ReaderStatus = (( USHORT ) pData[3] ) << 8;
					ReaderStatus |= (( USHORT ) pData[4] );
					
					if( ( ReaderStatus != 0x9000 ) &&
						( ReaderStatus != 0x9001 )
						)
					{
	                    SmartcardDebug( 
		                    DEBUG_TRACE, 
		                    ( "PSCR!PscrRead: ReaderStatus = %lx\n", ReaderStatus )
		                    );

						InDataLen	= 0;

                        if (ReaderStatus == PSCR_SW_PROTOCOL_ERROR) {

                            NTStatus = STATUS_IO_TIMEOUT;                         	

                        } else {
                         	
						    NTStatus = STATUS_UNSUCCESSFUL;
                        }
					}
				}
			}
		}
		else {

			//	flush interface in case of wrong buffer size
			do
        	{
				READ_PORT_UCHAR( &IOBase->DataReg );

			} while( --InDataLen );

			NTStatus = STATUS_BUFFER_TOO_SMALL;
		}

		//	clean up
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
	}

	//	write number of bytes received
	if( InDataLen )
	{
		if( pNBytes != NULL )
		{
			( *pNBytes ) = ( ULONG ) InDataLen;
		}
		NTStatus = STATUS_SUCCESS;
	}
	return ( NTStatus );
}

NTSTATUS
PscrWrite( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen,
	PULONG				pNBytes
	)
/*++
PscrWrite:
	calculates the LRC of the buffer & sends command to the reader

Arguments:
	ReaderExtension	context of call
	pData				ptr to data buffer
	DataLen				length of data buffer (exclusive LRC!)
	pNBytes				number of bytes written

Return Value:
	return value of PscrWriteDirect

--*/
{
	NTSTATUS	NTStatus;

	//	Add the EDC field to the end of the data
	pData[ DataLen ] = PscrCalculateLRC( pData, ( USHORT ) DataLen );

	//	Send buffer
	NTStatus = PscrWriteDirect( 
		ReaderExtension,
		pData,
		DataLen + PSCR_EPILOGUE_LENGTH,
		pNBytes
		);

	return( NTStatus );
}

NTSTATUS
PscrWriteDirect( 
	PREADER_EXTENSION	ReaderExtension,
	PUCHAR				pData,
	ULONG				DataLen,
	PULONG				pNBytes
	)

/*++
PscrWriteDirect:
	sends command to the reader. The LRC / CRC must be calculated by caller!

Arguments:
	ReaderExtension	context of call
	pData				ptr to data buffer
	DataLen				length of data buffer (exclusive LRC!)
	pNBytes				number of bytes written

Return Value:
	STATUS_SUCCESS
	STATUS_DEVICE_BUSY

--*/
{
	NTSTATUS		NTStatus = STATUS_SUCCESS;
	UCHAR			Status;
	PPSCR_REGISTERS	IOBase;

	IOBase = ReaderExtension->IOBase;

	//	in case of card change, there may be data available
	Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );
	if( Status & PSCR_DATA_AVAIL_BIT )
	{
		NTStatus = STATUS_DEVICE_BUSY;
	}
	else
	{
		//
		//	wait until reader is ready
		//
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );
		NTStatus = PscrWait( ReaderExtension, PSCR_FREE_BIT );
		
		if( NT_SUCCESS( NTStatus ))
		{
			ULONG	Idx;

			//	take control over
			WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, PSCR_HOST_CONTROL_BIT );

			//	write the buffer size
			WRITE_PORT_UCHAR( &IOBase->SizeMSReg, ( UCHAR )( DataLen >> 8 ));
			SysDelay( DELAY_WRITE_PSCR_REG );
			WRITE_PORT_UCHAR( &IOBase->SizeLSReg, ( UCHAR )( DataLen & 0x00FF ));
			SysDelay( DELAY_WRITE_PSCR_REG );

			//	write data
            for (Idx = 0; Idx < DataLen; Idx++) {

				WRITE_PORT_UCHAR( &IOBase->DataReg, pData[ Idx ] );
			}

			if( pNBytes != NULL )
			{
				*pNBytes = DataLen;
			}
		}

		//	clean up
		WRITE_PORT_UCHAR( &IOBase->CmdStatusReg, CLEAR_BIT );
	}
	return( NTStatus );
}

UCHAR
PscrCalculateLRC(
	PUCHAR	pData, 
	USHORT	DataLen
	)
/*++

PscrCalculateLRC:
	calculates the XOR LRC of a buffer.

Arguments:
	pData		ptr to data buffer
	DataLen		length of range

Return Value:
	LRC

--*/
{
	UCHAR	Lrc;
	USHORT	Idx;

	//
	//	Calculate LRC by XORing all the bytes.
	//
	Lrc = pData[ 0 ];
	for ( Idx = 1 ; Idx < DataLen; Idx++ )
	{
		Lrc ^= pData[ Idx ];
	}
	return ( Lrc );
}

NTSTATUS
PscrWait(
	PREADER_EXTENSION	ReaderExtension, 
	UCHAR				Mask 
	)
/*++
PscrWait:
	Test the status port of the reader until ALL bits in the mask are set.
	The maximum of time until DEVICE_BUSY is returned is approx.
	MaxRetries * DELAY_PSCR_WAIT if MaxRetries != 0.
	If MaxRetries = 0 the driver waits until the requested status is reported or the
	user defines a timeout.

Arguments:
	ReaderExtension		context of call
	Mask				mask of bits to test the status register

Return Value:
	STATUS_SUCCESS
	STATUS_DEVICE_BUSY

--*/
{
	NTSTATUS		NTStatus;
	PPSCR_REGISTERS	IOBase;
	ULONG			Retries;
	UCHAR			Status;

	IOBase		= ReaderExtension->IOBase;
	NTStatus	= STATUS_DEVICE_BUSY;

	//	wait until condition fulfilled or specified timeout expired
	for ( Retries = 0; Retries < ReaderExtension->MaxRetries; Retries++)
	{
		//	canceled?
		if( ReaderExtension->RequestCancelled == TRUE )
		{
			NTStatus = STATUS_CANCELLED;
			break;
		}

		if (( (READ_PORT_UCHAR( &IOBase->CmdStatusReg )) == 0x01) && 
			ReaderExtension->InvalidStatus)

		{
			NTStatus = STATUS_CANCELLED;
			break;
		}

		//	test requested bits
		if(( (READ_PORT_UCHAR( &IOBase->CmdStatusReg )) & Mask ) == Mask )
		{
			NTStatus = STATUS_SUCCESS;
			break;
		}
		SysDelay( DELAY_PSCR_WAIT );
	}

	Status = READ_PORT_UCHAR( &IOBase->CmdStatusReg );
	return NTStatus;
}

#pragma optimize( "", on )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\rnb3531\rnbo3531.h ===
/*++

Copyright (c) 1997 Rainbow Technologies Inc.

Module Name:

    RNBO3531.h

Abstract:

Author:
    Mehdi Sotoodeh          mehdi@rainbow.com

Environment:

    Kernel mode

Revision History :

    Jan 98 - Started from the DDK sources from Klaus Schutz
    Mar 98 - PnP support added
    Apr 98 - Changes on card timings and PnP
           - Added power management
    May 98 - RemoveLock changes

--*/

#ifndef _RNBO3531_
#define _RNBO3531_

#define VENDOR_NAME             "Rainbow Technologies"
#define DRIVER_NAME             "RNBO3531"
#define READER_NAME             "CardTerm"
#define SMARTCARD_POOL_TAG      'brCS'

#include <ntddk.h>
#include <ntddser.h>

#if _WIN32_WINNT >= 0x0500
#define NT5
#endif

#include "smclib.h"
#include "RbSclog.h"
#include "Ifddefs.h"

#ifndef NT5
#define MAXIMUM_SERIAL_READERS  4
#endif
#define SMARTCARD_READ          SCARD_CTL_CODE(1000)
#define SMARTCARD_WRITE         SCARD_CTL_CODE(1001)

#ifdef NT5
typedef enum _READER_POWER_STATE {
    PowerReaderUnspecified = 0,
    PowerReaderWorking,
    PowerReaderOff
} READER_POWER_STATE, *PREADER_POWER_STATE;
#endif

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION
{
    //
    // DeviceObject pointer to serial port
    //
    PDEVICE_OBJECT AttachedSerialPort;

    //
    // Synchronization objects
    //
    KEVENT ReaderStarted;
    //KEVENT ReaderClosed;
    KEVENT SerialCloseDone;

    // Used to keep track of open close calls
    LONG ReaderOpen;

#ifdef NT5
    UNICODE_STRING PnPDeviceName;
    ULONG DataRatesSupported[9];
#else
    //
    // The dos device name of our smart card reader
    //
    UNICODE_STRING DosDeviceName;

    //
    // This FileObject is needed to close the connection to the serial port.
    //
    PFILE_OBJECT SerialFileObject;
#endif

    //
    // This struct is used for CardTracking
    //
    PIRP SerialStatusIrp;

    // The current number of io-requests and its spinlock
    LONG IoCount;
    KSPIN_LOCK SpinLock;

    // Flag that indicates we're getting the ModemStatus
    BOOLEAN GetModemStatus;

    // Saved card state for hibernation/sleeping modes.
    BOOLEAN CardPresent;

    // Flag that indicates that the caller requests a power-down or a reset
    BOOLEAN PowerRequest;

    // Variable used to receive the modem status
    ULONG   ModemStatus;

    // Event serial reader uses to signal insert/removal
    ULONG   WaitMask;

    //
    // Stop bits, parity configuration
    //
    SERIAL_LINE_CONTROL LineControl;    
    SERIAL_TIMEOUTS SerialTimeouts;

#ifdef NT5
    // Used to keep track of the current power state the reader is in
    READER_POWER_STATE ReaderPowerState;
#endif

    // A worker thread that closes the serial driver
    PIO_WORKITEM CloseSerial;

    SMARTCARD_EXTENSION SmartcardExtension;

} READER_EXTENSION, *PREADER_EXTENSION;

//
// Prototypes
//
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    );

VOID
RBSCUnloadDriver(
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
RBSCCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RBSCAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT PhysicalDeviceObject
    );

VOID
RBSCRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RBSCDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RBSCConfigureSerialPort(
    PREADER_EXTENSION ReaderExtension
    );

NTSTATUS
RBSCSerialIo(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG  SerialIoControlCode,
    PUCHAR TxBuffer,
    ULONG  TxSize,
    ULONG  RxSize
    );

NTSTATUS
RBSCSetCommParams(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG DataRate
    );

NTSTATUS
RBSCPacketExchange(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PUCHAR  Command,
    ULONG   Length,
    ULONG   WaitTime,
    BOOLEAN IfdResponse
    );

NTSTATUS
RBSCReadFromCard(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG Length
    );

NTSTATUS
RBSCWriteToCard(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PUCHAR Buffer,
    ULONG  Length
    );

NTSTATUS
RBSCSerialEvents(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PREADER_EXTENSION ReaderExtension
    );

NTSTATUS
RBSCCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
RBSCReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
RBSCSetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
RBSCTransmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
RBSCT0Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
RBSCT1Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS
RBSCCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

VOID
RBSCCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    );

NTSTATUS 
RBSCStartDevice(
    PDEVICE_OBJECT DeviceObject
    );

#ifdef NT5
NTSTATUS
RBSCPnPDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

VOID 
RBSCCloseSerialPort(
    PDEVICE_OBJECT DeviceObject,
	PVOID Context
    );

NTSTATUS 
RBSCCallSerialDriver(
    PDEVICE_OBJECT AttachedSerialPort,
    PIRP Irp
    );

NTSTATUS
RBSCPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif

VOID
RBSCStopDevice(
    PREADER_EXTENSION ReaderExtension
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmn50m\makefile.inc ===
sccmlog.h sccmlog.rc msg00001.bin: sccmlog.mc
    mc sccmlog.mc

sccmn50m.rc: sccmlog.rc

sccmlog.rc: msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\rnb3531\rnbo3531.c ===
/*++

Copyright (c) 1997 Rainbow Technologies Inc.

Module Name:

    RNBO3531.c

Abstract:

Author:
    Mehdi Sotoodeh          mehdi@rainbow.com

Environment:

    Kernel mode

Revision History :

    Jan 98 - Started from the DDK sources from Klaus Schutz
    Mar 98 - PnP support added
    Apr 98 - Changes on card timings and PnP
           - Added power management
    May 98 - RemoveLock changes
           - RBSCT1Transmit timeout bug fixed
           - Sent to MicroSoft
    May 98 - Added variable baudrate support
           - Reduced ATR response time
           - Sent to MicroSoft
           - Data transmission size of 256 bug fixed.
    Jun 98 - Power management update
           - RBSCReaderPower and RBSCCardTracking moved to non-paged
             code (use of KeAcquireSpinLock/IoAcquireCancelSpinLock)
           - fixed: completeion function when IoSkipCurrentIrpStackLocation
             is called.
           - turned off PowerRequest flag on exit from RBSCReaderPower.
           - Sent to MicroSoft
    Sep 98 - Power management update
           - Sent to MicroSoft
    Oct 98 - warning fixes for win64 compatibility.
    Nov 98 - Set to default when PTS fails.
           - Mondex fix
           - Sent to MicroSoft
    Dec 98 - Reties removed from the reset operations
           - Sent to MicroSoft
    Apr 99 - Misc. changes

--*/

#include <stdio.h>
#include "RNBO3531.h"

//
// We do not need these functions after init anymore
//
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, RBSCAddDevice)
#pragma alloc_text(PAGEABLE, RBSCUnloadDriver)
#pragma alloc_text(PAGEABLE, RBSCRemoveDevice)
#pragma alloc_text(PAGEABLE, RBSCTransmit)
#pragma alloc_text(PAGEABLE, RBSCSetProtocol)
#pragma alloc_text(PAGEABLE, RBSCT0Transmit)
#pragma alloc_text(PAGEABLE, RBSCT1Transmit)

#if DBG
#pragma optimize ("", off)
#endif

UCHAR GetReaderType[] = {IFDCMD_HEADER1,IFDCMD_HEADER2,IFDCMD_GET_TYPE};
UCHAR CardPowerDown[] = {IFDCMD_HEADER1,IFDCMD_HEADER2,IFDCMD_PWR_OFF};
UCHAR CardPowerUp[]   = {IFDCMD_HEADER1,IFDCMD_HEADER2,IFDCMD_PWR_ON};

#ifdef  NT4
#define SmartcardAcquireRemoveLockWithTag(x,y) SmartcardAcquireRemoveLock(x)
#define SmartcardReleaseRemoveLockWithTag(x,y) SmartcardReleaseRemoveLock(x)
#endif

#ifndef NT5
DWORD UsedPortsMask = 0;    // Bit mask for used ports
#endif

//
// Table to convert inverse convention data
//
static UCHAR InverseCharTable[256] =
{
    0xFF,0x7F,0xBF,0x3F,0xDF,0x5F,0x9F,0x1F,
    0xEF,0x6F,0xAF,0x2F,0xCF,0x4F,0x8F,0x0F,
    0xF7,0x77,0xB7,0x37,0xD7,0x57,0x97,0x17,
    0xE7,0x67,0xA7,0x27,0xC7,0x47,0x87,0x07,
    0xFB,0x7B,0xBB,0x3B,0xDB,0x5B,0x9B,0x1B,
    0xEB,0x6B,0xAB,0x2B,0xCB,0x4B,0x8B,0x0B,
    0xF3,0x73,0xB3,0x33,0xD3,0x53,0x93,0x13,
    0xE3,0x63,0xA3,0x23,0xC3,0x43,0x83,0x03,
    0xFD,0x7D,0xBD,0x3D,0xDD,0x5D,0x9D,0x1D,
    0xED,0x6D,0xAD,0x2D,0xCD,0x4D,0x8D,0x0D,
    0xF5,0x75,0xB5,0x35,0xD5,0x55,0x95,0x15,
    0xE5,0x65,0xA5,0x25,0xC5,0x45,0x85,0x05,
    0xF9,0x79,0xB9,0x39,0xD9,0x59,0x99,0x19,
    0xE9,0x69,0xA9,0x29,0xC9,0x49,0x89,0x09,
    0xF1,0x71,0xB1,0x31,0xD1,0x51,0x91,0x11,
    0xE1,0x61,0xA1,0x21,0xC1,0x41,0x81,0x01,
    0xFE,0x7E,0xBE,0x3E,0xDE,0x5E,0x9E,0x1E,
    0xEE,0x6E,0xAE,0x2E,0xCE,0x4E,0x8E,0x0E,
    0xF6,0x76,0xB6,0x36,0xD6,0x56,0x96,0x16,
    0xE6,0x66,0xA6,0x26,0xC6,0x46,0x86,0x06,
    0xFA,0x7A,0xBA,0x3A,0xDA,0x5A,0x9A,0x1A,
    0xEA,0x6A,0xAA,0x2A,0xCA,0x4A,0x8A,0x0A,
    0xF2,0x72,0xB2,0x32,0xD2,0x52,0x92,0x12,
    0xE2,0x62,0xA2,0x22,0xC2,0x42,0x82,0x02,
    0xFC,0x7C,0xBC,0x3C,0xDC,0x5C,0x9C,0x1C,
    0xEC,0x6C,0xAC,0x2C,0xCC,0x4C,0x8C,0x0C,
    0xF4,0x74,0xB4,0x34,0xD4,0x54,0x94,0x14,
    0xE4,0x64,0xA4,0x24,0xC4,0x44,0x84,0x04,
    0xF8,0x78,0xB8,0x38,0xD8,0x58,0x98,0x18,
    0xE8,0x68,0xA8,0x28,0xC8,0x48,0x88,0x08,
    0xF0,0x70,0xB0,0x30,0xD0,0x50,0x90,0x10,
    0xE0,0x60,0xA0,0x20,0xC0,0x40,0x80,0x00
};

#if DBG
void
_stdcall
DumpData(
    PUCHAR Msg,
    PUCHAR Buffer,
    ULONG Length
    )
/*++

Routine Description:

  This function formats the debug output and
  shows it on the debug screen

Arguments:

  Buffer    - pointer to the buffer which contains the
              debug data

  Length    - length of the datablock

Return Value:

Note:
Output Format:

0000 : FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
0010 : FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
0020 : .....

--*/
{
    ULONG i, n;
    char buff[80];

    n = sprintf( buff, "RNBO3531!%s = %ld", Msg, Length );

    for( i = 0; i < Length; i++ )
    {
        if( (i & 15) == 0 )
        {
            SmartcardDebug( DEBUG_PROTOCOL, ("%s\n", buff) );
            n = sprintf( buff, "%04X :", i );
        }

        n += sprintf( buff+n, " %02X", Buffer[i] );
        if( ((i + 1) & 7) == 0 )
        {
            n += sprintf( buff+n, " " );
        }

    }
    SmartcardDebug( DEBUG_PROTOCOL, ("%s\n", buff) );
}
#else
#define DumpData(Msg,Buffer,Length)
#endif

VOID
RBSCDelay(
    ULONG waitTime
    )
/*++

Routine Description:

    Delay function.

Arguments:

    waitTime    - Waiting time in micro-seconds

Return Value:
   None

--*/
{
    if( waitTime )
    {
        LARGE_INTEGER delayPeriod;

        delayPeriod.HighPart = -1;
        delayPeriod.LowPart = waitTime * (-10); // units of 100nsec

        KeDelayExecutionThread( KernelMode,
                                FALSE,
                                &delayPeriod );
    }
}

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT  DriverObject,
    PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

--*/
{
#ifndef NT5
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG i, noOfDevices = 0;
    DWORD UsedPorts = 1;        // COM1 as default
    NTSTATUS status;
#endif

    SmartcardDebug(
        DEBUG_DRIVER,
        ("RNBO3531!DriverEntry: Enter - %s %s\n",
        __DATE__,
        __TIME__)
        );

    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverUnload                         = RBSCUnloadDriver;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = RBSCCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = RBSCCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = RBSCCleanup;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = RBSCDeviceControl;

#ifdef NT5
    DriverObject->DriverExtension->AddDevice  = RBSCAddDevice;
    DriverObject->MajorFunction[IRP_MJ_POWER] = RBSCPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]   = RBSCPnPDeviceControl;
#else
    RtlZeroMemory( paramTable, sizeof(paramTable) );

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"ComPorts";
    paramTable[0].EntryContext  = &UsedPorts;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &UsedPorts;
    paramTable[0].DefaultLength = 0;

    //
    // now try to find the entry in the registry
    //
    RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE,
                            RegistryPath->Buffer,
                            &paramTable[0],
                            NULL,
                            NULL );

    //
    // We now search the registry for DeviceN value
    //
    for( i = 0;
        noOfDevices < MAXIMUM_SERIAL_READERS && UsedPorts != 0;
        i++, UsedPorts >>= 1 )
    {
        PFILE_OBJECT   SerialFileObject;
        PDEVICE_OBJECT SerialDeviceObject;
        UNICODE_STRING SerialDeviceName;

        while( (UsedPorts & 1) == 0 )
        {
            UsedPorts >>= 1;
            i++;
        }

        RtlInitUnicodeString( &SerialDeviceName, L"\\Device\\Serial0" );

        //
        // create string like \Device\SerialN
        //
        SerialDeviceName.Buffer[14] = L'0' + (WCHAR) i;

        //
        // Try to create a device with the just created device name
        // It is possible that a smart card device with this name
        // already exists from a previous call.
        // It is possible to have up to 4 devices in a system
        //
        status = IoGetDeviceObjectPointer( &SerialDeviceName,
                                           FILE_ALL_ACCESS,
                                           &SerialFileObject,
                                           &SerialDeviceObject );
        if( !NT_SUCCESS(status) )
        {
            UNICODE_STRING comPortNumber;
            WCHAR buffer[2];

            //
            // Extract the com-port-number
            //
            comPortNumber.Buffer = buffer;
            comPortNumber.Length = sizeof(WCHAR);
            comPortNumber.MaximumLength = sizeof(buffer);

            comPortNumber.Buffer[0] = SerialDeviceName.Buffer[14] + (WCHAR)1;

            //
            // Write an event-log msg that this com port is not available
            //
            SmartcardLogError( DriverObject,
                               RBSC_CANT_CONNECT_TO_SERIAL_PORT,
                               &comPortNumber,
                               status );
            continue;
        }

        //
        // Now try to create a device and connect to the serial port
        //
        status = RBSCAddDevice( DriverObject, SerialDeviceObject );
        if( status == STATUS_SUCCESS )
        {
            //
            // We have successfully created a device
            //
            PREADER_EXTENSION ReaderExtension =
                DriverObject->DeviceObject->DeviceExtension;

            //
            // Save the serial port number this device is connected to
            //
            ReaderExtension->SmartcardExtension.ReaderCapabilities.Channel =
                i + 1;

            //
            // The fileObject is used in the unload function for
            // dereferencing
            //
            ReaderExtension->SerialFileObject = SerialFileObject;

            noOfDevices++;

        } else {

            //
            // We were unable to get the reader type.
            // So remove the device.
            //
            ObDereferenceObject( SerialFileObject );

            SmartcardLogError( DriverObject,
                               RBSC_CANNOT_OPEN_DEVICE,
                               &SerialDeviceName,
                               status );
        }
    }

    if( noOfDevices == 0 )
    {
        SmartcardLogError( DriverObject,
                           RBSC_NO_SUCH_DEVICE,
                           NULL,
                           status );
        return STATUS_NO_SUCH_DEVICE;
    }
#endif

    return STATUS_SUCCESS;
}

VOID
RBSCUnloadDriver(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:

    DriverObject - Pointer to driver object created by system.

Return Value:

    STATUS_SUCCESS.

--*/
{
#ifdef NT5
   //
   // We do not need to do anything since all the cleanups are done by
   // RBSCRemoveDevice().
   //
#else
    while( DriverObject->DeviceObject )
   {
        RBSCRemoveDevice( DriverObject->DeviceObject );
   }
#endif

    SmartcardDebug(
        DEBUG_INFO,
        ("RNBO3531!UnloadDriver\n")
        );
}

#ifdef NT5
NTSTATUS
RBSCIoCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PKEVENT Event
    )
/*++

Routine Description:
    Completion routine for an Irp sent to the serial driver. The event will
    be set to notify that the serial driver is done. The routine will not
    'complete' the Irp, so the caller of RBSCCallSerialDriver can continue.

Arguments:

    DeviceObject    - Pointer to device object
    Irp             - Irp to complete
    Event           - Used for process synchronization

Return Value:
    STATUS_CANCELLED                    Irp was cancelled by the IO manager
    STATUS_MORE_PROCESSING_REQUIRED     Irp will be finished by caller of
                                        RBSCCallSerialDriver
--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );

    Irp->IoStatus.Status =
        Irp->Cancel ? STATUS_CANCELLED : STATUS_MORE_PROCESSING_REQUIRED;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
RBSCCallSerialDriver(
    PDEVICE_OBJECT AttachedSerialPort,
    PIRP Irp
    )
/*++

Routine Description:

    Send an Irp to the serial driver and wait until the serial driver has
    finished the request.

    To make sure that the serial driver will not complete the Irp we first
    initialize an event and set our own completion routine for the Irp.

    When the serial driver has processed the Irp the completion routine will
    set the event and tell the IO manager that more processing is required.

    By waiting for the event we make sure that we continue only if the serial
    driver has processed the Irp completely.

Arguments:
    AttachedSerialPort - The PDO
    Irp                - Irp to send to the serial driver

Return Value:

    status returned by the serial driver

Note:
   Since this function can be called after our device is removed, do not
   use any of the reader extension data here.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    KEVENT Event;

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!CallSerialDriver: Enter\n")
        );

    //
    // Prepare everything to call the underlying driver
    //

    //
    // Copy our stack to the next stack location.
    //
    IoCopyCurrentIrpStackLocationToNext( Irp);

    //
    // initialize an event for process synchronization. the event is passed
    // to our completion routine and will be set if the serial driver is done
    //
    KeInitializeEvent( &Event,
                       NotificationEvent,
                       FALSE );

    //
    // Our IoCompletionRoutine sets only our event
    //
    IoSetCompletionRoutine( Irp,
                            RBSCIoCompletion,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );
    //
    // Call the serial driver
    //
    status = (IoGetCurrentIrpStackLocation( Irp )->MajorFunction ==
        IRP_MJ_POWER) ?
        PoCallDriver( AttachedSerialPort, Irp ) :
        IoCallDriver( AttachedSerialPort, Irp );

    //
    // Wait until the serial driver has processed the Irp
    //
    if( status == STATUS_PENDING )
    {
        status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,          // No alert
                                        NULL );         // No timeout
        ASSERT( STATUS_SUCCESS == status );
        status = Irp->IoStatus.Status;
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!CallSerialDriver: Exit %x\n",status)
        );

    return status;
}
#endif

NTSTATUS
RBSCStartDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Open the underlying serial driver and initialize it.
    Then initialize the reader hardware.

Arguments:
    DeviceObject    - Pointer to device object

Return Value:
    STATUS_SUCCESS
   STATUS_NO_MEMORY
    status returned by LowLevel routines

--*/
{
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT AttachedSerialPort = ReaderExtension->AttachedSerialPort;
    NTSTATUS status;
#ifdef NT5
   PIO_STACK_LOCATION irpSp;
    PIRP irp = IoAllocateIrp( (CCHAR)(DeviceObject->StackSize + 1), FALSE );
    ASSERT( irp != NULL );

    if( irp == NULL )
    {
        return STATUS_NO_MEMORY;
    }
#endif

    _try {

#ifdef NT5
        PIO_STACK_LOCATION irpStack;
        IO_STATUS_BLOCK ioStatusBlock;

        //
        // Open the underlying serial driver.
        // This is necessary for two reasons:
        // a) The serial driver can't be used without opening it
        // b) The call will go through serenum first which informs
        //    it to stop looking/polling for new devices.
        //
        irp->UserIosb = &ioStatusBlock;
        IoSetNextIrpStackLocation(irp);
        irpStack = IoGetCurrentIrpStackLocation( irp );

        irpStack->MajorFunction = IRP_MJ_CREATE;
        irpStack->Parameters.Create.Options = 0;
        irpStack->Parameters.Create.ShareAccess = 0;
        irpStack->Parameters.Create.FileAttributes = 0;
        irpStack->Parameters.Create.EaLength = 0;

        status = RBSCCallSerialDriver( AttachedSerialPort, irp );
        if( status != STATUS_SUCCESS )
        {
            if( status == STATUS_SHARED_IRQ_BUSY )
            {
                // Port is in use by another device
                SmartcardLogError( DeviceObject,
                                   RBSC_CANT_SHARE_IRQ,
                                   NULL,
                                   0 );
            }
            leave;
        }
#endif
        KeClearEvent( &ReaderExtension->SerialCloseDone );

        ReaderExtension->SmartcardExtension.ReaderCapabilities.CurrentState =
            (ULONG) SCARD_UNKNOWN;

        status = RBSCConfigureSerialPort( ReaderExtension );
        if( status != STATUS_SUCCESS )
        {
            leave;
        }

        //
        // Send a wait mask to the serial driver.
        // This call only sets the wait mask.
        // We want to be informed when CTS or DSR changes its state
        //
#ifdef NT5
        ReaderExtension->WaitMask = SERIAL_EV_CTS | SERIAL_EV_DSR;
#else
        ReaderExtension->WaitMask = SERIAL_EV_CTS;
#endif

        status = RBSCSerialIo( &ReaderExtension->SmartcardExtension,
                               IOCTL_SERIAL_SET_WAIT_MASK,
                               (PUCHAR) &ReaderExtension->WaitMask,
                               sizeof(ReaderExtension->WaitMask),
                               0 );
        if( status != STATUS_SUCCESS)
        {
            leave;
        }

        //
        // Now tell the serial driver that we want to be informed
        // when CTS or DSR changes its state.
        // Changing the lowest two bits tells IoBuildDeviceIoControlRequest
        // NOT to allocate a system buffer for the I/O operation.
        // We don't need a system buffer since we use our own buffers.
        //
      ReaderExtension->SerialStatusIrp = IoAllocateIrp(
         (CCHAR) (DeviceObject->StackSize + 1),
         FALSE
         );

       if (ReaderExtension->SerialStatusIrp == NULL) {

           status = STATUS_INSUFFICIENT_RESOURCES;
         leave;
       }

       irpSp = IoGetNextIrpStackLocation( ReaderExtension->SerialStatusIrp );
      irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

      irpSp->Parameters.DeviceIoControl.InputBufferLength = 0;
      irpSp->Parameters.DeviceIoControl.OutputBufferLength =
         sizeof(ReaderExtension->WaitMask);
      irpSp->Parameters.DeviceIoControl.IoControlCode =
         IOCTL_SERIAL_WAIT_ON_MASK;

      ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
         &ReaderExtension->WaitMask;

        //
        // this artificial delay is necessary to make this driver work
        // with digi board cards
        //
        RBSCDelay( 100000 );

        //
        // We simulate a callback now that triggers the card supervision
        //
        RBSCSerialEvents(
            ReaderExtension->SmartcardExtension.OsData->DeviceObject,
            ReaderExtension->SerialStatusIrp,
            ReaderExtension
            );

#ifdef NT5
        status = IoSetDeviceInterfaceState(
            &ReaderExtension->PnPDeviceName,
            TRUE
            );

        if( status != STATUS_SUCCESS )
        {
            leave;
        }
#endif
        KeSetEvent( &ReaderExtension->ReaderStarted, 0, FALSE );

    } _finally {

        if (status == STATUS_SHARED_IRQ_BUSY)
        {
            SmartcardLogError( DeviceObject,
                               RBSC_IRQ_BUSY,
                               NULL,
                               status );
        }

#ifdef NT5
        IoFreeIrp( irp );
#endif
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!StartDevice: Exit (%x)\n",status)
        );

    return status;
}

VOID
RBSCStopDevice(
    PREADER_EXTENSION ReaderExtension
    )
/*++

Routine Description:
    Waits for the device to be closed

Arguments:
    ReaderExtension - Pointer to our device data

Return Value:
    void

--*/
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!StopDevice: Enter\n")
        );

    if( !KeReadStateEvent( &ReaderExtension->SerialCloseDone ) )
    {
        NTSTATUS status;

        // test if we ever started event tracking
        if( ReaderExtension->WaitMask == 0 )
        {
            // no, we did not
            // We 'only' need to close the serial port
            RBSCCloseSerialPort(
                ReaderExtension->SmartcardExtension.OsData->DeviceObject,
                NULL );
        }
        else
        {
            //
            // We now inform the serial driver that we're no longer
            // interested in serial events. This will also free the irp
            // we use for those io-completions
            //
            ReaderExtension->WaitMask = 0;

            status = RBSCSerialIo(
                &ReaderExtension->SmartcardExtension,
                IOCTL_SERIAL_SET_WAIT_MASK,
                (PUCHAR)&ReaderExtension->WaitMask,
                sizeof(ULONG),
                0
                );
            ASSERT( status == STATUS_SUCCESS );

            // now wait until the connetion to serial is closed
            status = KeWaitForSingleObject(
                &ReaderExtension->SerialCloseDone,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
            ASSERT( status == STATUS_SUCCESS );
        }
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!StopDevice\n")
        );
}

VOID
RBSCRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Stops the device then releases all the resources used.

Arguments:
    DeviceObject    - Pointer to device object

Return Value:
    void

--*/
{
    NTSTATUS status;
    PREADER_EXTENSION ReaderExtension;
    PSMARTCARD_EXTENSION SmartcardExtension;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_INFO,
        ("RNBO3531!RemoveDevice: Enter\n")
        );

    ReaderExtension = DeviceObject->DeviceExtension;
    SmartcardExtension = &ReaderExtension->SmartcardExtension;

    if( SmartcardExtension->OsData )
    {
        // complete pending card tracking requests (if any)
        RBSCCompleteCardTracking( SmartcardExtension );
        ASSERT( SmartcardExtension->OsData->NotificationIrp == NULL );
#ifdef NT5
        SmartcardReleaseRemoveLockAndWait( SmartcardExtension );
#endif
    }

#ifndef NT5
    //
    // Free the device slot (if in use)
    //
    UsedPortsMask &= ~(1<<SmartcardExtension->VendorAttr.UnitNo);
#endif

    RBSCStopDevice( ReaderExtension );

#ifdef NT5
    if( ReaderExtension->AttachedSerialPort )
    {
        IoDetachDevice( ReaderExtension->AttachedSerialPort );
    }

    if( ReaderExtension->PnPDeviceName.Buffer != NULL )
    {
        RtlFreeUnicodeString( &ReaderExtension->PnPDeviceName );
    }

    if( ReaderExtension->CloseSerial != NULL )
    {
      IoFreeWorkItem(ReaderExtension->CloseSerial);
   }
#else
    if( ReaderExtension->SerialFileObject )
    {
        ObDereferenceObject( ReaderExtension->SerialFileObject );
    }

    if( ReaderExtension->DosDeviceName.Buffer != NULL )
    {
        //
        // Delete the symbolic link of the smart card reader
        //
        IoDeleteSymbolicLink( &ReaderExtension->DosDeviceName );
        RtlFreeUnicodeString( &ReaderExtension->DosDeviceName );
    }
#endif

    if( SmartcardExtension->OsData != NULL )
    {
        SmartcardExit( SmartcardExtension );
    }

    IoDeleteDevice( DeviceObject );

    SmartcardDebug(
        DEBUG_INFO,
        ("RNBO3531!RemoveDevice: Exit\n")
        );
}

#ifdef NT5
NTSTATUS
RBSCPnPDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    driver callback for pnp manager

    Request:                    Action:

    IRP_MN_START_DEVICE         Notify the driver about the new device
                                and start the device

    IRP_MN_STOP_DEVICE          Free all resources used by the device and
                                tell the driver that the device was stopped

    IRP_MN_QUERY_REMOVE_DEVICE  If the device is opened (i.e. in use) an
                                error will be returned to prevent the PnP
                                manager to stop the driver

    IRP_MN_CANCEL_REMOVE_DEVICE just notify that we can continue without any
                                restrictions

    IRP_MN_REMOVE_DEVICE        notify the driver that the device was
                                removed, stop & unload the device

    All other requests will be passed to the driver to ensure correct
    processing.

Arguments:
    DeviceObject    - Pointer to device object
    Irp             - Irp from the PnP manager

Return Value:
    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    status returned by serial driver

--*/
{

    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT AttachedSerialPort = ReaderExtension->AttachedSerialPort;
    NTSTATUS status;
    PIO_STACK_LOCATION stack;
    BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
    KEVENT Event;
    KIRQL irql;

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!PnPDeviceControl: Enter (%08x)\n",
        IoGetCurrentIrpStackLocation( Irp )->MinorFunction)
        );

    status = SmartcardAcquireRemoveLockWithTag(
                 &ReaderExtension->SmartcardExtension, ' PnP' );
    ASSERT( status == STATUS_SUCCESS );

    Irp->IoStatus.Information = 0;

    if( status != STATUS_SUCCESS )
    {
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    stack = IoGetCurrentIrpStackLocation( Irp );

    //
    // Now look what the PnP manager wants...
    //
    switch( stack->MinorFunction )
    {
        case IRP_MN_START_DEVICE:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_START_DEVICE\n")
                );

            // We have to call the underlying driver first
            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );
            ASSERT( status == STATUS_SUCCESS );

            if( status == STATUS_SUCCESS)
            {
                status = RBSCStartDevice( DeviceObject );
            }
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n")
                );

            KeAcquireSpinLock( &ReaderExtension->SpinLock, &irql );
            if( ReaderExtension->IoCount > 0 )
            {
                // we refuse to stop if we have pending io
                KeReleaseSpinLock( &ReaderExtension->SpinLock, irql );
                status = STATUS_DEVICE_BUSY;
                break;
            }

            // stop processing requests
            KeClearEvent( &ReaderExtension->ReaderStarted );
            KeReleaseSpinLock( &ReaderExtension->SpinLock, irql );

            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n")
                );

            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );
            if( status == STATUS_SUCCESS )
            {
                // we can continue to process requests
                KeSetEvent( &ReaderExtension->ReaderStarted, 0, FALSE );
            }
            break;

        case IRP_MN_STOP_DEVICE:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_STOP_DEVICE\n")
                );

            RBSCStopDevice( ReaderExtension );
            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n")
                );

            // disable the interface (and ignore possible errors)
            IoSetDeviceInterfaceState(
                &ReaderExtension->PnPDeviceName,
                FALSE
                );

            // now look if someone is currently connected to us
            if (ReaderExtension->ReaderOpen)
            {
                //
                // someone is connected, fail the call
                // we will enable the device interface in
                // IRP_MN_CANCEL_REMOVE_DEVICE again
                //
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            // pass the call to the next driver in the stack
            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n")
                );

            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );

            //
            // reenable the interface only in case that the reader is
            // still connected. This covers the following case:
            // hibernate machine, disconnect reader, wake up, stop device
            // (from task bar) and stop fails since an app. holds the device open
            //
            if( status == STATUS_SUCCESS &&
                ReaderExtension->WaitMask != 0 )
            {
                status = IoSetDeviceInterfaceState(
                    &ReaderExtension->PnPDeviceName,
                    TRUE
                    );

                ASSERT(status == STATUS_SUCCESS);
            }
            break;

        case IRP_MN_REMOVE_DEVICE:
            // Remove our device
            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!PnPDeviceControl: IRP_MN_REMOVE_DEVICE\n")
                );

            RBSCRemoveDevice( DeviceObject );
         // DeviceObject is freed, do not reference it again.
            status = RBSCCallSerialDriver( AttachedSerialPort, Irp );
            deviceRemoved = TRUE;
            break;

        default:
            // This is an Irp that is only useful for underlying drivers
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver( AttachedSerialPort, Irp );
            irpSkipped = TRUE;
            break;
    }

    if( !irpSkipped )
    {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    if( !deviceRemoved )
    {
        SmartcardReleaseRemoveLockWithTag(
            &ReaderExtension->SmartcardExtension, ' PnP' );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!PnPDeviceControl: Exit %x\n",status)
        );

    return status;
}
#endif

NTSTATUS
RBSCAddDevice(
    PDRIVER_OBJECT DriverObject,
    PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This is the add-device routine for the miniport.
    Find a device slot then, create device object and attach it to the
    given PhysicalDeviceObject.
    Initialize the device extension and its smart card data.

Arguments:

    DriverObject        - a pointer to the driver object for this device
    PhysicalDeviceObject- The device object of the serial port to attach to

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT DeviceObject = NULL;
    PSMARTCARD_EXTENSION SmartcardExtension = NULL;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!AddDevice: Enter\n")
        );

    try {

        ULONG DeviceNo;
        PREADER_EXTENSION ReaderExtension;
#ifndef NT5
        UNICODE_STRING SmartcardDeviceName;

        for( DeviceNo = 0;
             DeviceNo < MAXIMUM_SERIAL_READERS;
             DeviceNo++ )
        {
            if( (UsedPortsMask & (1<<DeviceNo)) == 0 )
            {
                break;
            }
        }

        if( DeviceNo == MAXIMUM_SERIAL_READERS )
        {
            SmartcardLogError(
                DriverObject,
                RBSC_CANT_CREATE_MORE_DEVICES,
                NULL,
                0
                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            leave;
        }

        //
        //  construct the device name
        //
        RtlInitUnicodeString( &SmartcardDeviceName, L"\\Device\\RNBO3531?" );
        SmartcardDeviceName.Buffer[16] = L'0' + (WCHAR) DeviceNo;
#endif
        //
        // Create the functional device object
        //
        status = IoCreateDevice(
            DriverObject,
            sizeof(READER_EXTENSION),
#ifdef NT5
            NULL,                      // No name
#else
            &SmartcardDeviceName,
#endif
            FILE_DEVICE_SMARTCARD,
            0,
            TRUE,                       // Exclusive
            &DeviceObject
            );

        if( status != STATUS_SUCCESS )
        {
            SmartcardLogError( DriverObject,
                               RBSC_CANT_CREATE_DEVICE,
                               NULL,
                               0 );
            leave;
        }

        //
        //  set up the device extension and initialize it.
        //
        ReaderExtension = DeviceObject->DeviceExtension;
        SmartcardExtension = &ReaderExtension->SmartcardExtension;
        SmartcardExtension->ReaderExtension = ReaderExtension;

#ifdef NT5
      ReaderExtension->CloseSerial = IoAllocateWorkItem(
         DeviceObject
         );

      if (ReaderExtension->CloseSerial == NULL) {

         SmartcardLogError(
            DriverObject,
            RBSC_NO_MEMORY,
            NULL,
            0
            );
         leave;
      }
#endif
        // Used for stop / start notification
        KeInitializeEvent( &ReaderExtension->ReaderStarted,
                           NotificationEvent,
                           FALSE );

        KeInitializeEvent( &ReaderExtension->SerialCloseDone,
                           NotificationEvent,
                           TRUE );

        // Used to keep track of open close calls
        ReaderExtension->ReaderOpen = FALSE;

        KeInitializeSpinLock( &ReaderExtension->SpinLock );

        //
        //  enter correct version of the lib
        //
        SmartcardExtension->Version = SMCLIB_VERSION;
        SmartcardExtension->SmartcardRequest.BufferSize =
        SmartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

        status = SmartcardInitialize( SmartcardExtension );

        if( status != STATUS_SUCCESS )
        {
            SmartcardLogError(
                DriverObject,
                (SmartcardExtension->OsData ?
                    RBSC_WRONG_LIB_VESION : RBSC_NO_MEMORY),
                NULL,
                0
                );
            leave;
        }

        //
        // Set up call back functions
        //
        SmartcardExtension->ReaderFunction[ RDF_TRANSMIT ] =
            RBSCTransmit;
        SmartcardExtension->ReaderFunction[ RDF_SET_PROTOCOL ] =
            RBSCSetProtocol;
        SmartcardExtension->ReaderFunction[ RDF_CARD_POWER ] =
            RBSCReaderPower;
        SmartcardExtension->ReaderFunction[ RDF_CARD_TRACKING ] =
            RBSCCardTracking;

        //
        //  setup smartcard extension
        //
        //
        // Initialize the vendor information
        //
        strcpy( SmartcardExtension->VendorAttr.VendorName.Buffer,
                VENDOR_NAME );

        SmartcardExtension->VendorAttr.VendorName.Length =
            sizeof(VENDOR_NAME);

        strcpy( SmartcardExtension->VendorAttr.IfdType.Buffer,
                READER_NAME );

        SmartcardExtension->VendorAttr.IfdType.Length =
            sizeof(READER_NAME);

        SmartcardExtension->VendorAttr.UnitNo = MAXULONG;

        for (DeviceNo = 0; DeviceNo < MAXULONG; DeviceNo++)
        {
            PDEVICE_OBJECT devObj;

            for (devObj = DeviceObject;
                devObj != NULL;
                devObj = devObj->NextDevice)
            {
                PREADER_EXTENSION devExt = devObj->DeviceExtension;

                if (DeviceNo ==
                    devExt->SmartcardExtension.VendorAttr.UnitNo)
                {
                    break;
                }
            }

            if (devObj == NULL)
            {
                SmartcardExtension->VendorAttr.UnitNo = DeviceNo;
                break;
            }
        }

        //
        //  tell the lib our device object
        //
        SmartcardExtension->OsData->DeviceObject = DeviceObject;

#ifdef NT5
        ReaderExtension->AttachedSerialPort = IoAttachDeviceToDeviceStack(
            DeviceObject,
            PhysicalDeviceObject
            );

        if( ReaderExtension->AttachedSerialPort == NULL )
        {
            SmartcardLogError( DriverObject,
                               RBSC_CANT_ATTACH_TO_SERIAL_PORT,
                               &DriverObject->DriverName,
                               0 );
            status = STATUS_UNSUCCESSFUL;
            leave;
        }

        // register our new device
        status = IoRegisterDeviceInterface( PhysicalDeviceObject,
                                            &SmartCardReaderGuid,
                                            NULL,
                                            &ReaderExtension->PnPDeviceName );
        ASSERT( status == STATUS_SUCCESS );

        ReaderExtension->ReaderPowerState = PowerReaderWorking;
#else
        //
        // Save the deviceObject for the connected serial port
        //
        ReaderExtension->AttachedSerialPort = PhysicalDeviceObject;

        status = RBSCStartDevice( DeviceObject );
        if( status != STATUS_SUCCESS )
        {
         leave;
      }

        //
        // Create a symbolic link
        //
        status = SmartcardCreateLink( &ReaderExtension->DosDeviceName,
                                      &SmartcardDeviceName );
#endif
        if( status != STATUS_SUCCESS )
        {
         leave;
      }

        //
        //  tell the OS that we supposed to do buffered io
        //
#ifdef NT5
        DeviceObject->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
#else
        DeviceObject->Flags |= DO_BUFFERED_IO;
        UsedPortsMask |= (1<<DeviceNo);
#endif
        DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        SmartcardDebug(
            DEBUG_INFO,
            ("RNBO3531!AddDevice: Device #%d created Ext=%08x.\n",
            DeviceNo,ReaderExtension)
            );
    }
    finally
    {
        if( status != STATUS_SUCCESS && DeviceObject != NULL )
        {
            RBSCRemoveDevice( DeviceObject );
        }
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!AddDevice: Exit %x\n",status)
        );

    return status;
}

NTSTATUS
RBSCConfigureSerialPort(
    PREADER_EXTENSION ReaderExtension
    )

/*++

Routine Description:

    This routine reads the default configuraton values for this device.

Arguments:

    ReaderExtension - Pointer to our device data

Return Value:

    none

--*/
{
    PSMARTCARD_EXTENSION SmartcardExtension =
        &ReaderExtension->SmartcardExtension;
    PUCHAR RxBuffer = SmartcardExtension->SmartcardReply.Buffer;
    NTSTATUS status;

    {
        //
        // Set up baudrate
        //
        SERIAL_BAUD_RATE BaudRate;

        BaudRate.BaudRate = DATARATE_DEFAULT;
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_BAUD_RATE,
                               (PUCHAR) &BaudRate,
                               sizeof(SERIAL_BAUD_RATE),
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Set up line control parameters
        //
        ReaderExtension->LineControl.Parity = ODD_PARITY;
        ReaderExtension->LineControl.StopBits = STOP_BIT_1;
        ReaderExtension->LineControl.WordLength = SERIAL_DATABITS_8;

        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_LINE_CONTROL,
                               (PUCHAR)&ReaderExtension->LineControl,
                               sizeof(SERIAL_LINE_CONTROL),
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Set serial special characters
        //
        SERIAL_CHARS SerialChars;

        SerialChars.ErrorChar = 0;
        SerialChars.EofChar   = 0;
        SerialChars.EventChar = 0;
        SerialChars.XonChar   = 0;
        SerialChars.XoffChar  = 0;
        SerialChars.BreakChar = 0xFF;

        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_CHARS,
                               (PUCHAR) &SerialChars,
                               sizeof(SERIAL_CHARS),
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Set up timeouts (all in msec)
        //
        ReaderExtension->SerialTimeouts.ReadTotalTimeoutMultiplier = 1;
        ReaderExtension->SerialTimeouts.ReadIntervalTimeout = 2*
            ATR_CHAR_TIMEOUT/1000;
        ReaderExtension->SerialTimeouts.ReadTotalTimeoutConstant = 2*
            ATR_BLOCK_TIMEOUT/1000;

        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_TIMEOUTS,
                               (PUCHAR)&ReaderExtension->SerialTimeouts,
                               sizeof(SERIAL_TIMEOUTS),
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Set flowcontrol and handshaking
        //
        SERIAL_HANDFLOW HandFlow;

        HandFlow.XonLimit = 0;
        HandFlow.XoffLimit = 0;
        HandFlow.FlowReplace = SERIAL_XOFF_CONTINUE ;
        HandFlow.ControlHandShake = 0;

        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_HANDFLOW,
                               (PUCHAR) &HandFlow,
                               sizeof(SERIAL_HANDFLOW),
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Set break off
        //
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_BREAK_OFF,
                               NULL,
                               0,
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_RTS,
                               NULL,
                               0,
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_DTR,
                               NULL,
                               0,
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        //
        // Toggle DTR line to wake-up the reader if it is
        // in SLEEP mode
        //
        RBSCDelay( 10000 );
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_CLR_DTR,
                               NULL,
                               0,
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_DTR,
                               NULL,
                               0,
                               0 );
    }

    if( status == STATUS_SUCCESS )
    {
        RBSCDelay( 10000 );
        status = RBSCPacketExchange( SmartcardExtension,
                                     GetReaderType,
                                     sizeof(GetReaderType),
                                     WAIT_TIME_READER_TYPE,
                                     TRUE );
    }

    if( status != STATUS_SUCCESS )
    {
        return status;
    }

    if( SmartcardExtension->SmartcardReply.BufferLength <
        SIZE_READER_TYPE ||
        RxBuffer[0] != 'R' || RxBuffer[1] != 'N' ||
        RxBuffer[2] != 'B' || RxBuffer[3] != 'O' ||
        RxBuffer[15] != READER_TYPE_1 )
    {
        return STATUS_DEVICE_DATA_ERROR;
    }

    //
    // Set reader info
    //
    SmartcardExtension->VendorAttr.IfdVersion.VersionMajor =
        (UCHAR)RxBuffer[6];
    SmartcardExtension->VendorAttr.IfdVersion.VersionMinor =
        (UCHAR)RxBuffer[7];
    SmartcardExtension->VendorAttr.IfdVersion.BuildNumber  =
        ((USHORT)RxBuffer[8]<<8) + ((USHORT)RxBuffer[9]);

    //
    // Clk frequency in KHz encoded as little endian integer
    //
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
    SmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
        ((USHORT)RxBuffer[10]<<8) + ((USHORT)RxBuffer[11]);

    SmartcardExtension->ReaderCapabilities.DataRate.Default =
    SmartcardExtension->ReaderCapabilities.DataRate.Max = DATARATE_DEFAULT;

    if( RxBuffer[13] != 0 )
    {
        // reader is supposed to support higher data rates
        ULONG NumRates = 1;

        if( RxBuffer[13] & DATARATE_14400 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 14400;
        }

        if( RxBuffer[13] & DATARATE_19200 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 19200;
        }

        if( RxBuffer[13] & DATARATE_28800 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 28800;
        }

        if( RxBuffer[13] & DATARATE_38400 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 38400;
        }

        if( RxBuffer[13] & DATARATE_57600 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 57600;
        }

        if( RxBuffer[13] & DATARATE_115200 )
        {
            SmartcardExtension->ReaderCapabilities.DataRate.Max =
            ReaderExtension->DataRatesSupported[ NumRates++ ] = 115200;
        }

        if( NumRates > 1 )
        {
            ReaderExtension->DataRatesSupported[0] = 9600; // always supported
            SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
                (UCHAR) NumRates;
            SmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
                ReaderExtension->DataRatesSupported;

            SmartcardDebug(
                DEBUG_INFO,
                ("RNBO3531!ConfigureSerialPort: %ld DataRates, Max=%ld\n",
                NumRates,
                SmartcardExtension->ReaderCapabilities.DataRate.Max)
                );
        }
    }

    SmartcardExtension->ReaderCapabilities.MaxIFSD = MAX_IFSD;

    //
    //  setup smartcard extension - reader capabilities
    //
    SmartcardExtension->ReaderCapabilities.SupportedProtocols =
        SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1;

    SmartcardExtension->ReaderCapabilities.ReaderType =
        SCARD_READER_TYPE_SERIAL;

    status = RBSCSerialIo( SmartcardExtension,
                           IOCTL_SERIAL_GET_MODEMSTATUS,
                           NULL,
                           0,
                           sizeof(ReaderExtension->ModemStatus) );
    if( status == STATUS_SUCCESS )
    {
        ReaderExtension->ModemStatus =
            *(PULONG)SmartcardExtension->SmartcardReply.Buffer;

        SmartcardExtension->ReaderCapabilities.CurrentState =
            (ReaderExtension->ModemStatus & SERIAL_CTS_STATE) ?
            SCARD_SWALLOWED : SCARD_ABSENT;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RBSCCreateClose(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the device is opened
    or closed.

Arguments:

    DeviceObject    - Pointer to device object
    Irp             - IRP involved.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension =
        &ReaderExtension->SmartcardExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    __try
    {
        if( irpStack->MajorFunction == IRP_MJ_CREATE )
        {
            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!Create\n")
                );

#ifdef NT5
            if( SmartcardAcquireRemoveLockWithTag(
                    SmartcardExtension, 'lCrC' ) != STATUS_SUCCESS )
            {
                status = STATUS_DEVICE_REMOVED;
                __leave;
            }

            // test if the device has been opened already
            if (InterlockedCompareExchange(
                &ReaderExtension->ReaderOpen,
                TRUE,
                FALSE) == FALSE)
            {
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("RNBO3531!CreateClose: Open\n")
                    );
            }
            else
            {
                // the device is already in use
                status = STATUS_UNSUCCESSFUL;

                // release the lock
                SmartcardReleaseRemoveLockWithTag( SmartcardExtension,
                                                   'lCrC' );
            }

#endif
        } else {

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!Close\n")
                );

#ifdef NT5
            SmartcardReleaseRemoveLockWithTag( SmartcardExtension,
                                               'lCrC' );
#endif
            ReaderExtension->ReaderOpen = FALSE;
        }

    }
    __finally
    {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return status;
}

NTSTATUS
RBSCCancel(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
   PREADER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!RBSCCancel: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp == SmartcardExtension->OsData->NotificationIrp);

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    RBSCCompleteCardTracking(SmartcardExtension);

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!RBSCCancel: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_CANCELLED;
}

NTSTATUS
RBSCCleanup(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system when the calling thread
    terminates

Arguments:

    DeviceObject    - Pointer to device object
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

--*/

{
    PREADER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!RBSCCleanup: Enter\n",
        DRIVER_NAME)
        );

    ASSERT(Irp != SmartcardExtension->OsData->NotificationIrp);

    // We need to complete the notification irp
    RBSCCompleteCardTracking(SmartcardExtension);

   SmartcardDebug(
      DEBUG_DRIVER,
      ("%s!RBSCCleanup: Completing IRP %lx\n",
        DRIVER_NAME,
        Irp)
      );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

   IoCompleteRequest(
      Irp,
      IO_NO_INCREMENT
      );

    SmartcardDebug(
        DEBUG_TRACE,
        ("%s!RBSCCleanup: Exit\n",
        DRIVER_NAME)
        );

    return STATUS_SUCCESS;
}

NTSTATUS
RBSCSerialIo(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG  SerialIoControlCode,
    PUCHAR TxBuffer,
    ULONG  TxSize,
    ULONG  RxSize
    )
/*++

Routine Description:

    This routine sends IOCTL's to the serial driver. It waits on for their
    completion, and then returns.

Arguments:
    SmartcardExtension  - Pointer to the smart card data
    SerialIoControlCode - IOCTL code to be sent to the serial driver
    TxBuffer         - Ponter to the data to send
    TxSize           - Size of data to send
    RxSize           - Number of bytes expected to receive

Return Value:

    NTSTATUS

--*/
{
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;

    if (KeReadStateEvent(&ReaderExtension->SerialCloseDone))
    {
        //
        // we have no connection to serial, fail the call
        // this could be the case if the reader was removed
        // during stand by / hibernation
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check if the buffers are large enough
    //
    ASSERT( RxSize <= SmartcardExtension->SmartcardReply.BufferSize );

    if( RxSize > SmartcardExtension->SmartcardReply.BufferSize )
    {
        SmartcardLogError( SmartcardExtension->OsData->DeviceObject,
                           RBSC_BUFFER_TOO_SMALL,
                           NULL,
                           0 );

        return STATUS_BUFFER_TOO_SMALL;
    }

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    //
    // Build irp to be sent to serial driver
    //
    irp = IoBuildDeviceIoControlRequest(
        SerialIoControlCode,
        ReaderExtension->AttachedSerialPort,
        (TxSize ? TxBuffer : NULL),
        TxSize,
        (RxSize ? SmartcardExtension->SmartcardReply.Buffer : NULL),
        RxSize,
        FALSE,
        &event,
        &ioStatus
        );

    ASSERT( irp != NULL );

    if( irp == NULL )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    switch( SerialIoControlCode )
    {
        PIO_STACK_LOCATION nextsp;

        //
        // The serial driver trasfers data from/to
        // irp->AssociatedIrp.SystemBuffer
        //
        case SMARTCARD_WRITE:
            nextsp = IoGetNextIrpStackLocation( irp );
            nextsp->MajorFunction = IRP_MJ_WRITE;
            nextsp->Parameters.Write.Length = TxSize;
            nextsp->Parameters.Write.ByteOffset.QuadPart = 0;
            break;

        case SMARTCARD_READ:
            nextsp = IoGetNextIrpStackLocation( irp );
            nextsp->MajorFunction = IRP_MJ_READ;
            nextsp->Parameters.Read.Length = RxSize;
            nextsp->Parameters.Read.ByteOffset.QuadPart = 0;
            break;
    }

    status = IoCallDriver( ReaderExtension->AttachedSerialPort, irp );

    if( status == STATUS_PENDING )
    {
        KeWaitForSingleObject( &event,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL );
        status = ioStatus.Status;

        if( status == STATUS_TIMEOUT &&
            ioStatus.Information != 0 &&
            ioStatus.Information < RxSize )
        {
            // Ignore time-out if some data returned
            status = STATUS_SUCCESS;
        }

        // save the number of bytes received
        SmartcardExtension->SmartcardReply.BufferLength =
            (RxSize != 0 && status == STATUS_SUCCESS) ?
            (ULONG) ioStatus.Information : 0;

    } else {
        SmartcardExtension->SmartcardReply.BufferLength =
            (status == STATUS_SUCCESS) ? RxSize : 0;
    }

#if 0
    if( SerialIoControlCode == SMARTCARD_WRITE )
    {
        // TDB: Wait for Tx buffer empty
    }
#endif

    //
    // STATUS_TIMEOUT isn't correctly mapped
    // to a WIN32 error, that's why we change it here
    // to STATUS_IO_TIMEOUT
    //
    return( (status == STATUS_TIMEOUT) ? STATUS_IO_TIMEOUT : status );
}

NTSTATUS
RBSCWriteToCard(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PUCHAR Buffer,
    ULONG  Length
    )
/*++

Routine Description:

    This routine sends data to the smart card. It handles the inverse
    convention and gaurd time.

Arguments:
    SmartcardExtension - Pointer to our smartcard data
    Buffer             - Points to the data to send
    Length             - Length of data to send (bytes)

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    UCHAR TempBuffer[MIN_BUFFER_SIZE];
    ULONG StopBits = SmartcardExtension->CardCapabilities.PtsData.StopBits;

    DumpData( "Data to the card", Buffer, Length );

    if( SmartcardExtension->CardCapabilities.ATR.Buffer[0] == 0x3F )
    {
        ULONG l;

        if( Length > sizeof(TempBuffer) )
        {
            return STATUS_DEVICE_DATA_ERROR;
        }

        for( l = 0; l < Length; l++ )
        {
            TempBuffer[l] = InverseCharTable[ Buffer[l] ];
        }

        Buffer = TempBuffer;
    }


    if( StopBits <= 2 )
    {
        return RBSCSerialIo( SmartcardExtension,
                             SMARTCARD_WRITE,
                             Buffer,
                             Length,
                             0 );
    }

    while( Length != 0 )
    {
        status = RBSCSerialIo( SmartcardExtension,
                               SMARTCARD_WRITE,
                               Buffer,
                               1,
                               0 );

        if( status != STATUS_SUCCESS )
        {
            return status;
        }

        Buffer++;
        Length--;

        if( Length != 0 )
            KeStallExecutionProcessor(
                (StopBits-1)*SmartcardExtension->CardCapabilities.etu );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RBSCSetCommParams(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG DataRate
    )
/*++

Routine Description:

    This routine sets the stop bits and read timeouts of the serial driver.

Arguments:
    SmartcardExtension - Pointer to our smartcard data

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    PSERIAL_LINE_CONTROL plc =
        &SmartcardExtension->ReaderExtension->LineControl;
    PSERIAL_TIMEOUTS timeout =
        &SmartcardExtension->ReaderExtension->SerialTimeouts;

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("RNBO3531!SetCommParams: DataRate=%ld, StopBits=%d\n",
        DataRate,SmartcardExtension->CardCapabilities.PtsData.StopBits)
        );

    plc->StopBits =
        (SmartcardExtension->CardCapabilities.PtsData.StopBits == 2) ?
          STOP_BITS_2 : STOP_BIT_1;

    status = RBSCSerialIo( SmartcardExtension,
                           IOCTL_SERIAL_SET_LINE_CONTROL,
                           (PUCHAR) plc,
                           sizeof(SERIAL_LINE_CONTROL),
                           0 );
    if( status != STATUS_SUCCESS )
    {
        return status;
    }

    if( SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries > 1 )
    {
        // Setup baudrate
        SERIAL_BAUD_RATE BaudRate;

        BaudRate.BaudRate = DataRate;
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_SET_BAUD_RATE,
                               (PUCHAR) &BaudRate,
                               sizeof(SERIAL_BAUD_RATE),
                               0 );
        if( status != STATUS_SUCCESS )
        {
            return status;
        }
    }

    if( SmartcardExtension->CardCapabilities.Protocol.Selected &
        SCARD_PROTOCOL_T1 )
    {
        timeout->ReadTotalTimeoutConstant = 2*      // for safty
            (SmartcardExtension->CardCapabilities.T1.BWT +
            WAIT_TIME_MINIMUM)/1000;

        timeout->ReadIntervalTimeout = 2*           // for safty
            (SmartcardExtension->CardCapabilities.T1.CWT +
            WAIT_TIME_MINIMUM)/1000;

    } else {

        timeout->ReadTotalTimeoutConstant =
        timeout->ReadIntervalTimeout = 2*           // for safty
            (SmartcardExtension->CardCapabilities.T0.WT +
            WAIT_TIME_MINIMUM)/1000;
    }

    //
    // Set up timeout (in msec)
    //
    return RBSCSerialIo( SmartcardExtension,
                         IOCTL_SERIAL_SET_TIMEOUTS,
                         (PUCHAR) timeout,
                         sizeof(SERIAL_TIMEOUTS),
                         0 );
}

NTSTATUS
RBSCReadFromCard(
    PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG Length
    )
/*++

Routine Description:

    Reads a block of data from the card.
    On successful read, it converts the data if inverse conversion used.

Arguments:

    SmartcardExtension - Pointer to smart card data.
    Length             - Number of bytes to read.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("RNBO3531!ReadFromCard(%ld)\n",Length)
        );

    status = RBSCSerialIo(
        SmartcardExtension,
        SMARTCARD_READ,
        NULL,
        0,
        Length
        );

    if( status == STATUS_SUCCESS &&
        SmartcardExtension->SmartcardReply.BufferLength != Length )
     {
        status = STATUS_IO_TIMEOUT;
     }

    if( SmartcardExtension->CardCapabilities.ATR.Buffer[0] == 0x3F )
    {
        ULONG i;
        for( i = 0; i < SmartcardExtension->SmartcardReply.BufferLength; i++ )
        {
            SmartcardExtension->SmartcardReply.Buffer[i] = InverseCharTable[
                SmartcardExtension->SmartcardReply.Buffer[i] ];
        }
    }


#if 0
    // The data dump here can time-out some cards
    DumpData( "Data from card",
               SmartcardExtension->SmartcardReply.Buffer,
               SmartcardExtension->SmartcardReply.BufferLength );

    SmartcardDebug(
        DEBUG_PROTOCOL,
        ("RNBO3531!ReadFromCard Exit %08X\n", status)
        );
#endif

    return status;
}

NTSTATUS
RBSCSerialEvents(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PREADER_EXTENSION ReaderExtension
    )
/*++

Routine Description:

    This routine is called in three cases:
    a) CTS changed (card inserted or removed) or
    b) DSR changed (reader has been removed) or
   c) The serial WaitMask is set to zero

    For a) we update the card status and complete outstanding
    card tracking requests.
    For b) and c) we start to unload the driver

Arguments:
    DeviceObject    - Pointer to device object
   Irp            - The notofication Irp
   ReaderExtension - Pointer to our device data

Return Value:

    NTSTATUS

--*/
{
    PSMARTCARD_EXTENSION SmartcardExtension = &ReaderExtension->SmartcardExtension;
    PIO_STACK_LOCATION nextsp;
    NTSTATUS status;
    KIRQL irql;

    UNREFERENCED_PARAMETER(DeviceObject);

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!SerialEvents: Enter\n")
        );

    KeAcquireSpinLock( &SmartcardExtension->OsData->SpinLock,
                       &irql );

    if( ReaderExtension->GetModemStatus )
    {
        //
        // This function requested the modem status previously.
        // As part of the io-completion, this function is then
        // called again. When we're here we can read the actual
        // modem-status to figure out if the card is in the reader
        //

#ifdef NT5
        if( (ReaderExtension->ModemStatus & SERIAL_DSR_STATE) == 0 )
        {
            SmartcardDebug(
                DEBUG_INFO,
                ("RNBO3531!SerialEvent: Reader removed\n")
                );

            //
            // We set the mask to zero to signal that we can
            // release the irp that we use for the serial events
            //
            ReaderExtension->WaitMask = 0;
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_UNKNOWN;

        } else
#endif
        {
            if( ReaderExtension->ModemStatus & SERIAL_CTS_STATE )
            {
                //
                // Card is inserted
                //
                SmartcardExtension->ReaderCapabilities.CurrentState =
                    SCARD_SWALLOWED;

                SmartcardExtension->CardCapabilities.Protocol.Selected =
                    SCARD_PROTOCOL_UNDEFINED;

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("RNBO3531!SerialEvents: Smart card inserted\n")
                    );

            } else {
                //
                // Card is removed
                //
                SmartcardExtension->CardCapabilities.ATR.Length = 0;

                SmartcardExtension->ReaderCapabilities.CurrentState =
                    SCARD_ABSENT;

                SmartcardExtension->CardCapabilities.Protocol.Selected =
                    SCARD_PROTOCOL_UNDEFINED;

                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("RNBO3531!SerialEvents: Smart card removed\n")
                    );
            }
        }
    }

    KeReleaseSpinLock( &SmartcardExtension->OsData->SpinLock, irql );

    if( SmartcardExtension->ReaderExtension->PowerRequest == FALSE )
    {
        // Inform the user of a card insertion/removal event
        RBSCCompleteCardTracking( SmartcardExtension );
    }

    // The wait mask is set to 0 when the driver unloads
    if( ReaderExtension->WaitMask == 0 )
    {
#ifdef NT5
        // schedule our remove thread
        IoQueueWorkItem(
         ReaderExtension->CloseSerial,
         (PIO_WORKITEM_ROUTINE) RBSCCloseSerialPort,
         DelayedWorkQueue,
         NULL
         );
#endif

        SmartcardDebug(
            DEBUG_INFO,
            ("RNBO3531!SerialEvent: Exit (Release IRP)\n")
            );

        ReaderExtension->PowerRequest = FALSE;

      //
        // We don't need the IRP anymore, so free it and tell the
      // io subsystem not to touch it anymore by returning the value below
      //
      IoFreeIrp(Irp);
      return STATUS_MORE_PROCESSING_REQUIRED;
    }

    nextsp = IoGetNextIrpStackLocation( ReaderExtension->SerialStatusIrp );

    nextsp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextsp->MinorFunction = 0UL;

    if( ReaderExtension->GetModemStatus )
    {
        nextsp->Parameters.DeviceIoControl.OutputBufferLength =
            sizeof(ReaderExtension->WaitMask);
        nextsp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_WAIT_ON_MASK;

        ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
            &ReaderExtension->WaitMask;

        ReaderExtension->GetModemStatus = FALSE;

        SmartcardDebug(
            DEBUG_DRIVER,
            ("RNBO3531!SerialEvents: IOCTL_SERIAL_WAIT_ON_MASK\n")
            );

    } else {

        //
        // Setup call for device control to get modem status.
        // The CTS signal tells us if the card is inserted or removed.
        // CTS is high if the card is inserted.
        //
        nextsp->Parameters.DeviceIoControl.OutputBufferLength =
            sizeof(ReaderExtension->ModemStatus);
        nextsp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_GET_MODEMSTATUS;

        ReaderExtension->SerialStatusIrp->AssociatedIrp.SystemBuffer =
            &ReaderExtension->ModemStatus;

        ReaderExtension->GetModemStatus = TRUE;

        SmartcardDebug(
            DEBUG_DRIVER,
            ("RNBO3531!SerialEvents: IOCTL_SERIAL_GET_MODEMSTATUS\n")
            );
    }

    IoSetCompletionRoutine( ReaderExtension->SerialStatusIrp,
                            RBSCSerialEvents,
                            ReaderExtension,
                            TRUE,
                            TRUE,
                            TRUE );

    status = IoCallDriver( ReaderExtension->AttachedSerialPort,
                           ReaderExtension->SerialStatusIrp );

    ReaderExtension->PowerRequest = FALSE;

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!SerialEvents: Exit\n")
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

#ifdef NT5
NTSTATUS
RBSCDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:
    This is our IOCTL dispatch function

Arguments:
    DeviceObject    - Pointer to device object

Return Value:
    NTSTATUS

--*/
{
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension =
        &ReaderExtension->SmartcardExtension;

    NTSTATUS status;
    KIRQL irql;

    if( ReaderExtension->WaitMask == 0 )
    {
        //
        // the wait mask is set to 0 whenever the device was either
        // surprise-removed or politely removed
        //
        status = STATUS_DEVICE_REMOVED;
    }
    else
    {
        KeAcquireSpinLock( &ReaderExtension->SpinLock, &irql );
        if( ReaderExtension->IoCount == 0 )
        {
            KeReleaseSpinLock( &ReaderExtension->SpinLock, irql );
            status = KeWaitForSingleObject( &ReaderExtension->ReaderStarted,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL );
            ASSERT( status == STATUS_SUCCESS );

            KeAcquireSpinLock( &ReaderExtension->SpinLock, &irql );
        }
        ASSERT( ReaderExtension->IoCount >= 0 );
        ReaderExtension->IoCount++;
        KeReleaseSpinLock( &ReaderExtension->SpinLock, irql );

        status = SmartcardAcquireRemoveLockWithTag( SmartcardExtension,
                                                    'tcoI' );
    }

    if (status != STATUS_SUCCESS)
    {
        // the device has been removed. Fail the call
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_REMOVED;
    }

    ASSERT(ReaderExtension->ReaderPowerState == PowerReaderWorking);

    status = SmartcardDeviceControl( SmartcardExtension, Irp );

    SmartcardReleaseRemoveLockWithTag( SmartcardExtension,'tcoI' );

    KeAcquireSpinLock( &ReaderExtension->SpinLock, &irql );
    ReaderExtension->IoCount--;
    ASSERT( ReaderExtension->IoCount >= 0 );
    KeReleaseSpinLock( &ReaderExtension->SpinLock, irql );

    return status;
}

#else

NTSTATUS
RBSCDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!DeviceControl: Enter (%lx)\n",
        IoGetCurrentIrpStackLocation( Irp )->MinorFunction)
        );

    return SmartcardDeviceControl(
        &((PREADER_EXTENSION)DeviceObject->DeviceExtension)->SmartcardExtension,
        Irp
        );
}

#endif

NTSTATUS
RBSCReaderPower(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called
    for certain power requests to the card.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    KIRQL oldIrql;
    ULONG step;

    //PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!ReaderPower: Enter (%lx)\n",
        SmartcardExtension->MinorIoControlCode)
        );

#define STEP_POWER_DOWN     0
#define STEP_COLD_RESET     (STEP_POWER_DOWN+2)
#define STEP_WARM_RESET     (STEP_COLD_RESET+10)

    switch( SmartcardExtension->MinorIoControlCode )
    {
        case SCARD_WARM_RESET:
            step = STEP_WARM_RESET;
            break;

        case SCARD_COLD_RESET:
            step = STEP_COLD_RESET;
            break;

        case SCARD_POWER_DOWN:
            step = STEP_POWER_DOWN;
            break;

        default :
            return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Since power down triggers the UpdateSerialStatus function, we have
    // to inform it that we forced the change of the status and not the user
    // (who might have removed and inserted a card)
    //
    ReaderExtension->PowerRequest = TRUE;

    do
    {
        switch( step++ )
        {
            case STEP_COLD_RESET+0:
            case STEP_POWER_DOWN+0:
                status = RBSCPacketExchange( SmartcardExtension,
                                             CardPowerDown,
                                             sizeof(CardPowerDown),
                                             WAIT_TIME_PWR_OFF,
                                             TRUE );
                break;

            case STEP_POWER_DOWN+1:
                if( SmartcardExtension->ReaderCapabilities.CurrentState >
                    SCARD_PRESENT )
                {
                    SmartcardExtension->ReaderCapabilities.CurrentState =
                        SCARD_PRESENT;
                }

                SmartcardExtension->CardCapabilities.Protocol.Selected =
                    SCARD_PROTOCOL_UNDEFINED;

                ReaderExtension->PowerRequest = FALSE;
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("RNBO3531!ReaderPower: Exit PowerDown OK\n")
                    );
                return STATUS_SUCCESS;

            case STEP_COLD_RESET+1:
            case STEP_WARM_RESET+0:
                status = RBSCSerialIo( SmartcardExtension,
                                       IOCTL_SERIAL_SET_DTR,
                                       NULL,
                                       0,
                                       0 );
                //RBSCDelay( 15000 );
                break;

            case STEP_COLD_RESET+2:
            case STEP_WARM_RESET+1:
                status = RBSCSerialIo( SmartcardExtension,
                                       IOCTL_SERIAL_SET_RTS,
                                       NULL,
                                       0,
                                       0 );
                // RBSCDelay( 15000 );
                break;

            case STEP_WARM_RESET+2:
            case STEP_COLD_RESET+3:
                //
                // Set up ATR timeouts (all in msec)
                //
                ReaderExtension->SerialTimeouts.ReadTotalTimeoutMultiplier = 1;
                ReaderExtension->SerialTimeouts.ReadIntervalTimeout = 2*
                    ATR_CHAR_TIMEOUT/1000;
                ReaderExtension->SerialTimeouts.ReadTotalTimeoutConstant = 2*
                    ATR_BLOCK_TIMEOUT/1000;

                status = RBSCSerialIo(
                    SmartcardExtension,
                    IOCTL_SERIAL_SET_TIMEOUTS,
                    (PUCHAR) &ReaderExtension->SerialTimeouts,
                    sizeof(SERIAL_TIMEOUTS),
                    0
                    );
                break;

            case STEP_WARM_RESET+3:
            case STEP_COLD_RESET+4:
                if( SmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries > 1 )
                {
                    // Setup default baudrate
                    SmartcardDebug(
                        DEBUG_TRACE,
                        ("RNBO3531!ReaderPower: Set DataRate=%ld\n",DATARATE_DEFAULT)
                        );
                    {
                        SERIAL_BAUD_RATE BaudRate;
                        BaudRate.BaudRate = DATARATE_DEFAULT;
                        status = RBSCSerialIo( SmartcardExtension,
                                            IOCTL_SERIAL_SET_BAUD_RATE,
                                            (PUCHAR) &BaudRate,
                                            sizeof(SERIAL_BAUD_RATE),
                                            0 );
                    }
                }
                break;

            case STEP_WARM_RESET+4:
            case STEP_COLD_RESET+5:
            RBSCDelay(15000);
                status = RBSCPacketExchange( SmartcardExtension,
                                             CardPowerUp,
                                             sizeof(CardPowerUp),
                                             0, //WAIT_TIME_PWR_ON,
                                             FALSE );
                break;

            case STEP_WARM_RESET+5:
            case STEP_COLD_RESET+6:
                //
                // Now read in part or all of the ATR
                //
                status = RBSCSerialIo( SmartcardExtension,
                                       SMARTCARD_READ,
                                       NULL,
                                       0,
                                       MAXIMUM_ATR_LENGTH );
                break;

            case STEP_WARM_RESET+6:
            case STEP_COLD_RESET+7:
            {
                ULONG i;
                if( SmartcardExtension->SmartcardReply.Buffer[0] == 0x03 )
                {
                    //
                    // Inverse convention (Inv(3F) = 03)
                    //
                    SmartcardExtension->CardCapabilities.ATR.Buffer[0] = 0x3F;
                    SmartcardExtension->CardCapabilities.ATR.Length = 1;
                }
                else
                if( SmartcardExtension->SmartcardReply.Buffer[0] == 0x3B )
                {
                    //
                    // Direct convention
                    //
                    SmartcardExtension->CardCapabilities.ATR.Buffer[0] = 0x3B;
                    SmartcardExtension->CardCapabilities.ATR.Length = 1;
                }
                else
                {
                    status = STATUS_UNRECOGNIZED_MEDIA;
                }

                for( i = 1; status == STATUS_SUCCESS; i = 0 )
                {
                    while( i <
                        SmartcardExtension->SmartcardReply.BufferLength &&
                        SmartcardExtension->CardCapabilities.ATR.Length <
                            MAXIMUM_ATR_LENGTH )
                    {
                        SmartcardExtension->CardCapabilities.ATR.Buffer[
                        SmartcardExtension->CardCapabilities.ATR.Length++ ] =
                        (SmartcardExtension->CardCapabilities.ATR.Buffer[0] == 0x3F) ?
                        InverseCharTable[
                        SmartcardExtension->SmartcardReply.Buffer[i] ] :
                        SmartcardExtension->SmartcardReply.Buffer[i];
                        i++;
                    }

                    //
                    // Check if ATR is complete
                    //
                    status = SmartcardUpdateCardCapabilities(
                  SmartcardExtension
                  );

                    if( status == STATUS_SUCCESS )
                    {
                        break;
                    }

                    //
                    // Read remaining bytes of ATR
                    //
                    status = RBSCSerialIo(
                        SmartcardExtension,
                        SMARTCARD_READ,
                        NULL,
                        0,
                        MAXIMUM_ATR_LENGTH -
                        SmartcardExtension->CardCapabilities.ATR.Length
                        );
                }
                break;
            }
            case STEP_WARM_RESET+7:
            case STEP_COLD_RESET+8:
                status = RBSCSetCommParams(
                    SmartcardExtension,
                    SmartcardExtension->CardCapabilities.PtsData.DataRate
                    );
                break;

            case STEP_WARM_RESET+8:
            case STEP_COLD_RESET+9:
                //RBSCDelay( 15000 );
                //
                // Make sure card is still in the reader.
                //
                if( (ReaderExtension->ModemStatus & SERIAL_CTS_STATE) == 0 )
                {
                    status = STATUS_NO_MEDIA;
                    break;
                }

                KeAcquireSpinLock( &SmartcardExtension->OsData->SpinLock,
                                   &oldIrql );

                //
                // Copy ATR to user space
                //
                if( SmartcardExtension->IoRequest.ReplyBuffer )
                {
                    RtlCopyMemory(
                        SmartcardExtension->IoRequest.ReplyBuffer,
                        SmartcardExtension->CardCapabilities.ATR.Buffer,
                        SmartcardExtension->CardCapabilities.ATR.Length
                        );

                    //
                    // Tell user length of ATR
                    //
                    *SmartcardExtension->IoRequest.Information =
                        SmartcardExtension->CardCapabilities.ATR.Length;
                }

                KeReleaseSpinLock( &SmartcardExtension->OsData->SpinLock,
                                   oldIrql );
                ReaderExtension->PowerRequest = FALSE;
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("RNBO3531!ReaderPower: Exit Reset OK\n")
                    );
                return STATUS_SUCCESS;

        }
    } while( status == STATUS_SUCCESS );

    //
    // Reset failed, make sure card is powered OFF
    //
    RBSCPacketExchange( SmartcardExtension,
                        CardPowerDown,
                        sizeof(CardPowerDown),
                        WAIT_TIME_PWR_OFF,
                        TRUE );

    SmartcardExtension->CardCapabilities.ATR.Length = 0;
    status = (ReaderExtension->ModemStatus & SERIAL_CTS_STATE) ?
          STATUS_UNRECOGNIZED_MEDIA :
          STATUS_NO_MEDIA;

    ReaderExtension->PowerRequest = FALSE;
    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!ReaderPower: Failed %08x\n",status)
        );

    return status;
}

NTSTATUS
RBSCSetProtocol(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called
    to set a particular protocol.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    UCHAR PtsRequest[8];
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!SetProtocol: Enter\n")
        );

    //
    // Check if the card is already in specific state
    // and if the caller wants to have the already selected protocol.
    // We return success if this is the case.
    //
    if( SmartcardExtension->ReaderCapabilities.CurrentState ==
        SCARD_SPECIFIC && (
        SmartcardExtension->CardCapabilities.Protocol.Selected &
        SmartcardExtension->MinorIoControlCode) )
    {
        status = STATUS_SUCCESS;

    } else
    while(TRUE)
    {
        PUCHAR reply = SmartcardExtension->SmartcardReply.Buffer;

        if( SmartcardExtension->CardCapabilities.Protocol.Supported &
            SmartcardExtension->MinorIoControlCode &
            SCARD_PROTOCOL_T1 )
        {
            PtsRequest[5] = 0x11;
            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_T1;

        } else if(
            SmartcardExtension->CardCapabilities.Protocol.Supported &
            SmartcardExtension->MinorIoControlCode &
            SCARD_PROTOCOL_T0 )
        {
            PtsRequest[5] = 0x10;
            SmartcardExtension->CardCapabilities.Protocol.Selected =
                SCARD_PROTOCOL_T0;
        } else {

            return STATUS_INVALID_DEVICE_REQUEST;
        }

        //
        // pts
        //
        PtsRequest[0] = IFDCMD_HEADER1;
        PtsRequest[1] = IFDCMD_HEADER2;
        PtsRequest[2] = IFDCMD_SEND_0xx;
        PtsRequest[3] = 4;                 // Length
        PtsRequest[4] = 0xff;              // PTS
        PtsRequest[6] =                    // set pts1 which codes Fl and Dl
            (SmartcardExtension->CardCapabilities.PtsData.Fl << 4) |
            SmartcardExtension->CardCapabilities.PtsData.Dl;
        //
        // pck (check character)
        //
        PtsRequest[7] = PtsRequest[4] ^ PtsRequest[5] ^ PtsRequest[6];

        status = RBSCPacketExchange( SmartcardExtension,
                                     PtsRequest,
                                     4,
                                     0,
                                     FALSE );
        if( status == STATUS_SUCCESS )
        {
            status = RBSCWriteToCard( SmartcardExtension, PtsRequest+4, 4 );
            if( status == STATUS_SUCCESS )
            {
                status = RBSCReadFromCard( SmartcardExtension, 4 );
            }
        }

        if( status == STATUS_SUCCESS &&
            reply[0] == PtsRequest[4] &&
            ((reply[1] ^ PtsRequest[5]) & 0x0f) == 0 )
        {
            //
            // Update the current protocol
            //
            SmartcardExtension->ReaderCapabilities.CurrentState =
                SCARD_SPECIFIC;

            status = RBSCSetCommParams(
                SmartcardExtension,
                SmartcardExtension->CardCapabilities.PtsData.DataRate
                );

        } else {

            if (status == STATUS_IO_TIMEOUT &&
                SmartcardExtension->CardCapabilities.PtsData.Type !=
                PTS_TYPE_DEFAULT)
            {
                SmartcardDebug(
                    DEBUG_TRACE,
                    ("RNBO3531!SetProtocol: PTS failed. Trying default parameters...\n")
                    );
                //
                // The card did either NOT reply or it replied incorrectly
                // so try default values
                //
                SmartcardExtension->CardCapabilities.PtsData.Type =
                    PTS_TYPE_DEFAULT;

                SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;

                status = RBSCReaderPower( SmartcardExtension );
                if( status == STATUS_SUCCESS )
                    continue;
            }

            status = STATUS_DEVICE_PROTOCOL_ERROR;
        }
        break;
    }

    if( status != STATUS_SUCCESS )
    {
        SmartcardExtension->CardCapabilities.Protocol.Selected =
            SCARD_PROTOCOL_UNDEFINED;

    } else {

        //
        // return the selected protocol to the caller
        //
        *(PULONG) SmartcardExtension->IoRequest.ReplyBuffer =
            SmartcardExtension->CardCapabilities.Protocol.Selected;

        *SmartcardExtension->IoRequest.Information =
            sizeof(SmartcardExtension->CardCapabilities.Protocol.Selected);
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!SetProtocol: Exit\n")
        );

   return status;
}

NTSTATUS
RBSCPacketExchange(
    PSMARTCARD_EXTENSION SmartcardExtension,
    PUCHAR  Command,
    ULONG   Length,
    ULONG   WaitTime,
    BOOLEAN IfdResponse
    )
/*++

Routine Description:

    This function is used to transmit a command to the reader (not card)
    and return the response (if asked).

Arguments:

    SmartcardExtension - Pointer to smart card data struct.
    Command            - Points to the IFD command to send
    Length             - Length of the command in bytes
    WaitTime           - Waiting time expected (in microseconds)
    IfdResponse        - When TRUE, IFD response is expected (vs card)

Return Value:

    NTSTATUS

--*/
{
    PUCHAR reply = SmartcardExtension->SmartcardReply.Buffer;
    ULONG  SerialRequest = SERIAL_PURGE_RXCLEAR | SERIAL_PURGE_TXCLEAR;
    ULONG  ResponseSize;
    NTSTATUS status;
    int    TrySend;

    DumpData( "PacketExchange", Command, Length );

    for( TrySend = 0; TrySend < 4; TrySend++ )
    {
        //
        // start with clean buffers
        //
        status = RBSCSerialIo( SmartcardExtension,
                               IOCTL_SERIAL_PURGE,
                               (PUCHAR) &SerialRequest,
                               sizeof(ULONG),
                               0 );

        if( status == STATUS_SUCCESS )
        {
            status = RBSCSerialIo( SmartcardExtension,
                                   SMARTCARD_WRITE,
                                   Command,
                                   Length,
                                   0 );

            if( status == STATUS_SUCCESS && WaitTime != 0 )
                RBSCDelay( WaitTime );
        }

        if( status == STATUS_SUCCESS && IfdResponse )
        {
            status = RBSCSerialIo( SmartcardExtension,
                                   SMARTCARD_READ,
                                   NULL,
                                   0,
                                   IFDRSP_HEADER_SIZE );
            if( status != STATUS_SUCCESS ||
                SmartcardExtension->SmartcardReply.BufferLength !=
                IFDRSP_HEADER_SIZE )
            {
                continue;
            }

            DumpData( "PacketExchange: Received Header",
                      reply,
                      IFDRSP_HEADER_SIZE );
            //
            // We should have the marker plus the status/length byte
            //
            if( reply[0] != IFDRSP_MARKER )
            {
                status = STATUS_DEVICE_DATA_ERROR;
                continue;
            }

            ResponseSize = (ULONG)reply[1];

            if( ResponseSize > 0 && ResponseSize < IFDRSP_ACK )
            {
                status = RBSCSerialIo( SmartcardExtension,
                                       SMARTCARD_READ,
                                       NULL,
                                       0,
                                       ResponseSize );
                if( status == STATUS_SUCCESS &&
                    SmartcardExtension->SmartcardReply.BufferLength !=
                    ResponseSize )
                {
                    status = STATUS_DEVICE_DATA_ERROR;
                }

                DumpData( "PacketExchange: Received Data",
                          SmartcardExtension->SmartcardReply.Buffer,
                          SmartcardExtension->SmartcardReply.BufferLength );
            }
            else
            {
                //
                // Map IFD errors
                //
                switch( ResponseSize )
                {
                    case IFDRSP_ACK    : return STATUS_SUCCESS;
                    case IFDRSP_NOCARD : return STATUS_NO_MEDIA;
                    case IFDRSP_BADCMD : return STATUS_INVALID_DEVICE_REQUEST;
                    case IFDRSP_PARITY :
                    default :
                        status = STATUS_DEVICE_DATA_ERROR;
                        break;
                }
            }
        }

        if( status == STATUS_SUCCESS)
            return STATUS_SUCCESS;
    }

    SmartcardExtension->SmartcardReply.BufferLength = 0;
    return status;
}

NTSTATUS
RBSCT0Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function performs the T=0 transmission.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    PREADER_EXTENSION ReaderExtension = SmartcardExtension->ReaderExtension;
    NTSTATUS status;
    PUCHAR RxBuffer = SmartcardExtension->SmartcardReply.Buffer;
    PUCHAR TxBuffer = SmartcardExtension->SmartcardRequest.Buffer;
    ULONG  RxLength, TxLength, RequestSize;
    UCHAR  SendHeader[4], Ins, ProcByte;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!T0Transmit: Enter\n")
        );

    //
    // Tell the lib function how many bytes I need for the prologue
    //
    SmartcardExtension->SmartcardRequest.BufferLength = 0;

    //
    // Let the lib build a T=0 packet
    //
    status = SmartcardT0Request( SmartcardExtension );

    if( status != STATUS_SUCCESS )
        return status;

    TxLength = SmartcardExtension->SmartcardRequest.BufferLength;

    if( TxLength < 5 || TxLength > 0x1ff )
    {
        return STATUS_DEVICE_DATA_ERROR;
    }

    //
    // The number of bytes we expect from the card
    // is Le + 2 status bytes
    //
    RxLength = SmartcardExtension->T0.Le + 2;

    //
    // Write command to the reader
    //
    Ins = TxBuffer[1];  // INS

    RequestSize = 5;

    for( ;; )
    {
        if( TxLength > 0 )
        {
            SendHeader[0] = IFDCMD_HEADER1;
            SendHeader[1] = IFDCMD_HEADER2;
            SendHeader[2] = (RequestSize > 256) ?
                IFDCMD_SEND_1xx : IFDCMD_SEND_0xx;
            SendHeader[3] = (UCHAR)RequestSize; // 0=256

            status = RBSCPacketExchange(
                SmartcardExtension,
                SendHeader,
                4,
                0,
                FALSE
                );

            if( status != STATUS_SUCCESS)
            {
                break;
            }

            status = RBSCWriteToCard(
                SmartcardExtension,
                TxBuffer,
                RequestSize
                );

            if( status != STATUS_SUCCESS)
            {
                break;
            }

            TxLength -= RequestSize;
            TxBuffer += RequestSize;
        }

        do
        {
            status = RBSCReadFromCard( SmartcardExtension, 1 ); // Proc. byte

            if( status != STATUS_SUCCESS )
            {
                break;
            }

            ProcByte = SmartcardExtension->SmartcardReply.Buffer[0];

            SmartcardDebug(
                DEBUG_TRACE,
                ("RNBO3531!ProcByte=%02x Ins=%02x\n",ProcByte,Ins)
                );

        } while( ProcByte == 0x60);

        if( status != STATUS_SUCCESS )
        {
            break;
        }

        if( ProcByte == Ins || ProcByte == (UCHAR)(Ins+1) )
        {
            //
            // Send all remaining bytes
            //
            if( TxLength > 0 )
            {
                RequestSize = TxLength;
                continue;
            }
            RequestSize = RxLength;
        }
        else if( ProcByte == (UCHAR)~Ins || ProcByte == (UCHAR)~(Ins+1) )
        {
            //
            // Send 1 byte only
            //
            RequestSize = 1;
            if( TxLength > 0 )
            {
                continue;
            }
        }
        else
        {
            //
            // Card returned status byte
            //
            SmartcardExtension->SmartcardReply.Buffer++;
            TxLength = 0;
            RxLength = 1;               // Second byte of status (SW2)
            RequestSize = 1;
        }

        status = RBSCReadFromCard( SmartcardExtension, RequestSize );

        if( status != STATUS_SUCCESS )
        {
            break;
        }

        SmartcardExtension->SmartcardReply.Buffer += RequestSize;
        RxLength -= RequestSize;

        if( RxLength == 0 )
        {
            break;
        }
    }

    //
    // Restore reply buffer pointer
    //
    SmartcardExtension->SmartcardReply.BufferLength =
        (ULONG) (SmartcardExtension->SmartcardReply.Buffer - RxBuffer);

    SmartcardExtension->SmartcardReply.Buffer = RxBuffer;

    if( status == STATUS_SUCCESS )
    {
        status = SmartcardT0Reply( SmartcardExtension );
    }

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!T0Transmit: Exit (%lx)\n",status)
        );

    return status;
}

NTSTATUS
RBSCT1Transmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function performs the T=1 transmission.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;
    UCHAR    SendHeader[4];

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!T1Transmit: Enter\n")
        );

    do
    {
        PUCHAR TxBuffer = SmartcardExtension->SmartcardRequest.Buffer;
        PUCHAR reply = SmartcardExtension->SmartcardReply.Buffer;
        ULONG  TxLength;

        //
        // Tell the lib function how many bytes I need for the prologue
        //
        SmartcardExtension->SmartcardRequest.BufferLength = 0;

        status = SmartcardT1Request( SmartcardExtension );

        if( status != STATUS_SUCCESS )
        {
            break;
        }

        TxLength = SmartcardExtension->SmartcardRequest.BufferLength;
        //RBSCDelay( SmartcardExtension->CardCapabilities.T1.BGT );

        //
        // Write the command to the reader
        //
        SendHeader[0] = IFDCMD_HEADER1;
        SendHeader[1] = IFDCMD_HEADER2;
        SendHeader[2] = (UCHAR)(TxLength > 256) ?
            IFDCMD_SEND_1xx : IFDCMD_SEND_0xx;
        SendHeader[3] = (UCHAR)TxLength;    // 0=256

        status = RBSCPacketExchange( SmartcardExtension,
                                     SendHeader,
                                     4,
                                     0,
                                     FALSE );
        if( status != STATUS_SUCCESS )
        {
            break;
        }

        status = RBSCWriteToCard( SmartcardExtension, TxBuffer, TxLength );
        if( status != STATUS_SUCCESS )
        {
            break;
        }

        if( SmartcardExtension->T1.Wtx > 1 )
        {
            SmartcardDebug(
                DEBUG_PROTOCOL,
                ("BWT=%ld, WTX=%d\n",
                SmartcardExtension->CardCapabilities.T1.BWT,
                SmartcardExtension->T1.Wtx)
                );
            RBSCDelay(
                SmartcardExtension->CardCapabilities.T1.BWT*
                SmartcardExtension->T1.Wtx );
        }

        status = RBSCReadFromCard( SmartcardExtension, 3 );

        if( status == STATUS_IO_TIMEOUT )
        {
            //
            // Since the card did not reply we set the number of
            // bytes received to 0. This will trigger a resend
            // request
            //
            SmartcardDebug(
                DEBUG_PROTOCOL,
                ("RNBO3531!T1Transmit: Timeout\n")
                );
            SmartcardExtension->SmartcardReply.BufferLength = 0;
        } else {

            if( status != STATUS_SUCCESS )
            {
                break;
            }

            //
            // Calculate length of the INF part of the response
            //
            SmartcardExtension->SmartcardReply.BufferLength =
                SmartcardExtension->SmartcardReply.Buffer[2] +
                (SmartcardExtension->CardCapabilities.T1.EDC & 1) + 1;

            SmartcardExtension->SmartcardReply.Buffer += 3;

            status = RBSCReadFromCard(
                SmartcardExtension,
                SmartcardExtension->SmartcardReply.BufferLength );

            SmartcardExtension->SmartcardReply.Buffer -= 3;
            SmartcardExtension->SmartcardReply.BufferLength += 3;

            if( status != STATUS_SUCCESS && status != STATUS_IO_TIMEOUT )
            {
                break;
            }
        }

        status = SmartcardT1Reply( SmartcardExtension );

    } while( status == STATUS_MORE_PROCESSING_REQUIRED );

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!T1Transmit: Exit (%lx)\n",status)
        );

    return status;
}

NTSTATUS
RBSCTransmit(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    This function is called by the smart card library whenever a transmission
    is required.

Arguments:

    SmartcardExtension - Pointer to smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    SmartcardDebug(
        DEBUG_TRACE,
        ("RNBO3531!Transmit: GT=%ld, etu=%ld\n",
        SmartcardExtension->CardCapabilities.GT,
        SmartcardExtension->CardCapabilities.etu)
        );

    switch( SmartcardExtension->CardCapabilities.Protocol.Selected )
    {
        case SCARD_PROTOCOL_T0:
            return RBSCT0Transmit( SmartcardExtension );

        case SCARD_PROTOCOL_T1:
            return RBSCT1Transmit( SmartcardExtension );
    }

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
RBSCCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:

    The smart card lib requires to have this function. It is called
    to setup event tracking for card insertion and removal events.

Arguments:

    SmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

--*/
{
    KIRQL ioIrql, keIrql;

    //
    // Set cancel routine for the notification irp
    //
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &keIrql
        );

    IoAcquireCancelSpinLock( &ioIrql );

    if( SmartcardExtension->OsData->NotificationIrp )
    {
        IoSetCancelRoutine( SmartcardExtension->OsData->NotificationIrp,
                            RBSCCancel );
    }

    IoReleaseCancelSpinLock( ioIrql );

    KeReleaseSpinLock( &SmartcardExtension->OsData->SpinLock,
                       keIrql );

    return STATUS_PENDING;
}

VOID
RBSCCompleteCardTracking(
    PSMARTCARD_EXTENSION SmartcardExtension
    )
{
    KIRQL ioIrql, keIrql;
    PIRP notificationIrp;

    IoAcquireCancelSpinLock(&ioIrql);
    KeAcquireSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        &keIrql
        );

    notificationIrp = SmartcardExtension->OsData->NotificationIrp;
    SmartcardExtension->OsData->NotificationIrp = NULL;

    KeReleaseSpinLock(
        &SmartcardExtension->OsData->SpinLock,
        keIrql
        );

    if (notificationIrp)
    {
        IoSetCancelRoutine(
            notificationIrp,
            NULL
            );
    }

    IoReleaseCancelSpinLock(ioIrql);

    if (notificationIrp)
    {
      SmartcardDebug(
         DEBUG_DRIVER,
         ("%s!RBSCCardTracking: Completing NotificationIrp %lxh\n",
            DRIVER_NAME,
            notificationIrp)
         );

       //   finish the request
        notificationIrp->IoStatus.Information = 0;
        notificationIrp->IoStatus.Status = notificationIrp->Cancel ?
            STATUS_CANCELLED : STATUS_SUCCESS;

       IoCompleteRequest(
            notificationIrp,
            IO_NO_INCREMENT
            );
    }
}

#ifdef NT5
VOID
RBSCCloseSerialPort(
    PDEVICE_OBJECT DeviceObject,
   PVOID Context
    )
/*++

Routine Description:
    This function closes the connection to the serial driver when the reader
    has been removed (unplugged). This function runs as a system thread at
    IRQL == PASSIVE_LEVEL. It waits for the remove event that is set by
    the IoCompletionRoutine

--*/
{
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION stack;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // first mark this device as 'gone'.
    // This will prevent that someone can re-open the device
    //
    status = IoSetDeviceInterfaceState( &ReaderExtension->PnPDeviceName,
                                        FALSE );
    ASSERT( status == STATUS_SUCCESS );

    irp = IoAllocateIrp( (CCHAR)(DeviceObject->StackSize + 1), FALSE );

    ASSERT( irp != NULL );

    if( irp )
    {
        SmartcardDebug(
            DEBUG_TRACE,
            ("RNBO3531!CloseSerialPort: Sending IRP_MJ_CLOSE\n")
            );

        IoSetNextIrpStackLocation( irp );

        //
        // We send down a close to the serial driver. This close goes
        // through serenum first which will trigger it to start looking
        // for changes on the com-port. Since our device is gone it will
        // call the device removal event of our PnP dispatch.
        //
        irp->UserIosb = &ioStatusBlock;
        stack = IoGetCurrentIrpStackLocation( irp );
        stack->MajorFunction = IRP_MJ_CLOSE;

        status = RBSCCallSerialDriver(
            ReaderExtension->AttachedSerialPort,
            irp );

        ASSERT( status == STATUS_SUCCESS );

        IoFreeIrp( irp );
    }

    SmartcardDebug(
        DEBUG_INFO,
        ("RNBO3531!CloseSerialPort: Serial Close Done.\n")
        );

    // inform the remove function that call is complete
    KeSetEvent( &ReaderExtension->SerialCloseDone, 0, FALSE );
}

NTSTATUS
RBSCDevicePowerCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMARTCARD_EXTENSION SmartcardExtension
    )
/*++

Routine Description:
    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.

--*/
{
    PREADER_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // We issue a power request in order to figure out
    // what the actual card status is
    //
    SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
    RBSCReaderPower( SmartcardExtension );

    //
    // If a card was present before power down or now there is
    // a card in the reader, we complete any pending card monitor
    // request, since we do not really know what card is now in the
    // reader.
    //
    if( SmartcardExtension->ReaderExtension->CardPresent ||
        SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT )
    {
        RBSCCompleteCardTracking( SmartcardExtension );
    }

    // save the current power state of the reader
    SmartcardExtension->ReaderExtension->ReaderPowerState =
        PowerReaderWorking;

    SmartcardReleaseRemoveLockWithTag( SmartcardExtension, 'rwoP' );

    // inform the power manager of our state.
    PoSetPowerState( DeviceObject,
                     DevicePowerState,
                     irpStack->Parameters.Power.State );

    PoStartNextPowerIrp( Irp );

    // signal that we can process ioctls again
    KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);

    return STATUS_SUCCESS;
}

VOID
RBSCSystemPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function is called when the underlying stacks
    completed the power transition.

--*/
{
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER (MinorFunction);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = IoStatus->Status;

    SmartcardReleaseRemoveLockWithTag( &ReaderExtension->SmartcardExtension,
                                       'rwoP' );

    if (PowerState.SystemState == PowerSystemWorking)
    {
        PoSetPowerState( DeviceObject,
                         SystemPowerState,
                         PowerState );
    }

    PoStartNextPowerIrp( Irp );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
}

typedef enum _ACTION {

    Undefined = 0,
    SkipRequest,
    WaitForCompletion,
    CompleteRequest,
    MarkPending

} ACTION;

NTSTATUS
RBSCPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    The power dispatch routine.
    All we care about is the transition from a low D state to D0.

Arguments:
    DeviceObject    - Pointer to device object
    Irp             - pointer to an I/O Request Packet.

Return Value:
    NT status code

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PREADER_EXTENSION ReaderExtension = DeviceObject->DeviceExtension;
    PSMARTCARD_EXTENSION SmartcardExtension =
        &ReaderExtension->SmartcardExtension;
    PDEVICE_OBJECT AttachedSerialPort;
    POWER_STATE powerState;
    ACTION action;

    SmartcardDebug(
        DEBUG_DRIVER,
        ("RNBO3531!3Power: Enter\n")
        );

    status = SmartcardAcquireRemoveLockWithTag( SmartcardExtension, 'rwoP' );
    ASSERT( status == STATUS_SUCCESS );

    if( !NT_SUCCESS( status ) )
    {
        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    AttachedSerialPort = ReaderExtension->AttachedSerialPort;

    if (irpStack->Parameters.Power.Type == DevicePowerState &&
        irpStack->MinorFunction == IRP_MN_SET_POWER )
    {
        switch( irpStack->Parameters.Power.State.DeviceState )
        {
            case PowerDeviceD0:
                // Turn on the reader
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("RNBO3531!Power: PowerDevice D0\n")
                    );

                //
                // First, we send down the request to the bus, in order
                // to power on the port. When the request completes,
                // we turn on the reader
                //
                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine (
                    Irp,
                    RBSCDevicePowerCompletion,
                    SmartcardExtension,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                action = WaitForCompletion;
                break;

            case PowerDeviceD3:
                // Turn off the reader
                SmartcardDebug(
                    DEBUG_DRIVER,
                    ("RNBO3531!Power: PowerDevice D3\n")
                    );

                PoSetPowerState (
                    DeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State
                    );

                // save the current card state
                ReaderExtension->CardPresent =
                    SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

                if( ReaderExtension->CardPresent )
                {
                    SmartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
                    status = RBSCReaderPower( SmartcardExtension );
                    ASSERT(status == STATUS_SUCCESS);
                }

                //
                // If there is a pending card tracking request, setting
                // this flag will prevent completion of the request
                // when the system will be waked up again.
                //
                ReaderExtension->PowerRequest = TRUE;

                // save the current power state of the reader
                ReaderExtension->ReaderPowerState = PowerReaderOff;

                action = SkipRequest;
                break;

            default:
                ASSERT(FALSE);
                action = SkipRequest;
                break;
        }
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        //
        // The system wants to change the power state.
        // We need to translate the system power state to
        // a corresponding device power state.
        //

        POWER_STATE_TYPE powerType = DevicePowerState;

        ASSERT(ReaderExtension->ReaderPowerState != PowerReaderUnspecified);

        switch(irpStack->MinorFunction)
        {
        KIRQL irql;

        case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!Power: Query Power\n")
                );

            //
            // By default we succeed and pass down
            //

            action = SkipRequest;
            Irp->IoStatus.Status = STATUS_SUCCESS;

            switch (irpStack->Parameters.Power.State.SystemState)
            {
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
                KeAcquireSpinLock(&ReaderExtension->SpinLock, &irql);
                if (ReaderExtension->IoCount == 0)
                {
                    // Block any further ioctls
                    KeClearEvent(&ReaderExtension->ReaderStarted);

                } else {

                    // can't go to sleep mode since the reader is busy.
                    status = STATUS_DEVICE_BUSY;
                    action = CompleteRequest;
                }
                KeReleaseSpinLock(&ReaderExtension->SpinLock, irql);
                break;
            }
            break;

        case IRP_MN_SET_POWER:

            SmartcardDebug(
                DEBUG_DRIVER,
                ("RNBO3531!Power: PowerSystem S%d\n",
                irpStack->Parameters.Power.State.SystemState - 1)
                );

            switch (irpStack->Parameters.Power.State.SystemState)
            {
            case PowerSystemMaximum:
            case PowerSystemWorking:
            case PowerSystemSleeping1:
            case PowerSystemSleeping2:

                if (SmartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderWorking) {

                    // We're already in the right state
                    action = CompleteRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD0;

                // wake up the underlying stack...
                action = MarkPending;
                break;

            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:

                if (SmartcardExtension->ReaderExtension->ReaderPowerState ==
                    PowerReaderOff) {

                    // We're already in the right state
                    action = CompleteRequest;
                    break;
                }

                powerState.DeviceState = PowerDeviceD3;

                // first, inform the power manager of our new state.
                PoSetPowerState (
                    DeviceObject,
                    SystemPowerState,
                    powerState
                    );
                action = MarkPending;
                break;

            default:
                ASSERT(FALSE);
                action = CompleteRequest;
                break;
            }
        }
    }

    switch( action )
    {
        case CompleteRequest:
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            SmartcardReleaseRemoveLockWithTag( SmartcardExtension, 'rwoP' );
            PoStartNextPowerIrp( Irp );
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;

        case MarkPending:
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending( Irp );
            status = PoRequestPowerIrp (
                DeviceObject,
                IRP_MN_SET_POWER,
                powerState,
                RBSCSystemPowerCompletion,
                Irp,
                NULL
                );
            ASSERT(status == STATUS_PENDING);
            break;

        case SkipRequest:
            SmartcardReleaseRemoveLockWithTag( SmartcardExtension, 'rwoP' );
            PoStartNextPowerIrp( Irp );
            IoSkipCurrentIrpStackLocation( Irp );
            status = PoCallDriver( AttachedSerialPort, Irp );
            break;

        case WaitForCompletion:
            status = PoCallDriver( AttachedSerialPort, Irp );
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    SmartcardDebug(
        DEBUG_DRIVER,
        ("RNBO3531!Power: Exit %lx\n",status)
        );

    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmn50m\sccmcb.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmcb.c $
* $Revision: 1.7 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#include <stdio.h>
#include "sccmn50m.h"




static ULONG dataRatesSupported[]      = {9600,38400};
static ULONG CLKFrequenciesSupported[] = {4000,5000};


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CardPower(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS DebugStatus = STATUS_SUCCESS;
   UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
   UCHAR  abSyncAtrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength;
#if DBG
   ULONG i;
#endif;



   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CardPower: Enter\n",
                   DRIVER_NAME)
                 );

#if DBG
   switch (pSmartcardExtension->MinorIoControlCode)
      {
      case SCARD_WARM_RESET:
         SmartcardDebug(
                       DEBUG_ATR,
                       ( "%s!SCARD_WARM_RESTART\n",
                         DRIVER_NAME)
                       );
         break;
      case SCARD_COLD_RESET:
         SmartcardDebug(
                       DEBUG_ATR,
                       ( "%s!SCARD_COLD_RESTART\n",
                         DRIVER_NAME)
                       );
         break;
      case SCARD_POWER_DOWN:
         SmartcardDebug(
                       DEBUG_ATR,
                       ( "%s!SCARD_POWER_DOWN\n",
                         DRIVER_NAME)
                       );
         break;
      }
#endif

   //DbgBreakPoint();

   switch (pSmartcardExtension->MinorIoControlCode)
      {
      case SCARD_WARM_RESET:
      case SCARD_COLD_RESET:
         status = SCCMN50M_PowerOn(pSmartcardExtension,
                                   &ulAtrLength,
                                   pbAtrBuffer,
                                   sizeof(pbAtrBuffer));
         if (status != STATUS_SUCCESS)
            {
            goto ExitReaderPower;
            }

         pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

         if (pSmartcardExtension->ReaderExtension->fRawModeNecessary == FALSE)
            {
            // copy ATR to smart card structure
            // the lib needs the ATR for evaluation of the card parameters

            MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
                   sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
                   pbAtrBuffer,
                   ulAtrLength);

            pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)ulAtrLength;

            pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_NEGOTIABLE;
            pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
            if (status != STATUS_SUCCESS)
               {
               goto ExitReaderPower;
               }

            // add extra guard time value to card stop bits
            pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = (UCHAR)(pSmartcardExtension->CardCapabilities.N);

            // copy ATR to user space
            MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
                   pSmartcardExtension->IoRequest.ReplyBufferLength,
                   pbAtrBuffer,
                   ulAtrLength);

            *pSmartcardExtension->IoRequest.Information = ulAtrLength;
#if DBG
            SmartcardDebug(DEBUG_ATR,
                           ("%s!ATR : ",
                            DRIVER_NAME));
            for (i = 0;i < ulAtrLength;i++)
               {
               SmartcardDebug(DEBUG_ATR,
                              ("%2.2x ",
                               pSmartcardExtension->CardCapabilities.ATR.Buffer[i]));
               }
            SmartcardDebug(DEBUG_ATR,("\n"));

#endif

            }
         else
            {
            abSyncAtrBuffer[0] = 0x3B;
            abSyncAtrBuffer[1] = 0x04;
            MemCpy(&abSyncAtrBuffer[2],
                   sizeof(abSyncAtrBuffer)-2,
                   pbAtrBuffer,
                   ulAtrLength);


            ulAtrLength += 2;

            MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
                   sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
                   abSyncAtrBuffer,
                   ulAtrLength);

            pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)(ulAtrLength);

            pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
            pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;

            status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
            if (status != STATUS_SUCCESS)
               {
               goto ExitReaderPower;
               }
            SmartcardDebug(DEBUG_ATR,("ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                                      pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));
            pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;

            // copy ATR to user space
            MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
                   pSmartcardExtension->IoRequest.ReplyBufferLength,
                   abSyncAtrBuffer,
                   ulAtrLength);

            *pSmartcardExtension->IoRequest.Information = ulAtrLength;
            }

         break;

      case SCARD_POWER_DOWN:
         status = SCCMN50M_PowerOff(pSmartcardExtension);
         if (status != STATUS_SUCCESS)
            {
            goto ExitReaderPower;
            }


         pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
         pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

         break;
      }



   ExitReaderPower:

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CardPower: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PowerOn (
                 IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                 OUT   PULONG pulAtrLength,
                 OUT   PUCHAR pbAtrBuffer,
                 IN    ULONG  ulAtrBufferSize
                 )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;


   // We always use 0x80 for reset delay
   pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay = 0x80;


   if (SCCMN50M_IsAsynchronousSmartCard(pSmartcardExtension) == TRUE)
      {
      if (pSmartcardExtension->MinorIoControlCode == SCARD_COLD_RESET)
         {
         status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                    pulAtrLength,
                                                    pbAtrBuffer,
                                                    ulAtrBufferSize,
                                                    FALSE);
         // if cold reset was not succesfull ,it maybe a SAMOS card with the sensor bug
         if (status != STATUS_SUCCESS)
            {
            status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                       pulAtrLength,
                                                       pbAtrBuffer,
                                                       ulAtrBufferSize,
                                                       TRUE);

            if (status != STATUS_SUCCESS)
               {
               status = SCCMN50M_UseParsingStrategy(pSmartcardExtension,
                                                    pulAtrLength,
                                                    pbAtrBuffer,
                                                    ulAtrBufferSize);
               }
            }
         }
      else
         {
         status = SCCMN50M_UseColdWarmResetStrategy(pSmartcardExtension,
                                                    pulAtrLength,
                                                    pbAtrBuffer,
                                                    ulAtrBufferSize,
                                                    TRUE);
         if (status != STATUS_SUCCESS)
            {
            status = SCCMN50M_UseParsingStrategy(pSmartcardExtension,
                                                 pulAtrLength,
                                                 pbAtrBuffer,
                                                 ulAtrBufferSize);
            }
         }
      }
   else
      {
      SmartcardDebug(DEBUG_ATR,
                     ("check if synchronous smart card is inserted\n"));
      // try to find a synchronous smart card
      status = SCCMN50M_UseSyncStrategy(pSmartcardExtension,
                                        pulAtrLength,
                                        pbAtrBuffer,
                                        ulAtrBufferSize);
      }




   if (status != STATUS_SUCCESS)
      {
      // smart card not powered
      status = STATUS_UNRECOGNIZED_MEDIA;
      *pulAtrLength = 0;
      DebugStatus = SCCMN50M_PowerOff(pSmartcardExtension);
      return status;
      }
   else
      {
      // add extra guard time value to card stop bits
      pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = (UCHAR)(pSmartcardExtension->CardCapabilities.N);
      return status;
      }

}







/*****************************************************************************
Routine Description:
This routine inverts the buffer
Bit0 -> Bit 7
Bit1 -> Bit 6
Bit2 -> Bit 5
Bit3 -> Bit 4
Bit4 -> Bit 3
Bit5 -> Bit 2
Bit6 -> Bit 1
Bit7 -> Bit 0


Arguments: pbBuffer     ... pointer to buffer
           ulBufferSize ... size of buffer


Return Value: none

*****************************************************************************/
VOID SCCMN50M_InverseBuffer (
                            PUCHAR pbBuffer,
                            ULONG  ulBufferSize
                            )
{
   ULONG i;
   ULONG j;
   ULONG m;
   ULONG n;

   for (i=0; i<ulBufferSize; i++)
      {
      n = 0;
      for (j=1; j<=8; j++)
         {
         m  = (pbBuffer[i] << j);
         m &= 0x00000100;
         n  |= (m >> (9-j));
         }
      pbBuffer[i] = (UCHAR)~n;
      }

   return;
}







/*****************************************************************************
Routine Description:

This function always permforms a cold reset of the smart card.
A SAMOS card with the sensor bug will not be powered by this function.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseParsingStrategy (IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                             OUT   PULONG pulAtrLength,
                             OUT   PUCHAR pbAtrBuffer,
                             IN    ULONG  ulAtrBufferSize
                            )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   UCHAR  ulCardType;
   UCHAR  ReadBuffer[SCARD_ATR_LENGTH];
   UCHAR  bAtrBytesRead[SCARD_ATR_LENGTH];
   ULONG  ulBytesRead;
   BOOLEAN    fInverseAtr = FALSE;
   ULONG  ulAtrBufferOffset = 0;
   ULONG  ulHistoricalBytes;
   ULONG  ulNextStepBytesToRead;
   ULONG  ulPrevStepBytesRead;
   ULONG  i;
   BOOLEAN    fTDxSent;
   BOOLEAN    fAtrParsed;
   BOOLEAN   fOnlyT0 = TRUE;
   ULONG  ulOldReadTotalTimeoutMultiplier;


   // DBGBreakPoint();

   // set ReadTotalTimeoutMultiplier to 250ms (9600 * 372/f = initial waiting time)
   ulOldReadTotalTimeoutMultiplier  = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 250;



   pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;

   for (ulCardType = ASYNC3_CARD;ulCardType <= ASYNC5_CARD;ulCardType++)
      {
      // power off + resync
      status = SCCMN50M_PowerOff(pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         goto ExitUseParsingStrategy;
         }


      SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
      SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

      if (ulCardType == ASYNC3_CARD)
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
      else
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);


      SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                0,
                                0,
                                0,
                                2);  // TS and T0  expected

      SmartcardDebug(DEBUG_ATR,
                     ("%s!ResetDelay = %d\n",
                      DRIVER_NAME,
                      pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay));

      // write config + header
      status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
      if (status != STATUS_SUCCESS)
         {
         goto ExitUseParsingStrategy;
         }


      // read state and length + TS + T0
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,4,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
      if (status != STATUS_SUCCESS)
         {
         continue;    // try next card
         }


      // contents of read buffer
      // [0] ... state
      // [1] ... length
      // [2] ... TS
      // [3] ... T0

      // TS
      if (ReadBuffer[2] == CHAR_INV)
         {
         fInverseAtr = TRUE;
         }

      if (fInverseAtr)
         SCCMN50M_InverseBuffer(&ReadBuffer[3],1);

      ulHistoricalBytes = ReadBuffer[3] & 0x0F;
      ulPrevStepBytesRead = 2;

      // T0 codes following TA1 - TD1

      fAtrParsed = TRUE;
      SmartcardDebug(DEBUG_ATR,
                     ("%s!Step : Bytes to read = 2\n",
                      DRIVER_NAME));


      do
         {
         ulNextStepBytesToRead = ulPrevStepBytesRead;
         fTDxSent = FALSE;
         if (ReadBuffer[ulBytesRead - 1 ] & 0x10)
            ulNextStepBytesToRead++;
         if (ReadBuffer[ulBytesRead - 1 ] & 0x20)
            ulNextStepBytesToRead++;
         if (ReadBuffer[ulBytesRead - 1 ] & 0x40)
            ulNextStepBytesToRead++;
         if (ReadBuffer[ulBytesRead - 1 ] & 0x80)
            {
            ulNextStepBytesToRead++;
            fTDxSent = TRUE;
            }

         if (ulPrevStepBytesRead != 2  &&
             ReadBuffer[ulBytesRead -1 ] & 0x0f)
            {
            fOnlyT0 = FALSE;
            }

         // -----------------------
         // POWER OFF
         // -----------------------
         // turn power off and get state
         status = SCCMN50M_PowerOff(pSmartcardExtension);
         if (status != STATUS_SUCCESS)
            {
            fAtrParsed = FALSE;
            goto ExitUseParsingStrategy;    // try next card
            }

         // -----------------------
         // POWER ON
         // -----------------------
         // turn on power flag
         SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

         if (ulCardType == ASYNC3_CARD)
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
         else
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

         SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                   0,
                                   0,
                                   0,
                                   (UCHAR)ulNextStepBytesToRead);


         // write config + header
         status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
         if (status != STATUS_SUCCESS)
            {
            fAtrParsed = FALSE;
            goto ExitUseParsingStrategy;    // try next card
            }



         // read state and length + TAx,TBx,TCx,TDx
         SmartcardDebug(DEBUG_ATR,
                        ("%s!Step : Bytes to read =  %ld\n",
                         DRIVER_NAME,
                         ulNextStepBytesToRead));
         status = SCCMN50M_ReadCardMan(pSmartcardExtension,2 + ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
         if (status != STATUS_SUCCESS)
            {
            fAtrParsed = FALSE;
            break;    // try next card
            }
         if (fInverseAtr)
            SCCMN50M_InverseBuffer(&ReadBuffer[2],ulBytesRead-2);
         MemCpy(bAtrBytesRead,sizeof(bAtrBytesRead),&ReadBuffer[2],ulBytesRead -2);

#if  DBG
         SmartcardDebug(DEBUG_ATR,
                        ("%s!read ATR bytes: ",
                         DRIVER_NAME));
         for (i = 0;i < ulBytesRead-2;i++)
            SmartcardDebug(DEBUG_ATR,
                           ("%2.2x ",
                            bAtrBytesRead[i]));
         SmartcardDebug(DEBUG_ATR,("\n"));

#endif

         ulPrevStepBytesRead = ulBytesRead - 2;

         } while (fTDxSent == TRUE);


      // +++++++++++++++++++++++++++++++++++++++
      // now we know how long the whole ATR is
      // +++++++++++++++++++++++++++++++++++++++

      // -----------------------
      // POWER OFF
      // -----------------------
      // turn power off and get state
      status = SCCMN50M_PowerOff(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         goto ExitUseParsingStrategy;
         }


      // -----------------------
      // POWER ON
      // -----------------------
      // turn on power flag
      SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY);

      if (ulCardType == ASYNC3_CARD)
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
      else
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

      // bug fix : old SAMOS cards have a damaged ATR
      if (bAtrBytesRead[0] == 0x3b   &&
          bAtrBytesRead[1] == 0xbf   &&
          bAtrBytesRead[2] == 0x11   &&
          bAtrBytesRead[3] == 0x00   &&
          bAtrBytesRead[4] == 0x81   &&
          bAtrBytesRead[5] == 0x31   &&
          bAtrBytesRead[6] == 0x90   &&
          bAtrBytesRead[7] == 0x73      )
         {
         ulHistoricalBytes = 4;
         }


      ulNextStepBytesToRead = ulPrevStepBytesRead + ulHistoricalBytes;
      if (fOnlyT0 == FALSE)
         ulNextStepBytesToRead++;  // TCK !


      SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                0,
                                0,
                                0,
                                (UCHAR)ulNextStepBytesToRead);



      // write config + header
      status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
      if (status != STATUS_SUCCESS)
         {
         goto ExitUseParsingStrategy;    // try next card
         }


      // read whole ATR
      SmartcardDebug(DEBUG_ATR,
                     ("%s!Step : Bytes to read =  %ld\n",
                      DRIVER_NAME,
                      ulNextStepBytesToRead));
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,2+ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ATR,
                        ("%s!Reading of whole ATR failed\n !",
                         DRIVER_NAME));
         continue;    // try next card
         }

      // check ATR
      if (ulBytesRead - 2 < MIN_ATR_LEN)
         {
         status = STATUS_UNRECOGNIZED_MEDIA;
         DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2+ulNextStepBytesToRead,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
         goto ExitUseParsingStrategy;
         }

      if (ulBytesRead -2 > ulAtrBufferSize)
         {
         // the ATR is larger then 33 bytes !!!
         status = STATUS_BUFFER_OVERFLOW;
         goto ExitUseParsingStrategy;
         }

      SCCMN50M_CheckAtrModified(pbAtrBuffer,*pulAtrLength);

      // pass ATR and ATR length to calling function
      MemCpy(pbAtrBuffer,ulAtrBufferSize,&ReadBuffer[2],ulBytesRead -2);
      *pulAtrLength = ulBytesRead -2;


      if (fInverseAtr)
         {
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,INVERSE_DATA);
         SCCMN50M_InverseBuffer(pbAtrBuffer,*pulAtrLength);
         pSmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
         }
      else
         {
         pSmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
         }
      pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
      break;
      }


   ExitUseParsingStrategy:
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier
   = ulOldReadTotalTimeoutMultiplier ;
   SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,IGNORE_PARITY);
   SCCMN50M_ClearCardManHeader(pSmartcardExtension);
   return status;
}





/*****************************************************************************
Routine Description:


   This function performs either a cold or a warm reset depending on
   the fWarmReset parameter .



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseColdWarmResetStrategy  (IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                                    OUT   PULONG pulAtrLength,
                                    OUT   PUCHAR pbAtrBuffer,
                                    IN    ULONG  ulAtrBufferSize,
                                    IN    BOOLEAN   fWarmReset
                                   )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   ULONG ulCardType;
   UCHAR  bReadBuffer[SCARD_ATR_LENGTH];
   ULONG  ulBytesRead;
   ULONG  ulOldReadTotalTimeoutMultiplier;


   //DBGBreakPoint();
   // set ReadTotalTimeoutMultiplier to 250ms (9600 * 372/f = initial waiting time)
   ulOldReadTotalTimeoutMultiplier  = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier = 250;

   if (fWarmReset == FALSE)
      {
      SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,COLD_RESET,ATR_LEN_ASYNC);
      }
   else
      {
      SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,ATR_LEN_ASYNC);
      }

   pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;


   for (ulCardType = ASYNC3_CARD;ulCardType <= ASYNC5_CARD;ulCardType++)
      {
      SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

      SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);


      if (ulCardType == ASYNC3_CARD)
         {
         SmartcardDebug(
                       DEBUG_ATR,
                       ("%s!ASYNC_3\n",
                        DRIVER_NAME));
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);
         }
      else
         {
         SmartcardDebug(
                       DEBUG_ATR,
                       ("%s!ASYN_5\n",
                        DRIVER_NAME));
         SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);
         }


      status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         goto ExitUseColdWarmResetStrategy;
         }

      // write config + header
      status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
      if (status != STATUS_SUCCESS)
         {
         goto ExitUseColdWarmResetStrategy;
         }


      pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

      // read state and length
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
      if (status != STATUS_SUCCESS)
         {
         continue;    // try next card
         }


      if (bReadBuffer[1] < MIN_ATR_LEN)
         {
         // read all remaining bytes from the CardMan
         DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
         status = STATUS_UNRECOGNIZED_MEDIA;
         goto ExitUseColdWarmResetStrategy;
         }

      if (bReadBuffer[1] > ulAtrBufferSize)
         {
         status = STATUS_BUFFER_OVERFLOW;
         goto ExitUseColdWarmResetStrategy;
         }

      // read ATR
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],pulAtrLength,pbAtrBuffer,ulAtrBufferSize);
      if (status != STATUS_SUCCESS)
         {
         continue;
         }

      switch (pbAtrBuffer[0])
         {
         case CHAR_INV:
            pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
            SCCMN50M_SetCardControlFlags(pSmartcardExtension,INVERSE_DATA);
            SCCMN50M_InverseBuffer(pbAtrBuffer,*pulAtrLength);
            pSmartcardExtension->ReaderExtension->fInverseAtr = TRUE;
            break;

         case CHAR_NORM:
            pSmartcardExtension->ReaderExtension->fRawModeNecessary = FALSE;
            pSmartcardExtension->ReaderExtension->fInverseAtr = FALSE;
            break;

         default :
            status = STATUS_UNRECOGNIZED_MEDIA;
            goto ExitUseColdWarmResetStrategy;
            break;

         }

      // the smart card has been powered
      SCCMN50M_CheckAtrModified(pbAtrBuffer,*pulAtrLength);
      MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
             sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
             pbAtrBuffer,
             *pulAtrLength);

      pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)*pulAtrLength;

      status = SmartcardUpdateCardCapabilities(pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ATR,
                        ("%s!Invalid ATR received\n",
                         DRIVER_NAME));
         goto ExitUseColdWarmResetStrategy;
         }
      if (SCCMN50M_IsAtrValid(pbAtrBuffer,*pulAtrLength) == FALSE)
         {
         SmartcardDebug(
                       DEBUG_ATR,
                       ("%s!Invalid ATR received\n",
                        DRIVER_NAME));
         status = STATUS_UNRECOGNIZED_MEDIA;
         goto ExitUseColdWarmResetStrategy;
         }
      break;
      } // end for

   ExitUseColdWarmResetStrategy:
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier
   = ulOldReadTotalTimeoutMultiplier ;
   SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | IGNORE_PARITY);
   SCCMN50M_ClearCardManHeader(pSmartcardExtension);
   return status;
}






/*****************************************************************************
Routine Description:

  This function checks if the received ATR is valid.


Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IsAtrValid(
                   PUCHAR pbAtrBuffer,
                   ULONG  ulAtrLength
                   )
{
   BOOLEAN  fAtrValid = TRUE;
   ULONG ulTD1Offset = 0;
   BOOLEAN  fTD1Transmitted = FALSE;
   BOOLEAN fOnlyT0 = FALSE;
   BYTE bXor;
   ULONG ulHistoricalBytes;
   ULONG ulTx2Characters = 0;
   ULONG i;

   //DBGBreakPoint();

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IsAtrValid : Enter\n",
                   DRIVER_NAME)
                 );
   // basic checks
   if (ulAtrLength <  2             ||
       (pbAtrBuffer[0] != 0x3F &&
        pbAtrBuffer[0] != 0x3B    ) ||
       (pbAtrBuffer[1] & 0xF0)  == 0x00 )
      {
      return FALSE;
      }


   if (pbAtrBuffer[1] & 0x10)
      ulTD1Offset++;
   if (pbAtrBuffer[1] & 0x20)
      ulTD1Offset++;
   if (pbAtrBuffer[1] & 0x40)
      ulTD1Offset++;

   ulHistoricalBytes = pbAtrBuffer[1] & 0x0F;

   if (pbAtrBuffer[1] & 0x80)  // TD1 in ATR ?
      {
      fTD1Transmitted = TRUE;

      if ((pbAtrBuffer[2 + ulTD1Offset] & 0x0F) == 0x00)  // T0 indicated ?
         fOnlyT0 = TRUE;
      }
   else
      {
      fOnlyT0 = TRUE;
      }


   if (fOnlyT0 == FALSE)
      {
      bXor = pbAtrBuffer[1];
      for (i=2;i<ulAtrLength;i++)
         bXor ^= pbAtrBuffer[i];

      if (bXor != 0x00)
         fAtrValid = FALSE;
      }
   else
      {
      // only T0 protocol is indicated
      if (fTD1Transmitted == TRUE)
         {
         if (pbAtrBuffer[2 + ulTD1Offset] & 0x10)
            ulTx2Characters++;
         if (pbAtrBuffer[2 + ulTD1Offset] & 0x20)
            ulTx2Characters++;
         if (pbAtrBuffer[2 + ulTD1Offset] & 0x40)
            ulTx2Characters++;
         if (ulAtrLength  != 2 + ulTD1Offset + 1 + ulTx2Characters + ulHistoricalBytes)
            fAtrValid = FALSE;


         }
      else
         {
         if (ulAtrLength  != 2 + ulTD1Offset + ulHistoricalBytes)
            fAtrValid = FALSE;

         }

      }




   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IsAtrValid : Exit %d\n",
                   DRIVER_NAME,fAtrValid)
                 );
   return fAtrValid;
}


/*****************************************************************************
Routine Description:

  This function checks if the received ATR is valid.


Arguments:



Return Value:

*****************************************************************************/
VOID SCCMN50M_CheckAtrModified (
                               PUCHAR pbBuffer,
                               ULONG  ulBufferSize
                               )
{
   UCHAR bNumberHistoricalBytes;
   UCHAR bXorChecksum;
   ULONG i;

   if (ulBufferSize < 0x09)  // mininmum length of a modified ATR
      return ;               // ATR is ok


   // variant 2
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xbf   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize == 13   )
      {
      // correct number of historical bytes
      bNumberHistoricalBytes = 4;

      pbBuffer[1] &= 0xf0;
      pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];

      pbBuffer[ulBufferSize -1 ] = bXorChecksum;
      SmartcardDebug(DEBUG_ATR,
                     ("%s!correcting SAMOS ATR (variant 2)\n",
                      DRIVER_NAME));
      }




   // variant 1
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xb4   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize == 13      )
      {
      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];


      if (pbBuffer[ulBufferSize -1 ] != bXorChecksum )
         {
         pbBuffer[ulBufferSize -1 ] = bXorChecksum;
         SmartcardDebug(DEBUG_ATR,
                        ("%s!correcting SAMOS ATR (variant 1)\n",
                         DRIVER_NAME));

         }
      }



   // variant 3
   if (pbBuffer[0] == 0x3b   &&
       pbBuffer[1] == 0xbf   &&
       pbBuffer[2] == 0x11   &&
       pbBuffer[3] == 0x00   &&
       pbBuffer[4] == 0x81   &&
       pbBuffer[5] == 0x31   &&
       pbBuffer[6] == 0x90   &&
       pbBuffer[7] == 0x73   &&
       ulBufferSize ==  9      )
      {
      // correct number of historical bytes
      bNumberHistoricalBytes = 0;

      pbBuffer[1] &= 0xf0;
      pbBuffer[1] |= bNumberHistoricalBytes;

      // correct checksum byte
      bXorChecksum = pbBuffer[1];
      for (i=2;i<ulBufferSize-1;i++)
         bXorChecksum ^= pbBuffer[i];

      pbBuffer[ulBufferSize -1 ] = bXorChecksum;
      SmartcardDebug(DEBUG_ATR,
                     ("%s!correcting SAMOS ATR (variant 3)\n",
                      DRIVER_NAME));
      }



}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PowerOff (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;
   NTSTATUS DebugStatus = STATUS_SUCCESS;
   UCHAR pReadBuffer[2];
   ULONG ulBytesRead;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!PowerOff: Enter\n",
                   DRIVER_NAME)
                 );


   // SCR control bytes
   SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CARD_POWER);
   // card control bytes
   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
   // header
   SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);
   // rx length = 1 because we don't want to receive a status



   // write config + header
   status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   if (status != STATUS_SUCCESS)
      {
      goto ExitSCCMN50M_PowerOff;
      }



   // CardMan echoes a BRK which is recevied in the read functions


   DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,pReadBuffer,sizeof(pReadBuffer));

#if 0
   if (DebugStatus != STATUS_SUCCESS)
      SmartcardDebug(
                    DEBUG_ERROR,
                    ( "%s!PowerOffBRK received\n",
                      DRIVER_NAME)
                    );
#endif


   ExitSCCMN50M_PowerOff:
   if (pSmartcardExtension->ReaderExtension->ulOldCardState == POWERED)
      pSmartcardExtension->ReaderExtension->ulOldCardState = INSERTED;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!PowerOff: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   NTSTATUS DebugStatus;



   switch (pSmartcardExtension->CardCapabilities.Protocol.Selected)
      {
      case SCARD_PROTOCOL_RAW:
         status = STATUS_INVALID_DEVICE_REQUEST;
         break;

      case SCARD_PROTOCOL_T0:
         status =  SCCMN50M_TransmitT0(pSmartcardExtension);
         break;

      case SCARD_PROTOCOL_T1:
         status = SCCMN50M_TransmitT1(pSmartcardExtension);
         break;

      default:
         status = STATUS_INVALID_DEVICE_REQUEST;
         break;

      }

   return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_TransmitT0(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   UCHAR    bWriteBuffer[MIN_BUFFER_SIZE];
   UCHAR    bReadBuffer [MIN_BUFFER_SIZE];
   ULONG    ulWriteBufferOffset;
   ULONG    ulReadBufferOffset;
   ULONG    ulBytesToWrite;
   ULONG    ulBytesToRead;
   ULONG    ulBytesToWriteThisStep;
   ULONG    ulBytesToReadThisStep;
   ULONG    ulBytesStillToWrite;
   ULONG    ulBytesRead;
   ULONG    ulBytesStillToRead;
   BOOLEAN  fDataDirectionFromCard;
   BYTE     bProcedureByte;
   BYTE     bINS;
   BOOLEAN  fT0TransferToCard = FALSE;
   BOOLEAN  fT0TransferFromCard = FALSE;
   BOOLEAN  fSW1SW2Sent = FALSE;
   ULONG ulReadTotalTimeoutMultiplier;

   ULONG  ulStatBytesRead;
   BYTE   abStatReadBuffer[2];

   //SmartcardDebug(DEBUG_TRACE,("TransmitT0 : Enter\n"));

   //
   // Let the lib build a T=0 packet
   //
   pSmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed
   status = SmartcardT0Request(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      //
      // This lib detected an error in the data to send.
      //
      // ------------------------------------------
      // ITSEC E2 requirements: clear write buffers
      // ------------------------------------------
      MemSet(bWriteBuffer,
             sizeof(bWriteBuffer),
             '\0',
             sizeof(bWriteBuffer));
      MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
             pSmartcardExtension->SmartcardRequest.BufferSize,
             '\0',
             pSmartcardExtension->SmartcardRequest.BufferSize);
      return status;
      }


   // increase timeout for T0 Transmission
   ulReadTotalTimeoutMultiplier = pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier;

   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier =
   pSmartcardExtension->CardCapabilities.T0.WT/1000 + 1500;



   // ##################################
   // TRANSPARENT MODE
   // ##################################

   ulBytesStillToWrite = ulBytesToWrite = T0_HEADER_LEN + pSmartcardExtension->T0.Lc;
   ulBytesStillToRead  = ulBytesToRead  = pSmartcardExtension->T0.Le;
   if (pSmartcardExtension->T0.Lc)
      fT0TransferToCard = TRUE;
   if (pSmartcardExtension->T0.Le)
      fT0TransferFromCard = TRUE;




   // copy data to the write buffer
   /*
   SmartcardDebug(DEBUG_TRACE,("CLA = %x INS = %x P1 = %x P2 = %X L = %x\n",
                 pSmartcardExtension->SmartcardRequest.Buffer[0],
                 pSmartcardExtension->SmartcardRequest.Buffer[1],
                 pSmartcardExtension->SmartcardRequest.Buffer[2],
                 pSmartcardExtension->SmartcardRequest.Buffer[3],
                 pSmartcardExtension->SmartcardRequest.Buffer[4]));
   */

   MemCpy(bWriteBuffer,
          sizeof(bWriteBuffer),
          pSmartcardExtension->SmartcardRequest.Buffer,
          ulBytesToWrite);

   bINS = bWriteBuffer[1];
   if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
      {
      SCCMN50M_InverseBuffer(bWriteBuffer,ulBytesToWrite);
      }

   status = SCCMN50M_EnterTransparentMode(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      goto ExitTransparentTransmitT0;
      }

   // STEP 1 : write config + header to enter transparent mode
   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             0,                         // Tx control
                             0,                         // Tx length
                             0,                         // Rx control
                             0);                       // Rx length

   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   0,
                                   NULL);
   if (NT_ERROR(status))
      {
      goto ExitTransparentTransmitT0;
      }


   pSmartcardExtension->ReaderExtension->fTransparentMode = TRUE;

   // if the inserted card uses inverse convention , we must now switch the COM port
   // to odd parity
   if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
      {
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = ODD_PARITY;
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

      pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
      RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                    &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                    sizeof(SERIAL_LINE_CONTROL));
      pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
      pSmartcardExtension->SmartcardReply.BufferLength = 0;

      status =  SCCMN50M_SerialIo(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         goto ExitTransparentTransmitT0;
         }
      }
   ulWriteBufferOffset = 0;
   ulReadBufferOffset = 0;


   // STEP 2 : write CLA INS P1 P2 Lc

   ulBytesToWriteThisStep = 5;
   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   ulBytesToWriteThisStep,
                                   bWriteBuffer+ulWriteBufferOffset);
   if (NT_ERROR(status))
      {
      goto ExitTransparentTransmitT0;
      }
   ulWriteBufferOffset += ulBytesToWriteThisStep;
   ulBytesStillToWrite -= ulBytesToWriteThisStep;





   // STEP 2 : read procedure byte
   do
      {
      do
         {
         pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
         status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,&bProcedureByte,sizeof(bProcedureByte));
         if (NT_ERROR(status))
            {
            goto ExitTransparentTransmitT0;
            }

         if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
            {
            SCCMN50M_InverseBuffer(&bProcedureByte,ulBytesRead);
            }

         //SmartcardDebug(DEBUG_TRACE,("Procedure byte = %x\n",bProcedureByte));
         //SmartcardDebug(DEBUG_TRACE,("waiting time = %x\n",pSmartcardExtension->CardCapabilities.T0.WT));
         if (bProcedureByte == 0x60)
            {
            // ISO 7816-3 :
            // This byte is sent by the card to reset the work waiting time and to anticipate
            // a subsequent procedure byte
            // => we do nothing here
            }
         } while (bProcedureByte == 0x60);


      // check for ACK
      if ((bProcedureByte & 0xFE) ==  (bINS & 0xFE) )
         {
         if (fT0TransferToCard)
            {
            ulBytesToWriteThisStep = ulBytesStillToWrite;
            status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                            ulBytesToWriteThisStep,
                                            bWriteBuffer+ulWriteBufferOffset);
            if (NT_ERROR(status))
               {
               goto ExitTransparentTransmitT0;
               }
            ulWriteBufferOffset += ulBytesToWriteThisStep;
            ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
         if (fT0TransferFromCard)
            {
            ulBytesToReadThisStep = ulBytesStillToRead;

            pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,ulBytesToReadThisStep,&ulBytesRead,bReadBuffer + ulReadBufferOffset,sizeof(bReadBuffer)-ulReadBufferOffset);
            if (NT_ERROR(status))
               {
               goto ExitTransparentTransmitT0;
               }
            if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
               {
               SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
               }

            ulReadBufferOffset += ulBytesRead;
            ulBytesStillToRead -= ulBytesRead;
            }




         }
      // check for NAK
      else if ( (~bProcedureByte & 0xFE) == (bINS & 0xFE))
         {
         if (fT0TransferToCard)
            {
            ulBytesToWriteThisStep = 1;
            status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                            ulBytesToWriteThisStep,
                                            bWriteBuffer+ulWriteBufferOffset);
            if (NT_ERROR(status))
               {
               goto ExitTransparentTransmitT0;
               }
            ulWriteBufferOffset += ulBytesToWriteThisStep;
            ulBytesStillToWrite -= ulBytesToWriteThisStep;

            }
         if (fT0TransferFromCard)
            {
            ulBytesToReadThisStep = 1;

            pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
            status = SCCMN50M_ReadCardMan(pSmartcardExtension,ulBytesToReadThisStep,&ulBytesRead,bReadBuffer + ulReadBufferOffset,sizeof(bReadBuffer)-ulReadBufferOffset);
            if (NT_ERROR(status))
               {
               goto ExitTransparentTransmitT0;
               }
            if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
               {
               SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
               }

            ulReadBufferOffset += ulBytesRead;
            ulBytesStillToRead -= ulBytesRead;
            }
         }
      // check for SW1
      else if ( (bProcedureByte > 0x60 && bProcedureByte <= 0x6F) ||
                (bProcedureByte >= 0x90 && bProcedureByte <= 0x9F)   )
         {
         pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
         bReadBuffer[ulReadBufferOffset] = bProcedureByte;
         ulReadBufferOffset++;
         status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,bReadBuffer+ulReadBufferOffset,sizeof(bReadBuffer)-ulReadBufferOffset);
         if (NT_ERROR(status))
            {
            goto ExitTransparentTransmitT0;
            }
         if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
            {
            SCCMN50M_InverseBuffer(bReadBuffer+ulReadBufferOffset,ulBytesRead);
            }
         ulReadBufferOffset += ulBytesRead;
         fSW1SW2Sent = TRUE;
         }
      else
         {
         status =  STATUS_UNSUCCESSFUL;
         goto ExitTransparentTransmitT0;
         }

      }while (!fSW1SW2Sent);


   // copy received bytes
   MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
          pSmartcardExtension->SmartcardReply.BufferSize,
          bReadBuffer,
          ulReadBufferOffset);
   pSmartcardExtension->SmartcardReply.BufferLength = ulReadBufferOffset;


   // let the lib copy the received bytes to the user buffer
   status = SmartcardT0Reply(pSmartcardExtension);
   if (NT_ERROR(status))
      {
      goto ExitTransparentTransmitT0;
      }





   ExitTransparentTransmitT0:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
   MemSet(bWriteBuffer,
          sizeof(bWriteBuffer),
          '\0',
          sizeof(bWriteBuffer));
   MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
          pSmartcardExtension->SmartcardRequest.BufferSize,
          '\0',
          pSmartcardExtension->SmartcardRequest.BufferSize);

   DebugStatus = SCCMN50M_ExitTransparentMode(pSmartcardExtension);
   pSmartcardExtension->ReaderExtension->fTransparentMode = FALSE;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = ulReadTotalTimeoutMultiplier;

   // to be sure that the new settings take effect
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
   DebugStatus = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
   if (NT_SUCCESS(DebugStatus))
      {
      DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulStatBytesRead,abStatReadBuffer,sizeof(abStatReadBuffer));
      }
   return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_TransmitT1(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   ULONG  ulBytesToWrite;
   UCHAR  bWriteBuffer [256 + T1_HEADER_LEN + MAX_EDC_LEN];
   UCHAR  bReadBuffer [256 + T1_HEADER_LEN + MAX_EDC_LEN];
   ULONG  ulBytesRead;
   ULONG  ulBytesStillToRead;

   /*
   SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!CWT = %ld(ms)\n",
                   DRIVER_NAME,
                   pSmartcardExtension->CardCapabilities.T1.CWT/1000)
                 );
   SmartcardDebug(
                  DEBUG_TRACE,
                  ("%s!BWT = %ld(ms)\n",
                   DRIVER_NAME,
                   pSmartcardExtension->CardCapabilities.T1.BWT/1000);
                  );
   */
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    =
   pSmartcardExtension->CardCapabilities.T1.BWT/1000;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  =
   pSmartcardExtension->CardCapabilities.T1.CWT/1000;
   /*
    SmartcardDebug(DEBUG_TRACE,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                   DRIVER_NAME,
                   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));

    SmartcardDebug(DEBUG_TRACE,("%s!ReadTotalTimeoutMultiplier = %ld(ms)\n",
                   DRIVER_NAME,
                   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier));
   */

   // set T1 protocol flag for CardMan
   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_T1);

   if (pSmartcardExtension->CardCapabilities.T1.EDC == T1_CRC_CHECK)
      {
      SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_CRC);
      }


   do
      {

      pSmartcardExtension->SmartcardRequest.BufferLength = 0;  // no bytes additionally needed


      status = SmartcardT1Request(pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         goto ExitTransmitT1;
         }

      ulBytesToWrite = pSmartcardExtension->SmartcardRequest.BufferLength;

      SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                0,                        // Tx conrol
                                (UCHAR)ulBytesToWrite,      // Tx length
                                0,                        // Rx control
                                T1_HEADER_LEN);          // Rx length



      if (sizeof(bWriteBuffer) < ulBytesToWrite)
         {
         status = STATUS_BUFFER_OVERFLOW;
         goto ExitTransmitT1;
         }

      // copy data to the write buffer
      MemCpy(bWriteBuffer,
             sizeof(bWriteBuffer),
             pSmartcardExtension->SmartcardRequest.Buffer,
             ulBytesToWrite);


      // write data to card
      status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                      ulBytesToWrite,
                                      bWriteBuffer);
      if (status == STATUS_SUCCESS)
         {

         // read CardMan Header
         pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
         status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
         if (status == STATUS_SUCCESS)
            {
            ulBytesStillToRead = bReadBuffer[1];


            status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                          ulBytesStillToRead,
                                          &ulBytesRead,
                                          bReadBuffer,
                                          sizeof(bReadBuffer));
            if (status == STATUS_SUCCESS)
               {
               if (bReadBuffer[1] == T1_WTX_REQUEST)
                  {
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
                  (ULONG)(1000 +((pSmartcardExtension->CardCapabilities.T1.BWT*bReadBuffer[3])/1000));
                  SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                                 DRIVER_NAME,
                                                 pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
                  }
               else
                  {
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
                  pSmartcardExtension->CardCapabilities.T1.BWT/1000;
                  SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                                 DRIVER_NAME,
                                                 pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
                  }
               // copy received bytes
               MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
                      pSmartcardExtension->SmartcardReply.BufferSize,
                      bReadBuffer,
                      ulBytesRead);
               pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;
               }
            }
         }

      if (status != STATUS_SUCCESS)
         {
         // reset serial timeout
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!reseting timeout constant\n",
                         DRIVER_NAME)
                       );
         pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant =
         pSmartcardExtension->CardCapabilities.T1.BWT/1000;
         SmartcardDebug(DEBUG_PROTOCOL,("%s!ReadTotalTimeoutConstant = %ld(ms)\n",
                                        DRIVER_NAME,
                                        pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));

         pSmartcardExtension->SmartcardReply.BufferLength = 0L;
         }

      // bug fix for smclib
      if (pSmartcardExtension->T1.State         == T1_IFS_RESPONSE &&
          pSmartcardExtension->T1.OriginalState == T1_I_BLOCK)
         {
         pSmartcardExtension->T1.State = T1_I_BLOCK;
         }

      status = SmartcardT1Reply(pSmartcardExtension);
      }
   while (status == STATUS_MORE_PROCESSING_REQUIRED);



   ExitTransmitT1:
   // ------------------------------------------
   // ITSEC E2 requirements: clear write buffers
   // ------------------------------------------
   MemSet(bWriteBuffer,
          sizeof(bWriteBuffer),
          '\0',
          sizeof(bWriteBuffer));
   MemSet(pSmartcardExtension->SmartcardRequest.Buffer,
          pSmartcardExtension->SmartcardRequest.BufferSize,
          '\0',
          pSmartcardExtension->SmartcardRequest.BufferSize);

   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  =
   DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    =
   DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
   return status;
}








/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_InitializeSmartcardExtension(
                                     IN PSMARTCARD_EXTENSION pSmartcardExtension,
                                     IN ULONG ulDeviceInstance
                                     )
{
   // ==================================
   // Fill the Vendor_Attr structure
   // ==================================
   MemCpy(pSmartcardExtension->VendorAttr.VendorName.Buffer,
          sizeof(pSmartcardExtension->VendorAttr.VendorName.Buffer),
          ATTR_VENDOR_NAME,
          sizeof(ATTR_VENDOR_NAME)
         );

   //
   // Length of vendor name
   //
   pSmartcardExtension->VendorAttr.VendorName.Length = sizeof(ATTR_VENDOR_NAME);


   //
   // Version number
   //
   pSmartcardExtension->VendorAttr.IfdVersion.BuildNumber  = IFD_NT_BUILDNUMBER_CARDMAN;
   pSmartcardExtension->VendorAttr.IfdVersion.VersionMinor = IFD_NT_VERSIONMINOR_CARDMAN;
   pSmartcardExtension->VendorAttr.IfdVersion.VersionMajor = IFD_NT_VERSIONMAJOR_CARDMAN;


   MemCpy(pSmartcardExtension->VendorAttr.IfdType.Buffer,
          sizeof(pSmartcardExtension->VendorAttr.IfdType.Buffer),
          ATTR_IFD_TYPE_CM,
          sizeof(ATTR_IFD_TYPE_CM));

   //
   // Length of reader name
   //
   pSmartcardExtension->VendorAttr.IfdType.Length = sizeof(ATTR_IFD_TYPE_CM);



   //
   // Unit number which is zero based
   //
   pSmartcardExtension->VendorAttr.UnitNo = ulDeviceInstance;



   // ================================================
   // Fill the SCARD_READER_CAPABILITIES structure
   // ===============================================
   //
   // Supported protoclols by the reader
   //

   pSmartcardExtension->ReaderCapabilities.SupportedProtocols = SCARD_PROTOCOL_T1 | SCARD_PROTOCOL_T0;




   //
   // Reader type serial, keyboard, ....
   //
   pSmartcardExtension->ReaderCapabilities.ReaderType = SCARD_READER_TYPE_SERIAL;

   //
   // Mechanical characteristics like swallows etc.
   //
   pSmartcardExtension->ReaderCapabilities.MechProperties = 0;


   //
   // Current state of the reader
   //
   pSmartcardExtension->ReaderCapabilities.CurrentState  = SCARD_UNKNOWN;






   //
   // Data Rate
   //
   pSmartcardExtension->ReaderCapabilities.DataRate.Default =
   pSmartcardExtension->ReaderCapabilities.DataRate.Max =
   dataRatesSupported[0];


   // reader could support higher data rates
   pSmartcardExtension->ReaderCapabilities.DataRatesSupported.List =
   dataRatesSupported;
   pSmartcardExtension->ReaderCapabilities.DataRatesSupported.Entries =
   sizeof(dataRatesSupported) / sizeof(dataRatesSupported[0]);




   //
   // CLKFrequency
   //
   pSmartcardExtension->ReaderCapabilities.CLKFrequency.Default =
   pSmartcardExtension->ReaderCapabilities.CLKFrequency.Max =
   CLKFrequenciesSupported[0];


   pSmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.List =
   CLKFrequenciesSupported;
   pSmartcardExtension->ReaderCapabilities.CLKFrequenciesSupported.Entries =
   sizeof(CLKFrequenciesSupported) / sizeof(CLKFrequenciesSupported[0]);


   //pSmartcardExtension->ReaderCapabilities.CLKFrequency.Default = 3571;    //3.571 MHz
   //pSmartcardExtension->ReaderCapabilities.CLKFrequency.Max = 3571;        //3.571 MHz

   //
   // MaxIFSD
   //
   pSmartcardExtension->ReaderCapabilities.MaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;





}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
StrSet(PUCHAR Buffer,ULONG BufferSize,UCHAR Pattern)
{
   ULONG i;

   for (i=0;i < BufferSize;i++)
      Buffer[i] = Pattern;

   return;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
StrCpy(PUCHAR pszDestination,ULONG DestinationLen,PUCHAR pszSrc)
{
   ULONG Len;
   ULONG SrcLen;
   ULONG i;

   StrSet(pszDestination, DestinationLen,'\0');
   SrcLen = StrLen(pszSrc);

   if (DestinationLen - 1 < SrcLen)
      {
      Len = DestinationLen - 1;
      }
   else
      {
      Len = SrcLen;
      }


   for (i = 0; i < Len; i++)
      {
      pszDestination[i] = pszSrc[i];
      if (pszSrc[i] == '\0')
         break;
      }

   return;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
ULONG
StrLen (PUCHAR pszString)
{
   ULONG Len = 0;

   while ( *(pszString+Len) != '\0')
      Len++;

   return(Len);
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
StrCat(PUCHAR pszDestination,ULONG DestinationLen,PUCHAR pszSrc)
{
   ULONG Len;
   ULONG i;
   ULONG SrcLen;
   ULONG DestLen;

   SrcLen = StrLen(pszSrc);
   DestLen = StrLen(pszDestination);


   if (StrLen(pszDestination)>=DestinationLen)
      return;


   if ((DestinationLen-DestLen-1) < SrcLen)
      {
      Len = DestinationLen-DestLen-1;
      }
   else
      {
      Len = SrcLen;
      }


   for (i=0; i < Len; i++)
      {
      pszDestination[DestLen+i] = pszSrc[i];
      if (pszSrc[i] == '\0')
         break;
      }

   return;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
MemSet(PUCHAR pBuffer,
       ULONG  ulBufferSize,
       UCHAR  ucPattern,
       ULONG  ulCount)
{
   ULONG i;

   for (i=0; i<ulCount;i++)
      {
      if (i >= ulBufferSize)
         break;
      pBuffer[i] = ucPattern;
      }

   return ;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
MemCpy(PUCHAR pDestination,
       ULONG  ulDestinationLen,
       PUCHAR pSource,
       ULONG ulCount)
{
   ULONG i = 0;
   while ( ulCount--  &&  ulDestinationLen-- )
      {
      pDestination[i] = pSource[i];
      i++;
      }
   return;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_UpdateCurrentStateThread(
                                 IN PVOID Context
                                 )

{
   PDEVICE_EXTENSION    deviceExtension = Context;
   PSMARTCARD_EXTENSION smartcardExtension;
   NTSTATUS status;
   LONG lRetry;
   KIRQL oldIrql;
   LONG  ulFailures;
   BOOLEAN fPriorityIncreased;
   LONG  lOldPriority;

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!UpdateCurrentStateThread started\n",DRIVER_NAME));

   ulFailures = 0;
   smartcardExtension = &deviceExtension->SmartcardExtension;

   //
   // Increase priority for first loop,
   // because state of card must be known for resource manager
   //
   fPriorityIncreased=TRUE;
   lOldPriority=KeSetPriorityThread(KeGetCurrentThread(),HIGH_PRIORITY);

   do
      {
      KeWaitForSingleObject(&smartcardExtension->ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);

      if ( smartcardExtension->ReaderExtension->TimeToTerminateThread )
         {
         KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
         smartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
         PsTerminateSystemThread( STATUS_SUCCESS );
         }

      lRetry = 1;



      do
         {
         //SmartcardDebug(DEBUG_TRACE,( "%s!*.",DRIVER_NAME));

         status=SCCMN50M_UpdateCurrentState(smartcardExtension);
         if (NT_SUCCESS(status))
            {
            break;
            }
         else
            {
            lRetry--;
            }
         }
      while (lRetry >= 0);

      if (lRetry < 0)
         {
         ulFailures++;
         if (ulFailures == 1)
            {
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ( "%s!CardMan removed\n",
                            DRIVER_NAME)
                          );
            // issue a card removal event if reader  has been removed
            if (smartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
                smartcardExtension->ReaderExtension->ulOldCardState == POWERED     )
               {
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ( "%s!issuing card removal event\n",
                               DRIVER_NAME)
                             );

               SCCMN50M_CompleteCardTracking(smartcardExtension);
               smartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested = TRUE;

               smartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
               smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
               smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
               smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
               smartcardExtension->CardCapabilities.ATR.Length        = 0;

               SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
               smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
               smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
               }
            }
         if (ulFailures == 3)
            {
            // remove the device and terminate this thread
            if (KeReadStateEvent(&deviceExtension->SerialCloseDone) == 0l)
               {
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ( "%s!closing serial driver\n",
                               DRIVER_NAME)
                             );

               SCCMN50M_CloseSerialDriver(smartcardExtension->OsData->DeviceObject);


               KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
               smartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
               smartcardExtension->ReaderExtension->ThreadObjectPointer = NULL;
               PsTerminateSystemThread( STATUS_SUCCESS );
               }
            }
         }
      else
         {
         ulFailures = 0;
         }

      KeReleaseMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

      if (fPriorityIncreased)
         {
         fPriorityIncreased=FALSE;
         KeSetPriorityThread(KeGetCurrentThread(),lOldPriority);

         //
         // Lower ourselves down just at tad so that we compete a
         // little less.
         //
         KeSetBasePriorityThread(KeGetCurrentThread(),-1);
         }

      //SmartcardDebug(DEBUG_TRACE,( "...#\n"));

      Wait (smartcardExtension,500 * ms_);
      }
   while (TRUE);
}




NTSTATUS SCCMN50M_UpdateCurrentState(
                                    IN PSMARTCARD_EXTENSION smartcardExtension
                                    )
{
   NTSTATUS    NTStatus;
   UCHAR       pbReadBuffer[2];
   ULONG       ulBytesRead;
   BOOLEAN     fCardStateChanged;

   fCardStateChanged = FALSE;


   SCCMN50M_ClearCardManHeader(smartcardExtension);

   smartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
   NTStatus = SCCMN50M_WriteCardMan(smartcardExtension,0,NULL);
   smartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
   if (NT_SUCCESS(NTStatus))
      {
      NTStatus = SCCMN50M_ReadCardMan(smartcardExtension,2,&ulBytesRead,pbReadBuffer,sizeof(pbReadBuffer));
      if (ulBytesRead == 0x02      &&         // two bytes must have benn received
          (pbReadBuffer[0] & 0x0F) &&         // at least one version bit must be set
          ((pbReadBuffer[0] & 0x09) == 0x00)) // Bit 0 and Bit 3 must be 0
         {
         if ((pbReadBuffer[0] & 0x04) == 0x04    &&
             (pbReadBuffer[0] & 0x02) == 0x02)
            smartcardExtension->ReaderExtension->ulNewCardState = INSERTED;

         if ((pbReadBuffer[0] & 0x04) == 0x00    &&
             (pbReadBuffer[0] & 0x02) == 0x02)
            smartcardExtension->ReaderExtension->ulNewCardState = REMOVED;

         if ((pbReadBuffer[0] & 0x04) == 0x04    &&
             (pbReadBuffer[0] & 0x02) == 0x00)
            smartcardExtension->ReaderExtension->ulNewCardState = POWERED;


         //SmartcardDebug(DEBUG_TRACE,("old %x   ",smartcardExtension->ReaderExtension->ulOldCardState ));
         //SmartcardDebug(DEBUG_TRACE,("new %x\n",smartcardExtension->ReaderExtension->ulNewCardState ));



         if (smartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
             smartcardExtension->ReaderExtension->ulOldCardState == POWERED     )
            {
            // card has been removed and reinserted within 500ms
            fCardStateChanged = TRUE;
            SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard removed and reinserted\n",DRIVER_NAME));
            smartcardExtension->ReaderExtension->ulOldCardState = REMOVED;
            smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            // clear any cardspecific data
            smartcardExtension->CardCapabilities.ATR.Length = 0;
            SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
            smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
            smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
            }


         if (smartcardExtension->ReaderExtension->ulNewCardState == REMOVED      &&
             (smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN  ||
              smartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
              smartcardExtension->ReaderExtension->ulOldCardState == POWERED    )   )
            {
            // card has been removed
            fCardStateChanged = TRUE;
            SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard removed\n",DRIVER_NAME));
            smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
            smartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;

            // clear any cardspecific data
            smartcardExtension->CardCapabilities.ATR.Length = 0;
            SCCMN50M_ClearCardControlFlags(smartcardExtension,ALL_FLAGS);
            smartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0;
            smartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0;
            }



         if (smartcardExtension->ReaderExtension->ulNewCardState  == INSERTED    &&
             (smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
              smartcardExtension->ReaderExtension->ulOldCardState == REMOVED    )   )
            {
            // card has been inserted
            fCardStateChanged = TRUE;
            SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard inserted\n",DRIVER_NAME));
            smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
            smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
            smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


         // state after reset of the PC (only for CardMan Power+ possible)
         if (smartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
             smartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN    )
            {
            // card has been inserted
            fCardStateChanged = TRUE;
            SmartcardDebug(DEBUG_DRIVER,( "%s!Smartcard inserted (and powered)\n",DRIVER_NAME));
            smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
            smartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
            smartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }

         if (smartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
             smartcardExtension->ReaderExtension->ulOldCardState == INSERTED     )
            {
            smartcardExtension->ReaderExtension->ulOldCardState = smartcardExtension->ReaderExtension->ulNewCardState;
            }


         // complete IOCTL_SMARTCARD_IS_ABSENT or IOCTL_SMARTCARD_IS_PRESENT
         if (fCardStateChanged == TRUE                  &&
             smartcardExtension->OsData->NotificationIrp  )
            {
            SCCMN50M_CompleteCardTracking(smartcardExtension);
            }

         }
      }

   return NTStatus;

}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS Wait (PSMARTCARD_EXTENSION pSmartcardExtension,ULONG ulMilliseconds)
{
   NTSTATUS status = STATUS_SUCCESS;
   LARGE_INTEGER   WaitTime;


   WaitTime = RtlConvertLongToLargeInteger(ulMilliseconds * WAIT_MS);
   KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetSCRControlFlags(
                           IN PSMARTCARD_EXTENSION pSmartcardExtension,
                           IN UCHAR Flags
                           )
{
   pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl |= Flags;
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearSCRControlFlags(
                             IN PSMARTCARD_EXTENSION pSmartcardExtension,
                             IN UCHAR Flags
                             )
{
   pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl &= ~Flags;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetCardControlFlags(
                            IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN UCHAR Flags
                            )
{
   pSmartcardExtension->ReaderExtension->CardManConfig.CardControl |= Flags;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearCardControlFlags(
                              IN PSMARTCARD_EXTENSION pSmartcardExtension,
                              IN UCHAR Flags
                              )
{
   pSmartcardExtension->ReaderExtension->CardManConfig.CardControl &=  ~Flags;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_ClearCardManHeader(
                           IN PSMARTCARD_EXTENSION pSmartcardExtension
                           )
{
   pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = 0x00;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SetCardManHeader(
                         IN PSMARTCARD_EXTENSION pSmartcardExtension,
                         IN UCHAR TxControl,
                         IN UCHAR TxLength,
                         IN UCHAR RxControl,
                         IN UCHAR RxLength
                         )
{
   pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = TxControl;
   pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = TxLength;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = RxControl;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = RxLength;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_WriteCardMan (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG ulBytesToWrite,
                      IN PUCHAR pbWriteBuffer
                      )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   PSERIAL_STATUS  pSerialStatus;


   // ===============================================
   // Set up timeouts for following read operation
   // ===============================================
   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;


   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                 sizeof(SERIAL_TIMEOUTS));

   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;


   /*
   SmartcardDebug(DEBUG_TRACE,("ReadTotalTimeoutMultiplier = %ld\n",
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier));
   SmartcardDebug(DEBUG_TRACE,("ReadTotalTimeoutConstant = %ld\n",
                  pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant));
   */
   status =  SCCMN50M_SerialIo(pSmartcardExtension);







   // ===============================================
   // write to the CardMan
   // ===============================================
   DebugStatus = SCCMN50M_SetWrite(pSmartcardExtension,ulBytesToWrite,pbWriteBuffer);


   // add pseudoboost (0x00) to write buffer for CardManII
   if (pSmartcardExtension->ReaderExtension->fTransparentMode == FALSE       )
      {
      pSmartcardExtension->SmartcardRequest.Buffer[pSmartcardExtension->SmartcardRequest.BufferLength] = 0x00;
      pSmartcardExtension->SmartcardRequest.BufferLength++;
      }
   status =  SCCMN50M_SerialIo(pSmartcardExtension);



   // overwrite write buffer with '@'
   RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 pSmartcardExtension->SmartcardRequest.BufferLength,
                 '@');



   // ===============================================
   // error checking
   // ===============================================
   DebugStatus = SCCMN50M_GetCommStatus(pSmartcardExtension);

   pSerialStatus = (PSERIAL_STATUS) pSmartcardExtension->SmartcardReply.Buffer;
   if (pSerialStatus->Errors || NT_ERROR(status))
      {
      pSmartcardExtension->ReaderExtension->SerialErrors = pSerialStatus->Errors;
      if (!pSmartcardExtension->ReaderExtension->fTransparentMode            )
         DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
      goto ExitSCCMN50M_WriteCardMan;
      }




   ExitSCCMN50M_WriteCardMan:

   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(
                    DEBUG_TRACE,
                    ( "%s!WriteCardMan: Failed, exit %lx\n",
                      DRIVER_NAME,status)
                    );
      }

   return status;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS SCCMN50M_ResyncCardManI (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;


   // SmartcardDebug(DEBUG_TRACE,("%s!ResyncCardManI: Enter\n",DRIVER_NAME))

   // clear error flags
   pSmartcardExtension->ReaderExtension->SerialErrors = 0;


   // clear any pending errors
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManI;
      }


   // clear COM buffers
   status = SCCMN50M_PurgeComm(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManI;
      }




   // ####################################################################
   // set break
   if (!pSmartcardExtension->ReaderExtension->fTransparentMode)
      {
      status = SCCMN50M_SetBRK(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ERROR,("SetBreak failed !   status = %x\n",status))
         goto ExitSCCMN50M_ResyncCardManI;
         }
      }


   // wait 1ms
   Wait(pSmartcardExtension,1 * ms_);

   // clear RTS
   status = SCCMN50M_ClearRTS(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ClearRTS failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManI;
      }

   // wait 2ms
   Wait(pSmartcardExtension,2 * ms_);


   // set RTS
   status = SCCMN50M_SetRTS(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_SetRTS failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManI;
      }

   // wait 1ms
   Wait(pSmartcardExtension,1 * ms_);



   // clear break

   if (!pSmartcardExtension->ReaderExtension->fTransparentMode)
      {
      pSmartcardExtension->ReaderExtension->BreakSet = FALSE;
      status = SCCMN50M_ClearBRK(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ERROR,("ClearBreak failed !   status = %x\n",status))
         goto ExitSCCMN50M_ResyncCardManI;
         }
      }

   // ####################################################################

   // next write operation must send config data
   pSmartcardExtension->ReaderExtension->NoConfig       = FALSE;

   // clear COM buffers
   status = SCCMN50M_PurgeComm(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      goto ExitSCCMN50M_ResyncCardManI;
      }

   // clear any pending errors
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      goto ExitSCCMN50M_ResyncCardManI;
      }


   ExitSCCMN50M_ResyncCardManI:
   //SmartcardDebug(DEBUG_TRACE,("%s!ResyncCardManI: Exit %lx\n",DRIVER_NAME,status))
   return status;
}





NTSTATUS SCCMN50M_ResyncCardManII (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResyncCardManII: Enter\n",
                   DRIVER_NAME)
                 );

   // clear error flags
   pSmartcardExtension->ReaderExtension->SerialErrors = 0;


   // clear any pending errors
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManII;
      }


   // clear COM buffers
   status = SCCMN50M_PurgeComm(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
      goto ExitSCCMN50M_ResyncCardManII;
      }



   // 150 * 0xFE
   RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,150,0xFE);
   pSmartcardExtension->SmartcardRequest.Buffer[150] = 0x00;
   pSmartcardExtension->SmartcardRequest.BufferLength = 151;
   pSmartcardExtension->SmartcardReply.BufferLength   =   0;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      Wait(pSmartcardExtension,2 * ms_);
      // try resync once more

      // clear error flags
      pSmartcardExtension->ReaderExtension->SerialErrors = 0;

      // clear any pending errors
      status = SCCMN50M_GetCommStatus(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %x\n",status))
         goto ExitSCCMN50M_ResyncCardManII;
         }

      // clear COM buffers
      status = SCCMN50M_PurgeComm(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ERROR,("SCCMN50M_PurgeComm failed !   status = %x\n",status))
         goto ExitSCCMN50M_ResyncCardManII;
         }


      // 150 * 0xFE
      RtlFillMemory(pSmartcardExtension->SmartcardRequest.Buffer,150,0xFE);
      pSmartcardExtension->SmartcardRequest.Buffer[150] = 0x00;
      pSmartcardExtension->SmartcardRequest.BufferLength = 151;
      pSmartcardExtension->SmartcardReply.BufferLength   =   0;

      pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;
      status =  SCCMN50M_SerialIo(pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,("SCCMN50M_SerialIo failed !   status = %x\n",status))
         goto ExitSCCMN50M_ResyncCardManII;
         }
      // normally the second resync command is always successful

      }


   // clear COM buffers
   status = SCCMN50M_PurgeComm(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      goto ExitSCCMN50M_ResyncCardManII;
      }

   // clear any pending errors
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      goto ExitSCCMN50M_ResyncCardManII;
      }


   ExitSCCMN50M_ResyncCardManII:

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResyncCardManII: Exit %lx\n",
                   DRIVER_NAME,status)
                 );

   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SerialIo(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   IO_STATUS_BLOCK ioStatus;
   KEVENT event;
   PIRP irp;
   PIO_STACK_LOCATION irpNextStack;
   PUCHAR pbRequestBuffer;
   PUCHAR pbReplyBuffer;
   ULONG ulRequestBufferLength;
   ULONG ulReplyBufferLength ;

   //
   // Check if the buffers are large enough
   //
   ASSERT(pSmartcardExtension->SmartcardReply.BufferLength <=
          pSmartcardExtension->SmartcardReply.BufferSize);

   ASSERT(pSmartcardExtension->SmartcardRequest.BufferLength <=
          pSmartcardExtension->SmartcardRequest.BufferSize);

   if (pSmartcardExtension->SmartcardReply.BufferLength >
       pSmartcardExtension->SmartcardReply.BufferSize      ||
       pSmartcardExtension->SmartcardRequest.BufferLength >
       pSmartcardExtension->SmartcardRequest.BufferSize)
      {
      SmartcardLogError(pSmartcardExtension->OsData->DeviceObject,
                        SCCMN50M_BUFFER_TOO_SMALL,
                        NULL,
                        0);
      return STATUS_BUFFER_TOO_SMALL;
      }




   // set pointer and length of request and reply buffer
   ulRequestBufferLength = pSmartcardExtension->SmartcardRequest.BufferLength;
   pbRequestBuffer       = (ulRequestBufferLength ? pSmartcardExtension->SmartcardRequest.Buffer : NULL);

   pbReplyBuffer         = pSmartcardExtension->SmartcardReply.Buffer;
   ulReplyBufferLength   = pSmartcardExtension->SmartcardReply.BufferLength;



   KeInitializeEvent(&event,
                     NotificationEvent,
                     FALSE);


   //
   // Build irp to be sent to serial driver
   //
   irp = IoBuildDeviceIoControlRequest(pSmartcardExtension->ReaderExtension->SerialIoControlCode,
                                       pSmartcardExtension->ReaderExtension->AttachedDeviceObject,
                                       pbRequestBuffer,
                                       ulRequestBufferLength,
                                       pbReplyBuffer,
                                       ulReplyBufferLength,
                                       FALSE,
                                       &event,
                                       &ioStatus);


   ASSERT(irp != NULL);
   if (irp == NULL)
      {
      return STATUS_INSUFFICIENT_RESOURCES;
      }


   irpNextStack = IoGetNextIrpStackLocation(irp);

   switch (pSmartcardExtension->ReaderExtension->SerialIoControlCode)
      {
      //
      // The serial driver transfers data from/to irp->AssociatedIrp.SystemBuffer
      //
      case SMARTCARD_WRITE:
         irpNextStack->MajorFunction = IRP_MJ_WRITE;
         irpNextStack->Parameters.Write.Length = pSmartcardExtension->SmartcardRequest.BufferLength;
         break;


      case SMARTCARD_READ:
         irpNextStack->MajorFunction = IRP_MJ_READ;
         irpNextStack->Parameters.Read.Length = pSmartcardExtension->SmartcardReply.BufferLength;
         break;
      }


   status = IoCallDriver(pSmartcardExtension->ReaderExtension->AttachedDeviceObject,irp);


   if (status == STATUS_PENDING)
      {
      KeWaitForSingleObject(&event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);
      status = ioStatus.Status;
      }

   switch (pSmartcardExtension->ReaderExtension->SerialIoControlCode)
      {
      case SMARTCARD_READ:
         if (status == STATUS_TIMEOUT)
            {
            SmartcardDebug(DEBUG_ERROR,
                           ("%s!Timeout while reading from CardMan\n",
                            DRIVER_NAME));
            //
            // STATUS_TIMEOUT isn't correctly mapped
            // to a WIN32 error, that's why we change it here
            // to STATUS_IO_TIMEOUT
            //
            status = STATUS_IO_TIMEOUT;

            pSmartcardExtension->SmartcardReply.BufferLength = 0;
            }
         break;
      }

#if 0
   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!SerialIo = %lx\n",
                      DRIVER_NAME,
                      status));
      }
#endif

   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ReadCardMan  (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG BytesToRead,
                      OUT PULONG pBytesRead,
                      IN PUCHAR pReadBuffer,
                      IN ULONG ReadBufferSize
                      )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   BOOLEAN fRc;

   // check if read buffer is large enough
   ASSERT(BytesToRead <= ReadBufferSize);


   *pBytesRead = 0;   // default setting


   DebugStatus = SCCMN50M_SetRead(pSmartcardExtension,BytesToRead);

   //
   // read operation
   //
   status = SCCMN50M_SerialIo(pSmartcardExtension);
   if (status == STATUS_SUCCESS)
      {
      *pBytesRead = pSmartcardExtension->SmartcardReply.BufferLength;

      MemCpy(pReadBuffer,
             ReadBufferSize,
             pSmartcardExtension->SmartcardReply.Buffer,
             pSmartcardExtension->SmartcardReply.BufferLength);

      // overwrite read buffer with '@'
      MemSet(pSmartcardExtension->SmartcardReply.Buffer,
             pSmartcardExtension->SmartcardReply.BufferSize,
             '@',
             pSmartcardExtension->SmartcardReply.BufferLength);
      }

   if (status != STATUS_SUCCESS || SCCMN50M_IOOperationFailed(pSmartcardExtension))
      {
      if (!pSmartcardExtension->ReaderExtension->fTransparentMode)
         {
         DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
         }
      goto ExitSCCMN50M_ReadCardMan;
      }


   // *****************************************
   // set CardManII to state RH Config
   // *****************************************
   // don't set CardMan to RH config if there are still bytes to be read
   if (pSmartcardExtension->ReaderExtension->ToRHConfig == TRUE)
      {
      pSmartcardExtension->SmartcardReply.BufferLength    = 0;

      pSmartcardExtension->SmartcardRequest.Buffer  [0] = 0x00;
      pSmartcardExtension->SmartcardRequest.Buffer  [1] = 0x00;
      pSmartcardExtension->SmartcardRequest.Buffer  [2] = 0x00;
      pSmartcardExtension->SmartcardRequest.Buffer  [3] = 0x00;
      pSmartcardExtension->SmartcardRequest.Buffer  [4] = 0x89;

      pSmartcardExtension->SmartcardRequest.BufferLength   = 5;


      pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;
      status = SCCMN50M_SerialIo(pSmartcardExtension);
      if (status != STATUS_SUCCESS || SCCMN50M_IOOperationFailed(pSmartcardExtension))
         {
         DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);
         goto ExitSCCMN50M_ReadCardMan;
         }
      }



   ExitSCCMN50M_ReadCardMan:
   // set default value;
   pSmartcardExtension->ReaderExtension->ToRHConfig = TRUE;

   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(
                    DEBUG_TRACE,
                    ( "%s!ReadCardMan: Failed, exit %lx\n",
                      DRIVER_NAME,status)
                    );
      }

   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetCommStatus (
                       IN PSMARTCARD_EXTENSION SmartcardExtension
                       )
{
   PSERIAL_READER_CONFIG configData = &SmartcardExtension->ReaderExtension->SerialConfigData;
   NTSTATUS status;
   PUCHAR request = SmartcardExtension->SmartcardRequest.Buffer;


   SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;

   SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_GET_COMMSTATUS;

   SmartcardExtension->SmartcardRequest.Buffer = (PUCHAR) &configData->SerialStatus;

   SmartcardExtension->SmartcardRequest.BufferLength = sizeof(SERIAL_STATUS);

   status =  SCCMN50M_SerialIo(SmartcardExtension);

   //
   // restore pointer to original request buffer
   //
   SmartcardExtension->SmartcardRequest.Buffer = request;

   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IOOperationFailed(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS DebugStatus;
   PSERIAL_STATUS  pSerialStatus;

   DebugStatus = SCCMN50M_GetCommStatus(pSmartcardExtension);

   pSerialStatus = (PSERIAL_STATUS)pSmartcardExtension->SmartcardReply.Buffer;
   if (pSerialStatus->Errors)
      return TRUE;
   else
      return FALSE;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS SCCMN50M_PurgeComm (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   PSERIAL_READER_CONFIG configData = &pSmartcardExtension->ReaderExtension->SerialConfigData;
   NTSTATUS status;
   PUCHAR request = pSmartcardExtension->SmartcardRequest.Buffer;


   pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_PURGE;

   pSmartcardExtension->SmartcardRequest.Buffer = (PUCHAR) &configData->PurgeMask;

   pSmartcardExtension->SmartcardRequest.BufferLength = sizeof(ULONG);

   status =  SCCMN50M_SerialIo(pSmartcardExtension);

   //
   // restore pointer to original request buffer
   //
   pSmartcardExtension->SmartcardRequest.Buffer = request;

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

   if (status == STATUS_CANCELLED)
      status = STATUS_SUCCESS;

   return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetRead(IN PSMARTCARD_EXTENSION pSmartcardExtension,
                 IN ULONG ulBytesToRead
                )
{
   pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_READ;

   pSmartcardExtension->SmartcardRequest.BufferLength = 0;

   pSmartcardExtension->SmartcardReply.BufferLength    = ulBytesToRead;

   return  STATUS_SUCCESS;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetWrite(IN PSMARTCARD_EXTENSION pSmartcardExtension,
                  IN ULONG BytesToWrite,
                  IN PUCHAR WriteBuffer
                 )
{
   ULONG Offset = 0;
   pSmartcardExtension->ReaderExtension->SerialIoControlCode = SMARTCARD_WRITE;

   pSmartcardExtension->SmartcardReply.BufferLength    = 0;


   if (pSmartcardExtension->ReaderExtension->fTransparentMode == FALSE)
      {
      // send always config string for CardManII, expect we set it manualy
      // to NoConfig = TRUE.  (note: only one time)
      if (pSmartcardExtension->ReaderExtension->NoConfig == FALSE)
         {
         MemCpy(pSmartcardExtension->SmartcardRequest.Buffer,
                pSmartcardExtension->SmartcardRequest.BufferSize,
                (PUCHAR)&pSmartcardExtension->ReaderExtension->CardManConfig,
                sizeof(CARDMAN_CONFIG));
         Offset = 4;
         }
      else
         {
         pSmartcardExtension->ReaderExtension->NoConfig = FALSE;
         }



      MemCpy(pSmartcardExtension->SmartcardRequest.Buffer + Offset,
             pSmartcardExtension->SmartcardRequest.BufferSize,
             (PUCHAR)&pSmartcardExtension->ReaderExtension->CardManHeader,
             sizeof(CARDMAN_HEADER));
      Offset+=4;
      }


   if (BytesToWrite != 0)
      {
      MemCpy(pSmartcardExtension->SmartcardRequest.Buffer + Offset,
             pSmartcardExtension->SmartcardRequest.BufferSize,
             WriteBuffer,
             BytesToWrite);
      }


   pSmartcardExtension->SmartcardRequest.BufferLength   = Offset +  BytesToWrite;


   return  STATUS_SUCCESS;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_StartCardTracking(
                          PDEVICE_EXTENSION pDeviceExtension
                          )
{
   NTSTATUS status;
   HANDLE hThread;
   PSMARTCARD_EXTENSION pSmartcardExtension = &pDeviceExtension->SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartCardTracking: Enter\n",DRIVER_NAME));

   KeWaitForSingleObject(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);


   // create thread for updating current state
   status = PsCreateSystemThread(&hThread,
                                 THREAD_ALL_ACCESS,
                                 NULL,
                                 NULL,
                                 NULL,
                                 SCCMN50M_UpdateCurrentStateThread,
                                 pDeviceExtension);
   if (!NT_ERROR(status))
      {
      //
      // We've got the thread.  Now get a pointer to it.
      //
      status = ObReferenceObjectByHandle(hThread,
                                         THREAD_ALL_ACCESS,
                                         NULL,
                                         KernelMode,
                                         &pSmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                         NULL);

      if (NT_ERROR(status))
         {
         pSmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
         }
      else
         {
         //
         // Now that we have a reference to the thread
         // we can simply close the handle.
         //
         ZwClose(hThread);
         }
      }
   else
      {
      }

   // Release the mutex
   KeReleaseMutex(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                  FALSE);

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartCardTracking: Exit %lx\n",DRIVER_NAME,status));
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_InitCommPort (PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!InitCommPort: Enter\n",
                   DRIVER_NAME)
                 );

   // ===============================
   // clear any pending errors
   // ===============================
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
      goto ExitInitCommPort;
      }



   // ==============================
   // set baudrate for CardMan
   // ==============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;


   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                 sizeof(SERIAL_BAUD_RATE));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
      goto ExitInitCommPort;
      }




   // ===============================
   // set comm timeouts
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadIntervalTimeout         = DEFAULT_READ_INTERVAL_TIMEOUT;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutConstant   = DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutMultiplier = DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER;


   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                 sizeof(SERIAL_TIMEOUTS));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_TIMEOUTS failed !   status = %x\n",status))
      goto ExitInitCommPort;
      }


   // ===============================
   // set line control
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 8;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                 sizeof(SERIAL_LINE_CONTROL));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
      goto ExitInitCommPort;
      }




   // ===============================
   // Set handflow
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XonLimit         = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XoffLimit        = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.FlowReplace      = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.ControlHandShake = SERIAL_ERROR_ABORT | SERIAL_DTR_CONTROL;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;


   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow,
                 sizeof(SERIAL_HANDFLOW));

   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_HANDFLOW);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_HANDFLOW failed !   status = %x\n",status))
      goto ExitInitCommPort;
      }


   // ===============================
   //  set purge mask
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.PurgeMask =
   SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT |
   SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR;



   // ===============================
   //  set DTR
   // ===============================
   status = SCCMN50M_SetDTR(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_DRT failed !   status = %x\n",status))
      goto ExitInitCommPort;
      }

   // ===============================
   //  set RTS
   // ===============================
   status = SCCMN50M_SetRTS(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
      goto ExitInitCommPort;
      }




   ExitInitCommPort:

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!InitCommPort: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetDTR(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;


   pSmartcardExtension->SmartcardReply.BufferLength = 0;
   pSmartcardExtension->SmartcardRequest.BufferLength = 0;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_DTR;



   status =  SCCMN50M_SerialIo(pSmartcardExtension);

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

   if (status == STATUS_CANCELLED)
      status = STATUS_SUCCESS;

   return status;

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetRTS(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;


   pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
   pSmartcardExtension->SmartcardRequest.BufferLength = 0;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_RTS;



   status =  SCCMN50M_SerialIo(pSmartcardExtension);

   // under W2000 & CardMan P+ STATUS_CANCELLED may be returned

   if (status == STATUS_CANCELLED)
      status = STATUS_SUCCESS;

   return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_InitializeCardMan(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   UCHAR pReadBuffer[2];
   ULONG ulBytesRead;
   BOOLEAN fCardManFound = FALSE;
   PREADER_EXTENSION readerExtension = pSmartcardExtension->ReaderExtension;
   ULONG ulRetries;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!InitializeCardMan: Enter\n",
                   DRIVER_NAME)
                 );


   pSmartcardExtension->ReaderExtension->ulOldCardState = UNKNOWN;


   // ==============================================
   // CardManII
   // ==============================================
   pSmartcardExtension->ReaderExtension->NoConfig    = FALSE;
   pSmartcardExtension->ReaderExtension->ToRHConfig  = TRUE;


   // This waiting time if necessary for CardMan Power+, because
   // the pnP string may be dumped
   Wait(pSmartcardExtension,200);

   status = SCCMN50M_InitCommPort(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      goto ExitInitializeCardMan;
   //
   // init CommPort was O.K.
   // now try to find a reader
   //

   // To be sure wait make an additional wait
   Wait(pSmartcardExtension,100);

   status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
   status = SCCMN50M_ResyncCardManII(pSmartcardExtension);


   // no data except config + header

   pSmartcardExtension->ReaderExtension->CardManConfig.SCRControl      = XMIT_HANDSHAKE_OFF;
   pSmartcardExtension->ReaderExtension->CardManConfig.CardControl    = 0x00;
   pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits   = 0x00;
   pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay     = 0x00;

   pSmartcardExtension->ReaderExtension->CardManHeader.TxControl      = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.TxLength       = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxControl      = 0x00;
   pSmartcardExtension->ReaderExtension->CardManHeader.RxLength       = 0x00;


   status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   if (status == STATUS_SUCCESS)
      {
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,pReadBuffer,sizeof(pReadBuffer));

      if (status == STATUS_SUCCESS     &&
          ulBytesRead == 0x02          &&   // two bytes received
          pReadBuffer[0] >= 0x40       &&   // at least one version bit must be set
          pReadBuffer[1] == 0x00       &&
          ((pReadBuffer[0] & 0x09) == 0)   ) // bit 0 and 3 must be cleared
         {
         pSmartcardExtension->ReaderExtension->ulFWVersion = (pReadBuffer[0] >> 4) * 30 + 120;
         pSmartcardExtension->ReaderExtension->fSPESupported = FALSE;

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ( "%s!CardMan (FW %ld) found\n",
                         DRIVER_NAME,pSmartcardExtension->ReaderExtension->ulFWVersion)
                       );
         fCardManFound = TRUE;
         }
      }


   ExitInitializeCardMan:

   if (fCardManFound == TRUE)
      status =  STATUS_SUCCESS;
   else
      status = STATUS_UNSUCCESSFUL;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!InitializeCardMan: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_EnterTransparentMode (IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;

   SmartcardDebug(DEBUG_TRACE,("EnterTransparentMode : enter\n"));

   // Step 1 : Resync CardMan by RTS usage
   status = SCCMN50M_ResyncCardManI(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManI failed !   status = %ld\n",status))
      goto ExitEnterTransparentMode;
      }

   // Step 2  : set baud rate to 9600
   pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 9600;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                 sizeof(SERIAL_BAUD_RATE));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
      goto ExitEnterTransparentMode;
      }



   ExitEnterTransparentMode:
   // Step 3  : set ATR and DUMP_BUFFER flags
   // During normal operation these two flags can never be set at the same time
   SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | TO_STATE_XH);





   SmartcardDebug(DEBUG_TRACE,("EnterTransparentMode : exit\n"));
   return status;

}







/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ExitTransparentMode (IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;



   SmartcardDebug(DEBUG_TRACE,("ExitTransparentMode : enter\n"));


   // ===============================
   // clear any pending errors
   // ===============================
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
      goto ExitExitTransparentMode;
      }


   // Step 1 : Resync CardMan by RTS usage
   status = SCCMN50M_ResyncCardManI(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManI failed !   status = %ld\n",status))
      goto ExitExitTransparentMode;
      }

   // Step 2  : set baud rate to 38400
   pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                 sizeof(SERIAL_BAUD_RATE));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
      goto ExitExitTransparentMode;
      }


   // if the inserted card uses inverse convention , we must now switch the COM port
   // back to even parity
   if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
      {
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
      pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

      pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
      RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                    &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                    sizeof(SERIAL_LINE_CONTROL));
      pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
      pSmartcardExtension->SmartcardReply.BufferLength = 0;

      status =  SCCMN50M_SerialIo(pSmartcardExtension);
      if (!NT_SUCCESS(status))
         {
         SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
         goto ExitExitTransparentMode;
         }
      }



   ExitExitTransparentMode:

   // Step 3  : set ATR and DUMP_BUFFER flags
   // During normal operation these two flags can never be set at the same time
   SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,CM2_GET_ATR | TO_STATE_XH);



   status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_ResyncCardManII failed !   status = %x\n",status))
      goto ExitExitTransparentMode;
      }


   SmartcardDebug(DEBUG_TRACE,("ExitTransparentMode : exit\n"));


   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ClearRTS(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
   NTSTATUS status;


   SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
   SmartcardExtension->SmartcardRequest.BufferLength = 0;

   SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_CLR_RTS;



   status =  SCCMN50M_SerialIo(SmartcardExtension);


   return status;

}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_IoCtlVendor(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS DebugStatus;
   UCHAR  pbAttrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength;


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IoCtlVendor : Enter\n",
                   DRIVER_NAME)
                 );



   switch (pSmartcardExtension->MajorIoControlCode)
      {
      case CM_IOCTL_SET_READER_9600_BAUD:
         status = SCCMN50M_SetFl_1Dl_1(pSmartcardExtension);
         break;

      case CM_IOCTL_SET_READER_38400_BAUD:
         status = SCCMN50M_SetFl_1Dl_3(pSmartcardExtension);
         break;

      case CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED:
         status = SCCMN50M_SetHighSpeed_CR80S_SAMOS(pSmartcardExtension);
         break;

      case CM_IOCTL_GET_FW_VERSION:
         status = SCCMN50M_GetFWVersion(pSmartcardExtension);
         break;

      case CM_IOCTL_READ_DEVICE_DESCRIPTION:
         status = SCCMN50M_ReadDeviceDescription(pSmartcardExtension);
         break;

      case CM_IOCTL_SET_SYNC_PARAMETERS :
         status = SCCMN50M_SetSyncParameters(pSmartcardExtension);
         break;

      case CM_IOCTL_3WBP_TRANSFER :  // for SLE4428
         status = SCCMN50M_Transmit3WBP(pSmartcardExtension);
         break;

      case CM_IOCTL_2WBP_TRANSFER :  // for SLE4442
         status = SCCMN50M_Transmit2WBP(pSmartcardExtension);
         break;

      case CM_IOCTL_2WBP_RESET_CARD: // SLE4442  Reset Card
         status = SCCMN50M_ResetCard2WBP(pSmartcardExtension);
         break;

      case CM_IOCTL_SYNC_CARD_POWERON:
         status = SCCMN50M_SyncCardPowerOn(pSmartcardExtension);
         break;
      default:
         status = STATUS_INVALID_DEVICE_REQUEST;
         break;
      }





   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IoCtlVendor : Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetFl_1Dl_3(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status = STATUS_SUCCESS;
   NTSTATUS DebugStatus;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetFl_1Dl_3 Enter\n",
                   DRIVER_NAME));

   // check if T=1 active
   if (pSmartcardExtension->CardCapabilities.Protocol.Selected !=
       SCARD_PROTOCOL_T1)
      {
      status = STATUS_CTL_FILE_NOT_SUPPORTED;
      goto ExitSetFl_1Dl_3;
      }

   // Fl=1
   // Dl=3
   // => 38400 Baud for 3.72 MHz

   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                  ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ_FAST);


   ExitSetFl_1Dl_3:
   *pSmartcardExtension->IoRequest.Information = 0L;
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetFl_1Dl_3  Exit\n",
                   DRIVER_NAME));
   return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetFl_1Dl_1(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status = STATUS_SUCCESS;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetFl_1Dl_1 Enter\n",
                   DRIVER_NAME));
   // Fl=1
   // Dl=1
   // => 9600 for 3.72 MHz

   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                  ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);


   *pSmartcardExtension->IoRequest.Information = 0L;
   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SetFl_1Dl_1  Exit\n",
                   DRIVER_NAME));
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetFWVersion (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status = STATUS_SUCCESS;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!GetFWVersion : Enter\n",
                   DRIVER_NAME)
                 );


   if (pSmartcardExtension->IoRequest.ReplyBufferLength  < sizeof (ULONG))
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitGetFWVersion;
      }
   else
      {
      *(PULONG)(pSmartcardExtension->IoRequest.ReplyBuffer) =
      pSmartcardExtension->ReaderExtension->ulFWVersion;
      }


   ExitGetFWVersion:
   *pSmartcardExtension->IoRequest.Information = sizeof(ULONG);
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!GetFWVersion : Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ReadDeviceDescription(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status = STATUS_SUCCESS;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ReadDeviceDescription : Enter\n",
                   DRIVER_NAME)
                 );


   if (pSmartcardExtension->IoRequest.ReplyBufferLength  < sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription))
      {
      status = STATUS_BUFFER_OVERFLOW;
      *pSmartcardExtension->IoRequest.Information = 0L;
      goto ExitReadDeviceDescription;
      }
   else
      {
      if (pSmartcardExtension->ReaderExtension->abDeviceDescription[0] == 0x00 &&
          pSmartcardExtension->ReaderExtension->abDeviceDescription[1] == 0x00    )
         {
         status = SCCMN50M_GetDeviceDescription(pSmartcardExtension);
         }

      if (status == STATUS_SUCCESS)
         {
         StrCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
                pSmartcardExtension->IoRequest.ReplyBufferLength,
                pSmartcardExtension->ReaderExtension->abDeviceDescription);
         *pSmartcardExtension->IoRequest.Information = StrLen(pSmartcardExtension->ReaderExtension->abDeviceDescription) +1;
         }
      else
         {
         MemSet(pSmartcardExtension->ReaderExtension->abDeviceDescription,
                sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription),
                0x00,
                sizeof(pSmartcardExtension->ReaderExtension->abDeviceDescription));

         *pSmartcardExtension->IoRequest.Information = 0;
         }

      }


   ExitReadDeviceDescription:
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ReadDeviceDescription : Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}












/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetHighSpeed_CR80S_SAMOS (IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   UCHAR bReadBuffer[16];
   ULONG ulBytesRead;
   BYTE bCR80S_SAMOS_SET_HIGH_SPEED[4] = {0xFF,0x11,0x94,0x7A};
   ULONG ulAtrLength;
   BYTE bAtr[MAXIMUM_ATR_LENGTH];

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetHighSpeed_CR80S_SAMOS : Enter\n",
                   DRIVER_NAME)
                 );



   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_SYN      | ENABLE_T0     |
                                  ENABLE_T1 );

   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             0,                                    // Tx control
                             sizeof(bCR80S_SAMOS_SET_HIGH_SPEED),  // Tx length
                             0,                                    // Rx control
                             sizeof(bCR80S_SAMOS_SET_HIGH_SPEED)); // Rx length

   status = SCCMN50M_WriteCardMan(pSmartcardExtension,
                                  sizeof(bCR80S_SAMOS_SET_HIGH_SPEED),
                                  bCR80S_SAMOS_SET_HIGH_SPEED);
   if (status != STATUS_SUCCESS)
      goto ExitSetHighSpeed;


   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
   if (status != STATUS_SUCCESS)
      goto ExitSetHighSpeed;

   if (bReadBuffer[1] > sizeof(bReadBuffer))
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitSetHighSpeed;
      }

   status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
   if (status != STATUS_SUCCESS)
      goto ExitSetHighSpeed;

   // if the card has accepted this string , the string is echoed
   if (bReadBuffer[0] == bCR80S_SAMOS_SET_HIGH_SPEED[0]  &&
       bReadBuffer[1] == bCR80S_SAMOS_SET_HIGH_SPEED[1]  &&
       bReadBuffer[2] == bCR80S_SAMOS_SET_HIGH_SPEED[2]  &&
       bReadBuffer[3] == bCR80S_SAMOS_SET_HIGH_SPEED[3]      )
      {
      SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                     ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );

      SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ_FAST);
      }
   else
      {
      DebugStatus = SCCMN50M_PowerOff(pSmartcardExtension);

      DebugStatus = SCCMN50M_PowerOn(pSmartcardExtension,&ulAtrLength,bAtr,sizeof(bAtr));
      status = STATUS_UNSUCCESSFUL;

      }




   ExitSetHighSpeed:
   *pSmartcardExtension->IoRequest.Information = 0L;
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetHighSpeed_CR80S_SAMOS : Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetBRK(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;


   pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
   pSmartcardExtension->SmartcardRequest.BufferLength = 0;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_ON;



   status =  SCCMN50M_SerialIo(pSmartcardExtension);


   return status;

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ClearBRK(IN PSMARTCARD_EXTENSION SmartcardExtension )
{
   NTSTATUS status;


   SmartcardExtension->SmartcardReply.BufferLength = SmartcardExtension->SmartcardReply.BufferSize;
   SmartcardExtension->SmartcardRequest.BufferLength = 0;

   SmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BREAK_OFF;



   status =  SCCMN50M_SerialIo(SmartcardExtension);


   return status;

}






/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetProtocol(PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   ULONG ulNewProtocol;
   UCHAR abPTSRequest[4];
   UCHAR abReadBuffer[6];
   UCHAR abPTSReply [4];
   ULONG ulBytesRead;
   UCHAR bTemp;
   ULONG ulPtsType;
   ULONG ulPTSReplyLength=0;
   ULONG  ulStatBytesRead;
   BYTE   abStatReadBuffer[2];

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetProtocol : Enter\n",
                   DRIVER_NAME)
                 );


   //
   // Check if the card is already in specific state
   // and if the caller wants to have the already selected protocol.
   // We return success if this is the case.
   //
   if ((pSmartcardExtension->CardCapabilities.Protocol.Selected & pSmartcardExtension->MinorIoControlCode))
      {
      status = STATUS_SUCCESS;
      goto ExitSetProtocol;
      }

   ulNewProtocol = pSmartcardExtension->MinorIoControlCode;



   ulPtsType = PTS_TYPE_OPTIMAL;

   // we are not sure if we need this at all
   pSmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_OPTIMAL;
   while (TRUE)
      {

      // set initial character of PTS
      abPTSRequest[0] = 0xFF;

      // set the format character
      if (pSmartcardExtension->CardCapabilities.Protocol.Supported &
          ulNewProtocol &
          SCARD_PROTOCOL_T1)
         {
         // select T=1 and indicate that PTS1 follows
         abPTSRequest[1] = 0x11;
         pSmartcardExtension->CardCapabilities.Protocol.Selected =
         SCARD_PROTOCOL_T1;
         }
      else if (pSmartcardExtension->CardCapabilities.Protocol.Supported &
               ulNewProtocol &
               SCARD_PROTOCOL_T0)
         {
         // select T=1 and indicate that PTS1 follows
         abPTSRequest[1] = 0x10;
         pSmartcardExtension->CardCapabilities.Protocol.Selected =
         SCARD_PROTOCOL_T0;
         }
      else
         {
         status = STATUS_INVALID_DEVICE_REQUEST;
         goto ExitSetProtocol;
         }

      // bug fix :
      // don 't use the suggestion from smclib
      pSmartcardExtension->CardCapabilities.PtsData.Fl =
      pSmartcardExtension->CardCapabilities.Fl;
      pSmartcardExtension->CardCapabilities.PtsData.Dl  =
      pSmartcardExtension->CardCapabilities.Dl;


      // CardMan support higher baudrates only for T=1
      // ==> Dl=1
      if (abPTSRequest[1] == 0x10)
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!overwriting PTS1 for T=0\n",
                         DRIVER_NAME)
                       );
         pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
         pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
         }


      if (ulPtsType == PTS_TYPE_DEFAULT)
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!overwriting PTS1 with default values\n",
                         DRIVER_NAME)
                       );
         pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
         pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
         }


      // set pts1 which codes Fl and Dl
      bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                      pSmartcardExtension->CardCapabilities.PtsData.Dl);

      SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ( "%s!PTS1 = %x (suggestion)\n",
                      DRIVER_NAME,bTemp)
                    );


      switch (bTemp)
         {
         case 0x11:
            // do nothing
            // we support these Fl/Dl parameters
            break;

         case 0x13:
         case 0x94:
            break ;


         case 0x14:
            // let's try it with 38400 baud
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!trying 57600 baud\n",DRIVER_NAME)
                          );
            // we must correct Fl/Dl
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x03;
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            pSmartcardExtension->CardCapabilities.PtsData.Dl);
            break;

         default:
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!overwriting PTS1(0x%x)\n",
                            DRIVER_NAME,bTemp)
                          );
            // we must correct Fl/Dl
            pSmartcardExtension->CardCapabilities.PtsData.Dl = 0x01;
            pSmartcardExtension->CardCapabilities.PtsData.Fl = 0x01;
            bTemp = (BYTE) (pSmartcardExtension->CardCapabilities.PtsData.Fl << 4 |
                            pSmartcardExtension->CardCapabilities.PtsData.Dl);
            break;


         }

      abPTSRequest[2] = bTemp;

      // set pck (check character)
      abPTSRequest[3] = (BYTE)(abPTSRequest[0] ^ abPTSRequest[1] ^ abPTSRequest[2]);

      SmartcardDebug(DEBUG_PROTOCOL,("%s!PTS request: 0x%x 0x%x 0x%x 0x%x\n",
                                     DRIVER_NAME,
                                     abPTSRequest[0],
                                     abPTSRequest[1],
                                     abPTSRequest[2],
                                     abPTSRequest[3]));


      MemSet(abPTSReply,sizeof(abPTSReply),0x00,sizeof(abPTSReply));



      DebugStatus = SCCMN50M_EnterTransparentMode(pSmartcardExtension);

      // STEP 1 : write config + header to enter transparent mode
      SCCMN50M_SetCardManHeader(pSmartcardExtension,
                                0,                         // Tx control
                                0,                         // Tx length
                                0,                         // Rx control
                                0);                       // Rx length

      status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                      0,
                                      NULL);
      if (NT_ERROR(status))
         {
         goto ExitSetProtocol;
         }


      pSmartcardExtension->ReaderExtension->fTransparentMode = TRUE;

      // if the inserted card uses inverse convention , we must now switch the COM port
      // to odd parity
      /*
      if (pSmartcardExtension->ReaderExtension->fInverseAtr == TRUE)
         {
         pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
         pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = ODD_PARITY;
         pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = SERIAL_DATABITS_8;

         pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
         RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                       &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                       sizeof(SERIAL_LINE_CONTROL));
         pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
         pSmartcardExtension->SmartcardReply.BufferLength = 0;

         status =  SCCMN50M_SerialIo(pSmartcardExtension);
         if (!NT_SUCCESS(status))
            {
            goto ExitTransparentTransmitT0;
            }
         }
      */
      SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ( "%s!writing PTS request\n",
                      DRIVER_NAME)
                    );
      status = SCCMN50M_WriteCardMan(pSmartcardExtension,
                                     4,
                                     abPTSRequest);
      if (status != STATUS_SUCCESS)
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!writing PTS request failed\n",
                         DRIVER_NAME)
                       );
         goto ExitSetProtocol;
         }



      // read back pts data
      SmartcardDebug(
                    DEBUG_PROTOCOL,
                    ( "%s!trying to read PTS reply\n",
                      DRIVER_NAME)
                    );


      // first read CardMan header
      pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,3,&ulBytesRead,abReadBuffer,sizeof(abReadBuffer));
      if (status != STATUS_SUCCESS     &&
          status != STATUS_IO_TIMEOUT      )
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!reading status failed\n",
                         DRIVER_NAME)
                       );
         goto ExitSetProtocol;
         }
      ulPTSReplyLength = 3;
      MemCpy(abPTSReply,sizeof(abPTSReply),abReadBuffer,3);



      // check if bit 5 is set
      if (abPTSReply[1] & 0x10)
         {
         pSmartcardExtension->ReaderExtension->ToRHConfig= FALSE;
         status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,abReadBuffer,sizeof(abReadBuffer));
         if (status != STATUS_SUCCESS     &&
             status != STATUS_IO_TIMEOUT      )
            {
            SmartcardDebug(
                          DEBUG_PROTOCOL,
                          ( "%s!reading status failed\n",
                            DRIVER_NAME)
                          );
            goto ExitSetProtocol;
            }
         ulPTSReplyLength += 1;
         MemCpy(&abPTSReply[3],sizeof(abPTSReply)-3,abReadBuffer,1);
         }

      DebugStatus = SCCMN50M_ExitTransparentMode(pSmartcardExtension);
      pSmartcardExtension->ReaderExtension->fTransparentMode = FALSE;

      // to be sure that the new settings take effect
      pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 250;
      DebugStatus = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
      pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
      if (NT_SUCCESS(DebugStatus))
         {
         DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulStatBytesRead,abStatReadBuffer,sizeof(abStatReadBuffer));
         }


#if DBG
      if (ulPTSReplyLength == 3)
         {
         SmartcardDebug(DEBUG_PROTOCOL,("PTS reply: 0x%x 0x%x 0x%x\n",
                                        abPTSReply[0],
                                        abPTSReply[1],
                                        abPTSReply[2]));
         }

      if (ulPTSReplyLength == 4)
         {
         SmartcardDebug(DEBUG_PROTOCOL,("PTS reply: 0x%x 0x%x 0x%x 0x%x\n",
                                        abPTSReply[0],
                                        abPTSReply[1],
                                        abPTSReply[2],
                                        abPTSReply[3]));
         }
#endif



      if (ulPTSReplyLength == 3 &&
          abPTSReply[0] == abPTSRequest[0] &&
          (abPTSReply[1] & 0x7F) == (abPTSRequest[1] & 0x0F) &&
          abPTSReply[2] == (BYTE)(abPTSReply[0] ^ abPTSReply[1]) )
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!short PTS reply received\n",
                         DRIVER_NAME)
                       );

         break;
         }

      if (ulPTSReplyLength == 4 &&
          abPTSReply[0] == abPTSRequest[0] &&
          abPTSReply[1] == abPTSRequest[1] &&
          abPTSReply[2] == abPTSRequest[2] &&
          abPTSReply[3] == abPTSRequest[3])
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!PTS request and reply match\n",
                         DRIVER_NAME)
                       );
         switch (bTemp)
            {
            case 0x11:
               break;

            case 0x13:
               SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                              ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
               SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ_FAST);
               break ;

            case 0x94:
               SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ENABLE_3MHZ      | ENABLE_5MHZ     |
                                              ENABLE_3MHZ_FAST | ENABLE_5MHZ_FAST );
               SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ_FAST);
               break;
            }
         break;
         }

      if (pSmartcardExtension->CardCapabilities.PtsData.Type !=
          PTS_TYPE_DEFAULT)
         {
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!PTS failed : Trying default parameters\n",
                         DRIVER_NAME)
                       );


         // the card did either not reply or it replied incorrectly
         // so try default valies
         ulPtsType = pSmartcardExtension->CardCapabilities.PtsData.Type = PTS_TYPE_DEFAULT;
         pSmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
         status = SCCMN50M_CardPower(pSmartcardExtension);
         continue;
         }

      // the card failed the pts request
      status = STATUS_DEVICE_PROTOCOL_ERROR;
      goto ExitSetProtocol;

      }



   ExitSetProtocol:
   switch (status)
      {
      case STATUS_IO_TIMEOUT:
         pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
         *pSmartcardExtension->IoRequest.Information = 0;
         break;


      case STATUS_SUCCESS:

         // now indicate that we're in specific mode
         pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;

         // return the selected protocol to the caller
         *(PULONG) pSmartcardExtension->IoRequest.ReplyBuffer =
         pSmartcardExtension->CardCapabilities.Protocol.Selected;

         *pSmartcardExtension->IoRequest.Information =
         sizeof(pSmartcardExtension->CardCapabilities.Protocol.Selected);
         SmartcardDebug(
                       DEBUG_PROTOCOL,
                       ( "%s!Selected protocol: T=%ld\n",
                         DRIVER_NAME,pSmartcardExtension->CardCapabilities.Protocol.Selected-1)
                       );
         break;

      default :
         pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
         *pSmartcardExtension->IoRequest.Information = 0;
         break;
      }



   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetProtocol : Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:

   The smart card lib requires to have this function. It is called
   to setup event tracking for card insertion and removal events.

Arguments:

    pSmartcardExtension - pointer to the smart card data struct.

Return Value:

    NTSTATUS

*****************************************************************************/
NTSTATUS
SCCMN50M_CardTracking(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   KIRQL oldIrql;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CardTracking: Enter\n",
                   DRIVER_NAME)
                 );

   //
   // Set cancel routine for the notification irp
   //
   IoAcquireCancelSpinLock(&oldIrql);

   IoSetCancelRoutine(pSmartcardExtension->OsData->NotificationIrp,SCCMN50M_Cancel);

   IoReleaseCancelSpinLock(oldIrql);

   //
   // Mark notification irp pending
   //
   IoMarkIrpPending(pSmartcardExtension->OsData->NotificationIrp);

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CardTracking: Exit\n",
                   DRIVER_NAME)
                 );

   return STATUS_PENDING;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_StopCardTracking(
                         IN PDEVICE_EXTENSION pDeviceExtension
                         )
{
   PSMARTCARD_EXTENSION pSmartcardExtension = &pDeviceExtension->SmartcardExtension;
   NTSTATUS status;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StopCardTracking: Enter\n",
                   DRIVER_NAME)
                 );

   if (pSmartcardExtension->ReaderExtension->ThreadObjectPointer != NULL)
      {

      // kill thread
      KeWaitForSingleObject(&pSmartcardExtension->ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL
                           );
      pSmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
      KeReleaseMutex(&pSmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);


      //
      // Wait on the thread handle, when the wait is satisfied, the
      // thread has gone away.
      //
      status = KeWaitForSingleObject(
                                    pSmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL
                                    );

      pSmartcardExtension->ReaderExtension->ThreadObjectPointer = NULL;
      }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StopCardTracking: Exit %lx\n",
                   DRIVER_NAME,
                   status)
                 );

}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_GetDeviceDescription (PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   ULONG ulBytesRead;
   BYTE bByteRead;
   ULONG i,j;
   BYTE abReadBuffer[256];
   ULONG ulPnPStringLength = 0;
   ULONG ulExtend;


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!GetDeviceDescriptiong: Enter\n",
                   DRIVER_NAME)
                 );



   // ===============================
   // clear any pending errors
   // ===============================
   status = SCCMN50M_GetCommStatus(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("SCCMN50M_GetCommStatus failed !   status = %ld\n",status))
      goto ExitGetDeviceDescription;
      }



   // =================================
   // set baudrate for CardMan to 1200
   // =================================
   pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 1200;


   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                 sizeof(SERIAL_BAUD_RATE));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
      goto ExitGetDeviceDescription;
      }


   // ===============================
   // set comm timeouts
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadIntervalTimeout         = DEFAULT_READ_INTERVAL_TIMEOUT;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT + 5000;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutMultiplier  = DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutConstant   = DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT;
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.WriteTotalTimeoutMultiplier = DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER;


   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_TIMEOUTS;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts,
                 sizeof(SERIAL_TIMEOUTS));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_TIMEOUTS);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_TIMEOUTS failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }





   // ===============================
   // set line control
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = NO_PARITY;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 7;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                 sizeof(SERIAL_LINE_CONTROL));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }




   // ===============================
   // Set handflow
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XonLimit         = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.XoffLimit        = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.FlowReplace      = 0;
   pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow.ControlHandShake = SERIAL_ERROR_ABORT | SERIAL_DTR_CONTROL;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_HANDFLOW;


   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.HandFlow,
                 sizeof(SERIAL_HANDFLOW));

   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_HANDFLOW);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_HANDFLOW failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }


   // ===============================
   //  set purge mask
   // ===============================
   pSmartcardExtension->ReaderExtension->SerialConfigData.PurgeMask =
   SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT |
   SERIAL_PURGE_TXCLEAR | SERIAL_PURGE_RXCLEAR;


   // ===============================
   //  clear RTS
   // ===============================
   status = SCCMN50M_ClearRTS(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }

   Wait(pSmartcardExtension,1);

   // ===============================
   //  set DTR
   // ===============================

   status = SCCMN50M_SetDTR(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_DRT failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }

   Wait(pSmartcardExtension,1);


   // ===============================
   //  set RTS
   // ===============================
   status = SCCMN50M_SetRTS(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_RTS failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }

   i=0;
   while (1)
      {
      pSmartcardExtension->ReaderExtension->ToRHConfig  = FALSE;
      status = SCCMN50M_ReadCardMan(pSmartcardExtension,1,&ulBytesRead,&bByteRead,sizeof(bByteRead));
      if (status == STATUS_SUCCESS)
         {
         abReadBuffer[i++] = bByteRead;
         if (bByteRead == 0x29)
            {
            ulPnPStringLength = i;
            break;
            }
         }
      else
         {
         break;
         }
      }


   if (ulPnPStringLength > 11 )
      {
      ulExtend = 0;
      for (i=0;i<ulPnPStringLength;i++)
         {
         if (abReadBuffer[i] == 0x5C)
            ulExtend++;
         if (ulExtend == 4)
            {
            j = 0;
            i++;
            while (i < ulPnPStringLength - 3)
               {
               pSmartcardExtension->ReaderExtension->abDeviceDescription[j] = abReadBuffer[i];
               i++;
               j++;
               }
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ( "%s!Device=%s\n",
                            pSmartcardExtension->ReaderExtension->abDeviceDescription)
                          );
            break;
            }

         }



      }





   // ===================
   // restore baud rate
   // ===================
   pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate      = 38400;


   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_BAUD_RATE;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.BaudRate.BaudRate,
                 sizeof(SERIAL_BAUD_RATE));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_BAUD_RATE);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_BAUDRATE failed !   status = %ld\n",status))
      goto ExitGetDeviceDescription;
      }

   // ====================
   // retore line control
   // ====================
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.StopBits   = STOP_BITS_2;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.Parity     = EVEN_PARITY;
   pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl.WordLength = 8;

   pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERIAL_SET_LINE_CONTROL;
   RtlCopyMemory(pSmartcardExtension->SmartcardRequest.Buffer,
                 &pSmartcardExtension->ReaderExtension->SerialConfigData.LineControl,
                 sizeof(SERIAL_LINE_CONTROL));
   pSmartcardExtension->SmartcardRequest.BufferLength        = sizeof(SERIAL_LINE_CONTROL);
   pSmartcardExtension->SmartcardReply.BufferLength = 0;

   status =  SCCMN50M_SerialIo(pSmartcardExtension);
   if (!NT_SUCCESS(status))
      {
      SmartcardDebug(DEBUG_ERROR,("IOCTL_SERIAL_SET_LINE_CONTROL failed !   status = %x\n",status))
      goto ExitGetDeviceDescription;
      }







   ExitGetDeviceDescription:
   DebugStatus = SCCMN50M_ResyncCardManII(pSmartcardExtension);

   if (status != STATUS_SUCCESS)
      {  // map all errors to STATUS_UNSUCCESSFULL;
      status = STATUS_UNSUCCESSFUL;
      }
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!GetDeviceDescriptiong: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SetSyncParameters(IN PSMARTCARD_EXTENSION pSmartcardExtension )
{
   NTSTATUS status = STATUS_SUCCESS;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetSyncParameters: Enter\n",
                   DRIVER_NAME)
                 );

   //DBGBreakPoint();

   pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol =
   ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulProtocol;

   pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileReading =
   ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulStateResetLineWhileReading;

   pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileWriting =
   ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulStateResetLineWhileWriting;

   pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks =
   ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulWriteDummyClocks;

   pSmartcardExtension->ReaderExtension->SyncParameters.ulHeaderLen =
   ((PSYNC_PARAMETERS)pSmartcardExtension->IoRequest.RequestBuffer)->ulHeaderLen;

   // Used for the 2 Wire Protocol. We must make a Card reset after Power On
   pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;


   // return length of reply
   *pSmartcardExtension->IoRequest.Information = 0L;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SetSyncParameters: Exit\n",
                   DRIVER_NAME)
                 );
   return status;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcTxControlByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                            IN ULONG ulBitsToWrite                        )
{
   UCHAR bTxControlByte = 0;

   if (pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol == SCARD_PROTOCOL_2WBP)
      {
      bTxControlByte = CLOCK_FORCED_2WBP;
      }
   else
      {
      if (ulBitsToWrite >=  255 * 8)
         bTxControlByte  |= TRANSMIT_A8;

      if (pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileWriting ==
          SCARD_RESET_LINE_HIGH)
         bTxControlByte  |= SYNC_RESET_LINE_HIGH;
      }

   bTxControlByte |= (BYTE)((ulBitsToWrite-1) & 0x00000007);

   return bTxControlByte;

}


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcTxLengthByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToWrite       )
{
   UCHAR bTxLengthByte = 0;

   bTxLengthByte = (BYTE)( ((ulBitsToWrite - 1) >> 3) + 1);

   return bTxLengthByte;
}


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcRxControlByte (IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN ULONG                ulBitsToRead        )
{
   UCHAR bRxControlByte = 0;


   if (pSmartcardExtension->ReaderExtension->SyncParameters.ulStateResetLineWhileReading ==
       SCARD_RESET_LINE_HIGH)
      bRxControlByte  |= SYNC_RESET_LINE_HIGH;

   if (ulBitsToRead == 0)
      {
      ulBitsToRead    = pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks;
      bRxControlByte |= SYNC_DUMMY_RECEIVE;
      }

   if (ulBitsToRead  > 255 * 8)
      bRxControlByte  |= RECEIVE_A8;

   bRxControlByte |= (BYTE)( (ulBitsToRead-1) & 0x00000007);

   return bRxControlByte;
}


//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
UCHAR
SCCMN50M_CalcRxLengthByte (IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToRead        )
{
   UCHAR bRxLengthByte = 0;

//   if (pSmartcardExtension->ReaderExtension->SyncParameters.ulProtocol == SCARD_PROTOCOL_3WBP)
//      {
   if (ulBitsToRead == 0)
      ulBitsToRead = pSmartcardExtension->ReaderExtension->SyncParameters.ulWriteDummyClocks;

   bRxLengthByte = (BYTE)( ((ulBitsToRead - 1) >> 3) + 1);
//      }

   return bRxLengthByte;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_SyncCardPowerOn  (
                          IN  PSMARTCARD_EXTENSION pSmartcardExtension
                          )
{
   NTSTATUS status;
   UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
   UCHAR  abSyncAtrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength = 0;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SyncCardPowerOn: Enter\n",
                   DRIVER_NAME)
                 );

   status = SCCMN50M_UseSyncStrategy(pSmartcardExtension,
                                     &ulAtrLength,
                                     pbAtrBuffer,
                                     sizeof(pbAtrBuffer));


   abSyncAtrBuffer[0] = 0x3B;
   abSyncAtrBuffer[1] = 0x04;
   MemCpy(&abSyncAtrBuffer[2],
          sizeof(abSyncAtrBuffer)-2,
          pbAtrBuffer,
          ulAtrLength);


   ulAtrLength += 2;

   MemCpy(pSmartcardExtension->CardCapabilities.ATR.Buffer,
          sizeof(pSmartcardExtension->CardCapabilities.ATR.Buffer),
          abSyncAtrBuffer,
          ulAtrLength);

   pSmartcardExtension->CardCapabilities.ATR.Length = (UCHAR)(ulAtrLength);

   pSmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SPECIFIC;
   pSmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_T0;
   pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = TRUE;
   pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested = FALSE;


   SmartcardDebug(DEBUG_ATR,("ATR of synchronous smart card : %2.2x %2.2x %2.2x %2.2x\n",
                             pbAtrBuffer[0],pbAtrBuffer[1],pbAtrBuffer[2],pbAtrBuffer[3]));



   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!SyncCardPowerOn: Exit %lx\n",
                   DRIVER_NAME,status)
                 );

   return status;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit2WBP(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status = STATUS_SUCCESS;
   UCHAR    bWriteBuffer [128];
   UCHAR    bReadBuffer [128];
   UCHAR    bTxControlByte;
   UCHAR    bTxLengthByte;
   UCHAR    bRxControlByte;
   UCHAR    bRxLengthByte;
   ULONG    ulBytesToWrite;
   ULONG    ulBytesToRead;
   ULONG    ulBitsToWrite;
   ULONG    ulBitsToRead;
   ULONG    ulBytesRead;
//   ULONG    ulBitsRead;
   ULONG    ulBytesStillToRead;
   ULONG    ulMaxIFSD;
   PCHAR    pbInData;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!Transmit2WBP: Enter\n",
                   DRIVER_NAME)
                 );


   /*-----------------------------------------------------------------------*/
   /** Power smartcard - if smartcard was removed and reinserted           **/
   /*-----------------------------------------------------------------------*/
   if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested == TRUE)
      {
      status = SCCMN50M_SyncCardPowerOn (pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         goto ExitTransmit2WBP;
         }
      }


   pbInData       = pSmartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToWrite  = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
   ulBitsToRead   = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToWrite = ulBitsToWrite/8;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);

   /*-----------------------------------------------------------------------*/
   // check buffer sizes
   /*-----------------------------------------------------------------------*/
   ulMaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;


   if (ulBytesToRead > ulMaxIFSD                                         ||
       ulBytesToRead > pSmartcardExtension->SmartcardReply.BufferSize)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit2WBP;
      }

   if (ulBytesToWrite > pSmartcardExtension->SmartcardRequest.BufferSize)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit2WBP;
      }

   pSmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWrite+1;

   /*-----------------------------------------------------------------------*/
   // copy data to the Smartcard Request Buffer
   /*-----------------------------------------------------------------------*/
   (pSmartcardExtension->SmartcardRequest.Buffer)[0] = '\x0F';
   MemCpy((pSmartcardExtension->SmartcardRequest.Buffer+1),
          pSmartcardExtension->SmartcardRequest.BufferSize,
          pbInData,
          ulBytesToWrite);

   /*-----------------------------------------------------------------------*/
   // copy data to the write buffer
   /*-----------------------------------------------------------------------*/
   MemCpy((bWriteBuffer),
          sizeof(bWriteBuffer),
          pSmartcardExtension->SmartcardRequest.Buffer,
          (ulBytesToWrite+1));


   /*-----------------------------------------------------------------------*/
   // set SYNC protocol flag for CardMan
   /*-----------------------------------------------------------------------*/
   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

   /*-----------------------------------------------------------------------*/
   // Header
   /*-----------------------------------------------------------------------*/
   if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested == TRUE)
      {
      status = SCCMN50M_ResetCard2WBP(pSmartcardExtension);
      if (NT_ERROR(status))
         {
         goto ExitTransmit2WBP;
         }

      pSmartcardExtension->ReaderExtension->SyncParameters.fCardResetRequested = FALSE;
      }

   /*-----------------------------------------------------------------------*/
   // 1. Send Carman-Header   4-Byte
   // 2. Send 0x0F, that builds a HIGH-LOW Edge for 4432 CC
   // 3. Send the Data (CC command = 3 Byte)
   /*-----------------------------------------------------------------------*/
   bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension,ulBitsToWrite);
   bTxLengthByte =  (BYTE)(SCCMN50M_CalcTxLengthByte(pSmartcardExtension,ulBitsToWrite)+1);
   bRxControlByte = 0;
   bRxLengthByte =  0;

   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             bTxControlByte,
                             bTxLengthByte,
                             bRxControlByte,
                             bRxLengthByte);

   /*-----------------------------------------------------------------------*/
   // write data to card
   /*-----------------------------------------------------------------------*/
   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   (ulBytesToWrite+1),
                                   bWriteBuffer);
   if (NT_ERROR(status))
      {
      goto ExitTransmit2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   // no Data from CC received
   /*-----------------------------------------------------------------------*/
   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 2,
                                 &ulBytesRead,
                                 bReadBuffer,
                                 sizeof(bReadBuffer));

   if (NT_ERROR(status))
      {
      goto ExitTransmit2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // 1. Send Carman-Header   4-Byte
   // 2. Send 0xF0, that builds a LOW-HIGH Edge for 4432 CC
   // 3. Now the receiviing of card-data begins
   /*-----------------------------------------------------------------------*/
   bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension, 8);
   bTxLengthByte =  SCCMN50M_CalcTxLengthByte(pSmartcardExtension, 8);
   bRxControlByte = SCCMN50M_CalcRxControlByte(pSmartcardExtension,ulBitsToRead);
   bRxLengthByte =  SCCMN50M_CalcRxLengthByte(pSmartcardExtension,ulBitsToRead);

   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             bTxControlByte,
                             bTxLengthByte,
                             bRxControlByte,
                             bRxLengthByte);

   /*-----------------------------------------------------------------------*/
   // in this sequnce SCCMN50M_WriteCardMan must not send the Config string.
   // write 0xF0 -> is the trigger to read data from card or start the
   // processing.
   /*-----------------------------------------------------------------------*/
   pSmartcardExtension->ReaderExtension->NoConfig = TRUE;

   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   1,                       // one byte to write
                                   "\xF0");                 // LOW-HIGH - Edge
   if (NT_ERROR(status))
      {
      goto ExitTransmit2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   // Data from CC received will be received
   /*-----------------------------------------------------------------------*/
   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 2,
                                 &ulBytesRead,
                                 bReadBuffer,
                                 sizeof(bReadBuffer));

   if (NT_ERROR(status))
      {
      goto ExitTransmit2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // Read the data string
   /*-----------------------------------------------------------------------*/
   ulBytesStillToRead = (ULONG)bReadBuffer[1];

   if (bReadBuffer[0] & RECEIVE_A8)
      ulBytesStillToRead += 256;

   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 ulBytesStillToRead,
                                 &ulBytesRead,
                                 bReadBuffer,
                                 sizeof(bReadBuffer));

   if (NT_ERROR(status))
      {
      goto ExitTransmit2WBP;
      }

   /*-----------------------------------------------------------------------*/
   /** calculate data length in bits  -  this value is not used            **/
   /*-----------------------------------------------------------------------*/
// ulBitsRead = ((ulBytesRead-1) * 8) + ((ulBitsToRead-1 ) & 0x00000007) + 1;

   /*-----------------------------------------------------------------------*/
   /** shift the bits in the last byte to the correct position             **/
   /*-----------------------------------------------------------------------*/
   bReadBuffer[ulBytesRead-1]  >>= (7 - ((ulBitsToRead-1) & 0x00000007));

   /*-----------------------------------------------------------------------*/
   // the first bit of the returned string is lost
   // so we must shift the whole data string one bit left
   // the first bit of the first data byte is lost while reading
   // this bit maybe incorrect
   /*-----------------------------------------------------------------------*/
   SCCMN50M_Shift_Msg(bReadBuffer, ulBytesRead);

   /*-----------------------------------------------------------------------*/
   // copy received bytes to Smartcard Reply Buffer
   /*-----------------------------------------------------------------------*/
   MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
          pSmartcardExtension->SmartcardReply.BufferSize,
          bReadBuffer,
          ulBytesRead);

   pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // copy received bytes to IoReply Buffer
   /*-----------------------------------------------------------------------*/
   MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
          pSmartcardExtension->IoRequest.ReplyBufferLength,
          pSmartcardExtension->SmartcardReply.Buffer,
          ulBytesRead);

   *(pSmartcardExtension->IoRequest.Information) = ulBytesRead;


   ExitTransmit2WBP:
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!Transmit2WBP: Exit\n",
                   DRIVER_NAME,status)
                 );
   return status;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_Shift_Msg (PUCHAR  pbBuffer,
                    ULONG   ulMsgLen)
{
   UCHAR  bTmp1, bTmp2;
   int    i;

   for (i=(int)ulMsgLen-1; i>=0; i--)
      {
      bTmp1=(BYTE)((pbBuffer[i] >> 7) & 0x01);      /* bTmp1 = bit 7 naechstes byte */
      if (i+1 != (int)ulMsgLen)
         {
         bTmp2=(BYTE)((pbBuffer[i+1] << 1) | bTmp1);
         pbBuffer[i+1] = bTmp2;
         }
      }

   pbBuffer[0] = (BYTE)(pbBuffer[0] << 1);

   return;
}



/*****************************************************************************
Routine Description:

  Reset Card 4442


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_ResetCard2WBP(IN PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status = STATUS_SUCCESS;
   BYTE     bBuffer[10];
   ULONG    ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // Enter Card Reset
   /*-----------------------------------------------------------------------*/
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetCard2WBP: Enter\n",
                   DRIVER_NAME)
                 );

   /*-----------------------------------------------------------------------*/
   //      bTxControlByte = 0;
   //      bTxLengthByte =  0;
   //      bRxControlByte = RESET_CARD;
   //      bRxLengthByte =  5;
   /*-----------------------------------------------------------------------*/

   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             0,                        // bTxControlByte
                             0,                        // bTxLengthByte
                             COLD_RESET,               // bRxControlByte
                             5);                       // bRxLengthByte


   /*-----------------------------------------------------------------------*/
   // write data to card
   /*-----------------------------------------------------------------------*/
   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   0,
                                   NULL);
   if (NT_ERROR(status))
      {
      goto ExitResetCard2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // read CardMan Header
   /*-----------------------------------------------------------------------*/
   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 2, &ulBytesRead, bBuffer, sizeof(bBuffer));

   if (NT_ERROR(status))
      {
      goto ExitResetCard2WBP;
      }

   if (bBuffer[1] != 5)
      {
      status = !STATUS_SUCCESS;
      goto ExitResetCard2WBP;
      }

   /*-----------------------------------------------------------------------*/
   // read ATR
   /*-----------------------------------------------------------------------*/
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 5, &ulBytesRead, bBuffer, sizeof(bBuffer));

   if (NT_ERROR(status))
      {
      goto ExitResetCard2WBP;
      }

   SmartcardDebug(DEBUG_ATR,("%s!Card Reset ATR : %02x %02x %02x %02x\n",
                             DRIVER_NAME,bBuffer[0],bBuffer[1],bBuffer[2],bBuffer[3]));

   ExitResetCard2WBP:
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!ResetCard2WBP: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}





/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Transmit3WBP(PSMARTCARD_EXTENSION pSmartcardExtension)
{
   NTSTATUS status = STATUS_SUCCESS;
   UCHAR    bWriteBuffer [128];
   UCHAR    bReadBuffer [128];
   UCHAR    bTxControlByte;
   UCHAR    bTxLengthByte;
   UCHAR    bRxControlByte;
   UCHAR    bRxLengthByte;
   ULONG    ulBytesToWrite;
   ULONG    ulBytesToRead;
   ULONG    ulBitsToWrite;
   ULONG    ulBitsToRead;
   ULONG    ulBytesRead;
//   ULONG    ulBitsRead;
   ULONG    ulBytesStillToRead;
   ULONG    ulMaxIFSD;
   PCHAR    pbInData;



   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!Transmit3WBP: Enter\n",
                   DRIVER_NAME)
                 );
//   DBGBreakPoint();

   /*-----------------------------------------------------------------------*/
   /** Power smartcard - if smartcard was removed and reinserted           **/
   /*-----------------------------------------------------------------------*/
   if (pSmartcardExtension->ReaderExtension->SyncParameters.fCardPowerRequested == TRUE)
      {
      status = SCCMN50M_SyncCardPowerOn (pSmartcardExtension);
      if (status != STATUS_SUCCESS)
         {
         goto ExitTransmit3WBP;
         }
      }


   pbInData       = pSmartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToWrite  = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
   ulBitsToRead   = ((PSYNC_TRANSFER)(pSmartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToWrite = ulBitsToWrite/8;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);

   /*-----------------------------------------------------------------------*/
   // check buffer sizes
   /*-----------------------------------------------------------------------*/
   ulMaxIFSD = ATTR_MAX_IFSD_CARDMAN_II;


   if (ulBytesToRead > ulMaxIFSD                                         ||
       ulBytesToRead > pSmartcardExtension->SmartcardReply.BufferSize)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit3WBP;
      }

   if (ulBytesToWrite > pSmartcardExtension->SmartcardRequest.BufferSize)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit3WBP;
      }

   pSmartcardExtension->SmartcardRequest.BufferLength = ulBytesToWrite;

   /*-----------------------------------------------------------------------*/
   // copy data to the Smartcard Request Buffer
   /*-----------------------------------------------------------------------*/
   MemCpy(pSmartcardExtension->SmartcardRequest.Buffer,
          pSmartcardExtension->SmartcardRequest.BufferSize,
          pbInData,
          ulBytesToWrite);

   /*-----------------------------------------------------------------------*/
   // copy data to the write buffer
   /*-----------------------------------------------------------------------*/
   MemCpy(bWriteBuffer,
          sizeof(bWriteBuffer),
          pSmartcardExtension->SmartcardRequest.Buffer,
          ulBytesToWrite);



   /*-----------------------------------------------------------------------*/
   // set SYNC protocol flag for CardMan
   /*-----------------------------------------------------------------------*/
   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

   /*-----------------------------------------------------------------------*/
   // build cardman header
   /*-----------------------------------------------------------------------*/
   bTxControlByte = SCCMN50M_CalcTxControlByte(pSmartcardExtension,ulBitsToWrite);
   bTxLengthByte =  SCCMN50M_CalcTxLengthByte(pSmartcardExtension,ulBitsToWrite);
   bRxControlByte = SCCMN50M_CalcRxControlByte(pSmartcardExtension,ulBitsToRead);
   bRxLengthByte =  SCCMN50M_CalcRxLengthByte(pSmartcardExtension,ulBitsToRead);

   SCCMN50M_SetCardManHeader(pSmartcardExtension,
                             bTxControlByte,
                             bTxLengthByte,
                             bRxControlByte,
                             bRxLengthByte);


   /*-----------------------------------------------------------------------*/
   /** write data to card                                                  **/
   /*-----------------------------------------------------------------------*/
   status = SCCMN50M_WriteCardMan (pSmartcardExtension,
                                   ulBytesToWrite,
                                   bWriteBuffer);
   if (NT_ERROR(status))
      {
      goto ExitTransmit3WBP;
      }

   /*-----------------------------------------------------------------------*/
   /** read CardMan Header                                                 **/
   /*-----------------------------------------------------------------------*/
   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
   if (NT_ERROR(status))
      {
      goto ExitTransmit3WBP;
      }

   /*-----------------------------------------------------------------------*/
   // calc data length to receive
   /*-----------------------------------------------------------------------*/
   ulBytesStillToRead = (ULONG)(bReadBuffer[1]);
   if (bReadBuffer[0] & RECEIVE_A8)
      ulBytesStillToRead += 256;


   // read data from card
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,
                                 ulBytesStillToRead,
                                 &ulBytesRead,
                                 bReadBuffer,
                                 sizeof(bReadBuffer));
   if (NT_ERROR(status))
      {
      goto ExitTransmit3WBP;
      }

   /*-----------------------------------------------------------------------*/
   // calculate data length in bits  -  this value is not used
   /*-----------------------------------------------------------------------*/
// ulBitsRead = ((ulBytesRead-1) * 8) + ((ulBitsToRead-1 ) & 0x00000007) + 1;

   /*-----------------------------------------------------------------------*/
   // shift the bits in the last byte to the correct position
   /*-----------------------------------------------------------------------*/
   bReadBuffer[ulBytesRead-1]  >>= (7 - ((ulBitsToRead-1) & 0x00000007));


   /*-----------------------------------------------------------------------*/
   // copy received bytes to Smartcard Reply Buffer
   /*-----------------------------------------------------------------------*/
   MemCpy(pSmartcardExtension->SmartcardReply.Buffer,
          pSmartcardExtension->SmartcardReply.BufferSize,
          bReadBuffer,
          ulBytesRead);

   pSmartcardExtension->SmartcardReply.BufferLength = ulBytesRead;

   /*-----------------------------------------------------------------------*/
   // copy received bytes to IoReply Buffer
   // this Memcpy should respond to SmartcardRawReply function
   /*-----------------------------------------------------------------------*/
   MemCpy(pSmartcardExtension->IoRequest.ReplyBuffer,
          pSmartcardExtension->IoRequest.ReplyBufferLength,
          pSmartcardExtension->SmartcardReply.Buffer,
          ulBytesRead);

   *pSmartcardExtension->IoRequest.Information = ulBytesRead;


   ExitTransmit3WBP:
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!Transmit3WBP: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   return status;
}



/*****************************************************************************
Routine Description:

   This function powers a synchronous smart card.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_UseSyncStrategy  (
                          IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                          OUT   PULONG pulAtrLength,
                          OUT   PUCHAR pbAtrBuffer,
                          IN    ULONG  ulAtrBufferSize
                          )
{
   NTSTATUS status;
   NTSTATUS DebugStatus;
   UCHAR  bReadBuffer[SCARD_ATR_LENGTH];
   ULONG  ulBytesRead;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!UseSyncStrategy: Enter\n",
                   DRIVER_NAME)
                 );
   //DBGBreakPoint();

   SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,SYNC_ATR_RX_CONTROL,ATR_LEN_SYNC);
   pSmartcardExtension->ReaderExtension->CardManConfig.ResetDelay   = SYNC_RESET_DELAY;
   pSmartcardExtension->ReaderExtension->CardManConfig.CardStopBits = 0x02;

   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);
   SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY );

   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_SYN);

   status = SCCMN50M_ResyncCardManII(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      goto ExitPowerSynchronousCard;
      }


   // write config + header
   status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   if (status != STATUS_SUCCESS)
      {
      goto ExitPowerSynchronousCard;
      }


   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;
   // read state and length
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
   if (status != STATUS_SUCCESS)
      {
      goto ExitPowerSynchronousCard;
      }

   if (bReadBuffer[1] < MIN_ATR_LEN )
      {
      // read all remaining bytes from the CardMan
      DebugStatus = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],&ulBytesRead,bReadBuffer,sizeof(bReadBuffer));
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitPowerSynchronousCard;
      }

   if (bReadBuffer[1] > ulAtrBufferSize)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitPowerSynchronousCard;
      }

   // read ATR
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,bReadBuffer[1],pulAtrLength,pbAtrBuffer,ulAtrBufferSize);
   if (status != STATUS_SUCCESS)
      {
      goto ExitPowerSynchronousCard;
      }

   if (pbAtrBuffer[0] == 0x00   ||
       pbAtrBuffer[0] == 0xff       )
      {
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitPowerSynchronousCard;
      }
   pSmartcardExtension->ReaderExtension->fRawModeNecessary = TRUE;


   ExitPowerSynchronousCard:
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!UseSyncStrategy: Exit %lx\n",
                   DRIVER_NAME,status)
                 );
   SCCMN50M_ClearSCRControlFlags(pSmartcardExtension,IGNORE_PARITY | CM2_GET_ATR);
   SCCMN50M_ClearCardManHeader(pSmartcardExtension);
   return status;
}


/*****************************************************************************
Routine Description:

 This function checks if the inserted card is a synchronous one


Arguments:



Return Value:

*****************************************************************************/
BOOLEAN
SCCMN50M_IsAsynchronousSmartCard(
                                IN PSMARTCARD_EXTENSION pSmartcardExtension
                                )
{
   NTSTATUS status;
   UCHAR  ReadBuffer[3];
   ULONG  ulBytesRead;
   BOOLEAN   fIsAsynchronousSmartCard = TRUE;
   UCHAR  abATR[33];

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IsAsynchronousSmartcard: Enter \n",
                   DRIVER_NAME)
                 );

   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant = 200;

   // 3MHz smart card ?
   SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);

   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

   SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);

   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_3MHZ);

   // write config + header
   status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   if (status != STATUS_SUCCESS)
      {
      goto ExitIsAsynchronousSmartCard;
      }

   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   // read state and length
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
   if (status == STATUS_SUCCESS    &&
       ReadBuffer[1] == 0x01          )
      {
      goto ExitIsAsynchronousSmartCard;
      }



   // ---------------------------------------
   // power off card
   // ---------------------------------------
   status = SCCMN50M_PowerOff(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      goto ExitIsAsynchronousSmartCard;
      }


   // 5MHz smart card ?
   SCCMN50M_SetCardManHeader(pSmartcardExtension,0,0,0,1);

   SCCMN50M_ClearCardControlFlags(pSmartcardExtension,ALL_FLAGS);

   SCCMN50M_SetSCRControlFlags(pSmartcardExtension,CARD_POWER| IGNORE_PARITY | CM2_GET_ATR);

   SCCMN50M_SetCardControlFlags(pSmartcardExtension,ENABLE_5MHZ);

   // write config + header
   status = SCCMN50M_WriteCardMan(pSmartcardExtension,0,NULL);
   if (status != STATUS_SUCCESS)
      {
      goto ExitIsAsynchronousSmartCard;
      }

   pSmartcardExtension->ReaderExtension->ToRHConfig = FALSE;

   // read state and length
   status = SCCMN50M_ReadCardMan(pSmartcardExtension,2,&ulBytesRead,ReadBuffer,sizeof(ReadBuffer));
   if (status == STATUS_SUCCESS    &&
       ReadBuffer[1] == 0x01          )
      {
      goto ExitIsAsynchronousSmartCard;
      }

   // now we assume that it is a synchronous smart card
   fIsAsynchronousSmartCard = FALSE;
   // ---------------------------------------
   // power off card
   // ---------------------------------------
   status = SCCMN50M_PowerOff(pSmartcardExtension);
   if (status != STATUS_SUCCESS)
      {
      goto ExitIsAsynchronousSmartCard;
      }



   ExitIsAsynchronousSmartCard:
   pSmartcardExtension->ReaderExtension->SerialConfigData.Timeouts.ReadTotalTimeoutConstant    = DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT;
   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!IsAsynchronousSmartcard: Exit \n",
                   DRIVER_NAME)
                 );
   return fIsAsynchronousSmartCard;
}



/*****************************************************************************
* History:
* $Log: sccmcb.c $
* Revision 1.7  2001/01/22 08:39:41  WFrischauf
* No comment given
*
* Revision 1.6  2000/09/25 10:46:22  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/24 09:05:44  TBruendl
* No comment given
*
* Revision 1.4  2000/08/16 08:24:04  TBruendl
* warning :uninitialized memory removed
*
* Revision 1.3  2000/07/28 09:24:12  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.16  2000/06/27 11:56:28  TBruendl
* workaraound for SAMOR smart cards with invalid ATR (ITSEC)
*
* Revision 1.15  2000/06/08 10:08:47  TBruendl
* bug fix : warm reset for ScfW
*
* Revision 1.14  2000/05/23 09:58:26  TBruendl
* OMNIKEY 3.0.0.1
*
* Revision 1.13  2000/04/13 08:07:22  TBruendl
* PPS bug fix for SCfW
*
* Revision 1.12  2000/04/04 07:52:18  TBruendl
* problem with the new WfsC fixed
*
* Revision 1.11  2000/03/03 09:50:50  TBruendl
* No comment given
*
* Revision 1.10  2000/03/01 09:32:04  TBruendl
* R02.20.0
*
* Revision 1.9  2000/01/04 10:40:33  TBruendl
* bug fix: status instead of DebugStatus used
*
* Revision 1.8  1999/12/16 14:10:16  TBruendl
* After transparent mode has been left, the status is read from the CardMan to be sure that
* the new settings are effective.
*
* Revision 1.6  1999/12/13 07:55:38  TBruendl
* Bug fix for P+ druing initialization
* PTS for 4.9 mhz smartcards added
*
* Revision 1.5  1999/11/04 07:53:21  WFrischauf
* bug fixes due to error reports 2 - 7
*
* Revision 1.4  1999/07/12 12:49:04  TBruendl
* Bug fix: Resync after GET_DEVICE_DESCRIPTION
*               Power On SLE4428
*
* Revision 1.3  1999/06/10 09:03:57  TBruendl
* No comment given
*
* Revision 1.2  1999/02/25 10:12:22  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:37  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmusbm\pcsc_cm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmapiifd/sw/sccmusbm.ms/rcs/pcsc_cm.h $
* $Revision: 1.1 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright (c) 1996-99 Utimaco Safeware AG
******************************************************************************/

#ifndef _INC_PCSC_CM
#define _INC_PCSC_CM

/*****************************************************************************/
/** includes                                                                **/
/*****************************************************************************/

#include <winsmcrd.h>
#include <devioctl.h>

/*****************************************************************************/
/** constants                                                               **/
/*****************************************************************************/

#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED_OLD       SCARD_CTL_CODE (0x8100)

#define CM_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
#define CM_IOCTL_GET_FW_VERSION_OLD                   SCARD_CTL_CODE (0x8101)

//#define CM_SPE_SECURE_PIN_ENTRY                    SCARD_CTL_CODE (0x8102)
//#define CM_IOCTL_IS_SPE_SUPPORTED                   SCARD_CTL_CODE (3003)
//#define CM_IOCTL_IS_SPE_SUPPORTED_OLD               SCARD_CTL_CODE (0x8103)

#define CM_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)

#define CM_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
#define CM_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
#define CM_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
#define CM_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
#define CM_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)

#define CM_IOCTL_SET_READER_38400_BAUD                SCARD_CTL_CODE (3020)
#define CM_IOCTL_SET_READER_9600_BAUD                 SCARD_CTL_CODE (3021)

#define CM_IOCTL_OPEN_CT_INTERFACE                    SCARD_CTL_CODE (3022)
#define CM_IOCTL_CLOSE_CT_INTERFACE                   SCARD_CTL_CODE (3023)
#define CM_IOCTL_GET_CT_STATE                         SCARD_CTL_CODE (3024)


//****************************************************************************
//* SYNCHRONOUS SMART CARDS
//****************************************************************************
#define SCARD_RESET_LINE_HIGH      0x00000001
#define SCARD_RESET_LINE_LOW       0x00000000

#define SCARD_PROTOCOL_2WBP        0x00000001
#define SCARD_PROTOCOL_3WBP        0x00000002

//#define CLOCK_FORDCED_2WBP         0x00000040

//----------------------------------------------------------------------------
// structure for "CM_IOCTL_SET_SYNC_PARAMETERS" IO-Control (CrasControl)
//----------------------------------------------------------------------------
#ifndef BOOL
   #define BOOL unsigned int
#endif

typedef struct _SYNC_PARAMETERS {
   ULONG  ulProtocol;
   ULONG  ulStateResetLineWhileReading;
   ULONG  ulStateResetLineWhileWriting;
   ULONG  ulWriteDummyClocks;
   ULONG  ulHeaderLen;
   BOOL   fCardResetRequested;
   BOOL   fCardPowerRequested;
} SYNC_PARAMETERS, *PSYNC_PARAMETERS;


//----------------------------------------------------------------------------
//  structure for CM_IOCTL_2WBP_TRANSFER and  CM_IOCTL_3WBP_TRANSFER
//  IO-Control (CRASControl)
//----------------------------------------------------------------------------
typedef struct _SYNC_TRANSFER
{
   ULONG ulSyncBitsToWrite;
   ULONG ulSyncBitsToRead;
}SYNC_TRANSFER, *PSYNC_TRANSFER;

#endif /* _INC_PCSC_CM */


/*****************************************************************************
* History:
* $Log: pcsc_cm.h $
* Revision 1.1  2000/03/29 06:08:13  TBruendl
* No comment given
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmn50m\sccmn50m.h ===
/*****************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmn50m.h $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#ifndef _CARDMAN_
   #define _CARDMAN_


// ****************************************************************************
//                    DEFINES
// ****************************************************************************
   #define DRIVER_NAME "SCCMN50M"
   #define SMARTCARD_POOL_TAG 'CMCS'

   #include <ntddk.h>
   #include <ntddser.h>

   #include "smclib.h"
   #include "sccmlog.h"

   #include "pcsc_cm.h"

   #define SMARTCARD_READ          SCARD_CTL_CODE(1000)
   #define SMARTCARD_WRITE         SCARD_CTL_CODE(1001)

   #define CARDMAN_DEVICE_NAME L"\\Device\\CM_2010_0"


   #define IFD_NT_VERSIONMAJOR_CARDMAN  3
   #define IFD_NT_VERSIONMINOR_CARDMAN  2
   #define IFD_NT_BUILDNUMBER_CARDMAN   1


   #define ATTR_VENDOR_NAME         "OMNIKEY"
   #define ATTR_IFD_TYPE_CM     "CardMan 2010"

   #define ATTR_MAX_IFSD_CARDMAN_II  80


   #define WAIT_MS  -10000
   #define ms_       1

   #define UNKNOWN    0xFFFFFFFF
   #define REMOVED    0x00000001
   #define INSERTED   0x00000002
   #define POWERED    0x00000004


// SCR control byte
   #define IGNORE_PARITY         0x01
   #define XMIT_HANDSHAKE_OFF    0x02
   #define CM2_GET_ATR           0x04
//#define reserved              0x08
   #define TO_STATE_XH           0x10
   #define LEDS_OFF              0x20
   #define LEDS_RED              0x40
   #define CARD_POWER            0x80


// card control byte
   #define INVERSE_DATA          0x01
   #define ENABLE_5MHZ_FAST      0x02
   #define ENABLE_3MHZ_FAST      0x04
   #define ENABLE_5MHZ           0x08
   #define ENABLE_3MHZ           0x00
   #define ENABLE_SYN            0x10
   #define ENABLE_T0             0x20
   #define ENABLE_T1             0x40
   #define ENABLE_CRC            0x80

   #define ALL_FLAGS             0xFF

// tx control byte
   #define  SYNC_RESET_LINE_HIGH    0x80
   #define  SYNC_RESET_LINE_LOW     0x00
   #define  CLOCK_FORCED_2WBP       0x40
   #define  TRANSMIT_A8             0x08
   #define  SYNC_DUMMY_RECEIVE      0x10

// rx control byte

   #define T0_DATA_TO_CARD          0x80
   #define T0_DATA_FROM_CARD        0x00
   #define COLD_RESET               0x40
   #define RECEIVE_A8               0x08

   #define DEFAULT_READ_INTERVAL_TIMEOUT           1000
   #define DEFAULT_READ_TOTAL_TIMEOUT_MULTIPLIER     50
   #define DEFAULT_READ_TOTAL_TIMEOUT_CONSTANT     1500
   #define DEFAULT_WRITE_TOTAL_TIMEOUT_MULTIPLIER    50
   #define DEFAULT_WRITE_TOTAL_TIMEOUT_CONSTANT     250


// for protocol T=0
   #define T0_HEADER_LEN  0x05
   #define T0_STATE_LEN   0x02

// for protocol T=1
   #define T1_HEADER_LEN   0x03
   #define MAX_EDC_LEN     0x02



// for power on
   #define RESET_DELAY_SYNC              0x01

   #define ASYNC3_CARD                   0x00
   #define ASYNC5_CARD                   0x01


   #define ATR_LEN_SYNC                   4
   #define ATR_LEN_ASYNC                 33



   #define CHAR_INV                      0x03
   #define CHAR_NORM                     0x3B


   #define MIN_ATR_LEN                   0x03

   #define SYNC_ATR_RX_CONTROL           0x47
   #define SYNC_RESET_DELAY              0x01


   #define TS_OFFSET                     0
   #define T0_OFFSET                     1




typedef enum _READER_POWER_STATE
   {
   PowerReaderUnspecified = 0,
   PowerReaderWorking,
   PowerReaderOff
   } READER_POWER_STATE, *PREADER_POWER_STATE;

typedef struct _SERIAL_READER_CONFIG
   {
   // flow control
   SERIAL_HANDFLOW HandFlow;

   // special characters
   SERIAL_CHARS SerialChars;

   // read/write timeouts
   SERIAL_TIMEOUTS Timeouts;

   // Baudrate for reader
   SERIAL_BAUD_RATE BaudRate;

   // Stop bits, parity configuration
   SERIAL_LINE_CONTROL LineControl;

   //
   // current status of the serial port for IOCTL_GET_COMMSTATUS
   //
   SERIAL_STATUS SerialStatus;

   // mask for purge operation
   ULONG PurgeMask;

   } SERIAL_READER_CONFIG, *PSERIAL_READER_CONFIG;

typedef struct _CARDMAN_CONFIG
   {
   UCHAR SCRControl;
   UCHAR CardControl;
   UCHAR CardStopBits;
   UCHAR ResetDelay;
   } CARDMAN_CONFIG, *PCARDMAN_CONFIG;

typedef struct _CARDMAN_HEADER
   {
   UCHAR TxControl;
   UCHAR TxLength;
   UCHAR RxControl;
   UCHAR RxLength;
   } CARDMAN_HEADER, *PCARDMAN_HEADER;



typedef struct _DEVICE_EXTENSION
   {
   // Our smart card extension
   SMARTCARD_EXTENSION SmartcardExtension;

   // The current number of io-requests
   LONG IoCount;

   // Used to signal that the reader is able to process reqeusts
   KEVENT ReaderStarted;

   // Used to signal the the reader has been closed
   KEVENT ReaderClosed;

   // Used to signal that the connection to the serial driver has been closed
   KEVENT SerialCloseDone;

   ULONG DeviceInstance;

   // The pnp device name of our smart card reader
   UNICODE_STRING PnPDeviceName;


   KSPIN_LOCK SpinLock;


   } DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION
   {

   HANDLE hThread;

   // DeviceObject pointer to serial port
   PDEVICE_OBJECT AttachedDeviceObject;

   // IoRequest to be send to serial driver
   ULONG SerialIoControlCode;


   // Saved card state for hibernation/sleeping modes.
   BOOLEAN CardPresent;

   // Current reader power state.
   READER_POWER_STATE ReaderPowerState;



   BOOLEAN              TimeToTerminateThread;
   PVOID                ThreadObjectPointer;
   KMUTEX               CardManIOMutex;
   SERIAL_READER_CONFIG SerialConfigData;
   BOOLEAN              NoConfig;
   BOOLEAN              ToRHConfig;
   BOOLEAN              BreakSet;
   ULONG                SerialErrors;
   CARDMAN_CONFIG       CardManConfig;
   CARDMAN_HEADER       CardManHeader;
   ULONG                ulOldCardState;
   ULONG                ulNewCardState;
   BOOLEAN              fRawModeNecessary;
   ULONG                ulFWVersion;
   BOOLEAN              fSPESupported;
   BOOLEAN              fTransparentMode;
   BOOLEAN              fInverseAtr;
   UCHAR                abDeviceDescription[42];
   SYNC_PARAMETERS      SyncParameters;
   } READER_EXTENSION, *PREADER_EXTENSION;

   #define READER_EXTENSION(member) (SmartcardExtension->ReaderExtension->member)
   #define ATTACHED_DEVICE_OBJECT deviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject




// ****************************************************************************
//                    PROTOTYPES
// ****************************************************************************
NTSTATUS
SCCMN50M_AddDevice (
                   IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT PhysicalDeviceObject
                   );


NTSTATUS
SCCMN50M_CallSerialDriver (
                          IN PDEVICE_OBJECT DeviceObject,
                          IN PIRP Irp
                          );

NTSTATUS
SCCMN50M_Cancel (
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                );


NTSTATUS
SCCMN50M_Cleanup (
                 IN PDEVICE_OBJECT DeviceObject,
                 IN PIRP Irp
                 );

VOID
SCCMN50M_ClearCardControlFlags (
                               IN PSMARTCARD_EXTENSION pSmartcardExtension,
                               IN UCHAR Flags
                               );

VOID
SCCMN50M_ClearCardManHeader (
                            IN PSMARTCARD_EXTENSION pSmartcardExtension
                            );

VOID
SCCMN50M_ClearSCRControlFlags (
                              IN PSMARTCARD_EXTENSION pSmartcardExtension,
                              IN UCHAR Flags
                              );
VOID
SCCMN50M_CompleteCardTracking (
                              IN PSMARTCARD_EXTENSION SmartcardExtension
                              );

NTSTATUS
SCCMN50M_CreateClose (
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     );

NTSTATUS
SCCMN50M_CreateDevice (
                      IN  PDRIVER_OBJECT DriverObject,
                      IN PDEVICE_OBJECT PhysicalDeviceObject,
                      OUT PDEVICE_OBJECT *DeviceObject
                      );

NTSTATUS
SCCMN50M_DeviceControl (
                       PDEVICE_OBJECT DeviceObject,
                       PIRP Irp
                       );

VOID
SCCMN50M_DriverUnload (
                      IN PDRIVER_OBJECT DriverObject
                      );

VOID
SCCMN50M_InitializeSmartcardExtension (
                                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                                      IN ULONG ulDeviceInstance
                                      );

NTSTATUS
SCCMN50M_PnP (
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp
             );

NTSTATUS
SCCMN50M_Power (
               IN PDEVICE_OBJECT    DeviceObject,
               IN PIRP              Irp
               );

VOID
SCCMN50M_RemoveDevice (
                      PDEVICE_OBJECT DeviceObject
                      );

NTSTATUS
SCCMN50M_SerialIo (
                  PSMARTCARD_EXTENSION SmartcardExtension
                  );


VOID
SCCMN50M_SetCardManHeader (
                          IN PSMARTCARD_EXTENSION pSmartcardExtension,
                          IN UCHAR TxControl,
                          IN UCHAR TxLength,
                          IN UCHAR RxControl,
                          IN UCHAR RxLength
                          );

VOID
SCCMN50M_SetCardControlFlags (
                             IN PSMARTCARD_EXTENSION pSmartcardExtension,
                             IN UCHAR Flags
                             );

VOID
SCCMN50M_SetSCRControlFlags (
                            IN PSMARTCARD_EXTENSION pSmartcardExtension,
                            IN UCHAR Flags
                            );

VOID
SCCMN50M_StopCardTracking (
                          IN PDEVICE_EXTENSION pDeviceExtension
                          );

VOID SCCMN50M_SetVendorAndIfdName(
                              IN  PDEVICE_OBJECT PhysicalDeviceObject,
                              IN  PSMARTCARD_EXTENSION SmartcardExtension
                              );
NTSTATUS
SCCMN50M_SystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   );

VOID
SCCMN50M_UpdateCurrentStateThread (
                                  IN PVOID Context
                                  );

NTSTATUS
SCCMN50M_UpdateCurrentState(
                           IN PSMARTCARD_EXTENSION smartcardExtension
                           );

NTSTATUS
SCCMN50M_VendorIoctl (
                     PSMARTCARD_EXTENSION SmartcardExtension
                     );

VOID
SCCMN50M_CloseSerialDriver(
                          IN PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS
DriverEntry(
           IN  PDRIVER_OBJECT  DriverObject,
           IN  PUNICODE_STRING RegistryPath
           );










VOID
StrSet(PUCHAR pbBuffer,ULONG ulBufferSize,UCHAR bPattern);

VOID
StrCpy(PUCHAR pszDestination,ULONG ulDestinationLen,PUCHAR pszSrc);

ULONG
StrLen (PUCHAR pszString);

VOID
StrCat(PUCHAR pszDestination,ULONG ulDestinationLen,PUCHAR pszSrc);

VOID
MemSet(PUCHAR pbBuffer,
       ULONG  ulBufferSize,
       UCHAR  ucPattern,
       ULONG  ulCount);

VOID
MemCpy(PUCHAR pbDestination,
       ULONG  ulDestinationLen,
       PUCHAR pbSource,
       ULONG  ulCount);

NTSTATUS Wait (
              IN PSMARTCARD_EXTENSION pSmartcardExtension,
              IN ULONG ulMilliseconds
              );








NTSTATUS
SCCMN50M_ReadCardMan  (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension,
                      IN ULONG ulBytesToRead,
                      OUT PULONG pulBytesRead,
                      IN PUCHAR pbReadBuffer,
                      IN ULONG ulReadBufferSize
                      );

NTSTATUS
SCCMN50M_WriteCardMan (
                      IN PSMARTCARD_EXTENSION SmartcardExtension,
                      ULONG BytesToWrite,
                      PUCHAR pWriteBuffer
                      );
NTSTATUS
SCCMN50M_SerialIo(
                 IN PSMARTCARD_EXTENSION SmartcardExtension
                 );

NTSTATUS
SCCMN50M_SetWrite (
                  IN PSMARTCARD_EXTENSION pSmartcardExtension,
                  IN ULONG ulBytesToWrite,
                  IN PUCHAR pbWriteBuffer
                  );


NTSTATUS
SCCMN50M_SetRead(
                IN PSMARTCARD_EXTENSION pSmartcardExtension,
                IN ULONG ulBytesToRead
                );


NTSTATUS
SCCMN50M_PurgeComm (
                   IN PSMARTCARD_EXTENSION SmartcardExtension
                   );

NTSTATUS
SCCMN50M_GetCommStatus(
                      IN PSMARTCARD_EXTENSION SmartcardExtension
                      );

NTSTATUS
SCCMN50M_ResyncCardManII (
                         IN PSMARTCARD_EXTENSION SmartcardExtension
                         );

BOOLEAN
SCCMN50M_IOOperationFailed(
                          IN PSMARTCARD_EXTENSION pSmartcardExtension
                          );


NTSTATUS
SCCMN50M_StartCardTracking (
                           PDEVICE_EXTENSION pDeviceExtension
                           );


NTSTATUS
SCCMN50M_InitCommPort (
                      PSMARTCARD_EXTENSION   pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_GetDeviceDescription (
                              PSMARTCARD_EXTENSION   pSmartcardExtension
                              );


NTSTATUS
SCCMN50M_InitializeCardMan (
                           IN PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS
SCCMN50M_SetRTS (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );

NTSTATUS
SCCMN50M_SetDTR (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );


NTSTATUS
SCCMN50M_TransmitT0 (
                    PSMARTCARD_EXTENSION pSmartcardExtension
                    );

NTSTATUS
SCCMN50M_TransmitT1 (
                    PSMARTCARD_EXTENSION pSmartcardExtension
                    );

NTSTATUS
SCCMN50M_Transmit (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );


NTSTATUS
SCCMN50M_EnterTransparentMode (
                              IN PSMARTCARD_EXTENSION pSmartcardExtension
                              );

NTSTATUS
SCCMN50M_ExitTransparentMode (
                             IN PSMARTCARD_EXTENSION pSmartcardExtension
                             );

VOID
SCCMN50M_InverseBuffer (
                       PUCHAR pbBuffer,
                       ULONG  ulBufferSize
                       );

NTSTATUS
SCCMN50M_ResyncCardManI (
                        IN PSMARTCARD_EXTENSION SmartcardExtension
                        );


NTSTATUS
SCCMN50M_SetBRK (
                PSMARTCARD_EXTENSION pSmartcardExtension
                );

NTSTATUS
SCCMN50M_ClearBRK (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );

NTSTATUS
SCCMN50M_ClearRTS (
                  PSMARTCARD_EXTENSION pSmartcardExtension
                  );


NTSTATUS
SCCMN50M_PowerOff (
                  IN PSMARTCARD_EXTENSION pSmartcardExtension
                  );

NTSTATUS
SCCMN50M_PowerOn (
                 IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                 OUT   PULONG pulAtrLength,
                 OUT   PUCHAR pbAtrBuffer,
                 IN    ULONG  ulAtrBufferSize
                 );

NTSTATUS
SCCMN50M_CardPower (
                   IN PSMARTCARD_EXTENSION pSmartcardExtension
                   );


NTSTATUS
SCCMN50M_UseParsingStrategy (
                            IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                            OUT   PULONG pulAtrLength,
                            OUT   PUCHAR pbAtrBuffer,
                            IN    ULONG  ulAtrBufferSize
                            );


NTSTATUS
SCCMN50M_UseColdWarmResetStrategy (
                                  IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                                  OUT   PULONG pulAtrLength,
                                  OUT   PUCHAR pbAtrBuffer,
                                  IN    ULONG  ulAtrBufferSize,
                                  IN    BOOLEAN fWarmReset
                                  );


BOOLEAN
SCCMN50M_IsAtrValid (
                    PUCHAR pbAtrBuffer,
                    ULONG  ulAtrLength
                    );


NTSTATUS
SCCMN50M_SetProtocol (
                     PSMARTCARD_EXTENSION pSmartcardExtension
                     );

NTSTATUS
SCCMN50M_CardTracking (
                      PSMARTCARD_EXTENSION pSmartcardExtension
                      );


NTSTATUS
SCCMN50M_IoCtlVendor (
                     PSMARTCARD_EXTENSION SmartcardExtension
                     );



NTSTATUS
SCCMN50M_SetHighSpeed_CR80S_SAMOS (
                                  IN PSMARTCARD_EXTENSION pSmartcardExtension
                                  );

NTSTATUS
SCCMN50M_GetFWVersion (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_ReadDeviceDescription (
                               IN PSMARTCARD_EXTENSION pSmartcardExtension
                               );

BOOLEAN
SCCMN50M_IsAsynchronousSmartCard (
                                 IN PSMARTCARD_EXTENSION pSmartcardExtension
                                 );


NTSTATUS
SCCMN50M_SetFl_1Dl_3(IN PSMARTCARD_EXTENSION pSmartcardExtension );

NTSTATUS
SCCMN50M_SetFl_1Dl_1(IN PSMARTCARD_EXTENSION pSmartcardExtension );


// synchronous smart cards
NTSTATUS
SCCMN50M_SyncCardPowerOn (
                         IN  PSMARTCARD_EXTENSION pSmartcardExtension
                         );

NTSTATUS
SCCMN50M_SetSyncParameters (
                           IN PSMARTCARD_EXTENSION pSmartcardExtension
                           );

UCHAR
SCCMN50M_CalcTxControlByte (
                           IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToWrite
                           );

UCHAR
SCCMN50M_CalcTxLengthByte (
                          IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                          IN ULONG                 ulBitsToWrite
                          );

UCHAR
SCCMN50M_CalcRxControlByte (
                           IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                           IN ULONG                 ulBitsToRead
                           );

UCHAR
SCCMN50M_CalcRxLengthByte (
                          IN PSMARTCARD_EXTENSION  pSmartcardExtension,
                          IN ULONG                 ulBitsToRead
                          );


NTSTATUS
SCCMN50M_ResetCard2WBP (
                       IN PSMARTCARD_EXTENSION pSmartcardExtension
                       );

NTSTATUS
SCCMN50M_Transmit2WBP (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );

NTSTATUS
SCCMN50M_Transmit3WBP (
                      IN PSMARTCARD_EXTENSION pSmartcardExtension
                      );


NTSTATUS
SCCMN50M_UseSyncStrategy (
                         IN    PSMARTCARD_EXTENSION pSmartcardExtension,
                         OUT   PULONG pulAtrLength,
                         OUT   PUCHAR pbAtrBuffer,
                         IN    ULONG  ulAtrBufferSize
                         );

VOID
SCCMN50M_Shift_Msg (
                   PUCHAR  pbBuffer,
                   ULONG   ulMsgLen
                   );



VOID SCCMN50M_CheckAtrModified (
                               IN OUT PUCHAR pbBuffer,
                               IN ULONG  ulBufferSize
                               );


#endif

/*****************************************************************************
* History:
* $Log: sccmn50m.h $
* Revision 1.3  2000/07/28 09:24:13  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.8  2000/06/28 08:47:33  TBruendl
* R03_0_1_1
*
* Revision 1.7  2000/06/27 11:56:29  TBruendl
* workaraound for SAMOR smart cards with invalid ATR (ITSEC)
*
* Revision 1.6  2000/05/23 09:58:27  TBruendl
* OMNIKEY 3.0.0.1
*
* Revision 1.5  2000/03/01 09:32:06  TBruendl
* R02.20.0
*
* Revision 1.4  1999/12/13 07:57:30  TBruendl
* build number increased
*
* Revision 1.3  1999/07/12 12:50:10  TBruendl
* new version information
*
* Revision 1.2  1999/06/10 09:03:58  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:39  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmn50m\sccmnt5.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmbs0/sw/sccmn50m.ms/rcs/sccmnt5.c $
* $Revision: 1.7 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  OMNIKEY AG
******************************************************************************/

#include <stdio.h>
#include "sccmn50m.h"

//
// We do not need these functions after init anymore
//
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEABLE, SCCMN50M_AddDevice)
#pragma alloc_text(PAGEABLE, SCCMN50M_CreateDevice)

#if DBG
   #pragma optimize ("", off)
#endif

BOOLEAN DeviceSlot[MAXIMUM_SMARTCARD_READERS];

/*****************************************************************************
Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.
    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not initialize even one device.

*****************************************************************************/
NTSTATUS
DriverEntry(
           IN  PDRIVER_OBJECT  DriverObject,
           IN  PUNICODE_STRING RegistryPath
           )
{
   NTSTATUS status = STATUS_SUCCESS;
   ULONG device;



//#if DBG
//   SmartcardSetDebugLevel(DEBUG_ALL);
//#endif

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!DriverEntry: Enter - %s %s\n",
                  DRIVER_NAME,
                  __DATE__,
                  __TIME__)
                 )






   // Initialize the Driver Object with driver's entry points
   DriverObject->DriverUnload = SCCMN50M_DriverUnload;
   DriverObject->MajorFunction[IRP_MJ_CREATE] = SCCMN50M_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLOSE] = SCCMN50M_CreateClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP] = SCCMN50M_Cleanup;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SCCMN50M_DeviceControl;
   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SCCMN50M_SystemControl;
   DriverObject->MajorFunction[IRP_MJ_PNP]   =  SCCMN50M_PnP;
   DriverObject->MajorFunction[IRP_MJ_POWER] = SCCMN50M_Power;
   DriverObject->DriverExtension->AddDevice =  SCCMN50M_AddDevice;

   return status;
}


/*****************************************************************************
Routine Description:
    Creates a new device without starting it.



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_AddDevice (
                   IN PDRIVER_OBJECT DriverObject,
                   IN PDEVICE_OBJECT PhysicalDeviceObject
                   )
{
   NTSTATUS status;
   PDEVICE_OBJECT DeviceObject = NULL;
   UCHAR PropertyBuffer[1024];
   ULONG ResultLength;

   PAGED_CODE();

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!AddDevice: Enter\n",
                   DRIVER_NAME)
                 );

   try
      {
      PDEVICE_EXTENSION deviceExtension;

      // create a device instance
      status = SCCMN50M_CreateDevice(
                                    DriverObject,
                                    PhysicalDeviceObject,
                                    &DeviceObject
                                    );

      if (status != STATUS_SUCCESS)
         {
         leave;
         }

      deviceExtension = DeviceObject->DeviceExtension;

      // and attach to the PDO
      ATTACHED_DEVICE_OBJECT = IoAttachDeviceToDeviceStack(
                                                          DeviceObject,
                                                          PhysicalDeviceObject
                                                          );

      ASSERT(ATTACHED_DEVICE_OBJECT != NULL);

      if (ATTACHED_DEVICE_OBJECT == NULL)
         {
         SmartcardLogError(
                          DriverObject,
                          SCCMN50M_CANT_CONNECT_TO_ASSIGNED_PORT,
                          NULL,
                          status
                          );

         status = STATUS_UNSUCCESSFUL;
         leave;
         }

      // register our new device
      status = IoRegisterDeviceInterface(
                                        PhysicalDeviceObject,
                                        &SmartCardReaderGuid,
                                        NULL,
                                        &deviceExtension->PnPDeviceName
                                        );
      ASSERT(status == STATUS_SUCCESS);

      DeviceObject->Flags |= DO_BUFFERED_IO;
      DeviceObject->Flags |= DO_POWER_PAGABLE;
      DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

      }
   finally
      {
      if (status != STATUS_SUCCESS)
         {
         SCCMN50M_RemoveDevice(DeviceObject);
         }
      }


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!AddDevice: Exit %x\n",
                   DRIVER_NAME,
                   status)
                 );

   return status;
}


/*****************************************************************************
Routine Description:
   Trys to read the reader name from the registry

Arguments:
   DriverObject context of call
   SmartcardExtension   ptr to smartcard extension

Return Value:
   none

******************************************************************************/
VOID SCCMN50M_SetVendorAndIfdName(
                              IN  PDEVICE_OBJECT PhysicalDeviceObject,
                              IN  PSMARTCARD_EXTENSION SmartcardExtension
                              )
{

   RTL_QUERY_REGISTRY_TABLE   parameters[3];
   UNICODE_STRING             vendorNameU;
   ANSI_STRING                vendorNameA;
   UNICODE_STRING             ifdTypeU;
   ANSI_STRING                ifdTypeA;
   HANDLE                     regKey = NULL;

   RtlZeroMemory (parameters, sizeof(parameters));
   RtlZeroMemory (&vendorNameU, sizeof(vendorNameU));
   RtlZeroMemory (&vendorNameA, sizeof(vendorNameA));
   RtlZeroMemory (&ifdTypeU, sizeof(ifdTypeU));
   RtlZeroMemory (&ifdTypeA, sizeof(ifdTypeA));

   try
      {
      //
      // try to read the reader name from the registry
      // if that does not work, we will use the default
      // (hardcoded) name
      //
      if (IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                  PLUGPLAY_REGKEY_DEVICE,
                                  KEY_READ,
                                  &regKey) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: IoOpenDeviceRegistryKey failed\n",DRIVER_NAME));
         leave;
         }

      parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[0].Name = L"VendorName";
      parameters[0].EntryContext = &vendorNameU;
      parameters[0].DefaultType = REG_SZ;
      parameters[0].DefaultData = &vendorNameU;
      parameters[0].DefaultLength = 0;

      parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
      parameters[1].Name = L"IfdType";
      parameters[1].EntryContext = &ifdTypeU;
      parameters[1].DefaultType = REG_SZ;
      parameters[1].DefaultData = &ifdTypeU;
      parameters[1].DefaultLength = 0;

      if (RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                 (PWSTR) regKey,
                                 parameters,
                                 NULL,
                                 NULL) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlQueryRegistryValues failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&vendorNameA,&vendorNameU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (RtlUnicodeStringToAnsiString(&ifdTypeA,&ifdTypeU,TRUE) != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: RtlUnicodeStringToAnsiString failed\n",DRIVER_NAME));
         leave;
         }

      if (vendorNameA.Length == 0 ||
          vendorNameA.Length > MAXIMUM_ATTR_STRING_LENGTH ||
          ifdTypeA.Length == 0 ||
          ifdTypeA.Length > MAXIMUM_ATTR_STRING_LENGTH)
         {
         SmartcardDebug(DEBUG_ERROR,
                        ("%s!SetVendorAndIfdName: vendor name or ifdtype not found or to long\n",DRIVER_NAME));
         leave;
         }

      RtlCopyMemory(SmartcardExtension->VendorAttr.VendorName.Buffer,
                    vendorNameA.Buffer,
                    vendorNameA.Length);
      SmartcardExtension->VendorAttr.VendorName.Length = vendorNameA.Length;

      RtlCopyMemory(SmartcardExtension->VendorAttr.IfdType.Buffer,
                    ifdTypeA.Buffer,
                    ifdTypeA.Length);
      SmartcardExtension->VendorAttr.IfdType.Length = ifdTypeA.Length;

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!SetVendorAndIfdName: overwritting vendor name and ifdtype\n",DRIVER_NAME));

      }

   finally
      {
      if (vendorNameU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&vendorNameU);
         }
      if (vendorNameA.Buffer != NULL)
         {
         RtlFreeAnsiString(&vendorNameA);
         }
      if (ifdTypeU.Buffer != NULL)
         {
         RtlFreeUnicodeString(&ifdTypeU);
         }
      if (ifdTypeA.Buffer != NULL)
         {
         RtlFreeAnsiString(&ifdTypeA);
         }
      if (regKey != NULL)
         {
         ZwClose (regKey);
         }
      }

}


/*****************************************************************************
Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CreateDevice(
                     IN  PDRIVER_OBJECT DriverObject,
                     IN  PDEVICE_OBJECT PhysicalDeviceObject,
                     OUT PDEVICE_OBJECT *DeviceObject
                     )
{
   PDEVICE_EXTENSION deviceExtension;
   NTSTATUS status = STATUS_SUCCESS;
   ULONG deviceInstance;
   PREADER_EXTENSION readerExtension;
   PSMARTCARD_EXTENSION smartcardExtension;
   UNICODE_STRING DriverID;
   RTL_QUERY_REGISTRY_TABLE   ParamTable[2];
   UNICODE_STRING             RegistryPath;
   DWORD                      dwStart;
   UNICODE_STRING             Tmp;
   WCHAR                      Buffer[64];

   // this is a list of our supported data rates


   PAGED_CODE();

   *DeviceObject = NULL;

   for ( deviceInstance = 0;deviceInstance < MAXIMUM_SMARTCARD_READERS;deviceInstance++ )
      {
      if (DeviceSlot[deviceInstance] == FALSE)
         {
         DeviceSlot[deviceInstance] = TRUE;
         break;
         }
      }

   if (deviceInstance == MAXIMUM_SMARTCARD_READERS)
      {
      SmartcardLogError(
                       DriverObject,
                       SCCMN50M_CANT_CREATE_MORE_DEVICES,
                       NULL,
                       0
                       );

      return STATUS_INSUFFICIENT_RESOURCES;
      }

   //
   //   construct the device name
   //
   DriverID.Buffer = Buffer;
   DriverID.MaximumLength = sizeof(Buffer);
   DriverID.Length = 0;
   RtlInitUnicodeString(&Tmp,CARDMAN_DEVICE_NAME);
   RtlCopyUnicodeString(&DriverID,&Tmp);
   DriverID.Buffer[(DriverID.Length)/sizeof(WCHAR)-1] = L'0' + (WCHAR)deviceInstance;

   // Create the device object
   status = IoCreateDevice(
                          DriverObject,
                          sizeof(DEVICE_EXTENSION),
                          &DriverID,
                          FILE_DEVICE_SMARTCARD,
                          0,
                          FALSE,
                          DeviceObject
                          );

   if (status != STATUS_SUCCESS)
      {
      SmartcardLogError(
                       DriverObject,
                       SCCMN50M_CANT_CREATE_DEVICE,
                       NULL,
                       0
                       );

      return status;
      }



   SmartcardDebug(
                 DEBUG_DRIVER,
                 ( "%s!CreateDevice: Device created\n",
                   DRIVER_NAME)
                 );

   //   set up the device extension.
   deviceExtension = (*DeviceObject)->DeviceExtension;
   deviceExtension->DeviceInstance =  deviceInstance;
   smartcardExtension = &deviceExtension->SmartcardExtension;




   // Used for stop / start notification
   KeInitializeEvent(
                    &deviceExtension->ReaderStarted,
                    NotificationEvent,
                    FALSE
                    );

   // This event signals that the serial driver has been closed
   KeInitializeEvent(
                    &deviceExtension->SerialCloseDone,
                    NotificationEvent,
                    TRUE
                    );

   // Used to keep track of open close calls
   KeInitializeEvent(
                    &deviceExtension->ReaderClosed,
                    NotificationEvent,
                    TRUE
                    );


   KeInitializeSpinLock(&deviceExtension->SpinLock);


   // Allocate data struct space for smart card reader
   smartcardExtension->ReaderExtension = ExAllocatePool(
                                                       NonPagedPool,
                                                       sizeof(READER_EXTENSION)
                                                       );

   if (smartcardExtension->ReaderExtension == NULL)
      {

      SmartcardLogError(
                       DriverObject,
                       SCCMN50M_NO_MEMORY,
                       NULL,
                       0
                       );

      return STATUS_INSUFFICIENT_RESOURCES;
      }

   readerExtension = smartcardExtension->ReaderExtension;
   RtlZeroMemory(readerExtension, sizeof(READER_EXTENSION));

   // ----------------------------------------------
   //   initialize mutex
   // ----------------------------------------------
   KeInitializeMutex(&smartcardExtension->ReaderExtension->CardManIOMutex,0L);


   // Write the version of the lib we use to the smartcard extension
   smartcardExtension->Version = SMCLIB_VERSION;
   smartcardExtension->SmartcardRequest.BufferSize =
   smartcardExtension->SmartcardReply.BufferSize = MIN_BUFFER_SIZE;

   //
   // Now let the lib allocate the buffer for data transmission
   // We can either tell the lib how big the buffer should be
   // by assigning a value to BufferSize or let the lib
   // allocate the default size
   //
   status = SmartcardInitialize(smartcardExtension);

   if (status != STATUS_SUCCESS)
      {

      SmartcardLogError(
                       DriverObject,
                       (smartcardExtension->OsData ? SCCMN50M_WRONG_LIB_VERSION : SCCMN50M_NO_MEMORY),
                       NULL,
                       0
                       );

      return status;
      }

   // Save deviceObject
   smartcardExtension->OsData->DeviceObject = *DeviceObject;

   // Set up call back functions
   smartcardExtension->ReaderFunction[RDF_TRANSMIT] =      SCCMN50M_Transmit;
   smartcardExtension->ReaderFunction[RDF_SET_PROTOCOL] =  SCCMN50M_SetProtocol;
   smartcardExtension->ReaderFunction[RDF_CARD_POWER] =    SCCMN50M_CardPower;
   smartcardExtension->ReaderFunction[RDF_CARD_TRACKING] = SCCMN50M_CardTracking;
   smartcardExtension->ReaderFunction[RDF_IOCTL_VENDOR] =  SCCMN50M_IoCtlVendor;


   SCCMN50M_InitializeSmartcardExtension(smartcardExtension,deviceInstance);

   // try to overwrite with registry values
   SCCMN50M_SetVendorAndIfdName(PhysicalDeviceObject, smartcardExtension);


   // save the current power state of the reader
   readerExtension->ReaderPowerState = PowerReaderWorking;



   return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
   Open the serial device, start card tracking and register our
    device interface. If any of the calls here fails we don't care
    to rollback since a stop will be called later which we then
    use to clean up.



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_StartDevice(
                    IN PDEVICE_OBJECT DeviceObject
                    )
{
   NTSTATUS status;
   PIRP irp;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StartDevice: Enter\n",
                   DRIVER_NAME)
                 );


   irp = IoAllocateIrp(
                      (CCHAR) (DeviceObject->StackSize + 1),
                      FALSE
                      );

   ASSERT(irp != NULL);

   if (irp == NULL)
      {

      return STATUS_NO_MEMORY;
      }

   _try {

      PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
      PSMARTCARD_EXTENSION pSmartcardExtension = &deviceExtension->SmartcardExtension;
      PIO_STACK_LOCATION irpStack;
      HANDLE handle = 0;
      IO_STATUS_BLOCK ioStatusBlock;

      //
      // Open the underlying serial driver.
      // This is necessary for two reasons:
      // a) The serial driver can't be used without opening it
      // b) The call will go through serenum first which informs
      //    it to stop looking/polling for new devices.
      //
      irp->UserIosb = &ioStatusBlock;
      IoSetNextIrpStackLocation(irp);
      irpStack = IoGetCurrentIrpStackLocation(irp);

      irpStack->MajorFunction = IRP_MJ_CREATE;
      irpStack->Parameters.Create.Options = 0;
      irpStack->Parameters.Create.ShareAccess = 0;
      irpStack->Parameters.Create.FileAttributes = 0;
      irpStack->Parameters.Create.EaLength = 0;

      status = SCCMN50M_CallSerialDriver(
                                        ATTACHED_DEVICE_OBJECT,
                                        irp
                                        );
      if (status != STATUS_SUCCESS)
         {

         leave;
         }

      KeClearEvent(&deviceExtension->SerialCloseDone);

      pSmartcardExtension->SmartcardReply.BufferLength = pSmartcardExtension->SmartcardReply.BufferSize;
      pSmartcardExtension->SmartcardRequest.BufferLength = 0;

      pSmartcardExtension->ReaderExtension->SerialIoControlCode = IOCTL_SERENUM_GET_PORT_NAME;
      status =  SCCMN50M_SerialIo(pSmartcardExtension);



      //
      // Channel id which the reader is using,
      // in our case the Portnumber
      // WCHAR are used. e.g. COM3
      pSmartcardExtension->ReaderCapabilities.Channel =
      pSmartcardExtension->SmartcardReply.Buffer[6] -'0';






      status = SCCMN50M_InitializeCardMan(&deviceExtension->SmartcardExtension);
      if (status != STATUS_SUCCESS)
         {

         leave;
         }


      status = SCCMN50M_StartCardTracking(deviceExtension);

      if (status != STATUS_SUCCESS)
         {

         leave;
         }

      status = IoSetDeviceInterfaceState(
                                        &deviceExtension->PnPDeviceName,
                                        TRUE
                                        );

      if (status != STATUS_SUCCESS)
         {

         leave;
         }

      deviceExtension->IoCount = 0;
      KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!Event ReaderStarted was set\n",DRIVER_NAME));

   }
   _finally {

      if (status == STATUS_SHARED_IRQ_BUSY)
         {

         SmartcardLogError(
                          DeviceObject,
                          SCCMN50M_IRQ_BUSY,
                          NULL,
                          status
                          );
         }

      IoFreeIrp(irp);
   }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StartDevice: Exit\n",
                   DRIVER_NAME)
                 );

   return status;
}

/*****************************************************************************
Routine Description:

    Finishes card tracking requests and closes the connection to the
    serial driver.


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_StopDevice(
                   IN PDEVICE_EXTENSION DeviceExtension
                   )
{
   NTSTATUS status;
   PUCHAR requestBuffer;
   PSMARTCARD_EXTENSION smartcardExtension;


   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StopDevice: Enter\n",
                   DRIVER_NAME)
                 );

   if (KeReadStateEvent(&DeviceExtension->SerialCloseDone) == 0l)
      {

      smartcardExtension = &DeviceExtension->SmartcardExtension;


      SCCMN50M_StopCardTracking(DeviceExtension);


      SCCMN50M_CloseSerialDriver (smartcardExtension->OsData->DeviceObject);



      // now wait until the connetion to serial is closed
      status = KeWaitForSingleObject(
                                    &DeviceExtension->SerialCloseDone,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL
                                    );
      ASSERT(status == STATUS_SUCCESS);
      }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!StopDevice: Exit\n",
                   DRIVER_NAME)
                 );
}

NTSTATUS
SCCMN50M_SystemControl(
   PDEVICE_OBJECT DeviceObject,
   PIRP        Irp
   )
/*++

--*/
{
   PDEVICE_EXTENSION DeviceExtension; 
   NTSTATUS status = STATUS_SUCCESS;

   DeviceExtension      = DeviceObject->DeviceExtension;

   IoSkipCurrentIrpStackLocation(Irp);
   status = IoCallDriver(DeviceExtension->SmartcardExtension.ReaderExtension->AttachedDeviceObject, Irp);
      
   return status;

}


/*****************************************************************************
Routine Description:

    This is our IOCTL dispatch function


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_DeviceControl(
                      PDEVICE_OBJECT DeviceObject,
                      PIRP Irp
                      )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   NTSTATUS status;
   KIRQL irql;
   PIO_STACK_LOCATION            irpSp;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DeviceIoControl: Enter\n",DRIVER_NAME));

   irpSp = IoGetCurrentIrpStackLocation(Irp);

   PAGED_CODE();


#if DBG
   switch (irpSp->Parameters.DeviceIoControl.IoControlCode)
      {
      case IOCTL_SMARTCARD_EJECT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_EJECT"));
         break;
      case IOCTL_SMARTCARD_GET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_GET_LAST_ERROR:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_LAST_ERROR"));
         break;
      case IOCTL_SMARTCARD_GET_STATE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_GET_STATE"));
         break;
      case IOCTL_SMARTCARD_IS_ABSENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_ABSENT"));
         break;
      case IOCTL_SMARTCARD_IS_PRESENT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_IS_PRESENT"));
         break;
      case IOCTL_SMARTCARD_POWER:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_POWER"));
         break;
      case IOCTL_SMARTCARD_SET_ATTRIBUTE:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_ATTRIBUTE"));
         break;
      case IOCTL_SMARTCARD_SET_PROTOCOL:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SET_PROTOCOL"));
         break;
      case IOCTL_SMARTCARD_SWALLOW:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_SWALLOW"));
         break;
      case IOCTL_SMARTCARD_TRANSMIT:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "IOCTL_SMARTCARD_TRANSMIT"));
         break;
      default:
         SmartcardDebug(DEBUG_IOCTL,
                        ("%s!DeviceControl: %s\n", DRIVER_NAME, "Vendor specific or unexpected IOCTL"));
         break;
      }
#endif


   if (KeReadStateEvent(&deviceExtension->SerialCloseDone) != 0l)
      {
      // Device has been removed
      // fail the call
      status = STATUS_DEVICE_REMOVED;
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
      }



   KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
   if (deviceExtension->IoCount < 0)
      {

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!waiting for Event ReaderStarted\n",DRIVER_NAME));
      KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
      status = KeWaitForSingleObject(
                                    &deviceExtension->ReaderStarted,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL
                                    );
      ASSERT(status == STATUS_SUCCESS);

      KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
      }
   ASSERT(deviceExtension->IoCount >= 0);


   deviceExtension->IoCount++;
   KeReleaseSpinLock(&deviceExtension->SpinLock, irql);



   status = SmartcardAcquireRemoveLock(&deviceExtension->SmartcardExtension);
   if (status != STATUS_SUCCESS)
      {

      // the device has been removed. Fail the call
      status = STATUS_DEVICE_REMOVED;
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);

      KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
      deviceExtension->IoCount--;
      ASSERT(deviceExtension->IoCount >= 0);
      KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

      SmartcardDebug(DEBUG_TRACE,
                     ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,status));

      return status;
      }


   // wait for update thread
   KeWaitForSingleObject(
                        &deviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );

   status = SCCMN50M_UpdateCurrentState(&(deviceExtension->SmartcardExtension));

   status = SmartcardDeviceControl(
                                  &(deviceExtension->SmartcardExtension),
                                  Irp
                                  );

   // release for update thread
   KeReleaseMutex(
                 &deviceExtension->SmartcardExtension.ReaderExtension->CardManIOMutex,
                 FALSE
                 );


   SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);

   KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
   deviceExtension->IoCount--;
   ASSERT(deviceExtension->IoCount >= 0);
   KeReleaseSpinLock(&deviceExtension->SpinLock, irql);


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DeviceIoControl: Exit %x\n",DRIVER_NAME,status));

   return status;
}

/*****************************************************************************
Routine Description:

    This function closes the connection to the serial driver when the reader
    has been removed (unplugged). This function runs as a system thread at
    IRQL == PASSIVE_LEVEL. It waits for the remove event that is set by
    the IoCompletionRoutine


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_CloseSerialDriver(
                          IN PDEVICE_OBJECT DeviceObject
                          )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   NTSTATUS status;
   PIRP irp;
   PIO_STACK_LOCATION irpStack;
   IO_STATUS_BLOCK ioStatusBlock;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CloseSerialDriver: Enter\n",
                   DRIVER_NAME)
                 );
   //
   // first mark this device as 'gone'.
   // This will prevent that someone can re-open the device
   //
   status = IoSetDeviceInterfaceState(
                                     &deviceExtension->PnPDeviceName,
                                     FALSE
                                     );

   irp = IoAllocateIrp(
                      (CCHAR) (DeviceObject->StackSize + 1),
                      FALSE
                      );

   ASSERT(irp != NULL);

   if (irp)
      {

      SmartcardDebug(
                    DEBUG_DRIVER,
                    ( "%s!CloseSerialDriver: Sending IRP_MJ_CLOSE\n",
                      DRIVER_NAME)
                    );

      IoSetNextIrpStackLocation(irp);

      //
      // We send down a close to the serial driver. This close goes
      // through serenum first which will trigger it to start looking
      // for changes on the com-port. Since our device is gone it will
      // call the device removal event of our PnP dispatch.
      //
      irp->UserIosb = &ioStatusBlock;
      irpStack = IoGetCurrentIrpStackLocation( irp );
      irpStack->MajorFunction = IRP_MJ_CLOSE;

      status = SCCMN50M_CallSerialDriver(
                                        ATTACHED_DEVICE_OBJECT,
                                        irp
                                        );

      ASSERT(status == STATUS_SUCCESS);

      IoFreeIrp(irp);
      }


   // now 'signal' that we closed the serial driver
   KeSetEvent(&deviceExtension->SerialCloseDone, 0, FALSE);

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!CloseSerialDriver: Exit\n",
                   DRIVER_NAME)
                 );
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_IoCompletion (
                      IN PDEVICE_OBJECT DeviceObject,
                      IN PIRP Irp,
                      IN PKEVENT Event
                      )
{
   UNREFERENCED_PARAMETER (DeviceObject);

   if (Irp->Cancel)
      {

      Irp->IoStatus.Status = STATUS_CANCELLED;

      }
   else
      {

      Irp->IoStatus.Status = STATUS_MORE_PROCESSING_REQUIRED;
      }

   KeSetEvent (Event, 0, FALSE);

   return STATUS_MORE_PROCESSING_REQUIRED;
}

/*****************************************************************************
Routine Description:

   Send an Irp to the serial driver.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_CallSerialDriver(
                         IN PDEVICE_OBJECT DeviceObject,
                         IN PIRP Irp
                         )
{

   NTSTATUS status = STATUS_SUCCESS;
   KEVENT Event;

   // Copy our stack location to the next.
   IoCopyCurrentIrpStackLocationToNext(Irp);

   //
   // initialize an event for process synchronization. The event is passed
   // to our completion routine and will be set when the serial driver is done
   //
   KeInitializeEvent(
                    &Event,
                    NotificationEvent,
                    FALSE
                    );

   // Our IoCompletionRoutine sets only our event
   IoSetCompletionRoutine (
                          Irp,
                          SCCMN50M_IoCompletion,
                          &Event,
                          TRUE,
                          TRUE,
                          TRUE
                          );

   if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_POWER)
      {

      status = PoCallDriver(DeviceObject, Irp);

      }
   else
      {

      // Call the serial driver
      status = IoCallDriver(DeviceObject, Irp);
      }

   // Wait until the serial driver has processed the Irp
   if (status == STATUS_PENDING)
      {

      status = KeWaitForSingleObject(
                                    &Event,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    NULL
                                    );

      ASSERT (STATUS_SUCCESS == status);
      status = Irp->IoStatus.Status;
      }

   return status;
}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_PnP(
            IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp
            )
{

   PUCHAR requestBuffer;
   NTSTATUS status = STATUS_SUCCESS;
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   PREADER_EXTENSION readerExtension = smartcardExtension->ReaderExtension;
   PDEVICE_OBJECT AttachedDeviceObject;
   PIO_STACK_LOCATION irpStack;
   IO_STATUS_BLOCK ioStatusBlock;
   BOOLEAN deviceRemoved = FALSE, irpSkipped = FALSE;
   KIRQL irql;
   PDEVICE_CAPABILITIES DeviceCapabilities;


   PAGED_CODE();

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!PnPDeviceControl: Enter\n",
                   DRIVER_NAME)
                 );

   status = SmartcardAcquireRemoveLock(smartcardExtension);
   ASSERT(status == STATUS_SUCCESS);

   if (status != STATUS_SUCCESS)
      {

      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
      }

   AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;


   irpStack = IoGetCurrentIrpStackLocation(Irp);

   // Now look what the PnP manager wants...
   switch (irpStack->MinorFunction)
      {
      case IRP_MN_START_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_START_DEVICE\n",
                        DRIVER_NAME)
                       );

         // We have to call the underlying driver first
         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
         ASSERT(NT_SUCCESS(status));

         if (NT_SUCCESS(status))
            {

            status = SCCMN50M_StartDevice(DeviceObject);
            }



         break;

      case IRP_MN_QUERY_STOP_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_QUERY_STOP_DEVICE\n",
                        DRIVER_NAME)
                       );

         KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
         if (deviceExtension->IoCount > 0)
            {

            // we refuse to stop if we have pending io
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = STATUS_DEVICE_BUSY;

            }
         else
            {

            // stop processing requests
            deviceExtension->IoCount = -1;
            KeClearEvent(&deviceExtension->ReaderStarted);
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
            KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
            status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
            }
         break;

      case IRP_MN_CANCEL_STOP_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_CANCEL_STOP_DEVICE\n",
                        DRIVER_NAME)
                       );

         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

         if (status == STATUS_SUCCESS)
            {

            // we can continue to process requests
            deviceExtension->IoCount = 0;
            KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
            SmartcardDebug(DEBUG_DRIVER,
                           ("%s!Event ReaderStarted was set\n",DRIVER_NAME));
            }
         break;

      case IRP_MN_STOP_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_STOP_DEVICE\n",
                        DRIVER_NAME)
                       );

         SCCMN50M_StopDevice(deviceExtension);

         //
         // we don't do anything since a stop is only used
         // to reconfigure hw-resources like interrupts and io-ports
         //
         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
         break;

      case IRP_MN_QUERY_REMOVE_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_QUERY_REMOVE_DEVICE\n",
                        DRIVER_NAME)
                       );

         // disable the interface (and ignore possible errors)
         IoSetDeviceInterfaceState(&deviceExtension->PnPDeviceName,
                                   FALSE);

         // now look if someone is currently connected to us
         if (KeReadStateEvent(&deviceExtension->ReaderClosed) == 0l)
            {
            //
            // someone is connected, fail the call
            // we will enable the device interface in
            // IRP_MN_CANCEL_REMOVE_DEVICE again
            //
            status = STATUS_UNSUCCESSFUL;
            break;
            }

         // pass the call to the next driver in the stack
         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
         break;

      case IRP_MN_CANCEL_REMOVE_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_CANCEL_REMOVE_DEVICE\n",
                        DRIVER_NAME)
                       );

         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

         if (status == STATUS_SUCCESS)
            {
            status = IoSetDeviceInterfaceState(&deviceExtension->PnPDeviceName,
                                               TRUE);
            ASSERT(status == STATUS_SUCCESS);
            }
         break;

      case IRP_MN_REMOVE_DEVICE:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_REMOVE_DEVICE\n",
                        DRIVER_NAME)
                       );

         SCCMN50M_RemoveDevice(DeviceObject);
         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);
         deviceRemoved = TRUE;
         break;

         // ---------------------
         // IRP_MN_QUERY_CAPABILITIES
         // ---------------------
      case IRP_MN_QUERY_CAPABILITIES:

         SmartcardDebug(
                       DEBUG_DRIVER,
                       ("%s!PnPDeviceControl: IRP_MN_QUERY_CAPABILITIES\n",
                        DRIVER_NAME));

         //
         // Get the packet.
         //
         DeviceCapabilities=irpStack->Parameters.DeviceCapabilities.Capabilities;

         if (DeviceCapabilities->Version == 1 &&
             DeviceCapabilities->Size == sizeof(DEVICE_CAPABILITIES))
            {
            //
            // Set the capabilities.
            //

            // We cannot wake the system.
            DeviceCapabilities->SystemWake = PowerSystemUnspecified;
            DeviceCapabilities->DeviceWake = PowerDeviceUnspecified;

            // We have no latencies
            DeviceCapabilities->D1Latency = 0;
            DeviceCapabilities->D2Latency = 0;
            DeviceCapabilities->D3Latency = 0;

            // No locking or ejection
            DeviceCapabilities->LockSupported = FALSE;
            DeviceCapabilities->EjectSupported = FALSE;

            // Device can be physically removed.
            DeviceCapabilities->Removable = TRUE;

            // No docking device
            DeviceCapabilities->DockDevice = FALSE;

            // Device can not be removed any time
            // it has a removable media
            DeviceCapabilities->SurpriseRemovalOK = FALSE;
            }

         //
         // Pass the IRP down
         //
         status = SCCMN50M_CallSerialDriver(AttachedDeviceObject, Irp);

         break; // end, case IRP_MN_QUERY_CAPABILITIES

      default:
#if DBG
         switch (irpStack->MinorFunction)
            {
            case IRP_MN_QUERY_DEVICE_RELATIONS       :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_DEVICE_RELATIONS\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_QUERY_INTERFACE              :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_INTERFACE\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_QUERY_CAPABILITIES           :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_CAPABILITIES\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_QUERY_RESOURCES              :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_RESOURCES\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_QUERY_RESOURCE_REQUIREMENTS  :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_RESOURCE_REQUIEREMENTS\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_QUERY_DEVICE_TEXT            :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_QUERY_DEVICE_TEXT\n",
                              DRIVER_NAME));
               break;
            case IRP_MN_FILTER_RESOURCE_REQUIREMENTS :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n",
                              DRIVER_NAME));
               break;
            default :
            case IRP_MN_READ_CONFIG :
               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_READ_CONFIG\n",
                              DRIVER_NAME));
               break;

               // This is an Irp that is only useful for underlying drivers
               SmartcardDebug(
                             DEBUG_DRIVER,
                             ("%s!PnPDeviceControl: IRP_MN_...%lx\n",
                              DRIVER_NAME,
                              irpStack->MinorFunction));
               break;
            }
#endif



         IoSkipCurrentIrpStackLocation(Irp);
         status = IoCallDriver(AttachedDeviceObject, Irp);
         irpSkipped = TRUE;
         break;
      }

   if (irpSkipped == FALSE)
      {

      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      }

   if (deviceRemoved == FALSE)
      {

      SmartcardReleaseRemoveLock(smartcardExtension);
      }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!PnPDeviceControl: Exit %lx\n",
                   DRIVER_NAME,
                   status)
                 );

   return status;
}

/*****************************************************************************
Routine Description:

    This function is called when the underlying stacks
    completed the power transition.


Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_SystemPowerCompletion(
                              IN PDEVICE_OBJECT DeviceObject,
                              IN UCHAR MinorFunction,
                              IN POWER_STATE PowerState,
                              IN PKEVENT Event,
                              IN PIO_STATUS_BLOCK IoStatus
                              )
{
   UNREFERENCED_PARAMETER (DeviceObject);
   UNREFERENCED_PARAMETER (MinorFunction);
   UNREFERENCED_PARAMETER (PowerState);
   UNREFERENCED_PARAMETER (IoStatus);

   KeSetEvent(Event, 0, FALSE);
}

/*****************************************************************************
Routine Description:

    This routine is called after the underlying stack powered
    UP the serial port, so it can be used again.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_DevicePowerCompletion (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP Irp,
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   UCHAR  pbAtrBuffer[MAXIMUM_ATR_LENGTH];
   ULONG  ulAtrLength;
   ULONG  ulOldState;
   NTSTATUS status;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DevicePowerCompletion: Enter\n",DRIVER_NAME));




   // We have to remember the old card state because
   // it is overwritten by SCCMN50M_InitializeCardMan
   ulOldState=SmartcardExtension->ReaderExtension->ulOldCardState;
   status = SCCMN50M_InitializeCardMan(SmartcardExtension);
   // Set back the previous state
   SmartcardExtension->ReaderExtension->ulOldCardState = ulOldState;
   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!InitializeCardMan failed ! %lx\n",DRIVER_NAME,status));
      }

   //
   // We issue a power request in because
   // we powered down the card before
   //
   //SmartcardExtension->MinorIoControlCode = SCARD_COLD_RESET;
   //status = SCCMN50M_PowerOn (SmartcardExtension,&ulAtrLength,pbAtrBuffer,sizeof(pbAtrBuffer));

   //
   // If a card was present before power down or now there is
   // a card in the reader, we complete any pending card monitor
   // request, since we do not really know what card is now in the
   // reader.
   //
   if (SmartcardExtension->ReaderExtension->CardPresent ||
       SmartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT)
      {
      deviceExtension->SmartcardExtension.ReaderExtension->ulOldCardState = UNKNOWN;
      deviceExtension->SmartcardExtension.ReaderExtension->ulNewCardState = UNKNOWN;
      }

   status = SCCMN50M_StartCardTracking(deviceExtension);
   if (status != STATUS_SUCCESS)
      {
      SmartcardDebug(DEBUG_ERROR,
                     ("%s!StartCardTracking failed ! %lx\n",DRIVER_NAME,status));
      }

   // save the current power state of the reader
   SmartcardExtension->ReaderExtension->ReaderPowerState =  PowerReaderWorking;

   SmartcardReleaseRemoveLock(SmartcardExtension);

   // inform the power manager of our state.
   PoSetPowerState (DeviceObject,
                    DevicePowerState,
                    irpStack->Parameters.Power.State);

   PoStartNextPowerIrp(Irp);

   // signal that we can process ioctls again
   deviceExtension->IoCount = 0;
   KeSetEvent(&deviceExtension->ReaderStarted, 0, FALSE);
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!Event ReaderStarted was set\n",DRIVER_NAME));




   SmartcardDebug(DEBUG_TRACE,
                  ("%s!DevicePowerCompletion: Exit\n",DRIVER_NAME));
   return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
    The power dispatch routine.
    This driver is the power policy owner of the device stack,
    because this driver knows about the connected reader.
    Therefor this driver will translate system power states
    to device power states.

Arguments:
   DeviceObject - pointer to a device object.
   Irp - pointer to an I/O Request Packet.

Return Value:
      NT status code

*****************************************************************************/
typedef enum _ACTION
   {

   Undefined = 0,
   SkipRequest,
   WaitForCompletion,
   CompleteRequest,
   MarkPending

   } ACTION;

NTSTATUS
SCCMN50M_Power (
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )
{
   NTSTATUS status = STATUS_SUCCESS;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   PDEVICE_OBJECT AttachedDeviceObject;
   POWER_STATE powerState;
   ACTION action = SkipRequest;
   KEVENT event;

   PAGED_CODE();

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Power: Enter\n",
                  DRIVER_NAME)
                 );

   status = SmartcardAcquireRemoveLock(smartcardExtension);
   ASSERT(status == STATUS_SUCCESS);

   if (!NT_SUCCESS(status))
      {
      PoStartNextPowerIrp(Irp);
      Irp->IoStatus.Status = status;
      IoCompleteRequest(Irp, IO_NO_INCREMENT);
      return status;
      }

   AttachedDeviceObject = ATTACHED_DEVICE_OBJECT;

   if (irpStack->Parameters.Power.Type == DevicePowerState &&
       irpStack->MinorFunction == IRP_MN_SET_POWER)
      {

      switch (irpStack->Parameters.Power.State.DeviceState)
         {

         case PowerDeviceD0:
            // Turn on the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerDevice D0\n",
                           DRIVER_NAME)
                          );





            //
            // First, we send down the request to the bus, in order
            // to power on the port. When the request completes,
            // we turn on the reader
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine (
                                   Irp,
                                   SCCMN50M_DevicePowerCompletion,
                                   smartcardExtension,
                                   TRUE,
                                   TRUE,
                                   TRUE
                                   );

            action = WaitForCompletion;
            break;

         case PowerDeviceD3:



            SCCMN50M_StopCardTracking(deviceExtension);
            // Turn off the reader
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerDevice D3\n",
                           DRIVER_NAME)
                          );

            PoSetPowerState (
                            DeviceObject,
                            DevicePowerState,
                            irpStack->Parameters.Power.State
                            );

            // save the current card state
            smartcardExtension->ReaderExtension->CardPresent = smartcardExtension->ReaderCapabilities.CurrentState > SCARD_ABSENT;

            if (smartcardExtension->ReaderExtension->CardPresent)
               {
               smartcardExtension->MinorIoControlCode = SCARD_POWER_DOWN;
               status = SCCMN50M_PowerOff(smartcardExtension);
               ASSERT(status == STATUS_SUCCESS);
               }


            // save the current power state of the reader
            smartcardExtension->ReaderExtension->ReaderPowerState = PowerReaderOff;

            action = SkipRequest;
            break;

         default:
            action = SkipRequest;
            break;
         }
      }

   if (irpStack->Parameters.Power.Type == SystemPowerState)
      {

      //
      // The system wants to change the power state.
      // We need to translate the system power state to
      // a corresponding device power state.
      //

      POWER_STATE_TYPE powerType = DevicePowerState;

      ASSERT(smartcardExtension->ReaderExtension->ReaderPowerState !=
             PowerReaderUnspecified);

      switch (irpStack->MinorFunction)
         {
         KIRQL irql;

         case IRP_MN_QUERY_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: Query Power\n",
                           DRIVER_NAME)
                          );

            switch (irpStack->Parameters.Power.State.SystemState)
               {

               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:
                  action = SkipRequest;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:
                  KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                  if (deviceExtension->IoCount == 0)
                     {
                     // Block any further ioctls
                     deviceExtension->IoCount = -1;
                     KeClearEvent(&deviceExtension->ReaderStarted);
                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
                     action = SkipRequest;
                     }
                  else
                     {
                     // can't go to sleep mode since the reader is busy.
                     status = STATUS_DEVICE_BUSY;
                     action = CompleteRequest;
                     }
                  KeReleaseSpinLock(&deviceExtension->SpinLock, irql);
                  break;
               }
            break;

         case IRP_MN_SET_POWER:

            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!Power: PowerSystem S%d\n",
                           DRIVER_NAME,
                           irpStack->Parameters.Power.State.SystemState - 1)
                          );

            switch (irpStack->Parameters.Power.State.SystemState)
               {

               case PowerSystemMaximum:
               case PowerSystemWorking:
               case PowerSystemSleeping1:
               case PowerSystemSleeping2:

                  if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                      PowerReaderWorking)
                     {

                     // We're already in the right state
                     action = SkipRequest;
                     break;
                     }

                  // wake up the underlying stack...
                  powerState.DeviceState = PowerDeviceD0;
                  action = MarkPending;
                  break;

               case PowerSystemSleeping3:
               case PowerSystemHibernate:
               case PowerSystemShutdown:

                  KeAcquireSpinLock(&deviceExtension->SpinLock, &irql);
                  if (deviceExtension->IoCount == 0)
                     {
                     // Block any further ioctls
                     deviceExtension->IoCount = -1;
                     KeClearEvent(&deviceExtension->ReaderStarted);
                     SmartcardDebug(DEBUG_DRIVER,
                                    ("%s!Event ReaderStarted was cleared\n",DRIVER_NAME));
                     action = SkipRequest;
                     }
                  else
                     {
                     // can't go to sleep mode since the reader is busy.
                     status = STATUS_DEVICE_BUSY;
                     action = CompleteRequest;
                     }
                  KeReleaseSpinLock(&deviceExtension->SpinLock, irql);

                  if (smartcardExtension->ReaderExtension->ReaderPowerState ==
                      PowerReaderOff)
                     {
                     // We're already in the right state
                     action = SkipRequest;
                     break;
                     }

                  powerState.DeviceState = PowerDeviceD3;

                  // first, inform the power manager of our new state.
                  PoSetPowerState (
                                  DeviceObject,
                                  SystemPowerState,
                                  powerState
                                  );

                  action = MarkPending;
                  break;

               default:

                  action = SkipRequest;
                  break;
               }
         }
      }

   switch (action)
      {
      case CompleteRequest:
         Irp->IoStatus.Status = status;
         Irp->IoStatus.Information = 0;

         SmartcardReleaseRemoveLock(smartcardExtension);
         PoStartNextPowerIrp(Irp);
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         break;

      case MarkPending:
         // initialize the event we need in the completion function
         KeInitializeEvent(&event,
                           NotificationEvent,
                           FALSE);
         // request the device power irp
         status = PoRequestPowerIrp (DeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     SCCMN50M_SystemPowerCompletion,
                                     &event,
                                     NULL);
         ASSERT(status == STATUS_PENDING);
         if (status == STATUS_PENDING)
            {
            // wait until the device power irp completed
            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            SmartcardReleaseRemoveLock(smartcardExtension);

            if (powerState.SystemState == PowerSystemWorking)
               {
               PoSetPowerState (DeviceObject,
                                SystemPowerState,
                                powerState);
               }

            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(AttachedDeviceObject, Irp);

            }
         else
            {
            SmartcardReleaseRemoveLock(smartcardExtension);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

         break;

      case SkipRequest:
         SmartcardReleaseRemoveLock(smartcardExtension);
         PoStartNextPowerIrp(Irp);
         IoSkipCurrentIrpStackLocation(Irp);
         status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

      case WaitForCompletion:
         status = PoCallDriver(AttachedDeviceObject, Irp);
         break;

      default:
         ASSERT(FALSE);
         SmartcardReleaseRemoveLock(smartcardExtension);
         break;
      }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Power: Exit %lx\n",
                  DRIVER_NAME,
                  status)
                 );

   return status;
}

/*****************************************************************************
Routine Description:

    This routine is called by the I/O system when the device is opened or closed.

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_SUCCESS.

*****************************************************************************/
NTSTATUS
SCCMN50M_CreateClose(
                    IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp
                    )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
   NTSTATUS status = STATUS_SUCCESS;

   if (irpStack->MajorFunction == IRP_MJ_CREATE)
      {

      if (status != STATUS_SUCCESS)
         {
         status = STATUS_DEVICE_REMOVED;
         }
      else
         {

         LARGE_INTEGER timeout;

         timeout.QuadPart = 0;

         // test if the device has been opened already
         status = KeWaitForSingleObject(
                                       &deviceExtension->ReaderClosed,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       &timeout
                                       );

         if (status == STATUS_SUCCESS)
            {
            status = SmartcardAcquireRemoveLock(
                                               &deviceExtension->SmartcardExtension
                                               );

            KeClearEvent(&deviceExtension->ReaderClosed);
            SmartcardDebug(
                          DEBUG_DRIVER,
                          ("%s!CreateClose: Open\n",
                           DRIVER_NAME)
                          );

            }
         else
            {

            // the device is already in use
            status = STATUS_UNSUCCESSFUL;
            }
         }

      }
   else
      {

      SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!CreateClose: Close\n",
                     DRIVER_NAME)
                    );

      SmartcardReleaseRemoveLock(&deviceExtension->SmartcardExtension);
      KeSetEvent(&deviceExtension->ReaderClosed, 0, FALSE);
      }

   Irp->IoStatus.Status = status;
   Irp->IoStatus.Information = 0;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
   return status;
}

/*****************************************************************************
Routine Description:

    This routine is called by the I/O system
    when the irp should be cancelled

Arguments:

    DeviceObject    - Pointer to device object for this miniport
    Irp             - IRP involved.

Return Value:

    STATUS_CANCELLED

*****************************************************************************/
NTSTATUS
SCCMN50M_Cancel(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp
               )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Cancel: Enter\n",
                  DRIVER_NAME)
                 );

   ASSERT(Irp == smartcardExtension->OsData->NotificationIrp);

   IoReleaseCancelSpinLock(
                          Irp->CancelIrql
                          );

   SCCMN50M_CompleteCardTracking(smartcardExtension);

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Cancel: Exit\n",
                  DRIVER_NAME)
                 );

   return STATUS_CANCELLED;
}

/*****************************************************************************
Routine Description:

    This routine is called when the calling application terminates.
    We can actually only have the notification irp that we have to cancel.


Arguments:



Return Value:

*****************************************************************************/
NTSTATUS
SCCMN50M_Cleanup(
                IN PDEVICE_OBJECT DeviceObject,
                IN PIRP Irp
                )
{
   PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension = &deviceExtension->SmartcardExtension;
   NTSTATUS status = STATUS_SUCCESS;
   BOOLEAN fCancelIrp = FALSE;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Cleanup: Enter\n",
                  DRIVER_NAME)
                 );


   if (Irp != smartcardExtension->OsData->NotificationIrp)
      fCancelIrp = TRUE;


   // We need to complete the notification irp
   SCCMN50M_CompleteCardTracking(smartcardExtension);

   if (fCancelIrp == TRUE)
      {
      SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!Cleanup: Completing IRP %lx\n",
                     DRIVER_NAME,
                     Irp)
                    );

      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = STATUS_SUCCESS;

      IoCompleteRequest(
                       Irp,
                       IO_NO_INCREMENT
                       );
      }

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!Cleanup: Exit\n",
                  DRIVER_NAME)
                 );

   return STATUS_SUCCESS;
}

/*****************************************************************************
Routine Description:
    Remove the device from the system.



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_RemoveDevice(
                     PDEVICE_OBJECT DeviceObject
                     )
{
   PDEVICE_EXTENSION deviceExtension;
   PSMARTCARD_EXTENSION smartcardExtension;
   NTSTATUS status;

   PAGED_CODE();

   if (DeviceObject == NULL)
      {

      return;
      }

   deviceExtension = DeviceObject->DeviceExtension;
   smartcardExtension = &deviceExtension->SmartcardExtension;

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!RemoveDevice: Enter\n",
                   DRIVER_NAME)
                 );

   if (smartcardExtension->OsData)
      {
      // complete pending card tracking requests (if any)
      SCCMN50M_CompleteCardTracking(smartcardExtension);
      ASSERT(smartcardExtension->OsData->NotificationIrp == NULL);
      }

   // Wait until we can safely unload the device
   SmartcardReleaseRemoveLockAndWait(smartcardExtension);

   ASSERT(deviceExtension->DeviceInstance < MAXIMUM_SMARTCARD_READERS);
   ASSERT(DeviceSlot[deviceExtension->DeviceInstance] == TRUE);

   // Mark this slot as available
   DeviceSlot[deviceExtension->DeviceInstance] = FALSE;

   SCCMN50M_StopDevice(deviceExtension);

   if (ATTACHED_DEVICE_OBJECT)
      {

      IoDetachDevice(ATTACHED_DEVICE_OBJECT);
      }

   if (deviceExtension->PnPDeviceName.Buffer != NULL)
      {

      RtlFreeUnicodeString(&deviceExtension->PnPDeviceName);
      }

   if (smartcardExtension->OsData != NULL)
      {

      SmartcardExit(smartcardExtension);
      }

   if (smartcardExtension->ReaderExtension != NULL)
      {

      ExFreePool(smartcardExtension->ReaderExtension);
      }

   IoDeleteDevice(DeviceObject);

   SmartcardDebug(
                 DEBUG_TRACE,
                 ( "%s!RemoveDevice: Exit\n",
                   DRIVER_NAME)
                 );
}

/*****************************************************************************
Routine Description:
    The driver unload routine.  This is called by the I/O system
    when the device is unloaded from memory.

Arguments:
    DriverObject - Pointer to driver object created by system.

Return Value:
    STATUS_SUCCESS.

*****************************************************************************/
VOID
SCCMN50M_DriverUnload(
                     IN PDRIVER_OBJECT DriverObject
                     )
{
   PAGED_CODE();

   SmartcardDebug(
                 DEBUG_TRACE,
                 ("%s!DriverUnload\n",
                  DRIVER_NAME)
                 );
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID
SCCMN50M_CompleteCardTracking(
                             IN PSMARTCARD_EXTENSION SmartcardExtension
                             )
{
   KIRQL ioIrql, keIrql;
   PIRP notificationIrp;

   IoAcquireCancelSpinLock(&ioIrql);
   KeAcquireSpinLock(
                    &SmartcardExtension->OsData->SpinLock,
                    &keIrql
                    );

   notificationIrp = SmartcardExtension->OsData->NotificationIrp;
   SmartcardExtension->OsData->NotificationIrp = NULL;

   KeReleaseSpinLock(
                    &SmartcardExtension->OsData->SpinLock,
                    keIrql
                    );

   if (notificationIrp)
      {
      IoSetCancelRoutine(
                        notificationIrp,
                        NULL
                        );
      }

   IoReleaseCancelSpinLock(ioIrql);

   if (notificationIrp)
      {

      //    finish the request
      if (notificationIrp->Cancel)
         {
         notificationIrp->IoStatus.Status = STATUS_CANCELLED;
         }
      else
         {
         notificationIrp->IoStatus.Status = STATUS_SUCCESS;
         }

      SmartcardDebug(
                    DEBUG_DRIVER,
                    ("%s!CompleteCardTracking: Completing NotificationIrp %lxh IoStatus=%lxh\n",
                     DRIVER_NAME,
                     notificationIrp,
                     notificationIrp->IoStatus.Status
                    )
                    );
      notificationIrp->IoStatus.Information = 0;

      IoCompleteRequest(
                       notificationIrp,
                       IO_NO_INCREMENT
                       );
      }
}

/*****************************************************************************
* History:
* $Log: sccmnt5.c $
* Revision 1.7  2001/01/22 08:39:42  WFrischauf
* No comment given
*
* Revision 1.6  2000/09/25 10:46:24  WFrischauf
* No comment given
*
* Revision 1.5  2000/08/24 09:05:45  TBruendl
* No comment given
*
* Revision 1.4  2000/08/14 12:41:06  TBruendl
* bug fix in CreateDevice
*
* Revision 1.3  2000/07/28 09:24:15  TBruendl
* Changes for OMNIKEY on Whistler CD
*
* Revision 1.6  2000/03/03 09:50:51  TBruendl
* No comment given
*
* Revision 1.5  2000/03/01 09:32:07  TBruendl
* R02.20.0
*
* Revision 1.4  1999/12/13 07:57:18  TBruendl
* bug fixes for hiberantion tests of MS test suite
*
* Revision 1.3  1999/11/04 07:53:24  WFrischauf
* bug fixes due to error reports 2 - 7
*
* Revision 1.2  1999/06/10 09:03:59  TBruendl
* No comment given
*
* Revision 1.1  1999/02/02 13:34:41  TBruendl
* This is the first release (R01.00) of the IFD handler for CardMan running under NT5.0.
*
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmn50m\pcsc_cm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmapiifd/sw/sccmn50m.ms/rcs/pcsc_cm.h $
* $Revision: 1.1 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright (c) 1996-99 Utimaco Safeware AG
******************************************************************************/

#ifndef _INC_PCSC_CM
#define _INC_PCSC_CM

/*****************************************************************************/
/** includes                                                                **/
/*****************************************************************************/

#include <winsmcrd.h>
#include <devioctl.h>

/*****************************************************************************/
/** constants                                                               **/
/*****************************************************************************/

#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
#define CM_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED_OLD       SCARD_CTL_CODE (0x8100)

#define CM_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
#define CM_IOCTL_GET_FW_VERSION_OLD                   SCARD_CTL_CODE (0x8101)

// #define CM_SPE_SECURE_PIN_ENTRY                    SCARD_CTL_CODE (0x8102)
//#define CM_IOCTL_IS_SPE_SUPPORTED                     SCARD_CTL_CODE (3003)
//#define CM_IOCTL_IS_SPE_SUPPORTED_OLD                 SCARD_CTL_CODE (0x8103)

#define CM_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)

#define CM_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
#define CM_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
#define CM_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
#define CM_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
#define CM_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)

#define CM_IOCTL_SET_READER_38400_BAUD                SCARD_CTL_CODE (3020)
#define CM_IOCTL_SET_READER_9600_BAUD                 SCARD_CTL_CODE (3021)

#define CM_IOCTL_OPEN_CT_INTERFACE                    SCARD_CTL_CODE (3022)
#define CM_IOCTL_CLOSE_CT_INTERFACE                   SCARD_CTL_CODE (3023)
#define CM_IOCTL_GET_CT_STATE                         SCARD_CTL_CODE (3024)




//****************************************************************************
//* SYNCHRONOUS SMART CARDS
//****************************************************************************
#define SCARD_RESET_LINE_HIGH      0x00000001
#define SCARD_RESET_LINE_LOW       0x00000000

#define SCARD_PROTOCOL_2WBP        0x00000001
#define SCARD_PROTOCOL_3WBP        0x00000002

//#define CLOCK_FORDCED_2WBP         0x00000040

//----------------------------------------------------------------------------
// structure for "CM_IOCTL_SET_SYNC_PARAMETERS" IO-Control (CrasControl)
//----------------------------------------------------------------------------
#ifndef BOOL
   #define BOOL unsigned int
#endif

typedef struct _SYNC_PARAMETERS {
   ULONG  ulProtocol;
   ULONG  ulStateResetLineWhileReading;
   ULONG  ulStateResetLineWhileWriting;
   ULONG  ulWriteDummyClocks;
   ULONG  ulHeaderLen;
   BOOL   fCardResetRequested;
   BOOL   fCardPowerRequested;
} SYNC_PARAMETERS, *PSYNC_PARAMETERS;


//----------------------------------------------------------------------------
//  structure for CM_IOCTL_2WBP_TRANSFER and  CM_IOCTL_3WBP_TRANSFER
//  IO-Control (CRASControl)
//----------------------------------------------------------------------------
typedef struct _SYNC_TRANSFER
{
   ULONG ulSyncBitsToWrite;
   ULONG ulSyncBitsToRead;
}SYNC_TRANSFER, *PSYNC_TRANSFER;

#endif /* _INC_PCSC_CM */


/*****************************************************************************
* History:
* $Log: pcsc_cm.h $
* Revision 1.1  2000/03/29 06:07:43  TBruendl
* No comment given
*
* Revision 1.10  2000/02/09 14:59:54  WFrischauf
* No comment given
*
* Revision 1.1  2000/02/03 07:50:28  TBruendl
* new IOCTLs : ENABEL_CT_INTERFACE and DISABLE_CT_INTERFACE
*
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmusbm\scusbsyn.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbsyn.c $
* $Revision: 1.3 $
*-----------------------------------------------------------------------------
* $Author: TBruendl $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/



#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "sccmusbm.h"




/*****************************************************************************
Routine Description: Powers a synchronous card and reads the ATR

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_PowerOnSynchronousCard  (
                              IN  PSMARTCARD_EXTENSION smartcardExtension,
                              IN  PUCHAR pbATR,
                              OUT PULONG pulATRLength
                              )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abMaxAtrBuffer[SCARD_ATR_LENGTH];
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR          bResetMode;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnSynchronousCard: Enter\n",DRIVER_NAME));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // in case of warm reset we have to power off the card first
   if (smartcardExtension->MinorIoControlCode != SCARD_COLD_RESET)
      {
      status = CMUSB_PowerOffCard (smartcardExtension );
      if (status != STATUS_SUCCESS)
         {
         // if we can't turn off power there must be a serious error
         goto ExitPowerOnSynchronousCard;
         }
      }

   // set card parameters
   smartcardExtension->ReaderExtension->CardParameters.bBaudRate = 0;
   smartcardExtension->ReaderExtension->CardParameters.bCardType = CMUSB_SMARTCARD_SYNCHRONOUS;
   smartcardExtension->ReaderExtension->CardParameters.bStopBits = 0;

   status = CMUSB_SetCardParameters (deviceObject,
                                     smartcardExtension->ReaderExtension->CardParameters.bCardType,
                                     smartcardExtension->ReaderExtension->CardParameters.bBaudRate,
                                     smartcardExtension->ReaderExtension->CardParameters.bStopBits);
   if (status != STATUS_SUCCESS)
      {
      // if we can't set the card parameters there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   RtlFillMemory((PVOID)abMaxAtrBuffer,
                 sizeof(abMaxAtrBuffer),
                 0x00);

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitPowerOnSynchronousCard;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      status = STATUS_NO_MEDIA;
      goto ExitPowerOnSynchronousCard;
      }


   // issue power on command
   // according to WZ nothing is sent back
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x10,                    //bRequest,
                          SMARTCARD_COLD_RESET,    //bValueLo,
                          0x00,                    //bValueHi,
                          0x00,                    //bIndexLo,
                          0x00                     //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't issue the power on command there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }


   // build control code for ATR
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 1,0,0,0);
   abSendBuffer[1]=CMUSB_CalcSynchControl(1,1,0,0, 1,0,0,0);
   abSendBuffer[2]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   // fill memory so that we can discard first byte
   RtlFillMemory((PVOID)&abSendBuffer[3],5,abSendBuffer[2]);

   // now get 4 bytes ATR -> 32 bytes to send
   abSendBuffer[8]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[9],31,abSendBuffer[8]);

   //now set clock to low to finish operation
   //and of course additional fill bytes
   abSendBuffer[40]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[41],7,abSendBuffer[40]);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 48;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write ATR command there must be a serious error
      if (status == STATUS_DEVICE_DATA_ERROR)
         {
         //error mapping necessary because there are CardManUSB
         //which have no support for synchronous cards
         status = STATUS_UNRECOGNIZED_MEDIA;
         }
      goto ExitPowerOnSynchronousCard;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitPowerOnSynchronousCard;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the ATR -> there must be a serious error
      goto ExitPowerOnSynchronousCard;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=6)
      {
      // 48 bytes sent but not 6 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitPowerOnSynchronousCard;
      }

   // now bytes 1-4 in SmartcardReply.Buffer should be ATR
   SmartcardDebug(DEBUG_ATR,
                  ("%s!ATR = %02x %02x %02x %02x\n",DRIVER_NAME,
                   smartcardExtension->SmartcardReply.Buffer[1],
                   smartcardExtension->SmartcardReply.Buffer[2],
                   smartcardExtension->SmartcardReply.Buffer[3],
                   smartcardExtension->SmartcardReply.Buffer[4]));

   // check if ATR != 0xFF -> synchronous card
   if (smartcardExtension->SmartcardReply.Buffer[1]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[2]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[3]==0xFF &&
       smartcardExtension->SmartcardReply.Buffer[4]==0xFF )
      {
      status = STATUS_UNRECOGNIZED_MEDIA;
      *pulATRLength = 0;
      goto ExitPowerOnSynchronousCard;
      }

   //it seems we have a synchronous smart card and a valid ATR
   //lets set the variables
   smartcardExtension->ReaderExtension->fRawModeNecessary = TRUE;
   *pulATRLength = 4;
   RtlCopyBytes((PVOID) pbATR,
                (PVOID) &(smartcardExtension->SmartcardReply.Buffer[1]),
                *pulATRLength );



   ExitPowerOnSynchronousCard:

   if (status!=STATUS_SUCCESS)
      {
      // turn off VCC again
      CMUSB_PowerOffCard (smartcardExtension );
      // ignor status
      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!PowerOnSynchronousCard: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Data transfer to synchronous cards SLE 4442/4432

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_Transmit2WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   PCHAR          pbInData;
   ULONG          ulBytesToRead;
   ULONG          ulBitsToRead;
   ULONG          ulBytesToReadThisStep;
   ULONG          ulBytesRead;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   int            i;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit2WBP: Enter\n",DRIVER_NAME));


   deviceObject = smartcardExtension->OsData->DeviceObject;

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit2WBP;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitTransmit2WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit2WBP;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      // it is not sure, which error messages are accepted
      // status = STATUS_NO_MEDIA_IN_DEVICE;
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitTransmit2WBP;
      }



   pbInData       = smartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToRead   = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);
//   ulBitsToWrite  = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
//   ulBytesToWrite = ulBitsToWrite/8;

   if (smartcardExtension->IoRequest.ReplyBufferLength  < ulBytesToRead)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit2WBP;
      }


   // send command
   status=CMUSB_SendCommand2WBP(smartcardExtension, pbInData);
   if (status != STATUS_SUCCESS)
      {
      // if we can't send the command -> proceeding is sensless
      goto ExitTransmit2WBP;
      }


   // now we have to differenciate, wheter card is in
   // outgoing data mode (after read command) or
   // in processing mode (after write/erase command)
   switch (*pbInData)
      {
      case SLE4442_READ:
      case SLE4442_READ_PROT_MEM:
      case SLE4442_READ_SEC_MEM:
         // outgoing data mode

         //now read data
         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         //read data in 6 byte packages
         ulBytesRead=0;
         do
            {
            if ((ulBytesToRead - ulBytesRead) > ATTR_MAX_IFSD_SYNCHRON_USB/8)
               ulBytesToReadThisStep = ATTR_MAX_IFSD_SYNCHRON_USB/8;
            else
               ulBytesToReadThisStep = ulBytesToRead - ulBytesRead;

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ulBytesToReadThisStep*8;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit2WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit2WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit2WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ulBytesToReadThisStep)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit2WBP;
               }


            RtlCopyBytes((PVOID) &(smartcardExtension->IoRequest.ReplyBuffer[ulBytesRead]),
                         (PVOID) smartcardExtension->SmartcardReply.Buffer,
                         smartcardExtension->SmartcardReply.BufferLength);

            ulBytesRead+=smartcardExtension->SmartcardReply.BufferLength;
            }
         while ((status == STATUS_SUCCESS) && (ulBytesToRead > ulBytesRead));
         *(smartcardExtension->IoRequest.Information)=ulBytesRead;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit2WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly

         break;
      case SLE4442_WRITE:
      case SLE4442_WRITE_PROT_MEM:
      case SLE4442_COMPARE_PIN:
      case SLE4442_UPDATE_SEC_MEM:
         // processing mode

         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         do
            {

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ATTR_MAX_IFSD_SYNCHRON_USB;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit2WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit2WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit2WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ATTR_MAX_IFSD_SYNCHRON_USB/8)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit2WBP;
               }

            /* not necessary this way, check last byte only
            ulReplySum=0;
            for (i=0;i<(int)smartcardExtension->SmartcardReply.BufferLength;i++)
               {
               ulReplySum+=smartcardExtension->SmartcardReply.Buffer[i];
               }
            */
            }
         while ((status == STATUS_SUCCESS) &&
                (smartcardExtension->SmartcardReply.Buffer[smartcardExtension->SmartcardReply.BufferLength-1]==0));
         *(smartcardExtension->IoRequest.Information)=0;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit2WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly


         break;
      default:
         // should not happen
         status=STATUS_ILLEGAL_INSTRUCTION;
         goto ExitTransmit2WBP;
      }

   ExitTransmit2WBP:


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit2WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Transmits a command (3 Bytes) to a SLE 4442/4432

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_SendCommand2WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR*         pByte;
   UCHAR          bValue;
   int            i,j;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand2WBP: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SendCommand2WBP: 4442 Command = %02x %02x %02x\n",DRIVER_NAME,
                   pbCommandData[0],
                   pbCommandData[1],
                   pbCommandData[2]));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // build control code for command to send
   // command is in first 3 Bytes of pbInData
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   abSendBuffer[1]=CMUSB_CalcSynchControl(0,0,1,1, 0,1,1,1);
   abSendBuffer[2]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,0);

   pByte=&abSendBuffer[3];
   for (j=0;j<3;j++)
      {
      for (i=0;i<8;i++)
         {
         bValue=(pbCommandData[j]&(1<<i));
         *pByte=CMUSB_CalcSynchControl(0,0,1,bValue, 0,1,1,bValue);
         pByte++;
         }
      }
   abSendBuffer[27]=CMUSB_CalcSynchControl(0,0,1,0, 0,1,1,0);
   abSendBuffer[28]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,0);
   RtlFillMemory((PVOID)&abSendBuffer[29],2,abSendBuffer[28]);
   abSendBuffer[31]=CMUSB_CalcSynchControl(0,1,1,0, 0,1,1,1);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 32;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write command there must be a serious error
      goto ExitSendCommand2WBP;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitSendCommand2WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read there must be a serious error
      goto ExitSendCommand2WBP;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=4)
      {
      // 32 bytes sent but not 4 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitSendCommand2WBP;
      }


   ExitSendCommand2WBP:

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand2WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Data transfer to synchronous cards SLE 4428/4418

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_Transmit3WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   PCHAR          pbInData;
   ULONG          ulBytesToRead;
   ULONG          ulBitsToRead;
   ULONG          ulBytesToReadThisStep;
   ULONG          ulBytesRead;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   int            i;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit3WBP: Enter\n",DRIVER_NAME));


   deviceObject = smartcardExtension->OsData->DeviceObject;

   // resync CardManUSB by reading the status byte
   // still necessary with synchronous cards ???
   smartcardExtension->SmartcardRequest.BufferLength = 0;
   status = CMUSB_WriteP0(deviceObject,
                          0x20,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );

   if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit3WBP;
      }

   smartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitTransmit3WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read the status there must be a serious error
      goto ExitTransmit3WBP;
      }

   // check if card is really inserted
   if (smartcardExtension->SmartcardReply.Buffer[0] == 0x00)
      {
      // it is not sure, which error messages are accepted
      // status = STATUS_NO_MEDIA_IN_DEVICE;
      status = STATUS_UNRECOGNIZED_MEDIA;
      goto ExitTransmit3WBP;
      }



   pbInData       = smartcardExtension->IoRequest.RequestBuffer + sizeof(SYNC_TRANSFER);
   ulBitsToRead   = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToRead;
   ulBytesToRead  = ulBitsToRead/8 + (ulBitsToRead % 8 ? 1 : 0);
//   ulBitsToWrite  = ((PSYNC_TRANSFER)(smartcardExtension->IoRequest.RequestBuffer))->ulSyncBitsToWrite;
//   ulBytesToWrite = ulBitsToWrite/8;

   if (smartcardExtension->IoRequest.ReplyBufferLength  < ulBytesToRead)
      {
      status = STATUS_BUFFER_OVERFLOW;
      goto ExitTransmit3WBP;
      }


   // send command
   status=CMUSB_SendCommand3WBP(smartcardExtension, pbInData);
   if (status != STATUS_SUCCESS)
      {
      // if we can't send the command -> proceeding is useless
      goto ExitTransmit3WBP;
      }


   // now we have to differenciate, wheter card is in
   // outgoing data mode (after read command) or
   // in processing mode (after write/erase command)
   switch (*pbInData & 0x3F)
      {
      case SLE4428_READ:
      case SLE4428_READ_PROT:
         // outgoing data mode

         //now read data
         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         //read data in 6 byte packages
         ulBytesRead=0;
         do
            {
            if ((ulBytesToRead - ulBytesRead) > ATTR_MAX_IFSD_SYNCHRON_USB/8)
               ulBytesToReadThisStep = ATTR_MAX_IFSD_SYNCHRON_USB/8;
            else
               ulBytesToReadThisStep = ulBytesToRead - ulBytesRead;

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ulBytesToReadThisStep*8;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit3WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit3WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit3WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ulBytesToReadThisStep)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit3WBP;
               }


            RtlCopyBytes((PVOID) &(smartcardExtension->IoRequest.ReplyBuffer[ulBytesRead]),
                         (PVOID) smartcardExtension->SmartcardReply.Buffer,
                         smartcardExtension->SmartcardReply.BufferLength);

            ulBytesRead+=smartcardExtension->SmartcardReply.BufferLength;
            }
         while ((status == STATUS_SUCCESS) && (ulBytesToRead > ulBytesRead));
         *(smartcardExtension->IoRequest.Information)=ulBytesRead;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit3WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly

         break;
      case SLE4428_WRITE:
      case SLE4428_WRITE_PROT:
      case SLE4428_COMPARE:
      case SLE4428_SET_COUNTER&0x3F:
      case SLE4428_COMPARE_PIN&0x3F:
         // processing mode

         abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
         RtlFillMemory((PVOID)&abSendBuffer[1],ATTR_MAX_IFSD_SYNCHRON_USB-1,abSendBuffer[0]);

         do
            {

            // now send command type 08 to CardManUSB
            smartcardExtension->SmartcardRequest.BufferLength = ATTR_MAX_IFSD_SYNCHRON_USB;
            RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                         (PVOID) abSendBuffer,
                         smartcardExtension->SmartcardRequest.BufferLength);
            status = CMUSB_WriteP0(deviceObject,
                                   0x08,         //bRequest,
                                   0x00,         //bValueLo,
                                   0x00,         //bValueHi,
                                   0x00,         //bIndexLo,
                                   0x00          //bIndexHi,
                                  );
            if (status != STATUS_SUCCESS)
               {
               // if we can't write command there must be a serious error
               goto ExitTransmit3WBP;
               }

            status = CMUSB_ReadP1(deviceObject);
            if (status == STATUS_DEVICE_DATA_ERROR)
               {
               DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
               goto ExitTransmit3WBP;
               }
            else if (status != STATUS_SUCCESS)
               {
               // if we can't read there must be a serious error
               goto ExitTransmit3WBP;
               }

            if (smartcardExtension->SmartcardReply.BufferLength!=ATTR_MAX_IFSD_SYNCHRON_USB/8)
               {
               // wrong number of bytes read
               // -> something went wrong
               status=STATUS_DEVICE_DATA_ERROR;
               goto ExitTransmit3WBP;
               }

            }
         while ((status == STATUS_SUCCESS) &&
                (smartcardExtension->SmartcardReply.Buffer[smartcardExtension->SmartcardReply.BufferLength-1]==0xFF));
         *(smartcardExtension->IoRequest.Information)=0;

         if (status!=STATUS_SUCCESS)
            {
            goto ExitTransmit3WBP;
            }

         // according to datasheet, clock should be set to low now
         // this is not necessary, because this is done before next command
         // or card is reseted respectivly


         break;
      default:
         // should not happen
         status=STATUS_ILLEGAL_INSTRUCTION;
         goto ExitTransmit3WBP;
      }

   ExitTransmit3WBP:


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!Transmit3WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
Routine Description: Transmits a command (3 Bytes) to a SLE 4428/4418

Arguments:


Return Value:

*****************************************************************************/
NTSTATUS
CMUSB_SendCommand3WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      )
{
   PDEVICE_OBJECT deviceObject;
   NTSTATUS       status = STATUS_SUCCESS;
   NTSTATUS       DebugStatus;
   UCHAR          abSendBuffer[CMUSB_SYNCH_BUFFER_SIZE];
   UCHAR*         pByte;
   UCHAR          bValue;
   int            i,j;


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand3WBP: Enter\n",DRIVER_NAME));

   SmartcardDebug(DEBUG_PROTOCOL,
                  ("%s!SendCommand3WBP: 4442 Command = %02x %02x %02x\n",DRIVER_NAME,
                   pbCommandData[0],
                   pbCommandData[1],
                   pbCommandData[2]));

   deviceObject = smartcardExtension->OsData->DeviceObject;

   // build control code for command to send
   // command is in first 3 Bytes of pbInData
   abSendBuffer[0]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);

   pByte=&abSendBuffer[1];
   for (j=0;j<3;j++)
      {
      for (i=0;i<8;i++)
         {
         bValue=(pbCommandData[j]&(1<<i));
         *pByte=CMUSB_CalcSynchControl(1,0,1,bValue, 1,1,1,bValue);
         pByte++;
         }
      }
   abSendBuffer[25]=CMUSB_CalcSynchControl(1,0,1,0, 0,0,0,0);
   // one additional clock cycle, because
   // first bit is only read back after second clock
   // for write it has no influence
   abSendBuffer[26]=CMUSB_CalcSynchControl(0,0,0,0, 0,1,0,0);
   // fill rest with zeros
   abSendBuffer[27]=CMUSB_CalcSynchControl(0,0,0,0, 0,0,0,0);
   RtlFillMemory((PVOID)&abSendBuffer[28],4,abSendBuffer[27]);

   // now send command type 08 to CardManUSB
   smartcardExtension->SmartcardRequest.BufferLength = 32;
   RtlCopyBytes((PVOID) smartcardExtension->SmartcardRequest.Buffer,
                (PVOID) abSendBuffer,
                smartcardExtension->SmartcardRequest.BufferLength);
   status = CMUSB_WriteP0(deviceObject,
                          0x08,         //bRequest,
                          0x00,         //bValueLo,
                          0x00,         //bValueHi,
                          0x00,         //bIndexLo,
                          0x00          //bIndexHi,
                         );
   if (status != STATUS_SUCCESS)
      {
      // if we can't write command there must be a serious error
      goto ExitSendCommand3WBP;
      }

   status = CMUSB_ReadP1(deviceObject);
   if (status == STATUS_DEVICE_DATA_ERROR)
      {
      DebugStatus = CMUSB_ReadStateAfterP1Stalled(deviceObject);
      goto ExitSendCommand3WBP;
      }
   else if (status != STATUS_SUCCESS)
      {
      // if we can't read there must be a serious error
      goto ExitSendCommand3WBP;
      }

   if (smartcardExtension->SmartcardReply.BufferLength!=4)
      {
      // 32 bytes sent but not 4 bytes received
      // -> something went wrong
      status=STATUS_DEVICE_DATA_ERROR;
      goto ExitSendCommand3WBP;
      }


   ExitSendCommand3WBP:

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!SendCommand3WBP: Exit %lx\n",DRIVER_NAME,status));

   return status;
}


/*****************************************************************************
* History:
* $Log: scusbsyn.c $
* Revision 1.3  2000/08/24 09:04:39  TBruendl
* No comment given
*
* Revision 1.2  2000/07/24 11:35:00  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:16  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmusbm\sccmusbm.h ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/sccmusbm.h $
* $Revision: 1.5 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/

#ifndef CMUSB_INC
   #define CMUSB_INC


/*****************************************************************************
*                         Defines
******************************************************************************/
   #define DRIVER_NAME "CMUSB"
   #define SMARTCARD_POOL_TAG 'CUCS'

   #include "smclib.h"
   #include "pcsc_cm.h"

   #define CARDMAN_USB_DEVICE_NAME  L"\\Device\\CM_2020_"



   #define MAXIMUM_USB_READERS	  10
   #define MAXIMUM_OEM_NAMES	      4


   #define VERSIONMAJOR_CARDMAN_USB  3
   #define VERSIONMINOR_CARDMAN_USB  2
   #define BUILDNUMBER_CARDMAN_USB   1

   #define CM2020_VENDOR_NAME		"OMNIKEY"
   #define CM2020_PRODUCT_NAME	"CardMan 2020"

   #define ATTR_MAX_IFSD_CARDMAN_USB  35
   #define ATTR_MAX_IFSD_SYNCHRON_USB  48


   #define UNKNOWN    0xFFFFFFFF
   #define REMOVED    0x00000001
   #define INSERTED   0x00000002
   #define POWERED    0x00000004



   #define CMUSB_BUFFER_SIZE   300
   #define CMUSB_SYNCH_BUFFER_SIZE   64



// defines for CMUSB_SetCardParameters

   #define CMUSB_SMARTCARD_SYNCHRONOUS       0x80
   #define CMUSB_SMARTCARD_ASYNCHRONOUS      0x00

   #define CMUSB_BAUDRATE_9600               0x01
   #define CMUSB_BAUDRATE_19200              0x02
//#define CMUSB_BAUDRATE_28800              0x03
   #define CMUSB_BAUDRATE_38400              0x04
//#define CMUSB_BAUDRATE_57600              0x06
   #define CMUSB_BAUDRATE_76800              0x08
   #define CMUSB_BAUDRATE_115200             0x0C

   #define CMUSB_FREQUENCY_3_72MHZ           0x00
   #define CMUSB_FREQUENCY_5_12MHZ           0x10

   #define CMUSB_ODD_PARITY                 0x80
   #define CMUSB_EVEN_PARITY                0x00


   #define SMARTCARD_COLD_RESET        0x00
   #define SMARTCARD_WARM_RESET        0x01




   #define DEFAULT_TIMEOUT_P1          1000

// own IOCTLs
//#define CMUSB_IOCTL_CR80S_SAMOS_SET_HIGH_SPEED           SCARD_CTL_CODE (3000)
//#define CMUSB_IOCTL_GET_FW_VERSION                       SCARD_CTL_CODE (3001)
// #define CMUSB_IOCTL_SPE_SECURE_PIN_ENTRY              SCARD_CTL_CODE (0x3102)
//#define CMUSB_IOCTL_IS_SPE_SUPPORTED                     SCARD_CTL_CODE (3003)
//#define CMUSB_IOCTL_READ_DEVICE_DESCRIPTION              SCARD_CTL_CODE (3004)
//#define CMUSB_IOCTL_SET_SYNC_PARAMETERS                  SCARD_CTL_CODE (3010)
//#define CMUSB_IOCTL_2WBP_RESET_CARD                      SCARD_CTL_CODE (3011)
//#define CMUSB_IOCTL_2WBP_TRANSFER                        SCARD_CTL_CODE (3012)
//#define CMUSB_IOCTL_3WBP_TRANSFER                        SCARD_CTL_CODE (3013)
//#define CMUSB_IOCTL_SYNC_CARD_POWERON                    SCARD_CTL_CODE (3014)


   #define SLE4442_WRITE            0x38        /* write without protect bit    */
   #define SLE4442_WRITE_PROT_MEM   0x3C        /* write protection memory      */
   #define SLE4442_READ             0x30        /* read without protect bit     */
   #define SLE4442_READ_PROT_MEM    0x34        /* read protection memory       */
   #define SLE4442_READ_SEC_MEM     0x31        /* read security memory         */
   #define SLE4442_COMPARE_PIN      0x33        /* compare one PIN byte         */
   #define SLE4442_UPDATE_SEC_MEM   0x39        /* update security memory       */

   #define SLE4428_WRITE            0x33        /* write without protect bit     */
   #define SLE4428_WRITE_PROT       0x31        /* write with protect bit        */
   #define SLE4428_READ             0x0E        /* read without protect bit      */
   #define SLE4428_READ_PROT        0x0C        /* read with protect bit         */
   #define SLE4428_COMPARE          0x30        /* compare and write prot. bit   */
   #define SLE4428_SET_COUNTER      0xF2        /* write error counter           */
   #define SLE4428_COMPARE_PIN      0xCD        /* compare one PIN byte          */


   #if DBG


static const PCHAR szIrpMajFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_POWER",
   "IRP_MJ_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CHANGE",
   "IRP_MJ_QUERY_QUOTA",
   "IRP_MJ_SET_QUOTA",
   "IRP_MJ_PNP"
};
//IRP_MJ_MAXIMUM_FUNCTION defined in wdm.h


static const PCHAR szPnpMnFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h

   "IRP_MN_START_DEVICE",
   "IRP_MN_QUERY_REMOVE_DEVICE",
   "IRP_MN_REMOVE_DEVICE",
   "IRP_MN_CANCEL_REMOVE_DEVICE",
   "IRP_MN_STOP_DEVICE",
   "IRP_MN_QUERY_STOP_DEVICE",
   "IRP_MN_CANCEL_STOP_DEVICE",
   "IRP_MN_QUERY_DEVICE_RELATIONS",
   "IRP_MN_QUERY_INTERFACE",
   "IRP_MN_QUERY_CAPABILITIES",
   "IRP_MN_QUERY_RESOURCES",
   "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
   "IRP_MN_QUERY_DEVICE_TEXT",
   "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
   "IRP_MN_READ_CONFIG",
   "IRP_MN_WRITE_CONFIG",
   "IRP_MN_EJECT",
   "IRP_MN_SET_LOCK",
   "IRP_MN_QUERY_ID",
   "IRP_MN_QUERY_PNP_DEVICE_STATE",
   "IRP_MN_QUERY_BUS_INFORMATION",
   "IRP_MN_PAGING_NOTIFICATION"
};

      #define IRP_PNP_MN_FUNCMAX	IRP_MN_PAGING_NOTIFICATION



static const PCHAR szSystemPowerState[] =
{
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

static const PCHAR szDevicePowerState[] =
{
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};




      #define CMUSB_ASSERT( cond ) ASSERT( cond )

      #define CMUSB_StringForDevState( devState )  szDevicePowerState[ devState ]

      #define CMUSB_StringForSysState( sysState )  szSystemPowerState[ sysState ]

      #define CMUSB_StringForPnpMnFunc( mnfunc ) szPnpMnFuncDesc[ mnfunc ]

      #define CMUSB_StringForIrpMjFunc(  mjfunc ) szIrpMajFuncDesc[ mjfunc ]


   #else // if not DBG

// dummy definitions that go away in the retail build

      #define CMUSB_ASSERT( cond )
      #define CMUSB_StringForDevState( devState )
      #define CMUSB_StringForSysState( sysState )
      #define CMUSB_StringForPnpMnFunc( mnfunc )
      #define CMUSB_StringForIrpMjFunc(  mjfunc )


   #endif //DBG

/*****************************************************************************
*                       Types, Structures
******************************************************************************/

// used to track driver-generated io irps for staged read/write processing
typedef struct _CMUSB_RW_CONTEXT
   {
   PURB Urb;
   PDEVICE_OBJECT DeviceObject;
   PIRP  Irp;
   } CMUSB_RW_CONTEXT, *PCMUSB_RW_CONTEXT;


typedef struct _CARD_PARAMETERS
   {
   UCHAR bCardType;
   UCHAR bBaudRate;
   UCHAR bStopBits;
   } CARD_PARAMETERS, *PCARD_PARAMETERS;

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION
   {
   //
   // The dos device name of our smart card reader
   //
   UNICODE_STRING DosDeviceName;

   // The pnp device name of our smart card reader
   UNICODE_STRING PnPDeviceName;

   // Our smart card extension
   SMARTCARD_EXTENSION SmartcardExtension;

   // The current number of io-requests
   LONG IoCount;


   ULONG DeviceInstance;


   KSPIN_LOCK SpinLock;

   // Device object we call when submitting Urbs
   PDEVICE_OBJECT TopOfStackDeviceObject;

   // The bus driver object
   PDEVICE_OBJECT PhysicalDeviceObject;

   DEVICE_POWER_STATE CurrentDevicePowerState;

   // USB configuration handle and ptr for the configuration the
   // device is currently in
   USBD_CONFIGURATION_HANDLE UsbConfigurationHandle;
   PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;


   // ptr to the USB device descriptor
   // for this device
   PUSB_DEVICE_DESCRIPTOR UsbDeviceDescriptor;

   // we support one interface
   // this is a copy of the info structure
   // returned from select_configuration or
   // select_interface
   PUSBD_INTERFACE_INFORMATION UsbInterface;

   //Bus drivers set the appropriate values in this structure in response
   //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
   //alter the capabilities set by the bus driver.
   DEVICE_CAPABILITIES DeviceCapabilities;

   // used to save the currently-being-handled system-requested power irp request
   PIRP PowerIrp;

   // Used to signal that update thread can run
   KEVENT               CanRunUpdateThread;

   // Blocks IOCtls during hibernate mode
   KEVENT               ReaderEnabled;

   // set when PendingIoCount goes to 0; flags device can be removed
   KEVENT RemoveEvent;

   // set when PendingIoCount goes to 1 ( 1st increment was on add device )
   // this indicates no IO requests outstanding, either user, system, or self-staged
   KEVENT NoPendingIoEvent;

   // set to signal driver-generated power request is finished
   KEVENT SelfRequestedPowerIrpEvent;

   KEVENT ReadP1Completed;

   // incremented when device is added and any IO request is received;
   // decremented when any io request is completed or passed on, and when device is removed
   ULONG PendingIoCount;

   // Name buffer for our named Functional device object link
   // The name is generated based on the driver's class GUID
   WCHAR DeviceLinkNameBuffer[ MAXIMUM_FILENAME_LENGTH ];  // MAXIMUM_FILENAME_LENGTH defined in wdm.h

   //device is opened by application (ScardSrv, CT-API)
   LONG lOpenCount;

   // flag set when processing IRP_MN_REMOVE_DEVICE
   BOOLEAN DeviceRemoved;

   // flag set when processing IRP_MN_SURPRISE_REMOVAL
   BOOLEAN DeviceSurpriseRemoval;

   // flag set when driver has answered success to IRP_MN_QUERY_REMOVE_DEVICE
   BOOLEAN RemoveDeviceRequested;

   // flag set when driver has answered success to IRP_MN_QUERY_STOP_DEVICE
   BOOLEAN StopDeviceRequested;

   // flag set when device has been successfully started
   BOOLEAN DeviceStarted;

   // flag set when IRP_MN_WAIT_WAKE is received and we're in a power state
   // where we can signal a wait
   BOOLEAN EnabledForWakeup;

   // used to flag that we're currently handling a self-generated power request
   BOOLEAN  SelfPowerIrp;

   BOOLEAN  fPnPResourceManager;

   // default power state to power down to on self-suspend
   ULONG PowerDownLevel;


   } DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Define the reader specific portion of the smart card extension
//
typedef struct _READER_EXTENSION
   {
   KTIMER  WaitTimer;
   KTIMER  P1Timer;

   // at least one info byte must be received within this timeout
   ULONG   ulTimeoutP1;


   ULONG                ulDeviceInstance;
   ULONG                ulOemNameIndex;
   ULONG                ulOemDeviceInstance;

   UCHAR   T0ReadBuffer [520];
   LONG    T0ReadBuffer_OffsetLastByte;
   LONG    T0ReadBuffer_OffsetLastByteRead;

   // Flag that indicates that the caller requests a power-down or a reset
   BOOLEAN  PowerRequest;

   // Saved card state for hibernation/sleeping modes.
   BOOLEAN CardPresent;

   // Current reader power state.
   //READER_POWER_STATE ReaderPowerState;

   CARD_PARAMETERS     CardParameters;


   BOOLEAN              TimeToTerminateThread;
   BOOLEAN              fThreadTerminated;

   KMUTEX               CardManIOMutex;

   // Handle of the UpdateCurrentState thread
   PVOID                ThreadObjectPointer;

   ULONG                ulOldCardState;
   ULONG                ulNewCardState;
   BOOLEAN              fRawModeNecessary;
   ULONG                ulFWVersion;
   BOOLEAN              fSPESupported;
   BOOLEAN              fInverseAtr;
   UCHAR                abDeviceDescription[42];
   BOOLEAN              fP1Stalled;

   } READER_EXTENSION, *PREADER_EXTENSION;



/*****************************************************************************
*                   Function Prototypes
******************************************************************************/
NTSTATUS CMUSB_ResetT0ReadBuffer (
                                 IN PSMARTCARD_EXTENSION smartcardExtension
                                 );

NTSTATUS CMUSB_AbortPipes (
                          IN PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS CMUSB_AsyncReadWrite_Complete (
                                       IN PDEVICE_OBJECT DeviceObject,
                                       IN PIRP Irp,
                                       IN PVOID Context
                                       );

PURB CMUSB_BuildAsyncRequest (
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP Irp,
                             IN PUSBD_PIPE_INFORMATION pipeInformation
                             );

NTSTATUS CMUSB_CallUSBD (
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PURB Urb
                        );

BOOLEAN CMUSB_CanAcceptIoRequests (
                                  IN PDEVICE_OBJECT DeviceObject
                                  );

NTSTATUS CMUSB_CancelCardTracking (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN PIRP Irp
                                  );



NTSTATUS CMUSB_CardPower (
                         IN PSMARTCARD_EXTENSION pSmartcardExtension
                         );

NTSTATUS CMUSB_CardTracking (
                            PSMARTCARD_EXTENSION SmartcardExtension
                            );

NTSTATUS CMUSB_Cleanup (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN PIRP Irp
                       );


VOID CMUSB_CompleteCardTracking (
                                IN PSMARTCARD_EXTENSION SmartcardExtension
                                );

NTSTATUS CMUSB_ConfigureDevice (
                               IN  PDEVICE_OBJECT DeviceObject
                               );


NTSTATUS CMUSB_CreateClose (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PIRP Irp
                           );

NTSTATUS CMUSB_CreateDeviceObject(
                                 IN PDRIVER_OBJECT DriverObject,
                                 IN PDEVICE_OBJECT PhysicalDeviceObject,
                                 IN PDEVICE_OBJECT *DeviceObject
                                 );

VOID CMUSB_DecrementIoCount (
                            IN PDEVICE_OBJECT DeviceObject
                            );

NTSTATUS CMUSB_GetFWVersion (
                            IN PSMARTCARD_EXTENSION smartcardExtension
                            );

VOID CMUSB_IncrementIoCount (
                            IN PDEVICE_OBJECT DeviceObject
                            );

VOID CMUSB_InitializeSmartcardExtension (
                                        IN PSMARTCARD_EXTENSION pSmartcardExtension
                                        ) ;
VOID CMUSB_InverseBuffer (
                         IN PUCHAR pbBuffer,
                         IN ULONG  ulBufferSize
                         ) ;

NTSTATUS CMUSB_IoCtlVendor (
                           PSMARTCARD_EXTENSION SmartcardExtension
                           );

NTSTATUS CMUSB_IrpCompletionRoutine (
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP Irp,
                                    IN PVOID Context
                                    );

NTSTATUS CMUSB_IsSPESupported (
                              IN PSMARTCARD_EXTENSION smartcardExtension
                              );

NTSTATUS CMUSB_PnPAddDevice (
                            IN PDRIVER_OBJECT DriverObject,
                            IN PDEVICE_OBJECT PhysicalDeviceObject
                            );

NTSTATUS CMUSB_PoSelfRequestCompletion (
                                       IN PDEVICE_OBJECT       DeviceObject,
                                       IN UCHAR                MinorFunction,
                                       IN POWER_STATE          PowerState,
                                       IN PVOID                Context,
                                       IN PIO_STATUS_BLOCK     IoStatus
                                       );

NTSTATUS CMUSB_PoRequestCompletion(
                                  IN PDEVICE_OBJECT       DeviceObject,
                                  IN UCHAR                MinorFunction,
                                  IN POWER_STATE          PowerState,
                                  IN PVOID                Context,
                                  IN PIO_STATUS_BLOCK     IoStatus
                                  );

NTSTATUS CMUSB_PowerIrp_Complete (
                                 IN PDEVICE_OBJECT NullDeviceObject,
                                 IN PIRP Irp,
                                 IN PVOID Context
                                 );

NTSTATUS CMUSB_PowerOffCard (
                            IN PSMARTCARD_EXTENSION smartcardExtension
                            );

NTSTATUS CMUSB_PowerOnCard (
                           IN  PSMARTCARD_EXTENSION smartcardExtension,
                           IN  PUCHAR pbATR,
                           OUT PULONG pulATRLength
                           );
NTSTATUS CMUSB_ProcessIOCTL (
                            IN PDEVICE_OBJECT DeviceObject,
                            IN PIRP Irp
                            );

NTSTATUS CMUSB_ProcessPowerIrp (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PIRP           Irp
                               );

NTSTATUS CMUSB_ProcessPnPIrp (
                             IN PDEVICE_OBJECT DeviceObject,
                             IN PIRP           Irp
                             );

NTSTATUS CMUSB_ProcessSysControlIrp (
                                    IN PDEVICE_OBJECT DeviceObject,
                                    IN PIRP           Irp
                                    );

NTSTATUS CMUSB_ReadT0 (
                      IN PSMARTCARD_EXTENSION smartcardExtension
                      );
NTSTATUS CMUSB_ReadP1 (
                      IN PDEVICE_OBJECT DeviceObject
                      );
NTSTATUS CMUSB_ReadP1_T0 (
                         IN PDEVICE_OBJECT DeviceObject
                         );
NTSTATUS CMUSB_ReadP0 (
                      IN PDEVICE_OBJECT DeviceObject
                      );

NTSTATUS CMUSB_ReadStateAfterP1Stalled(
                                      IN PDEVICE_OBJECT DeviceObject
                                      );

NTSTATUS CMUSB_ResetPipe(
                        IN PDEVICE_OBJECT DeviceObject,
                        IN PUSBD_PIPE_INFORMATION PipeInfo
                        );

NTSTATUS CMUSB_QueryCapabilities (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PDEVICE_CAPABILITIES DeviceCapabilities
                                 );

NTSTATUS CMUSB_ReadDeviceDescription (
                                     IN PSMARTCARD_EXTENSION smartcardExtension
                                     );

NTSTATUS CMUSB_RemoveDevice (
                            IN  PDEVICE_OBJECT DeviceObject
                            );

NTSTATUS CMUSB_SelfSuspendOrActivate (
                                     IN PDEVICE_OBJECT DeviceObject,
                                     IN BOOLEAN fSuspend
                                     );

NTSTATUS CMUSB_SelectInterface (
                               IN PDEVICE_OBJECT DeviceObject,
                               IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
                               );

NTSTATUS CMUSB_SelfRequestPowerIrp (
                                   IN PDEVICE_OBJECT DeviceObject,
                                   IN POWER_STATE PowerState
                                   );

BOOLEAN CMUSB_SetDevicePowerState (
                                  IN PDEVICE_OBJECT DeviceObject,
                                  IN DEVICE_POWER_STATE DeviceState
                                  );

NTSTATUS CMUSB_SetCardParameters (
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN UCHAR bCardType,
                                 IN UCHAR bBaudRate,
                                 IN UCHAR bStopBits
                                 );

NTSTATUS CMUSB_SetHighSpeed_CR80S_SAMOS (
                                        IN PSMARTCARD_EXTENSION smartcardExtension
                                        );

NTSTATUS CMUSB_SetProtocol (
                           PSMARTCARD_EXTENSION pSmartcardExtension
                           );

NTSTATUS CMUSB_SetReader_9600Baud (
                                  IN PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMUSB_SetReader_38400Baud (
                                   IN PSMARTCARD_EXTENSION SmartcardExtension
                                   );

NTSTATUS CMUSB_SetVendorAndIfdName(
                                  IN  PDEVICE_OBJECT PhysicalDeviceObject,
                                  IN  PSMARTCARD_EXTENSION SmartcardExtension
                                  );

NTSTATUS CMUSB_StartCardTracking (
                                 IN PDEVICE_OBJECT deviceObject
                                 );

NTSTATUS CMUSB_StartDevice (
                           IN  PDEVICE_OBJECT DeviceObject
                           );

VOID CMUSB_StopCardTracking (
                            IN PDEVICE_OBJECT deviceObject
                            );

NTSTATUS CMUSB_StopDevice (
                          IN  PDEVICE_OBJECT DeviceObject
                          );

NTSTATUS CMUSB_Transmit (
                        IN PSMARTCARD_EXTENSION smartcardExtension
                        );

NTSTATUS CMUSB_TransmitT0 (
                          IN PSMARTCARD_EXTENSION smartcardExtension
                          );

NTSTATUS CMUSB_TransmitT1 (
                          IN PSMARTCARD_EXTENSION smartcardExtension
                          );

VOID CMUSB_Unload (
                  IN PDRIVER_OBJECT DriverObject
                  );

VOID CMUSB_UpdateCurrentStateThread (
                                    IN PVOID Context
                                    );

NTSTATUS CMUSB_UpdateCurrentState(
                                 IN PDEVICE_OBJECT DeviceObject
                                 );

NTSTATUS CMUSB_Wait (
                    IN ULONG ulMilliseconds
                    );


NTSTATUS CMUSB_WriteP0 (
                       IN PDEVICE_OBJECT DeviceObject,
                       IN UCHAR bRequest,
                       IN UCHAR bValueLo,
                       IN UCHAR bValueHi,
                       IN UCHAR bIndexLo,
                       IN UCHAR bIndexHi
                       );


VOID CMUSB_CheckAtrModified (
                            IN OUT PUCHAR pbBuffer,
                            IN ULONG  ulBufferSize
                            );

// ----------------------------------------------------------------
// SYNCHRONOUS SMART CARDS
// ----------------------------------------------------------------

NTSTATUS
CMUSB_PowerOnSynchronousCard  (
                              IN  PSMARTCARD_EXTENSION smartcardExtension,
                              IN  PUCHAR pbATR,
                              OUT PULONG pulATRLength
                              );

NTSTATUS
CMUSB_Transmit2WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    );

NTSTATUS
CMUSB_Transmit3WBP  (
                    IN  PSMARTCARD_EXTENSION smartcardExtension
                    );

NTSTATUS
CMUSB_SendCommand2WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      );

NTSTATUS
CMUSB_SendCommand3WBP (
                      IN  PSMARTCARD_EXTENSION smartcardExtension,
                      IN  PUCHAR pbCommandData
                      );
__inline UCHAR
CMUSB_CalcSynchControl  (
                        IN UCHAR bStateReset1,         //0 -> low
                        IN UCHAR bStateClock1,         //0 -> low
                        IN UCHAR bStateDirection1,     //0 -> from card to pc
                        IN UCHAR bStateIO1,            //0 -> low
                        IN UCHAR bStateReset2,         //0 -> low
                        IN UCHAR bStateClock2,         //0 -> low
                        IN UCHAR bStateDirection2,     //0 -> from card to pc
                        IN UCHAR bStateIO2             //0 -> low
                        )
{
   return((UCHAR)( ((bStateReset1==0)?0:128) + ((bStateClock1==0)?0:64) +
                   ((bStateDirection1==0)?0:32) + ((bStateIO1==0)?0:16) +
                   ((bStateReset2==0)?0:8) + ((bStateClock2==0)?0:4) +
                   ((bStateDirection2==0)?0:2) + ((bStateIO2==0)?0:1) ));
};





#endif  // CMUSBM_INC


/*****************************************************************************
* History:
* $Log: sccmusbm.h $
* Revision 1.5  2000/09/25 13:38:21  WFrischauf
* No comment given
*
* Revision 1.4  2000/08/16 14:35:02  WFrischauf
* No comment given
*
* Revision 1.3  2000/07/24 11:34:57  WFrischauf
* No comment given
*
* Revision 1.1  2000/07/20 11:50:13  WFrischauf
* No comment given
*
*
******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\scmstcs\cbhndlr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) SCM Microsystems, 1998 - 1999
//
//  File:       cbhndlr.h
//
//--------------------------------------------------------------------------

#if !defined( __CB_HANDLER_H__ )
#define __CB_HANDLER_H__

NTSTATUS
CBCardPower(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSetProtocol(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBTransmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBCardTracking(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

VOID
CBUpdateCardState(
	PSMARTCARD_EXTENSION SmartcardExtension,
    ULONG CardState
	);
//
//	LOCAL PROTOTYPES (not part of the callback handler interface )
//
NTSTATUS
CBT0Transmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBT1Transmit(
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBRawTransmit(		
	PSMARTCARD_EXTENSION SmartcardExtension
	);

NTSTATUS
CBSynchronizeSTC(
	PSMARTCARD_EXTENSION SmartcardExtension 
	);

#endif // __CB_HANDLER_H__

//	------------------------------- END OF FILE -------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\smartcrd\sccmusbm\scusbcb.c ===
/*****************************************************************************
@doc            INT EXT
******************************************************************************
* $ProjectName:  $
* $ProjectRevision:  $
*-----------------------------------------------------------------------------
* $Source: z:/pr/cmeu0/sw/sccmusbm.ms/rcs/scusbcb.c $
* $Revision: 1.9 $
*-----------------------------------------------------------------------------
* $Author: WFrischauf $
*-----------------------------------------------------------------------------
* History: see EOF
*-----------------------------------------------------------------------------
*
* Copyright  2000 OMNIKEY AG
******************************************************************************/
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"


#include "sccmusbm.h"


ULONG dataRatesSupported[]    = { 9600, 19200, 38400, 76800, 115200};
ULONG CLKFrequenciesSupported[] = {3571};


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_StartCardTracking(
                                IN PDEVICE_OBJECT DeviceObject
                                )
{
   NTSTATUS NTStatus;
   HANDLE hThread;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   // settings for thread synchronization
   SmartcardExtension->ReaderExtension->TimeToTerminateThread = FALSE;
   SmartcardExtension->ReaderExtension->fThreadTerminated     = FALSE;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartCardTracking: Enter\n",DRIVER_NAME));

   KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

   // create thread for updating current state
   NTStatus = PsCreateSystemThread(&hThread,
                                   THREAD_ALL_ACCESS,
                                   NULL,
                                   NULL,
                                   NULL,
                                   CMUSB_UpdateCurrentStateThread,
                                   DeviceObject);
   if (!NT_ERROR(NTStatus))
      {
      //
      // We've got the thread.  Now get a pointer to it.
      //

      NTStatus = ObReferenceObjectByHandle(hThread,
                                           THREAD_ALL_ACCESS,
                                           NULL,
                                           KernelMode,
                                           &SmartcardExtension->ReaderExtension->ThreadObjectPointer,
                                           NULL);

      if (NT_ERROR(NTStatus))
         {
         SmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;
         }
      else
         {
         //
         // Now that we have a reference to the thread
         // we can simply close the handle.
         //
         ZwClose(hThread);
         }
      }

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!StartCardTracking: -----------------------------------------------------------\n",DRIVER_NAME));
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!StartCardTracking: STARTING THREAD\n",DRIVER_NAME));
   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!StartCardTracking: -----------------------------------------------------------\n",DRIVER_NAME));
   KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                  FALSE);


   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StartCardTracking: Exit %lx\n",DRIVER_NAME,NTStatus));

   return NTStatus;
}




/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_StopCardTracking(
                           IN PDEVICE_OBJECT DeviceObject
                           )
{
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StopCardTracking: Enter\n",DRIVER_NAME));

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   if (SmartcardExtension->ReaderExtension->fThreadTerminated == FALSE)
      {

      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!StopCardTracking: waiting for mutex\n",DRIVER_NAME));

      // kill thread
      KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);

      SmartcardExtension->ReaderExtension->TimeToTerminateThread = TRUE;

      KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

      while (SmartcardExtension->ReaderExtension->fThreadTerminated==FALSE)
         {
         CMUSB_Wait(10);
         }


      }

   SmartcardDebug(DEBUG_TRACE,
                  ("%s!StopCardTracking: Exit\n",DRIVER_NAME));

}

/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_UpdateCurrentStateThread(
                                   IN PVOID Context
                                   )

{
   PDEVICE_OBJECT DeviceObject  = Context;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   NTSTATUS NTStatus,DebugStatus;
   ULONG ulInterval;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;

   KeWaitForSingleObject(&DeviceExtension->CanRunUpdateThread,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

   SmartcardDebug(DEBUG_DRIVER,
                  ("%s!UpdateCurrentStateThread started\n",DRIVER_NAME));

   do
      {
      // every 500 ms  the s NTStatus request is sent
      ulInterval = 500;
      KeWaitForSingleObject(&SmartcardExtension->ReaderExtension->CardManIOMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL);

      if ( SmartcardExtension->ReaderExtension->TimeToTerminateThread )
         {
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!UpdateCurrentStateThread: -----------------------------------------\n",DRIVER_NAME));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!UpdateCurrentStateThread: STOPPING THREAD\n",DRIVER_NAME));
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!UpdateCurrentStateThread: -----------------------------------------\n",DRIVER_NAME));

         KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);
         SmartcardExtension->ReaderExtension->fThreadTerminated = TRUE;
         PsTerminateSystemThread( STATUS_SUCCESS );
         }

      NTStatus = CMUSB_UpdateCurrentState (DeviceObject);
      if (NTStatus == STATUS_DEVICE_DATA_ERROR)
         {
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!setting update interval to 1ms\n",DRIVER_NAME));

         ulInterval = 1;
         }
      else if (NTStatus != STATUS_SUCCESS)
         {
         SmartcardDebug(DEBUG_DRIVER,
                        ("%s!NO STATUS RECEIVED\n",DRIVER_NAME));
         }

      KeReleaseMutex(&SmartcardExtension->ReaderExtension->CardManIOMutex,FALSE);

      CMUSB_Wait (ulInterval);
      }
   while (TRUE);
}



NTSTATUS CMUSB_UpdateCurrentState(
                                 IN PDEVICE_OBJECT DeviceObject
                                 )
{
   NTSTATUS             NTStatus;
   PDEVICE_EXTENSION    DeviceExtension;
   PSMARTCARD_EXTENSION SmartcardExtension;
   BOOLEAN              fCardStateChanged = FALSE;
   ULONG                ulBytesRead;

   DeviceExtension = DeviceObject->DeviceExtension;
   SmartcardExtension = &DeviceExtension->SmartcardExtension;


   SmartcardExtension->SmartcardRequest.BufferLength = 0;
//#if DBG
//      ulDebugLevel = SmartcardGetDebugLevel();
//      SmartcardSetDebugLevel((ULONG)0);
//#endif
   NTStatus = CMUSB_WriteP0(DeviceObject,
                            0x20,         //bRequest,
                            0x00,         //bValueLo,
                            0x00,         //bValueHi,
                            0x00,         //bIndexLo,
                            0x00          //bIndexHi,
                           );
//#if DBG
//      SmartcardSetDebugLevel(ulDebugLevel);
//#endif


   if (NTStatus == STATUS_SUCCESS)
      {
      SmartcardExtension->ReaderExtension->ulTimeoutP1 = DEFAULT_TIMEOUT_P1;
      SmartcardExtension->SmartcardReply.BufferLength = 1;
//#if DBG
//         ulDebugLevel = SmartcardGetDebugLevel();
//         SmartcardSetDebugLevel((ULONG)0);
//#endif
      NTStatus = CMUSB_ReadP1(DeviceObject);
//#if DBG
//         SmartcardSetDebugLevel(ulDebugLevel);
//#endif
      ulBytesRead = SmartcardExtension->SmartcardReply.BufferLength;
      if (NTStatus == STATUS_SUCCESS && ulBytesRead == 1) /* we got the NTStatus information */
         {

         if ((SmartcardExtension->SmartcardReply.Buffer[0] & 0x40) == 0x40)
            {
            if ((SmartcardExtension->SmartcardReply.Buffer[0] & 0x80) == 0x80)
               {
               SmartcardExtension->ReaderExtension->ulNewCardState = POWERED;
               }
            else
               {
               SmartcardExtension->ReaderExtension->ulNewCardState = INSERTED;
               }
            }
         else
            {
            SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
            }

         /*
         SmartcardDebug(DEBUG_DRIVER,
                        ("old %x   ",SmartcardExtension->ReaderExtension->ulOldCardState ));
         SmartcardDebug(DEBUG_DRIVER,
                        ("new %x\n",SmartcardExtension->ReaderExtension->ulNewCardState ));
         */

         if (SmartcardExtension->ReaderExtension->ulNewCardState == INSERTED &&
             SmartcardExtension->ReaderExtension->ulOldCardState == POWERED )
            {
            // card has been removed and reinserted
            SmartcardExtension->ReaderExtension->ulNewCardState = REMOVED;
            }

         if (SmartcardExtension->ReaderExtension->ulNewCardState  == INSERTED &&
             (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN ||
              SmartcardExtension->ReaderExtension->ulOldCardState == REMOVED ))
            {
            // card has been inserted
            SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard inserted\n",DRIVER_NAME));
            fCardStateChanged = TRUE;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


         // state after reset of the PC
         if (SmartcardExtension->ReaderExtension->ulNewCardState == POWERED &&
             SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN    )
            {
            // card has been inserted
            SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard inserted (and powered)\n",DRIVER_NAME));
            fCardStateChanged = TRUE;
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_SWALLOWED;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            }


         if (SmartcardExtension->ReaderExtension->ulNewCardState == REMOVED      &&
             (SmartcardExtension->ReaderExtension->ulOldCardState == UNKNOWN  ||
              SmartcardExtension->ReaderExtension->ulOldCardState == INSERTED ||
              SmartcardExtension->ReaderExtension->ulOldCardState == POWERED    )   )
            {
            // card has been removed
            fCardStateChanged = TRUE;
            SmartcardDebug(DEBUG_DRIVER,( "%s!UpdateCurrentStateThread Smartcard removed\n",DRIVER_NAME));
            SmartcardExtension->ReaderCapabilities.CurrentState = SCARD_ABSENT;
            SmartcardExtension->CardCapabilities.Protocol.Selected = SCARD_PROTOCOL_UNDEFINED;
            SmartcardExtension->CardCapabilities.ATR.Length        = 0;

            RtlFillMemory((PVOID)&SmartcardExtension->ReaderExtension->CardParameters,
                          sizeof(CARD_PARAMETERS),
                          0x00);
            }

         // complete IOCTL_SMARTCARD_IS_ABSENT or IOCTL_SMARTCARD_IS_PRESENT
         if (fCardStateChanged == TRUE &&
             SmartcardExtension->OsData->NotificationIrp != NULL)
            {
            SmartcardDebug(DEBUG_DRIVER,("%s!UpdateCurrentStateThread: completing IRP\n",DRIVER_NAME));
            CMUSB_CompleteCardTracking(SmartcardExtension);
            }

         // save old state
         SmartcardExtension->ReaderExtension->ulOldCardState = SmartcardExtension->ReaderExtension->ulNewCardState;

         }
      }

   return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
VOID CMUSB_CompleteCardTracking(
                               IN PSMARTCARD_EXTENSION SmartcardExtension
                               )
{
   KIRQL ioIrql, keIrql;
   PIRP notificationIrp;

   IoAcquireCancelSpinLock(&ioIrql);
   KeAcquireSpinLock(&SmartcardExtension->OsData->SpinLock, &keIrql);

   notificationIrp = SmartcardExtension->OsData->NotificationIrp;
   SmartcardExtension->OsData->NotificationIrp = NULL;

   KeReleaseSpinLock(&SmartcardExtension->OsData->SpinLock, keIrql);

   if (notificationIrp)
      {
      IoSetCancelRoutine(notificationIrp,NULL);
      }

   IoReleaseCancelSpinLock(ioIrql);

   if (notificationIrp)
      {
      SmartcardDebug(DEBUG_DRIVER,
                     ("%s!CompleteCardTracking: Completing NotificationIrp %lxh\n",DRIVER_NAME,notificationIrp));

      //	finish the request
      if (notificationIrp->Cancel)
         {
         notificationIrp->IoStatus.Status = STATUS_CANCELLED;
         }
      else
         {
         notificationIrp->IoStatus.Status = STATUS_SUCCESS;
         }

      notificationIrp->IoStatus.Information = 0;

      IoCompleteRequest(notificationIrp, IO_NO_INCREMENT);
      }
}



/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************/
NTSTATUS CMUSB_Wait (ULONG ulMilliseconds)
{
   NTSTATUS NTStatus = STATUS_SUCCESS;
   LARGE_INTEGER   WaitTime;

   // -10000 indicates 1ms relativ
   WaitTime = RtlConvertLongToLargeInteger(ulMilliseconds * -10000);
   KeDelayExecutionThread(KernelMode,FALSE,&WaitTime);

   return NTStatus;
}


/*****************************************************************************
Routine Description:



Arguments:



Return Value:

*****************************************************************************